<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The problem of using CompletableFuture in multiple threads and its solution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java 8 has a new CompletableFuture class that allows you to conveniently write asynchronous code. 
 When using the CompletableFuture from several thre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The problem of using CompletableFuture in multiple threads and its solution</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d87/570/a6a/d87570a6ab2f466897dcb5408686c66d.jpg" alt="image" align="right" width="250">  Java 8 has a new <code>CompletableFuture</code> class that allows you to conveniently write asynchronous code. <br>  When using the <code>CompletableFuture</code> from several threads, I was faced with its unobvious behavior, namely that callbacks on it can be executed at all in those threads, as expected.  About this and how I managed to solve the problem - I will tell in this article. <br><br>  I developed an asynchronous, non-blocking single-threaded client to a server that used thread safe data structures.  The tests passed without problems, but the benchmarks sometimes fell with <code>ConcurrentModificationException</code> on the internal structures of the single-threaded client. <br><a name="habracut"></a><br>  Asynchrony in the client was implemented using <code>CompletableFuture</code> , all operations within the client were performed in one thread (hereinafter <code>singleThreadExecutor</code> code). <br><br>  Client code snippet with a <code>get</code> method that is available to users: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   private final Set&lt;CompletableFuture&gt; pendingFutures = Collections.newSetFromMap(new IdentityHashMap&lt;&gt;()); public CompletableFuture&lt;String&gt; get(String key) { CompletableFuture&lt;String&gt; future = new CompletableFuture&lt;&gt;(); //       singleThreadExecutor.execute(() -&gt; { // future     pendingFutures.add(future); future.whenComplete((v, e) -&gt; { // future       pendingFutures.remove(future); }); //            //     future.complete(data);    singleThreadExecutor }); return future; }</span></span></code> </pre><br>  It turned out that this can not be done. <br><br>  Perhaps I would have known about this earlier if I had carefully read the javadoc for <code>CompletableFuture</code> . <br><br><div class="spoiler">  <b class="spoiler_title">View javadoc</b> <div class="spoiler_text">  For the completion of the action. <br></div></div><br>  When using such an architecture, it is necessary that all callbacks from the <code>CompletableFuture</code> called on the same thread that <code>CompletableFuture.complete</code> makes. <br><br>  For the above code, it seems to be the case.  But benchmarks sometimes ended up with <code>ConcurrentModificationException</code> in code that <code>pendingFutures</code> over <code>pendingFutures</code> in the same client thread ( <code>singleThreadExecutor</code> ). <br><br>  The fact is that the callback passed in the <code>future.whenComplete</code> (which calls <code>pendingFutures.remove</code> ) is sometimes performed in a completely different thread.  Or rather, in the flow of the application that my client uses: <br><br><pre> <code class="java hljs">Client client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, <span class="hljs-number"><span class="hljs-number">8080</span></span>); CompletableFuture&lt;String&gt; result = client.get(key); result.thenAccept(data -&gt; { System.out.println(data); });</code> </pre><br>  Calling <code>result.thenAccept</code> in this application sometimes leads to calling other callbacks on the future that were added inside the client code itself. <br><br><h2>  Consider the problem with simple examples. </h2><br><pre> <code class="java hljs">Thread mainThread = Thread.currentThread(); CompletableFuture&lt;Void&gt; future = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompletableFuture&lt;&gt;(); future.thenRun(() -&gt; { System.out.println(Thread.currentThread() == mainThread); }); future.complete(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre> <br>  This code always displays <code>true</code> , since the callback is executed on the same thread as the complete method. <br><br>  But if the <code>CompletableFuture</code> has at least one call from another thread, the behavior may change: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Thread mainThread = Thread.currentThread(); //   Executor executor = Executors.newSingleThreadExecutor(); CompletableFuture&lt;Void&gt; future = new CompletableFuture&lt;&gt;(); future.thenRun(() -&gt; { System.out.println(Thread.currentThread() == mainThread) }); //  callback    future    executor.execute(() -&gt; { future.thenRun(() -&gt; { //nop }); }); // future future.complete(null);</span></span></code> </pre><br>  Such code can sometimes produce <code>false</code> . <br><br>  The fact is that the <code>thenRun</code> call from the same future, but in the second thread, can trigger the callback in the first <code>thenRun</code> .  In this case, the callback of the first <code>thenRun</code> will be called in the second thread. <br><br>  This happens at the moment when <code>future.complete(null)</code> started to run, but did not have time to call callbacks, and <code>thenRun</code> volunteered in the second thread, which will execute all other callbacks on this future but already in its own flow. <br><br>  The problems are solved simply: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  Thread mainThread = Thread.currentThread(); //   Executor executor = Executors.newSingleThreadExecutor(); CompletableFuture&lt;Void&gt; future = new CompletableFuture&lt;&gt;(); CompletableFuture&lt;Void&gt; secondThreadFuture = future.thenRun(() -&gt; { System.out.println(Thread.currentThread() == mainThread); }); //  callback    future    executor.execute(() -&gt; { secondThreadFuture.thenRun(() -&gt; { //nop }); }); // future future.complete(null);</span></span></code> </pre><br>  We simply added a secondThreadFuture, which depends on the outcome of the original future.  And <code>thenRun</code> call on it in the second thread does not lead to the possible triggering of callbacks on the original future. <br><br>  For guaranteed callbacks in user-defined threads, the <code>CompletableFuture</code> has async method implementations, for example, <code>thenRunAsync</code> , which need to be passed to the Executor.  But async versions of methods may work slower than usual ones.  Therefore, I did not want to use them once again. <br><br><h2>  Conclusion </h2><br>  The conclusion I made for myself: do not use one <code>CompletableFuture</code> object in several threads, if you need to be sure that all callbacks on it are executed in the specified stream.  And if it is necessary to use several streams with one CompletableFuture, then it is enough to transfer to another stream not the original <code>CompletableFuture</code> , but a new one, which will depend on the original one.  For example, like this: <br><br><pre> <code class="java hljs">CompletableFuture&lt;Void&gt; secondThreadFuture = firstThreadFuture.whenComplete((v, e) -&gt; { <span class="hljs-comment"><span class="hljs-comment">//nop });</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/325730/">https://habr.com/ru/post/325730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325720/index.html">Intel Media SDK has become an open source project.</a></li>
<li><a href="../325722/index.html">Cloud video surveillance from a webcam and router</a></li>
<li><a href="../325724/index.html">Everything in Openwork: Parallels RAS Integration into Microsoft Azure</a></li>
<li><a href="../325726/index.html">Siberia? The Bears? Code! Or how we visited CodeFest</a></li>
<li><a href="../325728/index.html">How to love machine learning and stop suffering</a></li>
<li><a href="../325732/index.html">From developers - to Solution Architects: the story of one transformation</a></li>
<li><a href="../325734/index.html">Setting up backup of information in the cloud Microsoft Azure Backup</a></li>
<li><a href="../325736/index.html">9th MSK.NET Community Meeting</a></li>
<li><a href="../325738/index.html">Why a lot of JOIN in the query is bad or do not interfere with the optimizer</a></li>
<li><a href="../325740/index.html">IT Events Calendar for April '17</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>