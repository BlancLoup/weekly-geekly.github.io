<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Practice with dapp. Part 2. Deploying Docker images in Kubernetes using Helm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="dapp is our Open Source utility that helps DevOps engineers follow the CI / CD processes (read more about it in the announcement ) . The Russian-langu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Practice with dapp. Part 2. Deploying Docker images in Kubernetes using Helm</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://github.com/flant/dapp">dapp</a> is our Open Source utility that helps DevOps engineers follow the CI / CD processes <i>(read more about it in the <a href="https://habrahabr.ru/company/flant/blog/333682/">announcement</a> )</i> .  The Russian-language documentation for it <a href="http://flant.github.io/dapp/shell_for_build.html">gives an example of</a> assembling a simple application, and this process (with a demonstration of the main features of dapp) was presented in more detail in the <a href="https://habrahabr.ru/company/flant/blog/336212/">first part of the article</a> .  Now, based on the same simple application, I'll show you how dapp works with the Kubernetes cluster. <br><br><img src="https://habrastorage.org/web/d8f/ffc/27b/d8fffc27b36847a588f71681cb4d524e.png"><a name="habracut"></a><br><br>  As in the first article, all additions to the symfony-demo application code are in <a href="https://github.com/flant/symfony-demo/tree/dapp_deploy_minikube">our repository</a> .  But <code>Vagrantfile</code> this time will not work: Docker and dapp will have to be installed locally. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To go through the steps, you need to start with the <code>dapp_build</code> branch, where the <code>Dappfile</code> was added in the first article. <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/flant/symfony-demo.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> symfony-demo $ git checkout dapp_build $ git checkout -b kube_test $ dapp dimg build</code> </pre> <br><h2>  Starting a cluster using Minikube </h2><br>  Now you need to create a cluster Kubernetes, where dapp will launch the application.  For this we will use Minikube as the recommended way to start the cluster on the local machine. <br><br>  Installation is simple and consists in downloading Minikube and the kubectl utility.  Instructions are available on the links: <br><br><ul><li>  <a href="https://github.com/kubernetes/minikube/releases">Minikube on github</a> ; </li><li>  <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">installation documentation kubectl</a> . </li></ul><br>  <i><b>Note</b> : Read also our translation of the article ‚Äú <a href="https://habrahabr.ru/company/flant/blog/333470/">Getting started in Kubernetes using Minikube</a> ‚Äù.</i> <br><br>  After installation, you need to run <code>minikube setup</code> .  Minikube will download the ISO and launch a virtual machine from it in VirtualBox. <br><br>  After a successful start, you can see what is in the cluster: <br><br><pre> <code class="bash hljs">$ kubectl get all NAME READY STATUS RESTARTS AGE po/hello-minikube-938614450-zx7m6 1/1 Running 3 71d NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/hello-minikube 10.0.0.102 &lt;nodes&gt; 8080:31429/TCP 71d svc/kubernetes 10.0.0.1 &lt;none&gt; 443/TCP 71d NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/hello-minikube 1 1 1 1 71d NAME DESIRED CURRENT READY AGE rs/hello-minikube-938614450 1 1 1 71d</code> </pre> <br>  The command will show all resources in the <i>namespace</i> by default ( <code>default</code> ).  A list of all <i>namespaces</i> can be viewed through <code>kubectl get ns</code> . <br><br><h2>  Preparation, step number 1: registry for images </h2><br>  So, we launched Kubernetes cluster in a virtual machine.  What else is needed to run the application? <br><br>  First, for this you need to upload an image to where the cluster can get it.  You can use the general Docker Registry or install your Registry in a cluster (we do this for production clusters).  For local development, the second option is also better, and implementing it with dapp is quite simple - for this there is a special command: <br><br><pre> <code class="bash hljs">$ dapp kube minikube setup Restart minikube [RUNNING] minikube: Running localkube: Running kubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100 Starting <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> Kubernetes v1.6.4 cluster... Starting VM... Moving files into cluster... Setting up certs... Starting cluster components... Connecting to cluster... Setting up kubeconfig... Kubectl is now configured to use the cluster. Restart minikube [OK] 34.18 sec Wait till minikube ready [RUNNING] Wait till minikube ready [OK] 0.05 sec Run registry [RUNNING] Run registry [OK] 61.44 sec Run registry forwarder daemon [RUNNING] Run registry forwarder daemon [OK] 5.01 sec</code> </pre> <br>  After its execution, the following redirection appears in the list of system processes: <br><br><pre> <code class="bash hljs">username 13317 0.5 0.4 57184 36076 pts/17 Sl 14:03 0:00 kubectl port-forward --namespace kube-system kube-registry-6nw7m 5000:5000</code> </pre> <br>  ... and in the <i>namespace</i> under the name <code>kube-system</code> , a Registry is created and a proxy to it: <br><br><pre> <code class="bash hljs">$ kubectl get -n kube-system all NAME READY STATUS RESTARTS AGE po/kube-addon-manager-minikube 1/1 Running 2 22m po/kube-dns-1301475494-7kk6l 3/3 Running 3 22m po/kube-dns-v20-g7hr9 3/3 Running 9 71d po/kube-registry-6nw7m 1/1 Running 0 3m po/kube-registry-proxy 1/1 Running 0 3m po/kubernetes-dashboard-9zsv8 1/1 Running 3 71d po/kubernetes-dashboard-f4tp1 1/1 Running 1 22m NAME DESIRED CURRENT READY AGE rc/kube-dns-v20 1 1 1 71d rc/kube-registry 1 1 1 3m rc/kubernetes-dashboard 1 1 1 71d NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/kube-dns 10.0.0.10 &lt;none&gt; 53/UDP,53/TCP 71d svc/kube-registry 10.0.0.142 &lt;none&gt; 5000/TCP 3m svc/kubernetes-dashboard 10.0.0.249 &lt;nodes&gt; 80:30000/TCP 71d NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/kube-dns 1 1 1 1 22m NAME DESIRED CURRENT READY AGE rs/kube-dns-1301475494 1 1 1 22m</code> </pre> <br>  We test the launched Registry, putting our image in it with the command <code>dapp dimg push --tag-branch :minikube</code> .  Used here <code>:minikube</code> is an alias embedded in dapp specifically for Minikube that will be converted to <code>localhost:5000/symfony-demo</code> . <br><br><pre> <code class="bash hljs">$ dapp dimg push --tag-branch :minikube symfony-demo-app localhost:5000/symfony-demo:symfony-demo-app-kube_test [PUSHING] pushing image `localhost:5000/symfony-demo:symfony-demo-app-kube_test` [RUNNING] The push refers to a repository [localhost:5000/symfony-demo] 0ea2a2940c53: Preparing ffe608c425e1: Preparing 5c2cc2aa6663: Preparing edbfc49bce31: Preparing 308e5999b491: Preparing 9688e9ffce23: Preparing 0566c118947e: Preparing 6f9cf951edf5: Preparing 182d2a55830d: Preparing 5a4c2c9a24fc: Preparing cb11ba605400: Preparing 6f9cf951edf5: Waiting 182d2a55830d: Waiting 5a4c2c9a24fc: Waiting cb11ba605400: Waiting 9688e9ffce23: Waiting 0566c118947e: Waiting 0ea2a2940c53: Layer already exists 308e5999b491: Layer already exists ffe608c425e1: Layer already exists edbfc49bce31: Layer already exists 5c2cc2aa6663: Layer already exists 0566c118947e: Layer already exists 9688e9ffce23: Layer already exists 182d2a55830d: Layer already exists 6f9cf951edf5: Layer already exists cb11ba605400: Layer already exists 5a4c2c9a24fc: Layer already exists symfony-demo-app-kube_test: digest: sha256:5c55386de5f40895e0d8292b041d4dbb09373b78d398695a1f3e9bf23ee7e123 size: 2616 pushing image `localhost:5000/symfony-demo:symfony-demo-app-kube_test` [OK] 0.54 sec</code> </pre> <br>  It can be seen that the image tag in the Registry is composed of the name dimg and the name of the branch (through a hyphen). <br><br><h2>  Preparation, Step # 2: Resource Configuration (Helm) </h2><br>  The second part required to run the application in a cluster is the configuration of resources.  The standard cluster management utility Kubernetes is <code>kubectl</code> .  If you need to create a new resource ( <i>Deployment</i> , <i>Service</i> , <i>Ingress</i> , etc.) or change the properties of an existing resource, then the YAML file with the configuration is transferred to the utility. <br><br>  However, dapp does not directly use <code>kubectl</code> , but works with the so-called batch manager, <a href="https://github.com/kubernetes/helm">Helm</a> , which provides the template YAML files and controls the rollout to the cluster itself. <br><br>  Therefore, our next step is to install Helm.  Official instructions can be found in the <a href="https://docs.helm.sh/using_helm/">project documentation</a> . <br><br>  After installation, you must run <code>helm init</code> .  What she does?  Helm consists of the client part that we installed and the server part.  The <code>helm init</code> command installs the server part ( <code>tiller</code> ).  Let's see what appeared in the namespace <code>kube-system</code> : <br><br><pre> <code class="bash hljs">$ kubectl get -n kube-system all NAME READY STATUS RESTARTS AGE po/kube-addon-manager-minikube 1/1 Running 2 1h po/kube-dns-1301475494-7kk6l 3/3 Running 3 1h po/kube-dns-v20-g7hr9 3/3 Running 9 71d po/kube-registry-6nw7m 1/1 Running 0 1h po/kube-registry-proxy 1/1 Running 0 1h po/kubernetes-dashboard-9zsv8 1/1 Running 3 71d po/kubernetes-dashboard-f4tp1 1/1 Running 1 1h !!! po/tiller-deploy-3703072393-bdqn8 1/1 Running 0 3m NAME DESIRED CURRENT READY AGE rc/kube-dns-v20 1 1 1 71d rc/kube-registry 1 1 1 1h rc/kubernetes-dashboard 1 1 1 71d NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/kube-dns 10.0.0.10 &lt;none&gt; 53/UDP,53/TCP 71d svc/kube-registry 10.0.0.142 &lt;none&gt; 5000/TCP 1h svc/kubernetes-dashboard 10.0.0.249 &lt;nodes&gt; 80:30000/TCP 71d !!! svc/tiller-deploy 10.0.0.196 &lt;none&gt; 44134/TCP 3m NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/kube-dns 1 1 1 1 1h !!! deploy/tiller-deploy 1 1 1 1 3m NAME DESIRED CURRENT READY AGE rs/kube-dns-1301475494 1 1 1 1h !!! rs/tiller-deploy-3703072393 1 1 1 3m</code> </pre> <br>  (Hereinafter, ‚Äú!!!‚Äù is manually highlighted the lines that are worth paying attention to.) <br><br>  That is: <i>Deployment</i> appeared under the name <code>tiller-deploy</code> with one <i>ReplicaSet</i> and one sub ( <i>Pod</i> ).  For <i>Deployment,</i> a service of the same name ( <code>tiller-deploy</code> ) was made, which allows access via port 44134. <br><br><h2>  Preparation, step number 3: IngressController </h2><br>  The third part is the configuration itself for the application.  At this stage, you need to understand what is required to put in a cluster for the application to work. <br><br>  The following scheme is proposed: <br><br><ul><li>  The application is <i>Deployment</i> .  For starters, this will be one <i>ReplicaSet</i> of one pod, as done for the Registry; </li><li>  the application responds on port 8000, so you need to define a <i>Service</i> so that it can respond to requests from outside; </li><li>  we have a web application, so we need a way to receive packets from users on the 80th port.  This is done by the <i>Ingress</i> resource.  For these resources to work, you need to configure <i>IngressController</i> . </li></ul><br>  <i>IngressController</i> is an additional component of the Kubernetes cluster for organizing load-balanced web applications.  In essence, this is nginx, the configuration of which depends on the <i>Ingress</i> resources added to the cluster.  The component must be installed separately, and for minikube there is an addon.  You can read more about it in <a href="https://medium.com/%40Oskarr3/setting-up-ingress-on-minikube-6ae825e98f82">this article</a> in English, but for now just run the <i>IngressController</i> installation: <br><br><pre> <code class="bash hljs">$ minikube addons <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> ingress ingress was successfully enabled</code> </pre> <br>  ... and see what appeared in the cluster: <br><br><pre> <code class="bash hljs">$ kubectl get -n kube-system all NAME READY STATUS RESTARTS AGE !!! po/default-http-backend-vbrf3 1/1 Running 0 2m po/kube-addon-manager-minikube 1/1 Running 2 3h po/kube-dns-1301475494-7kk6l 3/3 Running 3 3h po/kube-dns-v20-g7hr9 3/3 Running 9 72d po/kube-registry-6nw7m 1/1 Running 0 3h po/kube-registry-proxy 1/1 Running 0 3h po/kubernetes-dashboard-9zsv8 1/1 Running 3 72d po/kubernetes-dashboard-f4tp1 1/1 Running 1 3h !!! po/nginx-ingress-controller-hmvg9 1/1 Running 0 2m po/tiller-deploy-3703072393-bdqn8 1/1 Running 0 1h NAME DESIRED CURRENT READY AGE !!! rc/default-http-backend 1 1 1 2m rc/kube-dns-v20 1 1 1 72d rc/kube-registry 1 1 1 3h rc/kubernetes-dashboard 1 1 1 72d !!! rc/nginx-ingress-controller 1 1 1 2m NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE !!! svc/default-http-backend 10.0.0.131 &lt;nodes&gt; 80:30001/TCP 2m svc/kube-dns 10.0.0.10 &lt;none&gt; 53/UDP,53/TCP 72d svc/kube-registry 10.0.0.142 &lt;none&gt; 5000/TCP 3h svc/kubernetes-dashboard 10.0.0.249 &lt;nodes&gt; 80:30000/TCP 72d svc/tiller-deploy 10.0.0.196 &lt;none&gt; 44134/TCP 1h NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/kube-dns 1 1 1 1 3h deploy/tiller-deploy 1 1 1 1 1h NAME DESIRED CURRENT READY AGE rs/kube-dns-1301475494 1 1 1 3h rs/tiller-deploy-3703072393 1 1 1 1h</code> </pre> <br>  How to check?  <i>IngressController</i> has a <code>default-http-backend</code> , which responds with a 404 error to all pages for which there is no handler.  This can be seen with the following command: <br><br><pre> <code class="bash hljs">$ curl -i $(minikube ip) HTTP/1.1 404 Not Found Server: nginx/1.13.1 Date: Fri, 14 Jul 2017 14:29:46 GMT Content-Type: text/plain; charset=utf-8 Content-Length: 21 Connection: keep-alive Strict-Transport-Security: max-age=15724800; includeSubDomains; default backend - 404</code> </pre> <br>  The result is positive - the answer comes from nginx with the line <code>default backend - 404</code> . <br><br><h2>  Configuration Description for Helm </h2><br>  Now you can describe the configuration of the application.  The basic configuration can be generated by the <code>helm create _</code> : <br><br><pre> <code class="bash hljs">$ helm create symfony-demo $ tree symfony-demo symfony-demo/ ‚îú‚îÄ‚îÄ charts ‚îú‚îÄ‚îÄ Chart.yaml ‚îú‚îÄ‚îÄ templates ‚îÇ ‚îú‚îÄ‚îÄ deployment.yaml ‚îÇ ‚îú‚îÄ‚îÄ _helpers.tpl ‚îÇ ‚îú‚îÄ‚îÄ ingress.yaml ‚îÇ ‚îú‚îÄ‚îÄ NOTES.txt ‚îÇ ‚îî‚îÄ‚îÄ service.yaml ‚îî‚îÄ‚îÄ values.yaml</code> </pre> <br>  dapp expects this structure in a directory called <code>.helm</code> ( <a href="http://flant.github.io/dapp/kube_commands.html">see the documentation</a> ), so you need to rename <code>symfony-demo</code> to <code>.helm</code> . <br><br>  We have now created a chart description.  Chart is a configuration unit for Helm, you can think of it as a kind of package.  For example, there is a chart for nginx, for MySQL, for Redis.  And with the help of such charts you can assemble the desired configuration in a cluster.  Helm puts in Kubernetes not individual images, but Chart's ( <a href="">official documentation</a> ). <br><br>  The <code>Chart.yaml</code> file is a description of the chart of our application.  Here you need to specify at least the application name and version: <br><br><pre> <code class="bash hljs">$ cat Chart.yaml apiVersion: v1 description: A Helm chart <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Kubernetes name: symfony-demo version: 0.1.0</code> </pre> <br>  File <code>values.yaml</code> - description of variables that will be available in templates.  For example, in the generated file there is an <code>image: repository: nginx</code> .  This variable will be available through this construction: <code>{{ .Values.image.repository }}</code> . <br><br>  The <code>charts</code> directory is currently empty, because our application chart does not use external charts yet. <br><br>  Finally, the <code>templates</code> directory - here are stored templates of YAML files with a description of resources for their placement in the cluster.  The generated templates are not very necessary, so you can view and delete them. <br><br>  First, let's describe a simple <i>Deployment</i> option for our application: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Deployment metadata: name: {{ .Chart.Name }}-backend spec: replicas: 1 template: metadata: labels: app: {{ .Chart.Name }}-backend spec: containers: - command: [ '/opt/start.sh' ] image: {{ tuple "symfony-demo-app" . | include "dimg" }} imagePullPolicy: Always name: {{ .Chart.Name }}-backend ports: - containerPort: 8000 name: http protocol: TCP env: - name: KUBERNETES_DEPLOYED value: "{{ now }}"</code> </pre> <br>  In the configuration it is described that we need one replica so far, and in the <code>template</code> indicated which scans should be replicated.  This description indicates the image that will be launched and the ports that are available to other containers in the hearth. <br><br>  Mentioned in the config <code>.Chart.Name</code> is the value from <code>charts.yaml</code> . <br><br>  The <code>KUBERNETES_DEPLOYED</code> needed for Helm to update the slots if we update the image without changing the tag.  This is convenient for debugging and local development. <br><br>  Next, we describe the <i>Service</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: {{ .Chart.Name }}-srv spec: type: ClusterIP selector: app: {{ .Chart.Name }}-backend ports: - name: http port: 8000 protocol: TCP</code> </pre> <br>  With this resource, we create a <code>symfony-demo-app-srv</code> DNS record by which other <i>Deployments</i> can access the application. <br><br>  These two descriptions are combined through <code>---</code> and written in <code>.helm/templates/backend.yaml</code> , after which you can deploy the application! <br><br><h2>  First patch </h2><br>  Now everything is ready to run <code>dapp kube deploy</code> (for more information about the command, see the <a href="http://flant.github.io/dapp/kube_commands.html">documentation</a> ): <br><br><pre> <code class="bash hljs">$ dapp kube deploy :minikube --image-version kube_test Deploy release symfony-demo-default [RUNNING] Release <span class="hljs-string"><span class="hljs-string">"symfony-demo-default"</span></span> has been upgraded. Happy Helming! LAST DEPLOYED: Fri Jul 14 18:32:38 2017 NAMESPACE: default STATUS: DEPLOYED RESOURCES: ==&gt; v1beta1/Deployment NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE symfony-demo-app-backend 1 1 1 0 7s ==&gt; v1/Service NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE symfony-demo-app-srv 10.0.0.173 &lt;none&gt; 8000/TCP 7s Deploy release symfony-demo-default [OK] 7.02 sec</code> </pre> <br>  We see that the cluster appears under the state of <code>ContainerCreating</code> : <br><br><pre> <code class="bash hljs">po/symfony-demo-app-backend-3899272958-hzk4l 0/1 ContainerCreating 0 24s</code> </pre> <br>  ... and after a while everything works: <br><br><pre> <code class="bash hljs">$ kubectl get all NAME READY STATUS RESTARTS AGE po/hello-minikube-938614450-zx7m6 1/1 Running 3 72d !!! po/symfony-demo-app-backend-3899272958-hzk4l 1/1 Running 0 47s NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE svc/hello-minikube 10.0.0.102 &lt;nodes&gt; 8080:31429/TCP 72d svc/kubernetes 10.0.0.1 &lt;none&gt; 443/TCP 72d !!! svc/symfony-demo-app-srv 10.0.0.173 &lt;none&gt; 8000/TCP 47s NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE deploy/hello-minikube 1 1 1 1 72d deploy/symfony-demo-app-backend 1 1 1 1 47s NAME DESIRED CURRENT READY AGE rs/hello-minikube-938614450 1 1 1 72d !!! rs/symfony-demo-app-backend-3899272958 1 1 1 47s</code> </pre> <br>  Created <i>ReplicaSet</i> , <i>Pod</i> , <i>Service</i> , that is, the application is running.  This can be checked "in the old fashioned way" by entering the container: <br><br><pre> <code class="plaintext hljs">$ kubectl exec -ti symfony-demo-app-backend-3899272958-hzk4l bash root@symfony-demo-app-backend-3899272958-hzk4l:/# curl localhost:8000</code> </pre> <br><h2>  Open access </h2><br>  Now, to make the application available at <code>$(minikube ip)</code> , <code>$(minikube ip)</code> 's add the resource <i>Ingress</i> .  To do this, we describe it in <code>.helm/templates/backend-ingress.yaml</code> as follows: <br><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Ingress metadata: name: {{ .Chart.Name }} annotations: kubernetes.io/ingress.class: "nginx" spec: rules: - http: paths: - path: / backend: serviceName: {{ .Chart.Name }}-srv servicePort: 8000</code> </pre> <br>  <code>serviceName</code> must match the name of the <i>Service</i> , which was declared in <code>backend.yaml</code> .  Deploy the application again: <br><br><pre> <code class="bash hljs">$ dapp kube deploy :minikube --image-version kube_test Deploy release symfony-demo-default [RUNNING] Release <span class="hljs-string"><span class="hljs-string">"symfony-demo-default"</span></span> has been upgraded. Happy Helming! LAST DEPLOYED: Fri Jul 14 19:00:28 2017 NAMESPACE: default STATUS: DEPLOYED RESOURCES: ==&gt; v1/Service NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE symfony-demo-app-srv 10.0.0.173 &lt;none&gt; 8000/TCP 27m ==&gt; v1beta1/Deployment NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE symfony-demo-app-backend 1 1 1 1 27m ==&gt; v1beta1/Ingress NAME HOSTS ADDRESS PORTS AGE symfony-demo-app * 192.168.99.100 80 2s Deploy release symfony-demo-default [OK] 3.06 sec</code> </pre> <br>  Appeared <code>v1beta1/Ingress</code> !  Let's try to access the application through <i>IngressController</i> .  This can be done through the IP cluster: <br><br><pre> <code class="bash hljs">$ curl -Lik $(minikube ip) HTTP/1.1 301 Moved Permanently Server: nginx/1.13.1 Date: Fri, 14 Jul 2017 16:13:45 GMT Content-Type: text/html Content-Length: 185 Connection: keep-alive Location: https://192.168.99.100/ Strict-Transport-Security: max-age=15724800; includeSubDomains; HTTP/1.1 403 Forbidden Server: nginx/1.13.1 Date: Fri, 14 Jul 2017 16:13:45 GMT Content-Type: text/html; charset=UTF-8 Transfer-Encoding: chunked Connection: keep-alive Host: 192.168.99.100 X-Powered-By: PHP/7.0.18-0ubuntu0.16.04.1 Strict-Transport-Security: max-age=15724800; includeSubDomains; You are not allowed to access this file. Check app_dev.php <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> more information.</code> </pre> <br>  In general, we can assume that the deployment of the application in Minikube succeeded.  From the request, it is clear that the <i>IngressController is</i> sending to port 443 and the application responds that you need to check <code>app_dev.php</code> .  This is already the specificity of the selected application (symfony), because in the <code>web/app_dev.php</code> it is easy to notice: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// This check prevents access to debug front controllers that are deployed by // accident to production servers. Feel free to remove this, extend it, or make // something more sophisticated. if (isset($_SERVER['HTTP_CLIENT_IP']) || isset($_SERVER['HTTP_X_FORWARDED_FOR']) || !(in_array(@$_SERVER['REMOTE_ADDR'], ['127.0.0.1', 'fe80::1', '::1']) || php_sapi_name() === 'cli-server') ) { header('HTTP/1.0 403 Forbidden'); exit('You are not allowed to access this file. Check '.basename(__FILE__).' for more information.'); }</span></span></code> </pre> <br>  To see the normal page of the application, you need to deploy the application with a different setting or comment out this block for the tests.  Repeated deployment in Kubernetes (after edits in the application code) looks like this: <br><br><pre> <code class="bash hljs">$ dapp dimg build ... Git artifacts: latest patch ... [OK] 1.86 sec signature: dimgstage-symfony-demo:13a2487a078364c07999d1820d4496763c2143343fb94e0d608ce1a527254dd3 Docker instructions ... [OK] 1.46 sec signature: dimgstage-symfony-demo:e0226872a5d324e7b695855b427e8b34a2ab6340ded1e06b907b165589a45c3b instructions: EXPOSE 8000 $ dapp dimg push --tag-branch :minikube ... symfony-demo-app-kube_test: digest: sha256:eff826014809d5aed8a82a2c5cfb786a13192ae3c8f565b19bcd08c399e15fc2 size: 2824 pushing image `localhost:5000/symfony-demo:symfony-demo-app-kube_test` [OK] 1.16 sec localhost:5000/symfony-demo:symfony-demo-app-kube_test [OK] 1.41 sec $ dapp kube deploy :minikube --image-version kube_test $ kubectl get all !!! po/symfony-demo-app-backend-3438105059-tgfsq 1/1 Running 0 1m</code> </pre> <br>  Under the re-create, you can go to the browser and see a beautiful picture: <br><br><img src="https://habrastorage.org/web/08b/b8b/2d5/08bb8b2d51ee4f7c9b4d1a4d0eef68f9.png"><br><br><h2>  Total </h2><br>  With the help of Minikube and Helm, you can test your applications in a Kubernetes cluster, and dapp will help in building, deploying your Registry and the application itself. <br><br>  The article does not mention secret variables that can be used in templates for private keys, passwords and other sensitive information.  We will write about this separately. <br><br><h2>  PS </h2><br>  Read also in our blog: <br><br><ul><li>  <b>The first part of the article</b> : ‚Äú <a href="https://habrahabr.ru/company/flant/blog/336212/">Practice with dapp.</a>  <a href="https://habrahabr.ru/company/flant/blog/336212/">Part 1: Build simple applications</a> "; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/333682/">Officially present dapp - DevOps utility to maintain the CI / CD</a> "; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/324274/">We assemble Docker images for CI / CD quickly and conveniently along with dapp (review and video from the report)</a> ‚Äù; </li><li>  ‚Äú <a href="https://habrahabr.ru/company/flant/blog/333470/">Getting started in Kubernetes using Minikube</a> ‚Äù <i>(translation)</i> ; </li><li>  " <a href="https://habrahabr.ru/company/flant/blog/331188/">Our experience with Kubernetes in small projects</a> " <i>(video of the report, which includes an introduction to the technical device Kubernetes)</i> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/336170/">https://habr.com/ru/post/336170/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336160/index.html">Some functional programming techniques in Python</a></li>
<li><a href="../336162/index.html">Nginx in the work of DevOps / Administrator. Dark side of power</a></li>
<li><a href="../336164/index.html">Pentestit Corporate Laboratories: Practical Information Security Skills</a></li>
<li><a href="../336166/index.html">Learn OpenGL. Part 2.3. - Materials</a></li>
<li><a href="../336168/index.html">Kaggle Mercedes and cross-validation</a></li>
<li><a href="../336172/index.html">Mobile browsers and their fluffy legs</a></li>
<li><a href="../336174/index.html">4 ways to stand out in the coffee market</a></li>
<li><a href="../336180/index.html">How to enjoy work</a></li>
<li><a href="../336182/index.html">Creating modules for MODX Evolution in 2017 for the smallest</a></li>
<li><a href="../336184/index.html">The implementation of the list with the title, footer and pagination in Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>