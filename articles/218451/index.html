<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ and copying overlapping areas of memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="memmove() programming in C, many have come across such functions as memcpy() and memmove() , in fact, the functions do the same thing, but the second ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ and copying overlapping areas of memory</h1><div class="post__text post__text-html js-mediator-article"> <code>memmove()</code> programming in C, many have come across such functions as <code>memcpy()</code> and <code>memmove()</code> , in fact, the functions do the same thing, but the second one correctly works out the situation when memory areas overlap (to which additional overheads appear). <br><br>  In the C ++ world, no one forbids using these functions (often these functions use various optimization mechanisms and can be faster than their fellows from the C ++ world), but there is a more native tool that works through iterators: <code>std::copy</code> .  This tool is applicable not only to POD types, but to any entities that support iterators.  The implementation details in the standard say nothing, but it can be assumed that library developers are not so stupid as to not use optimized <code>memcpy()</code> / <code>memmove()</code> when possible. <br><a name="habracut"></a><br>  But on a whim, I want to see, but what about overlapping memory blocks?  After all, the task, in fact, is not so rare.  For example, we want to read MPEG-TS packets (the size of each is 188 bytes, each packet starts with 0x47 / sync byte /) from some stream, and there is a possibility that the first (and maybe the next one: for example, we deal with M2TS a container with a block size of 192 bytes and an extra 4 bytes in most cases we can ignore / timestamp /) reading can get to the middle of the packet.  In such cases, it is usually done this way: we read the block 188 bytes, then we look for the synchronization byte, if it is in the zero position - everything is fine, if not, the data from it to the end should be moved to the beginning of the block, the remaining portion needs to be read into the free space , after which the package is considered to be read and you can give it to processing. <br><br>  Visually the process of copying data to the beginning of the block can be shown with this picture: <br><img src="https://habrastorage.org/getpro/habr/post_images/72e/ece/51b/72eece51bf63211db89a7bab5c487a4a.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Those.  see that there is an overlap.  It would be logical to apply some analogue of <code>memmove()</code> , but in the standard library there is only <code>std::move</code> which does absolutely not the same thing (here you need to smile).  But at the same time, reading the description for <a href="http://www.cplusplus.com/reference/algorithm/copy">std :: copy</a> we see the following line: <br><blockquote>  This is not the case. [First, last) </blockquote><br><br>  those.  in fact, if the beginning of the region (result) where to copy, lies outside the region [first, last), then everything should be ok.  And it really is. <br><br>  But let's look at this overlapping copy scheme: <br><img src="https://habrastorage.org/getpro/habr/post_images/9f4/351/41f/9f435141f1f3b9d1ed02e49b4ba83d58.png" alt="image"><br><br>  until we pay attention to the fact that the result is here at the end.  The meaning of the picture is that the memory block needs to be shifted from the beginning by some kind of an offset forward, respectively, if this offset is less than the size of the shifted block, then the destination address will be within [first, last), thus the condition of applicability of <code>std::copy</code> not respected.  And if we apply it, we simply wipe the data in the overlapping area. <br><br>  But here his colleague comes to the rescue, just solving this problem: <code>std::copy_backward</code> , the whole difference of this function is that it performs copying from the end.  Those.  for the case depicted in the second picture, it takes (further roughly) an element from last and goes to result, then from last-1 to result-1, then from last-2 to result-2, and so on. <br><br>  It can be seen that with such a copying scheme, when we start writing in an overlapping area, the data in it will already be processed.  Those.  everything is good for us  It's funny that the condition of applicability with overlapping areas for <code>std::copy_backward</code> word for word repeats this condition for <code>std::copy</code> . <br><br>  So, summarizing, a simple rule: <br><ol><li>  If result &lt;first (‚Äúblock shift to the beginning / or left /‚Äù), then use <code>std::copy</code> , and specify the <b>beginning of the</b> target block as result. </li><li>  If result&gt; first (‚Äúblock shift to end / or right /‚Äù), then apply <code>std::copy_backward</code> , and specify <b>end of</b> <code>std::copy_backward</code> block as result. </li></ol><br><br>  The text is a creative reinterpretation of an English-language article: <a href="http://www.trilithium.com/johan/2006/02/copy-confusion">www.trilithium.com/johan/2006/02/copy-confusion</a> , pictures taken from the same place, an example from my own experience. <br><br>  Reference: <br><ol><li>  <a href="http://www.cplusplus.com/reference/algorithm/copy">www.cplusplus.com/reference/algorithm/copy</a> </li><li>  <a href="http://www.cplusplus.com/reference/algorithm/copy_backward">www.cplusplus.com/reference/algorithm/copy_backward</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/218451/">https://habr.com/ru/post/218451/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../218437/index.html">Terms of Service, Privacy Policy and License Agreement: an educational program for an indie mobile developer</a></li>
<li><a href="../218441/index.html">Universal applications for Windows and Windows Phone</a></li>
<li><a href="../218443/index.html">Epson on Droidcon Moscow</a></li>
<li><a href="../218445/index.html">Product Design Digest February-March 2014</a></li>
<li><a href="../218449/index.html">What do small iron companies need from the state?</a></li>
<li><a href="../218453/index.html">Saving memory: Picasso vs UniversalImageLoader</a></li>
<li><a href="../218455/index.html">How we HackPSU won</a></li>
<li><a href="../218457/index.html">Multiple Core Data</a></li>
<li><a href="../218459/index.html">Build Systems - Intro</a></li>
<li><a href="../218461/index.html">Free virtualization - practical applicability</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>