<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>VIM syntax highlighting: full immersion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VIM is notable for how simple and flexible it can be customized. In this article I will describe in detail how easy and simple it is to create your ow...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>VIM syntax highlighting: full immersion</h1><div class="post__text post__text-html js-mediator-article">  VIM is notable for how simple and flexible it can be customized.  In this article I will describe in detail how easy and simple it is to create your own rules for syntax highlighting with various examples. <br><br>  Yes, on Habr√© about this was already a <a href="http://habrahabr.ru/post/42141/">article</a> , but in it the topic was considered very superficially, and I will try to understand this in detail.  They will cover from the simplest examples, including html backlight enhancements for highlighting habra-tagging tags, to creating highlighting for full-fledged programming languages, with context-sensitive syntax highlighting. <br><a name="habracut"></a><br>  What is especially convenient - you can play with the backlight without any additional movements right while editing your file, immediately watching the result.  So I suggest everyone to open VIM and try the examples given in my article. <br><br><h2>  Keyword highlighting </h2><br>  To begin with, let's look at a simple example: you edit the text and leave for yourself notes like ‚Äútodo - rewrite this sentence, which would be easier to read.‚Äù  Let's simplify reading the text and we will highlight the word todo.  To do this in command mode, enter <br><pre><code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:syn</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">keyword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Keyword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">todo</span></span></code> </pre> <br>  Voila!  Now we are in the editor apparently something like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/1e9/de8/925/1e9de89250b517b13ddce2789f1eca57.png"><br><br>  The syn (syntax) command with the first keyword parameter means the following: highlight the word todo with the Keyword style.  The color of this style depends on your color scheme.  You can list many keywords at once: <br><br><pre> <code class="hljs css"><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:syn</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">keyword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Keyword</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">todo</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rewrite</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">done</span></span></code> </pre> <br><br><h2>  Highlighting by regular expressions </h2><br>  To highlight regular expressions in the Vime, use the following command: <br><pre> <code class="hljs vbscript">:syn match AnyHighlightStyle /herer-<span class="hljs-keyword"><span class="hljs-keyword">is</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">regexp</span></span>/</code> </pre> <br>  The main thing to remember is that the syntax of WIM regular expressions differs significantly from Perl-like regular expressions (which many people are used to): <br><table><tbody><tr><td>  <b>Perl-like</b> </td><td>  <b>Vim</b> </td></tr><tr><td>  oneOrMany + </td><td>  oneOrMany \ + </td></tr><tr><td>  (group) </td><td>  \ (group \) </td></tr><tr><td>  (optional) </td><td>  \ (optional \) \ = </td></tr><tr><td>  (notSoManyTimes) {2, 4} </td><td>  \ (notSoManyTimes \) \ {2, 4} </td></tr><tr><td>  something (? = lookAhead) </td><td>  something \ (lookAhead \) \ @ = </td></tr><tr><td>  something (?! shouldNotBeThere) </td><td>  something \ (shouldNotBeThere \) \ @! </td></tr><tr><td>  (? &lt;= lookBackward) something </td><td>  \ (lookBackword \) \ @ &lt;= ssomething </td></tr></tbody></table><br><br>  As a first example, consider highlighting numbers: <br><br><pre> <code class="hljs tex">:syn match Float /<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">d</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">d</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span>/</code> </pre> <br><img src="https://habrastorage.org/storage2/018/a0e/67c/018a0e67c3ee24c372b68c03180d06b1.png"><br><br>  Now consider the example more complicated - let's highlight the function calls.  A function call is defined as follows: an identifier followed by an opening bracket (but the bracket itself should not be highlighted. To do this, use the look-ahead construction with \ ze, which requires an atom to the right but does not include it in the matching result (thus the parenthesis will not be highlighted in the function color): <br><br><pre> <code class="hljs tex">:syn match Function /<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">w</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(</span></span></span></span>(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">@</span></span></span><span class="hljs-tag">=</span></span>/</code> </pre> <br><img src="https://habrastorage.org/storage2/2aa/3a5/b80/2aa3a5b8067c87a98a583c183505f7a3.png"><br><br>  Or let's highlight the constructor call: new SomeClassName.  To do this, use the construction similar to \ ze, only scanning "back": \ zs <br><br><pre> <code class="hljs tex">:syn match Function /<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">(</span></span></span></span>new<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">s</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">)</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">@</span></span></span></span>&lt;=<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">w</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">+</span></span></span></span>/</code> </pre> <br><br><h2>  Highlighting the regions </h2><br>  Highlighting regions exists to simplify the highlighting of blocks with certain opening and closing constructions, for example: comments, lines, tags in html, etc.  The syntax for setting regions is as follows: <br><pre> <code class="hljs sql">:syn region SomeHighlightStyle <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>=/<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>-regexp/ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=/<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-regexp/ <span class="hljs-keyword"><span class="hljs-keyword">skip</span></span>=/regexp-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">skip</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">and</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">treat</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>-an-<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-regexp/</code> </pre> <br><br>  Consider use on remakes.  First, highlight the C-style multi-line comments: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region Comment start=<span class="hljs-regexp"><span class="hljs-regexp">/\/\*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/\*\//</span></span></code> </pre> <br>  Now let's look at an example a bit more complicated: let's highlight the string with a double quotation mark: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region String start=<span class="hljs-regexp"><span class="hljs-regexp">/"/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/"/</span></span></code> </pre> <br>  However, there is a flaw in this design - we cannot include the character itself in the string. ‚ÄùLet's correct this flaw and make sure that the screened quotes are not considered the end of the string. It is this that created the skip parameter, which‚Äú swallows ‚Äùthe expression without giving it check for the end of the region: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region String start=<span class="hljs-regexp"><span class="hljs-regexp">/"/</span></span> skip=<span class="hljs-regexp"><span class="hljs-regexp">/\\"/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/"/</span></span></code> </pre> <br><img src="http://habrastorage.org/storage2/6ef/11f/ebb/6ef11febb732ecf8ce128799a6713f10.png"><br><br>  Now it works as it should. <br><br><h2>  "Folding" (folding) regions </h2><br>  Vim allows you to "collapse" blocks (for example, long comments or blocks of code).  For this, the command: syn has the optional parameter fold.  So if you want to allow the user to fold comments, simply add fold to the end of the syn command: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region Comment start=<span class="hljs-regexp"><span class="hljs-regexp">/\/\*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/\*\//</span></span> fold</code> </pre> <br>  You just need to make sure that the information from syntax highlighting is used for ‚Äúfolding‚Äù: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> foldmethod=syntax</code> </pre> <br>  In order to describe the folding {} of the brackets in the code, but at the same time leave the code highlighting inside (which by default ‚Äúeat‚Äù: syn region), you can use the transparent parameter at: syn region: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region CodeBlock start=<span class="hljs-regexp"><span class="hljs-regexp">/{/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/}/</span></span> transparent fold</code> </pre> <br>  In this case, the command will not change the appearance of the block inside {}, but will enable it to collapse. <br><br><h2>  Backlight styles </h2><br>  The second argument of the command: syn - the style that you want to mark up, can be any line.  And in a good way, in order to separate "structure" and "presentation", in: syn the "structural names" with the prefix language indicate the styles, for example: <br><br><pre> <code class="hljs delphi">:syn keyword pascalKeyword <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> :</span></span>syn keyword pascalBuiltinFunction WriteLn ReadLn Assign</code> </pre><br>  And then they match these styles with the styles described in VIM color schemes with the help of the hi (hilight) command: <br><br><pre> <code class="hljs perl">:hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> pascalKeyword Keyword :hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> pascalBuiltinFunction Keyword</code> </pre><br><br><h2>  Nested blocks </h2><br>  Now let's consider the following example: we want to highlight our keywords in the comments: TODO, NOTE, which are often left by programmers.  For this, VIM has two parameters contained and contains for the structure: syn.  contained means that the highlight rule does not apply "in the global" region.  And contains = Style1, Style2 means that inside the rule you should look for rules that describe the Style1 and Style2 style.  Let's see how it looks like: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> keyword CommentKeyword TODO NOTE contained <span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region Comment start=<span class="hljs-regexp"><span class="hljs-regexp">/\/\*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/\*\//</span></span> contains CommentKeyword <span class="hljs-symbol"><span class="hljs-symbol">:hi</span></span> link CommentKeyword Keyword</code> </pre><br>  Thus, TODO and NOTE will not be highlighted outside the comments, and only they will be highlighted in the comments. <br><br>  You can "contain" not only keywords, but also any rules for highlighting.  For example, you can select escaped characters in a string: \ n, \ t, \ r, \ b: <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> region String start=<span class="hljs-regexp"><span class="hljs-regexp">/"/</span></span> skip=<span class="hljs-regexp"><span class="hljs-regexp">/\\"/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=<span class="hljs-regexp"><span class="hljs-regexp">/"/</span></span> contains=EscapeSymbol <span class="hljs-symbol"><span class="hljs-symbol">:syn</span></span> match EscapeSymbol /\\[ntrb<span class="hljs-string"><span class="hljs-string">"]/ contained :highlight link EscapeSymbol Keyword</span></span></code> </pre><br><img src="http://habrastorage.org/storage2/6b4/4eb/e20/6b44ebe20be96832d162c5472df7c8f7.png"><br><br><h2>  Practical example: highlighting of habrateg in .html files </h2><br>  If you write habraposts in VIM in .html files, then, unfortunately, habracut-specific tags like habracut, hh will not be highlighted.  Correct this misunderstanding.  To do this, we climb into the html backlight file: .vim / syntax / html.vim and find out that the tagname highlighting style is called htmlTagName, so typing the command: <br><br><pre> <code class="hljs mel">:syn keyword htmlTagName habracut <span class="hljs-keyword"><span class="hljs-keyword">source</span></span> hh video slideshow</code> </pre> <br><img src="http://habrastorage.org/storage2/cc0/45a/12a/cc045a12a155ccba4e9532cdadc63cda.png"><br><br><h2>  Highlighting by extension </h2><br>  Each time to introduce commands to highlight all designs, of course, no one requires.  All commands need to be placed in the file (for example) my.vim in the directory (required) .vim / syntax / Now this file will be automatically applied to my files.  And in order for the type to be automatically added depending on the extension, it is necessary to add a line to .vimrc: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">au</span></span> BufRead,BufNewFile <span class="hljs-regexp"><span class="hljs-regexp">*.my</span></span> set filetype=my</code> </pre> <br>  BufRead and BufNewFile mean to apply the rule for opening existing and for creating new files. <br><br>  By the way, if suddenly you didn‚Äôt know this command, you can also use it to automatically highlight files with non-standard extensions: for example, if you store a database dump in .dump files, then the line <br><br><pre> <code class="hljs swift">au <span class="hljs-type"><span class="hljs-type">BufRead</span></span>,<span class="hljs-type"><span class="hljs-type">BufNewFile</span></span> *.<span class="hljs-built_in"><span class="hljs-built_in">dump</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> filetype=sql</code> </pre> <br>  Automatically when you open it will color you as an sql file. <br><br><h2>  Example entirely </h2><br>  Now let's look at a simple example in its entirety: let's color a certain subset of the javascript language: <br><br><pre> <code class="hljs sql">" javascript       ,   if exists("b:current_syntax") finish endif " javascript       ,       syn region jsString <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>=/<span class="hljs-string"><span class="hljs-string">"/ skip=/\\"</span></span>/ <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=/<span class="hljs-string"><span class="hljs-string">"/ contains=jsEscapeSymbol,jsDoubleQuoteEscape syn region jsString start=/'/ skip=/\\'/ end=/'/ contains=jsEscapeSymbol,jsSingleQuoteEscape syn match jsEscapeSymbol /\\[ntrb]/ contained syn match jsSingleQuoteEscape /\\'/ contained syn match jsDoubleQuoteEscape /\\"</span></span>/ contained syn <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> jsFunction /\w\+\((\)\@=/ syn <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> jsFunction /\(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>\s\+\)\@&lt;=\w\+/ <span class="hljs-string"><span class="hljs-string">"  /* * syn region jsComment start=/\/\*/ end=/\*\// "</span></span>  // syn region jsComment <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>=/\/\// <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>=/$/ syn keyword jsKeyword <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> throw catch <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsKeyword Keyword hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsString <span class="hljs-keyword"><span class="hljs-keyword">String</span></span> hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsEscapeSymbol jsEscape hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsDoubleQuoteEscape jsEscape hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsSingleQuoteEscape jsEscape hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsEscape Keyword hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsComment <span class="hljs-keyword"><span class="hljs-keyword">Comment</span></span> hi <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> jsFunction <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-string"><span class="hljs-string">",     javascript   let b:current_syntax="</span></span>javascript<span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre><br><br><h2>  And lastly </h2><br><br>  If the language for which you are highlighting is not important register - use the command <pre> <code class="hljs objectivec">syn <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ignore</code> </pre>  at the beginning of the description of the backlight. <br><br>  When editing the backlight, you want to constantly see the result.  To do this, open the coloring text in another buffer and when you want to update the result just enter: e or: syn off | syn on <br><br>  UPD: Thanks to <a href="http://habrahabr.ru/users/goder/" class="user_link">Goder</a> for a large number of comments about errors in the article :) </div><p>Source: <a href="https://habr.com/ru/post/140161/">https://habr.com/ru/post/140161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140152/index.html">If ... else conditions</a></li>
<li><a href="../140154/index.html">Part number 2. Introduction to folding biochemistry. Mat. criteria</a></li>
<li><a href="../140156/index.html">War is war and dinner is on schedule. Samsung iPad 3 display</a></li>
<li><a href="../140158/index.html">Part number 3. Biochemistry on folding. How to reduce the number of turns the chain?</a></li>
<li><a href="../140159/index.html">Likbez on IonCube</a></li>
<li><a href="../140162/index.html">Uralic fonts with extended Cyrillic for Uralic languages</a></li>
<li><a href="../140163/index.html">The task of the missionaries and cannibals in the language Haskell</a></li>
<li><a href="../140164/index.html">VIM, Django ... Django, VIM</a></li>
<li><a href="../140165/index.html">Kinect for Windows helps pick clothes</a></li>
<li><a href="../140166/index.html">PayPal has released a mobile terminal PayPal Here</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>