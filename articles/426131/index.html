<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Download configuration to FPGA via USB or disassemble FTDI MPSSE</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the life of each pleisovod there comes a time when you need to write your own configuration file loader in the FPGA. I had to participate in the de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Download configuration to FPGA via USB or disassemble FTDI MPSSE</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/dx/i7/px/dxi7pxs820_gc9p_q_1m6zoaakm.jpeg"><br><br>  In the life of each pleisovod there comes a time when you need to write your own configuration file loader in the FPGA.  I had to participate in the development of an educational stand for the department of a technical university.  The stand is designed to study digital signal processing, although in this article it does not really matter.  And what matters is that the stand is based on the FPGA (Altera Cyclone IV), on which, according to the idea of ‚Äã‚Äãthe stand's author, students assemble all kinds of DSP schemes.  The stand is connected to the computer via USB.  Required to download FPGA from a computer via USB. <br><p>  The decision to connect to a PC to use FTDI in its dual channel form - FT2232H was made.  One channel will be used to configure the FPGA, the other can be used for high-speed exchange in FIFO mode. </p><a name="habracut"></a><br><p>  FTDI has a <a href="https://www.ftdichip.com/Products/Modules/DevelopmentModules.htm">MORPH-IC-II</a> debugging board, where the Cyclone II FPGA is <a href="https://www.ftdichip.com/Products/Modules/DevelopmentModules.htm">flashed</a> via USB.  Schematic diagrams are freely available.  The source code of the loader is partially open: the loader itself is available, but all the logic of working with FTDI is moved to a private library and cannot be modified.  To tell the truth, initially I planned to use this bootloader in my project, or, in extreme cases, make my shell based on their dll.  The firmware is loaded into the FPGA in passive serial mode (passive serial - PS), FTDI operates in the MPSSE mode.  The performance of the MORPH-IC-II solution was fully confirmed on the breadboard, but the problem, as it often happens, came from no one was waiting.  It turned out that during the MORPH-IC-II dll operation all the connected FTDI devices are blocked, and as part of the training complex there are two more devices with similar converters: a generator and a signal analyzer.  Simultaneous work with them is not possible.  Damn weird and annoying. </p><br><p>  A similar case is implemented in the guys from the Mars <a href="https://marsohod.org/prodmbftdi">Rover</a> : <a href="https://marsohod.org/prodmbftdi">USB JTAG programmer MBFTDI</a> .  There, FTDI is also used in the MPSSE mode, but unlike MORPH-IC-II, work with FPGAs occurs in the JTAG mode.  The source code is freely available, but I did not find a clear indication of their status (license).  Therefore, I did not raise my hand in a commercial project. </p><br><p>  I will correct such a mistake, everything that will be presented within the framework of this article is laid out in an open repository under the BSD license. </p><br><h2 id="zagruzka-fayla-konfiguracii-v-mikroshemu-plis">  Downloading the configuration file to the FPGA chip </h2><br><p>  The first step is to deal with the FPGA boot mode.  For those who are just starting to get acquainted with the topic, I will spend a little excursion.  Although the Altera (Intel) FPGA of the Cyclone IV E family is installed on my board, the boot methods are similar for the entire FPGA Cyclone group, and it is suspected that they are suitable for many other families in one form or another. </p><br><p>  FPGA of this type uses volatile SRAM to store configuration data.  This configuration data defines the functionality of the final device.  In professional jargon, this data is often referred to as "firmware."  Thus, the firmware is stored in a special RAM and each time the device is turned on it must be loaded into the FPGA chip.  There are several ways (configuration schemes) with which the firmware can be loaded into SRAM (the list is relevant for Cyclone IV E): </p><br><ol><li>  Active serial (AS). </li><li>  Active parallel (Active parallel (AP)). </li><li>  Passive serial (Passive serial (PS)). </li><li>  Fast passive parallel (FPP)). </li><li>  JTAG. </li></ol><br><p>  The choice of a specific mode of loading is carried out using the external conclusions of the FPGA (MSEL group).  JTAG mode is always available.  Active mode implies that when powering the FPGA it reads data from external memory (serial or parallel) independently.  In the passive mode, the FPGA waits for the external media to proactively transfer configuration data to it.  These schemes fit well into the Master (Master) Slave concept.  In active modes, FPGA acts as a master, and in passive modes - as a slave. </p><br><p>  In this task, not the FPGA, but the user must decide when the firmware should be updated, therefore the download mode should be passive.  And to save the legs of the chip, we select the serial interface.  Passive sequential (PS) mode and JTAG are suitable here.  The logic of JTAG is somewhat more complicated, so we will focus on the first option. <br>  The figure below shows the scheme of connecting the FPGA to an external controller for downloading in PS mode. </p><br><img width="400" src="https://habrastorage.org/webt/q-/rj/pe/q-rjpeqe5y8ojlu8ywedoejklxq.png"><br><p>  To begin configuration, the external master controller must generate a low to high transition on the <em>nCONFIG</em> line.  As soon as the FPGA is ready to receive data, it will form a high level on the <em>nSTATUS</em> line.  After that, the master can start transmitting data on the <em>DATA [0] line</em> , and the corresponding clock pulses - on the <em>DCLK</em> line.  The data must be transmitted to the target device until a high level is established on the <em>CONF_DONE</em> line (or the data does not run out), and the FPGA goes into the initialization state.  It should be noted that after <em>CONF_DONE is</em> set to one, two more clock pulses must be applied in order for the FPGA to initialize. </p><br><p>  The data is transmitted by the least significant digit ( <abbr title="Least Significant Bit">LSB</abbr> ) ahead, that is, if the configuration file contains the sequence 02 1B EE 01 FA (take the example as it is from the Handbook), a sequence should be formed on the data line: </p><br><pre><code class="hljs">0100-0000 1101-1000 0111-0111 1000-0000 0101-1111</code> </pre> <br><p>  Thus, only five lines are used: the <em>DATA [0]</em> and <em>DCLK lines</em> for serial transmission, the <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE lines</em> for control. <br>  At its core, the PS mode is nothing more than SPI with additional flag manipulation. <br>  The data transfer rate should be lower than the maximum frequency specified in the documentation; for the Cyclone IV E project used in the project, it is 66 MHz. </p><br><p>  The minimum transmission frequency does not exist, in theory it is possible to suspend the configuration indefinitely.  This gives excellent opportunities for step-by-step debugging with the participation of an oscilloscope, which we will certainly use. </p><br><p>  The figure below shows the timing diagram of the interface with the most significant timings. </p><br><img width="720" src="https://habrastorage.org/webt/54/et/uy/54etuy0yva1est_qtdqp9yopqj8.png"><br><h2 id="hitryy-zver-mpsse">  Sly Beast MPSSE </h2><br><p>  Consider the operation of FTDI in MPSSE mode.  The MPSSE (Multi-Protocol Synchronous Serial Engine) mode, in my opinion, is a more or less successful attempt to create some kind of serial interface designer, give the developer the opportunity to implement widely used data transfer protocols such as SPI, I2C, JTAG, 1-wire and many others based on them. </p><br><p>  Currently, the mode is available for ICs: FT232H, FT2232D, FT2232H, FT4232H.  I use the FT2232H in my project, so I‚Äôm talking more about it.  For MPSSE mode, 16 legs are allocated, divided into two bytes: low L and high H. Each byte can be read or set.  The four lower legs of the byte L have special functions ‚Äî sequential data transfer can occur through them.  Each foot can be configured as an input or output, a default value can be set for output.  For serial transmission, the order of the bits ( <abbr title="Most Significant Bit">MSB</abbr> / <abbr title="Least Significant Bit">LSB</abbr> ), the length of the transmitted word, the frequency of clock pulses, the clock edge ‚Äî forward (Rising) or rear (Falling) is configured; you can choose to transmit only clock pulses without data, or you can choose 3-phase clock (relevant for I2C) and much more. </p><br><p>  Gently proceed to programming.  There are two alternative ways of software interaction with FTDI chips: first, let's call it classic, in this case, when connected to the USB port, the chip in the system is defined as a virtual serial port (COM), the operating system uses the Virtual COM Port (VCP) driver.  All further programming is no different from programming a classic COM port: opened - transmitted / counted - closed.  And this is true for various operating systems, including Linux and Mac OS.  However, with this approach, it will not be possible to realize all the capabilities of the FTDI controller - the chip will work as a USB-UART adapter.  The second method is provided by the proprietary library FTD2XX, this interface provides special functions that are not available in the standard API COM port, in particular, setting and using special modes of operation are available, such as MPSSE, 245 FIFO, Bit-bang.  The FTD2XX API library is well documented by the <a href="https://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer%27s_Guide(FT_000071).pdf">Software Application Development D2XX Programmer's Guide</a> , widely and for a long time known in narrow circles.  And yes, FTD2XX is also available for various operating systems. </p><br><p>  The FTDI developers faced the task of putting a relatively new MPSSE into the existing D2XX software interaction model.  And they succeeded; to work in the MPSSE mode, the same set of functions is used as for the other "classic" modes, the same FTD2XX API library is used. </p><br><p>  In short, the algorithm of operation in the MPSSE mode can be described as follows: </p><br><ol><li>  Find the device in the system and open it. </li><li>  Perform the initial chip initialization and transfer it to the MPSSE mode. </li><li>  Configure MPSEE operation mode. </li><li>  Direct work with data: transmit, receive, manage GPIO - we implement the target exchange protocol. </li><li>  Close the device. </li></ol><br><h2 id="pishem-zagruzchik">  We write the loader </h2><br><p>  We proceed to the practical part.  In my experiments as <abbr title="Integrated Development Environment">IDE,</abbr> I will use Eclipse version Oxygen.3a Release (4.7.3a), as a compiler - mingw32-gcc (6.3.0).  Win7 operating system. </p><br><p>  From the <a href="https://www.ftdichip.com/Drivers/D2XX.htm">FTDI</a> website we download the latest current version of the driver for your operating system.  In the archive we find the header file ftd2xx.h with a description of all API functions.  The API itself is implemented as ftd2xx.dll, but we will leave the dynamic import for later, and use static linking: we will need the ftd2xx.lib library file.  For my case, ftd2xx.lib is in the i386 directory. </p><br><p>  In Eclipse, create a new C project.  Creating a <em>makefile</em> can be trusted with IDE.  In the link settings, we specify the path and name of the ftd2xx library (I transferred the required files to the project directory in the ftdi daddy).  I will not focus on the specifics of setting up a project for Eclipse, since I suspect that most people use other environments and compilers for programming under Win. </p><br><h3 id="punkt-pervyy-nayti-devays-i-otkryt-ego">  Point one.  Find a device and open it. </h3><br><p>  FTD2XX API allows you to open a chip using one or another known information about it.  This can be its serial number in the system: the first FTDI chip connected will take the number 0, the next 1, and so on.  The number in the system is determined by the order of connection of microcircuits, to put it mildly, this is not always convenient.  To open a chip by number, the <code>FT_Open</code> function is <code>FT_Open</code> .  You can open the chip by its serial number ( <code>FT_OPEN_BY_SERIAL_NUMBER</code> ), description ( <code>FT_OPEN_BY_DESCRIPTION</code> ) or by location ( <code>FT_OPEN_BY_LOCATION</code> ), for this the function <code>FT_OpenEx</code> is <code>FT_OpenEx</code> .  The serial number and description are stored in the internal memory of the chip and can be recorded there during the manufacture of the device in which FTDI is installed.  The description, as a rule, characterizes the type of instrument or family, and the serial number must be unique for each product.  Therefore, the most convenient way to identify the devices supported by the developed program is its description.  We will open the FTDI chip by description (descriptor).  In fact, if we initially know the chip descriptor string, then we don‚Äôt need to search for a device in the system, however, as an experiment, we will derive all devices connected to a computer with FTDI.  Using the <code>FT_CreateDeviceInfoList</code> function, <code>FT_CreateDeviceInfoList</code> will create a detailed list of connected chips, and with the help of the <code>FT_GetDeviceInfoList</code> function, <code>FT_GetDeviceInfoList</code> consider it. </p><br><div class="spoiler">  <b class="spoiler_title">A list of connected devices.</b>  <b class="spoiler_title">Listing:</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus == FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Number of devices is %d\n"</span></span>,numDevs); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numDevs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allocate storage for list based on numDevs devInfo = (FT_DEVICE_LIST_INFO_NODE*)malloc(sizeof(FT_DEVICE_LIST_INFO_NODE)*numDevs); ftStatus = FT_GetDeviceInfoList(devInfo,&amp;numDevs); if (ftStatus == FT_OK) for (int i = 0; i &lt; numDevs; i++) { printf("Dev %d:\n",i); printf(" Flags=0x%x\n",devInfo[i].Flags); printf(" Type=0x%x\n",devInfo[i].Type); printf(" ID=0x%x\n",devInfo[i].ID); printf(" LocId=0x%x\n",devInfo[i].LocId); printf(" SerialNumber=%s\n",devInfo[i].SerialNumber); printf(" Description=%s\n",devInfo[i].Description); }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Hail my zoo</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">D:\workspace\ftdi-mpsse-ps\<span class="hljs-keyword"><span class="hljs-keyword">Debug</span></span>&gt;ftdi-mpsse-ps.exe Number <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> devices <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Dev <span class="hljs-number"><span class="hljs-number">0</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x5</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036001</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x214</span></span> SerialNumber = AI043NNV Description = FT232R USB UART Dev <span class="hljs-number"><span class="hljs-number">1</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2121</span></span> SerialNumber = L731T70OA Description = LESO7 A Dev <span class="hljs-number"><span class="hljs-number">2</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x6</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036010</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x2122</span></span> SerialNumber = L731T70OB Description = LESO7 B Dev <span class="hljs-number"><span class="hljs-number">3</span></span>: Flags = <span class="hljs-number"><span class="hljs-number">0x2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> = <span class="hljs-number"><span class="hljs-number">0x8</span></span> ID = <span class="hljs-number"><span class="hljs-number">0x4036014</span></span> LocId = <span class="hljs-number"><span class="hljs-number">0x213</span></span> SerialNumber = FTYZ92L6 Description = LESO4<span class="hljs-number"><span class="hljs-number">.1</span></span>_ER</code> </pre> </div></div><br><p>  Three devices with FTDI chips are connected to my PC: FT232RL (type 0x5), FT2232H (type 0x6) and FT232H (tepe 0x8).  The FT2232H chip in the system was displayed as two independent devices (Dev 1 and Dev 2).  The PS FPGA interface is connected to Dev 2, its dexryptor is ‚ÄúLESO7 B‚Äù.  Open it: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//Open a device with device description "LESO7 B" ftStatus = FT_OpenEx("LESO7 B", FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); if (ftStatus != FT_OK) { printf ("pen failure\r\n"); return -1; }</span></span></code> </pre> <br><p>  Most API functions return the status of their call of type <code>FT_STATUS</code> , all possible values ‚Äã‚Äãare described as enum in the header file.  There are many of them, but it is enough to know that the value of <code>FT_OK</code> is the absence of error, all other values ‚Äã‚Äãare error codes.  A good programming style will check the status value after each API function call. </p><br><p>  If the device was successfully opened, then in the variable <code>ftHandle</code> there appears some value other than zero, some equivalent of the file descriptor, which is used when working with files.  The resulting handle establishes communication with the hardware interface and must be used when calling all library functions that require access to the chip. <br>  In order to prove in practice the working capacity of the system for the current stage, we should go directly to point five of our algorithm. </p><br><p>  After completing work with the chip, it must be closed.  The function <code>FT_Close</code> used for this: </p><br><pre> <code class="cpp hljs">FT_Close(ftHandle);</code> </pre> <br><h3 id="punkt-2-inicializiruem-chip-i-vklyuchaem-mpsse">  Item 2. Initialize the chip and enable MPSSE </h3><br><p>  The setting is typical for most modes and is well described in the <a href="https://www.ftdichip.com/Support/Documents/AppNotes/AN_135_MPSSE_Basics.pdf">AN_135 FTDI MPSSE Basics</a> documentation. </p><br><ol><li>  Perform a reset (resets) chip.  Function <code>FT_ResetDevice</code> . </li><li>  In case there is some garbage lying around in the receive buffer, we clear it.  <code>FT_Purge</code> function. </li><li>  Adjust the size of buffers for reading and writing.  <code>FT_SetUSBParameters</code> function. </li><li>  Disable parity check.  <code>FT_SetChars</code> . </li><li>  We set the read and write timeouts.  By default, timeouts are disabled, we enable timeout for transmission.  <code>FT_SetTimeouts</code> . </li><li>  We configure the waiting time for sending a packet from the chip to the host.  By default, 16 ms, we accelerate to 1 ms.  <code>FT_SetLatencyTimer</code> . </li><li>  Enable stream control for inbound requests.  <code>FT_SetFlowControl</code> . </li><li>  Everything is ready to activate the MPSSE mode.  We reset the MPSSE controller.  Use the function <code>FT_SetBitMode</code> , set the mode to 0 (mode = 0, mask = 0). </li><li>  Enable MPSSE mode.  Function <code>FT_SetBitMode</code> - mode = 2, mask = 0. </li></ol><br><p>  The opening and configuration of the chip are combined into the <code>MPSSE_open</code> function, and as a parameter, we pass the string with the handle of the device being opened: </p><br><div class="spoiler">  <b class="spoiler_title">Listing MPSSE_open</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_open</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *description)</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; ftStatus = FT_OpenEx(description, FT_OPEN_BY_DESCRIPTION, &amp;ftHandle); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ftStatus != FT_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open failure\r\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FT_DEVICE_NOT_OPENED; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (<span class="hljs-string"><span class="hljs-string">"open OK, %d\r\n"</span></span>, ftHandle); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"\nConfiguring port for MPSSE use...\n"</span></span>); ftStatus |= FT_ResetDevice(ftHandle); <span class="hljs-comment"><span class="hljs-comment">//Purge USB receive buffer first by reading out all old data from FT2232H receive buff: ftStatus |= FT_Purge(ftHandle, FT_PURGE_RX); //Set USB request transfer sizes to 64K: ftStatus |= FT_SetUSBParameters(ftHandle, 65536, 65536); //Disable event and error characters: ftStatus |= FT_SetChars(ftHandle, 0, 0, 0, 0); //Sets the read and write timeouts in milliseconds: ftStatus |= FT_SetTimeouts(ftHandle, 0, 5000); //Set the latency timer to 1mS (default is 16mS): ftStatus |= FT_SetLatencyTimer(ftHandle, 1); //Turn on flow control to synchronize IN requests: ftStatus |= FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, 0x00, 0x00); //Reset controller: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_RESET); //Enable MPSSE mode: ftStatus |= FT_SetBitMode(ftHandle, 0x0, FT_BITMODE_MPSSE); if (ftStatus != FT_OK) { printf("Error in initializing the MPSSE %d\n", ftStatus); return FT_OTHER_ERROR; } Sleep(50); // Wait for all the USB stuff to complete and work return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-3-nastroim-rezhim-raboty-mpsee">  Item 3. Configure MPSEE operation mode. </h3><br><p>  Actually, at this stage, the MPSSE processor is activated and ready to receive commands.  Commands are byte sequences, the first byte of which is "op-code", followed by the command parameters.  The command may have no parameters and consist of one "op-code".  Commands are transmitted using the <code>FT_Write</code> function, the response from the MPSSE processor can be obtained using the <code>FT_Read</code> function. </p><br><p>  After each command sending, it is useful to subtract the processor's response, since in case of an incorrect command, the answer may contain an error message - the 0xFA symbol.  The "bad command - 0xFA response" mechanism can be used to synchronize an application program with an MPSSE processor.  If everything is OK, then the chip will return the symbol 0xFA to the obviously erroneous command.  Op-code is described in <a href="https://www.ftdichip.com/Support/Documents/AppNotes/AN_108_Command_Processor_for_MPSSE_and_MCU_Host_Bus_Emulation_Modes.pdf">Command Processor for MPSSE and MCU Host Bus Emulation Mode</a> . <br>  MPSSE tuning is reduced to setting the data transfer rate, direction and initial states of the I / O lines. <br>  Consider setting the MPSSE processor's transfer rate.  The setting for chips with support for Full-speed mode only (FT2232 <strong>D</strong> ) and chips with High-speed (FT2232 <strong>H</strong> , FT232H, FT4232H) occurs somewhat differently.  In the outdated FT2232D, a 12 MHz clock is used, and in modern ones - 60 MHz.  Hence the formula for calculating the data transfer rate: </p><br><p></p><p><math></math><script type="math/tex;mode=display"> Data Speed ‚Äã‚Äã= \ frac {f_ {core}} {(1 + Divisor) \ cdot 2} </script></p><br><p>  where <em>f <sub>core</sub></em> is the FTDI <em><sub>core</sub></em> frequency, <em>Divisor</em> is a two-byte divider, which, in fact, sets the data clocking frequency. <br>  As a result, if the divisor is zero, then the maximum data transfer rate will be 30 Mbps, and the minimum data transfer rate will be at 65535 divider - 458 bps. <br>  The calculation of the divisor is entrusted to the preprocessor.  The macro returns the divisor: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FCORE 60000000ul #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV(data_speed) ((FCORE/(2*data_speed)) -1)</span></span></code> </pre> <br><p>  And these two macros return the high and low bytes of the divider, respectively: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_H(data_speed) ((MPSSE_DATA_SPEED_DIV(data_speed)) &gt;&gt; 8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MPSSE_DATA_SPEED_DIV_L(data_speed) \ (MPSSE_DATA_SPEED_DIV(data_speed) - (MPSSE_DATA_SPEED_DIV_H(data_speed)&lt;&lt; 8))</span></span></code> </pre> <br><p>  In addition, it should be noted that in modern chips for compatibility with the old man FT2232D there is an additional divider of 5, which turns 60 MHz into 12 MHz.  This divider is activated by default, in our case it should be disabled. <br>  We find the corresponding op-code (0x8A) and a helmet command to the processor: </p><br><div class="spoiler">  <b class="spoiler_title">Listing sending command</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; DWORD dwNumBytesToRead, dwNumBytesSent = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesRead = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x8A</span></span>; ftStatus = FT_Write(ftHandle, byOutputBuffer, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Error\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("dwNumBytesToRead = %d:", dwNumBytesToRead); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK;</span></span></code> </pre> </div></div><br><p>  As an experiment, instead of the actual command 0x8A, send the value 0xFE, which does not correspond to any op-code, console output: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">dwNumBytesToRead</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>: FAh FEh</code> </pre> <br><p>  The processor returned two bytes, the byte "bad command" - 0xFA and the value of this "bad" command.  Thus, by sending several commands at once, we will be able not only to track the fact of the error itself, but also to understand on which command this error occurred. <br>  In order not to deal with "magic numbers" in the future, we will arrange all op-code in the form of constants and put it in a separate header file. <br>  To fully configure the mode, you must specify the direction of the I / O lines and their default value.  Let us turn to the concept of connection.  In order not to clutter up an already bloated article, I crossed out a fragment of the scheme of interest: </p><br><img width="500" src="https://habrastorage.org/webt/sc/6g/no/sc6gnoqy5_eyc5lsjpmlqbnl2-m.png"><br><p>  The <em>DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG lines</em> must be configured as outputs, and the <em>nSTATUS</em> , <em>CONF_DONE lines</em> as inputs.  According to the diagram, we determine what initial states the lines should have.  For clarity, the pinout of the scheme is summarized in the table: </p><br><table><thead><tr><th>  FPGA pin </th><th>  Pin name </th><th>  Pin </th><th>  MPSSE </th><th>  Direction </th><th>  default </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Out </td><td>  0 </td></tr><tr><td>  DATA [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Out </td><td>  one </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Out </td><td>  one </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  In </td><td>  one </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  In </td><td>  one </td></tr></tbody></table><br><p>  All used lines are located on the low byte of the MPSSE port.  To set the value, use op-code 0x80.  This command assumes two arguments: the first following the op-code byte is a bitwise value, and the second is the direction (one is the port to be output, zero is the port to be input). <br>  As part of the struggle with the "magic number", all the ordinal numbers of the lines and their default values ‚Äã‚Äãwill be in the form of constants: </p><br><div class="spoiler">  <b class="spoiler_title">Define ports</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT_DIRECTION (0x07) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DCLK (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DATA0 (1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_CONFIG (2) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> N_STATUS (3) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CONF_DONE (4) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// initial states of the MPSSE interface #define DCLK_DEF (1) #define DATA0_DEF (0) #define N_CONFIG_DEF (1) #define N_STATUS_DEF (1) #define CONF_DONE_DEF (1)</span></span></span></span></code> </pre> </div></div><br><p>  It remains only to make sure that the TDI - TDO loop is disabled (can be activated for testing) and issue a separate function: </p><br><div class="spoiler">  <b class="spoiler_title">Listing MPSSE_setup function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_setup</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], byInputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Multple commands can be sent to the MPSSE with one FT_Write dwNumBytesToSend = 0; // Start with a fresh index byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_DIVIDER_5; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_ADAPTIVE_CLK; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_3PHASE_CLOCKING; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set TCK frequency // Command to set clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_TCK_DIVISION; // Set ValueL of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_L(DATA_SPEED); // Set 0xValueH of clock divisor: byOutputBuffer[dwNumBytesToSend++] = MPSSE_DATA_SPEED_DIV_H(DATA_SPEED); ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - low byte, both pin directions and output values /* | FPGA pin | Pin Name | Pin | MPSSE | Dir | def | | --------- | -------- | --- | ------ | --- | --- | | DCLK | BDBUS0 | 38 | TCK/SK | Out | 0 | | DATA[0] | BDBUS1 | 39 | TDI/DO | Out | 1 | | nCONFIG | BDBUS2 | 40 | TDO/DI | Out | 1 | | nSTATUS | BDBUS3 | 41 | TMS/CS | In | 1 | | CONF_DONE | BDBUS4 | 43 | GPIOL0 | In | 1 | */ // Configure data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; // Initial state config above: byOutputBuffer[dwNumBytesToSend++] = (DCLK_DEF &lt;&lt; DCLK) | (DATA0_DEF &lt;&lt; DATA0) | (N_CONFIG_DEF &lt;&lt; N_CONFIG) | (N_STATUS_DEF &lt;&lt; N_STATUS) | (CONF_DONE_DEF &lt;&lt; CONF_DONE); // Direction config above: byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Send off the low GPIO config commands dwNumBytesToSend = 0; // Reset output buffer pointer // Set initial states of the MPSSE interface // - high byte, all input, Initial State -- 0. // Send off the high GPIO config commands: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_HIGHBYTE; byOutputBuffer[dwNumBytesToSend++] = 0x00; byOutputBuffer[dwNumBytesToSend++] = 0x00; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); // Disable loopback: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_DISABLE_LOOP_TDI_TDO; ftStatus |= FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(2); // Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, byInputBuffer, dwNumBytesToRead, &amp;dwNumBytesRead); if (ftStatus != FT_OK) { printf("Unknown error in initializing the MPSSE\r\n"); return FT_OTHER_ERROR; } else if (dwNumBytesToRead &gt; 0) { printf("Error in initializing the MPSSE, bad code:\r\n"); for ( int i = 0; i &lt; dwNumBytesToRead; i++) printf (" %02Xh", byInputBuffer[i]); printf("\r\n"); return FT_INVALID_PARAMETER; } return FT_OK; }</span></span></code> </pre> </div></div><br><h3 id="punkt-4-realizuem-protokol-zagruzki">  Item 4. We implement the download protocol </h3><br><p>  It seems everything is ready for practical experiments.  First, we check that the initialization is performed correctly, in the main program body we call <code>MPSSE_open()</code> and <code>MPSSE_setup()</code> , and before closing the device ( <code>FT_Close</code> ) we place an empty <code>getchar()</code> .  Run the program and use the oscilloscope to make sure that the default levels are set on all the PS lines.  By changing the value of these levels in the initialization (nothing terrible will happen with the FPGA), we make sure that the desired MPSSE processor is the real thing - everything works adequately and you can proceed to the data transfer. <br>  Sequential sending and receiving of data is performed in command mode using the same op-code.  The first byte of the command is the op-code, which determines the type of operation, followed by the length of the transmitted or received sequence and, if it is a transmission, the data itself.  The MPSSE processor can transmit and receive data, also do it simultaneously.  The transmission may be either the least significant bit forward (LSB) or the most significant (MSB).  Data transmission can occur either on the leading or trailing edge of clock pulses.  For each combination of options there is its own op-code, each bit of op-code describes the mode of operation: </p><br><table><thead><tr><th>  Bit </th><th>  Function </th></tr></thead><tbody><tr><td>  0 </td><td>  Synchronization on the front of the record: 0 - positive, 1 - negative </td></tr><tr><td>  one </td><td>  1 - work with bytes, 0 - work with bits </td></tr><tr><td>  2 </td><td>  Synchronization on the front for reading: 0 - positive, 1 - negative </td></tr><tr><td>  3 </td><td>  Transfer Mode: 1 - LSB, 0 - MSB first </td></tr><tr><td>  four </td><td>  TDI data transmission </td></tr><tr><td>  five </td><td>  Reading data from TDO line </td></tr><tr><td>  6 </td><td>  TMS data transfer </td></tr><tr><td>  7 </td><td>  Must be 0, otherwise it is a different group of commands. </td></tr></tbody></table><br><p>  When configuring the FPGAs using the PS scheme, data transfer occurs on the leading edge in LSB mode.     ,   ,    op-code   0001_1000b  0x18   .       ( ,   ),    .    :     .  ,      ,     0,    65536,     65535. ,     .        <code>MPSSE_send</code> . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_send</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BYTE byBuffer[<span class="hljs-number"><span class="hljs-number">65536</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_send</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE * buff, DWORD dwBytesToWrite)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>, dwNumBytesSent, bytes; FT_STATUS ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Output on rising clock, no input // MSB first, clock a number of bytes out byBuffer[dwNumBytesToSend++] = MPSSE_CMD_LSB_DATA_OUT_BYTES_POS_EDGE; // 0x18 bytes = dwBytesToWrite -1; byBuffer[dwNumBytesToSend++] = (bytes) &amp; 0xFF; // Length L byBuffer[dwNumBytesToSend++] = (bytes &gt;&gt; 8) &amp; 0xFF; // Length H memcpy(&amp;byBuffer[dwNumBytesToSend], buff, dwBytesToWrite); dwNumBytesToSend += dwBytesToWrite; ftStatus = FT_Write(ftHandle, byBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if (ftStatus != FT_OK ) { printf ("ERROR send data\r\n"); return ftStatus; } else if (dwNumBytesSent != dwNumBytesToSend) { printf ("ERROR send data, %d %d\r\n", dwNumBytesSent, dwNumBytesToSend); } return FT_OK; }</span></span></code> </pre> </div></div><br><p>        ‚Äî      65 ,   - ,        op-code   .   <code>byBuffer</code> ,             <code>buff</code> ,  ,      op-code  .    ,     ,         . <br>    ,        ""  ,       25 , ,  ,     1  ( ,     <code>#define DATA_SPEED 1000000ul</code> ).   : </p><br><pre> <code class="hljs objectivec">BYTE byOutputBuffer[] = {<span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x1B</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0x01</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">MPSSE_send</span></span>(byOutputBuffer, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(byOutputBuffer));</code> </pre> <br><p>    ( ): <br> <a href=""><img src="https://habrastorage.org/webt/bp/gp/es/bpgpesvsoradzqfecft07bdjk-u.png"></a> </p><br><p>   ‚Äî    <em>DATA[0]</em> ,   ‚Äî <em>DCLK</em> .             .  ,  ,   . </p><br><p>      ,     SPI  ( ).  ,     PS,     .   <em>nCONFIG</em> , <em>nSTATUS</em> , <em>CONF_DONE</em> .   ‚Äî  ,      ,   ‚Äî ,     . </p><br><p>  <code>MPSSE_get_lbyte</code>    ,  ,         . </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_get_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_get_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE *lbyte)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent, dwNumBytesToRead, dwNumBytesRead; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>]; FT_STATUS ftStatus; dwNumBytesToSend = <span class="hljs-number"><span class="hljs-number">0</span></span>; byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_GET_DATA_BITS_LOWBYTE; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); Sleep(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Wait for data to be transmitted and status ftStatus = FT_GetQueueStatus(ftHandle, &amp;dwNumBytesToRead); ftStatus |= FT_Read(ftHandle, lbyte, dwNumBytesToRead, &amp;dwNumBytesRead); if ((ftStatus != FT_OK) &amp; (dwNumBytesToRead != 1)) { printf("Error read Lbyte\r\n"); return FT_OTHER_ERROR; // Exit with error } return FT_OK; }</span></span></code> </pre> </div></div><br><p>  ,  op-code  ,         . ,     -     ,    ,          .    ,   .     <code>MPSSE_set_lbyte</code> : </p><br><div class="spoiler"> <b class="spoiler_title">  MPSSE_set_lbyte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FT_STATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MPSSE_set_lbyte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BYTE lb, BYTE mask)</span></span></span><span class="hljs-function"> </span></span>{ DWORD dwNumBytesToSend, dwNumBytesSent; BYTE byOutputBuffer[<span class="hljs-number"><span class="hljs-number">8</span></span>], lbyte; FT_STATUS ftStatus; ftStatus = MPSSE_get_lbyte(&amp;lbyte); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ftStatus != FT_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ftStatus; <span class="hljs-comment"><span class="hljs-comment">// Set to zero the bits selected by the mask: lbyte &amp;= ~mask; // Setting zero is not selected by the mask bits: lb &amp;= mask; lbyte |= lb; dwNumBytesToSend = 0; // Set data bits low-byte of MPSSE port: byOutputBuffer[dwNumBytesToSend++] = MPSSE_CMD_SET_DATA_BITS_LOWBYTE; byOutputBuffer[dwNumBytesToSend++] = lbyte; byOutputBuffer[dwNumBytesToSend++] = PORT_DIRECTION; ftStatus = FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &amp;dwNumBytesSent); if ((ftStatus != FT_OK) &amp; (dwNumBytesSent != 1)) { printf("Error set Lbyte\r\n"); return FT_OTHER_ERROR; } return FT_OK; }</span></span></code> </pre> </div></div><br><p>   ,     .   :  FTDI;    MPSSE;  rbf-  ,    <em>nCONFIG</em>  ,      <em>N_STATUS</em> ;    rbf-    ;  ,    ,      <em>CONF_DONE</em> .     ,     MPSSE   FTDI       .   ,  <em>nCONFIG</em>      ""  ,     ,        ,     . </p><br><div class="spoiler"> <b class="spoiler_title">  main</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ FT_STATUS ftStatus; BYTE lowByte; DWORD numDevs; <span class="hljs-comment"><span class="hljs-comment">// create the device information list if ( argv[1] == NULL) { printf ("NO file\r\n"); return -1; } frbf = fopen(argv[1],"rb"); if (frbf == NULL) { printf ("Error open rbf\r\n"); return -1; } ftStatus = FT_CreateDeviceInfoList(&amp;numDevs); if ((numDevs == 0) || (ftStatus != FT_OK)) { printf("Error. FTDI devices not found in the system\r\n"); return -1; } ftStatus = MPSSE_open ("LESO7 B"); if (ftStatus != FT_OK) { printf("Error in MPSSE_open %d\n", ftStatus); EXIT(-1); } MPSSE_setup(); if (ftStatus != FT_OK) { printf("Error in MPSSE_setup %d\n", ftStatus); EXIT(-1); } printf ("nConfig -&gt; 0\r\n"); MPSSE_set_lbyte(0, 1 &lt;&lt; N_CONFIG); printf ("nConfig -&gt; 1\r\n"); MPSSE_set_lbyte(1 &lt;&lt; N_CONFIG, 1 &lt;&lt; N_CONFIG); if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { EXIT(-1); } if (((lowByte &gt;&gt; N_STATUS) &amp; 1) == 0) { printf("Error. FPGA is not responding\r\n"); EXIT(-1); } int i = 0; size_t readBytes = 0; // Send the configuration file: do { readBytes = fread(buff, 1, MPSSE_PCK_SEND_SIZE, frbf); if (MPSSE_send(buff, readBytes) != FT_OK) EXIT(-1); putchar('*'); if (!((++i)%16)) printf("\r\n"); } while (readBytes == MPSSE_PCK_SEND_SIZE); printf("\r\n"); memset(buff, 0x00, sizeof(buff)); MPSSE_send(buff, 1); //        ? printf("Load complete\r\n"); // wait CONF_DONE set // A low-to-high transition on the CONF_DONE pin indicates that the configuration is // complete and initialization of the device can begin. i = 0; do { if (MPSSE_get_lbyte(&amp;lowByte) != FT_OK) { printf ("Error read CONF_DONE\r\n"); EXIT(-1); } if (i++ &gt; TIMEOUT_CONF_DONE) { printf ("Error CONF_DONE\r\n"); EXIT(-1); } Sleep(2); } while (((lowByte &gt;&gt; CONF_DONE) &amp; 1) == 0); printf("Configuration complete\r\n"); FT_Close(ftHandle); fclose(frbf); }</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="hljs pgsql">pen "LESO7 B" OK nConfig -&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> nConfig -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ** <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> complete <span class="hljs-keyword"><span class="hljs-keyword">Configuration</span></span> complete</code> </pre> </div></div><br><p>    rbf-  .    .       30 /     . <br>      ,        -  JTAG. </p><br><h3 id="materialy-po-teme">  Materials on the topic </h3><br><ol><li> <a href="https://bitbucket.org/Shamrel/ftdi-mpsse-altera-ps/src/master/">FTDI-MPSSE-Altera PS</a> .   . </li><li> <a href="http://www.labfor.ru/devices/leso7">   </a> .   .       . </li><li> <a href="http://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer%27s_Guide(FT_000071).pdf">Software Application Development D2XX Programmer's Guide</a> .        FTDI.   API D2XX. </li><li> <a href="https://www.ftdichip.com/Support/Documents/AppNotes/AN_135_MPSSE_Basics.pdf">FTDI MPSSE Basics. Application Note AN_135</a> .    .  FTDI MPSSE.      . </li><li> <a href="https://www.ftdichip.com/Support/Documents/AppNotes/AN_108_Command_Processor_for_MPSSE_and_MCU_Host_Bus_Emulation_Modes.pdf">Command Processor for MPSSE and MCU Host Bus Emulation Modes. Application Note AN_108</a> .   op-code.   . </li><li> <a href="https://www.ftdichip.com/Drivers/D2XX.htm">D2XX Drivers</a> .  FTDI. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/426131/">https://habr.com/ru/post/426131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426117/index.html">Ombudsman proposed to block ads with potentially dangerous children's products</a></li>
<li><a href="../426119/index.html">Antiquities: Cryptonomicon Iron</a></li>
<li><a href="../426121/index.html">MC.exe (Message compiler), rc.exe, link.exe to generate .dll for EventMessageFile</a></li>
<li><a href="../426123/index.html">Learn OpenGL. Lesson 6.1. PBR or Physically-correct rendering. Theory</a></li>
<li><a href="../426125/index.html">Career steroids. Elevators</a></li>
<li><a href="../426133/index.html">We get acquainted with the alpha version of snapshots volumes in Kubernetes</a></li>
<li><a href="../426135/index.html">Private cloud for the Internet of Things</a></li>
<li><a href="../426137/index.html">Age of Honesty</a></li>
<li><a href="../426141/index.html">Red Hat replaces Docker with Podman</a></li>
<li><a href="../426143/index.html">3D animation - video or interactive?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>