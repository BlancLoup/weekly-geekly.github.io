<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenGL WBOIT: transparency without sorting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It will focus on ‚ÄúWeighted blended order-independent transparency‚Äù (hereinafter WBOIT) - the technique described in JCGT in 2013 ( link ). 

 When sev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenGL WBOIT: transparency without sorting</h1><div class="post__text post__text-html js-mediator-article">  It will focus on ‚ÄúWeighted blended order-independent transparency‚Äù (hereinafter WBOIT) - the technique described in JCGT in 2013 ( <a href="http://jcgt.org/published/0002/02/09/">link</a> ). <br><a name="habracut"></a><br>  When several transparent objects appear on the screen, the color of the pixel depends on which one is closer to the observer.  Here is the well-known color mixing formula for this case: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;C_&amp;#xA0;{near}&amp;#xA0;\&amp;#xA0;alpha&amp;#xA0;+&amp;#xA0;C_&amp;#xA0;{far}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(1)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) &amp;&amp; (1) \ end {matrix}</font></font></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;C_&nbsp;{near}&nbsp;\&nbsp;alpha&nbsp;+&nbsp;C_&nbsp;{far}&nbsp;(1-&nbsp;\&nbsp;alpha)&nbsp;&amp;&amp;&nbsp;(1)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ begin {matrix} C = C_ {near} \ alpha + C_ {far} (1- \ alpha) && (1) \ end {matrix} </script></p><br>  The order of the fragments is important for it: the color of the near fragment and its opacity are designated as C <sub>near</sub> and <i>Œ±</i> , and the resulting color of all fragments that are located behind it - as C <sub>far</sub> .  Opacity is a property that takes values ‚Äã‚Äãfrom 0 to 1, where 0 means that the object is so transparent that it is not visible, and 1 means that it is so opaque that nothing is visible <i>behind it</i> . <br><br>  To use this formula, you must first sort the fragments by depth.  Imagine how much a headache is associated with this!  In general, sorting should be done in each frame.  If you are sorting objects, then some objects of complex shape will have to be cut into pieces and sorted by depth into cut parts (in particular, for intersecting surfaces, this will definitely have to be done).  If you are sorting fragments, then the sorting will occur in shaders.  This approach is called ‚ÄúOrder-independent transparency‚Äù (OIT), and it uses a coherent list stored in the video card's memory.  Predicting how much memory you have to allocate for this list is almost impossible.  And if there is not enough memory, artifacts will appear on the screen. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Lucky for those who can control how many translucent objects are placed on the stage, and where they are relative to each other.  But if you make a CAD, then you will have as many transparent objects as the user wants, and they will be placed at random. <br><br>  Now you understand the desire of some people to simplify their lives and come up with a formula for mixing colors that does not require sorting.  Such a formula is in the article to which I referred at the beginning.  There are even some formulas there, but the best in the opinion of the authors (and in my opinion too) is this one: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><merror><mtext>\&amp;#xA0;begin&amp;#xA0;{matrix}&amp;#xA0;C&amp;#xA0;=&amp;#xA0;{{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;C_i&amp;#xA0;\&amp;#xA0;alpha_i}&amp;#xA0;\&amp;#xA0;over&amp;#xA0;{\&amp;#xA0;sum_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;\&amp;#xA0;alpha_i}}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i))&amp;#xA0;+&amp;#xA0;C_0&amp;#xA0;\&amp;#xA0;prod_&amp;#xA0;{i&amp;#xA0;=&amp;#xA0;1}&amp;#xA0;^&amp;#xA0;{n}&amp;#xA0;(1-&amp;#xA0;\&amp;#xA0;alpha_i)&amp;#xA0;&amp;amp;&amp;amp;&amp;#xA0;(2)&amp;#xA0;\&amp;#xA0;end&amp;#xA0;{matrix}</mtext></merror></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><span class="noError" aria-hidden="true" style="display: inline-block;">\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><merror><mtext>\&nbsp;begin&nbsp;{matrix}&nbsp;C&nbsp;=&nbsp;{{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;C_i&nbsp;\&nbsp;alpha_i}&nbsp;\&nbsp;over&nbsp;{\&nbsp;sum_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;\&nbsp;alpha_i}}&nbsp;(1-&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i))&nbsp;+&nbsp;C_0&nbsp;\&nbsp;prod_&nbsp;{i&nbsp;=&nbsp;1}&nbsp;^&nbsp;{n}&nbsp;(1-&nbsp;\&nbsp;alpha_i)&nbsp;&amp;&amp;&nbsp;(2)&nbsp;\&nbsp;end&nbsp;{matrix}</mtext></merror></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> \ begin {matrix} C = {{\ sum_ {i = 1} ^ {n} C_i \ alpha_i} \ over {\ sum_ {i = 1} ^ {n} \ alpha_i}} (1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i)) + C_0 \ prod_ {i = 1} ^ {n} (1- \ alpha_i) && (2) \ end {matrix} </script></p><br><img src="https://habrastorage.org/webt/65/b9/oz/65b9ozbni1afvlupqfso9uve2ey.png" width="1000"><br><br>  In the screenshot - a group of semi-transparent triangles arranged in four layers in depth.  On the left, they are rendered using the WBOIT technique.  On the right is a picture obtained using formula (1), a classic blending of colors, taking into account the order of the fragments.  Further I will call it CODB (Classic order-dependent blending). <br><br>  Before we start rendering transparent objects, we need to render everything that is not transparent.  After that, transparent objects are rendered with a depth test, but without writing to the depth buffer (this is done like this: <code>glEnable(GL_DEPTH_TEST); glDepthMask(GL_FALSE);</code> ).  That is, this is what happens at the point with some screen coordinates (x, y): transparent fragments that are closer to opaque pass the depth test, regardless of how they are located in depth relative to the already drawn transparent fragments, and transparent fragments that are further opaque, do not pass the depth test, and, accordingly, are discarded. <br><br>  C <sub>0</sub> in the formula (2) is the color of the opaque fragment, on top of which transparent fragments are drawn, of which we have n pieces, indicated by indices from 1 to n.  C <sub>i</sub> is the color of the i-th transparent fragment, <i>Œ± <sub>i</sub></i> is its opacity. <br><br>  If you look closely, then formula (2) is a little bit like formula (1).  If you imagine that <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  Is C <sub>near</sub> , C <sub>0</sub> is C <sub>far</sub> , and <img src="https://habrastorage.org/webt/li/tu/em/lituem-w98r3gl7cee5184y6b7q.png" width="100">  - this is <i>Œ±</i> , then this will be the 1st formula, one to one.  And true <img src="https://habrastorage.org/webt/xz/w1/z8/xzw1z8f-nsnfuokbqssbhic6tpw.png" width="60">  - this is the weighted average of the colors of the transparent fragments (the center of mass is determined by the same formula in mechanics), it will go beyond the color of the near fragment C <sub>near</sub> .  C <sub>0</sub> is the color of the opaque fragment located behind all the fragments for which we have calculated this weighted average, and it will pass for C <sub>far</sub> .  That is, we replaced all transparent fragments with one ‚Äúaveraged‚Äù fragment and applied the standard color mixing formula - formula (1).  What is this clever formula for <i>Œ±</i> that the authors of the original article offer us? <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>n</mi></mrow></msubsup><mo stretchy=&quot;false&quot;>(</mo><mn>1</mn><mo>&amp;#x2212;</mo><mtext>&amp;#xA0;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="34.233ex" height="2.901ex" viewBox="0 -832 14738.9 1249" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-61" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-6C" x="779" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-70" x="1078" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-68" x="1581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-61" x="2158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-3D" x="2965" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-31" x="4021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-2212" x="4744" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-70" x="5995" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-72" x="6498" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-6F" x="6950" y="0"></use><g transform="translate(7435,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-64" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-6E" x="741" y="499"></use><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-31" x="1124" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-28" x="9204" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-31" x="9594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-2212" x="10316" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-61" x="11567" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-6C" x="12097" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-70" x="12395" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-68" x="12899" y="0"></use><g transform="translate(13475,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-61" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMATHI-69" x="748" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/457284/&amp;xid=17259,15700023,15700043,15700186,15700191,15700256,15700259,15700262&amp;usg=ALkJrhgaJ71g5AOJkGWj8JeUmpklKUfziw#MJMAIN-29" x="14349" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>=</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>n</mi></mrow></msubsup><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>&nbsp;</mtext><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> \ alpha = 1- \ prod_ {i = 1} ^ {n} (1- \ alpha_i) </script></p><br>  This is a scalar function in n-dimensional space, so recall the differential analysis of functions of several variables.  Given that all <i>Œ± <sub>i</sub></i> belong to the range from 0 to 1, the partial derivative with respect to any variable will always be a non-negative constant.  This means that the opacity of the ‚Äúaveraged‚Äù fragment increases as the opacity of any of the transparent fragments increases, and this is exactly what we need.  In addition, it increases linearly. <br><br>  If the opacity of a fragment is 0, then it is not visible at all, it does not affect the resulting color. <br><br>  If the opacity of at least one fragment is equal to 1, then <i>Œ±</i> is equal to 1. That is, the opaque fragment becomes invisible, which is generally good.  Only here the transparent fragments located behind the fragment with opacity = 1 still shine through it and affect the resulting color: <br><br><img src="https://habrastorage.org/webt/3s/lm/3y/3slm3yxglf43xno7dyqu8g7ua-o.png" width="300"><br><br>  There is an orange triangle on top, green underneath, and gray and cyan beneath the green, all on a black background.  In blue, the opacity = 1, all others - 0.5.  The picture on the right is what should be.  As you can see, WBOIT looks disgusting.  The only place where the normal orange color appears is the edge of the green triangle, circled in an opaque white line.  As I just said, an opaque fragment is invisible if the opacity of the transparent fragment is 1. <br><br>  You can see it even better here: <br><br><img src="https://habrastorage.org/webt/-3/dc/ey/-3dcey8p1s2ynmgq9oyatw1ojma.png" width="300"><br><br>  The orange triangle has an opacity of 1, while a green triangle with disabled opacity is simply drawn along with opaque objects.  It looks as if the GREEN triangle shines in ORANGE through the orange triangle. <br><br>  To make the picture look decent, the easiest way is not to assign objects with high opacity.  In my working draft, I do not allow setting an opacity greater than 0.5.  This is a 3D CAD, in which objects are drawn schematically, and special realism is not required, so that such a restriction is permissible there. <br><br>  With low opacity values, the left and right images look almost the same: <br><br><img src="https://habrastorage.org/webt/hz/pc/ud/hzpcud9vuojz7vk0rsofbidyumy.png" width="1000"><br><br>  And with high they differ markedly: <br><br><img src="https://habrastorage.org/webt/iv/hq/_l/ivhq_lqrb8ofbxie323mtwpfg-q.png" width="1000"><br><br>  This is what a transparent polyhedron looks like: <br><br><img src="https://habrastorage.org/webt/nm/oi/6u/nmoi6u1xvycmbwvt50z6pinofbg.png" width="500"><br><img src="https://habrastorage.org/webt/ej/9u/p1/ej9up1muignigkr73kn2mi5byrs.png" width="500"><br><br>  The polyhedron has orange side and green horizontal faces.  Unfortunately, at first glance you will not understand it, i.e.  The picture does not look convincing.  Where the orange wall is in front, you need more orange, and where green is more green.  It will be much better to draw edges with one color: <br><br><img src="https://habrastorage.org/webt/a2/eg/bf/a2egbfdzwlwmaltuc4lpyna45gs.png" width="500"><br><br><h3>  WBOIT with depth </h3><br>  In order to somehow compensate for the lack of sorting by depth, the authors of the article came up with several options for adding depth to formula (2).  This makes the implementation more difficult, and the result less predictable and dependent on the features of a particular three-dimensional scene.  I did not go into this topic, so whoever is interested - I suggest to read the article. <br><br>  It is argued that WBOIT is sometimes capable of something that classical transparency with sorting cannot.  For example, you draw smoke as a particle system, using only two particles - with dark and light smoke.  When one particle passes through another, the classic mixing of colors with sorting gives an ugly result - the color of smoke from light becomes sharply dark.  The article says that WBOIT, taking into account the depth, allows you to achieve a smooth transition and looks more likely.  The same can be said about the modeling of fur and hair in the form of thin tubes. <br><br><h3>  Code </h3><br>  Now how to implement the formula (2) on OpenGL.  The example code lies on Github ( <a href="https://github.com/belyakov-igor/WBOIT_tester">link</a> ), and most of the pictures in the article come from there.  You can collect and play with my triangles.  The Qt framework is used. <br><br>  For those who are just starting to study the rendering of transparent objects, I recommend these two articles: <br><br>  ‚Üí <a href="https://habr.com/ru/post/343096/">Learn OpenGL.</a>  <a href="https://habr.com/ru/post/343096/">Lesson 4.3 - Mixing colors</a> <br>  ‚Üí <a href="https://habr.com/ru/post/224003/">Order-Independent Transparency algorithm using link lists on Direct3D 11 and OpenGL 4</a> <br><br>  The second, however, is not so important for understanding this material, but the first is required to read. <br><br>  To calculate the formula (2), we need 2 additional framebuffers, 3 multisample textures and a render buffer to which we will write the depth.  In the first texture - colorTextureNT (NT means non-transparent) - we will render non-transparent objects.  It has type GL_RGB16F.  The second texture (colorTexture) will be of type GL_RGBA16F;  In the first 3 components of this texture, we will write this piece of the formula (2): <img src="https://habrastorage.org/webt/9p/7i/vm/9p7ivmikwxs8ltenmceiumeogoo.png" width="70">  Fourth - <img src="https://habrastorage.org/webt/i2/bg/uc/i2bguc_jhzovzvn6ybqfkkuds4q.png" width="50">  .  Another texture of type GL_R16F (alphaTexture) will contain <img src="https://habrastorage.org/webt/ma/si/f0/masif074trzop-clpwvbwtfj92i.png" width="90">  . <br><br>  First you need to create these objects and get their identifiers from OpenGL: <br><br><pre> <code class="cpp hljs"> f-&gt;glGenFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT ); f-&gt;glGenRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer ); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glGenTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> <br>  As I said, the Qt framework is used here, and all OpenGL calls go through an object of type QOpenGLFunctions_4_5_Core, which I have denoted everywhere as f. <br><br>  Now you should allocate memory: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGB16F, w, h, GL_TRUE ); f-&gt;glBindRenderbuffer(GL_RENDERBUFFER, depthRenderbuffer); f-&gt;glRenderbufferStorageMultisample( GL_RENDERBUFFER, numOfSamples, GL_DEPTH_COMPONENT, w, h ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_RGBA16F, w, h, GL_TRUE ); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glTexImage2DMultisample( GL_TEXTURE_2D_MULTISAMPLE, numOfSamples, GL_R16F, w, h, GL_TRUE );</code> </pre> <br>  And set up framebuffers: <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer ); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, colorTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); f-&gt;glFramebufferTexture2D( GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D_MULTISAMPLE, alphaTexture, <span class="hljs-number"><span class="hljs-number">0</span></span> ); GLenum attachments[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1}; f-&gt;glDrawBuffers(<span class="hljs-number"><span class="hljs-number">2</span></span>, attachments); f-&gt;glFramebufferRenderbuffer( GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthRenderbuffer );</code> </pre> <br>  On the second rendering pass, the output from the fragment shader will go to two textures at once, and this must be explicitly indicated with glDrawBuffers. <br><br>  Most of this code is executed once, when the program starts.  The code that allocates memory for textures and renderbuffers is called each time the window is resized.  Next comes the rendering code, which is called every time the window is redrawn. <br><br><pre> <code class="cpp hljs"> f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebufferNT); <span class="hljs-comment"><span class="hljs-comment">// ...   ...</span></span></code> </pre> <br>  We have just drawn all the opaque objects on the colorTextureNT texture, and recorded the depths in the renderbuffer.  Before you use the same renderbuffer in the next drawing stage, you need to make sure that all the depths of the opaque objects are already written there.  For this, GL_FRAMEBUFFER_BARRIER_BIT is used.  After rendering the transparent objects, we will call the ApplyTextures () function, which will start the final rendering stage, at which the fragment shader will read data from the colorTextureNT, colorTexture and alphaTexture textures to apply the formula (2).  Textures should be fully recorded by that time, so before calling ApplyTextures () we use GL_TEXTURE_FETCH_BARRIER_BIT. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearColor[<span class="hljs-number"><span class="hljs-number">4</span></span>] = { <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> GLfloat clearAlpha = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, framebuffer); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">0</span></span>, clearColor); f-&gt;glClearBufferfv(GL_COLOR, <span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;clearAlpha); f-&gt;glMemoryBarrier(GL_FRAMEBUFFER_BARRIER_BIT); PrepareToTransparentRendering(); { <span class="hljs-comment"><span class="hljs-comment">// ...   ... } CleanupAfterTransparentRendering(); f-&gt;glMemoryBarrier(GL_TEXTURE_FETCH_BARRIER_BIT); f-&gt;glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO); ApplyTextures();</span></span></code> </pre> <br>  defaultFBO is a framebuffer through which we display an image on the screen.  In most cases, this is 0, but in Qt this is QOpenGLWidget :: defaultFramebufferObject (). <br><br>  Each time we call a fragmentary shader, we will have information about the color and opacity of the current fragment.  But at the output in the colorTexture texture we want to get the sum (and in the alphaTexture texture the product) of some functions of these values.  For this, blending is used.  Moreover, since we calculate the sum for the first texture and the product for the second, the blending settings (glBlendFunc and glBlendEquation) for each attachment must be set separately. <br><br>  Here is the contents of the PrepareToTransparentRendering () function: <br><br><pre> <code class="cpp hljs"> f-&gt;glEnable(GL_DEPTH_TEST); f-&gt;glDepthMask(GL_FALSE); f-&gt;glDepthFunc(GL_LEQUAL); f-&gt;glDisable(GL_CULL_FACE); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glEnable(GL_BLEND); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_ONE, GL_ONE); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">0</span></span>, GL_FUNC_ADD); f-&gt;glBlendFunci(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_DST_COLOR, GL_ZERO); f-&gt;glBlendEquationi(<span class="hljs-number"><span class="hljs-number">1</span></span>, GL_FUNC_ADD);</code> </pre> <br>  And the contents of the CleanupAfterTransparentRendering () function: <br><br><pre> <code class="cpp hljs"> f-&gt;glDepthMask(GL_TRUE); f-&gt;glDisable(GL_BLEND);</code> </pre> <br>  In my fragment shader the opacity is denoted by the letter w.  The product of color on w and w itself is displayed in one output parameter, and 1 - w - in another.  For each output parameter, the layout qualifier is defined as ‚Äúlocation = X‚Äù, where X is the index of the element in the array of attachments, which we passed to glDrawBuffers in the 3rd listing (specifically, the output parameter with location = 0 is sent to the texture bound to GL_COLOR_ATTACHMENT0 , and the parameter with location = 1 - to the texture bound to GL_COLOR_ATTACHMENT1).  The same numbers are used in the glBlendFunci and glBlendEquationi functions to indicate the attachment number for which we set the blending parameters. <br><br>  Fragment shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core in vec3 color; layout (location = 0) out vec4 outData; layout (location = 1) out float alpha; layout (location = 2) uniform float w; void main() { outData = vec4(w * color, w); alpha = 1 - w; }</span></span></code> </pre> <br>  In the ApplyTextures () function, we simply draw a rectangle over the entire window.  The fragment shader queries the data of all the textures we have created, using the current screen coordinates as texture coordinates and the current sample number (gl_SampleID) as the sample number in the multisample texture.  Using the gl_SampleID variable in the shader automatically turns on the mode when the fragment shader is called once for each sample (under normal conditions it is called once for the entire pixel, and the result is written to all samples that were inside the primitive). <br><br>  There is nothing remarkable about the vertex shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core const vec2 p[4] = vec2[4]( vec2(-1, -1), vec2( 1, -1), vec2( 1, 1), vec2(-1, 1) ); void main() { gl_Position = vec4(p[gl_VertexID], 0, 1); }</span></span></code> </pre> <br>  Fragment shader: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 core out vec4 outColor; layout (location = 0) uniform sampler2DMS colorTextureNT; layout (location = 1) uniform sampler2DMS colorTexture; layout (location = 2) uniform sampler2DMS alphaTexture; void main() { ivec2 upos = ivec2(gl_FragCoord.xy); vec4 cc = texelFetch(colorTexture, upos, gl_SampleID); vec3 sumOfColors = cc.rgb; float sumOfWeights = cc.a; vec3 colorNT = texelFetch(colorTextureNT, upos, gl_SampleID).rgb; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (sumOfWeights == 0) { outColor = vec4(colorNT, 1.0); return; } float alpha = 1 - texelFetch(alphaTexture, upos, gl_SampleID).r; colorNT = sumOfColors / sumOfWeights * alpha + colorNT * (1 - alpha); outColor = vec4(colorNT, 1.0); }</span></span></code> </pre> <br>  Finally, the contents of the ApplyTextures () function: <br><br><pre> <code class="cpp hljs"> f-&gt;glActiveTexture(GL_TEXTURE0); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTextureNT); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); f-&gt;glActiveTexture(GL_TEXTURE1); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, colorTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); f-&gt;glActiveTexture(GL_TEXTURE2); f-&gt;glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, alphaTexture); f-&gt;glUniform1i(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); f-&gt;glEnable(GL_MULTISAMPLE); f-&gt;glDisable(GL_DEPTH_TEST); f-&gt;glDrawArrays(GL_TRIANGLE_FAN, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Well, it would be nice to release OpenGL resources after it's over.  I have this code called in the destructor of my OpenGL widget: <br><br><pre> <code class="cpp hljs"> f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebufferNT); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTextureNT); f-&gt;glDeleteRenderbuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthRenderbuffer); f-&gt;glDeleteFramebuffers (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;framebuffer); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;colorTexture); f-&gt;glDeleteTextures (<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;alphaTexture);</code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/457284/">https://habr.com/ru/post/457284/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45727/index.html">Peter Nalitch - new album on the system "Pay What You Want"</a></li>
<li><a href="../457270/index.html">Prisma-CMS as an engine for quickly creating MVP</a></li>
<li><a href="../457276/index.html">Seven threats from bots to your site</a></li>
<li><a href="../45728/index.html">You can take a picture and a matchbox</a></li>
<li><a href="../457282/index.html">‚ÄúThe death of God‚Äù or the collapse of the generally accepted laws of building IT teams and creating IT systems in the 21st century</a></li>
<li><a href="../457286/index.html">The solution of the WorldSkills tasks of the Network module in the CICA competency. Part 1 - Basic Setup</a></li>
<li><a href="../457288/index.html">PKCS # 11 token-based cryptographic workstations. Electronic signature. Part 2</a></li>
<li><a href="../45729/index.html">Control of lost time: learn to observe balance</a></li>
<li><a href="../457290/index.html">Conference DEFCON 25. Garry Kasparov. "The Last Battle of the Brain." Part 2</a></li>
<li><a href="../457294/index.html">"To live in a high" or my story from procrastination to self-development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>