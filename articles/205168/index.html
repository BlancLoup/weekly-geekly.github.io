<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Iron in the service of the algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Boris Babayan about the past, present and future of computing technology 

 What is the development of computing technology to a person who has been d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Iron in the service of the algorithm</h1><div class="post__text post__text-html js-mediator-article"><h5>  <i>Boris Babayan about the past, present and future of computing technology</i> </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/8a3/31e/031/8a331e031a4aaf2c0f6843cdd9de8ffd.jpg" alt="Boris Babayan" align="right"><br>  What is the development of computing technology to a person who has been developing computer technology for more than half a century? <br><br>  I was able to talk on this subject with Boris Artashesovich Babayan, director of architecture at Intel. <br><br>  Boris Babayan is known as the chief architect of the computer computing systems Elbrus-1, Elbrus-2 and Elbrus-3.  Some of his ideas are used in the Transmeta architecture.  Currently, Boris is leading the development of a new microprocessor architecture at Intel. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to completely do away with the formalities, I will list the titles, degrees and positions of Boris: Corresponding Member of the Russian Academy of Sciences, Doctor of Technical Sciences, Professor, Head of the Microprocessor Technologies Department of the Moscow Institute of Physics and Technology, Intel Fellow, State and Lenin Prize Laureate. <br><br>  <i>Further narration is built on behalf of Babayan.</i>  <i>My mean comments are decorated in the form of frames or links to Internet pages.</i> <br><br><a name="habracut"></a><br>  It is appropriate to ask a question about what I will say.  The answer may seem very unusual: everything.  About everything that I and my colleagues do.  I thought about the problems of my current project and what to do next.  And I deeply felt that everything in our business <i>is</i> closely connected.  And architecture, and programming languages, and the operating system.  Well, everything, everything, everything, you know?  This will be my story. <br><br>  When I looked at the situation as a whole, it struck me very strongly.  It seems that nothing more can be optimized in the gland.  My colleagues and I know that this is not the case.  We are already optimizing the microprocessor architecture of the new generation, although it has not yet become a product.  And for those who are engaged in <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2583%25D0%25BF%25D0%25B5%25D1%2580%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D1%258F%25D1%2580%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">superscalar</a> , the end seems to be - there is nothing left to do next.  And nevertheless, if we consider the whole development of computing technology, then we are closer to the beginning than to the end. <br><br>  Unfortunately - or perhaps fortunately - I don‚Äôt know - the whole story, I think, has an end.  But this is probably the visible end.  It seems to me that the end.  And it is possible that under other conditions ... But it was something like a preface. <br><br>  In general, the topic of my conversation is the history of the development of our business, the entire computer technology, computer technology.  Along the way, I will talk about the role of our Russian scientists, Soviet scientists, or something ... But this is not my goal.  That, so to speak, in passing.  Unfortunately, very few people in Russia know about this. <br><br>  Everything, it was the last foreword.  Now we will begin. <br><br>  Look here: computing is what is it?  This is an implementation of algorithms in hardware using programming languages.  That is, we have three major components: algorithms, languages ‚Äã‚Äãand hardware.  Therefore, if we are going to analyze something, then first of all it is necessary to look at these components. <br><br>  Let's start with the algorithms.  Algorithms are something abstract, something eternal.  Like numbers, for example.  There may be many different algorithms, and each of them is eternal. <br><br>  How are the algorithms presented?  In them, as in many other things related to the real world, two components can be distinguished: temporal and spatial.  A time component is a sequence of operations: what is being done.  This component is extremely parallel.  Of course, there are purely sequential algorithms, but in principle the concept of an algorithm is an idea of ‚Äã‚Äãa parallel structure.  Typically, the computation graph is very parallel and extremely structured. <br><br>  Now the spatial component.  The spatial component is also parallel and structured.  What is she like?  These are objects with which operations work.  A lot of objects.  These objects can refer to each other, be nested into each other.  But there are many of them and different operations work with them.  Everything is <i>very</i> parallel. <br><br>  That's what algorithms are. <br><br>  And iron?  And iron, unlike algorithms, is not forever.  It varies greatly over time.  Initially, iron was very primitive.  When I started ... - and I started at the Physical and Technical Institute, in the 51st year I entered it - and so, then the first BESM did not work either.  One bit of information was then represented by two electronic tubes.  This is a cubic decimeter!  Incredible volume.  And there was only one executing device.  It occupied three rooms.  As I always joke, the transfer of a bit began in one room, and ended in two rooms.  This is a terrible size. <br><br>  And look, what now.  On one crystal an incredible amount of performing devices is placed. <br><br>  But the first BESM was already far from the first.  I did not see the very first cars.  For example, the Urals.  It was a strictly consistent machine.  Bit-serial machine.  That is, there was a magnetic drum.  One bit of information was read from it.  Then the read values, for example, were added and again one bit was written to the drum.  Awful.  But it was necessary to design such machines.  Where to go?  Then there was no way to reflect on the equipment such an incredible magnificence as parallelism in time and in space.  There was simply nothing to talk about. <br><br>  It was necessary to simplify.  Well, what kind of simplification would be natural in this case?  Linearize everything!  Turn everything into a ticker.  It is very simple.  Nothing worth turning a parallel algorithm into a ruler.  And in space and in time.  Here are the first cars were made.  And this is a brilliant decision, of course.  Although ... it is difficult to call him a genius, since it is so simple.  But this is an effective solution for the time.  Because to turn a complex algorithm into a ruler - no optimization is needed.  Compiler to do this is easy.  True, then about compilers and programming languages ‚Äã‚Äãnever heard of.  Everything was programmed in bits.  The state of computing was such that it did not allow to focus on programmers.  They were not considered at all.  Programmers worked with what the hardware developers gave them.  And the programs were tiny.  Therefore, it was easier and more efficient to write in bits than in any language.  Then the use of languages ‚Äã‚Äãwas a waste of machine time. <br><br>  My favorite joke in those days was that real men work in assembler, and languages ‚Äã‚Äãare so much mischief. <br><br>  In the absence of languages ‚Äã‚Äãand compilers, a person personally represented the algorithm as a ruler.  And this corresponded to some familiar concept of time.  The time is sequential - and the algorithm is sequential.  This is all natural.  Therefore, compilers (by the time they appeared) to do this work was very simple.  For the car - even easier.  The linear sequence of instructions that the algorithm turned into was performed strictly sequentially.  This requires a very simple equipment!  Then ‚Äî and I had already done the machines ‚Äî we had never even imagined to model the behavior of the equipment. <br><br>  Now without modeling is impossible.  Modern architectures are very dynamic.  It is impossible to optimize them without modeling.  And in that era, the execution time of the application was equal to the sum of the execution times of individual operations.  Nothing needed to be modeled, everything was clear.  There were no registers and no caches.  The first BESM worked this way: it read one number from the memory, the second number, performed the operations, wrote back.  Reading from memory, compared with the operation, occurred instantly.  Operations then took many cycles. <br><br>  The space was also very simple.  There were no objects.  There was just a sequence of bits. <br><br>  About security, i.e.  about the protection of processes from each other, there was no talk at all.  The car was in a separate room.  Someone had the key to this room - that‚Äôs all the security.  A programmer came, sat down at the car, started to work.  Finished - shot his tape, left, the other came.  Each one brought and carried their data with them, and only one process worked on the machine.  100% secure. <br><br>  The life of the programmer was not easy.  Each new machine is a new command system.  All programs were copied.  It was only the fact that there were very few programs that saved, so that it was possible to put up with the rewriting. <br><br>  That was the beginning. <br><br>  The tragedy is that compatibility with this beginning we have until today.  All modern command systems are linear.  Although the equipment is now very parallel.  And it's very bad.  This complicates programming.  A lot of mistakes arise.  We have big security problems because of pointers that allow us to reach out to any information from any place.  Awful  But that's not all.  From the first personal cars we got the tire.  The hardware at that time was not yet parallel, and the processors had only one actuator.  But the processors themselves could already work in parallel with each other on shared memory.  Just for this they needed a tire.  The bus created strict orderliness of all memory accesses from all processors.  What is now called strong ordering or memory model. <br><br>  Programmers were given such a system, and they understood that everything was ordered in time.  Programmers, as always, just used what they were given.  And they gave them that.  Then synchronization through semaphores and reading data from memory took the same time.  Therefore, for programmers, from the point of view of application efficiency, there was no difference: to use semaphores for synchronization, or to use the orderliness set by the memory model.  As a result, programs were written as horrible. <br><br>  And then the situation only worsened.  Caches appeared.  And if someone used to work out honest synchronization through semaphores in their programs, now he simply had to rewrite the programs so that they work through the memory model.  Because data access has become much faster than access to the semaphore.  After all, the data now lie in the cache, and the semaphore is in shared memory, access to which is much slower than to the cache.  Using semaphores has become very unprofitable. <br><br>  From here went compatibility issues. <br><br>  It has long been no tires.  However, in all cars that tire was modeled, which was in the very first cars.  Of course, it was slightly changed.  The developers of <a href="http://en.wikipedia.org/wiki/P6_(microarchitecture)">P6 have</a> looked that if we strictly perform memory ordering, then 25% of performance is lost.  Therefore, they introduced one relief: reads from memory can outrun entries in memory.  But still, the readings cannot overtake each other, the records cannot overtake each other, and the records cannot overtake the readings. <br><br>  And it would be possible to cancel and do everything in a new way.  We never used tires in <a href="http://www.computer-museum.ru/histussr/elbrus.htm">Elbrus</a> .  We had a cross-bar-switch from the very beginning. <br><div class="spoiler">  <b class="spoiler_title">Cross-bar-switch</b> <div class="spoiler_text">  Direct connection of each processor with each </div></div><br>  So: the humor is that the first cars are still being modeled.  And not only in hardware, but also in programming languages.  All programming languages ‚Äã‚Äãare corrupted.  They are very far from the algorithms - from what I called parallel time and parallel space.  They are closer to the very first machines, where everything is consistent. <br><br>  We see that compatibility has taken everything in a stranglehold, and it is very difficult to change it. <br><br>  Now let's take a look at how the temporal component progressed and how the spatial one developed.  Well, let's start with the spatial component.  It is much easier.  Although more relevant, perhaps, the time component.  But it is more difficult. <br><br>  So spatial ... Everything is very simple with it.  These are objects.  So, the machine must work with objects.  When we started the first Elbrus, we did not think about security. <br><div class="spoiler">  <b class="spoiler_title">Security...</b> <div class="spoiler_text">  Protecting processes from one another could be an independent motivation for introducing all the things mentioned below.  That is why safety is mentioned here. </div></div><br>  As I already said, there were no security problems at that time.  We tackled objects to support high-level languages.  We then thought: what should be a high-level language?  At the time, in the 72nd year, it was thought that high-level programming was provided by languages ‚Äã‚Äãsuch as Algol and Fortran.  But we quickly realized that existing languages ‚Äã‚Äãare oriented to existing machines, where everything is consistent.  Therefore, trying to support existing languages ‚Äã‚Äãin a new machine, we would actually be oriented indirectly, through languages, to existing architectures.  It is nonsense! <br><br>  I note that at that time there were already machines with support for high-level languages.  For example, the company <a href="http://en.wikipedia.org/wiki/Burroughs_Corporation">Burroughs</a> produced a machine that performed <a href="http://www.fh-jena.de/~kleine/history/languages/burroughs_B5500_ExtendedAlgol.pdf">Extended Algol</a> .  The data types there were implemented through tags that were stored in memory along with the data.  It was a good idea, and we borrowed it from Burroughs.  But the way they used these tags was just a misunderstanding.  With the help of tags Burroughs supported static types at the hardware level.  It worked like this: a certain type was rigidly assigned to each used memory cell.  This information was used to automatically convert the data while it was being written to memory.  If, for example, a real number was saved to a memory area marked with an integer tag, then the machine dynamically turned the real into an integer before writing. <br><br>  By supporting the existing static languages, Burroughs, in fact, supported the old hardware, because it was the static languages ‚Äã‚Äãthat were oriented towards it.  It‚Äôs just stupid!  Burroughs, developing a new architecture, eventually focused on the old machines.  In addition, the tags could be changed on the go in an unprivileged mode, which is also a big nonsense. <br><br>  However, in fairness, it should be noted that the dynamic type casting was given by Burroughs almost free of charge.  For such a conversion, it was necessary to recognize the type of cell in which the data was stored at each memory entry.  This was necessary in order to find out how the data should be converted.  It turns out that each entry in the memory required prior reading.  Such extra readings look terrible waste.  But the fact is that then <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C_%25D0%25BD%25D0%25B0_%25D0%25BC%25D0%25B0%25D0%25B3%25D0%25BD%25D0%25B8%25D1%2582%25D0%25BD%25D1%258B%25D1%2585_%25D1%2581%25D0%25B5%25D1%2580%25D0%25B4%25D0%25B5%25D1%2587%25D0%25BD%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2585">thoric memory was used</a> .  Before writing to such a memory, it had to be demagnetized.  And degaussing was done through reading.  Therefore, reading the cell type during the recording did not lead to additional overhead.  It was simply combined with demagnetization. <br><br>  But back to Elbrus.  We rejected the orientation of the old languages.  We analyzed a variety of different options and realized that high-level programming should allow programming not on linear memory, not on bits, but on objects.  This is an object orientation. <br><br>  This is how the algorithms work?  Imagine that some algorithm is being executed.  If it generates a new object, it does not need any bits.  An object, well, appears in space or something.  To this newly generated object, only the current algorithm can access.  No one else even knows about him.  Because it was generated by a specific algorithm.  An abstract algorithm, but no iron, do you understand?  This should be supported in the gland somehow. <br><br>  Further, each object has a type.  So we must support the types.  At first, we tried to apply a very extremist approach: integers that were real in tags were written.  But then we saw that it was completely unnecessary.  No need to support any types in tags.  And that's why. <br><div class="spoiler">  <b class="spoiler_title">It is a little about type system Elbrus-1</b> <div class="spoiler_text">  next to user data, information about their type was stored in memory.  The same information fell into the registers when reading data from memory.  Knowledge of the type made it possible to control the operations that could be performed on objects.  For example, an attempt to produce integer addition of real numbers caused scrapping </div></div><br>  Imagine that you take a real number and want to change some bits in it.  For example, you want to do something with an exhibitor.  If strictly all the variety of types is supported (bit set, real, integers, ...), then to change any bits in a real number, you must first turn it into a set of bits, then do the necessary manipulations, then turn back the bit set into a real one.  A bunch of unnecessary transformations!  And if you can literally work with the material, which, of course, you must be able to do, the error may not lie in what the programmer changes, so to speak, in the real number of bits, but in that he writes literally incorrect values. <br><div class="spoiler">  <b class="spoiler_title">Work literally</b> <div class="spoiler_text">  Those.  via bit set </div></div><br>  I want to say that inside the procedure it is impossible to check its semantics.  The apparatus cannot know semantics.  Errors within the procedure are the responsibility of the programmer.  There is no need to protect the programmer inside the procedure.  If he wants, he can always make a mistake there.  Another thing - interprocedural relationships.  Here interprocedural relationships are governed by pointers.  And pointers, generally speaking, cannot be changed literally.  That is, if a procedure works with a certain set of pointers, it should not be able to forge them. <br><br>  Thus, we realized that you only need to check pointers and nothing else.  This is the first.  The second.  We realized that a high-level language should be dynamic.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is if we want to have a universal language. </font><font style="vertical-align: inherit;">For me, then - let me remind you that this 72 year was - universalism meant that an operating system could be effectively written in a language. </font><font style="vertical-align: inherit;">If the operating system is not programmed, then the approach is not universal. </font><font style="vertical-align: inherit;">In order to be able to write an operating system, data types must be dynamic.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic types</font></font></b> <div class="spoiler_text"> ,        .     , ,  ,         .         </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is this so? Suppose you define some name and statically bind a type to this name. In your program, you know this type, but the operating system, when dealing with your data, does not know how it is described in the source language. If the program variable is statically described as an integer, the operating system does not know about it. She only sees binary codes. Therefore, the static approach is completely unacceptable. In addition, it is also not convenient. For example, it is convenient to be able to transmit the same parameter of the procedure as a direct value, a reference to this value, or even a procedure call that produces the desired value. It is absolutely natural. But the static approach does not allow doing this, unlike the dynamic one.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, we came to the conclusion that a high-level language is a dynamic language with strict control of pointers. Exactly to this conclusion, in fact, independently - we didn‚Äôt make much contact and hardly read each other - Nicklaus Wirth arrived. This is man number one in languages. He also realized that high-level programming is based on type safety and type dynamics. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wirth created the dynamic type of Euler. He was incredibly interesting. Everything was just delighted with this language. But he lacked efficiency. Because it was not supported by hardware. There was a mass of dynamic control. Then Wirth passed back. He said: yes, the types should be, but let them be static. And the control should be ... but maybe not very strong, because, for example, controlling the output of the array beyond borders requires additional commands.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We from the very beginning implied that the types are checked by hardware. </font><font style="vertical-align: inherit;">For example, if you have a pointer to an array, then no one can, having this pointer, go beyond the bounds of the array.</font></font> It's impossible. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what happened as a result? </font><font style="vertical-align: inherit;">We made a real language. </font><font style="vertical-align: inherit;">We had tags. </font><font style="vertical-align: inherit;">That is, several digits were added to all the data describing the type. </font><font style="vertical-align: inherit;">We did control pointers. </font><font style="vertical-align: inherit;">In short, we created the </font></font><a href="http://notes.sochi.org.ru/1271/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El-76</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is the late </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BA%25D0%25BE%25D0%25B2%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9,_%25D0%2592%25D0%25BB%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25BC%25D0%25B8%25D1%2580_%25D0%259C%25D1%2581%25D1%2582%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0%25D0%25B2%25D0%25BE%25D0%25B2%25D0%25B8%25D1%2587"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volodya Pentkovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> made. </font><font style="vertical-align: inherit;">He was a programmer then. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On El-76 the Elbrus operating system was written. </font><font style="vertical-align: inherit;">This is already done by Serezha Semenikhin. </font><font style="vertical-align: inherit;">26 people in the mid-70s made an operating system: multiprogram, multiprocessor, multiterminal. </font><font style="vertical-align: inherit;">At that time, basically packet mode was used everywhere. </font><font style="vertical-align: inherit;">And we have such a developed operating system!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, our standard approach dramatically simplified programming. </font><font style="vertical-align: inherit;">He even increased productivity. </font><font style="vertical-align: inherit;">We have made three generations of cars on this approach: the first, second, third Elbrus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our machines were used in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> critical systems. </font><font style="vertical-align: inherit;">Moscow‚Äôs anti-missile defense, space control, nuclear projects in Arzamas. </font><font style="vertical-align: inherit;">At the same time, all our users said: debugging on this machine is 10 times faster than on older machines. </font><font style="vertical-align: inherit;">The impression was as if you were working with a permanently enabled debugging system. </font><font style="vertical-align: inherit;">And without loss of efficiency. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When our guys got Western cars - in the beginning of the 90s - they began to approach me and say: how can these machines work? </font><font style="vertical-align: inherit;">They can not debug the program.</font></font> Awful <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now look what happened with this approach! </font></font> Historically.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We released the first car in '78. Then passed the first test of the operating system. Until 82‚Äì83, First Elbrus were widely used in our country. Around the same time, research in the field of type safety was carried out in many universities of the world. And Intel is also interested in this approach. They also made a type-safety-car, the </font></font><a href="http://en.wikipedia.org/wiki/Intel_iAPX_432"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">432nd</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ask any Intel man if he knows that Intel in history has 432 cars. The answer will be: no, I do not know. This is a shame to remember! Just a shameful car. She provided type safety. But there were elementary mistakes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the 432nd, the protection of users was implemented, which of course is very correct. However, all the pointers were stored in a separate segment. It was called program reference table. The car controlled that only pointers can be in this segment. And nowhere, besides him, could there be more pointers. I read their papers. They say that all this is very cool, but it is very inconvenient to keep the pointers in a separate segment.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pointers should be sent as normal data. We did just that. We have pointers - just data. And the 432nd kept pointers in a separate segment. This led to terrible results. For example, a three-address operation was required to index the array. It was necessary to specify three operands: the position of the pointer to the array in the pointer segment, the position of the index in the data segment and again the offset in the pointer segment, for which the result was required to be written. But the worst thing is not even this, but the fact that when entering the procedure, the operating system was requested four segments! Two segments for parameters: pointer and scalar. And two segments for local data: also Pointer and scalar. </font></font><br><br> <a href="http://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B5%25D0%25BD%25D1%2582%25D1%2580%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B8%25D1%2582%25D0%25B5%25D1%2582_%25D0%259A%25D0%259F%25D0%25A1%25D0%25A1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Central Committee</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2582_%25D0%25BC%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B2_%25D0%25A1%25D0%25A1%25D0%25A1%25D0%25A0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Council of Ministers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then Western machines were copied, and with the advent of the 432nd, they spread the paper on scientists: here, you need to copy this machine. Since I was a defender of the ideology of type-safety, I was included in the commission. Ernst Filtsev headed it. And then I wrote a big cart against Intel. Wrote that the car is bad and that after a few months it will fail. And she failed. When I came to Intel, I found an article by </font></font><a href="http://en.wikipedia.org/wiki/Bob_Colwell"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bob Colwell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the brilliant man who created the P6. He analyzed the 432th machine and came to the same conclusion as me: the idea is colossal, but the implementation is useless. Colwell‚Äôs article has specific numbers. For example, entering the procedure took up to fifty memory accesses. How was it possible to work on such a machine?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I said, the 432nd did not last long. </font><font style="vertical-align: inherit;">But what happened after that with type safety? </font><font style="vertical-align: inherit;">In what areas did languages ‚Äã‚Äãand equipment develop?</font></font><br><br><h5> <a href="http://habrahabr.ru/post/214377/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be </font><a href="http://habrahabr.ru/post/214377/"><font style="vertical-align: inherit;">continued</font></a><font style="vertical-align: inherit;"> ...</font></font></h5><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The author thanks Andrei Dobrov, Alexander Kim, Dmitry Maslennikov and Alexander Ostanevich for their help in preparing the material. </font></font><br></div><p>Source: <a href="https://habr.com/ru/post/205168/">https://habr.com/ru/post/205168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../205154/index.html">JSfiddle style HTML + CSS + JS editor with 230 character code</a></li>
<li><a href="../205158/index.html">Migrate Google Chrome to RAM Disk on Linux</a></li>
<li><a href="../205160/index.html">Apple plans to launch iBeacon in 254 US stores</a></li>
<li><a href="../205162/index.html">Configuring VPN connection with l2tp + ipsec using OpenVZ container as server</a></li>
<li><a href="../205166/index.html">New Year Gift Guide 2013</a></li>
<li><a href="../205170/index.html">DIY-dimmer: New Year's pre-order printed circuit boards</a></li>
<li><a href="../205174/index.html">German Digital Library opens API</a></li>
<li><a href="../205176/index.html">SELECT ... WHERE queries in Cassandra 2.0 in CQL3</a></li>
<li><a href="../205178/index.html">JavaScript Majority</a></li>
<li><a href="../205184/index.html">How will protect children from harmful information?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>