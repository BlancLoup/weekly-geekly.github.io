<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple SFML game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We will make a ‚Äútag‚Äù game in C ++ using the SFML library. Fifteen is a well-known puzzle that looks like this: 


 On the playing field of 4x4 size th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple SFML game</h1><div class="post__text post__text-html js-mediator-article">  We will make a ‚Äútag‚Äù game in C ++ using the SFML library.  Fifteen is a well-known puzzle that looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7u/hl/by/7uhlbycd1tkovgw_igia0xwklc8.jpeg"></div><br>  On the playing field of 4x4 size there are 15 randomly placed dice with numbers from 1 to 15 and one free space.  It is possible to move dies only one by one and only on an empty seat.  The goal of the game is to align the dice on the playing field in the order corresponding to their numbers. <br><br>  So, let's begin. <br><a name="habracut"></a><br>  We start the Visual Studio and we create the new empty project.  You can call it what you want, I called "15".  In this project, create a new main.cpp file and an empty main function: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp int main() { return 0; }</span></span></code> </pre> <br>  Next, download the SFML library from <a href="http://sfml-dev.org/">sfml-dev.org</a> and unpack it.  In the unpacked library we have the necessary folders: <b>include</b> , <b>lib</b> and <b>bin</b> .  In the project properties in the C / C ++ section of <i>Additional Include Directories,</i> add the path to the <b>include</b> folder: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/t8/ky/zdt8kyekzv1txcad5vhycwphdma.png"></div><br>  In the Linker section of the <i>Additional Library Directories,</i> add the path to the <b>lib</b> folder: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9l/us/lb/9luslb9vhfieeof3lczrjq_85u0.png"></div><br>  And from the <b>bin</b> directory you need to copy the DLL-files and put them in the directory with the exe-file of our project: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/nk/ex/ewnkexitg7y6mvlxwb4fvs2_ums.png"></div><br>  In addition, in the Linker section, in the Input section, you need to add used library files to <i>Additional Dependencies</i> .  In our case, it is enough to add three files: sfml-system-d.lib, sfml-window-d.lib and sfml-graphics-d.lib: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k1/zc/p-/k1zcp-w1_jcbgd8rzy0itmhwe7m.png"></div><br>  The symbol <b>-d</b> in the file name means that it is a debug version and should be used in the Debug configuration.  In the release version settings, you will need to specify files without the <b>-d</b> symbol in the name. <br><br>  A good guide for connecting the SFML library to a Visual Studio project is on <a href="https://www.sfml-dev.org/tutorials/2.5/start-vc.php">the</a> library's <a href="https://www.sfml-dev.org/tutorials/2.5/start-vc.php">website</a> . <br><br>  Now let's try to involve the library in our project.  Create a window and run the event loop: <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include &lt;SFML/Graphics.hpp&gt; int main() { //    600  600    60    sf::RenderWindow window(sf::VideoMode(600, 600), "15"); window.setFramerateLimit(60); sf::Event event; while (window.isOpen()) { while (window.pollEvent(event)) { if (event.type == sf::Event::Closed) window.close(); if (event.type == sf::Event::KeyPressed) { //    -    if (event.key.code == sf::Keyboard::Escape) window.close(); } } //      window.clear(); window.display(); } return 0; }</span></span></code> </pre> <br></div></div><br>  The result will be a square window measuring 600 by 600 pixels with a black background: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qb/l3/_o/qbl3_op1hp84mtuq5b49c2q1dlc.png"></div><br>  The window can be closed in the usual way with the mouse, or via the Esc key.  Keyboard keystroke is also included in the message loop. <br><br>  Before we get down to business, we need some kind of font to display text on the screen.  For example, I took the font TrueType Calibri. <br><br>  Now we can start making our game. <br><br>  Create a new Game class: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gb/-b/sf/gb-bsf2p5hjalkleyc4s_nm5vso.png"></div><br>  The class will be responsible for the operation of the game and for drawing the playing field.  To do this, we will inherit our class from the Drawable and Transformable SFML libraries. <br><br>  So, we begin to describe our class. <br><br><div class="spoiler">  <b class="spoiler_title">Game.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SFML/Graphics.hpp&gt; const int SIZE = 4; //      const int ARRAY_SIZE = SIZE * SIZE; //   const int FIELD_SIZE = 500; //      const int CELL_SIZE = 120; //     enum class Direction { Left = 0, Right = 1, Up = 2, Down = 3 }; class Game : public sf::Drawable, public sf::Transformable { protected: int elements[ARRAY_SIZE]; int empty_index; bool solved; sf::Font font; public: Game(); void Init(); bool Check(); void Move(Direction direction); public: virtual void draw(sf::RenderTarget&amp; target, sf::RenderStates states) const; };</span></span></span></span></code> </pre><br></div></div><br>  First of all, connect the Graphics library: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SFML/Graphics.hpp&gt;</span></span></span></span></code> </pre> <br>  Immediately declare some constants required for the game: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SIZE = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      const int ARRAY_SIZE = SIZE * SIZE; //    const int FIELD_SIZE = 500; //      const int CELL_SIZE = 120; //    </span></span></code> </pre> <br>  We also declare our type enum, which determines the direction of movement of the plate: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Direction</span></span></span><span class="hljs-class"> {</span></span> Left = <span class="hljs-number"><span class="hljs-number">0</span></span>, Right = <span class="hljs-number"><span class="hljs-number">1</span></span>, Up = <span class="hljs-number"><span class="hljs-number">2</span></span>, Down = <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre> <br>  Well, finally the class itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Game</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sf::Drawable, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sf::Transformable { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elements[ARRAY_SIZE]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> empty_index; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> solved; sf::Font font; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Game(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Check</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Direction direction)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sf::RenderTarget&amp; target, sf::RenderStates states)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  The most important thing that we have in it is an array of elements containing integer values ‚Äã‚Äãcorresponding to the state of the playing field.  The elements in the array correspond to the elements of the playing field from left to right, from top to bottom, that is, the first 4 elements of the array correspond to the first line of the field, the second 4 elements to the second line, etc. <br><br>  Then, two variables that will be calculated each turn are <b>empty_index</b> (the index in the array corresponding to the free cell) and <b>solved</b> (a sign that the puzzle has been solved). <br><br>  In addition, the class has a font variable that defines the font that will be used when displaying text in a window. <br><br>  Now we will write the implementation of the methods of our class. <br><br><div class="spoiler">  <b class="spoiler_title">Game.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Game.h"</span></span></span><span class="hljs-meta"> Game::Game() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      font.loadFromFile("calibri.ttf"); Init(); } void Game::Init() { //    for (int i = 0; i &lt; ARRAY_SIZE - 1; i++) elements[i] = i + 1; //        empty_index = ARRAY_SIZE - 1; elements[empty_index] = 0; //     = 0 solved = true; } bool Game::Check() { //    for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { if (elements[i] &gt; 0 &amp;&amp; elements[i] != i + 1) return false; } return true; } void Game::Move(Direction direction) { //       int col = empty_index % SIZE; int row = empty_index / SIZE; //          int move_index = -1; if (direction == Direction::Left &amp;&amp; col &lt; (SIZE - 1)) move_index = empty_index + 1; if (direction == Direction::Right &amp;&amp; col &gt; 0) move_index = empty_index - 1; if (direction == Direction::Up &amp;&amp; row &lt; (SIZE - 1)) move_index = empty_index + SIZE; if (direction == Direction::Down &amp;&amp; row &gt; 0) move_index = empty_index - SIZE; //      if (empty_index &gt;= 0 &amp;&amp; move_index &gt;= 0) { int tmp = elements[empty_index]; elements[empty_index] = elements[move_index]; elements[move_index] = tmp; empty_index = move_index; } solved = Check(); } void Game::draw(sf::RenderTarget&amp; target, sf::RenderStates states) const { states.transform *= getTransform(); sf::Color color = sf::Color(200, 100, 200); //     sf::RectangleShape shape(sf::Vector2f(FIELD_SIZE, FIELD_SIZE)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); target.draw(shape, states); //       shape.setSize(sf::Vector2f(CELL_SIZE - 2, CELL_SIZE - 2)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); //        sf::Text text("", font, 52); for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { shape.setOutlineColor(color); text.setFillColor(color); text.setString(std::to_string(elements[i])); if (solved) { //      shape.setOutlineColor(sf::Color::Cyan); text.setFillColor(sf::Color::Cyan); } else if (elements[i] == i + 1) { //        text.setFillColor(sf::Color::Green); } //   ,   if (elements[i] &gt; 0) { //      sf::Vector2f position(i % SIZE * CELL_SIZE + 10.f, i / SIZE * CELL_SIZE + 10.f); shape.setPosition(position); //     text.setPosition(position.x + 30.f + (elements[i] &lt; 10 ? 15.f : 0.f), position.y + 25.f); target.draw(shape, states); target.draw(text, states); } } }</span></span></span></span></code> </pre><br></div></div><br>  The class constructor loads the font from the external file and calls the game initialization method: <br><br><pre> <code class="cpp hljs">Game::Game() { <span class="hljs-comment"><span class="hljs-comment">//      font.loadFromFile("calibri.ttf"); Init(); }</span></span></code> </pre> <br>  The game initialization method fills the array with the elements in the correct order and sets a sign of the solved puzzle: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Init() { <span class="hljs-comment"><span class="hljs-comment">//    for (int i = 0; i &lt; ARRAY_SIZE - 1; i++) elements[i] = i + 1; //   -     empty_index = ARRAY_SIZE - 1; elements[empty_index] = 0; //     = 0 solved = true; }</span></span></code> </pre> <br>  Yes, initially our game will be initialized as solved, and before the game starts we will mix the dice using random moves. <br><br>  The following method checks if the puzzle is solved and returns the result of the check: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Game::Check() { <span class="hljs-comment"><span class="hljs-comment">//    for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { if (elements[i] &gt; 0 &amp;&amp; elements[i] != i + 1) return false; } return true; }</span></span></code> </pre> <br>  And finally, the method that implements the movement of the plate in the game: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::Move(Direction direction) { <span class="hljs-comment"><span class="hljs-comment">//       int col = empty_index % SIZE; int row = empty_index / SIZE; //          int move_index = -1; if (direction == Direction::Left &amp;&amp; col &lt; (SIZE - 1)) move_index = empty_index + 1; if (direction == Direction::Right &amp;&amp; col &gt; 0) move_index = empty_index - 1; if (direction == Direction::Up &amp;&amp; row &lt; (SIZE - 1)) move_index = empty_index + SIZE; if (direction == Direction::Down &amp;&amp; row &gt; 0) move_index = empty_index - SIZE; //      if (empty_index &gt;= 0 &amp;&amp; move_index &gt;= 0) { int tmp = elements[empty_index]; elements[empty_index] = elements[move_index]; elements[move_index] = tmp; empty_index = move_index; } solved = Check(); }</span></span></code> </pre> <br>  The last class method is the method that renders the playing field: <br><br><div class="spoiler">  <b class="spoiler_title">draw</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Game::draw(sf::RenderTarget&amp; target, sf::RenderStates states) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { states.transform *= getTransform(); sf::Color color = sf::Color(<span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     sf::RectangleShape shape(sf::Vector2f(FIELD_SIZE, FIELD_SIZE)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); target.draw(shape, states); //       shape.setSize(sf::Vector2f(CELL_SIZE - 2, CELL_SIZE - 2)); shape.setOutlineThickness(2.f); shape.setOutlineColor(color); shape.setFillColor(sf::Color::Transparent); //        sf::Text text("", font, 52); for (unsigned int i = 0; i &lt; ARRAY_SIZE; i++) { shape.setOutlineColor(color); text.setFillColor(color); text.setString(std::to_string(elements[i])); if (solved) { //      shape.setOutlineColor(sf::Color::Cyan); text.setFillColor(sf::Color::Cyan); } else if (elements[i] == i + 1) { //        text.setFillColor(sf::Color::Green); } //   ,   if (elements[i] &gt; 0) { //      sf::Vector2f position(i % SIZE * CELL_SIZE + 10.f, i / SIZE * CELL_SIZE + 10.f); shape.setPosition(position); //     text.setPosition(position.x + 30.f + (elements[i] &lt; 10 ? 15.f : 0.f), position.y + 25.f); //    target.draw(shape, states); //    target.draw(text, states); } } }</span></span></code> </pre> <br></div></div><br>  In the drawing method, first of all, we apply coordinate transformation by multiplying by the transformation matrix.  This is necessary in order to be able to set the coordinates of our playing field.  Next, using the SFML RectangleShape objects, draw the playing field frames and the frames of each plate in the game.  We also draw text with the plate number on the plates.  In addition, if the puzzle is solved, then the color of the dice is made different. <br><br>  It is time to return to the main function: <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// main.cpp #include &lt;SFML/Graphics.hpp&gt; #include "Game.h" int main() { //    600  600    60    sf::RenderWindow window(sf::VideoMode(600, 600), "15"); window.setFramerateLimit(60); sf::Font font; font.loadFromFile("calibri.ttf"); //     sf::Text text("F2 - New Game / Esc - Exit / Arrow Keys - Move Tile", font, 20); text.setFillColor(sf::Color::Cyan); text.setPosition(5.f, 5.f); //    Game game; game.setPosition(50.f, 50.f); sf::Event event; int move_counter = 0; //       while (window.isOpen()) { while (window.pollEvent(event)) { if (event.type == sf::Event::Closed) window.close(); if (event.type == sf::Event::KeyPressed) { //    -    if (event.key.code == sf::Keyboard::Escape) window.close(); if (event.key.code == sf::Keyboard::Left) game.Move(Direction::Left); if (event.key.code == sf::Keyboard::Right) game.Move(Direction::Right); if (event.key.code == sf::Keyboard::Up) game.Move(Direction::Up); if (event.key.code == sf::Keyboard::Down) game.Move(Direction::Down); //   if (event.key.code == sf::Keyboard::F2) { game.Init(); move_counter = 100; } } } //     ,    if (move_counter-- &gt; 0) game.Move((Direction)(rand() % 4)); //      window.clear(); window.draw(game); window.draw(text); window.display(); } return 0; }</span></span></code> </pre> <br></div></div><br>  First we load the font and create a Text object to display a line of text with key assignment.  Next, create our game object and set the field position to a point with coordinates (50.50) - this is how we indent from the edge of the window. <br><br>  I decided to control the game through the keyboard, so for every keystroke of the arrows we call the Move object on the game object - to move the plate in the appropriate direction. <br><br>  Pressing the F2 key is the beginning of a new game, so in the event handler for this event, we re-initialize the game (which will lead to the placement of the dice in its place), and also set the value of the move counter to 100. This counter is used further to execute moves in random directions, until will not be reset, and the dies do not mix.  In this way, we will definitely get a solved puzzle state. <br><br>  In general, that's all, compile, build, run: <br><br><img src="https://habrastorage.org/webt/p0/ne/rg/p0nerg896fzcjdv2rwaqy47kr7m.png"><img src="https://habrastorage.org/webt/8s/c5/pc/8sc5pcprcxdaplxgekluevknn4c.png"><br><br>  In this article, I showed how you can quickly create a simple C ++ game using the SFML library.  However, the architecture of the program itself is far from ideal.  In the next article we will try to do something about it. </div><p>Source: <a href="https://habr.com/ru/post/449596/">https://habr.com/ru/post/449596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../44958/index.html">The largest light sculpture</a></li>
<li><a href="../449586/index.html">Difficult principle of sole responsibility</a></li>
<li><a href="../449588/index.html">What is the strength and weakness of the hosting market?</a></li>
<li><a href="../44959/index.html">How I painted a laptop. What came of it all</a></li>
<li><a href="../449590/index.html">Microsoft's market capitalization exceeded $ 1 trillion 04/25/2019</a></li>
<li><a href="../4496/index.html">Putin will ban online casinos</a></li>
<li><a href="../449600/index.html">Smart Home with Yandex.Alisa</a></li>
<li><a href="../449602/index.html">Inspired by production and basketball: how Yandex is preparing the programming championship</a></li>
<li><a href="../449604/index.html">When new technologies are more important than fundamentals: why the ‚Äúbendable‚Äù Samsung Galaxy Fold turned out to be a failure</a></li>
<li><a href="../449606/index.html">Dismantling of the Shuliavsky bridge in Kiev on April 19</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>