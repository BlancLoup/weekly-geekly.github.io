<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kubernetes Service Writing Guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the author. Already for the fifth December in a row on the GopherAcademy blog , the most diverse representatives of the Go community are sharing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kubernetes Service Writing Guide</h1><div class="post__text post__text-html js-mediator-article"><p>  <strong>From the author.</strong>  <em>Already for the fifth December in a row on the <a href="https://blog.gopheracademy.com/">GopherAcademy</a> blog <a href="https://blog.gopheracademy.com/">, the</a> most diverse representatives of the Go community are sharing their experiences in a special pre-Christmas series of posts.</em>  <em>This year I also decided to offer my article based on the first part of our <a href="https://youtu.be/0ndWw1udpsA%3Ft%3D7m16s">workshop</a> with Igor Dolzhikov <a href="https://youtu.be/0ndWw1udpsA%3Ft%3D7m16s">on microservices</a> .</em>  <em>On Habr√© a small part of this guide, we <a href="https://habrahabr.ru/post/337158/">have already considered earlier</a> .</em> </p><br><p>  If you have ever tried Go, you know that writing services on Go is very simple.  We need <a href="https://github.com/rumyantseva/advent-2017/commit/76864ab0587dd9a599752ed090f618749b6bfe0c">literally a few lines of code</a> in order to be able to start the http-service.  But what needs to be added if we want to prepare such an application in production?  Let's look at this on the example of a service that is ready to launch in <a href="http://kubernetes.io/">Kubernetes</a> . </p><br><p>  All steps from this article can be found <a href="https://github.com/rumyantseva/advent-2017/tree/all-steps">in one tag</a> , or you can follow the article examples <a href="https://github.com/rumyantseva/advent-2017/commits/master">for commit</a> . </p><a name="habracut"></a><br><h3 id="shag-1-prosteyshiy-servis">  Step 1. The simplest service </h3><br><p>  So, we have a very simple application: </p><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/home"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, _ *http.Request)</span></span></span></span> { fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"Hello! Your request was processed."</span></span>) }, ) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> </div></div><br><p>  If we want to try to run it, the <code>go run main.go</code> will be enough.  With curl, we can check how this service works: <code>curl -i http://127.0.0.1:8000/home</code> .  But when we launch this application, we see that there is no information in the terminal about its state. </p><br><h3 id="shag-2-dobavlyaem-logirovanie">  Step 2. Add logging </h3><br><p>  First of all, let's add logging in order to understand what is happening with the service and so that errors or other important situations can be logged.  In this example, we will use the simplest logger from the standard Go library, but for a real service running in production, there may be interesting more complex solutions, such as <a href="https://github.com/golang/glog">glog</a> or <a href="https://github.com/sirupsen/logrus">logrus</a> . </p><br><p>  We may be interested in 3 situations: when the service starts, when the service is ready to process requests, and when <code>http.ListenAndServe</code> returns an error.  The result is something <a href="https://github.com/rumyantseva/advent-2017/commit/65689d282be7e6a7ec38ec254605811fd3bef784">like this</a> : </p><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Print(<span class="hljs-string"><span class="hljs-string">"Starting the service..."</span></span>) http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/home"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, _ *http.Request)</span></span></span></span> { fmt.Fprint(w, <span class="hljs-string"><span class="hljs-string">"Hello! Your request was processed."</span></span>) }, ) log.Print(<span class="hljs-string"><span class="hljs-string">"The service is ready to listen and serve."</span></span>) log.Fatal(http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":8000"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre> </div></div><br><p>  Already better! </p><br><h3 id="shag-3-dobavlyaem-router">  Step 3. Add a router </h3><br><p>  For this application, we will most likely want to use a router to simplify the handling of different URIs, HTTP methods, or other rules.  In the standard Go library there is no router, so let's try <a href="https://github.com/gorilla/mux">gorilla / mux</a> , which is quite compatible with the standard <code>net/http</code> library. </p><br><p>  If your service requires some noticeable number of routing rules, it makes sense to put everything related to routing into a separate package.  Let's take the initialization and setting of the routing rules, as well as handler functions into the handlers package (you can see the complete changes <a href="https://github.com/rumyantseva/advent-2017/commit/1a61e7952e227e33eaab81404d7bff9278244080">here</a> ). </p><br><p>  Add the <code>Router</code> function, which will return the configured router, and the <code>home</code> function, which will process the rule for the <code>/home</code> path.  I prefer to divide such functions into separate files: </p><br><div class="spoiler">  <b class="spoiler_title">handlers / handlers.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> handlers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Router register necessary routes and returns an instance of a router. func Router() *mux.Router { r := mux.NewRouter() r.HandleFunc("/home", home).Methods("GET") return r }</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">handlers / home.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> handlers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// home is a simple HTTP handler function which writes a response. func home(w http.ResponseWriter, _ *http.Request) { fmt.Fprint(w, "Hello! Your request was processed.") }</span></span></code> </pre> </div></div><br><p>  In addition, we need small changes in the <code>main.go</code> file: </p><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/rumyantseva/advent-2017/handlers"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// How to try it: go run main.go func main() { log.Print("Starting the service...") router := handlers.Router() log.Print("The service is ready to listen and serve.") log.Fatal(http.ListenAndServe(":8000", router)) }</span></span></code> </pre> </div></div><br><h3 id="shag-4-testy">  Step 4. Tests </h3><br><p>  It's time to add a <a href="https://github.com/rumyantseva/advent-2017/commit/a3e7f6356478095c41166ade41feba6917b37096">few tests</a> .  To do this, you can use the standard <code>httptest</code> package.  For the <code>Router</code> function, you can write something like this: </p><br><div class="spoiler">  <b class="spoiler_title">handlers / handlers_test.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> handlers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http/httptest"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { r := Router() ts := httptest.NewServer(r) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ts.Close() res, err := http.Get(ts.URL + <span class="hljs-string"><span class="hljs-string">"/home"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res.StatusCode != http.StatusOK { t.Errorf(<span class="hljs-string"><span class="hljs-string">"Status code for /home is wrong. Have: %d, want: %d."</span></span>, res.StatusCode, http.StatusOK) } res, err = http.Post(ts.URL+<span class="hljs-string"><span class="hljs-string">"/home"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res.StatusCode != http.StatusMethodNotAllowed { t.Errorf(<span class="hljs-string"><span class="hljs-string">"Status code for /home is wrong. Have: %d, want: %d."</span></span>, res.StatusCode, http.StatusMethodNotAllowed) } res, err = http.Get(ts.URL + <span class="hljs-string"><span class="hljs-string">"/not-exists"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> res.StatusCode != http.StatusNotFound { t.Errorf(<span class="hljs-string"><span class="hljs-string">"Status code for /home is wrong. Have: %d, want: %d."</span></span>, res.StatusCode, http.StatusNotFound) } }</code> </pre> </div></div><br><p>  Here we check that calling <code>GET</code> for <code>/home</code> will return <code>200</code> .  And when you try to send <code>POST</code> expected response will be <code>405</code> .  And finally, for a non-existent path, we expect <code>404</code> .  In general, this test may be somewhat redundant, because the work of the router is already covered by tests within the <code>gorilla/mux</code> , so here you can check even fewer cases. </p><br><p>  For the <code>home</code> function, it makes sense to check not only the code, but also the response body: </p><br><div class="spoiler">  <b class="spoiler_title">handlers / home_test.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> handlers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http/httptest"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestHome</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { w := httptest.NewRecorder() home(w, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) resp := w.Result() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> have, want := resp.StatusCode, http.StatusOK; have != want { t.Errorf(<span class="hljs-string"><span class="hljs-string">"Status code is wrong. Have: %d, want: %d."</span></span>, have, want) } greeting, err := ioutil.ReadAll(resp.Body) resp.Body.Close() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> have, want := <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(greeting), <span class="hljs-string"><span class="hljs-string">"Hello! Your request was processed."</span></span>; have != want { t.Errorf(<span class="hljs-string"><span class="hljs-string">"The greeting is wrong. Have: %s, want: %s."</span></span>, have, want) } }</code> </pre> </div></div><br><p>  Run <code>go test</code> and check that the tests work: </p><br><pre> <code class="bash hljs">$ go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v ./... ? github.com/rumyantseva/advent-2017 [no <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> files] === RUN TestRouter --- PASS: TestRouter (0.00s) === RUN TestHome --- PASS: TestHome (0.00s) PASS ok github.com/rumyantseva/advent-2017/handlers 0.018s</code> </pre> <br><h3 id="shag-5-konfigurirovanie">  Step 5. Configuring </h3><br><p>  The next important step is the ability to configure the service.  Now at startup, the service always listens on port <code>8000</code> , and the ability to configure this value can be useful.  <a href="https://12factor.net/">The manifest of twelve-factor applications</a> , which is a very interesting approach to writing services, recommends that we store the configuration based on the environment.  So, <a href="https://github.com/rumyantseva/advent-2017/commit/a7446f5db919ed0ecd3b4f966ed9b4a399e68210">we will set the config for the port through the environment variable</a> : </p><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/rumyantseva/advent-2017/handlers"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// How to try it: PORT=8000 go run main.go func main() { log.Print("Starting the service...") port := os.Getenv("PORT") if port == "" { log.Fatal("Port is not set.") } r := handlers.Router() log.Print("The service is ready to listen and serve.") log.Fatal(http.ListenAndServe(":"+port, r)) }</span></span></code> </pre> </div></div><br><p>  In this example, if the port is not set, the application will immediately terminate with an error.  It makes no sense to try to continue working if the configuration is specified incorrectly. </p><br><h3 id="shag-6-makefile">  Step 6. Makefile </h3><br><p>  A few days ago, an <a href="https://blog.gopheracademy.com/advent-2017/make">article</a> about the <code>make</code> utility was published on the GopherAcademy blog, which can be very useful if you have to deal with repetitive actions.  Let's see how you can use this in our project.  Right now we have two repetitive actions: running tests and compiling and running a service.  <a href="https://github.com/rumyantseva/advent-2017/commit/90966780ba6656f8dc0aebd166938c9adcbe0514">Let's add these actions to the Makefile</a> , but instead of a simple <code>go run</code> we will now use the <code>go build</code> and then run the compiled binary, this option is better if in the future we are preparing an application for production: </p><br><div class="spoiler">  <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="hljs bash">APP?=advent PORT?=8000 clean: rm -f <span class="hljs-variable"><span class="hljs-variable">${APP}</span></span> build: clean go build -o <span class="hljs-variable"><span class="hljs-variable">${APP}</span></span> run: build PORT=<span class="hljs-variable"><span class="hljs-variable">${PORT}</span></span> ./<span class="hljs-variable"><span class="hljs-variable">${APP}</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>: go <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> -v -race ./...</code> </pre> </div></div><br><p>  In this example, we brought the name of the binary to a separate <code>APP</code> variable, so as not to repeat it several times. </p><br><p>  In addition, if we want to run the application in the manner described, we must first remove the old binary (if it exists).  Therefore, when running <code>make build</code> , <code>clean</code> is first called. </p><br><h3 id="shag-7-versionirovanie">  Step 7. Versioning </h3><br><p>  The next practice we add to the service is versioning.  Sometimes it is useful to know which particular build and even the commit we use in production, and when exactly the binary has been built. </p><br><p>  In order to store this information, add a new <code>version</code> - <code>version</code> : </p><br><div class="spoiler">  <b class="spoiler_title">version / version.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( <span class="hljs-comment"><span class="hljs-comment">// BuildTime is a time label of the moment when the binary was built BuildTime = "unset" // Commit is a last commit hash at the moment when the binary was built Commit = "unset" // Release is a semantic version of current build Release = "unset" )</span></span></code> </pre> </div></div><br><p>  We can log these variables when the application starts: </p><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs">... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"Starting the service...\ncommit: %s, build time: %s, release: %s"</span></span>, version.Commit, version.BuildTime, version.Release, ) ... }</code> </pre> </div></div><br><p>  And also we can add them to <code>home</code> (don't forget to fix the tests!): </p><br><div class="spoiler">  <b class="spoiler_title">handlers / home.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> handlers <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/rumyantseva/advent-2017/version"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// home is a simple HTTP handler function which writes a response. func home(w http.ResponseWriter, _ *http.Request) { info := struct { BuildTime string `json:"buildTime"` Commit string `json:"commit"` Release string `json:"release"` }{ version.BuildTime, version.Commit, version.Release, } body, err := json.Marshal(info) if err != nil { log.Printf("Could not encode info data: %v", err) http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable) return } w.Header().Set("Content-Type", "application/json") w.Write(body) }</span></span></code> </pre> </div></div><br><p>  We will use a linker to set the <code>BuildTime</code> , <code>Commit</code> and <code>Release</code> variables at compile time. </p><br><p>  Add new variables to the <code>Makefile</code> : </p><br><p> <code>Makefile</code> </p> <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">RELEASE</span></span>?=<span class="hljs-number"><span class="hljs-number">0.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>?=$(shell git rev-<span class="hljs-keyword"><span class="hljs-keyword">parse</span></span> <span class="hljs-comment"><span class="hljs-comment">--short HEAD) BUILD_TIME?=$(shell date -u '+%Y-%m-%d_%H:%M:%S')</span></span></code> </pre> <br><p>  Here, <code>COMMIT</code> and <code>BUILD_TIME</code> defined through specified commands, and for <code>RELEASE</code> we can use, for example, <a href="https://dave.cheney.net/2016/06/24/gophers-please-tag-your-releases">semantic versioning</a> or simply incremental versions of assemblies. </p><br><p>  Now we will rewrite the goal of the <code>build</code> in order to use the values ‚Äã‚Äãof these variables: </p><br><p> <code>Makefile</code> </p> <br><pre> <code class="hljs perl">build: clean go build \ -ldflags <span class="hljs-string"><span class="hljs-string">"-s -w -X </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${PROJECT}</span></span></span><span class="hljs-string">/version.Release=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${RELEASE}</span></span></span><span class="hljs-string"> \ -X </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${PROJECT}</span></span></span><span class="hljs-string">/version.Commit=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${COMMIT}</span></span></span><span class="hljs-string"> -X </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${PROJECT}</span></span></span><span class="hljs-string">/version.BuildTime=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${BUILD_TIME}</span></span></span><span class="hljs-string">"</span></span> \ -o ${APP}</code> </pre> <br><p>  We also added the <code>PROJECT</code> variable to the start of the <code>Makefile</code> in order not to repeat the same thing several times: </p><br><p> <code>Makefile</code> </p> <br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">PROJECT?</span></span>=github.com/rumyantseva/advent-<span class="hljs-number"><span class="hljs-number">2017</span></span></code> </pre> <br><p>  All changes made in this step can be found <a href="https://github.com/rumyantseva/advent-2017/commit/eaa4ff224b32fb343f5eac2a1204cc3806a22efd">here</a> .  Try <code>make run</code> to check how this works. </p><br><h3 id="shag-8-menshe-zavisimostey">  Step 8. Less dependencies! </h3><br><p>  There is one thing I don‚Äôt like about our code: the <code>handler</code> package depends on the <code>version</code> package.  Changing this is easy: we need to make the <code>home</code> function configurable: </p><br><p> <code>handlers/home.go</code> </p> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// home returns a simple HTTP handler function which writes a response. func home(buildTime, commit, release string) http.HandlerFunc { return func(w http.ResponseWriter, _ *http.Request) { ... } }</span></span></code> </pre> <br><p>  And, again, do not forget to correct the tests and make <a href="https://github.com/rumyantseva/advent-2017/commit/e73b996f8522b736c150e53db059cf041c7c3e64">all the necessary changes</a> . </p><br><h3 id="shag-9-helscheki">  Step 9. Helschek </h3><br><p>  In the case of launching the service in Kubernetes, it is usually required to add two helpers: <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/">liveness and readiness tests</a> .  The purpose of the liveness test is to give an understanding that the service has started.  If the liveness test fails, the service will be restarted.  The purpose of the readiness test is to give an understanding that the application is ready to receive traffic.  If the readiness fails, the container will be removed from the service load balancers. </p><br><p>  In order to determine the liveness test, you can write a simple handler, which always returns code <code>200</code> : </p><br><div class="spoiler">  <b class="spoiler_title">handlers / healthz.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// healthz is a liveness probe. func healthz(w http.ResponseWriter, _ *http.Request) { w.WriteHeader(http.StatusOK) }</span></span></code> </pre> </div></div><br><p>  For readiness samples, a similar solution is often enough, but sometimes it is necessary to wait for some event (for example, a database is ready) in order to start processing traffic: </p><br><div class="spoiler">  <b class="spoiler_title">handlers / readyz.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// readyz is a readiness probe. func readyz(isReady *atomic.Value) http.HandlerFunc { return func(w http.ResponseWriter, _ *http.Request) { if isReady == nil || !isReady.Load().(bool) { http.Error(w, http.StatusText(http.StatusServiceUnavailable), http.StatusServiceUnavailable) return } w.WriteHeader(http.StatusOK) } }</span></span></code> </pre> </div></div><br><p>  In this example, we return <code>200</code> only if the <code>isReady</code> variable <code>isReady</code> set and <code>true</code> . </p><br><p>  Let's see how this can be used: </p><br><div class="spoiler">  <b class="spoiler_title">handlers.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buildTime, commit, release </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mux</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Router</span></span></span></span> { isReady := &amp;atomic.Value{} isReady.Store(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"Readyz probe is negative by default..."</span></span>) time.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Second) isReady.Store(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) log.Printf(<span class="hljs-string"><span class="hljs-string">"Readyz probe is positive."</span></span>) }() r := mux.NewRouter() r.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/home"</span></span>, home(buildTime, commit, release)).Methods(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>) r.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/healthz"</span></span>, healthz) r.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/readyz"</span></span>, readyz(isReady)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r }</code> </pre> </div></div><br><p>  Here we say that the application is ready to handle traffic 10 seconds after launch.  Of course, in real life it makes no sense to wait 10 seconds, but maybe you want to add warm cache or something like that here. </p><br><p>  As always, full changes can be found <a href="https://github.com/rumyantseva/advent-2017/commit/e73b996f8522b736c150e53db059cf041c7c3e64">on GitHub</a> . </p><br><p>  <strong>Note.</strong>  <em>If the application receives too much traffic, it will start responding unstably.</em>  <em>For example, a liveness test may fail due to timeouts, and the container will be reloaded.</em>  <em>For this reason, some engineers prefer not to use liveness samples at all.</em>  <em>Personally, I think it is better to scale resources if you notice that more and more requests come to the service.</em>  <em>For example, you can try the <a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">automatic scaling of the stock through HPA</a> .</em> </p><br><h3 id="shag-10-graceful-shutdown">  Step 10. Graceful shutdown </h3><br><p>  When a service needs to be stopped, it‚Äôs good practice not to immediately disconnect connections, requests and other operations, but to handle them correctly.  Go supports "graceful shutdown" for <code>http.Server</code> , starting with version 1.8.  Consider <a href="https://github.com/rumyantseva/advent-2017/commit/93f8357d5f2a8fb0c978e5256d400dd00a393575">how this can be used</a> : </p><br><div class="spoiler">  <b class="spoiler_title">main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... r := handlers.Router(version.BuildTime, version.Commit, version.Release) interrupt := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> os.Signal, <span class="hljs-number"><span class="hljs-number">1</span></span>) signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM) srv := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">":"</span></span> + port, Handler: r, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { log.Fatal(srv.ListenAndServe()) }() log.Print(<span class="hljs-string"><span class="hljs-string">"The service is ready to listen and serve."</span></span>) killSignal := &lt;-interrupt <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> killSignal { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> os.Interrupt: log.Print(<span class="hljs-string"><span class="hljs-string">"Got SIGINT..."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> syscall.SIGTERM: log.Print(<span class="hljs-string"><span class="hljs-string">"Got SIGTERM..."</span></span>) } log.Print(<span class="hljs-string"><span class="hljs-string">"The service is shutting down..."</span></span>) srv.Shutdown(context.Background()) log.Print(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>) }</code> </pre> </div></div><br><p>  In this example, we intercept the system signals <code>SIGINT</code> and <code>SIGTERM</code> and, if one of them is caught, stop the service correctly. </p><br><p>  <strong>Note.</strong>  <em>When I wrote this code, I also tried to intercept <code>SIGKILL</code> here.</em>  <em>I saw this approach several times in different libraries and was sure that it worked.</em>  <em>But, as Sandor Sz√ºcs noted, intercepting <code>SIGKILL</code> impossible.</em>  <em>In the case of <code>SIGKILL</code> application will be stopped immediately.</em> </p><br><h3 id="shag-11-dockerfile">  Step 11. Dockerfile </h3><br><p>  Our application is almost ready to launch in Kubernetes, it's time to containerize it. </p><br><p>  The simplest <code>Dockerfile</code> , which will be needed, may look like this: </p><br><p> <code>Dockerfile</code> </p> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">FROM</span></span> scratch ENV PORT <span class="hljs-number"><span class="hljs-number">8000</span></span> EXPOSE <span class="hljs-variable"><span class="hljs-variable">$PORT</span></span> COPY advent / CMD [<span class="hljs-string"><span class="hljs-string">"/advent"</span></span>]</code> </pre> <br><p>  We create the lowest possible container, copy the binary there and run it (besides, we did not forget to forward the variable <code>PORT</code> ). </p><br><p>  Now let's change the <code>Makefile</code> bit and add the image build and the container launch there.  Here we can use two new variables: <code>GOOS</code> and <code>GOARCH</code> , which we will use for cross-compiling within the framework of the <code>build</code> goal. </p><br><div class="spoiler">  <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="hljs ruby">... GOOS?=linux GOARCH?=amd64 ... <span class="hljs-symbol"><span class="hljs-symbol">build:</span></span> clean CGO_ENABLED=<span class="hljs-number"><span class="hljs-number">0</span></span> GOOS=${GOOS} GOARCH=${GOARCH} go build \ -ldflags <span class="hljs-string"><span class="hljs-string">"-s -w -X ${PROJECT}/version.Release=${RELEASE} \ -X ${PROJECT}/version.Commit=${COMMIT} -X ${PROJECT}/version.BuildTime=${BUILD_TIME}"</span></span> \ -o ${APP} <span class="hljs-symbol"><span class="hljs-symbol">container:</span></span> build docker build -t $(APP)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>$(RELEASE) . <span class="hljs-symbol"><span class="hljs-symbol">run:</span></span> container docker stop $(APP)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>$(RELEASE) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; docker rm $(APP)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>$(RELEASE) <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> docker run --name ${APP} -p ${PORT}<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>${PORT} --rm \ -e <span class="hljs-string"><span class="hljs-string">"PORT=${PORT}"</span></span> \ $(APP)<span class="hljs-symbol"><span class="hljs-symbol">:</span></span>$(RELEASE) ...</code> </pre> </div></div><br><p>  So, we added the <code>container</code> target to build the image and adjusted the <code>run</code> target so that instead of launching the binary, the container now runs.  All changes are available <a href="https://github.com/rumyantseva/advent-2017/commit/909fef6d585c85c5e16b5b0e4fdbdf080893b679">here</a> . </p><br><p>  Now you can try running <code>make run</code> to check the whole process. </p><br><h3 id="shag-12-upravleniya-zavisimostyami">  Step 12. Addiction Management </h3><br><p>  There is one external dependency in our project - <code>github.com/gorilla/mux</code> .  And that means for an application that is really ready for production, you need to add <a href="https://github.com/rumyantseva/advent-2017/commit/7ffa56a78400367e5d633521dee816b767d7d05d">dependency management</a> .  If we use the <a href="https://github.com/golang/dep">dep</a> utility, then all we need to do is call the <code>dep init</code> command: </p><br><pre> <code class="bash hljs">$ dep init Using ^1.6.0 as constraint <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> direct dep github.com/gorilla/mux Locking <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v1.6.0 (7f08801) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> direct dep github.com/gorilla/mux Locking <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v1.1 (1ea2538) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> transitive dep github.com/gorilla/context</code> </pre> <br><p>  As a result, the <code>Gopkg.toml</code> and <code>Gopkg.lock</code> and the <code>vendor</code> directory containing all the dependencies used were created.  Personally, I prefer to push <code>vendor</code> in git, especially for important projects. </p><br><h3 id="shag-13-kubernetes">  Step 13. Kubernetes </h3><br><p>  And finally, the <a href="https://github.com/rumyantseva/advent-2017/commit/27b256191dc8d4530c895091c49b8a9293932e0f">final step</a> : run the application in Kubernetes.  The easiest way to try Kubernetes is to install and configure <a href="https://github.com/kubernetes/minikube">minikube</a> on your local environment. </p><br><p>  Kubernetes downloads images from the registry (Docker registry).  In our case, a public registry is enough - <a href="https://hub.docker.com/">Docker Hub</a> .  We will need another variable and another command in the <code>Makefile</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Makefile</b> <div class="spoiler_text"><pre> <code class="hljs mel">CONTAINER_IMAGE?=docker.io/webdeva/${APP} ... <span class="hljs-keyword"><span class="hljs-keyword">container</span></span>: build docker build -t $(CONTAINER_IMAGE):$(RELEASE) . ... push: <span class="hljs-keyword"><span class="hljs-keyword">container</span></span> docker push $(CONTAINER_IMAGE):$(RELEASE)</code> </pre> </div></div><br><p>  Here, the <code>CONTAINER_IMAGE</code> variable sets the registry repository, where we will send and where we will download images of containers.  As you can see, in this example, the user name ( <code>webdeva</code> ) is used in the registry path.  If you do not have an account on <a href="https://hub.docker.com/">hub.docker.com</a> , it's time to start it and then log in using the <code>docker login</code> .  After that you can send images to the registry. </p><br><p>  Let's try <code>make push</code> : </p><br><pre> <code class="bash hljs">$ make push ... docker build -t docker.io/webdeva/advent:0.0.1 . Sending build context to Docker daemon 5.25MB ... Successfully built d3cc8f4121fe Successfully tagged webdeva/advent:0.0.1 docker push docker.io/webdeva/advent:0.0.1 The push refers to a repository [docker.io/webdeva/advent] ee1f0f98199f: Pushed 0.0.1: digest: sha256:fb3a25b19946787e291f32f45931ffd95a933100c7e55ab975e523a02810b04c size: 528</code> </pre> <br><p>  Works!  Now the created image can be <a href="https://hub.docker.com/r/webdeva/advent/tags/">found in the registry</a> . </p><br><p>  We define the necessary configurations (manifests) for Kubernetes.  They are static files in JSON or YAML format, so for the substitution of "variables" we will have to use the help of the <code>sed</code> utility.  In this example, we will look at three types of resources: <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">deployment</a> , <a href="https://kubernetes.io/docs/concepts/services-networking/service/">service,</a> and <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">ingress</a> . </p><br><p>  <strong>Note.</strong>  <em>The <a href="https://github.com/kubernetes/helm">helm</a> project solves the problem of managing the release of configurations in Kubernetes in general and addresses the issues of creating flexible configurations in particular.</em>  <em>So if simple <code>sed</code> not enough, it makes sense to get to know Helm.</em> </p><br><p>  Consider the configuration for deployment: </p><br><div class="spoiler">  <b class="spoiler_title">deployment.yaml</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">apiVersion</span></span>: extensions/v1beta1 kind: <span class="hljs-type"><span class="hljs-type">Deployment</span></span> metadata: name: {{ .<span class="hljs-type"><span class="hljs-type">ServiceName</span></span> }} labels: app: {{ .<span class="hljs-type"><span class="hljs-type">ServiceName</span></span> }} spec: replicas: <span class="hljs-number"><span class="hljs-number">3</span></span> strategy: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RollingUpdate</span></span></span><span class="hljs-class"> rollingUpdate: maxUnavailable: 50% maxSurge: 1 template: metadata: labels: app: {{ .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ServiceName</span></span></span><span class="hljs-class"> }} spec: containers: - name: {{ .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ServiceName</span></span></span><span class="hljs-class"> }} image: docker.io/webdeva/{{ .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ServiceName</span></span></span><span class="hljs-class"> }}:{{ .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Release</span></span></span><span class="hljs-class"> }} imagePullPolicy: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Always</span></span></span><span class="hljs-class"> ports: - containerPort: 8000 livenessProbe: httpGet: path: /healthz port: 8000 readinessProbe: httpGet: path: /readyz port: 8000 resources: limits: cpu: 10m memory: 30Mi requests: cpu: 10m memory: 30Mi terminationGracePeriodSeconds: 30</span></span></code> </pre> </div></div><br><p>  Kubernetes configuration issues are best addressed in a separate article, but, as you can see, among other things, the registry and the container image are defined, as well as the rules for liveness and readiness samples. </p><br><p>  The typical configuration for service looks simpler: </p><br><div class="spoiler">  <b class="spoiler_title">service.yaml</b> <div class="spoiler_text"><pre> <code class="hljs django"><span class="xml"><span class="xml">apiVersion: v1 kind: Service metadata: name: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"><span class="xml"> labels: app: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"><span class="xml"> spec: ports: - port: 80 targetPort: 8000 protocol: TCP name: http selector: app: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> </div></div><br><p>  And finally, ingress.  Here we define the configuration of the ingress controller, which will help, for example, to access the service from outside Kubernetes.  Suppose we want to send requests to the service when accessing the domain <code>advent.test</code> (which in reality, of course, does not exist): </p><br><div class="spoiler">  <b class="spoiler_title">ingress.yaml</b> <div class="spoiler_text"><pre> <code class="hljs django"><span class="xml"><span class="xml">apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: kubernetes.io/ingress.class: nginx ingress.kubernetes.io/rewrite-target: / labels: app: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"><span class="xml"> name: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"><span class="xml"> spec: backend: serviceName: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"><span class="xml"> servicePort: 80 rules: - host: advent.test http: paths: - path: / backend: serviceName: </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ .ServiceName }}</span></span><span class="xml"><span class="xml"> servicePort: 80</span></span></code> </pre> </div></div><br><p>  In order to check how the configuration works, install the <code>minikube</code> using its <a href="https://github.com/kubernetes/minikube">official documentation</a> .  In addition, we need the <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">kubectl</a> utility to apply the configurations and test the service. </p><br><p>  To start <code>minikube</code> , enable ingress and prepare <code>kubectl</code> will need the following commands: </p><br><pre> <code class="bash hljs">minikube start minikube addons <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> ingress kubectl config use-context minikube</code> </pre> <br><p>  Now add a separate target to the <code>Makefile</code> to install the service in the <code>minikube</code> : </p><br><p> <code>Makefile</code> </p> <br><pre> <code class="hljs tex">minikube: push for t in <span class="hljs-formula"><span class="hljs-formula">$(shell find ./kubernetes/advent -type f -name "*.yaml"); do </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">cat $</span></span><span class="hljs-formula"><span class="hljs-formula">$t | </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">gsed -E "s/</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">{</span></span></span></span></span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">{</span></span></span></span></span><span class="hljs-formula">(</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">s*</span></span></span></span></span><span class="hljs-formula">)</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span></span><span class="hljs-formula">Release(</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">s*</span></span></span></span></span><span class="hljs-formula">)</span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">}</span></span></span></span></span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name">}</span></span></span></span></span><span class="hljs-formula">/$</span></span>(RELEASE)/g" | <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>gsed -E "s/<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">{</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">{</span></span></span></span>(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">s*</span></span></span></span>)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">.</span></span></span></span>ServiceName(<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">s*</span></span></span></span>)<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">}</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">}</span></span></span></span>/<span class="hljs-formula"><span class="hljs-formula">$(APP)/g"; </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">echo ---; </span><span class="hljs-tag"><span class="hljs-formula"><span class="hljs-tag">\</span></span><span class="hljs-name"><span class="hljs-formula"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span></span><span class="hljs-formula">done &gt; tmp.yaml kubectl apply -f tmp.yaml</span></span></code> </pre> <br><p>  These commands "compile" all <code>*.yaml</code> configurations into one file, replace the "variables" <code>Release</code> and <code>ServiceName</code> real values ‚Äã‚Äã(I use <code>gsed</code> instead of the usual <code>sed</code> ) and run <code>kubectl apply</code> to install the application in Kubernetes. </p><br><p>  Check how the configurations were applied: </p><br><pre> <code class="bash hljs">$ kubectl get deployment NAME DESIRED CURRENT UP-TO-DATE AVAILABLE AGE advent 3 3 3 3 1d $ kubectl get service NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE advent 10.109.133.147 &lt;none&gt; 80/TCP 1d $ kubectl get ingress NAME HOSTS ADDRESS PORTS AGE advent advent.test 192.168.64.2 80 1d</code> </pre> <br><p>  Now we will try to send a request to the service through the specified domain.  First of all, we need to add the domain <code>advent.test</code> to the local <code>/etc/hosts</code> (for Windows - <code>%SystemRoot%\System32\drivers\etc\hosts</code> ): </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(minikube ip)</span></span></span><span class="hljs-string"> advent.test"</span></span> | sudo tee -a /etc/hosts</code> </pre> <br><p>  And now you can check the work of the service: </p><br><pre> <code class="bash hljs">curl -i http://advent.test/home HTTP/1.1 200 OK Server: nginx/1.13.6 Date: Sun, 10 Dec 2017 20:40:37 GMT Content-Type: application/json Content-Length: 72 Connection: keep-alive Vary: Accept-Encoding {<span class="hljs-string"><span class="hljs-string">"buildTime"</span></span>:<span class="hljs-string"><span class="hljs-string">"2017-12-10_11:29:59"</span></span>,<span class="hljs-string"><span class="hljs-string">"commit"</span></span>:<span class="hljs-string"><span class="hljs-string">"020a181"</span></span>,<span class="hljs-string"><span class="hljs-string">"release"</span></span>:<span class="hljs-string"><span class="hljs-string">"0.0.5"</span></span>}%</code> </pre> <br><p>  Hurray, it works! </p><br><hr><br><p>  All manual steps can be found <a href="https://github.com/rumyantseva/advent-2017">here</a> , two options are available: <a href="https://github.com/rumyantseva/advent-2017/commits/master">commit-for-commit</a> and <a href="https://github.com/rumyantseva/advent-2017/tree/all-steps">all steps in one directory</a> .  If you have questions, you can <a href="https://github.com/rumyantseva/advent-2017/issues/new">create an issue</a> , knock me on Twitter: <a href="https://twitter.com/webdeva">@webdeva</a> , or just leave a comment here. </p><br><p>  If you are wondering what a real and more flexible production-ready service might look like, look at the project <a href="https://github.com/takama/k8sapp">takama / k8sapp</a> - a Go-application template that satisfies the requirements of Kubernetes. </p><br><p>  PS I express my gratitude to <a href="https://twitter.com/NataliePis">Natalie Pistunovich</a> , <a href="https://twitter.com/object88">Paul Brousseau</a> , <a href="https://twitter.com/sszuecs">Sandor Sz√ºcs</a> , <a href="https://github.com/bregor">Maxim Filatov</a> and other community members for reviewing and commenting. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/345332/">https://habr.com/ru/post/345332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345322/index.html">Karmic incompatibility and other vicissitudes of service engineer</a></li>
<li><a href="../345324/index.html">Pygest # 20. Releases, articles, interesting projects, packages and libraries from the world of Python [December 6, 2017 - December 23, 2017]</a></li>
<li><a href="../345326/index.html">Is there life without standards in javascript?</a></li>
<li><a href="../345328/index.html">Simulation of the simplest statements</a></li>
<li><a href="../345330/index.html">Using Roslyn to edit game content</a></li>
<li><a href="../345336/index.html">We spread the application in the App Store. Even if you are not a developer</a></li>
<li><a href="../345340/index.html">A story about how to create a repository and understand Redux</a></li>
<li><a href="../345342/index.html">What are dangerous social networks on your PC?</a></li>
<li><a href="../345344/index.html">Sending a request to the specified MS SQL Server databases of all the specified servers using available tools</a></li>
<li><a href="../345346/index.html">Nebraska problem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>