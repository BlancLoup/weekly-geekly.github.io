<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 15. Memory sections: services and data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we continue to consider sections of RTOS memory. 

 Nucleus RTOS has three API calls that provide utility functions related to memory...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 15. Memory sections: services and data structures</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/3t/wd/au/3twdaubgcbrqlkg0al5lttnqs-y.jpeg"><br><br>  In this article, we continue to consider sections of RTOS memory. <br><br>  Nucleus RTOS has three API calls that provide utility functions related to memory partition pools: returning partition pool information, returning the number of partition pools in an application, and returning pointers to all partition pools in an application.  The first two calls are implemented in the Nucleus SE. <br><a name="habracut"></a><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> <br><h2>  Retrieving partition pool information </h2><br>  This service call allows you to get partial information about the partition pool.  The implementation of the Nucleus SE differs from the Nucleus RTOS in that less information is returned in it, since the assignment of names to the objects and suspension requests are not supported, and the suspension of the task is impossible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Calling for information about the partition pool in Nucleus RTOS </h3><br>  Call prototype: <br><br>  <b>STATUS NU_Partition_Pool_Information (NU_PARTITION_POOL * pool, CHAR * name, VOID ** start_address, UNSIGNED * pool_size, UNSIGNED * partition_size, UNSIGNED * available, UNSIGNED * allocated, OPTION * suspend_type, UNSIGNED * tasks_waiting, NU_TEP, NU_TED, NU_EDED, UNTIGNED, UNSIGNED * allocated, UNSIGNED * pool_size</b> <br><br>  Options: <br><br>  <b>pool</b> - pointer to the partition pool about which information is requested; <br>  <b>name</b> - pointer to the 8-character destination area for the name of the partition pool;  includes space for terminating zero; <br>  <b>start_address</b> - a pointer to a variable that receives a pointer to the beginning of the section pool data area; <br>  <b>pool_size</b> - pointer to the variable that receives the size of the partition pool (in bytes); <br>  <b>partition_size</b> - a pointer to a variable that receives the size of partitions in this pool; <br>  <b>available</b> - a pointer to a variable that receives the number of currently available partitions in this pool; <br>  <b>allocated</b> - a pointer to a variable that receives the number of currently used sections in this pool; <br>  <b>suspend_type</b> - a pointer to a variable to get the type of task suspension;  valid suspension types are <b>NU_FIFO</b> and <b>NU_PRIORITY</b> ; <br>  <b>tasks_waiting</b> - pointer to a variable that receives the number of suspended tasks in this section pool; <br>  <b>first_task</b> is a pointer to the task pointer in which the pointer to the first suspended task is located. <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was made successfully; <br>  <b>NU_INVALID_POOL</b> - invalid pointer to partition pool. <br><br><h3>  Calling for information about partitioning in Nucleus SE </h3><br>  Call prototype: <br><br>  <b>STATUS NUSE_Partition_Pool_Information (NUSE_PARTITION_POOL pool, ADDR * start_address, U32 * pool_size, U16 * partition_size, U8 * available, U8 * allocated, U8 * tasks_waiting, NUSE_TASK * first_task)</b> <br><br>  Options: <br><br>  <b>pool</b> - index of the partition pool about which information is requested; <br>  <b>start_address</b> - a pointer to a variable that receives a pointer to the beginning of the section pool data area; <br>  <b>pool_size</b> - pointer to the variable that receives the size of the partition pool (in bytes); <br>  <b>partition_size</b> - a pointer to a variable that receives the size of partitions in this pool; <br>  <b>available</b> - a pointer to a variable that receives the number of currently available partitions in this pool; <br>  <b>allocated</b> - a pointer to a variable that receives the number of currently used sections in this pool; <br>  <b>tasks_waiting</b> - pointer to a variable that receives the number of suspended tasks in this section pool (if task suspension is disabled, 0 is returned); <br>  <b>first_task</b> - a pointer to a variable of type <b>NUSE_TASK</b> , which receives the index of the first suspended task (if the task suspension is disabled, 0 is returned). <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was made successfully; <br>  <b>NUSE_INVALID_POOL</b> - incorrect partition pool index; <br>  <b>NUSE_INVALID_POINTER</b> - one or more of the passed pointers are incorrect. <br><br><h3>  Implementing information retrieval and partitioning in Nucleus SE </h3><br>  Implementing such an API call is simple: <br><br><img src="https://habrastorage.org/webt/ia/82/sj/ia82sj807l4yuaio-mvf-ypjivm.jpeg"><br><br>  The function returns the status of the partition pool.  Then, if the blocking of API calls is activated, the number of pending tasks and the index of the first one are returned (otherwise, these parameters are set to 0). <br><br><h2>  Getting the number of partition pools </h2><br>  This call returns information about the number of partition pools configured in the application.  While in Nucleus RTOS, this number changes over time, and the return value will represent the current number of pools, in Nucleus SE, the return value is set at build time and remains unchanged. <br><br><h3>  Call to get the number of partition pools in the Nucleus RTOS </h3><br>  The call supports the core functionality of the Nucleus RTOS API. <br><br>  Call prototype: <br><br>  <b>UNSIGNED NU_Established_Partition_Pools (VOID);</b> <br><br>  Options: <br><br>  None. <br><br>  Return value: <br><br>  The number of partition pools created in the application. <br><br><h3>  Call to get the number of partition pools in a Nucleus SE </h3><br>  This service call supports the core functionality of the Nucleus RTOS API. <br><br>  Call prototype: <br><br>  <b>U8 NUSE_Partition_Pool_Count (void);</b> <br><br>  Options: <br><br>  Absent <br><br>  Return value: <br><br>  The number of partition pools created in the application. <br><br><h3>  Implementation </h3><br>  The implementation of this API call is extremely simple: the <b>#define</b> value of the character <b>NUSE_PARTITION_POOL_NUMBER is returned</b> . <br><br><h2>  Data structures </h2><br>  Like all other Nucleus SE objects, partition pools use structure arrays in both ROM and RAM, the number of which depends on the number of pools specified in the settings. <br><br>  I strongly recommend that application code refer to such data structures through API functions, rather than directly.  This will avoid incompatibility with future versions of the Nucleus SE and unwanted side effects, and also simplifies porting the application to the Nucleus RTOS.  Below is a detailed description of the data structures for easier understanding of the work of the call code and for debugging. <br><br><h3>  The data structure of the kernel, placed in RAM </h3><br>  These data structures include: <br><br>  <b>NUSE_Partition_Pool_Partition_Used []</b> - an array of type <b>U8</b> , having one entry for each configured partition pool, containing a counter of the pools currently used; <br>  <b>NUSE_Partition_Pool_Blocking_Count []</b> is an array of type <b>U8</b> containing a counter of blocked tasks in each pool of partitions.  This array exists if blocking an API call is possible. <br><br>  Such data structures are initialized with zeros using <b>NUSE_Init_ Partition_Pool ()</b> when the Nucleus SE is started.  This is logical because it makes every section in each pool unused (free).  The next article will provide a full description of startup procedures in the Nucleus SE. <br><br>  Below are descriptions of the data structures in the <b>nuse_init.c</b> file. <br><br><img src="https://habrastorage.org/webt/vi/3x/sx/vi3xsxmbwdzkwgfge9ws_dsvups.jpeg"><br><br><h3>  User data in RAM </h3><br>  The user needs to allocate an area in the RAM for storing data for each partition pool.  The amount of space in RAM must correspond to the volume of configured partitions (see ‚ÄúData in ROM‚Äù below) with an additional byte for each partition in the pool.  Each section of the data area is preceded by one status byte. <br><br><h3>  ROM data </h3><br>  These include: <br><br>  <b>NUSE_Partition_Pool_Data_Address []</b> is an array of type <b>ADDR</b> , with one entry for each configured partition pool, containing the address of the beginning of the storage area; <br>  <b>NUSE_Partition_Pool_Partition_Number []</b> - an array of type <b>U8</b> with one entry for each configured partition pool, containing information on the number of partitions in the pool; <br>  <b>NUSE_Partition_Pool_Partition_Size []</b> is an <b>U16</b> type array with one entry for each configured partition pool, containing the partition size for the pools. <br><br>  Such data structures are declared and initialized (statically) in <b>nuse_config.c</b> : <br><br><img src="https://habrastorage.org/webt/zt/67/lq/zt67lqadvkdzmuvazbj0mmlhp8a.jpeg"><br><br><h3>  Memory footprint for partition pool </h3><br>  As with all kernel objects in Nucleus SE, the amount of memory required for partition pools is predictable. <br><br>  The ROM size (in bytes) for all pools of application partitions can be calculated as follows: <br><br>  <b>NUSE_PARTITION_POOL_NUMBER * (sizeof (ADDR) + 2)</b> <br><br>  The amount of kernel data in RAM for all application pool partitions with activated blocking of API calls takes up only 2 bytes per partition pool, and with no blocking activated - 1 byte. <br><br>  The amount of memory for storing user data in RAM varies for each partition pool, although, as already mentioned, for a pool with index n it can be calculated as: <br><br>  <b>NUSE_Partition_Pool_Partition_Number [n] *</b> <br>  <b>(NUSE_Partition_Pool_Partition_Size [n] + 1)</b> <br><br><h2>  Unrealized API calls </h2><br>  Three API calls for partition pools, implemented in the Nucleus RTOS, are not supported in Nucleus SE. <br><br><h3>  Create Partition Pool </h3><br>  This API call creates a pool of sections.  In the Nucleus SE, it is not necessary because tasks are created statically. <br><br>  Call prototype: <br><br>  <b>STATUS NU_Create_Partition_Pool (NU_PARTITION_POOL * pool, CHAR * name, VOID * start_address, UNSIGNED pool_size, UNSIGNED partition_size, OPTION suspend_type);</b> <br><br>  Options: <br><br>  <b>pool</b> - a pointer to a user control for partition <b>pool</b> management;  used as a ‚Äúhandle‚Äù for the section pool in other API calls; <br>  <b>name</b> is a pointer to the name of the partition pool, a 7-character string with a zero terminator; <br>  <b>start_address</b> - sets the starting address for the memory area of ‚Äã‚Äãthe partition pool; <br>  <b>pool_size</b> is the total amount of memory in bytes; <br>  <b>partition_size</b> is the amount of memory in bytes for each partition in the pool.  Above this, there is an additional small amount of memory associated with each partition, which is realized thanks to the two data pointers used. <br>  <b>suspend_type</b> - defines how tasks are suspended in the partition pool;  valid parameter options are <b>NU_FIFO</b> and <b>NU_PRIORITY</b> . <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - indicates the successful completion of the call; <br>  <b>NU_INVALID_POOL</b> - indicates the zero value of the partition pool control unit ( <b>NULL</b> ); <br>  <b>NU_INVALID_MEMORY</b> - indicates the zero value of the memory area defined by <b>start_ address</b> ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> - indicates that the partition size is either 0 or greater than the memory allocated for the partition; <br>  <b>NU_INVALID_SUSPEND</b> - incorrect value of <b>suspend_type</b> . <br><br><h3>  Deleting a partition pool </h3><br>  This API call removes the previously created partition pool.  In the Nucleus SE, it is not necessary, since objects are created statically and cannot be deleted. <br><br>  Call prototype: <br><br>  <b>STATUS NU_Delete_Partition_Pool (NU_PARTITION_POOL * pool);</b> <br><br>  Options: <br><br>  <b>pool</b> - a pointer to the block pool control unit; <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - indicates the successful completion of the call; <br>  <b>NU_INVALID_POOL</b> - indicates an incorrect value of the partition pool pointer; <br><br><h3>  Section Pool Pointers </h3><br>  This API call builds a sequential list of pointers to all partition pools in the system.  This is not necessary in the Nucleus SE, since objects are identified by an index, not a pointer. <br><br>  Call prototype: <br><br>  <b>UNSIGNED NU_Partition_Pool_Pointers (NU_PARTITION_POOL ** pointer_list, UNSIGNED maximum_pointers);</b> <br><br>  Options: <br><br>  <b>pointer_list</b> - pointer to array of pointers <b>NU_PARTITION_POOL</b> ;  the array is filled with pointers to the configured pools in the system; <br>  <b>maximum_pointers</b> - the maximum number of pointers that can be placed in an array. <br><br>  Return value: <br><br>  The number of <b>NU_PARTITION_POOL</b> pointers placed in an array. <br><br><h2>  Nucleus RTOS Compatibility </h2><br>  When developing the Nucleus SE, one of the main tasks was to ensure a high level of code compatibility with Nucleus RTOS.  Partition pools are no exception, and, from a developer‚Äôs point of view, they are implemented in much the same way as in Nucleus RTOS.  Some existing areas of incompatibility are acceptable, although it is worth considering that the final code is easier to understand and more efficient in terms of memory.  However, Nucleus RTOS API calls can be almost directly used as Nucleus SE calls.  In the future, an article is planned with information on the use of Nucleus SE by users of Nucleus RTOS. <br><br><h3>  Object IDs </h3><br>  In Nucleus RTOS, all objects are described by data structures (control units) of a particular type.  A pointer to this control block is used as an identifier for the partition pool.  I decided that a different approach was needed in Nucleus SE to use memory more efficiently.  All kernel objects are described by several tables in RAM and / or ROM.  The sizes of these tables are determined by the number of configurable types of all objects.  The identifier for a particular object is the index in these tables.  Therefore, I have defined <b>NUSE_PARTITION_POOL</b> equivalent to <b>U8</b> , after which the variable (not a pointer) of this type serves as the task identifier.  This small incompatibility is easy to understand if the code is ported from or to Nucleus RTOS.  Object identifiers are usually stored and transmitted unchanged. <br><br>  Nucleus RTOS also supports naming of partition pools.  These names are used only when debugging.  I excluded them from the Nucleus SE to save memory. <br><br><h3>  The number of sections and their volume </h3><br>  In the Nucleus RTOS, the partition pool is configured for the total volume of the pool and the volume of the partitions (which carry 2 more pointers).  These parameters are defined as UNSIGNED (approximately 32 bits).  In the Nucleus SE, the partition pool is configured based on the volume of the partition (for which an extra byte is added) and the total number of partitions.  These parameters are defined as U16 and U8, respectively. <br><br><h3>  Unrealized API calls </h3><br>  Nucleus RTOS supports 7 partitioning calls, 3 of which are not implemented in Nucleus SE.  In more detail about these calls and about the reasons of their exception is stated above. <br><br>  The next article will be devoted to signals. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/426477/">https://habr.com/ru/post/426477/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426465/index.html">"We are changing the relief of the earth" - IT goes to a large construction site</a></li>
<li><a href="../426469/index.html">Telegram as corporate standard</a></li>
<li><a href="../426471/index.html">How data flows from spyware applications</a></li>
<li><a href="../426473/index.html">Redux architecture. Yes or no?</a></li>
<li><a href="../426475/index.html">Miya - helper from the smartphone</a></li>
<li><a href="../426479/index.html">Homemade test bench for motherboards</a></li>
<li><a href="../426481/index.html">Unity Hexagon Maps: Path Search, Player Squads, Animation</a></li>
<li><a href="../426483/index.html">The one who overtakes Tesla. For more profitable</a></li>
<li><a href="../426485/index.html">Third check of Qt 5 with PVS-Studio</a></li>
<li><a href="../426487/index.html">Test automation from scratch. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>