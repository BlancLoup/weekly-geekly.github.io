<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using readable and writable images in OpenCL 2.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before OpenCL 2.0, it was impossible to carry out read and write operations of the image within the same core. You could declare images as CL_MEM_READ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using readable and writable images in OpenCL 2.0</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/38f/f10/b7c/38ff10b7c857489ab5d1cb2f70a22482.jpg">  Before OpenCL 2.0, it was impossible to carry out read and write operations of the image within the same core.  You could declare images as <i>CL_MEM_READ_WRITE</i> , but after transferring the image, the kernel had to choose one of two <i>things</i> : either <i>__ read_only</i> (read-only access) or <i>__ write_only</i> ( <i>write</i> -only access).  OpenCL 2.0 has the ability to read and write images within the same core.  However, there are several features that we will discuss in detail in this post. <br><a name="habracut"></a><br><pre><code class="cpp hljs">input1 = clCreateImage( oclobjects.context, CL_MEM_READ_WRITE|CL_MEM_COPY_HOST_PTR, &amp;format, &amp;desc, &amp;input_data1[<span class="hljs-number"><span class="hljs-number">0</span></span>], &amp;err ); SAMPLE_CHECK_ERRORS( err );</code> </pre>  <i>Code snippet 1. You could create an image buffer using CL_MEM_READ_WRITE</i> <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Alpha</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __read_write </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inputImage1, __read_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inputImage2, uint width, uint height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gamma )</span></span></span></span></code> </pre>  <i>Code snippet 2. In OpenCL 2.0, it became possible to read and write images within a single core.</i> <br><br><h2>  <font color="#0071c5">The advantages of images available for reading and writing</font> </h2><br>  Convolving images is less effective when using the new functionality of reading and writing images, but other image processing algorithms can get significant benefits from this functionality.  One example of such a process may be imaging. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In OpenCL 1.2 and earlier versions, only the __read_only and __write_only qualifiers could have an image.  In OpenCL 2.0, the qualifier __read_write has appeared, the output can be copied to the input buffer.  This reduces the number of required resources.  For any image changes, you need to process the image as a buffer and work with this buffer (see <a href="https://software.intel.com/en-us/articles/using-image2d-from-buffer-extension">cl_khr_image2d_from_buffer</a> ). <br><br>  The current solution is to process the images as buffers and manage the buffers.  To process two-dimensional images as buffers, a certain amount of resources are required.  It also becomes impossible to use the cut and filter capabilities available in read_images.  Therefore, it is advisable to use images with the read_write qualifier. <br><br><h2>  <font color="#0071c5">Sample Overview</font> </h2><br>  In the example, two bitmap images (input1.bmp and input2.bmp) are buffered.  These images are then superimposed one on the other based on the alpha value (this is a weight factor in the pixel equation).  The alpha value is passed as a parameter. <br><br><img src="https://habrastorage.org/files/563/f35/e66/563f35e66f1b4fc6a53db52e0fdc1103.png"><br>  <i>Figure 1. Alpha = 0.84089642</i> <br><br>  Input images must be 24- or 32-bit.  The output is a 24-bit image.  Input images must be the same size.  Images were in ARGB format, this was taken into account when loading them. <br><br><img src="https://habrastorage.org/files/455/e2c/6b0/455e2c6b0b674c74bc2fa2075f16c5f6.png"><br>  <i>Figure 2. Alpha = 0.32453</i> <br><br>  The ARGB format is converted to RGBA.  Changing the beta value causes a significant change in the output image. <br>  SDK usage <br>  The SDK demonstrates image overlay using read and write.  To control the operation of the sample code, you can use the following command line parameters. <br><table><tbody><tr><th>  Options </th><th>  Description </th></tr><tr><td>  -h, --help </td><td>  Display this text and exit. </td></tr><tr><td>  -p, --platform &lt;number or string&gt; </td><td>  Selection of the platform whose devices are used. </td></tr><tr><td>  -t, --type all |  cpu |  gpu |  acc |  default |  &lt;OpenCL constant for device type&gt; </td><td>  Select the type of device on which the OpenCL core is running. </td></tr><tr><td>  -d, --device &lt;number or string&gt; </td><td>  Select the device on which all work is performed. </td></tr><tr><td>  -i, --infile &lt;24-bit or 32-bit input bmp file&gt; </td><td>  The name of the first readable file in BMP format.  The default is <b>input1.bmp</b> . </td></tr><tr><td>  -j, --infile &lt;24-bit or 32-bit input bmp file&gt; </td><td>  The name of the second readable file in BMP format.  The default is <b>input2.bmp</b> . </td></tr><tr><td>  -o, --outfile &lt;24-bit or 32-bit input bmp file&gt; </td><td>  The name of the output file to write to.  The default is <b>output.bmp</b> for OCL1.2 and <b>20_output.bmp</b> for OCL2.0. </td></tr><tr><td>  -a, - alpha &lt;floating-point value from zero to one&gt; </td><td>  A non-zero positive value that determines how much two images will be superimposed on each other when combined.  The default alpha value is 0.84089642.  The default beta value is 0.15950358. </td></tr></tbody></table><br>  Default values ‚Äã‚Äãare set in the sample SDK, so the application can work without any input from the user.  Users can use their own input BMP files.  All files must be 24-bit or 32-bit.  The alpha value determines how much the first image will overlap the second. <br><br><pre> <code class="cpp hljs">calculatedPixel = ((currentPixelImage1 * alpha) + (currentPixeImage2 * beta) + gamma);</code> </pre><br>  The beta value is equal to the difference between the unit and the alpha value. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> beta = <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äì alpha;</code> </pre><br>  These two values ‚Äã‚Äãdetermine the "weight" of images 1 and 2 in the output image. <br>  To change the brightness of each pixel, you can use the value of gamma.  By default, this value is zero.  The user can change the brightness of the finished image as a whole. <br><br><h2>  <font color="#0071c5">An example of running the program</font> </h2><br><img src="https://habrastorage.org/files/13e/019/84e/13e01984efc84f948733a8a970a1d698.png"><br>  <i>Figure 3. Running the program on an OpenCL 2.0 device</i> <br><br><h2>  <font color="#0071c5">Limitations of images available for reading and writing</font> </h2><br>  Limiters cannot be used with images that require synchronization between different work groups.  To convolve images, synchronization of all streams is required.  Convolution with respect to images usually involves mathematical operations on two matrices and the creation of a third matrix as a result.  The image convolution example uses Gaussian blur.  Other examples use image sharpening, edge detection and embossing. <br><br>  As an example, consider the Gaussian blur.  A Gaussian filter is a low pass filter that removes high frequency values.  As a result, the image detail level decreases and a blur effect is obtained.  Applying a Gaussian blur is the same as transforming an image using a Gaussian distribution function (often referred to as a mask).  To demonstrate the functionality of reading and writing images had to apply a blur horizontally and vertically. <br><br>  In OpenCL 1.2, this would have to be done in two passes.  One core would be used only for horizontal blur, and the other for vertical blur.  The result of one blur will be used as input for the next (depending on which blur was the first). <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GaussianBlurHorizontalPass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __read_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inputImage, __write_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outputImage, __constant </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maskSize)</span></span></span><span class="hljs-function"> </span></span>{ int2 currentPosition = (int2)(get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>), get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>)); float4 currentPixel = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); float4 calculatedPixel = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskIndex = -maskSize; maskIndex &lt; maskSize+<span class="hljs-number"><span class="hljs-number">1</span></span>; ++maskIndex) { currentPixel = read_imagef(inputImage, imageSampler, currentPosition + (int2)(maskIndex, <span class="hljs-number"><span class="hljs-number">0</span></span>)); calculatedPixel += currentPixel * mask[maskSize + maskIndex]; } write_imagef(outputImage, currentPosition, calculatedPixel); } __<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GaussianBlurVerticalPass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __read_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inputImage, __write_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outputImage, __constant </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maskSize)</span></span></span><span class="hljs-function"> </span></span>{ int2 currentPosition = (int2)(get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>), get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>)); float4 currentPixel = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); float4 calculatedPixel = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskIndex = -maskSize; maskIndex &lt; maskSize+<span class="hljs-number"><span class="hljs-number">1</span></span>; ++maskIndex) { currentPixel = read_imagef(inputImage, imageSampler, currentPosition + (int2)(<span class="hljs-number"><span class="hljs-number">0</span></span>, maskIndex)); calculatedPixel += currentPixel * mask[maskSize + maskIndex]; } write_imagef(outputImage, currentPosition, calculatedPixel); }</code> </pre>  <i>Code snippet 3. Gauss blur kernel in OpenCL 1.2</i> <br><br>  In OpenCL 2.0, these two cores can be merged into one.  Use the limiter to force the blur to finish horizontally or vertically before starting the next blur. <br><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">kernel </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GaussianBlurDualPass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __read_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inputImage, __read_write </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tempRW, __write_only </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">image2d_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> outputImage, __constant </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">* mask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maskSize)</span></span></span><span class="hljs-function"> </span></span>{ int2 currentPosition = (int2)(get_global_id(<span class="hljs-number"><span class="hljs-number">0</span></span>), get_global_id(<span class="hljs-number"><span class="hljs-number">1</span></span>)); float4 currentPixel = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); float4 calculatedPixel = (float4)(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) currentPixel = read_imagef(inputImage, currentPosition); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskIndex = -maskSize; maskIndex &lt; maskSize+<span class="hljs-number"><span class="hljs-number">1</span></span>; ++maskIndex) { currentPixel = read_imagef(inputImage, currentPosition + (int2)(maskIndex, <span class="hljs-number"><span class="hljs-number">0</span></span>)); calculatedPixel += currentPixel * mask[maskSize + maskIndex]; } write_imagef(tempRW, currentPosition, calculatedPixel); barrier(CLK_GLOBAL_MEM_FENCE); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maskIndex = -maskSize; maskIndex &lt; maskSize+<span class="hljs-number"><span class="hljs-number">1</span></span>; ++maskIndex) { currentPixel = read_imagef(tempRW, currentPosition + (int2)(<span class="hljs-number"><span class="hljs-number">0</span></span>, maskIndex)); calculatedPixel += currentPixel * mask[maskSize + maskIndex]; } write_imagef(outputImage, currentPosition, calculatedPixel); }</code> </pre>  <i>Code snippet 4. Gauss blur kernel in OpenCL 2.0</i> <br><br>  It turned out that the limiters are ineffective.  The use of delimiters does not guarantee that the horizontal blur will be performed before the beginning of the vertical blur (if the first one was a horizontal blur).  As a result, with several launches, different results were obtained.  Limiters can be used to synchronize streams in a group.  The cause of the problem is that edge pixels are being read from several workgroups, and there is no way to synchronize between several workgroups.  The initial assumption about the possibility of implementing a single Gaussian blur using reading and writing images turned out to be incorrect, since in OpenCL it is impossible to synchronize data dependencies between working groups. </div><p>Source: <a href="https://habr.com/ru/post/268851/">https://habr.com/ru/post/268851/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268833/index.html">Restoring the window size upon restart, a lot of fixes in Vivaldi 1.0.298.15. Plus movie</a></li>
<li><a href="../268837/index.html">Visual Studio Code - the evolution of the cross-platform code editor on the example of the version for OS X</a></li>
<li><a href="../268841/index.html">The mystery of the finalizers in Go</a></li>
<li><a href="../268845/index.html">Why do I need a free code and how to earn on it</a></li>
<li><a href="../268849/index.html">Rust hit the TIOBE index</a></li>
<li><a href="../268853/index.html">Office as Platform Release 7 - Manage Office 365 and SharePoint Online via PowerShell</a></li>
<li><a href="../268855/index.html">Introducing 3CX Phone System v14 SP1 with many new features.</a></li>
<li><a href="../268857/index.html">How I monitored Avito by SMS</a></li>
<li><a href="../268859/index.html">The nuances of ESXi, FlexFabric, 10 Gbit and NFS bundles</a></li>
<li><a href="../268863/index.html">Google Cloud Endpoints in Java: A Guide. part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>