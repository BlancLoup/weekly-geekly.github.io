<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to RxJava: Creating a Sequence</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now that we understand the basic principles of Rx, it is time to learn how to create and manage sequences. The sequence management style was borrowed ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to RxJava: Creating a Sequence</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d29/234/42c/d2923442c6d54c8e9e6b517d73ff978f.png" alt="image"><br><p>  Now that we understand the basic principles of Rx, it is time to learn how to create and manage sequences.  The sequence management style was borrowed from the original C # <a href="https://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a> , which in turn was inspired by functional programming.  We will divide all operations by topics, which are sorted in order of increasing complexity of operations.  Most of the Rx operators control existing sequences, but first we learn how to create them. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><h5>  Content: </h5><br><ul><li>  Part One - Introduction <br><ol><li>  <a href="http://habrahabr.ru/post/269417/">Why Rx?</a> </li><li>  <a href="http://habrahabr.ru/post/270023/">Key types</a> </li><li>  <a href="http://habrahabr.ru/post/270975/">Subscription life cycle</a> </li></ol></li><li>  Part Two - Sequences <br><ol><li>  <b>Creating a sequence</b> </li><li>  Sequence filtering </li><li>  Study </li><li>  Aggregation </li><li>  Transformation </li></ol></li><li>  Part Three - Sequence Management </li><li>  Part Four - Parallelism </li></ul></div></div><br><h1 id="chast-2---osnovy-posledovatelnostey">  Part 2 - Sequence Basics </h1><br><h1 id="sozdanie-posledovatelnosti">  Creating a sequence </h1><br><p> <a href="http://habrahabr.ru/post/270975/">Previously</a> , we used <code>Subject</code> and manually applied values ‚Äã‚Äãto them to create a sequence.  We did this to demonstrate some key points, including the main Rx method <code>subscribe</code> .  In most cases, the <code>Subject</code> is not the best way to create a new <code>Observable</code> .  In this section, we will look at more elegant ways to do this. </p><br><h2 id="prostye-fabrichnye-metody">  Simple factory methods </h2><br><h3 id="observablejust">  Observable.just </h3><br><p>  <code>just</code> creates an <code>Observable</code> , which will produce a predetermined number of values, and then it will end. </p><br><pre> <code class="java hljs">Observable&lt;String&gt; values = Observable.just(<span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-string"><span class="hljs-string">"three"</span></span>); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">Received: one Received: two Received: three Completed</code> </pre> <br><h3 id="observableempty">  Observable.empty </h3><br><p>  This <code>Observable</code> will only <code>onCompleted</code> an <code>onCompleted</code> event and nothing else. </p><br><pre> <code class="java hljs">Observable&lt;String&gt; values = Observable.empty(); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">Completed</code> </pre> <br><h3 id="observablenever">  Observable.never </h3><br><p>  This <code>Observable</code> will never issue anything. </p><br><pre> <code class="java hljs">Observable&lt;String&gt; values = Observable.never(); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  The code <a href="">above</a> will not print anything.  But this does not mean that the program is blocked.  In fact, it just ends instantly. </p><br><h3 id="observableerror">  Observable.error </h3><br><p>  This <code>Observable</code> will throw an onError event and terminate. </p><br><pre> <code class="java hljs">Observable&lt;String&gt; values = Observable.error(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">"Oops"</span></span>)); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Error</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Exception</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">Oops</span></span></code> </pre> <br><h3 id="observabledefer">  Observable.defer </h3><br><p>  <code>defer</code> does not create a new <code>Observable</code> , but allows you to determine how the <code>Observable</code> will be created when subscribers appear.  Think about how you would create an <code>Observable</code> that will issue the current time?  Since there is only one meaning, it seems that <code>just</code> can help us here. </p><br><pre> <code class="java hljs">Observable&lt;Long&gt; now = Observable.just(System.currentTimeMillis()); now.subscribe(System.out::println); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); now.subscribe(System.out::println);</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">1431443908375 1431443908375</code> </pre> <br><p>  Notice how the second subscriber, subscribing a second later, got the same time.  This is because the time value was calculated only once: when the execution reaches the <code>just</code> method.  However, in our case, we want to calculate the current time for each subscription.  <code>defer</code> accepts a function that returns <code>Observable</code> and will be executed for each new subscriber. </p><br><pre> <code class="java hljs">Observable&lt;Long&gt; now = Observable.defer(() -&gt; Observable.just(System.currentTimeMillis())); now.subscribe(System.out::println); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); now.subscribe(System.out::println);</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">1431444107854 1431444108858</code> </pre> <br><h3 id="observablecreate">  Observable.create </h3><br><p>  <code>create</code> is a very powerful method of creating <code>Observable</code> . </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Observable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observable.OnSubscribe&lt;T&gt; f)</span></span></span></span></code> </pre> <br><p>  Everything is much simpler than it looks.  Inside there is only a function that accepts <code>Subscriber</code> for type <code>T</code>  Inside it, we can manually determine the events that will be issued to the subscriber. </p><br><pre> <code class="java hljs">Observable&lt;String&gt; values = Observable.create(o -&gt; { o.onNext(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>); o.onCompleted(); }); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">Received: Hello Completed</code> </pre> <br><p>  When someone signs up to our <code>Observable</code> ( <code>values</code> in this case), the corresponding <code>Subscriber</code> instance will be passed to the <code>create</code> function.  As the code runs, the values ‚Äã‚Äãwill be transferred to the subscriber.  Note that you need to call the <code>onCompleted</code> method yourself to signal the end of the sequence. </p><br><p>  This method is the recommended way to create an <code>Observable</code> in case none of the other methods are appropriate.  This is similar to how we created the <code>Subject</code> and manually applied values ‚Äã‚Äãto it, however there are several important differences.  First of all, the event source is neatly encapsulated and separated from other code.  Secondly, the <code>Subject</code> have unobvious hazards: anyone who has access to the object can change the sequence.  We will return to this problem later. </p><br><p>  Another key difference with using <code>Subject</code> is that the code is executed "lazily", only when a new subscriber arrives.  In the example above, the code is executed <em>not</em> at the time of creation of <code>Observable</code> (since there are no subscribers yet), but at the time of calling the <code>subscribe</code> method.  This means that the values ‚Äã‚Äãwill be recalculated for each subscriber, as in the <code>ReplaySubject</code> .  The end result is similar to <code>ReplaySubject</code> , with the exception of caching.  With the help of <code>create</code> we can also easily transfer execution to a separate stream, while with the <code>ReplaySubject</code> we would have to manually create threads to calculate values.  We will also look at ways to make the execution of the <code>onSubscribe</code> method parallel. </p><br><p>  You may have noticed that any of the previous <code>Observable</code> can be implemented using <code>Observable.create</code> .  Our <code>create</code> example is equivalent to <code>Observable.just("hello")</code> . </p><br><h2 id="funkcionalnye-metody">  Functional methods </h2><br><p>  In functional programming, the creation of infinite sequences is commonplace. </p><br><h3 id="observablerange">  Observable.range </h3><br><p>  Simple and familiar to functional programmers method.  Gives values ‚Äã‚Äãfrom the specified range. </p><br><pre> <code class="java hljs">Observable&lt;Integer&gt; values = Observable.range(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>);</code> </pre> <br><p>  This <a href="">example</a> consistently yields values ‚Äã‚Äãfrom 10 to 24. </p><br><h3 id="observableinterval">  Observable.interval </h3><br><p>  This function will create an <em>infinite</em> sequence of values ‚Äã‚Äãseparated by a specified time interval. </p><br><pre> <code class="java hljs">Observable&lt;Long&gt; values = Observable.interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>, TimeUnit.MILLISECONDS); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) ); System.in.read();</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs erlang">Received: <span class="hljs-number"><span class="hljs-number">0</span></span> Received: <span class="hljs-number"><span class="hljs-number">1</span></span> Received: <span class="hljs-number"><span class="hljs-number">2</span></span> Received: <span class="hljs-number"><span class="hljs-number">3</span></span> ...</code> </pre> <br><p>  The sequence is not completed until we unsubscribe. </p><br><p>  Attention should be paid to why blocking input at the end of the example is required.  Without it, the program will end without printing.  This is because all our operations are non-blocking: we create periodically issuing <code>Observable</code> values, then register a subscriber who performs some actions at the time of arrival of these values.  None of this blocks the main thread from terminating. </p><br><h3 id="observabletimer">  Observable.timer </h3><br><p>  There are two overloads of <code>Observable.timer</code> .  The first option creates <code>Observable</code> issuing <code>0L</code> after a specified period of time. </p><br><pre> <code class="java hljs">Observable&lt;Long&gt; values = Observable.timer(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">Received: 0 Completed</code> </pre> <br><p>  The second option waits for a specified period of time, then begins to produce values ‚Äã‚Äãas well as <code>interval</code> with a specified frequency. </p><br><pre> <code class="java hljs">Observable&lt;Long&gt; values = Observable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs erlang">Received: <span class="hljs-number"><span class="hljs-number">0</span></span> Received: <span class="hljs-number"><span class="hljs-number">1</span></span> Received: <span class="hljs-number"><span class="hljs-number">2</span></span> ...</code> </pre> <br><p>  The example above waits 2 seconds, then starts counting every second. </p><br><h2 id="prevraschenie-v-observable">  Turning into an Observable </h2><br><p>  In java, there are tools for working with sequences, collections, and asynchronous events that may not be directly compatible with Rx.  Now we will look at how you can turn them into the input data of your Rx code. </p><br><p>  If you use EventHandlers, then using <code>Observable.create</code> you can create a sequence from events. </p><br><pre> <code class="java hljs">Observable&lt;ActionEvent&gt; events = Observable.create(o -&gt; { button2.setOnAction(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler&lt;ActionEvent&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActionEvent e)</span></span></span><span class="hljs-function"> </span></span>{ o.onNext(e) } }); })</code> </pre> <br><p>  Depending on the specific event, its type (in this case, <code>ActionEvent</code> ) itself can carry enough information to become the type of your <code>Observable</code> .  However, very often you may need something else, for example, the value of a certain field at the time of the event.  It is best to get the value of such a field inside the handler while the UI stream is blocked and the field values ‚Äã‚Äãare relevant.  And although there are no guarantees that the value will remain unchanged until reaching the final subscriber, in a correctly implemented Rx code, changes are controlled on the consumer side [1]. </p><br><h2 id="observablefrom">  Observable.from </h2><br><p>  You can turn any input into <code>Observable</code> using <code>create</code> .  However, for common data types, ready-made methods exist to make this process easier. </p><br><p>  <code>Future</code> 's are part of Java and you must have come across them while working with frameworks that use multi-threading.  They are a less powerful multi-threaded tool than Rx, since they return only one value.  Typically, you will want to turn them into <code>Observable</code> . </p><br><pre> <code class="java hljs">FutureTask&lt;Integer&gt; f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FutureTask&lt;Integer&gt;(() -&gt; { Thread.sleep(<span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">21</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(f).start(); Observable&lt;Integer&gt; values = Observable.from(f); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">Received: 21 Completed</code> </pre> <br><p>  <code>Observable</code> <code>FutureTask</code> result of <code>FutureTask</code> in readiness, and then terminates.  If the task has been canceled, observable will generate a <code>java.util.concurrent.CancellationException</code> error. </p><br><p>  If you are interested in the result of the <code>Future</code> for a limited time only, it is possible to set a timeout as an argument. </p><br><pre> <code class="java hljs">Observable&lt;Integer&gt; values = Observable.from(f, <span class="hljs-number"><span class="hljs-number">1000</span></span>, TimeUnit.MILLISECONDS);</code> </pre> <br><p>  If during this time <code>Future</code> does not end, observable ignores the result and <code>TimeoutException</code> . </p><br><p>  With <code>Observable.from</code> you can turn any collection into a sequence.  An <code>Observable</code> will be created, issuing each element of the collection separately and <code>onCompleted</code> at the end. </p><br><pre> <code class="java hljs">Integer[] is = {<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>}; Observable&lt;Integer&gt; values = Observable.from(is); Subscription subscription = values.subscribe( v -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Received: "</span></span> + v), e -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Error: "</span></span> + e), () -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Completed"</span></span>) );</code> </pre> <br><p>  <a href="">Conclusion</a> </p><br><pre> <code class="hljs">Received: 1 Received: 2 Received: 3 Completed</code> </pre> <br><p>  <code>Observable</code> is not the same as <code>Iterable</code> or <code>Stream</code> .  <code>Observable</code> push-oriented, in the sense that the <code>onNext</code> call <code>onNext</code> stack of handlers to execute right up to the last <code>subscribe</code> method.  The remaining models are pull-oriented ‚Äî values ‚Äã‚Äãare requested from the other side and execution is blocked until the result is returned. </p><br><p>  [1] <em>consumer</em> , who absorbs values ‚Äã‚Äãissued by <code>Observable</code> </p><br><p>  <em>Now the project has its own public <a href="https://github.com/bolein/Intro-To-RxJava">repository</a> and anyone can join the creation of an in-depth Russian-language tutorial on Rx.</em>  <em>The translation of <a href="">this part is</a> already there, the rest will appear soon, and with your help, even faster.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/281633/">https://habr.com/ru/post/281633/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281619/index.html">Internet of things (IoT) - challenges of new reality</a></li>
<li><a href="../281621/index.html">Storydesk - my non-existent wonder designer</a></li>
<li><a href="../281627/index.html">Welcome to the RISSPA seminar on April 20</a></li>
<li><a href="../281629/index.html">Is it necessary to get rid of the branches? - For example, sign, abs, min and max</a></li>
<li><a href="../281631/index.html">I thought I knew everything about cisco ...</a></li>
<li><a href="../281635/index.html">JSCS, CST and New Start</a></li>
<li><a href="../281637/index.html">Code who live: Livecoding.tv launched an online hackathon to create your application</a></li>
<li><a href="../281639/index.html">Develop HTML5 games in Intel XDK. Part 5. Increase the length of the snake and manage it</a></li>
<li><a href="../281641/index.html">I do not know how to do that! Honestly</a></li>
<li><a href="../281643/index.html">Patterns and antipatterns Cucumber BDD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>