<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We pump React hooks using FRP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having mastered the hooks, many React-developers have experienced euphoria, finally getting a simple and convenient toolkit that allows them to implem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We pump React hooks using FRP</h1><div class="post__text post__text-html js-mediator-article"><p>  Having mastered the hooks, many React-developers have experienced euphoria, finally getting a simple and convenient toolkit that allows them to implement tasks with significantly less code.  But does this mean that the standard useState and useReducer hooks offered out of the box are all we need to manage the state? </p><br><p>  In my opinion, in raw form, their use is not very convenient, they can rather be regarded as the basis for the construction of really convenient state control hooks.  React developers themselves strongly encourage the development of custom hooks, so why not do it?  Under the cut, we will consider a very simple and clear example of what is wrong with ordinary hooks and how they can be improved, so much so that we can completely abandon their use in their pure form. </p><a name="habracut"></a><br><p>  There is a certain field for input, conditionally, a name.  And there is a button, by clicking on which we must make a request to the server with the entered name (some kind of search).  It would seem, what could be easier?  However, the solution is far from obvious.  First naive implementation: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(name)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre> <br><p>  What is wrong here?  If the user, having entered something in the field, sends the form twice, only the first request will work for us, since  the second click will not change the request and useEffect will not work.  If we imagine that our application is a ticket search service, and the user may very well send the form over and over again without any changes, then such an implementation will not work for us!  Using name as a dependency for useEffect is also unacceptable, otherwise the form will be sent immediately when the text changes.  Well, you have to be creative. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, setRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; setRequest(!request)}/&gt; { result &amp;&amp; &lt;div&gt;Result: { result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  Now, with each click, we will change the request values ‚Äã‚Äãto the opposite, and we will achieve the desired behavior.  This is a very small and innocent crutch, but it makes the code somewhat confusing to understand.  Perhaps, now it seems to you that I suck the problem out of my finger and inflate its scales.  Well, to answer this or not, you need to compare this code with other implementations that offer a more expressive approach. </p><br><p>  Let's look at this example on a theoretical level, using the abstraction of threads.  It is very convenient for describing the state of user interfaces.  So, we have two streams: the data entered in the text field (name $), and the flow of clicks on the form submit button (click $).  Of these, we need to create a third, combined stream of requests to the server. </p><br><pre> <code class="plaintext hljs">name$ __(C)____(Ca)_____(Car)____________________(Carl)___________ click$ ___________________________()______()________________()_____ request$ ___________________________(Car)___(Car)_____________(Carl)_</code> </pre> <br><p>  Here is the behavior we need to achieve.  Each flow has two aspects: the value it has, and the point in time at which values ‚Äã‚Äãflow through it.  In various situations, we may need one or another aspect, or both.  You can compare it with the rhythm and harmony in the music.  Streams for which only the time of their triggering is significant is also called signals. </p><br><p>  In our case, click $ is a pure signal: it doesn‚Äôt matter what values ‚Äã‚Äãflow through it (undefined / true / Event / whatever), it only matters when it happens.  Case name $ <br>  the opposite: its changes do not entail any changes in the system, but we may need its value at some point.  And from these two streams we need to make the third, taking from the first - time, from the second - meaning. </p><br><p>  In the case of Rxjs, we have an almost ready operator for this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> click$ = fromEvent(...); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request$ = click$.pipe(withLatestFrom(name$), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[name]</span></span></span><span class="hljs-function">) =&gt;</span></span> fromPromise(fetch(...))));</code> </pre> <br><p>  However, the practical use of Rx in React can be quite inconvenient.  A more suitable option is the <a href="https://www.npmjs.com/package/mrr">mrr</a> library, built on the same functionally reactive principles as Rx, but specially adapted for use with the Reactor according to the principle of "total reactivity" and connected in the form of a hook. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> useMrr <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'mrr/hooks'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">result</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.result), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input value={state.name} onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('submit')}/&gt; { state.result &amp;&amp; &lt;div&gt;Result: { state.result }&lt;/div&gt; } &lt;/div&gt;; }</code> </pre><br><p>  The useMrr interface is similar to useState or useReducer: returns a state object (the values ‚Äã‚Äãof all streams) and a setter for putting values ‚Äã‚Äãinto streams.  But inside everything is a little different: each state field (= stream), except for those in which we put values ‚Äã‚Äãdirectly from DOM events, is described by a function and a list of parent streams, changing which will cause the child to recalculate.  In this case, the values ‚Äã‚Äãof the parent streams will be substituted into the function.  If we just want to get the value of the stream, but not react to its change, then we write a minus before the name, as in the case of name. </p><br><p>  We got the right behavior, in essence, in one line.  But it‚Äôs not just the brevity.  Let's compare the obtained results in more detail, and first of all in such a parameter as readability and clarity of the resulting code. </p><br><p>  In mrr, you will have almost complete separation of the "logic" from the "template": you will not have to write any complex imperative handlers in JSX.  Everything is ultimately declarative: we just map the DOM event to the corresponding stream, practical without conversions (for input fields, the e.target.value value is automatically retrieved, unless you specify otherwise), and already in the useMrr structure we describe how child  Thus, in the case of both synchronous and asynchronous data transformations, we can always easily see how our value is formed. </p><br><p>  Comparing with : we didn‚Äôt even have to use additional operators: if as a result, the function mrr gets promise, it will automatically wait for its resolver and put the received data into the stream.  Also, instead of the withLatestFrom operator, we used <br>  passive listening (minus sign), which is more convenient.  Imagine that in addition to the name, we will need to send other fields.  Then in mrr we will add another passively listened stream: </p><br><pre> <code class="javascript hljs">result: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, surname</span></span></span><span class="hljs-function">) =&gt;</span></span> fetch(...), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'-surname'</span></span>, <span class="hljs-string"><span class="hljs-string">'submit'</span></span>],</code> </pre> <br><p>  And in Rx you will have to sculpt another one withLatestFrom with a map, or you can pre-merge name and surname into one stream. </p><br><p>  But back to the hooks and mrr.  A more readable dependency record, which always shows how data is generated, is perhaps one of the main advantages.  The current useEffect interface fundamentally does not allow to respond to the flow of signals, which is why <br>  you have to invent different quirks. </p><br><p>  Another point is that the variant of ordinary hooks carries extra renders.  If the user simply clicked on the button, this does not entail any further changes in the UI that the reactor needs to draw.  However, the render will be triggered.  In the version with mrr, the returned state will only be updated when the server has already received a response.  Saving on matches, you say?  Well, maybe.  But for me personally, the principle of ‚Äúin any incomprehensible situation, re-render‚Äù, underlying the basic hooks, causes rejection. </p><br><p>  Superfluous renders also mean a new formation of event handlers.  By the way, even ordinary hooks are bad here.  Not only are handlers imperative, they also have to be regenerated at every render.  And it will not be possible to fully use caching here, since  Many handlers must be closed on the internal variables of the component.  The mrr handlers are more declarative, and caching is already built in to mrr: set ('name') will be generated only once, and will be substituted from the cache on subsequent renders. </p><br><p>  With an increase in the code base, imperative handlers can become even more cumbersome.  Suppose that we also need to show the number of form submissions made by the user. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [request, makeRequest] = useState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [name, setName] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [result, setResult] = useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [clicks, setClicks] = useState(<span class="hljs-number"><span class="hljs-number">0</span></span>); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { setResult(data.result); }); }, [request]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={e =&gt; setName(e.target.value)}/&gt; &lt;input type="submit" value="Check" onClick={() =&gt; { makeRequest(!request); setClicks(clicks + 1); }}/&gt;&lt;br /&gt; Clicked: { clicks } &lt;/div&gt;; }</code> </pre><br><p>  Not very nice looking.  You can of course render the handler a separate function inside the component.  The readability will increase, but the problem of regenerating the function with each render will remain, as will the problem of imperativeness.  In essence, this is a common procedural code, despite the widespread belief that the React API is gradually changing towards a functional approach. </p><br><p>  To those who find the scale of the problem exaggerated, I can answer that, for example, the developers of React themselves are aware of the problem of unnecessary generation of handlers, immediately offering us a crutch in the form of useCallback. </p><br><p>  On mrr: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;input onChange={set('name')}/&gt; &lt;input type="submit" value="Check" onClick={set('makeRequest')}/&gt; &lt;/div&gt;; }</code> </pre><br><p>  A more convenient alternative is useReducer, allowing you to abandon the imperativeness of handlers.  But other important problems remain: the lack of work with signals (since side effects will be responsible for the same useEffect), as well as worse readability for asynchronous transformations (in other words, it is more difficult to trace the relationship between the fields of the story, because ).  If in the mrr dependency graph between the state fields (streams) is immediately clearly visible, in the hooks you will have to run a little up and down with your eyes. </p><br><p>  Also, sharing in the same component useState and useReducer is not very convenient (again, there will be complex imperative handlers that will change something in useState <br>  and dispute action), which is why most likely before developing a component you will have to accept this or that option. </p><br><p>  Of course, consideration of all aspects can still go on and on.  In order not to go beyond the scope of the article, I will touch on some less important points. </p><br><p>  Centralized logging debug.  Since in mrr all streams are contained in one hub, for debug it is enough to add one flag: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> App = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [state, set] = useMrr(props, { <span class="hljs-attr"><span class="hljs-attr">$log</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">$init</span></span>: { <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function"> =&gt;</span></span> fetch(<span class="hljs-string"><span class="hljs-string">'//example.api/'</span></span> + name).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> data.isValid), <span class="hljs-string"><span class="hljs-string">'-name'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], <span class="hljs-attr"><span class="hljs-attr">clicks</span></span>: [<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function"> =&gt;</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'-clicks'</span></span>, <span class="hljs-string"><span class="hljs-string">'makeRequest'</span></span>], }); ...</code> </pre> <br><p>  After that, all changes to the threads will be displayed in the console.  To access the entire state (that is, the current values ‚Äã‚Äãof all threads) there is a $ state pseudo-thread: </p><br><pre> <code class="javascript hljs">a: [<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ name, click, result }</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... }, <span class="hljs-string"><span class="hljs-string">'$state'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>],</code> </pre> <br><p>  Thus, if needed or if you are very used to the redox style, you can write in the redac style on mrr, returning the new field value based on the event and the whole previous state.  But the opposite (writing on the useReducer or editorial in the style of mrr) will not work, due to the lack of reactivity in these. </p><br><p>  Work with time.  Remember the two aspects of flows: value and response time, harmony and rhythm?  So, working with the first in ordinary hooks is quite simple and convenient, but with the second one - no.  By working with time, I mean the formation of child flows, the "rhythm" of which differs from the parent.  First of all, these are various kinds of filters, debuffs, trotles, etc.  You will most likely have to implement all this yourself.  In mrr, you can use ready-made operators out of the box.  The gentlemanly set mrr is inferior to the variety of operators Rx, but it has more intuitive naming. </p><br><p>  Intercomponent interaction.  I remember in the Redax it was considered good practice to create only one story.  If we use useReducer in many components, <br>  possible problem with the organization of interaction stor.  On mrr, streams can freely ‚Äúflow‚Äù from one component to another both up and down the hierarchy, but this will not create problems due to the declarative approach.  In details <br>  this topic, as well as other features of the mrr API, are described in the article <a href="https://habr.com/ru/post/438112/">Actors + FRP in React</a> </p><br><h3 id="vyvody">  findings </h3><br><p>  The new Reactor hooks are beautiful and simplify our lives, but they have some drawbacks that a higher-level general purpose hook (state management) can eliminate.  As such, useMrr from the mrr functionally reactive library was proposed and reviewed. </p><br><p>  Problems and solutions: </p><br><ul><li>  unnecessary data recalculations for each render (in mrr are absent due to push-based reactivity) </li><li>  extra renders when changing state doesn‚Äôt entail changing UI </li><li>  bad readability of the code with asynchronous conversions (compared to synchronous).  In mrr, asynchronous code is not inferior to synchronous in readability and expressiveness.  Most of the problems discussed in a <a href="https://habr.com/ru/company/ruvds/blog/445276/">recent article on useEffect</a> on mrr are basically impossible. </li><li>  imperative handlers that are not always cachable (they are automatically cached in mrr, can almost always be cached, declarative) </li><li>  using useState and useReducer at the same time can create awkward code </li><li>  lack of tools to convert threads in time (debounce, throttle, race condition) </li></ul><br><p>  On many points one can argue that they can be solved with custom hooks.  But after all, this is exactly what is proposed, but instead of separate implementations for each individual task, a holistic, consistent solution is proposed. </p><br><p>  Many problems have become too familiar to us to be clearly understood.  For example, asynchronous conversions have always looked more complicated and confusing than synchronous ones, and hooks in this sense are no worse than earlier approaches (redaks, etc.).  To understand this as a problem, you must first see other approaches that offer a more perfect solution. </p><br><p>  This article is intended not to impose any specific views, but rather to draw attention to the problem.  I am sure that other solutions exist or are being created that can be a worthy alternative, but have not yet become widely known.  The future React Cache API can also make a significant difference.  I will be glad to criticism and discussion in the comments. </p><br><p>  <a href="https://twitter.com/kyivjs">Those</a> interested can also watch a performance on this topic on <a href="https://twitter.com/kyivjs">March</a> 28, <a href="https://twitter.com/kyivjs">kyivjs</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/445214/">https://habr.com/ru/post/445214/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445204/index.html">Stream Firebird 2.5 bases conversion to ODS12 format (Firebird 3.0)</a></li>
<li><a href="../445206/index.html">Reduce downtime when updating Zimbra</a></li>
<li><a href="../445208/index.html">Maturity Levels of Enterprise IT Infrastructure</a></li>
<li><a href="../445210/index.html">Cryptocurrency colony</a></li>
<li><a href="../445212/index.html">NetBIOS in the hands of a hacker</a></li>
<li><a href="../445220/index.html">AMD Radeon VII: High-End Dash (Part 3)</a></li>
<li><a href="../445222/index.html">Get an offer in 1 day in the backend team on Cosmonautics Day</a></li>
<li><a href="../445226/index.html">Development of a rocket capable of reaching the moon will cost the Russian Federation 740 billion rubles</a></li>
<li><a href="../445228/index.html">Cryptography in Java. Mac class</a></li>
<li><a href="../445230/index.html">Registration for the II IT conference for novice developers SMARTRHINO-2019 has begun</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>