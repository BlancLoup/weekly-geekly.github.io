<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LLVM: do-it-yourself compiler. Introduction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine that one day you came up with the idea of ‚Äã‚Äãa processor of your own, unlike anything architecture, and you really wanted to implement this ide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LLVM: do-it-yourself compiler. Introduction</h1><div class="post__text post__text-html js-mediator-article">  Imagine that one day you came up with the idea of ‚Äã‚Äãa processor of your own, unlike anything architecture, and you really wanted to implement this idea ‚Äúin hardware‚Äù.  Fortunately, there is nothing impossible in this.  A little verilogue, and here's your idea.  You already have beautiful dreams about how Intel went bankrupt, Microsoft hastily rewrites Windows for your architecture, and the Linux community has already written a fresh version of the system for your microprocessor with very boring wallpapers. <br>  However, for all this, one little thing is missing: a compiler! <br>  Yes, I know that many do not consider the presence of a compiler to be something important, considering that everyone should program strictly in assembler.  If you think so too, I will not argue with you, just do not read further. <br>  If you want at least C language to be available for your original architecture, I ask for cat. <br>  The article will discuss the use of the LLVM compiler infrastructure to build its own solutions based on it. <br>  The scope of LLVM is not limited to the development of compilers for new processors, the LLVM compilers infrastructure can also be used to develop compilers for new programming languages, new optimization algorithms and specific static code analysis tools (search for errors, statistics collection, etc.). <br>  For example, you can use some kind of standard processor (for example, ARM) in combination with a specialized coprocessor (for example, a matrix FPU), in which case you may need to modify the existing compiler for ARM so that it can generate code for your FPU. <br>  Also interesting is the use of LLVM to generate high-level source texts (‚Äútranslation‚Äù from one language to another).  For example, you can write a code generator on Verilog using the source code in C. <br><br><img src="https://habrastorage.org/files/84e/79a/c13/84e79ac13efb48f19f490840a2339c27.jpeg"><br><br>  KDPV 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h2>  Why LLVM? </h2><br>  Today there are only two realistic ways to develop a compiler for your own architecture: using GCC or using LLVM.  Other open source compiler projects either did not reach the same level of development as GCC and LLVM, or were outdated and stopped developing, they do not have advanced optimization algorithms, and may not provide full compatibility even with the C standard, not to mention the support of others. programming languages.  Developing your own compiler from scratch is a very irrational way, because existing open source solutions already implement the compiler's frontend with a lot of highly non-trivial optimization algorithms, which, moreover, have been well tested and have been used for a long time. <br>  Which of these two open-source projects to choose as the basis for your compiler?  GCC (GNU Compiler Collection) is an older project, the first release of which took place in 1987; its author is Richard Stallman, a well-known figure in the open-source movement [4].  It supports many programming languages: C, C ++, Objective C, Fortran, Java, Ada, Go.  There are also frontends for many other programming languages ‚Äã‚Äãthat are not included in the main assembly.  The GCC compiler supports a large number of processor architectures and operating systems, and is currently the most common compiler.  GCC itself is written in C (in the comments I was corrected that it was already mostly rewritten in C ++). <br>  LLVM is much "younger", its first release took place in 2003, it (or rather, its Clang frontend) supports the programming languages ‚Äã‚ÄãC, C ++, Objective-C and Objective-C ++, and also has front-ends for Common Lisp, ActionScript, Ada , D, Fortran, OpenGL Shading Language, Go, Haskell, Java bytecode, Julia, Swift, Python, Ruby, Rust, Scala, C # and Lua.  It was developed at the University of Illinois, in the USA, and is the main compiler for developing for OS X. LLVM is written in C ++ (C ++ 11 for the latest releases) [5]. <br><img src="https://habrastorage.org/files/d34/774/864/d34774864f9c418cad6d9763e51eea02.png"><br>  The relative "youth" of LLVM is not a disadvantage, it is mature enough that it does not have critical bugs, nor does it carry a huge load of outdated architectural solutions, like GCC.  The modular structure of the compiler allows the use of the LLVM-GCC front-end, which provides full support for the GCC standards, while the target platform code will be generated by LLC (LLVM backend).  You can also use Clang - the original frontend LLVM. <br>  LLVM is well documented, and for it a large number of code examples. <br><br><h2>  Compiler Modular Architecture </h2><br>  The infrastructure of the LLVM compilers consists of various tools; it does not make sense to consider them all within the framework of this article.  We confine ourselves to the basic tools that make up the compiler as such. <br>  The LLVM compiler, like some other compilers, consists of a frontend, an optimizer (midland), and a backend.  This structure allows us to separate the development of a compiler for a new programming language, the development of optimization methods and the development of a code generator for a specific processor (such compilers are called ‚Äúretargeted‚Äù, retargetable). <br>  The connecting link between them is the intermediate language LLVM, the assembler of the ‚Äúvirtual machine‚Äù.  The frontend (for example, Clang) converts the text of a program in a high-level language into text in an intermediate language, the optimizer (opt) performs various optimizations on it, and the backend (llc) generates the code of the target processor (in assembler or directly as a binary file).  In addition, LLVM can work in JIT (just-in-time) compilation mode when compilation occurs directly during program execution. <br>  The intermediate presentation of the program can be either in the form of a text file in the LLVM assembler language, or in the form of a binary format, a ‚Äúbitcode‚Äù.  By default, clang generates exactly the bitcode (.bc file), but to debug and learn LLVM, we will need to generate a text intermediate representation in the LLVM assembler (it is also called IR code, from the words Intermediate Representation, intermediate representation). <br><br><img src="https://habrastorage.org/files/aa5/252/fa4/aa5252fa400b454abf726aec001c7f86.png"><br>  Fig.  1. Modular compiler architecture <br><br>  In addition to the above programs, LLVM includes other utilities [6]. <br>  So, we write the simplest program in C. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre> <br>  And compile it: <br> <code>clang-3.5 -c add.c -O0 --target=xcore -emit-llvm -S -o add_o0.ll <br></code> <br>  Some explanations: <br>  -c add.c - input file; <br>  -O0 - optimization level 0, no optimization; <br>  --target = xcore - the core of the xcore processor does not have any complicated features when compiled into IR code, therefore it is an ideal object for research.  This core is 32-bit wide, and clang aligns all variables along the 32-bit word boundaries; <br>  -emit-llvm -S - an instruction to clang to generate the llvm file in text form (in LLVM assembler); <br>  -o add_o0.ll - output file <br>  Let's look at the result: <br> <code>; ModuleID = 'add.c' <br> target datalayout = "em:ep:32:32-i1:8:32-i8:8:32-i16:16:32-i64:32-f64:32-a:0:32-n32" <br> target triple = "xcore" <br> <br> ; Function Attrs: nounwind <br> define i32 @foo(i32 %x, i32 %y) #0 { <br> %1 = alloca i32, align 4 <br> %2 = alloca i32, align 4 <br> store i32 %x, i32* %1, align 4 <br> store i32 %y, i32* %2, align 4 <br> %3 = load i32* %1, align 4 <br> %4 = load i32* %2, align 4 <br> %5 = add nsw i32 %3, %4 <br> ret i32 %5 <br> } <br> <br> attributes #0 = { nounwind "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "unsafe-fp-math"="false" "use-soft-float"="false" } <br> <br> !llvm.ident = !{!0} <br> !xcore.typestrings = !{!1} <br> <br> !0 = metadata !{metadata !"Ubuntu clang version 3.5.0-4ubuntu2~trusty2 (tags/RELEASE_350/final) (based on LLVM 3.5.0)"} <br> !1 = metadata !{i32 (i32, i32)* @foo, metadata !"f{si}(si,si)"} <br></code> <br>  Looks pretty hard, right?  However, let's see what is written here.  So: <br>  target datalayout = "em: ep: 32: 32-i1: 8: 32-i8: 8: 32-i16: 16: 32: i-i64: 32-f64: 32-a: 0: 32-n32" <br>  description of the digit capacity of variables and the most basic features of the architecture.  e-little-endian architecture.  For big-endian, here would be the letter E. m: e - mangling, a naming convention.  We don't need it yet.  p: 32: 32 - pointers have 32 bits and are aligned on 32-bit word boundaries.  i1: 8: 32 - Boolean variables (i1) are expressed in 8-bit values ‚Äã‚Äãand are aligned on 32-bit word boundaries.  Further, similarly for integer variables i8 - i64 (from 8 to 64 bits, respectively), and f64 - for real double-precision variables.  a: 0: 32 ‚Äî aggregate variables (ie, arrays and structures) have an alignment of 32 bits, n32 ‚Äî the width of the numbers processed by the processor's ALU (native integer width). <br>  Next comes the name of the target (i.e. the target processor): target triple = "xcore".  Although the IR code is often referred to as ‚Äúmachine-independent,‚Äù in fact, we see it is not.  It reflects some features of the target architecture.  This is one of the reasons why we have to specify the target architecture not only for the backend, but also for the frontend. <br>  The following is the function code foo: <br> <code>define i32 @foo(i32 %x, i32 %y) #0 { <br> %1 = alloca i32, align 4 <br> %2 = alloca i32, align 4 <br> store i32 %x, i32* %1, align 4 <br> store i32 %y, i32* %2, align 4 <br> %3 = load i32* %1, align 4 <br> %4 = load i32* %2, align 4 <br> %5 = add nsw i32 %3, %4 <br> ret i32 %5 <br> } <br></code> <br>  The code is rather cumbersome, although the source function is very simple.  That's what he does. <br>  Immediately, we note that all variable names in LLVM have a prefix of either% (for local variables) or @ - for global ones.  In this example, all variables are local. <br>  % 1 = alloca i32, align 4 - allocates 4 bytes for the variable on the stack, pointer to this area is pointer% 1. <br>  store i32% x, i32 *% 1, align 4 - copies one of the function arguments (% x) to the selected area. <br>  % 3 = load i32 *% 1, align 4 - retrieves the value in the variable% 3.  Now local copy of% x is stored in% 3. <br>  Does the same for the% y argument. <br>  % 5 = add nsw i32% 3,% 4 - adds local copies of% x and% y, puts the result in% 5.  There is also the nsw attribute, but it is not important for us yet. <br>  Returns the value of% 5. <br>  From the above example, it is clear that with the zero level of optimization, clang generates code, literally following the source code, creates local copies of all arguments and does not make any attempts to remove redundant commands.  This may seem to be a bad compiler property, but in fact this is a very useful feature when debugging programs and when debugging the code of the compiler itself. <br>  Let's see what happens if you change the optimization level to O1: <br> <code>define i32 @foo(i32 %x, i32 %y) #0 { <br> %1 = add nsw i32 %y, %x <br> ret i32 %1 <br> } <br></code> <br>  We see that not a single extra team is left.  Now the program adds directly the function arguments and returns the result. <br>  There are higher levels of optimization, but in this particular case they will not give a better result, because  maximum optimization level has already been reached. <br>  The rest of the LLVM code (attributes, metadata) carries the service information, which is not interesting to us yet. <br><br><h2>  LLVM code structure </h2><br>  The structure of the LLVM code is very simple.  The program code consists of modules, the compiler processes one module at a time.  The module has global declarations (variables, constants, and declarations of function headers that are in other modules) and functions.  Functions have arguments and return types.  Functions consist of basic blocks.  The base unit is a sequence of LLVM assembler commands that has one entry point and one exit point.  The base unit does not contain any branches and cycles, it runs strictly sequentially from beginning to end and must end with a terminating command (return from a function or transfer to another block). <br>  And finally, the base unit consists of assembly commands.  The list of commands is given in the documentation on LLVM [7]. <br>  So again: the base unit has one entry point marked with a label, and must necessarily end with an unconditional branch command br or a return command ret.  There may be a conditional branch command in front of them, in which case it must be immediately before the terminating team.  The base unit has a list of predecessors - base units from which control can come to it, and successors - base units to which it can transfer control.  Based on this information, CFG - Control Flow Graph, a control flow graph, the most important structure representing the program in the compiler, is built. <br>  Consider a test case in C: <br>  Let the source code in C has a cycle: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   10   int for_loop(int x[]) { int sum = 0; for(int i = 0; i &lt; 10; ++i) { sum += x[i]; } return sum; }</span></span></code> </pre><br>  Its CFG is: <br><img src="https://habrastorage.org/files/90b/046/83e/90b04683e8134587a7e2e06fa01f4e1b.png"><br>  Another type of graph in LLVM is the DAG - directed acyclic graph, a directed acyclic graph, which is a basic block. <br>  It represents the assembler commands and the dependencies between them.  The figure below shows the DAG of the base unit, representing the body of the loop in the example above, at the optimization level -O1: <br><img src="https://habrastorage.org/files/452/ce5/910/452ce591082c4bd1a0a9f427a05d0680.png"><br><br><h2>  SSA form </h2><br>  The key feature of the IR code that distinguishes it from high-level languages ‚Äã‚Äãis that it is presented in the so-called SSA form (Static Single Assignment form).  This feature is very important for understanding when developing a compiler on the LLVM platform, so we will give it some attention.  In short, in the SSA form, each variable is assigned a value exactly once and only at one point in the program.  All algorithms for optimizing and converting the IR code work only with this form. <br>  However, how to convert an ordinary high-level language program into such a form?  Indeed, in ordinary programming languages, the value of a variable can be assigned several times in different places of the program, or, for example, in a cycle. <br>  To implement this behavior, the program uses one of two techniques.  The first technique is to use load / store pairs of commands, as in the above code.  The only assignment restriction applies only to LLVM named variables, and does not apply to memory cells referenced by pointers.  That is, you can write to the memory an unlimited number of times with the store command, and the formal SSA rule will be observed, since the pointer to this cell does not change.  This method is usually used at the optimization level -O0, and we will not dwell on it in detail.  The second technique uses the œÜ-function, another interesting concept of the IR-code. <br><br><h3>  Code in SSA-form: load / store </h3><br>  Let's use the test example from the previous section. <br>  Compile with optimization level -O0: <br> <code>define i32 @for_loop(i32* %x) #0 { <br> %1 = alloca i32*, align 4 <br> %sum = alloca i32, align 4 <br> %i = alloca i32, align 4 <br> store i32* %x, i32** %1, align 4 <br> store i32 0, i32* %sum, align 4 <br> store i32 0, i32* %i, align 4 <br> br label %2 <br> <br> ; :2 ; preds = %12, %0 <br> %3 = load i32* %i, align 4 <br> %4 = icmp slt i32 %3, 10 <br> br i1 %4, label %5, label %15 <br> <br> ; :5 ; preds = %2 <br> %6 = load i32* %i, align 4 <br> %7 = load i32** %1, align 4 <br> %8 = getelementptr inbounds i32* %7, i32 %6 <br> %9 = load i32* %8, align 4 <br> %10 = load i32* %sum, align 4 <br> %11 = add nsw i32 %10, %9 <br> store i32 %11, i32* %sum, align 4 <br> br label %12 <br> <br> ; :12 ; preds = %5 <br> %13 = load i32* %i, align 4 <br> %14 = add nsw i32 %13, 1 <br> store i32 %14, i32* %i, align 4 <br> br label %2 <br> <br> ; :15 ; preds = %2 <br> %16 = load i32* %sum, align 4 <br> ret i32 %16 <br> } <br></code> <br>  Here we see what was written above: the loop variable is just a memory location referenced by the% i pointer. <br><br><h3>  Code in SSA form: œÜ-function </h3><br>  Now let's try the O1 optimization level: <br> <code>define i32 @for_loop(i32* nocapture readonly %x) #0 { <br> br label %1 <br> <br> ; :1 ; preds = %1, %0 <br> %i.02 = phi i32 [ 0, %0 ], [ %5, %1 ] <br> %sum.01 = phi i32 [ 0, %0 ], [ %4, %1 ] <br> %2 = getelementptr inbounds i32* %x, i32 %i.02 <br> %3 = load i32* %2, align 4, !tbaa !2 <br> %4 = add nsw i32 %3, %sum.01 <br> %5 = add nsw i32 %i.02, 1 <br> %exitcond = icmp eq i32 %5, 10 <br> br i1 %exitcond, label %6, label %1 <br> <br> ; :6 ; preds = %1 <br> ret i32 %4 <br> } <br></code> <br>  Here we see that the loop variable is% i.02 (variable names in LLVM can contain dots), and this is not a pointer, but a regular 32-bit variable, and the assignment of a value occurs using the function phi i32 [0,% 0], [% 5,% 1].  This means that the function will take the value 0 if the transition occurred from the base unit% 0 (the first base unit in the function), and the value of the variable% 5 if the transition occurred from the base unit% 1 (that is, from the output point of the same basic block).  Thus, the IR code generator got rid of two variable assignments, strictly following the formal rules of SSA.  Further, it is seen that the assignment of the variable% sum.01 occurs in a similar way. <br>  So, the meaning of the œÜ-function is that its value depends on from which base unit the transition was made to it.  œÜ-functions can be only at the beginning of the base unit.  If there are several, they should follow continuously, starting with the first instruction of the base unit. <br><br><h2>  Moar optimization! </h2><br>  What will happen with the optimization level -O2? <br> <code>define i32 @for_loop(i32* nocapture readonly %x) #0 { <br> %1 = load i32* %x, align 4, !tbaa !2 <br> %2 = getelementptr inbounds i32* %x, i32 1 <br> %3 = load i32* %2, align 4, !tbaa !2 <br> %4 = add nsw i32 %3, %1 <br> %5 = getelementptr inbounds i32* %x, i32 2 <br> %6 = load i32* %5, align 4, !tbaa !2 <br> %7 = add nsw i32 %6, %4 <br> %8 = getelementptr inbounds i32* %x, i32 3 <br> %9 = load i32* %8, align 4, !tbaa !2 <br> %10 = add nsw i32 %9, %7 <br> %11 = getelementptr inbounds i32* %x, i32 4 <br> %12 = load i32* %11, align 4, !tbaa !2 <br> %13 = add nsw i32 %12, %10 <br> %14 = getelementptr inbounds i32* %x, i32 5 <br> %15 = load i32* %14, align 4, !tbaa !2 <br> %16 = add nsw i32 %15, %13 <br> %17 = getelementptr inbounds i32* %x, i32 6 <br> %18 = load i32* %17, align 4, !tbaa !2 <br> %19 = add nsw i32 %18, %16 <br> %20 = getelementptr inbounds i32* %x, i32 7 <br> %21 = load i32* %20, align 4, !tbaa !2 <br> %22 = add nsw i32 %21, %19 <br> %23 = getelementptr inbounds i32* %x, i32 8 <br> %24 = load i32* %23, align 4, !tbaa !2 <br> %25 = add nsw i32 %24, %22 <br> %26 = getelementptr inbounds i32* %x, i32 9 <br> %27 = load i32* %26, align 4, !tbaa !2 <br> %28 = add nsw i32 %27, %25 <br> ret i32 %28 <br> } <br></code> <br>  The optimizer has expanded the loop.  In general, the IR code optimizer in LLVM is very intelligent, it can not only expand cycles, but also simplify non-trivial constructions, calculate constant values, even if they are not present in the code explicitly, and do other complex code conversions. <br><br><h2>  IR layout </h2><br>  Real programs consist of more than one module.  The traditional compiler compiles the modules separately, turning them into object files, and then transfers them to the linker (linker), which combines them into one executable file.  LLVM also allows you to do this. <br>  But LLVM also has the ability to link IR code.  The easiest way to consider this is an example.  Suppose there are two source modules: foo.c and bar.c: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//bar.h #ifndef BAR_H #define BAR_H int bar(int x, int k); #endif //bar.c int bar(int x, int k) { return x * x * k; } //foo.c #include "bar.h" int foo(int x, int y) { return bar(x, 2) + bar(y, 3); }</span></span></code> </pre><br>  If the program is compiled in the ‚Äútraditional‚Äù way, the optimizer cannot do almost anything with it: when compiling foo.c, the compiler does not know what is inside the bar function and can do the only obvious way to insert bar () calls. <br>  But if we compose the IR code, we will get one module, which after optimization with the -O2 level will look like this (for clarity, the module header and metadata are omitted): <br> <code>define i32 @foo(i32 %x, i32 %y) #0 { <br> %1 = shl i32 %x, 1 <br> %2 = mul i32 %1, %x <br> %3 = mul i32 %y, 3 <br> %4 = mul i32 %3, %y <br> %5 = add nsw i32 %4, %2 <br> ret i32 %5 <br> } <br> <br> ; Function Attrs: nounwind readnone <br> define i32 @bar(i32 %x, i32 %k) #0 { <br> %1 = mul nsw i32 %x, %x <br> %2 = mul nsw i32 %1, %k <br> ret i32 %2 <br> } <br></code> <br>  Here it can be seen that no calls occur in the foo function, the compiler transferred the contents of bar () to it completely, in the process substituting constant values ‚Äã‚Äãof k.  Although the bar () function remains in the module, it will be excluded when the executable file is compiled, provided that it is not called anywhere else in the program. <br>  It should be noted that GCC also has the ability to link and optimize an intermediate code (LTO, link-time optimization) [6]. <br>  Of course, optimization in LLVM is not limited to optimization of the IR-code.  Inside the backend, various optimizations also occur at different stages of converting the IR code into a machine representation.  Some of these optimizations are done by LLVM independently, but the backend developer can (and should) develop his own optimization algorithms that will make full use of the features of the processor architecture. <br><br><h2>  Target platform code generation </h2><br>  Development of a compiler for the original processor architecture, this is mainly the development of the backend.  Intervention in the frontend algorithms, as a rule, is not necessary, or, in any case, requires very good reasons.  If you analyze the source code of Clang, you can see that most of the "special" algorithms are on the x86 and PowerPC processors with their non-standard real number formats.  For most other processors, you only need to specify the sizes of the base types and endianness (big-endian or little-endian).  Most often, you can simply find a similar (in terms of digit capacity) processor among the many supported. <br>  Code generation for the target platform occurs in the LLVM, LLC backend.  LLC supports many different processors, and you can use it to make a code generator for your own original processor.  This task is simplified by the fact that all source code, including modules for each supported architecture, is completely open and available for study. <br>  It is the code generator for the target platform (target) that is the most time-consuming task when developing a compiler based on the LLVM infrastructure.  I decided not to dwell in detail here on the implementation features of the backend, since they significantly depend on the architecture of the target processor.  However, if a respected Habr audience has an interest in this topic, I am ready to describe the key points in the development of the backend in the next article. <br><br><h2>  Conclusion </h2><br>  Within a small article, neither the LLVM architecture, the syntax of the LLVM IR language, nor the backend development process can be considered in detail.  However, these issues are covered in detail in the documentation.  The author rather tried to give a general idea of ‚Äã‚Äãthe LLVM compilers infrastructure, emphasizing that this platform is modern, powerful, universal, and independent of either the input language or the target processor architecture, allowing you to implement both. <br>  In addition to the considered, LLVM contains other utilities, but their consideration is beyond the scope of the article. <br>  LLVM allows implementing a backend for any architecture (see note), including architectures with pipelining, with extraordinary execution of commands, with various parallelization options, VLIW, for classical and stack architectures, in general, for any options. <br>  Regardless of how non-standard solutions underlie the processor architecture, it‚Äôs just a matter of writing a larger or smaller amount of code. <br><div class="spoiler">  <b class="spoiler_title">note</b> <div class="spoiler_text">  for anyone within reason.  It is hardly possible to implement a C compiler for 4-bit architecture, since  The language standard clearly requires that the digit capacity be at least 8. <br></div></div><br><br><h2>  Literature </h2><br><img src="https://habrastorage.org/files/47a/c3d/adf/47ac3dadfd7b41119d2daf5cb3ae2e6a.jpg"><br>  <b>Compilers</b> <br>  [1] <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2582%25D0%25BE%25D1%2580%25D1%258B:_%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF%25D1%258B,_%25D1%2582%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25B8_%25D0%25B8_%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D1%258B">Dragon Book</a> <br>  [2] Wirth N. Construction of compilers <br>  <b>Gcc</b> <br>  [3] <a href="https://gcc.gnu.org/">gcc.gnu.org</a> - GCC project site <br>  [4] Richard M. Stallman and the GCC Developer Community.  GNU Compiler Collection Internals <br>  <b>Llvm</b> <br>  [5] <a href="http://llvm.org/">http://llvm.org/</a> - LLVM project site <br>  [6] <a href="http://llvm.org/docs/GettingStarted.html">http://llvm.org/docs/GettingStarted.html</a> Getting Started with the LLVM System <br>  [7] <a href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a> LLVM Language Reference Manual <br>  [8] <a href="http://llvm.org/docs/WritingAnLLVMBackend.html">http://llvm.org/docs/WritingAnLLVMBackend.html</a> Writing An LLVM Backend <br>  [9] <a href="http://llvm.org/docs/WritingAnLLVMPass.html">http://llvm.org/docs/WritingAnLLVMPass.html</a> Writing An LLVM Pass <br>  [10] Chen Chung-Shu.  Creating an LLVM Backend for the Cpu0 Architecture <br>  [11] Mayur Pandey, Suyog Sarda.  LLVM Cookbook <br>  [12] Bruno Cardoso Lopes.  Getting Started with LLVM Core Libraries <br>  [13] Suyog Sarda, Mayur Pandey.  LLVM Essentials <br>  <i>The author will be happy to answer your questions in the comments and in PM.</i> <i><br></i>  <i>Request for all noticed typos reported in a personal.</i>  <i>Thank you in advance.</i> </div><p>Source: <a href="https://habr.com/ru/post/277717/">https://habr.com/ru/post/277717/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277705/index.html">Library development for iOS / Android on Golang</a></li>
<li><a href="../277707/index.html">10 habits of content developer.js</a></li>
<li><a href="../277711/index.html">C ++ SDK for Amazon Web Services</a></li>
<li><a href="../277713/index.html">Preparing for the CISA exam. Business Continuity Definitions</a></li>
<li><a href="../277715/index.html">D std.ndslice as a replacement for Python Numpy</a></li>
<li><a href="../277721/index.html">Mesh router is easy</a></li>
<li><a href="../277723/index.html">Asymmetric solutions. ICS Information Security in Energy</a></li>
<li><a href="../277725/index.html">Microsoft Android emulator cooling beer with IoT and Windows 10 and The Maker Show for those who like to solder</a></li>
<li><a href="../277727/index.html">Another implementation of the is_function <T> metafunction for C ++ 98/03</a></li>
<li><a href="../277729/index.html">Build a hybrid Android application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>