<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book "UNIX. Professional programming. 3rd ed. "</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! We reprinted the classic work of William Stevenson and Stephen Rago with the corrected misprints of the translation in hardcover. 

 This book ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book "UNIX. Professional programming. 3rd ed. "</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/piter/blog/349464/"><img src="https://habrastorage.org/webt/yr/k2/nk/yrk2nk3rzy8m2f5uvms6yr5bgfu.jpeg" align="left" alt="image"></a>  Hello!  We reprinted the classic work of William Stevenson and Stephen Rago with the corrected misprints of the translation in hardcover. <br><br>  This book is deservedly popular with serious programmers around the world, because it contains the most important and practical information about managing UNIX and Linux kernels.  Without this knowledge, it is impossible to write efficient and reliable code.  From the basics ‚Äî files, directories, and processes ‚Äî you will gradually move to more complex issues, such as signal processing and terminal I / O, a multithreaded execution model, and interprocess communication using sockets.  In total, this book covers more than 70 interfaces, including POSIX asynchronous I / O functions, cyclic locks, barriers, and POSIX semaphores. <br><br>  Inside, we will look at the ‚ÄúDemon Process‚Äù chapter. <br><a name="habracut"></a><br><h3>  13.2.  Demon characteristics </h3><br>  Consider some of the most common system daemons and their relationship with process groups, controlling terminals, and sessions described in Chapter 9. The ps (1) command displays information about processes in the system.  This command has many parameters, additional information about them you will find in the reference manual.  Run the command 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ps</span></span> -axj</code> </pre> <br>  in the BSD-system and we will use the information received from it in the further discussion.  The -a switch is used to output processes owned by other users, the -x switch to output processes that do not have a controlling terminal, and the -j switch to display additional information related to tasks: session identifier, process group identifier, controlling terminal and terminal process group identifier. <br><br>  For systems based on System V, a similar command looks like ps -efj.  (For security reasons, some versions of UNIX do not allow processes belonging to other users to be viewed by the ps command.) The output of the ps command looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/z1/jm/kc/z1jmkcezc1smfi2f0-zu5nvpiba.png" alt="image"></div><br>  From this example, we have removed several columns that are not of particular interest to us, such as accumulated processor time.  The following columns are shown, from left to right: user ID (UID), process ID (PID), parent process ID (PPID), process group ID (PGID), session ID (SID), terminal name (TTY), and command line (CMD ). <br><br>  <i>The system on which this command was run (Linux 3.2.0) supports the notion of a session identifier, which we mentioned when discussing the setsid function in section 9.5.</i>  <i>The session ID is just the session leader process ID.</i>  <i>However, in BSD-based systems, the address of the session structure corresponding to the process group to which this process belongs (section 9.11) will be displayed.</i> <br><br>  The list of system processes that you will see depends largely on the implementation of the operating system.  Typically, these will be processes with a parent process ID of 0, launched by the kernel during the boot process.  (The exception is the init process, as this is a user-level command that the kernel starts at boot time.) Kernel processes are special processes, they exist all the time while the system is running.  These processes have superuser privileges and have neither a controlling terminal nor command lines. <br><br>  In this example, the output of the ps command, the kernel demons can be recognized by the names in square brackets.  This version of Linux uses a special kernel process, kthreadd, to create kernel processes; therefore, the parent of all other kernel daemons is the kthreadd process.  For each component of the kernel, which must perform operations in the context of a process, but has not been called from a user process, it usually creates its own process ‚Äî a kernel daemon.  For example, in Linux: <br><br><ul><li>  There is a kswapd daemon, also known as a page dumping daemon.  It provides support for the virtual memory subsystem, over time writing the modified memory pages to disk so that they can be freed. </li><li>  The flush daemon pushes changed pages to disk when the amount of available memory drops to the minimum limit.  It also pushes modified memory pages to disk at regular intervals to reduce data loss in the event of a system crash.  The system can simultaneously run several flush daemons ‚Äî one for each device.  In the example above, there is only one flush daemon named flush-8: 0, where 8 is the most significant device number and 0 is the lowest. </li><li>  The sync_supers daemon periodically pops file system metadata to disk. </li><li>  The jbd daemon provides ext4 journal support. </li></ul><br>  The process with ID 1 is usually the init process (launchd on Mac OS X), as discussed in Section 8.2.  This is a system daemon, which, among other things, is responsible for starting various system services at various levels of loading.  As a rule, these services are also implemented as daemons. <br><br>  The rpcbind daemon converts RPC (Remote Procedure Call) numeric identifiers of services (Remote Procedure Calls) into network port numbers.  The rsyslogd daemon can be used by programs to display messages in the system log, where the administrator can then look.  Messages can be displayed in the console, as well as recorded in a file.  (The syslogd logging mechanism is discussed in more detail in section 13.4.) <br>  In section 9.3 we already talked about the inetd daemon.  This daemon waits for network requests from the network.  The nfsd, nfsiod, lockd, rpciod, rpc.idmapd, rpc.statd, and rpc.mountd daemons provide support for the Network File System (NFS).  Note that the first four of these are kernel daemons, and the last three are user level daemons. <br><br>  The cron daemon executes commands at regular intervals.  It handles various system administration tasks, running them at specified intervals.  The atd daemon resembles the cron daemon and gives users the ability to run jobs at certain points in time, but runs jobs once.  The cupsd daemon is a print server, it serves requests to the printer.  The sshd daemon provides remote access to the system and execution in secure mode. <br><br>  Please note that most daemons have superuser privileges (root).  None of the demons has a controlling terminal - instead of the name of the terminal there is a question mark.  Kernel daemons start without a controlling terminal.  The lack of a controlling terminal for user-level daemons is probably the result of a call to the setsid function.  All user-level daemons are group leaders and session leaders, as well as the only processes in their process groups and sessions (with the exception of rsyslogd).  Finally, note that the parent for most daemons is the init process. <br><br><h3>  13.3.  Demon programming rules </h3><br>  To avoid unwanted interactions when programming daemons, you should follow certain rules.  First we list these rules, and then we will demonstrate the daemonize function that implements them. <br><br>  1. Call the umask function to reset the file creation mode mask to 0. A mask inherited from the triggering process may mask some bits of access rights.  If it is assumed that the daemon process will create files, it may be necessary to set certain bits of access rights.  For example, if a daemon creates files with read and write permissions for a group, the mask of the file creation mode, which turns off any of these bits, will prevent this.  On the other hand, if the daemon calls the library functions that create the files, it makes sense to set a more restrictive mask (for example, 007), since the library functions may not take an argument with permission bits. <br><br>  2. Call the fork function and terminate the parent process.  What is it done for?  First, if the daemon is started as a normal shell command, completing the parent process, we will make the command shell think that the command has been executed.  Secondly, the child process inherits the process group identifier from the parent, but receives its process identifier;  thus, it is guaranteed that the child process will not be the leader of the group, and this is a necessary condition for calling the function setsid, which will be performed later. <br><br>  3. Create a new session by calling the function setsid.  At the same time (remember section 9.5), the process becomes (a) the leader of a new session, (b) the leader of a new group of processes and (c) loses the control terminal. <br><br>  <i>For systems based on System V, some experts recommend at this point to re-invoke the fork function and terminate the parent process so that the second descendant continues as a daemon.</i>  <i>This technique ensures that the daemon will not be the session leader, and this prevents you from receiving a controlling terminal in System V (section 9.6).</i>  <i>Alternatively, in order to avoid acquiring a controlling terminal, the O_NOCTTY flag should be specified whenever opening a terminal device.</i> <br><br>  4. Make the root directory the current working directory.  The current working directory inherited from the parent process may reside on a mounted file system.  Since the daemon, as a rule, exists all the time until the system reboots, in such a situation, when the working directory of the daemon is in a mounted file system, it cannot be unmounted.  Alternatively, some demons can set their own current working directory in which they perform all the necessary actions.  For example, print daemons often select a spooled directory as the current working directory where print jobs are placed. <br><br>  5. Close all unnecessary file descriptors.  This prevents certain descriptors that are inherited from the parent process (the shell or another process) from being kept open.  Using our open_max function (Listing 2.4) or using the getrlimit function (section 7.11), you can determine the maximum possible descriptor number and close all descriptors up to this number. <br><br>  6. Some daemons open file descriptors with numbers 0, 1 and 2 on the / dev / null device, so any library functions that try to read from a standard input device or write to a standard output device or error messages will not render no influence.  Since the daemon is not connected to any terminal device, it cannot interact with the user interactively.  Even if the daemon is running in an interactive session, it still goes into the background, and the initial session can end without affecting the daemon process.  From the same terminal, other users can log in to the system, and the daemon should not output any information to the terminal, and users do not expect that their input from the terminal will be read by the daemon. <br><br>  <b>Example</b> <br>  Listing 13.1 shows the function that an application that wants to become a daemon can call. <br><br>  Listing 13.1.  Initializing the daemon process <br><br><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"apue.h"</span></span> #include &lt;syslog.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/resource.h&gt; void daemonize(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *cmd) {    int                 i, fd0, fd1, fd2;    pid_t               pid;    <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rlimit</span></span></span></span>       rl;    <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sigaction</span></span></span></span>    sa;    <span class="hljs-comment"><span class="hljs-comment">/*     *     .     */</span></span>    umask(<span class="hljs-number"><span class="hljs-number">0</span></span>);    <span class="hljs-comment"><span class="hljs-comment">/*     *      .     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getrlimit(RLIMIT_NOFILE, &amp;rl) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_quit(<span class="hljs-string"><span class="hljs-string">"%s:      "</span></span>, cmd);    <span class="hljs-comment"><span class="hljs-comment">/*     *    ,    .     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pid = fork()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_quit(<span class="hljs-string"><span class="hljs-string">"%s:    fork"</span></span>, cmd);    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>        exit(<span class="hljs-number"><span class="hljs-number">0</span></span>);    setsid();    <span class="hljs-comment"><span class="hljs-comment">/*     *       .     */</span></span>    sa.sa_handler = SIG_IGN;    sigemptyset(&amp;sa.sa_mask);    sa.sa_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sigaction(SIGHUP, &amp;sa, NULL) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_quit(<span class="hljs-string"><span class="hljs-string">"%s:    SIGHUP"</span></span>, cmd);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((pid = fork()) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_quit(<span class="hljs-string"><span class="hljs-string">"%s:    fork"</span></span>, cmd);    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pid != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span>        exit(<span class="hljs-number"><span class="hljs-number">0</span></span>);    <span class="hljs-comment"><span class="hljs-comment">/*     *      ,     *       . */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chdir(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_quit(<span class="hljs-string"><span class="hljs-string">"%s:      /"</span></span>, cmd);    <span class="hljs-comment"><span class="hljs-comment">/*     *     .     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rl.rlim_max == RLIM_INFINITY)        rl.rlim_max = <span class="hljs-number"><span class="hljs-number">1024</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; rl.rlim_max; i++)    close(i);    <span class="hljs-comment"><span class="hljs-comment">/*     *    0, 1  2  /dev/null.     */</span></span>    fd0 = open(<span class="hljs-string"><span class="hljs-string">"/dev/null"</span></span>, O_RDWR);    fd1 = dup(<span class="hljs-number"><span class="hljs-number">0</span></span>);    fd2 = dup(<span class="hljs-number"><span class="hljs-number">0</span></span>);    <span class="hljs-comment"><span class="hljs-comment">/*     *   .     */</span></span>    openlog(cmd, LOG_CONS, LOG_DAEMON);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd0 != <span class="hljs-number"><span class="hljs-number">0</span></span> || fd1 != <span class="hljs-number"><span class="hljs-number">1</span></span> || fd2 != <span class="hljs-number"><span class="hljs-number">2</span></span>) {        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"   %d %d %d"</span></span>,               fd0, fd1, fd2);        exit(<span class="hljs-number"><span class="hljs-number">1</span></span>);    } }</code> </pre> <br>  If the daemonize function is called from a program that then pauses, we can check the status of the daemon using the ps command: <br><br><pre> <code class="hljs cs">$ ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> $ ps -efj UID     PID   PPID   PGID   SID   TTY  CMD sar   <span class="hljs-number"><span class="hljs-number">13800</span></span>      <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">13799</span></span> <span class="hljs-number"><span class="hljs-number">13799</span></span>   ?    ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> $ ps -efj | grep <span class="hljs-number"><span class="hljs-number">13799</span></span> sar   <span class="hljs-number"><span class="hljs-number">13800</span></span>      <span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">13799</span></span> <span class="hljs-number"><span class="hljs-number">13799</span></span>   ?    ./a.<span class="hljs-keyword"><span class="hljs-keyword">out</span></span></code> </pre> <br>  Using the ps command, you can also make sure that the system does not have an active process with the identifier 13799. This means that our daemon belongs to an orphaned process group (section 9.10) and is not the session leader, and therefore cannot acquire a controlling terminal.  This is the result of the second call to the fork function in the daemonize function.  As you can see, our daemon is initialized correctly. <br><br><h3>  13.4.  Error logging </h3><br>  One of the problems inherent in demons is related to the maintenance of error messages.  The daemon cannot simply output messages to the standard error message output device, since it does not have a controlling terminal.  We cannot require the daemon to display messages in the console, since on most workstations a multi-window system is started up in the console.  We also cannot require the daemon to store its messages in a separate file.  This would be a source of constant headaches for the system administrator, who would be forced to memorize which file each daemon writes in its messages.  Some centralized error logging mechanism is required. <br><br>  <i>The syslog mechanism for BSD systems was developed at Berkeley and has been widely distributed since 4.2BSD.</i>  <i>Most BSD-derived systems support syslog.</i>  <i>Before the advent of SVR4, System V did not have a centralized mechanism for logging error messages.</i>  <i>The syslog function was included in the Single UNIX Specification standard as an XSI extension.</i> <br><br>  The syslog mechanism for BSD systems has been widely used since 4.2BSD.  Most demons use this particular mechanism.  In fig.  13.1 shows its structure.  There are three ways to register messages. <br><br>  1. Kernel procedures can access the log function.  These messages are available to any user process that can open and read the device / dev / klog.  We will not consider this function, since we are not going to write kernel procedures. <br><br>  2. Most user processes (daemons) for logging messages call the syslog (3) function.  We will look at how to work with it later.  This function sends messages through the UNIX domain socket - / dev / log. <br><br>  3. A user process running on this computer or on another computer connected to this computer via TCP / IP can send messages via UDP protocol to port 514. Note that the syslog function never generates UDP datagrams ‚Äî this functionality requires that The program supported networking. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/mx/au/ox/mxauoxjbdcflpgwc5fkiwcic1nm.png" alt="image"></div><br>  For more information about UNIX domain sockets, see [Stevens, Fenner, and Rudoff, 2004].  Usually, the syslogd daemon understands all three ways to log messages.  At startup, this daemon reads a configuration file (usually /etc/syslog.conf), which defines where messages of various classes should be sent.  For example, urgent messages can be displayed in the system administrator's console (if it is in the system), while warnings can be written to a file. <br><br>  In our case, interaction with this mechanism is carried out through the syslog function. <br><br><pre> <code class="hljs vbscript">#include &lt;syslog.h&gt; void openlog(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char *ident, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">option</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> facility); void syslog(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> priority, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char *format, ...); void closelog(void); <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> setlogmask(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> maskpri);</code> </pre> <br>  Returns the previous mask priority value of logged messages. <br><br>  The openlog function is optional.  If the openlog function was not called before the first call to the syslog function, it will be called automatically.  Calling the closelog function is also optional ‚Äî it simply closes the file descriptor that was used to interact with the syslogd daemon. <br><br>  The openlog function allows you to define an identification string in the ident argument, which usually contains the name of the program (for example, cron or inetd).  The option argument is a bitmask that defines various ways to display messages.  In tab.  13.1 lists the values ‚Äã‚Äãthat can be included in the mask.  The XSI column identifies those that the Single UNIX Specification standard includes in the definition of the openlog function. <br><br>  Possible values ‚Äã‚Äãfor the facility argument are given in table.  13.2.  Note that the Standard Single UNIX Specification defines only a fraction of the values ‚Äã‚Äãnormally available on a particular system.  The facility argument allows you to determine how messages from different sources should be processed.  If the program does not call the openlog function or passes the value 0 to the facility argument, you can specify the source of the message using the syslog function, defining it as part of the priority argument. <br><br>  The syslog function is called to send a message.  The priority argument is the combination of the value for the facility argument (table 13.2) and the message severity level (table 13.3).  The levels of importance are listed in the table.  13.3 in descending order, from highest to lowest. <br><br>  Table 13.1.  Possible values ‚Äã‚Äãthat can be included in the option argument of the openlog function <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1g/ts/uk/1gtsukzfx_icfzxcpdebnfigye8.png" alt="image"></div><br>  The format argument and all subsequent arguments are passed to the vsprintf function to create a message string.  The characters% m in the format string are replaced with an error message (strerror), which corresponds to the value of the variable errno. <br><br>  The setlogmask function can be used to set the priority mask for process messages.  This function returns the previous mask value.  If the priority mask is set, messages whose priority level is not contained in the mask will not be logged.  Note: it follows from the above that if the mask is set to 0, all messages will be logged. <br><br>  Many systems also have a logger (1) program that can send messages to the syslog mechanism.  Some implementations allow the program to pass optional arguments that indicate the source of the message (facility), the level of importance (level) and the identification string (ident), although the System UNIX Specification standard does not define additional arguments.  The logger command is intended for use in shell scripts that run in non-interactive mode and need a message logging mechanism. <br><br>  Table 13.2.  Possible values ‚Äã‚Äãfor the facility argument of the openlog function <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/wg/g-/nkwgg-l34qplyof2judt3l_b4ku.png" alt="image"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hu/zn/n8/huznn8ycerlyvmhrqzmktelityg.png" alt="image"></div><br>  Table 13.3.  Message severity levels (in descending order) <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/es/ih/gs/esihgslnza0m8jrnebztx1lheoe.png" alt="image"></div><br>  <b>Example</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the (hypothetical) print daemon you can find the following lines: </font></font><br><br><pre> <code class="hljs perl">openlog(<span class="hljs-string"><span class="hljs-string">"lpd"</span></span>, LOG_PID, LOG_LPR); syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"open error for %s: %m"</span></span>, filename);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A call to the openlog function establishes an identification string with the name of the program, indicates that the process identifier must be added to the message, and stipulates that the source of messages is the printing system daemon. </font><font style="vertical-align: inherit;">The syslog function call indicates the level of importance of the message and the message itself. </font><font style="vertical-align: inherit;">If you omit the openlog function call, the syslog call might look like this:</font></font><br><br><pre> <code class="hljs lisp">syslog(<span class="hljs-name"><span class="hljs-name">LOG_ERR</span></span> | LOG_LPR, <span class="hljs-string"><span class="hljs-string">"open error for %s: %m"</span></span>, filename)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, in the priority argument, we have combined the link to the source of the message and the level of importance of the message. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the syslog function, many platforms support its version, which takes additional arguments in the form of a variable-length list.</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">syslog</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-id"><span class="hljs-selector-id">#include</span></span> &lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">stdarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.h</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vsyslog</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">int</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">priority</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">const</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">char</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">format</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">va_list</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">arg</span></span>);</code> </pre> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All four platforms discussed in this book support the vsyslog function, but it is not part of the Single UNIX Specification standard. </font><font style="vertical-align: inherit;">Note: to make this feature available in your application, you may need to define an extra character, such as __BSD_VISIBLE in FreeBSD or __USE_BSD in Linux. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most syslogd implementations in order to reduce the processing time for requests from applications put incoming messages into a queue. </font><font style="vertical-align: inherit;">If at this time the daemon receives two identical messages, only one will be logged. </font><font style="vertical-align: inherit;">But at the end of such a message, the daemon will add a line like this: ‚Äúlast message repeated N times‚Äù (the last message was repeated N times).</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.5. </font><font style="vertical-align: inherit;">Single Demons</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some demons are implemented in such a way that they allow simultaneous operation of only one of their copies. The reason for this behavior may be, for example, the requirement of a monopoly ownership of a resource. So, if the cron daemon allowed several copies of itself to work simultaneously, each of them would attempt, upon reaching the scheduled time, to start the same operation, which would certainly lead to an error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the daemon requires access to the device, several actions may be taken by the device driver to prevent the device from opening by several programs. This will limit the number of concurrent daemon instances to one. However, if the daemon does not intend to contact such devices, then we ourselves will have to do all the necessary work to impose restrictions.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the main mechanisms for limiting the number of simultaneously working copies of a daemon is file and record locking. (We will look at locking files and records in files in section 14.3.) If each of the daemons creates a file and attempts to set a lock for the file for the record, the system will allow only one such lock to be set. All subsequent attempts to establish a lock for writing will fail, informing the other copies of the daemon that the daemon is already running. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">File and record locking is a convenient mechanism for mutual exclusion. If the daemon sets a lock for the whole file, it will be automatically released upon completion of the daemon. This simplifies the recovery process after errors, since it removes the need to remove the lock left from the previous copy of the daemon.</font></font><br><br>  <b>Example</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function in Listing 13.2 demonstrates the use of file locks and records to ensure that a single daemon instance is started. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 13.2. </font><font style="vertical-align: inherit;">The function that guarantees the launch of only one copy of the daemon</font></font><br><br><pre> <code class="hljs lua">#include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;fcntl.h&gt; #include &lt;syslog.h&gt; #include &lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.h&gt; #include &lt;errno.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/stat.h&gt; #define LOCKFILE <span class="hljs-string"><span class="hljs-string">"/var/run/daemon.pid"</span></span> #define LOCKMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) extern int lockfile(int); int already_running(void) {    int     fd; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>    buf[<span class="hljs-number"><span class="hljs-number">16</span></span>];    fd = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(LOCKFILE, O_RDWR|O_CREAT, LOCKMODE);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"  %s: %s"</span></span>,               LOCKFILE, strerror(errno));        <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);    }    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lockfile(fd) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errno == EACCES || errno == EAGAIN) {            <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd);            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);        }        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"    %s: %s"</span></span>,               LOCKFILE, strerror(errno));        <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>);    }    ftruncate(fd, <span class="hljs-number"><span class="hljs-number">0</span></span>);    sprintf(buf, <span class="hljs-string"><span class="hljs-string">"%ld"</span></span>, (long)getpid());    <span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(fd, buf, strlen(buf)+<span class="hljs-number"><span class="hljs-number">1</span></span>);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each copy of the daemon will attempt to create a file and write its process ID into it. </font><font style="vertical-align: inherit;">This will help the system administrator to identify the process. </font><font style="vertical-align: inherit;">If the file is already locked, the lockfile function will fail with the error code EACCESS or EAGAIN in the errno variable and return to the caller a value of 1 indicating that the daemon is already running. </font><font style="vertical-align: inherit;">Otherwise, the function truncates the file size to zero, writes the process ID to it, and returns the value 0.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The truncation of the file size is necessary because the process identifier of the previous copy of the daemon, represented as a string, could have a greater length. </font><font style="vertical-align: inherit;">Suppose, for example, that a previously running copy of the daemon had process ID 12345, and the current copy has process ID 9999. That is, when this daemon writes its ID, the file will contain line 99995. The truncation of the file deletes information that relates to the previous copy of the daemon.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.6. </font><font style="vertical-align: inherit;">Demon Conventions</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> On UNIX, the demons adhere to the following conventions. </font></font><br><br><ul><li>     ,      /var/run. ,      ,     .      name.pid,  name ‚Äî    . ,  cron      /var/run/crond.pid. </li><li>      ,      /etc.   ,  ,   name.conf,  name ‚Äî    . ,    syslogd  /etc/syslog.conf. </li><li>      ,          (/etc/rc*  /etc/init.d/*).       ,       init,   respawn   /etc/inittab (,     init   System V). </li><li>     ,        ,         .       ,       ,      .         SIGHUP,         .              ,     ,       SIGHUP.       . </li></ul><br>  <b>Example</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The program in Listing 13.3 demonstrates one way to force the daemon to re-read the configuration file. The program uses the sigwait function and a separate stream for signal processing, as described in section 12.8. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 13.3. An example of a daemon that re-reads a configuration file by signal</font></font><br><br><pre> <code class="hljs go">#include <span class="hljs-string"><span class="hljs-string">"apue.h"</span></span> #include &lt;pthread.h&gt; #include &lt;syslog.h&gt; sigset_t mask; extern <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> already_running(void); void reread(void) {    <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } void * thr_fn(void *arg) {    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err, signo;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) {        err = sigwait(&amp;mask, &amp;signo);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err != <span class="hljs-number"><span class="hljs-number">0</span></span>) {            syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"   sigwait"</span></span>);            exit(<span class="hljs-number"><span class="hljs-number">1</span></span>);        }        <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (signo) {        <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIGHUP:            syslog(LOG_INFO, <span class="hljs-string"><span class="hljs-string">"  "</span></span>);            reread();            <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SIGTERM:            syslog(LOG_INFO, <span class="hljs-string"><span class="hljs-string">"  SIGTERM; "</span></span>);            exit(<span class="hljs-number"><span class="hljs-number">0</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:            syslog(LOG_INFO, <span class="hljs-string"><span class="hljs-string">"   %d\n"</span></span>, signo);        }    }    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char *argv[]) {    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>              err;    pthread_t        tid;    char             *cmd;    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> sigaction sa;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cmd = strrchr(argv[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'/'</span></span>)) == NULL)        cmd = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>];    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>        cmd++;    <span class="hljs-comment"><span class="hljs-comment">/*     *    .     */</span></span>    daemonize(cmd);    <span class="hljs-comment"><span class="hljs-comment">/*     * ,        .     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (already_running()) {        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"  "</span></span>);        exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); }    <span class="hljs-comment"><span class="hljs-comment">/*     *       SIGHUP     *    .     */</span></span>    sa.sa_handler = SIG_DFL;    sigemptyset(&amp;sa.sa_mask);    sa.sa_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sigaction(SIGHUP, &amp;sa, NULL) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_quit(<span class="hljs-string"><span class="hljs-string">"%s:    SIG_DFL  SIGHUP"</span></span>);    sigfillset(&amp;mask);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((err = pthread_sigmask(SIG_BLOCK, &amp;mask, NULL)) != <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_exit(err, <span class="hljs-string"><span class="hljs-string">"   SIG_BLOCK"</span></span>);    <span class="hljs-comment"><span class="hljs-comment">/*     *     SIGHUP  SIGTERM.     */</span></span>    err = pthread_create(&amp;tid, NULL, thr_fn, <span class="hljs-number"><span class="hljs-number">0</span></span>);    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err != <span class="hljs-number"><span class="hljs-number">0</span></span>)        err_exit(err, <span class="hljs-string"><span class="hljs-string">"  "</span></span>);    <span class="hljs-comment"><span class="hljs-comment">/*     *   -.     */</span></span>    <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>    exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To switch to daemon mode, the program uses the daemonize function from Listing 13.1. After returning from it, the function already_running from Listing 13.2 is called, which checks for other running copies of the daemon. At this point, the SIGHUP signal is still ignored, so we must reset its disposition to its default value, otherwise the sigwait function will never be able to get it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, all signals are blocked, since this is recommended for multi-threaded programs, and a stream is created that will deal with signal processing. The stream serves only the SIGHUP and SIGTERM signals. When a SIGHUP signal is received, the reread function rereads the configuration file, and when a SIGTERM signal is received, the stream writes a message to the log and terminates the process.</font></font><br><br>  In tab.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10.1 indicates that by default, the SIGHUP and SIGTERM signals terminate the process. </font><font style="vertical-align: inherit;">Since these signals are blocked, the daemon will not terminate if it receives one of them. </font><font style="vertical-align: inherit;">Instead, the stream, causing sigwait, will receive the numbers of the delivered signals.</font></font><br><br>  <b>Example</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The program in Listing 13.4 shows how the daemon can intercept the SIGHUP signal and re-read the configuration file without using a separate thread. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 13.4. </font><font style="vertical-align: inherit;">Alternative implementation of a daemon that re-reads the configuration file by signal</font></font><br><br><pre> <code class="hljs go">#include <span class="hljs-string"><span class="hljs-string">"apue.h"</span></span> #include &lt;syslog.h&gt; #include &lt;errno.h&gt; extern <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lockfile(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); extern <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> already_running(void); void reread(void) {    <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } void sigterm(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signo) {    syslog(LOG_INFO, <span class="hljs-string"><span class="hljs-string">"  SIGTERM; "</span></span>);    exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); } void sighup(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signo) {    syslog(LOG_INFO, <span class="hljs-string"><span class="hljs-string">"  "</span></span>);    reread(); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char *argv[]) {    char             *cmd;    <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> sigaction sa;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cmd = strrchr(argv[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-string"><span class="hljs-string">'/'</span></span>)) == NULL)        cmd = argv[<span class="hljs-number"><span class="hljs-number">0</span></span>];    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>        cmd++;    <span class="hljs-comment"><span class="hljs-comment">/*     *    .     */</span></span>    daemonize(cmd);    <span class="hljs-comment"><span class="hljs-comment">/*     * ,        .     */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (already_running()) {        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"  "</span></span>);        exit(<span class="hljs-number"><span class="hljs-number">1</span></span>);    }    <span class="hljs-comment"><span class="hljs-comment">/*     *   .     */</span></span>    sa.sa_handler = sigterm;    sigemptyset(&amp;sa.sa_mask);    sigaddset(&amp;sa.sa_mask, SIGHUP);    sa.sa_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sigaction(SIGTERM, &amp;sa, NULL) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"   SIGTERM: %s"</span></span>,               strerror(errno));        exit(<span class="hljs-number"><span class="hljs-number">1</span></span>);    }    sa.sa_handler = sighup;    sigemptyset(&amp;sa.sa_mask);    sigaddset(&amp;sa.sa_mask, SIGTERM);    sa.sa_flags = <span class="hljs-number"><span class="hljs-number">0</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sigaction(SIGHUP, &amp;sa, NULL) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {        syslog(LOG_ERR, <span class="hljs-string"><span class="hljs-string">"   SIGHUP: %s"</span></span>,               strerror(errno));        exit(<span class="hljs-number"><span class="hljs-number">1</span></span>);    }    <span class="hljs-comment"><span class="hljs-comment">/*     *   -.     */</span></span>     <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>     exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13.7. </font><font style="vertical-align: inherit;">Client server model</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Most often, daemon processes are used as server processes. </font></font> In fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 13.1 shows an example of interaction with the syslogd server, which receives messages from applications (clients) via a UNIX domain socket. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, a server is a process that expects requests for the provision of certain services to customers. So, on fig. 13.1 syslogd server provides error logging services. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shown in fig. 13.1 the interaction between the server and the client is one-way. The client sends messages to the server, but receives nothing from it. In subsequent chapters, we will see many examples of two-way interaction between the server and the client, when the client sends a request to the server, and the server returns a response to the client.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Servers often provide customer service by running other programs using fork and exec. Such servers often open a lot of file descriptors: endpoints of interactions, configuration files, log files, etc. In the best case, it would be just a matter of negligence to leave descriptors open in the child process, because they most likely will not be used in a child-launched program, especially if this program has nothing to do with the server, at worst - this can lead to security problems: the program being launched may try to perform some malicious actions, for example, from change the server configuration file or fraudulently obtain important information from the client.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The simplest solution to this problem is to set the close flag when calling the exec function (close-on-exec) for all file descriptors that are not required by the program being run. </font><font style="vertical-align: inherit;">Listing 13.5 shows a function that can be used in a server process for this purpose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 13.5. </font><font style="vertical-align: inherit;">Setting the close flag when calling exec</font></font><br><br><pre> <code class="hljs kotlin">#include <span class="hljs-string"><span class="hljs-string">"apue.h"</span></span> #include &lt;fcntl.h&gt; int set_cloexec(int fd) {    int     <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>;    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> = fcntl(fd, F_GETFD, <span class="hljs-number"><span class="hljs-number">0</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(-<span class="hljs-number"><span class="hljs-number">1</span></span>);    <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> |= FD_CLOEXEC; <span class="hljs-comment"><span class="hljs-comment">/*      exec */</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(fcntl(fd, F_SETFD, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>)); }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13.8. </font></font> Summarizing </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The running time of the daemon processes in most cases coincides with the running time of the system itself. </font><font style="vertical-align: inherit;">When developing programs that will work as daemons, it is necessary to understand and take into account the relationships between the processes that were described in Chapter 9. In this chapter, we developed a function that can be called from the process to correctly switch to daemon mode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also discussed ways of logging daemon error messages, since they usually do not have a controlling terminal. </font><font style="vertical-align: inherit;">We reviewed a series of agreements that demons must follow in most versions of UNIX, and showed examples of how these agreements are implemented.</font></font><br><br>  ¬ªMore information about the book can be found on <a href="https://www.piter.com/collection/all/product/unix-professionalnoe-programmirovanie-3-e-izd">the publisher's website.</a> <br>  ¬ª <a href="http://storage.piter.com/upload/contents/978544610649/978544610649_X.pdf">Table of Contents</a> <br>  ¬ª <a href="http://storage.piter.com/upload/contents/978544610649/978544610649_p.pdf">Excerpt</a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For Habrozhiteley 20% discount coupon - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UNIX</font></font></b> </div><p>Source: <a href="https://habr.com/ru/post/349464/">https://habr.com/ru/post/349464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349452/index.html">[bookmark] Tools for testing javascript projects</a></li>
<li><a href="../349454/index.html">Ring bar graphs in stock</a></li>
<li><a href="../349456/index.html">Digital events in Moscow from February 19 to 25</a></li>
<li><a href="../349458/index.html">Interesting facts about Python or "Happy Birthday, Python!"</a></li>
<li><a href="../349462/index.html">Html page through the eyes of an application developer. Part 1: "Preparation"</a></li>
<li><a href="../349466/index.html">Sanatorium for the brain: how not to force the user to strain</a></li>
<li><a href="../349468/index.html">Why Ramda?</a></li>
<li><a href="../349470/index.html">Virtual Reality Arguments</a></li>
<li><a href="../349472/index.html">The concept of a qualified customer in project management</a></li>
<li><a href="../349474/index.html">How does the software launch: analysis from Zorka.Mobi and Nitro Games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>