<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An example of using policy-based design in C ++ instead of copy-paste and creating OOPs of hierarchies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ is often blamed for unjustified complexity. Of course, the C ++ language is complicated. And with each new standard it becomes more difficult. Th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An example of using policy-based design in C ++ instead of copy-paste and creating OOPs of hierarchies</h1><div class="post__text post__text-html js-mediator-article">  C ++ is often blamed for unjustified complexity.  Of course, the C ++ language is complicated.  And with each new standard it becomes more difficult.  The paradox, however, is that by constantly complicating, C ++ consistently and progressively simplifies the life of developers.  Including ordinary programmers who write code easier than the developers of Boost-a or Folly.  In order not to be unfounded, I will try to show it with a small example ‚Äúfrom the recent one‚Äù: as a result of adaptation to various conditions, the trivial class turned into an easy hardcore using <a href="https://en.wikipedia.org/wiki/Policy-based_design">policy-based design</a> . <br><a name="habracut"></a><br>  So, there was a task to modify a set of certain classes, adding to them a collection of statistics about the time spent in the process of work.  There are not so many classes, about a dozen, some are far from simple according to their logic.  Outside, they expose the same interface, but inside each works in its own way, although some similar pieces in the implementations of each of them, of course, can be found. <br><br>  In the process of implementing this task, it quickly became clear that each of the modified classes would acquire such a set of private methods: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_performer_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work_started</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> &gt; lock{ m_stats_lock }; m_is_in_working = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; m_work_started_at = activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">clock_type_t</span></span>::now(); m_work_activity.m_count += <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work_finished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> &gt; lock{ m_stats_lock }; m_is_in_working = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; activity_tracking::update_stats_from_current_time( m_work_activity, m_work_started_at ); } activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> take_work_stats() { activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_in_working{ <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">clock_type_t</span></span>::time_point work_started_at; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> &gt; lock{ m_stats_lock }; result = m_work_activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-literal"><span class="hljs-literal">true</span></span> == (is_in_working = m_is_in_working) ) work_started_at = m_work_started_at; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( is_in_working ) activity_tracking::update_stats_from_current_time( result, work_started_at ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } ... activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> m_stats_lock; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_is_in_working; activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">clock_type_t</span></span>::time_point m_work_started_at; activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> m_work_activity; ... };</code> </pre> <br>  In some classes, instead of work_started () / work_finished () / take_work_stats () there will be methods wait_started () / wait_finished () / take_wait_stats ().  And in some, and others.  But the code inside these methods will almost 1-in-1 match. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It‚Äôs clear that I didn‚Äôt want to duplicate the same thing, so all the details were moved to the auxiliary class stats_collector_t, after which the main code began to look something like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some_performer_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work_started</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_work_stats.start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work_finished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_work_stats.stop(); } activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> take_work_stats() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_work_stats.take_stats(); } ... activity_tracking::<span class="hljs-keyword"><span class="hljs-keyword">stats_collector_t</span></span> m_work_stats; ... };</code> </pre><br>  The stats_collector_t class initially looked quite simple: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stats_collector_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    work_started */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    work_finished */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> take_stats() { <span class="hljs-comment"><span class="hljs-comment">/*    take_work_stats */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> m_lock; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_is_in_working{ <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">clock_type_t</span></span>::time_point m_work_started_at; <span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> m_work_activity{}; };</code> </pre><br>  Everything seems to be good.  But the first ambush came to light: in some cases, stats_collector_t should not have its own lock.  For example, in some performer classes there are several instances of stats_collector_t, each stats_collector_t counts statistics for different types of work, but work with them is performed under the same lock.  Those.  it turned out that in some places the stats_collector_t should have its own lock, in other places it should be able to use someone else's lock. <br><br>  Well, not a problem.  Let's transform stats_collector_t into a template whose parameter will say whether an internal or external lock object is used: <br><br><pre> <code class="hljs ruby">template&lt; LOCK_HOLDER &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stats_collector_t</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> : //     ,    // -    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LOCK_HOLDER</span></span></span><span class="hljs-class">-. //            // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LOCK_HOLDER</span></span></span><span class="hljs-class">,    </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stats_collector_t</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">template</span></span></span><span class="hljs-class">&lt; typename... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stats_collector_t</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARGS</span></span></span><span class="hljs-class"> &amp;&amp; ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class"> ) : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_lock_holder</span></span></span><span class="hljs-class">{ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::forward</span></span></span><span class="hljs-class">&lt;ARGS&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">)... } {} </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std::lock_guard</span></span></span><span class="hljs-class">&lt; LOCK_HOLDER &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">{ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_lock_holder</span></span></span><span class="hljs-class"> };</span></span> ... /*      *<span class="hljs-regexp"><span class="hljs-regexp">/ } void stop() { std::lock_guard&lt; LOCK_HOLDER &gt; lock{ m_lock_holder }; ... /</span></span>*      *<span class="hljs-regexp"><span class="hljs-regexp">/ } stats_t take_stats() {...} private : LOCK_HOLDER m_lock_holder; bool m_is_in_working{ false }; clock_type_t::time_point m_work_started_at; stats_t m_work_activity{}; };</span></span></code> </pre><br>  Where such classes were to be used as LOCK_HOLDERs: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internal_lock_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> m_lock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">internal_lock_t</span></span>() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.lock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.unlock(); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">external_lock_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> &amp; m_lock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">external_lock_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> &amp; lock ) : m_lock( lock ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.lock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.unlock(); } };</code> </pre><br>  Accordingly, in the performer class, the stats_collector_t instances began to be initialized in one of two possible ways: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">activity_tracking</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">one_performer_t</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-comment"><span class="hljs-comment">//  ,     lock-. lock_t m_common_lock; stats_collector_t&lt; external_lock_t &gt; m_work_stats{ m_common_lock }; stats_collector_t&lt; external_lock_t &gt; m_wait_stats{ m_common_lock }; ... }; class another_performer_t { ... private : //  ,     lock-. stats_collector_t&lt; internal_lock_t &gt; m_work_stats{}; ... };</span></span></code> </pre><br>  True, there also showed up an ambush.  It turned out that the type of an external lock object will not always be activity_tracking :: lock_t.  Sometimes you need to use a different type of lock object, which, however, is suitable for working with std :: lock_guard. <br><br>  Therefore, the auxiliary class external_lock_t also became a template: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; typename <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> = lock_t &gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> external_lock_t { <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> &amp; m_lock; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> : external_lock_t( <span class="hljs-keyword"><span class="hljs-keyword">LOCK</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> ) : m_lock( <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> ) {} <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>() { m_lock.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); } <span class="hljs-type"><span class="hljs-type">void</span></span> unlock() { m_lock.unlock(); } };</code> </pre><br>  As a result, the use of stats_collector_t began to look like this: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">activity_tracking</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">one_performer_t</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-comment"><span class="hljs-comment">//  ,     lock-. lock_t m_common_lock; stats_collector_t&lt; external_lock_t&lt;&gt; &gt; m_work_stats{ m_common_lock }; stats_collector_t&lt; external_lock_t&lt;&gt; &gt; m_wait_stats{ m_common_lock }; ... }; class tricky_performer_t { ... private : //  ,     lock- // -  . mpmc_queue_traits::lock_t m_common_lock; stats_collector_t&lt; external_lock_t&lt; mpmc_queue_traits::lock_t &gt; &gt; m_work_stats{ m_common_lock }; stats_collector_t&lt; external_lock_t&lt; mpmc_queue_traits::lock_t &gt; &gt; m_wait_stats{ m_common_lock }; ... };</span></span></code> </pre><br>  But as it turned out, it was still flowers.  The berries went off when it turned out that in some cases the lock object cannot be captured in the start () and stop () methods, since  these methods are called in a context where the external lock object is already captured. <br><br>  The first thought was to make a pair of methods start_no_lock () / start () and stop_no_lock () / stop ().  But this is a so-so idea.  In particular, such a division may make it difficult to use stats_collector in any template.  In the template code, it may not be clear whether start_no_lock () should be called or just start ().  And in general, the presence of start_no_lock () along with start () looks ugly and complicates the use of stats_collector. <br><br>  Therefore, the behavior of the stats_collector_t template has been changed: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_HOLDER &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stats_collector_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_HOLDER::<span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_HOLDER::<span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> lock{ m_lock_holder }; ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> lock{ m_lock_holder }; ... } <span class="hljs-keyword"><span class="hljs-keyword">stats_t</span></span> take_stats() { ... { <span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span> lock{ m_lock_holder }; ... } ... } ... };</code> </pre><br>  Now the LOCK_HOLDER type must define two type names: start_stop_lock_t (how locking is performed in the start () and stop () methods) and take_stats_lock_t (how locking is performed in the take_stats () method).  And already the class stats_collector_t and with their help does or does not lock the lock object in its code. <br><br>  The simple class internal_lock_t defines these names in a trivial way: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">internal_lock_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span> m_lock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; <span class="hljs-keyword"><span class="hljs-keyword">internal_lock_t</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; <span class="hljs-keyword"><span class="hljs-keyword">internal_lock_t</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">internal_lock_t</span></span>() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.lock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.unlock(); } };</code> </pre><br>  But the external_lock_t template needed to be expanded and another parameter added - the lock policy: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_TYPE = <span class="hljs-keyword"><span class="hljs-keyword">lock_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;class&gt; class LOCK_POLICY = <span class="hljs-keyword"><span class="hljs-keyword">default_lock_policy_t</span></span> &gt; class <span class="hljs-keyword"><span class="hljs-keyword">external_lock_t</span></span> { LOCK_TYPE &amp; m_lock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_POLICY&lt; <span class="hljs-keyword"><span class="hljs-keyword">external_lock_t</span></span> &gt;::<span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_POLICY&lt; <span class="hljs-keyword"><span class="hljs-keyword">external_lock_t</span></span> &gt;::<span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external_lock_t</span></span>( LOCK_TYPE &amp; lock ) : m_lock( lock ) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.lock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_lock.unlock(); } };</code> </pre><br>  Well, the implementation of classes for blocking policies looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_actual_lock_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no_actual_lock_t</span></span>( L &amp; ) {} <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_HOLDER &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_lock_policy_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; LOCK_HOLDER &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; LOCK_HOLDER &gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> LOCK_HOLDER &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">no_lock_at_start_stop_policy_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start_stop_lock_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">no_actual_lock_t</span></span>&lt; LOCK_HOLDER &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">take_stats_lock_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt; LOCK_HOLDER &gt;; }</code> </pre><br>  It turns out that in the case of default_lock_policy_t, the start_stop_lock_t classes are the std :: lock_guard classes and the lock-objects are actually locked in the start () / stop () methods.  But when the no_lock_at_start_stop_policy_t policy is used, start_stop_lock_t is an empty type no_actual_lock_t, which does nothing either in the constructor or in the destructor.  Therefore, there is no lock in start () / stop ().  And the start_stop_lock_t instance itself (also known as no_actual_lock_t) will most likely be simply thrown away by the optimizing compiler. <br><br>  Well, the use of stats_collector_t in different cases began to look like this: <br><br><pre> <code class="hljs ruby">using namespace activity_tracking; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">one_performer_t</span></span></span><span class="hljs-class"> { ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> : //  ,     </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">-. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_common_lock</span></span></span><span class="hljs-class">;</span></span> stats_collector_t&lt; external_lock_t&lt;&gt; &gt; m_work_stats{ m_common_lock }; stats_collector_t&lt; external_lock_t&lt;&gt; &gt; m_wait_stats{ m_common_lock }; ... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tricky_performer_t</span></span></span><span class="hljs-class"> { ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> : //  ,     </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">- // -  . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mpmc_queue_traits::lock_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_common_lock</span></span></span><span class="hljs-class">;</span></span> stats_collector_t&lt; external_lock_t&lt; mpmc_queue_traits::lock_t &gt; &gt; m_work_stats{ m_common_lock }; stats_collector_t&lt; external_lock_t&lt; mpmc_queue_traits::lock_t &gt; &gt; m_wait_stats{ m_common_lock }; ... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">very_tricky_performer_t</span></span></span><span class="hljs-class"> { ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> : //  ,     </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">- // -  ,        // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">start</span></span></span><span class="hljs-class">()  </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stop</span></span></span><span class="hljs-class">()  . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">complex_task_queue_t::lock_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m_common_lock</span></span></span><span class="hljs-class">;</span></span> stats_collector_t&lt; external_lock_t&lt; complex_task_queue_t::lock_t, no_lock_at_start_stop_policy_t &gt; &gt; m_wait_stats{ m_common_lock }; ... };</code> </pre><br>  At the same time, in the preformer classes, both the same start () / stop () / take_stats () methods were called on the objects of the stats_collectors, and continued to be called.  In this regard, nothing has changed for performers; all differences in behavior are explicitly indicated when the corresponding stats_collector object is declared.  Those.  we got to configure the behavior of a particular stats_collector in compile-time without any additional overhead in run-time. <br><br>  What could be the alternatives?  Probably, it was possible to write several variants of stats_collectors, differing in details of the behavior of start () / stop (), but mostly duplicating each other.  Or, it would be possible to make stats_collector an abstract class (interface) from which concrete implementations will be inherited, redefining the behavior of the start () / stop () methods.  Just do not think that in the end it would have turned out shorter and simpler.  Rather, it would be the opposite.  So use of policy-based design in this case looks quite appropriate. <br><br>  What is the moral of this whole story?  That the C ++ language is difficult, but it is justified complexity.  C ++ without templates was much easier.  But programming on it was more difficult. <br><br>  Patterns have appeared, new approaches have become available, such as the policy-based design used in this example.  This simplified the reuse of the code without losing its effectiveness.  Those.  the programmer has become easier to live. <br><br>  Then came the variadic patterns.  Which, of course, made the language even more difficult.  But programming on it has become even easier.  Just look at the constructor class stats_collector_t.  Which is just one and easy to understand.  Without variadics, several constructors for different numbers of arguments would have to be hardcoded (or resort to macros). <br><br>  Well and that can not but rejoice, the process of developing C ++ continues.  Which will make using this language even easier in the future.  If, of course, by that time someone else will continue to use it ...) </div><p>Source: <a href="https://habr.com/ru/post/308594/">https://habr.com/ru/post/308594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308574/index.html">Webinar: FreePBX. Office telephony: quick start</a></li>
<li><a href="../308578/index.html">Big Data hackathon from Innopolis University and Provectus</a></li>
<li><a href="../308586/index.html">What is big data, part 2</a></li>
<li><a href="../308588/index.html">KUKU.io SMM application case: the path from a sprint of 4 months to sensible planning</a></li>
<li><a href="../308590/index.html">How we taught Facebook to make websites or Plan ‚ÄúEnvelope‚Äù</a></li>
<li><a href="../308596/index.html">How to use the standard settings to kill the microcontroller. Part 1</a></li>
<li><a href="../308598/index.html">Several new products in the world of data centers: will they become the norm?</a></li>
<li><a href="../308600/index.html">Russian hacker convicted of stealing $ 169 million</a></li>
<li><a href="../308602/index.html">WhatsApp is going to share data of its users with Facebook</a></li>
<li><a href="../308604/index.html">Mathematics for artificial neural networks for beginners, part 3 - gradient descent continued</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>