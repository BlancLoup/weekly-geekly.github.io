<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>End React Components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What I like about the React ecosystem is that behind many solutions there is an IDEA. Different authors write various articles in support of the exist...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>End React Components</h1><div class="post__text post__text-html js-mediator-article"><p>  What I like about the React ecosystem is that behind many solutions there is an IDEA.  Different authors write various articles in support of the existing order and explain why everything is ‚Äúright‚Äù, so everyone understands that the party is on the right track. </p><br><p>  After some time, the IDEA changes a little, and everything starts from the beginning. </p><br><p>  And the beginning of this story is the separation of components into Containers and non-Containers (in the people - Stupid Components, sorry for my French). </p><br><p><img src="https://habrastorage.org/webt/p3/cl/nl/p3clnlwh5eus18t7l4xkoxgc09a.jpeg"></p><a name="habracut"></a><br><h3 id="problema">  Problem </h3><br><p>  The problem is very simple - unit tests.  Recently, there is some movement towards the integrations tests - well, you know, <em>"Write tests. Not too many. Mostly integration."</em>  .  The idea is not bad, and if time is short (and tests are not particularly needed), this is how it should be done.  Just let's call it smoke tests - purely to verify that nothing <em>seems to</em> explode. </p><br><p>  If there is a lot of time, and tests are needed - this road is better not to go, because writing good integration tests is very, very LONG.  Just because they will grow and grow, and in order to test the third button on the right, you will have to click on the 3 buttons in the menu at the beginning, and remember to log in.  In general - here's a <u>combinatorial explosion</u> on a saucer. </p><br><p>  The solution here is one and simple (by definition) - unit tests.  The ability to start tests with some ready state of some part of the application.  Or rather, to reduce (narrow) the field of testing from an Application or a <em>Big Block</em> to something small ‚Äî a unit, whatever it is.  It does not necessarily use the enzyme - you can run browser tests, if the soul asks.  The most important thing here is to be able to test something in <em>isolation</em> .  And without any problems. </p><br><p>  Isolation is one of the key points in unit testing, and that‚Äôs why units don‚Äôt like tests.  They do not like for various reasons: </p><br><ul><li>  for example, your "unit" is detached from the application, and does not work in its composition even when its own tests are green. </li><li>  or, for example, because isolation is such a spherical horse in a vacuum that no one has seen.  How to achieve it, and how to measure it? </li></ul><br><p>  Personally, I see no problems here.  On the first point, of <em>course,</em> we can recommend integration tests, they are invented for this purpose - to check how the previously tested components are correctly assembled.  You trust npm packages that test, of course, only themselves, and not themselves as part of your application.  How do your "components" differ from "not your" packages? </p><br><p>  With the second paragraph, everything is a bit more complicated.  And this article will be about this item (and everything before this was so - an introduction) - about how to make a "unit" <em>unit testable</em> . </p><br><h3 id="razdelyay-i-vlastvuy">  Divide and rule </h3><br><p>  The idea of ‚Äã‚Äãseparating the React component into "Container" and "Presentation" is not new, is well described, and has already managed to become outdated.  If we take as a basis (what 99% of developers do) the <a href="https://medium.com/%40dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">article by Dan Abramov</a> , then the Presentation Component: </p><br><ul><li>  Are responsible for appearance (Are concerned with how things look) </li><li> May contain both other presentation components and containers <code>**</code> (May contain both presentational and container components <code>**</code> inside, and usually have some DOM markup and styles of their own) </li><li>  Support slots (Often allow containment via this.props.children) </li><li>  Do not depend on the application (Have no dependencies on the rest of the app, such as Flux actions or stores) </li><li>  Do not depend on the data (not the data is loaded or mutated) </li><li>  Interface based on props (Receive data and callbacks exclusively via props) </li><li>  Often stateless (Rarely have their own state (when they do, it's UI state rather than data)) </li><li>  Often SFCs (life written hooks, or performance optimizations) </li></ul><br><p>  Well, Containers are all logic, all data access, and all application in principle. </p><br><blockquote>  In an ideal world, the containers are the trunk, and the presentation components are the leaves. </blockquote><p>  The key points in Dan‚Äôs definition of two are <em>‚ÄúDo not depend on the application‚Äù</em> , which is almost the academic definition of a ‚Äúunit‚Äù, and * ‚ÄúMay contain both other presentation components and containers <code>**</code> ‚Äù * where these stars are particularly interesting. </p><br><blockquote>  (free translation) ** In earlier versions of my article, I (Dan) said that the presentation of the components should contain only other presentation components.  I don't think so anymore.  Component type is detail and may change over time.  In general, do not worry and everything will be okay. </blockquote><p>  Let's remember what happens after this: </p><br><ul><li>  In the storybook, everything falls, because some container, in the third button on the left, climbs into the page which is not.  Special greetings graphql, react-router and other react-intl. </li><li>  You lose the ability to use mount in tests, because it renders everything from A to Z, and again, somewhere in the depths of the render tree, someone does something and the tests drop. </li><li>  The ability to control the application state is lost, since (figuratively speaking) the opportunity to switch selectors / resolvers is lost (especially with proxyquire), and the entire page is required to be wet.  And this is cool for unit tests. </li></ul><br><blockquote>  If it seems to you that the problems are a bit contrived - try to work in a team, when these containers to be used in your non-containers change in other departments, and as a result, you look at the tests and you cannot understand why yesterday worked, and here again. </blockquote><p>  As a result, you have to use shallow, which <em>by design</em> eliminates all harmful (and unexpected) side effects.  Here is a simple example from the article <a href="https://hackernoon.com/why-i-always-use-shallow-rendering-a3a50da60942">"Why I always use shallow"</a> </p><br><p>  Imagine that the Tooltip will render "?", When clicked, the type itself will be shown. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tooltip <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyComponent = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { &lt;Tooltip&gt; hint: {veryImportantTextYouHaveToTest} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/Tooltip&gt; }</span></span></code> </pre> <br><p>  How to protest it?  Mount + click + check what is visible.  This is an integration test, not a unit, and the question is how to click on the "alien" component for you.  There is no problem with shallow, since there are no <em>brains</em> and the "alien component" itself.  And there are brains here, since Tooltip is a container, while MyComponent is <em>practically</em> presentation. </p><br><pre> <code class="javascript hljs">jest.mock(<span class="hljs-string"><span class="hljs-string">'react-cool-tooltip'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">default</span></span>: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> childlren});</code> </pre> <br><p>  But if you click react-cool-tooltip, then there will be no testing problems.  "Component" has become sharply dumber, much shorter, much more <em>finite</em> . </p><br><p>  <strong>Final component</strong> </p><br><ul><li>  a component with a well-known size, which may include other, previously known, final components, or not containing them at all. </li><li>  does not contain other containers, since they contain an uncontrolled state and "increase" the size, i.e.  make the current component <em>infinite</em> . </li><li>  otherwise, this is the usual presentation component.  In fact, it was exactly as described in the <em>first</em> version of Dan‚Äôs article. </li></ul><br><p>  The final component is just a gear, taken out of a large mechanism. </p><br><p>  The whole question is how to take it out. </p><br><h3 id="reshenie-1---di">  Solution 1 - DI </h3><br><p>  My favorite is Dependency Injection.  <a href="https://twitter.com/dan_abramov/status/1021850499618955272">Dan loves him too</a> .  In general, it is not DI, but "slots".  In a nutshell - no need to use containers inside Presentation - they need to be <em>injected</em> there.  And in the tests it will be possible to inject something else. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    mount     const PageChrome = ({children, aside}) =&gt; ( &lt;section&gt; &lt;aside&gt;{aside}&lt;/aside&gt; {children} &lt;/section&gt; ); //     shallow,       //     mount ? , ,   wiring? const PageChromeContainer = () =&gt; ( &lt;PageChrome aside={&lt;ASideContainer /&gt;}&gt; &lt;Page /&gt; &lt;/PageChrome&gt; );</span></span></code> </pre> <br><p>  This is the case when <em>"the containers are the trunk and the presentation components are the leaves"</em> </p><br><h3 id="reshenie-2---granicy">  Solution 2 - Borders </h3><br><p>  DI can often be cool.  Probably now%% username% thinks how it can be applied on the current code base, and the solution is not invented ... </p><br><p>  In such cases, you will save the <strong>boundaries</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Boundary = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{children}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( process.env.NODE_ENV === <span class="hljs-string"><span class="hljs-string">'test'</span></span> ? <span class="hljs-literal"><span class="hljs-literal">null</span></span> : children <span class="hljs-comment"><span class="hljs-comment">// //  jest.mock ); const PageChrome = () =&gt; ( &lt;section&gt; &lt;aside&gt;&lt;Boundary&gt;&lt;ASideContainer /&gt;&lt;/Boundary&gt;&lt;/aside&gt; &lt;Boundary&gt;&lt;Page /&gt;&lt;/Boundary&gt; &lt;/section&gt; );</span></span></code> </pre> <br><p>  Here, instead of "slots", just all the "transition points" turn into Boundary, which will render <em>anything</em> during the tests.  Pretty <em>declarative</em> , and exactly what you need to "take out the gear." </p><br><h3 id="reshenie-3---tier">  Solution 3 - Tier </h3><br><p>  Borders can be a little rough, and it may be easier to make them a little smarter by adding a little knowledge about Layer. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> tier === currentTier; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> withTier = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tier</span></span></span><span class="hljs-function"> =&gt;</span></span> WrapperComponent =&gt; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">process.env.NODE_ENV !== </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'test'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> || checkTier(tier</span></span></span><span class="hljs-function">)) &amp;&amp; &lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WrapperComponent</span></span></span><span class="hljs-function">{...</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">} /&gt; ); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PageChrome</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ASideContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Page = withTier(<span class="hljs-string"><span class="hljs-string">'Page'</span></span>)(...) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChromeContainer = withTier(<span class="hljs-string"><span class="hljs-string">'UI'</span></span>)(PageChrome);</code> </pre> <br><p>  Under the name Tier / Layer there can be different things - feature, duck, module, or just what layer / tier.  The essence is not important, the main thing is that you can pull out the gear, perhaps not one, but a finite amount, <em>somehow</em> drawing the line between what is needed and what is not needed (for different tests this is a different line). </p><br><p>  And nothing prevents to mark these boundaries somehow differently. </p><br><h3 id="reshenie-4separate-concerns">  Solution 4 - Separate Concerns </h3><br><p>  If the solution (by definition) lies in the separation of essences - what will happen if we take them and divide them? </p><br><p>  ‚ÄúContainers‚Äù that we don‚Äôt like so much are usually called <em>containers</em> .  And if not, nothing prevents right now to start calling Components somehow more sonorous.  Or they have a certain pattern in the name - Connect (WrappedComonent), or GraphQL / Query. </p><br><p>  What if right in rantayma draw a boundary between entities based on the name? </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PageChrome = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ASideContainer</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">aside</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Page</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); <span class="hljs-comment"><span class="hljs-comment">// remove all components matching react-redux pattern reactRemock.mock(/Connect\(\w\)/) // all any other container reactRemock.mock(/Container/)</span></span></code> </pre> <br><p>  Plus, one line in the tests, and <a href="https://github.com/theKashey/react-remock">react-remock will</a> remove all containers that might interfere with the tests. </p><br><p>  In principle, this approach can be used to test the containers themselves - just need <em>to remove</em> everything except the first container. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {createElement, remock} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-remock'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  "" const ContainerCondition = React.createContext(true); reactRemock.mock(/Connect\(\w\)/, (type, props, children) =&gt; ( &lt;ContainerCondition.Consumer&gt; { opened =&gt; ( opened ? ( // ""     &lt;ContainerCondition.Provider value={false}&gt; {createElement(type, props, ...children)} &lt;ContainerCondition.Provider&gt; ) // "" : null )} &lt;/ContainerCondition.Consumer&gt; )</span></span></code> </pre> <br><p>  Again - a couple of lines and gear removed. </p><br><h2 id="itogo">  Total </h2><br><p>  Over the past year, testing of the React component has become more complicated, especially for the mount ‚Äî all 10 Providers, Contexts need to be turned, and it is becoming more and more difficult to test the necessary component in the required state ‚Äî too many strings to pull. <br>  Someone spits and goes into the shallow world.  Someone waves his hand at unit tests and transfers everything to Cypress (walk for a walk!). </p><br><p>  Someone else pokes a finger into the reactor, says that it is <em>algebraic effects</em> and you can do what you want.  All the examples above are essentially the use of these <em>algebraic effects</em> and mocks.  For me and DI this is moki. </p><br><blockquote>  PS: This post was written as an answer <a href="https://github.com/reactjs/rfcs/pull/65">to a comment in React / RFC about the fact that the React team broke everything, and all the polymers there too</a> <br>  PPS: This post is actually a <a href="https://hackernoon.com/testing-the-finite-react-components-d08ca74eb8c1">very free translation of another</a> <br>  PPPS: In general, for real isolation, look at <a href="https://habr.com/search/%3Fq%3D%255Brewiremock%255D%26target_type%3Dposts">rewiremock</a> </blockquote></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/434830/">https://habr.com/ru/post/434830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434818/index.html">The accident at the CenturyLink Data Center has caused disruptions in the 911 service</a></li>
<li><a href="../434822/index.html">Program of China "Cars with new energy sources." What to expect in 2019</a></li>
<li><a href="../434824/index.html">Polit-electrical engineering. Modeling of socio-political processes by electrical circuits</a></li>
<li><a href="../434826/index.html">Field beds on time, or 5 signs of hidden problems in the team</a></li>
<li><a href="../434828/index.html">Become a professional. Useful habits of UX designers</a></li>
<li><a href="../434836/index.html">Wonderful Version annotation in JPA</a></li>
<li><a href="../434838/index.html">Creating a bot to participate in the Russian AI Cup 2018 CodeBall</a></li>
<li><a href="../434840/index.html">How I did ‚ÄúYour Diary‚Äù - or the situation in the market of electronic diaries</a></li>
<li><a href="../434842/index.html">City farms can be extremely efficient, but not now</a></li>
<li><a href="../434844/index.html">Restoration of cognitive abilities of 100 patients (translation of the article by Dale Bredesen)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>