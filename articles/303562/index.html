<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of component caching in Unity3D</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most of the unity-developers know that you should not abuse expensive operations for productivity, such as, for example, obtaining components. For thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of component caching in Unity3D</h1><div class="post__text post__text-html js-mediator-article">  Most of the unity-developers know that you should not abuse expensive operations for productivity, such as, for example, obtaining components.  For this it is worth using <a href="http://www.jerrodputman.com/2014/03/27/quick-component-caching-in-unity/">caching</a> .  But for such a simple optimization one can find several different approaches. <br>  This article will look at various caching options, their unobvious features and performance. <br><br><img src="https://habrastorage.org/files/79e/269/8bc/79e2698bcb1e4184a5f2bfb849275a52.png"><br><a name="habracut"></a><br><br>  It is worth noting that we will mainly talk about ‚Äúinternal‚Äù caching, that is, getting those components that are on the current object for its internal needs.  To begin with, we abandon the direct assignment of dependencies in the inspector - this is inconvenient to use, litters the script settings and can lead to broken links when the editor is launched.  Therefore, we will use GetComponent (). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Basic knowledge of components and a simple example of caching</b> <div class="spoiler_text">  In Unity3D, every object on the game scene is a container (GameObject) for various components (Component), which can be either embedded in the engine (Transform, AudioSource, etc.), or custom scripts (MonoBehaviour). <br>  The component can be assigned directly in the editor, and the GetComponent () method is used to get the component from the container in the script. <br><br>  If the component needs to be used more than once, the traditional approach is to declare a variable in the script, where it will be used, to take the necessary component once and then use the resulting value.  Example: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Example</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Rigidbody _rigidbody; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _rigidbody = GetComponent&lt;Rigidbody&gt;(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _rigidbody.AddForce(Vector3.up * Time.deltaTime); } }</code> </pre> <br><br></div></div><br><br>  Initialization caching is also relevant for the properties provided by the GameObject by default, such as .transform, .render, and others.  To access them, explicit caching will still be faster (and most of them are marked as deprecated in Unity 5, so it‚Äôs good practice to refuse to use them). <br><br>  It is worth noting that the most obvious caching method (direct acquisition of components) is initially the most efficient in general and other options only use it and provide easier access to components, eliminating the need to write the same type of code each time or receive components on demand. <br><br><div class="spoiler">  <b class="spoiler_title">A little bit about the fact that caching is not important</b> <div class="spoiler_text">  Also note that there are much more expensive operations (such as creating and deleting objects on the scene) and caching components, without paying attention to them, will be a waste of time.  For example, in your game there is a machine gun that shoots bullets, each of which is a separate object (which in itself is wrong, but this is a spherical example).  You create an object, cache a Collider, ParticleSystem and a whole bunch of it, but the bullet flies into the sky and is killed in 3 seconds, and these components are not used at all. <br><br>  In order to avoid this, use a pool of objects, there are articles on Habr√© ( <a href="https://habrahabr.ru/post/275091/">1</a> , <a href="https://habrahabr.ru/post/255499/">2</a> ) about this and there are <a href="https://www.assetstore.unity3d.com/en/">ready-made solutions</a> .  In this case, you will not constantly create and delete objects and cache them again and again, they will be reused, and caching will happen only once. <br></div></div><br><br>  The performance of all considered caching options will be displayed in a pivot chart. <br><br><h1>  The basics </h1><br><br>  The GetComponent method has two uses: the template GetComponent () and the regular GetComponent (type), which requires an additional cast (comp as T).  In the performance summary chart, both of these options will be considered, but it is worth considering that the template method is easier to use.  There is also an option to get a list of components GetComponents with similar options, they will also be checked.  In the diagrams, the execution time of GetComponent on each platform is taken as 100% for leveling equipment features, and there are also interactive versions for greater convenience. <br><br><h1>  Use of properties </h1><br><br>  For caching, you can use properties.  The advantage of this method is that caching will occur only when we access the property, and it will not be when that property is used.  The downside is that in this case we write more of the same type of code. <br><br>  The easiest option: <br><br><pre> <code class="cs hljs">Transform _transform = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform CachedTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_transform ) { _transform = GetComponent&lt;Transform&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _transform; } }</code> </pre><br><br>  This option, due to checking for a missing component, has performance issues. <br><br><div class="spoiler">  <b class="spoiler_title">! component, what is it?</b> <div class="spoiler_text">  Here you need to take into account that a custom comparison operator is used in Unity3D, so when we safely check if a component is cached (if (! Component)), the engine actually turns into native code, which is resource intensive, you can read more in this <a href="http://blogs.unity3d.com/2014/05/16/custom-operator-should-we-keep-it/">article</a> . <br></div></div><br><br>  There are two options for solving this problem: <br>  Use an additional flag indicating whether caching was performed: <br><br><pre> <code class="cs hljs">Transform _transform = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _transformCached = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform CachedTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !_transformCached ) { _transformCached = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _transform = GetComponent&lt;Transform&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _transform; } }</code> </pre><br><br>  Explicitly cast a component to an object: <br><br><pre> <code class="cs hljs">Transform _transform = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform CachedTransform { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)_transform == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ) { _transform = GetComponent&lt;Transform&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _transform; } }</code> </pre><br><br>  But keep in mind that this option is safe only when the components of the object are not deleted (which usually happens infrequently). <br><br><div class="spoiler">  <b class="spoiler_title">Why in Unity you can refer to the destroyed object?</b> <div class="spoiler_text">  A short excerpt from the article at the link above: <br><blockquote>  When you get the ac # object of type ‚ÄúGameObject‚Äù, it contains almost nothing.  Unity is a C / C ++ engine.  This is a GameObject (its name, it‚Äôs a list of components, it‚Äôs HideFlags, etc.) lives in the c ++ side.  It is a pointer to the native object.  We call these c # objects ‚Äúwrapper objects‚Äù.  The life of these c ++ objects like GameObject and everything else that derives from UnityEngine.Object is explicitly managed.  These objects get destroyed when you load a new scene.  Or when you call Object.Destroy (myObject);  on them.  Lifetime of c # garment collector.  Ac # wrapper object that still exists, it has been destroyed.  If you‚Äôre not sure, you‚Äôll not want to make it true. </blockquote><br><br>  The problem here is that coercion to object allows us to bypass the expensive call of the native code, but at the same time it deprives us of the custom operator to check the existence of the object.  Its C # wrapper can still exist when in fact the object is already destroyed. <br></div></div><br><br><h1>  Inheritance </h1><br><br>  To simplify the task, you can inherit your classes from the component that caches the most used properties, but this option is not universal (requires creating and modifying all the necessary properties) and does not allow inheriting from other components if necessary (in C # there is no multiple inheritance). <br><br>  The first problem can be solved using patterns: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">InnerCache</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { Dictionary&lt;Type, Component&gt; cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, Component&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Get&lt;T&gt;() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Component { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); Component item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> item)) { item = GetComponent&lt;T&gt;(); cache.Add(type, item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; } }</code> </pre><br><br>  You can get around the second problem by creating a separate component for caching and using a link to it in your scripts. <br><br><h1>  Static caching </h1><br><br>  There is a variant of using such a feature of C # as an extension.  It allows you to add your methods to existing classes without modifying them and inheriting them.  This is done as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExternalCache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;GameObject, TestComponent&gt; test = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;GameObject, TestComponent&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCachedTestComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameObject owner</span></span></span><span class="hljs-function">)</span></span> { TestComponent item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!test.TryGetValue(owner, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> item)) { item = owner.GetComponent&lt;TestComponent&gt;(); test.Add(owner, item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item; } }</code> </pre><br><br>  After that, in any script you can get this component: <br><br><pre> <code class="cs hljs">gameObject.GetCachedTestComponent();</code> </pre><br><br>  But this option again requires setting all necessary components in advance.  You can solve this with the help of templates: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExternalCache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;GameObject, Dictionary&lt;Type, Component&gt;&gt; cache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;GameObject, Dictionary&lt;Type, Component&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T GetCachedComponent&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> GameObject owner) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Component { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T); Dictionary&lt;Type, Component&gt; container = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cache.TryGetValue(owner, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> container)) { container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, Component&gt;(); cache.Add(owner, container); } Component item = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!container.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> item)) { item = owner.GetComponent&lt;T&gt;(); container.Add(type, item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> T; } }</code> </pre><br><br>  The disadvantage of these options is to keep track of dead links.  If you do not clear the cache (for example, when loading a scene), then its volume will only grow and clog the memory with references to objects that have already been deleted. <br><br><h1>  Performance comparison </h1><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a0/d6a/bb8/0a0d6abb8e1a5989975c81a901a32756.png" alt="image"><br>  <a href="https://docs.google.com/spreadsheets/d/1OPSe_wu4acAoLY87XD_aNHQFiTYeV9YaJmD34aEQ-DA/pubchart%3Foid%3D1262221294%26format%3Dinteractive">Interactive option</a> <br><br>  As we see, a silver bullet was not found and the most optimal caching option is to receive components directly during initialization.  Workarounds are not optimal, except for properties that require writing additional code. <br><br><h1>  Using Attributes </h1><br><br>  <a href="https://habrahabr.ru/post/140842/">Attributes</a> allow you to add meta-information for code elements, such as, for example, class members.  Attributes themselves are not fulfilled, they must be used with the help of reflection, which is quite an expensive operation. <br><br>  We can declare our own attribute for caching: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.Field)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CachedAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { }</code> </pre><br><br>  And use it for the fields of your classes: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Cached</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TestComponent Test;</code> </pre><br><br>  But so far this will not give us anything, this information is not used in any way. <br><br><h1>  Inheritance </h1><br><br>  We can create our own class, which will receive class members with this attribute and explicitly receive them during initialization: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AttributeCacheInherit</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CacheAll(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheAll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = GetType(); CacheFields(GetFieldsToCache(type)); } <span class="hljs-function"><span class="hljs-function">List&lt;FieldInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFieldsToCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fields = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FieldInfo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> type.GetFields()) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field.GetCustomAttributes(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CachedAttribute) { fields.Add(field); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fields; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;FieldInfo&gt; fields</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iter = fields.GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iter.MoveNext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = iter.Current.FieldType; iter.Current.SetValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, GetComponent(type)); } } }</code> </pre><br><br>  If we create an inheritor of this component, then we can mark its members with the [Cached] attribute, thereby not caring for their explicit caching. <br>  But the problem with performance and the need for inheritance levels the convenience of this method. <br><br><h1>  Static type cache </h1><br><br>  The list of class members does not change when the code is executed, so we can get it once, save it for this type and use it in the future, almost without resorting to expensive reflection.  To do this, we need a static class that stores the results of the type analysis. <br><br><div class="spoiler">  <b class="spoiler_title">Type Caching</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CacheHelper</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Type, List&lt;FieldInfo&gt;&gt; cachedTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, List&lt;FieldInfo&gt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheAll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour instance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> internalCache = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = instance.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( internalCache ) { List&lt;FieldInfo&gt; fields = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !cachedTypes.TryGetValue(type, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> fields) ) { fields = GetFieldsToCache(type); cachedTypes[type] = fields; } CacheFields(instance, fields); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { CacheFields(instance, GetFieldsToCache(type)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;FieldInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFieldsToCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fields = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FieldInfo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> type.GetFields() ) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field.GetCustomAttributes(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CachedAttribute ) { fields.Add(field); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fields; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour instance, List&lt;FieldInfo&gt; fields</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iter = fields.GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(iter.MoveNext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = iter.Current.FieldType; iter.Current.SetValue(instance, instance.GetComponent(type)); } } }</code> </pre><br></div></div><br><br>  And now for caching in any script we use the appeal to it: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { CacheHelper.CacheAll(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre><br><br>  After that, all class members marked [Cached] will be retrieved using GetComponent. <br><br><h1>  Efficiency of caching using attributes </h1><br><br>  Compare performance for variants with 1 or 5 cached components: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d44/76b/978/d4476b9782bb0cddf02e4710daf7585a.png" alt="image"><br>  <a href="https://docs.google.com/spreadsheets/d/1OPSe_wu4acAoLY87XD_aNHQFiTYeV9YaJmD34aEQ-DA/pubchart%3Foid%3D1071723327%26format%3Dinteractive">Interactive option</a> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/259/974/76c/25997476cae9cfa75de379a9db888620.png" alt="image"><br>  <a href="https://docs.google.com/spreadsheets/d/1OPSe_wu4acAoLY87XD_aNHQFiTYeV9YaJmD34aEQ-DA/pubchart%3Foid%3D1654855247%26format%3Dinteractive">Interactive option</a> <br><br>  As you can see, this method is inferior in performance to the direct production of components (the gap decreases slightly with an increase in their number), but has several features: <br><ul><li>  A critical performance degradation occurs only when initializing the first instance of a class. </li><li>  Initialization of subsequent instances of this class is much faster, but not as fast as direct caching. </li><li>  The performance of getting components after initialization is identical to getting a member of a class and higher than that of GetComponent and various options with properties </li><li>  But at the same time all members of the class are initialized, regardless of whether they will be used in the future </li></ul><br><br><h1>  Step back or use editor </h1><br><br>  Already when I finished this article, I was prompted by one interesting solution for caching.  Is it necessary in our case to keep the components in the running state of the application?  Not at all, we only do this once for each instance, respectively, functionally, it is no different from assigning them in the editor before launching the application.  And everything that can be done in the editor can be automated. <br><br>  So the idea was to cache the script dependencies using a separate option in the menu, which prepares instances on the scene for further use. <br><br><div class="spoiler">  <b class="spoiler_title">The last for today sheet code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Reflection; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">UnityCache</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PreCacheEditor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WriteToLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; [MenuItem(<span class="hljs-string"><span class="hljs-string">"UnityCache/PreCache"</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = GameObject.FindObjectsOfType&lt;MonoBehaviour&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PreCacheAll(item)) { EditorUtility.SetDirty(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(WriteToLog) { Debug.LogFormat(<span class="hljs-string"><span class="hljs-string">"PreCached: {0} [{1}]"</span></span>, item.name, item.GetType()); } } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreCacheAll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour instance</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = instance.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CacheFields(instance, GetFieldsToCache(type)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;FieldInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFieldsToCache</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fields = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;FieldInfo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> field <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> type.GetFields()) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> field.GetCustomAttributes(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> PreCachedAttribute) { fields.Add(field); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fields; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CacheFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour instance, List&lt;FieldInfo&gt; fields</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> cached = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; UnityEditor.SerializedObject serObj = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iter = fields.GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (iter.MoveNext()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(serObj == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { serObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityEditor.SerializedObject(instance); cached = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = iter.Current.FieldType; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = iter.Current.Name; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property = serObj.FindProperty(name); property.objectReferenceValue = instance.GetComponent(type); Debug.Log(property.objectReferenceValue); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cached) { serObj.ApplyModifiedProperties(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cached; } } }</code> </pre><br></div></div><br><br>  This method has its own characteristics: <br><ul><li>  It does not require resources for explicit initialization. </li><li>  Objects are prepared explicitly (recompiling the code is not enough) </li><li>  Objects during preparation must be on stage </li><li>  Preparation does not affect the prefabs in the project (unless you save them explicitly from the scene) and objects in other scenes. </li></ul><br><br>  It is possible that the current restrictions can be removed in the future. <br><br><div class="spoiler">  <b class="spoiler_title">Bonus for reading</b> <div class="spoiler_text"><h2>  Features of getting the missing components </h2><br><br>  An interesting feature was that trying to get the missing component takes more time than getting an existing one.  At the same time, there is a noticeable anomaly in the editor, which made me think of testing this behavior.  So never rely on profiling results in the editor. <br><img src="https://habrastorage.org/getpro/habr/post_images/32a/775/e1a/32a775e1ad7f73c0315b80c042cf9424.png" alt="image"><br>  <a href="https://docs.google.com/spreadsheets/d/1OPSe_wu4acAoLY87XD_aNHQFiTYeV9YaJmD34aEQ-DA/pubchart%3Foid%3D1675523749%26format%3Dinteractive">Interactive option</a> <br></div></div><br><br><h1>  Conclusion </h1><br><br>  In this article, you saw the evaluation of various component caching methods, and also learned about one of the useful uses of attributes.  Methods based on reflection, in principle, can be used when creating projects on Unity3D, given its features.  One of them allows you to write less of the same type of code, but a little less productive than the solution "in the forehead".  The second at the moment requires a little more attention, but does not affect the final performance. <br><br>  The project with the source scripts for the test and the proof-of-concept cache using attributes is available on <a href="https://github.com/KonH/UnityCache">GitHub</a> (a separate package with the final version is <a href="https://github.com/KonH/UnityCache/raw/master/Assets/unity-cache-0.32.unitypackage">here</a> ).  You may have suggestions for improvement. <br><br>  Thank you for your attention, I hope for useful comments.  Surely this question was considered by many and you have something to say about this. <br><br>  <b>UPDATE</b> <br>  In the latest available version (0.32) 2 new features have been added: <br><ol><li>  Separate <a href="">class</a> for caching property () </li><li>  When using the "in the editor" mode, before assembling the scene, the necessary components will be cached and a warning will be displayed if something has not been cached in advance using the menu item (unfortunately, you cannot save the scene in OnPostProcessScene). </li></ol></div><p>Source: <a href="https://habr.com/ru/post/303562/">https://habr.com/ru/post/303562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303546/index.html">How to distinguish a trademark from a trademark</a></li>
<li><a href="../303548/index.html">SEM-startups and realities of the crisis</a></li>
<li><a href="../303552/index.html">Unraveling the story of Ada Lovelace (the first programmer in history)</a></li>
<li><a href="../303554/index.html">VIM: why, if there is an IDE, and how?</a></li>
<li><a href="../303560/index.html">Money does not smell: the scandalously bankrupt edition of Gawker begin to pull apart in parts</a></li>
<li><a href="../303566/index.html">When software communicates with us, should they be friendly</a></li>
<li><a href="../303572/index.html">We write an extension for PHP (7.0.7) without knowledge of C / C ++ and how it works in general</a></li>
<li><a href="../303574/index.html">Implementing demons on Node.js</a></li>
<li><a href="../303576/index.html">Unique data center Finger Lakes Technologies Group inside the nuclear storage</a></li>
<li><a href="../303578/index.html">Creating a blog on symfony 2.8 lts [Part 6]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>