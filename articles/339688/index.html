<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developer Tacts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you have experience creating software and you want to get acquainted with the design of digital logic circuits (digital design), then one of the fi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developer Tacts</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/59/dd/df/59dddf8b1e03e594224568.jpeg"></p><br><p> If you have experience creating software and you want to get acquainted with the design of digital logic circuits (digital design), then one of the first things you need to understand is the concept of ticks.  It annoys many software engineers who are starting <a href="https://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BE%25D0%25BF%25D0%25B8%25D1%2581%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B0%25D0%25BF%25D0%25BF%25D0%25B0%25D1%2580%25D0%25B0%25D1%2582%25D1%2583%25D1%2580%25D1%258B">HDL</a> design.  Without ticks, they can turn HDL into a programming language with <code>$display</code> , <code>if</code> and <code>for</code> loops, as in any other language.  But at the same time, the cycles that beginners ignore are often one of the fundamental elements in the design of any digital logic circuits. </p><br><p>  This problem manifests itself most clearly when considering the first schemes created by novice HDL developers.  I recently spoke with some of them.  Newbies have posted their questions on the forums I read.  When I analyzed what they were doing, the hair stood on end from what he saw. </p><a name="habracut"></a><br><p>  For example, one of the students asked to explain why no one in the network was interested in his HDL implementation of <a href="https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> .  I will not embarrass him, give a link to the project or the name of its creator.  Instead, I will call him a <em>student</em> .  (No, <a href="https://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">I'm not a professor</a> .) So, this student created <a href="https://ru.wikipedia.org/wiki/Verilog">Verilog, a</a> scheme in which AES encryption is performed for more than one round, but <strong>each round, with combinatorial logic without clock cycles</strong> .  I do not remember which AES he applied, 128, 192 or 256, but AES requires 10 to 14 rounds.  In the simulator, his encryption engine worked perfectly, while he only used one clock to encrypt / decrypt his data.  The student was proud of his work, but he could not understand why those who watched it told him that he was thinking like a software engineer, not a hardware engineer. </p><br><p>  Figure 1. Software sequentially </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/436/cce/1f2/436cce1f2043dea61471a03671590c4c.svg"></div><br><p>  Now I have the opportunity to advise software engineers like that student.  Many of them treat HDL as another language for <strong>writing applications</strong> .  Having a programming experience, they take the basics from any software programming language ‚Äî how to declare variables, how to make an ‚Äúif‚Äù expression, a choice statement, how to write loops, etc. ‚Äî and then write the code as a computer program in which everything is executed sequentially while completely ignoring the realities of designing digital logic circuits, where everything happens in parallel. </p><br><p>  Sometimes these programmers find a simulator like <a href="https://www.veripool.org/wiki/verilator">Verilator</a> , <a href="http://iverilog.icarus.com/">iverilog</a> or <a href="https://www.edaplayground.com/">EDA playground</a> .  Then they use a bunch of <code>$display</code> commands in their logic, treating them as if they were serial <code>printf</code> , forcing the code to work <strong>without using ticks</strong> .  Then their schemes "work" in the simulator using only combinatorial logic. </p><br><p>  And then these students describe their schemes to me and explain that they are ‚Äúwithout measures.‚Äù </p><br><p>  You know what? </p><br><p>  The fact is that no digital logic circuit can work ‚Äúwithout clock cycles‚Äù.  There are always physical processes that create input data.  All these data must be valid at the start - at the moment that forms the first "tick" of the clock generator in the circuit.  Similarly, some time later, from the input data you need to get the output.  The moment when all the output data is valid for a given set of input data forms the next ‚Äútick‚Äù in the ‚Äútactless‚Äù scheme.  Perhaps the first ‚Äútick‚Äù is when the last switch on the board is configured, and the last ‚Äútick‚Äù is when the eyes read the result.  It doesn‚Äôt matter: tact exists. </p><br><p>  As a result, if someone claims that there are ‚Äúno ticks‚Äù in his scheme, then this means that either he uses a simulator in some unnatural way, or his scheme has some kind of external clock that defines the input data and reads the output - and then it turns out that in fact there are bars. </p><br><p>  If you are trying to understand the need for clockwork when working on a digital logic circuit, or if you know someone who puzzles over this concept, then this article is for you. </p><br><p>  Let's discuss the tact and the importance of building and designing your logic around it for now. </p><br><h2 id="urok--1-apparatnaya-arhitektura--eto-parallelnaya-arhitektura">  Lesson # 1: Hardware architecture is a parallel architecture. </h2><br><p>  The first and probably the most difficult part of studying hardware design is to realize that the entire hardware architecture is parallel.  Nothing is performed sequentially, as one instruction after another (see Figure 1) on a computer.  In fact, everything happens at once, as in Figure 2. </p><br><p>  Figure 2. Hardware logic running in parallel </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/753/160/7d0/7531607d0fb4bebfbdf45b83874255b2.svg"></div><br><p>  It changes a <strong>lot</strong> . </p><br><p>  Figure 3. Program Cycle </p><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e5/a72/10e/3e5a7210e707aff48c96292204c1eba6.svg"></div><br><p>  The first thing that needs to change is the developer himself.  <a href="http://zipcpu.com/blog/2017/08/21/rules-for-newbies.html">Learn to think in parallel</a> . </p><br><p>  A good example illustrating this difference is the hardware cycle. </p><br><p>  In software, a cycle consists of a series of instructions, as in Figure 3. They create a set of initial conditions.  Then logic is applied in the loop.  To define this logic, a loop variable is used, which is often incremented.  Until this variable reaches the interrupt state, the processor will cycle through instructions and logic.  The more times the loop is run, the longer the program runs. </p><br><p>  HDL-based hardware cycles do not work at all.  The synthesis tool (synthesis tool) HDL uses a description of the cycle to create multiple copies of logic, all of which are executed in parallel.  There is no need to synthesize the logic used to create the loop ‚Äî for example, the index, incrementing this index, comparing the index with the final state, etc. ‚Äî so it is usually removed.  Moreover, since the synthesis tool creates physical connections and logical blocks, the number of loop passes cannot be changed after the completion of the synthesis. </p><br><p>  The resulting structure is shown in Figure 4. It is <strong>very</strong> different from the structure of the program cycle in Figure 3. </p><br><p>  Figure 4. HDL-generated cycle </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/db/85/59db8555e8dae393735246.jpeg"></div><br><p>  From this there are a number of consequences.  For example, loop iterations do not necessarily depend on the output of previous iterations, as in software.  As a result, it is difficult to drive a cycle of logic on all the data in the set, getting the answer in the next clock cycle. </p><br><p>  But ... now we are back to the concept of a cycle. </p><br><p>  The loop is the basis of any <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D1%2583%25D0%25B5%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BC_%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0">FPGA</a> scheme.  Everything revolves around him.  All development of your logic should <strong>begin</strong> with tact.  This is not a minor thing, tact primarily forms the structure of your thinking about the design of digital logic circuits. </p><br><h2 id="pochemu-vazhen-takt">  Why tact is important </h2><br><p>  First you need to understand that all operations that you design in a digital logic circuit are performed by the hardware for some time.  Moreover, different operations last in different ways.  The transition from one edge of the chip to the other takes time. </p><br><p>  This thought is depicted on the graph.  Let's put the input data for our algorithm on top, the logic in the middle, and the output data at the bottom.  The time axis is postponed from top to bottom, from one measure to another. </p><br><p>  Figure 5. Logic execution takes time, three operations </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/db/85/59db8555efb60660252874.jpeg"></div><br><p>  Figure 5 shows several operations (addition, multiplication) and several rounds of using AES, although for our example these could be rounds of any other algorithm.  The vertical size of the blocks characterizes the duration of each operation.  In addition, operations that depend on other operations follow each other.  That is, if you want to perform many rounds of AES use within a tact, then keep in mind that the second round will not start until the first round is completed.  Therefore, the introduction of such logic will increase the duration between tick ticks and slow down the total clock frequency. </p><br><p>  Look at the pink blocks. </p><br><p>  They reflect the loss of activity of your hardware circuit (hardware circuit) - the time that could be spent on performing some operations.  But since you decide to wait for the end of a clock or wait to process the input data first, you cannot do anything.  For example, on this graph, multiplication lasts no more than one round of AES, as well as addition.  However, you cannot do anything with the results of these two operations while AES calculations are being performed, because you need to wait for the next clock cycle to get their next input.  That is, pink blocks are idle time of the electronic circuit.  And in this case, it is increased due to the fact that the AES rounds postpone the next beat.  So this scheme will not be able to use all the capabilities of the equipment. </p><br><p>  If we only needed an AES application pipeline, so that one round could be computed in each cycle, then the scheme could work faster, spending less time waiting. </p><br><p>  Figure 6. Splitting operations to speed clocks </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/db/85/59db85563419b752336145.jpeg"></div><br><p>  After splitting the operation into smaller operations, each of which can be performed between tick ticks, the loss of activity is greatly reduced.  And instead of encrypting only one block of data at a time, we can turn the encryption algorithm into a pipeline.  The resulting logic will not encrypt a single block faster than in Figure 5, but if you keep the pipeline full, this will increase the AES encryption speed by 10-14 times. </p><br><p>  This is a consequence of better architecture. </p><br><p>  Is it possible to do even better?  Yes!  If you are familiar with AES, then you know that each round consists of discrete steps.  They can also be scattered, even more increasing the speed of the tact, until the execution of the AES-round logic takes less time than the multiplication.  This will increase the number of additions and multiplications that you can perform, so decomposing the encryption engine into microconveyors will allow even more data to pass per cycle. </p><br><p>  Not bad. </p><br><p>  Figure 6 also shows a couple of other things. </p><br><p>  First, we will consider the arrows as delays in routing (routing delays).  The graph is not large, it is just an illustration for an abstract discussion.  Each part of the logic should receive the result of the previous part of the logic.  This means that even if some part of the logic does not take time to execute - as if the order of the wires just changed - then switching the logic from one end of the chip to the other will still take time.  Therefore, even if you simplify your operations as much as possible, there will still be delays in moving data. </p><br><p>  Secondly, you may have noticed that no arrow starts from the beginning of the measure.  And no one comes to the next measure.  This is done to illustrate the concept of setup and hold timing.  <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8%25D0%25B3%25D0%25B3%25D0%25B5%25D1%2580">Triggers</a> are structures that hold and synchronize your data in tact.  They need time before the start of the cycle, so that the data become permanent and defined.  Although many believe that the beat begins instantly, in fact it is not.  In different parts of the chip, it starts at different times.  And this also requires a buffer between operations. </p><br><p>  What conclusions can be drawn from this lesson? </p><br><ol><li>  Performing logic takes time. </li><li>  The more logic, the more time is needed. </li><li>  The speed of a clock is limited by the amount of time it takes to execute the logic between clock ticks (plus routing delays, setup and hold times, uncertainty at the start of a clock, etc.). <br>  The more logic in the clock, the lower the clock frequency. </li><li>  The speed of the fastest operation will be limited by the speed of the tact needed to perform the slowest operation. <br>  For example, the above addition operation.  She could have done faster than multiplication and any single round of AES, but she had to wait for the rest of the logic in the scheme to be executed. </li><li>  There is a hardware clock speed limit.  It takes some time even for operations that do not require logic. </li></ol><br><p>  It turns out that with a balanced architecture, a more or less equal amount of logic needs to be located in cycles throughout the entire circuit. </p><br><h2 id="skolko-logiki-pomeschat-v-taktah">  How much logic to put in cycles? </h2><br><p>  Now you know that you need to work with bars.  How do you modify or build your circuit in the light of this information?  The correct answer is: you limit the amount of logic in clock cycles.  But how much to limit and how to understand it? </p><br><p>  One way to determine the optimal amount of logic in a clock is to set an average of the speed of the clock, and then build a circuit using a set of tools that your hardware understands.  Every time the circuit does not meet the timing requirements, you will have to go back and break the circuit components or slow down the clock frequency.  You need to be able to use your design tools to find the longest path. </p><br><p>  Having done this, you will learn a number of heuristic rules, which you will then use to calculate the amount of logic in ticks applied to the equipment with which you work. </p><br><p>  For example, I want to build a circuit with a clock frequency of 100 MHz with details of the Xilinx 7 series. These circuits then usually operate at 80 MHz and on Spartan-6 or 50 MHz and on iCE40 - although these are not strict combinations.  On one chip, it will go fine, the other chip will turn out to be excessively powerful, on the third there will be problems with the timing check. </p><br><p>  Here are some sample heuristic rules related to clocks.  Since this is a heuristic, it is hardly applicable for all types of schemes: </p><br><p>  <strong>1</strong> .  Usually, I can perform a 32-bit addition with multiplexing 4‚Äì8 elements within a clock cycle. </p><br><p>  If you use faster clocks, for example 200 MHz, then you may need to separate the addition from the multiplexer.  The longest <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> path begins with the <a href="http://zipcpu.com/zipcpu/2017/08/11/simple-alu.html">ALU</a> output and ends with the ALU input.  It sounds easy.  Even corresponds to the above described heuristics.  The problem that <a href="https://github.com/ZipCPU/zipcpu">ZipCPU</a> is struggling <a href="https://github.com/ZipCPU/zipcpu">with</a> at higher speeds is to route the output back to the ALU. </p><br><p>  Let's take a look at the route: after ALU, the logical path first goes through a four-way multiplexer to decide which output to write back ‚Äî from the ALU, the <a href="">memory,</a> or the <a href="">division</a> operation.  The recorded result is then transferred to the bypass circuit to determine if it should be immediately transferred to the ALU as one of the two inputs.  Only at the end of this multiplexer and traversal is the ALU operation and multiplexer finally performed.  That is, at each stage a logical path can pass through the ALU.  But thanks to the ZipCPU design, any clocks inserted in the logical path will proportionally slow down the execution of the ZipCPU.  This means that the longest path will most certainly remain the longest ZipCPU path for a while. </p><br><p>  If I was interested in running ZipCPU at a higher speed, then this would be the first logical path that I would try to break and optimize. </p><br><p>  <strong>2.</strong> 16 √ó 16-bit multiplication takes only one clock.  Sometimes on some hardware I can implement 32 √ó 32-bit multiplications in one clock cycle.  And on the other equipment will have to break into pieces.  So if I ever need a signed (signed) 32 √ó 32-bit multiplication, I will use the <a href="">pipelined routine</a> I have done for such cases.  It contains several multiplication options, which allows me to choose the appropriate options for the current equipment. </p><br><p>  Your hardware may also initially support 18 √ó 18-bit multiplications.  Some FPGAs support multiplication and accumulation within one optimized hardware clock cycle.  Examine your equipment to find out what features are available to you. </p><br><p>  <strong>3.</strong> Any block access to RAM (block RAM access) takes one clock cycle.  Try not to tweak the index during this tact.  Also avoid any output operations at this time. </p><br><p>  Although I argue that this is a good rule, I had to successfully break both its parts without (serious) consequences when operating at 100 MHz on the Xilinx 7 device (iCE40 has this problem). </p><br><p>  For example, ZipCPU reads from its registers, adds an immediate operand to the result, and then selects whether the result should be a register plus a constant, PC plus a constant, or a condition code register plus a constant ‚Äî all in one measure. </p><br><p>  Another example: for a long time, <a href="https://github.com/ZipCPU/wbscope">Wishbone Scope</a> determined the address to read from its buffer based on whether it was reading from memory during the current clock cycle.  Breaking this dependency required adding one more clock cycle, so the <a href="">current version</a> no longer violates this rule. </p><br><p>  These rules are nothing more than heuristics, which I use to determine how much logic fits in tacts.  It depends on the equipment and the speed of the clock, so you may not be suitable.  I recommend to develop their heuristics. </p><br><h2 id="sleduyuschie-shagi">  Next steps </h2><br><p>  Perhaps the best advice that I can give to FPGA beginner developers in the end is to study HDL, while practicing in parallel on real equipment, and not on simulators alone.  Tools related to real hardware components will allow you to check the code and the necessary timings.  In addition, it is good to develop circuits for fast clocks, but in the hardware design this world has not come together with a wedge. </p><br><p>  Remember, hardware architecture is parallel in nature.  It all starts with tact. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339688/">https://habr.com/ru/post/339688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339676/index.html">Proxmox 4. Day Two. Thin-LVM</a></li>
<li><a href="../339678/index.html">Simple Python Scada (continued)</a></li>
<li><a href="../339680/index.html">Startup of the day (August and September 2017)</a></li>
<li><a href="../339682/index.html">How to get alerts from Jupyter notebook in Telegram?</a></li>
<li><a href="../339684/index.html">Spark - A stunning web microframe for Java</a></li>
<li><a href="../339690/index.html">Cocos2d-x - Working with sprites</a></li>
<li><a href="../339692/index.html">How to successfully implement the Help Desk? 12 examples (part 2)</a></li>
<li><a href="../339694/index.html">New 3CX Call Flow Designer: Complicated Call Routing Without Programming</a></li>
<li><a href="../339696/index.html">Knowledge sharing and copyright management platform. Look at the state order?</a></li>
<li><a href="../339698/index.html">Hello World's thorny path</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>