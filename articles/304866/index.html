<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing reactivity - how to write unit tests for RxSwift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, I talked about how to create a simple reactive application for iOS using the RxSwift framework. In one of the comments there was ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing reactivity - how to write unit tests for RxSwift</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="https://habrahabr.ru/post/276971/">last article,</a> I talked about how to create a simple reactive application for iOS using the <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> framework.  In one of the comments there was a request to tell about writing unit tests for a reactive code.  I promised to write about it after a couple of other articles about RxSwift.  But they were ahead of me - what I was going to write about was perfectly disclosed in <a href="https://habrahabr.ru/post/283128/">this</a> and <a href="https://habrahabr.ru/post/281292/">this</a> article.  I personally want to thank the author for his titanic work - these two articles are firmly established in my favorites and help me in my work. <br><br>  Well, we will start writing tests! <br><a name="habracut"></a><br><h4>  Adding functionality </h4><br>  Before we start writing tests, let's torture Facebook a bit more and write the post creation function on our wall.  To do this, we first need to add the <i>publish_actions</i> permission for the login button in LoginViewController.viewDidLoad (): <br><pre><code class="objectivec hljs">loginButton.publishPermissions = [<span class="hljs-string"><span class="hljs-string">"publish_actions"</span></span>]</code> </pre> <br>  After that, we will write a request to create a post in the APIManager file: <br><pre> <code class="objectivec hljs">func addFeed(feedMessage: String) -&gt; Observable&lt;Any&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.create { observer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let parameters = [<span class="hljs-string"><span class="hljs-string">"message"</span></span>: feedMessage] let addFeedRequest = FBSDKGraphRequest.init(graphPath: <span class="hljs-string"><span class="hljs-string">"me/feed"</span></span>, parameters: parameters, HTTPMethod: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>) addFeedRequest.startWithCompletionHandler { (connection, result, error) -&gt; Void <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { observer.on(.Error(error!)) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { observer.on(.Next(result)) observer.on(.Completed) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AnonymousDisposable { } } }</code> </pre><br><br>  Next, create a new screen with two elements - a UITextView for entering a message and a UIButton for sending a message.  I will not describe this part, everything is fairly standard, who has difficulties - at the end of this article you can find a link to Github and see my implementation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now we need to make the ViewModel for the new screen: <br><div class="spoiler">  <b class="spoiler_title">Implementing AddPostViewModel</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AddPostViewModel { let validatedText: Observable&lt;Bool&gt; let sendEnabled: Observable&lt;Bool&gt; <span class="hljs-comment"><span class="hljs-comment">// If some process in progress let indicator: Observable&lt;Bool&gt; // Has feed send in let sendedIn: Observable&lt;Any&gt; init(input: ( feedText: Observable&lt;String&gt;, sendButton: Observable&lt;Void&gt; ), dependency: ( API: APIManager, wireframe: Wireframe ) ) { let API = dependency.API let wireframe = dependency.wireframe let indicator = ViewIndicator() self.indicator = indicator.asObservable() validatedText = input.feedText .map { text in return text.characters.count &gt; 0 } .shareReplay(1) sendedIn = input.sendButton.withLatestFrom(input.feedText) .flatMap { feedText -&gt; Observable&lt;Any&gt; in return API.addFeed(feedText).trackView(indicator) } .catchError { error in return wireframe.promptFor((error as NSError).localizedDescription, cancelAction: "OK", actions: []) .map { _ in return error } .flatMap { error -&gt; Observable&lt;Any&gt; in return Observable.error(error) } } .retry() .shareReplay(1) sendEnabled = Observable.combineLatest( validatedText, indicator.asObservable() ) { text, sendingIn in text &amp;&amp; !sendingIn } .distinctUntilChanged() .shareReplay(1) } }</span></span></code> </pre><br></div></div><br>  Let's look at the input block, at the input we submit feedText (the text of our news) and sendButton (event of pressing the button).  In the class variables, we have validatedText (to check that the text field is not empty), sendEnabled (to check that the post sending button is available) and sendedIn (to fulfill the request to send the post).  Let's take a closer look at the validatedText variable: <br><pre> <code class="objectivec hljs">validatedText = input.feedText .map { text <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.characters.count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> } .shareReplay(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  It's all quite simple - we take the text that we submitted to the input, and check the number of characters in it.  If there are characters, then true is returned; otherwise, false.  Now consider the sendEnabled variable: <br><pre> <code class="objectivec hljs">sendEnabled = Observable.combineLatest( validatedText, indicator.asObservable() ) { text, sendingIn <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> text &amp;&amp; !sendingIn } .distinctUntilChanged() .shareReplay(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Here, too, everything is simple.  We get the latest text status and loading indicator.  If the text is not empty and there is no loading, then true is returned, otherwise false.  It remains to deal with the sendedIn field: <br><pre> <code class="objectivec hljs">sendedIn = input.sendButton.withLatestFrom(input.feedText) .flatMap { feedText -&gt; Observable&lt;Any&gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> API.addFeed(feedText).trackView(indicator) } .catchError { error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wireframe.promptFor((error as <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>).localizedDescription, cancelAction: <span class="hljs-string"><span class="hljs-string">"OK"</span></span>, actions: []) .map { _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error } .flatMap { error -&gt; Observable&lt;Any&gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.error(error) } } .retry() .shareReplay(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  And there is nothing complicated.  We take the most recent value from input.feedText and try to fulfill the request to send the post, if we catch an error - we process it, output it to the user and retry () so that there is no disconnection from the button press event. <br><br>  Super, with ViewModel finished, go to the controller to add the post and write the following code there: <br><pre> <code class="objectivec hljs">let viewModel = AddPostViewModel( input: ( feedText: feedTextView.rx_text.asObservable(), sendButton: sendFeed.rx_tap.asObservable() ), dependency: ( API: APIManager.sharedAPI, wireframe: DefaultWireframe.sharedInstance ) ) let progress = MBProgressHUD() progress.mode = MBProgressHUDMode.Indeterminate progress.labelText = <span class="hljs-string"><span class="hljs-string">" ..."</span></span> progress.dimBackground = <span class="hljs-literal"><span class="hljs-literal">true</span></span> viewModel.indicator.asObservable() .bindTo(progress.rx_mbprogresshud_animating) .addDisposableTo(disposeBag) viewModel.sendEnabled .subscribeNext { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>] valid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>!.sendFeed.enabled = valid <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>!.sendFeed.alpha = valid ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.5</span></span> } .addDisposableTo(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.disposeBag) viewModel.sendedIn .flatMap { _ -&gt; Observable&lt;String&gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DefaultWireframe.sharedInstance.promptFor(<span class="hljs-string"><span class="hljs-string">"   !"</span></span>, cancelAction: <span class="hljs-string"><span class="hljs-string">"OK"</span></span>, actions: []) .flatMap { action -&gt; Observable&lt;Any&gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.just(action) } } .subscribeNext { action <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.navigationController?.popToRootViewControllerAnimated(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) } .addDisposableTo(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.disposeBag)</code> </pre><br>  Create an object of the AddPostViewModel class, use the sendEnabled variable to set the state button, and use the sendedIn variable to track the status of adding a post, if successful, display a window to the user about it and return to the main screen.  We check that everything works and finally go to the tests. <br><br><h4>  The concept of unit tests when using RxSwift </h4><br>  Let's start with the concept of recording events.  Let's set an array of events, like this: <br><pre> <code class="objectivec hljs">let booleans = [<span class="hljs-string"><span class="hljs-string">"f"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"t"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>]</code> </pre><br>  Now imagine this in a timeline format: <br><pre> <code class="objectivec hljs">--f-----t---</code> </pre><br>  We first called the false event in the timeline, and then the true event. <br>  Next in line is the Sheduler object.  It allows you to convert a timeline into an array of events, for example, it converts the above described timeline like this: <br><pre> <code class="objectivec hljs">[shedule onNext(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) @ <span class="hljs-number"><span class="hljs-number">0.4</span></span>s, shedule onNext(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) @ <span class="hljs-number"><span class="hljs-number">1.6</span></span>s]</code> </pre><br>  In addition, Sheduler allows you to record sequence events in the same format.  He has a number of other functions, but for testing, these two will suffice for now. <br><br>  We now turn to the concept of testing.  It consists in the following: there are events expected by us (expected), which we set initially, and there are actual events (recorded) that actually occur in the ViewModel.  First, we write the expected events to the timeline and use the Sheduler object to convert them into an array, and then we take the ViewModel under test and also use the Sheduler object to write all the events into the array. <br><br>  After that, we can compare the array of expected events with those recorded and conclude whether our ViewModel works as we expect from it or not.  Strictly speaking, we can compare not only the events, but also their number: in the source code of the project you can find the unit test for FeedsViewModel, it compares the number of clicks on the table cell. <br><br>  As my practice shows, to test business logic is enough to cover the ViewModel tests, however, this is a debatable question, and I will be happy to discuss it. <br><br><h4>  We start testing </h4><br>  First of all we will test AddPostViewModel.  First you need to configure the Podfile: <br><pre> <code class="objectivec hljs">target <span class="hljs-string"><span class="hljs-string">'ReactiveAppTests' do pod '</span></span>RxTests<span class="hljs-string"><span class="hljs-string">', '~&gt; 2.0'</span></span> pod <span class="hljs-string"><span class="hljs-string">'FBSDKLoginKit'</span></span> pod <span class="hljs-string"><span class="hljs-string">'RxCocoa'</span></span>, <span class="hljs-string"><span class="hljs-string">'~&gt; 2.0' end</span></span></code> </pre><br>  Next, run the <i>pod install</i> command, wait for everything to complete and open the workspace.  Let's do some mockups for testing.  From the RxSwift repository, we take a <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample-iOSTests/Mocks/MockWireframe.swift">mocap for testing Wireframe</a> , as well as <a href="https://github.com/ReactiveX/RxSwift/blob/master/RxExample/RxExample-iOSTests/Mocks/NotImplementedStubs.swift">NotImplementedStubs</a> .  Mocap for our API will look like this: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MockAPI : API { let _getFeeds: () -&gt; Observable&lt;GetFeedsResponse&gt; let _getFeedInfo: (String) -&gt; Observable&lt;GetFeedInfoResponse&gt; let _addFeed: (String) -&gt; Observable&lt;AnyObject&gt; init( getFeeds: () -&gt; Observable&lt;GetFeedsResponse&gt; = notImplemented(), getFeedInfo: (String) -&gt; Observable&lt;GetFeedInfoResponse&gt; = notImplemented(), addFeed: (String) -&gt; Observable&lt;Any&gt; = notImplemented() ) { _getFeeds = getFeeds _getFeedInfo = getFeedInfo _addFeed = addFeed } func getFeeds() -&gt; Observable&lt;GetFeedsResponse&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _getFeeds() } func getFeedInfo(feedId: String) -&gt; Observable&lt;GetFeedInfoResponse&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _getFeedInfo(feedId) } func addFeed(feedMessage: String) -&gt; Observable&lt;AnyObject&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _addFeed(feedMessage) } }</code> </pre><br>  Let's write a small helper extension for our test class to make it easier to create a MockAPI object: <br><pre> <code class="objectivec hljs">extension ReactiveAppTests { func mockAPI(scheduler: TestScheduler) -&gt; API { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MockAPI( getFeeds: scheduler.mock(feeds, errors: errors) { _ -&gt; String <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"--fs"</span></span> }, getFeedInfo: scheduler.mock(feedInfo, errors: errors) { _ -&gt; String <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"--fi"</span></span> }, addFeed: scheduler.mock(textValues, errors: errors) { _ -&gt; String <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"--ft"</span></span> } ) } }</code> </pre><br><br>  Now we need to create a chain of expected events (expected), i.e.  we must designate how our program will work.  To do this, we need to create a series of arrays of the form [String: YOUR_TYPE], where String is the variable name, YOUR_TYPE is the data type that will be returned when the variable is called.  For example, let's make such an array for Boolean variables: <br><pre> <code class="objectivec hljs">let booleans = [<span class="hljs-string"><span class="hljs-string">"t"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"f"</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>]</code> </pre><br>  Perhaps, it‚Äôs not very clear why all this is needed, so let's create the remaining arrays for testing and see how it works - everything will immediately become clear: <br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    let events = ["x" : ()] //    let errors = [ "#1" : NSError(domain: "Some unknown error maybe", code: -1, userInfo: nil), ] //       let textValues = [ "ft" : "feed", "e" : "" ] //   // ,      ,        :-) let feeds = [ "fs" : GetFeedsResponse() ] let feedInfo = [ "fi" : GetFeedInfoResponse() ] let feedArray = [ "fa" : [Feed]() ] let feed = [ "f" : Feed(createdTime: "1", feedId: "1") ]</span></span></code> </pre><br>  Now create a chain of expected events: <br><pre> <code class="objectivec hljs">let ( feedTextEvents, buttonTapEvents, expectedValidatedTextEvents, expectedSendFeedEnabledEvents ) = ( scheduler.parseEventsAndTimes(<span class="hljs-string"><span class="hljs-string">"e----------ft------"</span></span>, values: textValues).first!, scheduler.parseEventsAndTimes(<span class="hljs-string"><span class="hljs-string">"-----------------x-"</span></span>, values: events).first!, scheduler.parseEventsAndTimes(<span class="hljs-string"><span class="hljs-string">"f----------t-------"</span></span>, values: booleans).first!, scheduler.parseEventsAndTimes(<span class="hljs-string"><span class="hljs-string">"f----------t-------"</span></span>, values: booleans).first! )</code> </pre><br>  So let's deal with this issue.  As we can see, we have events for 4 variables - feedTextEvents, buttonTapEvents, expectedValidatedTextEvents and expectedSendFeedEnabledEvents.  The very first variable is feedTextEvents, its chain of events is scheduler.parseEventsAndTimes ("e ---------- ft ------", values: textValues) .first! .. We take events from textValues, there are only 2 variables: ‚Äúe‚Äù: "" is an empty string, "ft": ‚Äúfeed is a string with the value‚Äú feed ‚Äù.  Now let's take a look at the chain of events <i>e ---------- ft ------</i> , at first we in the chain of events trigger the event e, thereby saying that at the moment there is an empty string, and then at some point cause the event fl, that is, we say that we have written the word ‚Äúfeed‚Äù into a variable. <br><br>  Now let's look at the other variables, for example, on the expectedValidatedTextEvents.  When we have a feedTextEvents empty string, then the expectedValidatedTextEvents should be false.  We look at our boolean array and see that f is false, so when we call event <i>e</i> for feedTextEvents, we need to call event <i>f</i> for the expectedValidatedTextEvents.  As soon as the ft event occurred for the feedTextEvents variable, that is, the text in the text field was not empty, then the t event should occur - true for expectedValidatedTextEvents. <br><br>  It is the same with expectedSendFeedEnabledEvents - as soon as the text field becomes non-empty, the button becomes enabled and we need to trigger the t event - true for it.  Well, for the buttonTapEvents variable, we trigger a button click event after the button has become available. <br><br>  This is the key point of unit testing for RxSwift - to understand how to create chains of events and learn how to position them so that they are called at the right moment.  for example, if you try for the variable expectedValidatedTextEvents to raise the t event - true before the ft event for the variable feedTextEvents occurs, the tests will fail because the expectedValidatedTextEvents event cannot occur with an empty string.  In general, I advise you to play around with chains of events in order to understand what's what, and now let's add the code: <br><pre> <code class="objectivec hljs">let wireframe = MockWireframe() let viewModel = AddPostViewModel( input: ( feedText: scheduler.createHotObservable(feedTextEvents).asObservable(), sendButton: scheduler.createHotObservable(buttonTapEvents).asObservable() ), dependency: ( API: mock, wireframe: wireframe ) ) <span class="hljs-comment"><span class="hljs-comment">// run experiment let recordedSendFeedEnabled = scheduler.record(viewModel.sendEnabled) let recordedValidatedTextEvents = scheduler.record(viewModel.validatedText) scheduler.start() // validate XCTAssertEqual(recordedValidatedTextEvents.events, expectedValidatedTextEvents) XCTAssertEqual(recordedSendFeedEnabled.events, expectedSendFeedEnabledEvents)</span></span></code> </pre><br><br>  We run tests and experience this pleasant sensation from the fact that they are green :-) By the same principle, I wrote a unit test for FeedsViewModel, you can find it in the <a href="https://github.com/svyatoslav-reshetnikov/ReactiveApp-UnitTests">repo project</a> .  I have everything on it, I will be happy with comments / suggestions / wishes, thank you for your attention! </div><p>Source: <a href="https://habr.com/ru/post/304866/">https://habr.com/ru/post/304866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304842/index.html">Critical vulnerability allows to intercept all network traffic of users of Windows</a></li>
<li><a href="../304844/index.html">Main trends in the development of the payment systems market</a></li>
<li><a href="../304848/index.html">Welcome to Odessa at WebCamp 2016! Sea, relaxation and favorite technologies</a></li>
<li><a href="../304850/index.html">Basics of game design: 20 board games. Part Three: Pente, Colonialists, Puerto Rico</a></li>
<li><a href="../304856/index.html">JavaFX visual creation of a simple application and native packaging in Eclipse</a></li>
<li><a href="../304868/index.html">Windows PC as an ARP flood generator</a></li>
<li><a href="../304870/index.html">What the developer needs to know about application localization</a></li>
<li><a href="../304888/index.html">TDD for Oracle stored procedures</a></li>
<li><a href="../304904/index.html">Purchase history of a single ticket on the Russian Railways website</a></li>
<li><a href="../304906/index.html">Applications for the VIII Summer School of High-Performance Computing in the Field of Computer Vision have been opened</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>