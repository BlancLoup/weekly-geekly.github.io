<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flutter. Keys! What are they for?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The key parameter can be found in almost every constructor of the widget, but they are rarely used during development. Keys retain state when moving w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flutter. Keys! What are they for?</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/bd/bp/o2/bdbpo2nvc1jntzhrnowfckpywh0.jpeg"></p><br><p> The <code>key</code> parameter can be found in almost every constructor of the widget, but they are rarely used during development.  <code>Keys</code> retain state when moving widgets in a tree of widgets.  In practice, this means that they can be useful for saving the user's scrolling location or saving state when the collection changes. </p><br><p>  This article is adapted from the following <a href="https://youtu.be/kn0EOS-ZiIc">video</a> .  If you prefer to listen / watch rather than read, the video will provide you with the same material. </p><a name="habracut"></a><br><h2 id="sekretnaya-informaciya-o-keys">  Secret information about the <code>keys</code> </h2><br><p>  Most of the time ... <code>keys</code> you don't need.  In general, there is no harm in adding them, but this is also not necessary, since they simply take up space as a new keyword or type declaration on both sides of a new variable (I‚Äôm on you, <code>Map&lt;Foo, Bar&gt; aMap = Map&lt;Foo, Bar&gt;()</code> ). </p><br><blockquote>  But if you find that you add, delete or rearrange widgets in the collection that contain some state and have one type, then you should pay attention to the <code>keys</code> ! </blockquote><p>  To demonstrate why you need <code>keys</code> when changing a collection of widgets, I wrote an extremely simple application with two multi-colored widgets that change places when you press a button: </p><br><p><img src="https://habrastorage.org/webt/n3/qy/l1/n3qyl1ute2ckxrbmjoasonmttra.gif"></p><br><p>  In this version of the application, I have two random stateless state widgets ( <code>StatelessWidget</code> ) in <code>Row</code> and a stateful PositionedTiles widget with state ( <code>StatefulWidget</code> ) to store the order of color widgets in it.  When I click the <code>FloatingActionButton</code> button at the bottom, the colored widgets correctly change their place in the list: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ StatelessColorfulTile(), StatelessColorfulTile(), ]; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(<span class="hljs-number"><span class="hljs-number">1</span></span>, tiles.removeAt(<span class="hljs-number"><span class="hljs-number">0</span></span>)); }); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ Color myColor = UniqueColorGenerator.getColor(); <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding(padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>))); } }</code> </pre> <br><p>  But if we add a state to our color widgets (we make them <code>StatefulWidget</code> ) and store the color in them, then when we click on the button it looks as if nothing is happening: </p><br><p><img src="https://habrastorage.org/webt/ou/xm/mh/ouxmmh4qaybwgmg3pezne9ocwwo.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(), StatefulColorfulTile(), ]; ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulColorfulTile</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">ColorfulTileState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; ColorfulTileState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTileState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColorfulTile</span></span></span><span class="hljs-class">&gt; </span></span>{ Color myColor; <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.initState(); myColor = UniqueColorGenerator.getColor(); } <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BuildContext context)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Container( color: myColor, child: Padding( padding: EdgeInsets.all(<span class="hljs-number"><span class="hljs-number">70.0</span></span>), )); } }</code> </pre> <br><p>  As an explanation: the code mentioned above is buggy in that it does not show the color exchange when the user presses the button.  To correct this error, you need to add the <code>key</code> parameter to the color <code>StatefulWidget</code> widgets, and then the widgets will switch places as we want: </p><br><p><img src="https://habrastorage.org/webt/se/zh/am/sezham9ms7u158mzemvce1wwlhu.gif"></p><br><pre> <code class="java hljs">List&lt;Widget&gt; tiles = [ StatefulColorfulTile(key: UniqueKey()), <span class="hljs-comment"><span class="hljs-comment">// Keys added here StatefulColorfulTile(key: UniqueKey()), ]; ... class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); // NEW CONSTRUCTOR @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  But this is only necessary if you have widgets with a state in the subtree that you are changing.  If the entire subtree of the widget in your collection has no status, the keys are not needed. <br>  Like this!  In general, all you need to know to use the <code>keys</code> in <code>Flutter</code> .  But if you want to go deep into what is happening ... </p><br><hr><br><h2 id="razbiraemsya-pochemu-keys-inogda-neobhodimy">  Understand why <code>keys</code> sometimes needed </h2><br><p>  Are you still here, huh?  Well, then come closer to find out the true nature of the element trees and widgets, to become the Flutter Magician!  Uhahaha!  Haha  Haha  Um, sorry. </p><br><p>  As you know, inside for each widget Flutter builds the corresponding element.  Just as Flutter builds a tree of widgets, it also creates a tree of elements (ElementTree).  ElementTree is extremely simple, it contains only information about the type of each widget and a link to its children.  You can think of thinking of ElementTree as the skeleton of your Flutter application.  It shows the structure of your application, but all additional information can be viewed at the link to the source widget. </p><br><p>  The Row widget in the example above contains a set of ordered slots for each of its child elements.  When we change the order of the color widgets in Row, Flutter walks over the ElementTree to check if the skeleton structure of the application is the same. </p><br><p><img src="https://habrastorage.org/webt/ha/dh/vy/hadhvybi_mhjvuwdiiucmmx2w6i.gif"></p><br><p>  Validation begins with a RowElement, and then proceeds to child elements.  ElementTree verifies that the new widget has the same type and <code>key</code> as the old one, and if so, the element updates its link to the new widget.  In the stateless version of the code, widgets do not have a <code>key</code> , so Flutter simply checks only the type.  (If too much information at a time, then look at the animated diagram above.) </p><br><p>  Below the ElementTree for state widgets looks a little different.  There are widgets and elements as before, but there are also a couple of state objects for the widgets, and the color information is stored in them, not in the widgets themselves. </p><br><p><img src="https://habrastorage.org/webt/dh/ay/sh/dhayshomjpkfv7b45fxmx1ecduw.gif"></p><br><p>  In the case of <code>StatefulWidget</code> color widgets without a <code>key</code> , when I change the order of two widgets, Flutter walks over an ElementTree, checks the type of RowWidget, and updates the link.  Then the color widget element checks that the corresponding widget is of the same type and updates the link.  The same thing happens with the second widget.  Since Flutter uses the ElementTree and its corresponding state to determine what is actually displayed on your device, from our point of view, it seems that the widgets have not been swapped! </p><br><p><img src="https://habrastorage.org/webt/nu/yw/ah/nuywahtbnrv2bfvrwb0osfj1fye.gif"></p><br><p>  In the revised version of the code in color widgets with the state in the constructor, I defined the <code>key</code> property.  Now, if we change the widgets in <code>Row</code> , then by type they will match as before, but the <code>key</code> values ‚Äã‚Äãof the color widget and the corresponding element in the ElementTree will be different.  This causes Flutter to deactivate these elements of the color widgets and remove references to them in the ElementTree, starting with the first one that does not have a <code>key</code> . </p><br><p><img src="https://habrastorage.org/webt/iz/vw/os/izvwos_wwqsng-afywi2az2shsu.gif"></p><br><p>  Then Flutter searches for the child widgets in the <code>Row</code> element in the ElementTree with the corresponding <code>key</code> .  When matched, adds a link to the item on the widget.  Flutter makes for each child element without a link.  Now Flutter will display what we expect, color widgets are swapped when I press the button. </p><br><p>  Thus, <code>keys</code> are useful if you change the order or number of widgets with the state in the collection.  In this example, I saved the color.  However, often the condition is not so obvious.  Playing animation, displaying user input, and scrolling a location ‚Äî everything has a state. </p><br><hr><br><h2 id="kogda-mne-ispolzovat-keys">  When should I use <code>keys</code> ? </h2><br><p>  The short answer is: if you need to add <code>keys</code> to the application, you should add them at the top of the subtree of the widgets with the state you want to save. </p><br><p>  A common mistake I‚Äôve seen is that people think that they only need to define a <code>key</code> for the first widget with a state, but there are nuances.  Do not believe me?  To show what trouble we could get into, I wrapped my color widgets in the <code>Padding</code> widgets, while leaving the keys for the color widgets. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Stateful tiles now wrapped in padding (a stateless widget) to increase height // of widget tree and show why keys are needed at the Padding level. List&lt;Widget&gt; tiles = [ Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), Padding( padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(key: UniqueKey()), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Now, by pressing the button, widgets get completely random colors! </p><br><p><img src="https://habrastorage.org/webt/w2/ge/lb/w2gelbrnaw_hlvftimjhe-vhhim.gif"></p><br><p>  This is how the tree of widgets and ElementTree looks like with <code>Padding</code> widgets added: </p><br><p><img src="https://habrastorage.org/webt/k-/br/0o/k-br0o5hmbvzwvjodwemswze0na.jpeg"></p><br><p>  When we change the positions of child widgets, the algorithm for finding the correspondence between elements and widgets looks at one level in the element tree.  In the diagram, the child elements of the child elements are darkened so that nothing distracts from the first level.  At this level, everything matches correctly. </p><br><p><img src="https://habrastorage.org/webt/j6/tt/zp/j6ttzpgzdbpupkzqw4s1vlsyz6g.gif"></p><br><p>  At the second level, Flutter notices that the <code>key</code> color element does not match the <code>key</code> widget, so he deactivates this element, discarding all references to it.  <code>keys</code> we use in this example are <code>LocalKeys</code> .  This means that when matching a widget with elements, Flutter only searches for <code>keys</code> at a particular tree level. </p><br><p>  Since it cannot find the element of the color widget at this level with the corresponding <code>key</code> , it creates a new one and initializes the new state, making the widget orange in this case! </p><br><p><img src="https://habrastorage.org/webt/2q/mn/xk/2qmnxkwb7xpxtyi3jgbefvg70mi.gif"></p><br><p>  If we define <code>keys</code> for <code>Padding</code> widgets: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; runApp(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MaterialApp(home: PositionedTiles())); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatefulWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@override</span></span> <span class="hljs-function"><span class="hljs-function">State&lt;StatefulWidget&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>=&gt; PositionedTilesState(); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTilesState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionedTiles</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Widget&gt; tiles = [ Padding( <span class="hljs-comment"><span class="hljs-comment">// Place the keys at the *top* of the tree of the items in the collection. key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), Padding( key: UniqueKey(), padding: const EdgeInsets.all(8.0), child: StatefulColorfulTile(), ), ]; @override Widget build(BuildContext context) { return Scaffold( body: Row(children: tiles), floatingActionButton: FloatingActionButton( child: Icon(Icons.sentiment_very_satisfied), onPressed: swapTiles), ); } swapTiles() { setState(() { tiles.insert(1, tiles.removeAt(0)); }); } } class StatefulColorfulTile extends StatefulWidget { StatefulColorfulTile({Key key}) : super(key: key); @override ColorfulTileState createState() =&gt; ColorfulTileState(); } class ColorfulTileState extends State&lt;ColorfulTile&gt; { Color myColor; @override void initState() { super.initState(); myColor = UniqueColorGenerator.getColor(); } @override Widget build(BuildContext context) { return Container( color: myColor, child: Padding( padding: EdgeInsets.all(70.0), )); } }</span></span></code> </pre> <br><p>  Flutter notices the problem and updates the links correctly, as was the case in our previous example.  The order in the universe is restored. </p><br><p><img src="https://habrastorage.org/webt/xp/4w/h0/xp4wh0wpzgd-5wxtxdkwu3jogps.gif"></p><br><hr><br><h2 id="kakoy-tip-key-mne-sleduet-ispolzovat">  What type of <code>Key</code> should i use? </h2><br><p>  Flutter APIs gave us a choice of several <code>Key</code> classes.  The type of <code>key</code> that you must use depends on what is the distinguishing characteristic of the elements that need <code>keys</code> .  Look at the information that you store in the appropriate widgets. </p><br><p>  Consider the following To-do application [1], where you can change the order of items in the task list based on priority, and when you're done, you can delete them. </p><br><p><img src="https://habrastorage.org/webt/nz/qb/8g/nzqb8g-8ywgycp0g_xe-6p7-xk0.gif"></p><br><p>  <strong>Valuekey</strong> <br>  In this case, it can be expected that the text of the item to be executed will be permanent and unique.  If so, then this is probably a good candidate for <code>ValueKey</code> , where the text is ‚Äúvalue‚Äù. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TodoItem( key: ValueKey(todo.task), todo: todo, onDismissed: (direction) =&gt; _removeTodo(context, todo), );</code> </pre> <br><p>  <strong>Objectkey</strong> <br>  In another case, you may have the Address Book application, which lists information about each user.  In this case, each child widget stores a more complex combination of data.  Any of the individual fields, such as the name or birthday, may be the same as another entry, but the combination is unique.  In this case, the <code>ObjectKey</code> is most likely best suited. </p><br><p><img src="https://habrastorage.org/webt/jk/jz/av/jkjzavsw7v74t_dnnmb79mvukd0.png"></p><br><p>  <strong>UniqueKey</strong> <br>  If you have several widgets in the collection with the same value, or if you really want to make sure that each widget is different from all others, you can use <code>UniqueKey</code> .  I used <code>UniqueKey</code> in the sample application to switch colors, because we did not have other persistent data that would be stored in our widgets, and we did not know what color the widget would have when it was created. </p><br><p>  However, one thing you <strong>do not want to</strong> use as your <code>key</code> is a random number.  Every time a widget is created, a new random number will be generated and you will lose consistency between frames.  In this scenario, you may not use the <code>keys</code> at all! </p><br><p>  <strong>PageStorageKeys</strong> <br>  <code>PageStorageKeys</code> are specialized <code>keys</code> that contain the current state of the scroll so that the application can save it for later use. </p><br><p><img src="https://habrastorage.org/webt/dx/db/if/dxdbif6yn7hlszee_-hbzbaevn8.gif"></p><br><p>  <strong>Globalkeys</strong> <br>  There are two options for using <code>GlobalKeys</code> : they allow widgets to change parents anywhere in the application without losing state and can be used to access information about another widget in a completely different part of the widget tree.  As an example of the first scenario, you can imagine that you want to show the same widget on two different screens, but with the same state, so that the widget data is saved, you will use <code>GlobalKey</code> .  In the second case, a situation may arise when you need to verify the password, but you do not want to share status information with other widgets in the tree.  <code>GlobalKeys</code> can also be useful for testing, using the <code>key</code> to access a specific widget and request information about its state. </p><br><p><img src="https://habrastorage.org/webt/eh/rq/bl/ehrqble5pcoeqrh7ktl0j0_dm5s.gif"></p><br><p>  Often (but not always!) <code>GlobalKeys</code> bit like global variables.  Often, they can be replaced by the use of <code>InheritedWidgets</code> or something like Redux, or the BLoC template. </p><br><hr><br><h2 id="kratkoe-zaklyuchenie">  Brief conclusion </h2><br><p>  In general, use <code>Keys</code> if you want to keep the state between the subtrees of the widgets.  This most often occurs when changing the collection of widgets of the same type.  Place the <code>key</code> at the top of the subtree of the widgets that you want to save, and select the <code>key</code> type based on the data stored in the widget. </p><br><p>  Congratulations, you are now on your way to becoming a Flutter Magician!  Oh, I told the magician?  I meant the magician [2], as the one who writes the source code of the application ... which is almost as good.  ‚Ä¶Nearly. </p><br><p>  [1] Inspiration for writing code for to-do applications is obtained here. <br>  <a href="https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla">https://github.com/brianegan/flutter_architecture_samples/tree/master/vanilla</a> <br>  [2] The author uses the word <code>sorcerer</code> and later adds an extra letter to it to the <code>sourcerer</code> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/446050/">https://habr.com/ru/post/446050/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446042/index.html">DJI Mavic 2 Pro after half a year of use</a></li>
<li><a href="../446044/index.html">Do not be afraid to try, or How I became a programmer at an age far beyond 29</a></li>
<li><a href="../446046/index.html">Expansion of the Universe - the greatest misconception in the history of science</a></li>
<li><a href="../446048/index.html">Union Arduino and classic processor</a></li>
<li><a href="../44605/index.html">Testing in different versions of IE</a></li>
<li><a href="../446052/index.html">Creating a voice & tone for your product</a></li>
<li><a href="../446054/index.html">Backup at the ready: destroying myths in honor of the holiday</a></li>
<li><a href="../446058/index.html">How to build SDN - eight open source tools</a></li>
<li><a href="../44606/index.html">Do it yourself: Aperture photo albums</a></li>
<li><a href="../446060/index.html">Synthesis of high molecular dreams</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>