<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>View design pattern in languages ‚Äã‚Äãwith dependent types</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Design patterns! I first learned about them in the Software Design course when I was studying in the magistracy of the Academic University. We wrote v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>View design pattern in languages ‚Äã‚Äãwith dependent types</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/0e0/67b/a24/0e067ba244494c62b8f4941c4898ba60.jpg"><br><br>  Design patterns!  I first learned about them in the Software Design course when I was studying in the magistracy of the Academic University.  We wrote various Java programs using templates.  Since then, I have associated this phrase with something such OOPshny.  However, while figuring out the Agda language, I came across the article The Power Of Pi, which tells about design patterns in languages ‚Äã‚Äãwith dependent types! <br><br>  In this post I want to talk about one of these templates, which is called View.  With it, you can implement custom pattern matching'a rules.  If you are wondering what this pattern is, what is custom pattern matching, what are the features of pattern matching in languages ‚Äã‚Äãwith dependent types, and you are familiar with some functional programming language with static typing (Haskell, Scala, Ocaml, F #) - welcome under the cat! <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Views and custom pattern matching </h1><br>  To begin with, let's see what custom pattern matching is.  Suppose we work with some <i>xs</i> list and perform pattern matching on it: <br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> xs <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> [] -&gt; ... (y : ys) -&gt; ...</code> </pre> <br>  Here we look at <i>xs</i> either as an empty list or as a list consisting of a head element and a list assigned to it.  But what if we want to look at <i>xs</i> , say, as a list consisting of the concatenation of some two lists <i>ys</i> and <i>zs</i> ?  Sort of <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> xs <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> [] -&gt; ... (ys ++ zs) -&gt; ...</code> </pre><br>  In other words, we want to influence how the data structure will be represented as a result of pattern matching'a.  This is what we will call custom pattern matching. <br><br>  In the course of the article, our goal will be to implement custom pattern matching for the following situation.  Suppose we work with bit vectors of fixed length.  At the same time, we have the ability to specify the length of the vector directly in the type.  For example, writing <i>bits: [32]</i> means that <i>bits</i> is a 32-bit vector.  We, in the process of pattern matching, want to be able to split the vector into equal parts in various ways, for example, like this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">swapAB</span></span> : [<span class="hljs-number"><span class="hljs-number">32</span></span>] -&gt; [<span class="hljs-number"><span class="hljs-number">32</span></span>] swapAB [abcd] = [bacd]</code> </pre><br>  This function accepts a 32-bit vector as input, breaks it into 4 parts, each of which is an 8-bit vector, and swaps the first two 8-bit words.  She, with the same success, could break it into 2 parts, each 16-bit.  Such functionality can be useful when writing cryptographic software.  For example, something like this is the basis of the Cryptol language, which is designed to write cryptographic algorithms.  Let's see how to implement this on Agda. <br><br>  The general scheme for implementing custom pattern matching will be as follows: <br><ol><li>  Implement the View template for the original data type <br><ol><li>  Determine the type of data View, constructors of which represent the values ‚Äã‚Äãof the source type in the desired form </li><li>  Write a function view, which by value of the original data type builds a value of type View </li></ol></li><li>  Use pattern matching on the results of calling the view function. </li></ol><br>  Before dealing with these items, we define some basic data types. <br><br><h1>  Natural numbers and vector in Agda </h1><br>  Natural numbers are defined recursively: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Zero</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Suc</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span></span></code> </pre><br>  When determining the type of <i>Nat</i> , we indicate its type!  Just as the number 3 is of type <i>Nat</i> , in itself type <i>Nat</i> is of type <i>Set</i> .  <i>Set</i> is the built-in type of Agda.  However, understanding why this is necessary is not useful to us, and we can simply assume that all types are of type <i>Set</i> , although this is not true. <br>  The <i>Nat</i> type has two constructors: <i>Zero</i> , which has no arguments, and <i>Suc</i> is a constructor with one argument.  The number 3 thus looks like <i>(Suc (Suc (Suc Zero)))</i> , that is, something like (1 + (1 + (1 + 0))).  However, Agda has built-in literals, so instead of a long <i>Suc string,</i> you can simply write 3. <br><br>  A vector is a list of fixed length, defined as: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where [] : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Zero</span></span></span><span class="hljs-class"> _::_ : {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> n -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Suc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  The type <i>Vec</i> , in contrast to <i>Nat</i> , has 2 parameters: type <i>A</i> and a value of type <i>Nat</i> .  Due to the fact that the second parameter <i>Vec</i> is a value, not a type, <i>Vec</i> is a dependent type.  The fact that the parameters are separated from each other by a colon, and not, say, the symbol <i>-&gt;</i> is not a coincidence.  In fact, what is written after the colon is the so-called indices, not parameters.  However, for us this difference will not play a special meaning and we will call everything as parameters. <br>  The first constructor builds an empty vector.  In Agda, different sequences of characters can be used as names, so we can call the constructor <i>[]</i> . <br>  The second constructor takes 3 arguments ‚Äî the size of vector <i>n</i> , an element of type <i>A</i> , vector of size <i>n</i> , and returns a size vector <i>(n + 1)</i> .  Note that for the first argument, as well as for the first parameter of the <i>Vec</i> type itself, we specified not just the type, but also the name - <i>n: Nat</i> .  This is necessary because we refer to this value when declaring the third argument and the return value.  In addition, the first argument is taken in braces.  So in Agda are implicit arguments.  The fact is that the value of <i>n</i> can be uniquely restored from the third argument of the constructor.  Indeed, when we pass a vector, we know its size, it is indicated in the type.  Therefore, in fact, the first argument we can not pass - Agda itself would guess what it should be.  Thus, the constructor call <i>_ :: _</i> looks either as <i>_ :: _ {n} a someVec</i> , or as <i>_ :: _ a someVec</i> .  But that's not all!  The underscore characters in the name of the constructor actually say that it is infix.  Two explicit arguments can be written not after the name of the constructor, but instead of underscores, separated by a space.  In summary, here is an example of creating a vector: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">v1</span></span> : <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> :: (<span class="hljs-number"><span class="hljs-number">2</span></span> :: [])</code> </pre><br>  Note that we cannot write like this: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">v1</span></span> : <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">Nat</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> v1 = <span class="hljs-number"><span class="hljs-number">1</span></span> :: (<span class="hljs-number"><span class="hljs-number">2</span></span> :: [])</code> </pre><br>  The constructor <i>[]</i> creates a vector of length 0, the first constructor <i>::</i> is a vector of length 1, the second <i>::</i> is a vector of length 2. We <i>get Vec Nat 2</i> , but we need 3. The type inference system will not allow us to compile such a code. <br><br>  Among other things, we need some operations on vectors: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">_</span></span>++_ : <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> {<span class="hljs-type"><span class="hljs-type">A</span></span> mn} -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> m -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> n -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (m + n) take : <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> {<span class="hljs-type"><span class="hljs-type">A</span></span> m} -&gt; (n : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (n + m) -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> n drop : <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> {<span class="hljs-type"><span class="hljs-type">A</span></span> m} -&gt; (n : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (n + m) -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> m</code> </pre><br>  This is a concatenation of vectors, the operation ‚Äútake the first <i>n</i> elements‚Äù and ‚Äúthrow away the first <i>n</i> elements‚Äù, similar to those in the Haskell list.  A record like <i>forall {A mn}</i> means that, besides the fact that the arguments <i>A</i> , <i>m</i> and <i>n are</i> implicit, we still do not want to specify their type and ask Agda to define it on the basis of explicit arguments, which happens in an obvious way. <br><br><h1>  Bit Vector Type </h1><br>  The type of bit vector for which we will implement pattern matching will look pretty simple: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bit</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">O</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bit</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">I</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bit</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> n = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bit</span></span></span><span class="hljs-class"> n</span></span></code> </pre><br>  <i>Word</i> is a synonym for <i>Vec Bit</i> , using it we can declare a 32-bit vector as <i>bits: Word 32</i> . <br>  Before moving on to pattern matching, let's take a look at its features in the presence of dependent types. <br><br><h1>  Features of pattern matching in the presence of dependent types </h1><br>  Consider the following data type: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> _==_ {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class">} : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Refl</span></span></span><span class="hljs-class"> : {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">} -&gt; x == x</span></span></code> </pre><br>  The type <i>(x == y) is</i> parameterized by two concrete values ‚Äã‚Äãof type <i>A</i> and, as it is easy to guess, represents the statement that the values ‚Äã‚Äãof <i>x</i> and <i>y</i> are equal.  Having a single <i>Refl</i> constructor ensures that we cannot create values ‚Äã‚Äãof type <i>(x == y)</i> for different values ‚Äã‚Äãof <i>x</i> and <i>y</i> .  For example: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eq</span></span> : (<span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">3</span></span>) eq = <span class="hljs-type"><span class="hljs-type">Refl</span></span> notEq : (<span class="hljs-number"><span class="hljs-number">3</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span>) notEq = ?</code> </pre><br>  In the first case, we need to construct a value of type <i>(3 == 3)</i> and we have a constructor that allows this to be done - <i>Refl</i> .  We cannot construct a value of the type <i>(3 == 4)</i> - <i>Refl</i> does not fit the type, and there is no other constructors for the type <i>==</i> . <br>  Now consider this function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> : (x : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (y : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (x == y) -&gt; <span class="hljs-type"><span class="hljs-type">Nat</span></span></code> </pre><br>  What will pattern matching look like for the arguments of this function?  Obviously, for the third argument, we will write <i>Refl</i> , since the type <i>== has</i> no other constructors.  At the same time, we automatically find out that the first and second arguments are the same number!  In such cases, in Agda it is necessary to clearly note this fact using the so-called dot pattern: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fx</span></span> .x <span class="hljs-type"><span class="hljs-type">Refl</span></span> = x</code> </pre><br>  Such a record means that the second argument (which has the same name as the first with the assigned dot) is the same as the first argument.  We cannot write, say, <i>y</i> instead of <i>.x</i> , because we don‚Äôt want to lose the equality information that we received after the comparison with <i>Refl</i> . <br><br>  The conclusion is as follows: in languages ‚Äã‚Äãwith dependent types, after pattern matching on any argument, we can get additional information about other arguments. <br><br><h1>  Views </h1><br>  Before building a View for our <i>Word</i> type, consider a simpler example to understand what we want to achieve. <br>  Consider the type of list: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class">) : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where [] : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> _::_ : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span></span></code> </pre><br>  This is a regular list, the same as in Haskell, it is presented recursively, as ‚Äúthe first element and list‚Äù.  We want to be able to present the same list as the ‚Äúlist and last item‚Äù.  Let's create for this data type <i>SnocView</i> : <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SnocView</span></span></span><span class="hljs-class"> {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class">} : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where [] : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SnocView</span></span></span><span class="hljs-class"> [] _:::_ : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SnocView</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xs</span></span></span><span class="hljs-class"> ++ (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class"> :: []))</span></span></code> </pre><br>  Here the operator <i>++</i> is used - it is concatenation of lists, as in Haskell.  An example of a value of type <i>SnocView</i> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sx</span></span> : <span class="hljs-type"><span class="hljs-type">SnocView</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> :: <span class="hljs-number"><span class="hljs-number">2</span></span> :: <span class="hljs-number"><span class="hljs-number">3</span></span> :: []) sx = (<span class="hljs-number"><span class="hljs-number">1</span></span> :: <span class="hljs-number"><span class="hljs-number">2</span></span> :: []) ::: <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Note that the type <i>SnocView is</i> parameterized by the list for which the list and last element view is constructed. <br>  Now let's write the <i>snocView</i> function, which for the transferred list builds a value of the <i>SnocView</i> type: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">snocView</span></span> : {<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span>} -&gt; (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">SnocView</span></span> xs snocView [] = [] snocView (x :: xs) with snocView xs snocView (x :: .[]) | [] = [] ::: x snocView (x :: .(ys ++ (y :: []))) | ys ::: y = (x :: ys) ::: y</code> </pre><br>  There are a lot of things, let's start in order.  The case with an empty list is obvious: an empty list gives a trivial <i>SnocView</i> .  Further, if the list is not empty, we use the with construction (long indents here for readability only).  This construct performs approximately the same tasks as the Haskell case of construct, that is, it is used to perform pattern matching in the function body.  The patterns with which we associate the recursive call to <i>snocView xs</i> are indicated to the right of the vertical dashes.  So, if the recursive call gave us the trivial <i>SnocView</i> , then the <i>xs</i> list was empty, so the <i>SnocView</i> for <i>x :: []</i> is <i>[] ::: x</i> .  In the second case, we get that <i>SnocView</i> for <i>xs</i> looks like <i>ys ::: y</i> , so in order to get <i>SnocView</i> for <i>x :: xs</i> you need to add <i>x</i> to the head <i>ys</i> . <br>  It remains unclear only what is indicated to the left of the vertical dashes.  As we discussed earlier, pattern matching in the presence of dependent types can give us additional information about other function arguments.  In our example, pattern matching on a recursive call to <i>snocView xs</i> gives us information about the value of the <i>xs</i> list.  It is this information that is indicated by the dot patterns to the left of the vertical bar.  For example, in the second case, having learned that <i>snocView xs</i> gives us <i>ys ::: y</i> , we understand that the list <i>xs is</i> constructed as a concatenation of <i>ys</i> and a list from one element <i>y :: []</i> . <br><br>  Here is an example of using <i>snocView</i> to write a function that cyclically shifts the transferred list to the right: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">rotateRight</span></span> : {<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span>} -&gt; <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> rotateRight xs with snocView xs rotateRight ._ | [] = [] rotateRight ._ | ys ::: y = y :: ys</code> </pre><br>  Here we used underscores.  This can be done when we are not interested in the meaning that should be in place of underscores.  Looks pretty brief and beautiful!  This example essentially shows how to implement custom pattern matching in languages ‚Äã‚Äãwith dependent types.  Now let's see how to do the same for the Word type! <br><br><h1>  SplitView for Word </h1><br>  As in the previous example, we need 2 things: a special <i>SplitView</i> data <i>type</i> and the <i>splitView</i> function, which will build the <i>SplitView</i> value for a given <i>Word</i> value. <br>  To begin with, we will need 2 additional functions to work with the type <i>Vec</i> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">split</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> {<span class="hljs-type"><span class="hljs-type">A</span></span>} -&gt; (n : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (m : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (m * n) -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> (<span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> n) m split n <span class="hljs-type"><span class="hljs-type">Zero</span></span> [] = [] split n (<span class="hljs-type"><span class="hljs-type">Suc</span></span> k) xs = (take n xs) :: (split nk (drop n xs)) concat : <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> {<span class="hljs-type"><span class="hljs-type">A</span></span> nm } -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> (<span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> n) m -&gt; <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (m * n) concat [] = [] concat (xs :: xss) = xs ++ concat xss</code> </pre><br>  <i>SplitView</i> type will look like this: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplitView</span></span></span><span class="hljs-class"> {</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class">} : {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">} -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Set</span></span></span><span class="hljs-class"> where [_] : forall {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mn</span></span></span><span class="hljs-class">} -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xss</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Vec</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">) m) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SplitView</span></span></span><span class="hljs-class"> m (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">concat</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xss</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  This type is parametrized by the number <i>m</i> and the vector.  <i>m</i> indicates how many parts we want to break the vector.  That is why the vector length is a multiple of <i>m</i> .  A single constructor will allow us to write values ‚Äã‚Äãof this type like this: <br><pre> <code class="haskell hljs">[ a :: b :: c :: d :: [] ]</code> </pre><br>  where a, b, c and d are vectors of length n. <br>  The next step is the <i>splitView</i> function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitView</span></span> : {<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span>} -&gt; (n : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (m : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (xs : <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (m * n)) -&gt; <span class="hljs-type"><span class="hljs-type">SplitView</span></span> m xs</code> </pre><br>  To implement it, you need to split the transmitted vector into <i>m</i> parts, each of length <i>n</i> , and transfer it to the constructor <i>[_]</i> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitView</span></span> nm xs = [ split nm xs ]</code> </pre><br>  However, such a definition is not accepted by the compiler.  The point is that the constructor <i>[_]</i> returns a value of type <i>SplitView m (concat xss)</i> .  In our case, <i>xss</i> is <i>split nm xs</i> , so the expression <i>[split nm xs]</i> is of type <i>SplitView m (concat (split nm xs))</i> .  In this case, the function signature indicates that it should return the type <i>SplitView m xs</i> , where <i>xs</i> is the third argument of the function.  We all understand that the expressions <i>xs</i> and <i>concat (split nm xs)</i> are one and the same, because we know how the functions <i>concat</i> and <i>split</i> are arranged.  Let's convince the compiler. <br>  To begin with, let's rewrite the <i>splitView</i> body <i>above</i> in the following form: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitView</span></span> nm xs with [ split nm xs ] splitView nm xs | v = v</code> </pre><br>  This definition is not accepted by the compiler for the same reasons as the previous one: <i>v</i> has the type <i>SplitView m (concat (split nm xs))</i> , but must be <i>SplitView m xs</i> .  Continue to change the definition: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitView</span></span> nm xs with concat (split nm xs) | [ split nm xs ] splitView nm xs | ys | v = v</code> </pre><br>  The with construction can be used for pattern matching by several expressions at once, which are separated from each other by vertical dashes.  In addition, using with produces an effect called generalisation.  It manifests itself in the fact that the types of function arguments and the type of expression that we need to construct can vary depending on the expressions we use for pattern matching with with.  For example, if we have a function <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fxy</span></span> with e fxy | p = ...</code> </pre><br>  then, as a result of generalization, all occurrences of the expression <i>e</i> in the types of arguments <i>x</i> and <i>y</i> , as well as in the type of expression that we need to construct in the body, will be replaced by <i>p</i> .  And if we have several expressions in with <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fxy</span></span> with e1 | e2 | e3 fxy | p1 | p2 | p3 = ...</code> </pre><br>  then, among other things, all occurrences of <i>e1</i> in <i>p2</i> and <i>p3 are</i> replaced by <i>p1</i> , occurrences of <i>e2</i> in <i>p3 are</i> replaced by <i>p2</i> . <br>  In our definition of <i>splitView</i> , by adding <i>concat (split nm xs)</i> to with, type <i>v</i> will change from <i>SplitView m (concat (split nm xs))</i> to <i>SplitView m ys</i> .  Now we need to prove that <i>xs</i> and <i>ys</i> are the same.  To do this, we need the following function: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitConcatLemma</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> {<span class="hljs-type"><span class="hljs-type">A</span></span>} -&gt; (n : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (m : <span class="hljs-type"><span class="hljs-type">Nat</span></span>) -&gt; (xs : <span class="hljs-type"><span class="hljs-type">Vec</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> (m * n)) -&gt; concat (split nm xs) == xs</code> </pre><br>  According to the transmitted vector, it constructs the value of the familiar type <i>==</i> , which indicates the equality of the necessary expressions <i>concat (split nm xs)</i> and <i>xs</i> .  Using this function, we get the following version of <i>splitView</i> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitView</span></span> nm xs with concat (split nm xs) | [ split nm xs ] | splitConcatLemma nm xs splitView nm xs | ys | v | eq = v</code> </pre><br>  Here, no types have changed, but <i>eq</i> has the type <i>ys == xs</i> due to the same generalization effect on the first expression in with.  Now we have everything to make the function work.  Perform pattern matching on the value of <i>eq</i> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">splitView</span></span> nm xs with concat (split nm xs) | [ split nm xs ] | splitConcatLemma nm xs splitView nm xs | .xs | v | <span class="hljs-type"><span class="hljs-type">Refl</span></span> = v</code> </pre><br>  Hooray!  Now everything works! <br>  I did not give the definition of the <i>splitConcatLemma</i> function <i>here</i> .  This is not critical for our conversation on the View template, besides, I am sure that I already loaded you!  But brave warriors who have read this far, the end is on the horizon. <br>  Finally, the implementation of the <i>swapAB</i> function through custom pattern matching using <i>splitView</i> : <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">swapAB</span></span> : <span class="hljs-type"><span class="hljs-type">Word</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Word</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span> swapAB xs with splitView <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> xs swapAB ._ | [ a :: b :: c :: d :: [] ] = concat (b :: a :: c :: d :: [])</code> </pre><br><br><h1>  Conclusion </h1><br>  After reading the article, you might have a question: is it possible to use the same approach in languages ‚Äã‚Äãwithout dependent types?  And indeed, all we did was set the data type, which allowed us to represent the source type in the form we needed, and wrote a function that constructs the value of the target based on the input value of the source type. <br>  The difference in the use of this approach in languages ‚Äã‚Äãwithout dependent types is that we lose touch with the original value.  For example, the type of <i>SnocView</i> depends on the value of the list for which we build it, that is, the relationship between the original value and the View is maintained at the type level.  Due to this, when executing pattern matching on <i>SnocView xs</i> values, we learn information about how the original <i>xs</i> list looks.  Without dependent types to get this information will not work. <br>  The second difference that follows from the first one is that without dependent types, the function that builds the View will be too general.  For example, the <i>snocView</i> function has the type: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">snocView</span></span> : {<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Set</span></span>} -&gt; (xs : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">SnocView</span></span> xs</code> </pre><br>  It is clear from it that the function body cannot be completely arbitrary - it is limited by the fact that <i>SnocView</i> depends on <i>xs</i> .  If we did not have dependent types, then this function could be of type <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">snocView</span></span> : <span class="hljs-type"><span class="hljs-type">List</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SnocView</span></span></code> </pre><br>  and, let's say, just returning an empty list at any input, which makes it rather useless. <br><br>  Therefore, I will finish my post with the words with which the article begins The Power Of Pi: dependent types! <br><br>  <i>References:</i> <br>  <a href="http://cs.ru.nl/~wouters/Publications/ThePowerOfPi.pdf">Nicolas Oury, Wouter Swierstra "The Power Of Pi"</a> <br>  <a href="http://agda.readthedocs.org/en/latest/language/with-abstraction.html">With documentation</a> <br>  <a href="https://github.com/octomarat/AgdaLearning/tree/master/ThePowerOfPi/ViewHabraPaper/src">Sources</a> </div><p>Source: <a href="https://habr.com/ru/post/277989/">https://habr.com/ru/post/277989/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277975/index.html">Moving to the cloud: A possibility not only for IT companies</a></li>
<li><a href="../277977/index.html">IaaS provider and security issues</a></li>
<li><a href="../277979/index.html">Alternatives to parse.com</a></li>
<li><a href="../277983/index.html">Software Internet gateway for a company not already small (Shorewall, QoS in full width). Part 3</a></li>
<li><a href="../277987/index.html">Go in terms of PHP programmer</a></li>
<li><a href="../277991/index.html">What does the VxRail hyper-convergent system look like? Online demo, functionality, availability to order</a></li>
<li><a href="../277995/index.html">Hooks are easy (part 3)</a></li>
<li><a href="../277999/index.html">An example of using the inventory and reporting features in System Center Configuration Manager</a></li>
<li><a href="../278001/index.html">Performance and multithreading at the JPoint 2016 Java Conference</a></li>
<li><a href="../278005/index.html">Implementing a stable UART, at a speed of 921600 baud or more, in Verilog language under FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>