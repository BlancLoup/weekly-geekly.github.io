<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 10: "Symbolic execution", part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 10: "Symbolic execution", part 2</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <br>  Lecture 8: "Model of network security" <a href="https://habr.com/company/ua-hosting/blog/418229/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/423155/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/423423/">Part 3</a> <br>  Lecture 9: "Web Application Security" <a href="https://habr.com/company/ua-hosting/blog/424289/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/424295/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/424297/">Part 3</a> <br>  Lecture 10: "Symbolic execution" <a href="https://habr.com/company/ua-hosting/blog/425557/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425561/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/425559/">Part 3</a> <a name="habracut"></a><br><br>  <b>Audience:</b> it seems you didn‚Äôt talk about how bits are used to store an integer int. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Professor:</b> this is a very good question.  And this is really related to how you define your limitations, right?  Therefore, if you look at our simple example from the very beginning, you will see that we assumed the presence of integers that we studied in elementary school.  At the same time, we completely decided to ignore overflow errors.  If you care about overflow errors, and it is important for you that there are no such errors, using mathematically whole numbers will not fix the problem. <br><br><img src="https://habrastorage.org/webt/d4/-r/y0/d4-ry0kha0k0koshx0mwy3zwums.jpeg"><br><br>  What you need is to present these values ‚Äã‚Äãnot as integers, but as bit vectors.  When you present them as bit vectors, you should use a broader view of things.  Here we return to the SMT solvers.  The aspect of modular theory is that the solver itself is expandable with the help of various theories. <br><br>  The most popular theories are theories of bit vectors of fixed length.  This means that if you interpret your formulas in the theory of fixed-length bit vectors, you have to pre-set the length of the bit vectors.  That is, you must explicitly indicate that this will be used for bit vectors with a length of 32 bits, or 8 bits, or 64 bits. <br><br><img src="https://habrastorage.org/webt/_n/af/n-/_nafn-pei3kbsz4sxqgnbvi8ggy.jpeg"><br><br>  There is another theory called the TOA array theory.  And we will talk a little more about it.  Unlike the theory of bit vectors, which is intended for things of fixed length, the theory of arrays is intended for collections whose size is a priori unknown. <br><br>  Now, in practice, no one uses the theory of arrays, for example, to model integers, because it is too expensive.  Much more expensive to talk about the problem when you do not know its boundaries.  Therefore, as a rule, people use the theory of fixed length of bit vectors when reasoning about integers or even symbols. <br><br>  Another very common theory is the theory of real integer arithmetic, and in particular linear integer arithmetic. <br><br><img src="https://habrastorage.org/webt/qb/aa/8t/qbaa8tza3h3ahkhgi5eeo1ba4mw.jpeg"><br><br>  People love this theory very much, because it provides effective reasoning, but it‚Äôs not very good when you talk about programs, because here you really care about the problems of overflow.  But this theory is widely used for many things. <br><br>  Another theory that is often used is the theory of uninterpreted functions.  What does this theory mean? <br><br><img src="https://habrastorage.org/webt/8k/8l/1j/8k8l1jurngs68kehvett1zaaifk.jpeg"><br><br>  It means that you have some formula.  In this formula, you know that you are calling a function, but you don‚Äôt know anything about this function except for the fact that if you insert some input data into it, you will get the same output data. <br><br>  It turns out that this is very useful when talking about things like using floating point code, modeling, sines, cosines, square roots.  Detailed reasoning about such things can be very time consuming and expensive.  But using this theory allows you to say: ‚ÄúListen, I really don't care what the sine function does.  I don't care what exactly it will give out at the exit.  I just need to know that if I call the sine function in different places in the program with specific inputs, I will get data of the same kind on the output.  This is quite enough for me to talk about my program. ‚Äù <br><br>  And so the most common operations in the analysis of real systems are bit vectors that work with integers, logs and pointers.  In fact, pointers are often represented as integers, because sometimes you don't set bit vectors on pointers.  But sometimes you have to do it, and then you can no longer use whole numbers. <br><br>  So, we looked at what the SMT solver can do for you.  How does it really work?  What is inside them that makes them work? <br><br>  In fact, SMT solvers rely on our ability to solve the satisfiability problems of the SAT boolean formulas, on the ability to deal with problems related only to purely boolean constraints and boolean variables, and tell us whether you will ensure the execution of the program values ‚Äã‚Äãassigned to these boolean variables or not . <br><br>  This is something that many, many years have taught undergraduates, saying that this is actually an NP-complete task, and in cases where something comes down to the SAT, you should not do that.  But it turns out that we actually have very good SAT solvers. <br><br>  So, I will tell you the basic idea of ‚Äã‚Äãhow the SAT solvers work.  It lies in the fact that you take all your constraints on Boolean variables and put them in a database.  You may not be able to see the small letters on the screen, but that's all I can do. <br><br><img src="https://habrastorage.org/webt/h6/j8/gp/h6j8gpmtgfurf6gsslrlr76i8tw.jpeg"><br><br>  I will comment and tell about it in the course of the action, and later I will publish the slides so that you can see what is written there. <br><br>  So, here in the SAT task we have all these variables representing Boolean unknowns, right?  We want to know if it is possible for both X to be true (X = TRUE), and Y to be true, and Z to be true.  These are our unknowns.  Moreover, all restrictions are in a normal conjunctive form.  This means that all our limitations are in the form of either X1 = true, or X2 = true, or X3 = true. <br><br><img src="https://habrastorage.org/webt/jh/b0/-v/jhb0-vkga5zdzwxjtu5zlg6euky.jpeg"><br><br>  In this form, we have all our limitations, which say that either X1 is true, or X2 is false, or X3 is false.  You probably remember from discrete mathematics that any Boolean formula can be represented in a normal connective form.  This means that any representation that you use to represent Boolean formulas can be converted to this format very easily. <br><br>  So, we have a database with a lot of limitations of this form.  The SAT solver will select one of these variables randomly, supposing it to be X1.  And he will say: ‚Äúwhy not set X1 to true?  I don‚Äôt know anything about these restrictions, so I can assume that this is true. ‚Äù  And then it will happen that you will have restrictions, which, for example, claim that either X1 is false, or X7 is true. <br><br>  So, if you know that X1 is true and you know that either X1 is false or X7 is true, what do you know about X7? <br><br>  <b>Audience:</b> it must be true! <br><br>  <b>Professor:</b> yes, it must be true.  Because otherwise this restriction will not be fulfilled.  So now you spread this value from X1 to X7.  Suppose that you now choose another random variable, for example X5. <br><br><img src="https://habrastorage.org/webt/c8/xt/rp/c8xtrpz4r9k438asupto0lwc5ni.jpeg"><br><br>  Now suppose you have a constraint that says: either X7 is false, or X6 is true, or X5 is false.  So, I have X5 = true and X7 = true.  This means that X6 should now also be true.  Because otherwise this restriction would be violated.  So, the system concludes that X6 should be true, and continues the process, performing the available checks and looking at all the available offers.  The system checks if there are other things that are implied by the checks it has.  And it follows these values ‚Äã‚Äãuntil one of two things happens. <br><br>  The first is that you continue to follow the consequences and try random things, and eventually you set the value for each variable without ever encountering a contradiction.  So you did everything right. <br><br>  Second, you are faced with a contradiction, and then you return to the condition that caused X4 to be true, excluding the condition that caused X4 to be false.  But there is one rule of Boolean algebra, which everyone should know: a variable cannot be both true and false. <br><br><img src="https://habrastorage.org/webt/yf/bk/tg/yfbktgumqupvocdxul_cx9wlt20.jpeg"><br><br>  And it says that you are faced with a contradiction, you obviously did something wrong in one of these random tasks that you tried to do. <br><br>  Let's analyze this contradiction and see what kind of tasks led to this contradiction.  Based on the tasks that led to this contradiction, let's think up a new conflict situation that summarizes this contradiction. <br><br>  What happens that X1 is false, and X5 is false, and X9 is also false?  Essentially, this is based on what I learned from these random quests, during which I discovered that one of these things must be true, that it cannot be so that X1 is true and X5 is true, and X9 is false, this can not be. <br><br>  I know that this cannot happen, because when I tried to do this, everything ‚Äúexploded‚Äù, I ended the program on a contradiction. <br><br>  And so the SAT ‚Äì solver tries to perform random tasks, checking how they pass.  When it encounters contradictions, it analyzes the set of consequences that led to these contradictions, and ultimately forms a new constraint that ensures that the solver will never again encounter this particular contradiction, this particular problem. <br>  Thus, we can imagine the SAT-solver as a ‚Äúblack box‚Äù, which gives a boolean constraint and can tell whether it is satisfactory or not.  SMT solvers are based on the best SAT solvers.  They can use the power of SAT solvers to solve NP-complete problems with subject-oriented reasoning about supported theories. <br><br>  To get an idea of ‚Äã‚Äãhow this works, let's assume that you have such a formula. <br><br><img src="https://habrastorage.org/webt/fi/hc/za/fihczar0nfdk1h7j_jgkzixzpli.jpeg"><br><br>  Is it doable?  Can we find a satisfying check for her?  The SMT solver can separate a part of this formula that requires reasoning in the theory of integers.  We use Boolean structures to separate formulas.  So we have the formulas F1, F2, F3 and F4. <br><br><img src="https://habrastorage.org/webt/wi/yr/sy/wiyrsy_aikhwm3soegrypiu2vfk.jpeg"><br><br>  Now this is a purely logical, boolean task - can I find a satisfactory task for this?  The SAT solver can say: ‚Äúyes, I can find something that satisfies this task by making F1 = true, F2 = true and F3 = true‚Äù.  This satisfies the assignment of a Boolean formula. <br><br><img src="https://habrastorage.org/webt/s5/ff/pc/s5ffpcpzbfo2cktluc4jrnnz9pk.jpeg">  \ <br><br>  So, now we have a question that we can ask the solver for a specific area, in this case it‚Äôs just a linear arithmetic solver.  So we can go to the Theory solver linear solver and say, "The SAT solver claims that this is a reasonable assignment, and that if I can get this assignment to work, then my formula will be satisfied." <br><br>  I can say that F1 is X&gt; 5, F2 is Y &lt;5, and F3 is Y&gt; X. So I can ask the SAT solver whether you can get X and Y such that X is&gt; 5, Y is &lt; 5, while Y would be&gt; X?  Now it is a question of purely linear arithmetic, there is no Boolean logic. <br><br>  And what is the answer to this question?  Not.  To satisfy these conditions at the same time is impossible. <br>  So, there are traditional methods for solving linear problems.  You can use the simplex method, for example, to solve systems of linear inequalities.  There are many methods that can be used to solve systems of linear inequalities. <br><br><img src="https://habrastorage.org/webt/4g/q3/uy/4gq3uyrn1tqglftbpfldn0-vofe.jpeg"><br><br>  So, the SAT solver sends theoretical questions to the theoretical solver Theory solver.  The bottom line is that the Theory solver solvers know all about these problems and can give an exact answer to the question whether these conditions will work. <br><br>  In this case, the theoretical solver processes the request, finds out that the given assignment of conditions cannot work, returns to the SAT solver and says: ‚Äúthe things that you did will not work‚Äù! <br><br>  But he doesn‚Äôt just say ‚Äúyes‚Äù or ‚Äúno‚Äù, but explains why something will not work.  From the fact that these formulas do not work, Theory solver concludes that F1 and F2 and F3 cannot exist simultaneously, and tells the SAT solver that these 3 formulas are mutually exclusive. <br><br>  So now we have some information that I can return to the SAT solver and ask him: ‚ÄúHey, you can give me a solution that satisfies not only the constraint that we had at the beginning, but also the new constraint that Theory found solver? <br><br>  Is there any other purpose that now satisfies both of these limitations? <br><br><img src="https://habrastorage.org/webt/3v/zx/ls/3vzxlsvv19wp3h-ifqye1fushps.jpeg"><br><br>  So, we discard the original constraint X&gt; 5, Y &lt;5, Y&gt; X, we do not care anymore. <br><br><img src="https://habrastorage.org/webt/jc/es/mi/jcesmivnxfc8ur3hzivvmrt1ywc.jpeg"><br><br>  We have a new constraint that we can set our Theory solver - X&gt; 5, Y &lt;5, Y&gt; 2. We can make Y equal 3, and X equal 6, and then it will work.  Now you have a task that satisfies the formula in the theory and satisfies the boolean structure for this purpose.  And with this, the system can come back and say: "Yes, here is a task that satisfies all your limitations."  This is the interaction between the Theory solver and the SAT solver.  In fact, this means being able to talk about very, very large and very complex Boolean formulas.  This is what makes symbolic execution possible. <br><br>  Now we will consider the next question - how is the transition from the program to the limitations that we can provide to the SMT solver. <br><br>  <b>Audience:</b> Is building an SMT solver an NP-complete task or not? <br><br>  <b>Professor:</b> SMT ‚Äì solver is in fact itself a canonical NP-complete problem.  But the majority of solvers today also include the support of some theories that are completely insoluble. <br><br>  <b>Audience:</b> how to approach this issue in your system? <br><br>  <b>Professor:</b> well, in the end, you get a restriction created from this program.  You are going to give it to the SMT solver.  And the fact that these are NP-complete tasks or the fact that they are not satisfactory means that if you are lucky, you will get an answer in a matter of seconds.  But if you are unlucky, it may take longer than the creation of the universe took. <br><br><img src="https://habrastorage.org/webt/ji/zl/eb/jizlebbqvbb7ni0w0snmlsx_dqm.jpeg"><br><br>  <b>Audience:</b> Does it happen that the tasks of the linear system do not pass the SAT? <br><br>  <b>Professor:</b> yes, that really happens.  However, the available engineering tools make it happen less and less.  We do not solve random problems of SAT, we do not solve completely random problems of bit vectors. <br><br>  We solve problems that have a certain structure, so that a person can look at it and have some confidence that it will work.  We are trying to create in his head some arguments for understanding why this worked.  And SAT solvers use this structure.  Your problem may have a million boolean variables, but in fact most of these variables are very dependent on each other‚Äôs values.  Thus, the number of degrees of freedom in a problem is actually much smaller than millions of variables suggest. <br><br>  <b>Audience:</b> you say that this is not an exam question, but real life.  Once someone has built this system, it should work and make sense.  So this probably will not be one of the useless theoretical talk. <br><br>  <b>Professor:</b> that's it.  Therefore, in practice, when you use this tool, what you always do is set timeouts.  In general, everything happens because exponentiality does not mean that you cannot do this.  Exponentiality, that is, when one function is limited to another function, simply means that there is a brick wall in front of which these things will work, and they will work really very quickly.  Exponentiality works in both directions. <br><br><img src="https://habrastorage.org/webt/tm/yu/3j/tmyu3janxuwwu_ghngg9srbpg-0.jpeg"><br><br>  When you move away from this wall, things grow very quickly, but when you get closer to smaller or simpler problems, these problems also accelerate very, very quickly.  This means that many problems end very quickly.  And then there is a timeout of problems.  The point is to design things in such a way that among those problems that quickly end there are problems that are of practical use.  These are problems that point you to the security vulnerabilities of your system, to errors on the path that you may not have investigated before, or on input data that would break your path if you did not examine them in advance. <br><br>  So, we know how to move from a formula, from a set of constraints to an answer, which either says: ‚ÄúYes, this formula has a solution, and here it is, this solution‚Äù.  Or he will say: ‚Äúthis formula is unsatisfactory, because there is no input data satisfying your assignments‚Äù.  So how do we get the formula from the program? <br><br>  When you do symbolic execution, go to the branch and don‚Äôt know in which direction it will go.  There are two possibilities for what to do in this case.    ‚Äî  ,      ,             ,        . <br><br>  ,   ,         .   ,          SMT-.         .   ,               . <br><br>      : ¬´   ,          ,     ,     ,      ¬ª. <br><br>      ,     ,      .         .  ,     . <br><br>   ,   . ,     ,   . ,     ‚Äì       ,        .        ?    ,     . <br><br><img src="https://habrastorage.org/webt/ty/jk/r0/tyjkr0wfkidwul4c72ksygznaky.jpeg"><br><br>     ,     ,    t=0    false. <br><br><img src="https://habrastorage.org/webt/9b/vk/fq/9bvkfq3d5pjdx1hvldxuu6sidvq.jpeg"><br><br>   ,    ,       ?       : ,      ,    . <br><br>  ,  ,      ,    ,   ,            ,     . <br><br>   ,     ,    t = 0,    x, y  0.       ,       . ,         ,  X ,  Y. <br><br>  ,      X &gt; Y. <br><br><img src="https://habrastorage.org/webt/px/us/2m/pxus2m_qn9igfcjvipllca7-juk.jpeg"><br><br> 55:00  <br><br> <a href="https://habr.com/company/ua-hosting/blog/425559/"> MIT ¬´  ¬ª.  10: ¬´ ¬ª,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yRVZPvHYHzw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/"></a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until December for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>    <b><a href="https://ua-hosting.company/serversnl">2  Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100   $249</a>    !</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/425561/">https://habr.com/ru/post/425561/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425551/index.html">Who should receive money when selling works of art created by AI?</a></li>
<li><a href="../425553/index.html">What can Count Monte Cristo tell us about cybersecurity</a></li>
<li><a href="../425555/index.html">Charles Nutter on Dynamic Languages ‚Äã‚Äãin JVM on jug.msk.ru</a></li>
<li><a href="../425557/index.html">MIT course "Computer Systems Security". Lecture 10: "Symbolic execution", part 1</a></li>
<li><a href="../425559/index.html">MIT course "Computer Systems Security". Lecture 10: "Symbolic Execution", part 3</a></li>
<li><a href="../425563/index.html">California bans the sale of IoT devices with simple passwords or no passwords.</a></li>
<li><a href="../425565/index.html">Fast Fixed Point Math for Java Financial Applications</a></li>
<li><a href="../425569/index.html">Functional PCB Testing</a></li>
<li><a href="../425571/index.html">Protecting the web server on Linux</a></li>
<li><a href="../425575/index.html">Neurospine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>