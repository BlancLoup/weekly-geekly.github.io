<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generic and hybrid storage of records in the Teradata DBMS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Until recently, all DBMS working with structured data (and not only them) could be divided into 2 categories: storing records in a row format and stor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generic and hybrid storage of records in the Teradata DBMS</h1><div class="post__text post__text-html js-mediator-article">  Until recently, all DBMS working with structured data (and not only them) could be divided into 2 categories: storing records in a row format and storing records in a row format.  This is a fundamental difference that affects how the rows of tables look at the level of the internal database storage mechanisms.  For a long time, Teradata DBMS belonged to the first group, but with the release of the 14th version, it was possible to determine how to store data of a particular table - in the form of columns or rows.  Thus, hybrid storage appeared.  In this article we want to talk about why it is needed, how it is implemented and what benefits it gives. <br><a name="habracut"></a><br><h4>  What is Teradata Columnar? </h4><br>  Before we talk about the format of storage by columns, let's say a few words about how we usually store data by rows.  Take a relational table with columns and rows: <br><img src="https://habrastorage.org/storage2/b0e/a45/979/b0ea459791553e635cb201594c836a2c.png"><br>  How do we write the data of this table to disk in the case of its line format?  First, we write the first line, then the second, third, and so on: <br><img src="https://habrastorage.org/storage2/883/1f6/422/8831f64223137d5eccc33273b2214fab.png"><br><br>  How to minimize the load on the disk system when reading this table?  You can use different methods to access it: <ol><li>  Access by index - if you need to read only a few lines. </li><li>  Access to its individual partitions (sections) - if the table is very large (for example, there are transactions for several years, but you need to read the data only for the last few weeks).  <b>These are partitions in rows</b> . </li><li>  Full table reading - if you need to read a large percentage of the number of its rows. </li></ol><br>  That is, minimizing the load on the disk system is based on the fact that we do not need to read the entire table, but only its individual rows. <br><br>  What about the speakers?  If the SQL query does not use all the columns of the table, but only some of them?  When reading lines, we read every line from the disk completely.  If there are 100 columns in the table, and only 5 of them are needed for a specific SQL query, then we are forced to read 95 columns from the disk that the SQL query does not use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is where the idea of ‚Äã‚Äãstoring data not in rows but in columns comes to mind.  In the case of the storage format for columns - columnar - the approach is as follows: first, we write the first column on the disk, then the second, third, and so on: <br><img src="https://habrastorage.org/storage2/785/8d9/9ca/7858d99caf45cc277438d153deed4508.png"><br><br>  Such a partitioning of the table into columns creates <b>partitions by columns</b> .  If the query needs only separate columns, then we read only the necessary partitions by column from the disk, significantly reducing the number of I / O operations when reading data that is needed by the SQL query. <br><br>  An interesting feature of this approach is that partitions by rows and partitions by columns can be used simultaneously in the same table, in other words - partitions within partitions.  First we go into the necessary partitions in columns, then inside them we read only the necessary partitions in rows. <br><br>  Summarizing the above, Teradata Columnar is a data storage method in the Teradata DBMS, which allows tables to simultaneously use two partitioning methods: <br><ul><li>  Horizontal partitions - in the lines </li><li>  Vertical partitions - by columns </li></ul><br><h4>  Benefits of Teradata Columnar </h4><br>  The advantages are as follows: <br><ul><li>  <b>Increase query performance</b> - by reading only individual partitions in columns, eliminating the need to read all the data in the rows of the table.  This is exactly where we started our article. </li><li>  <b>Efficient automatic data compression</b> using an automatic compression mechanism.  But this is an additional pleasant opportunity that opens when storing data by columns: in this case, the data is much more convenient to compress.  Some even put this advantage in the first place, and rightly so. </li></ul><br>  Both of these points lead to a reduction in the load on the disk system.  In the first case, we read a smaller amount of data, so we perform fewer I / O operations.  In the second case, the table takes up less disk space, and as a result, fewer I / O operations are required to read it. <br><br>  Reducing the load on the disk system reduces the response time in applications, since requests are executed faster.  And it also increases the performance of the Teradata system as a whole ‚Äî individual requests consume a smaller percentage of the system capacity for I / O operations, so the system can execute more such requests. <br><br><h4>  Reading data from a table stored in columns </h4><br>  Storing data in columns significantly changes the mechanics of reading data from such a table.  In fact, we need to ‚Äúcollect‚Äù data from separate column partitions to get the rows that the SQL query should return. <br><br>  It looks like this.  If the query has a WHERE condition for a column, then first scan this column.  We filter the data, and for those rows that satisfy the WHERE condition, go to the neighboring partitions in columns and read the values ‚Äã‚Äãof the remaining columns for these rows. <br><br>  Example: What customers live in Sochi? <br>  The format of rows (for comparison) reads the values ‚Äã‚Äãof all columns when filtering by the City column (WHERE City condition = 'Sochi'). <br><img src="https://habrastorage.org/storage2/8c5/690/c63/8c5690c63253afa90a934a9bd08f91c8.png"><br><br>  In the format of columns only the data of the columns City and Cust are read.  Number - first filter the City column, then search for the corresponding Cust values.  Number. <br><img src="https://habrastorage.org/storage2/46d/87f/65a/46d87f65afa42232cb8061f638a35c64.png"><br><br>  If there are several columns in the WHERE condition, first the most selective one is selected, the filter by which will lead to the largest clipping of rows, then the next WHERE column, etc.  And then all the other columns involved in the request. <br><br>  As for the mechanics of the transition between partitions of columns for ‚Äúassembling‚Äù one row from separate columns, such a transition is carried out ‚Äúpositionally‚Äù.  When reading a specific line, we know that in each column partition the value of the line we need is in the Nth position relative to the beginning of the table.  To search for a string, a special rowid address row structure is used, which contains the partition number and the row number.  This allows you to switch between partitions of columns, replacing the partition number within the rowid for the same row number.  Thus, we collect the values ‚Äã‚Äãof the columns for a single row together. <br><br><h4>  Hybrid data storage in one table </h4><br>  And if there are a lot of columns in the table?  Then it will take more overhead to collect rows from individual columns.  This effect can be avoided by creating separate partitions not for each column, but for groups of columns.  If we know that some columns are often used together and rarely separately, then we place these columns in one partition.  Then inside such a partition, the data of these columns can be stored in rows, as if it were a subtable.  This method of storage is called hybrid: part of the data in the table is stored in columns, and part of the data in the same table is stored in rows. <br>  Example (another table than before): <br><img src="https://habrastorage.org/storage2/dd1/a02/cae/dd1a02cae49d583baccc3cf15d912595.png"><br><br>  The only thing we can say is that the term ‚Äúhybrid data storage‚Äù can be used not only for the above method of data storage, but also for storing data blocks on disks of different speeds, which we had a <a href="http://habrahabr.ru/company/teradata/blog/165463/">separate article</a> about in Habrahabr. <br><br><h4>  Saving disk space </h4><br>  We told about the exclusion of partitions in more detail than about data compression.  Let us give him due attention. <br><br>  Partitions by columns mean that the values ‚Äã‚Äãof a single column are next to each other.  This is very convenient for data compression.  For example, if a column has slightly different values, then you can create a ‚Äúdictionary‚Äù of frequently used column values ‚Äã‚Äãand use it to compress data.  Moreover, for one column there can be several such dictionaries - separately for different ‚Äúcontainers‚Äù, into which the column is divided when it is stored on disk (by analogy with data blocks when stored in rows). <br><br>  What is convenient - Teradata selects dictionaries automatically based on the data that is loaded into the table, and if the data changes over time, the dictionaries for data compression also change. <br><br>  In addition to dictionaries, there are other data compression methods, such as run length encoding encoding, trimming, Null compression, delta storage, UNICODE in UTF8.  We will not go into the details of each of them - let us just say that they can be used both separately and in combination with each other for the same data.  Teradata can dynamically change the compression mechanism for a column if it brings the best result. <br><br>  The goal of compression is to reduce the amount of data (in gigabytes) that the table occupies on disk.  This allows you to store more data (in terms of the number of rows of the table) on the same hardware, as well as more data on fast SSD disks, if any. <br><br><h4>  When to use Columnar? </h4><br>  Teradata Columnar is a great feature that allows you to increase query performance and compress data.  However, it should not be considered as an ideal solution.  The win will be obtained only for the corresponding data and SQL queries with certain characteristics.  In other cases, the effect may even be negative - for example, when all queries use all the columns in a table and the data does not compress well. <br>  Successful candidates for column storage are tables in which there are many columns, but each SQL query uses a relatively small number of them.  In this case, different queries can use different columns, as long as each individual query uses only a small number of columns.  In these cases, there is a significant reduction in the number of I / O operations and an improvement in I / O performance. <br><br>  Splitting row data into separate columns when inserting data (insert) and then ‚Äúcollecting‚Äù column values ‚Äã‚Äãback into rows when selecting data (select) - these operations consume more CPU for column tables than for normal ones.  Therefore, it should be borne in mind that if the system has a significant shortage of CPU resources (the so-called CPU-bound-systems), then for them Teradata Columnar should also be used with care, as this can reduce the overall system performance due to lack of CPU resources. <br><br>  One of the requirements for column tables is that the data is loaded into the table in large chunks of INSERT-SELECT.  The reason is as follows: if you insert data "line by line", then for column tables it is very inconvenient, since  instead of one row record (one input-output operation), as it would be for a regular table, here you need to write the values ‚Äã‚Äãof the columns into different columns separately - dramatically increasing the number of input-output operations.  However, this is typical for inserting just one line.  If multiple rows are inserted at once, then writing a large set of rows is comparable in laboriousness in order to break up the same amount of data into columns and write these columns into the necessary partitions by columns. <br><br>  For the same reason, in the column tables, the UPDATE and DELETE operations are time consuming, because you need to go into different partition partitions of the columns in order to perform these operations.  However, laborious - this does not mean impossible.  If the volume of such changes is relatively small, then Teradata Columnar is quite suitable for such tasks. <br><br>  Another feature of the column tables is the absence of a primary index - a column that ensures the distribution of rows by AMPs in the Teradata system.  Access by primary index is the fastest way to get rows in Teradata.  There is no such index for the column tables, the No-Primary Index (No-PI) mechanism is used instead - when the data is evenly distributed by Teradata itself, but without the possibility of accessing this data by the primary index.  This means that column tables should not be used for tables whose specific use implies the presence of a primary index. <br><br>  These rules are not straightforward.  Each situation should be analyzed separately.  For example, you can create additional indexes to mitigate the effect of the absence of a primary index.  Or another example: you can create a table in a row format, and on top of it a join index in a column format (a join index is a materialized view in Teradata, it can also be stored in a column format).  Then queries that use many columns will refer to the table itself, and queries that have few columns will use the materialized view. <br><br>  What is convenient - it is not at all necessary to declare all tables to be columnar.  It is possible to create only a part of the tables in the format of columns, and the remaining tables in the format of rows. <br>  In summary, Teradata Columnar is used for tables that have the following properties: <br><ul><li>  SQL queries are performed on separate sets of table columns. <br>  OR <br>  SQL queries are performed on a separate subset of table rows. <br>  &gt; The best result is when both </li><li>  Data can be loaded with large INSERT-SELECTs. </li><li>  No or few update / delete operations </li></ul><br><br>  If you look closely, many very large tables that grow over time, just have these properties.  Do you want them to take up less disk space and query them faster?  Then the functionality of the Teradata Columnar is worth paying attention to. <br><br>  To help those who perform physical modeling, determine which tables should or should not be created in column format, there is a special tool - the Columnar Analysis Tool.  This tool analyzes the use of a particular table by SQL queries and gives recommendations on the applicability of the storage format by columns.  There is also a lot of useful information, of course, in the <a href="http://www.info.teradata.com/Datawarehouse/eBrowseBy.cfm%3Fpage%3DTeradataDatabase">Teradata 14</a> documentation. </div><p>Source: <a href="https://habr.com/ru/post/170321/">https://habr.com/ru/post/170321/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../170303/index.html">Bitcoin 0.8.0 released (Important changes)</a></li>
<li><a href="../170305/index.html">How we created a cluster from Raspberry Pi</a></li>
<li><a href="../170307/index.html">Prototype against designer</a></li>
<li><a href="../170313/index.html">Another boring, boring story about the first independent project</a></li>
<li><a href="../170319/index.html">What devices do 2can owners use?</a></li>
<li><a href="../170323/index.html">How much? I would do it for X / 10 rubles!</a></li>
<li><a href="../170327/index.html">Templates in the template engine and how Django templates reached PHP (once again)</a></li>
<li><a href="../170329/index.html">Acrobatics quadrocopters</a></li>
<li><a href="../170331/index.html">Improving the power scheme of the wireless keyboard</a></li>
<li><a href="../170333/index.html">How to make a bomb out of XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>