<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exasol: Badoo Experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Exasol is a modern high-performance proprietary database for analytics. Its direct competitors are HP Vertica, Teradata, Redshift, BigQuery. They are ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exasol: Badoo Experience</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4c1/46b/93e/4c146b93e3c9426b8c87b3cab38e9859.png" align="left">  <a href="http://www.exasol.com/en/">Exasol</a> is a modern high-performance proprietary database for analytics.  Its direct competitors are HP Vertica, Teradata, Redshift, BigQuery.  They are widely covered in RuNet and Habr√©, while there is almost no word about Exasol in Russian.  We would like to correct this situation and share the experience of practical use of the DBMS in the company Badoo. <br><br>  Exasol is based on three main concepts: <br><br><h3>  1. Massively Parallel Architecture (massive parallel processing, MPP) </h3><br>  SQL queries are executed in parallel on all nodes, making the most of all available resources: processor cores, memory, disks, and the network.  The concept of "master node" is absent - all servers in the system are equivalent. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Separate stages of the execution of a single request can also go in parallel.  In this case, partially calculated results are transmitted to the next stage, without waiting for the end of the previous one. <br><br><h3>  2. Column storage (English columnar store) </h3><br>  Exasol stores data in <a href="http://kejser.org/how-do-column-stores-work/">column form</a> , and not in the form of separate rows, as in classical DBMS.  Each column is stored separately, divided into large blocks, sorted, compressed and evenly distributed across all nodes. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/a0c/0b1/42c/a0c0b142c5044d3e8bb1dbc3329d1229.png"><br>  Compression efficiency varies greatly depending on the data types and the distribution of values ‚Äã‚Äãin the tables.  On average, Badoo data is compressed 6.76 times. <br><br>  Column storage allows you to repeatedly accelerate analytical queries, as well as read only the data that is necessary to fulfill the query.  In classical DBMS, it is necessary to read the entire series as a whole, even if it uses only one column. <br><br><h3>  3. In-memory analytics </h3><br>  Exasol has a mechanism similar to MySQL's buffer pool or PostgreSQL's shared buffer.  Data blocks once loaded from disk remain in memory and can be reused for subsequent requests. <br><br>  As a rule, in real life, users work primarily with ‚Äúhot‚Äù data (last day, week, month).  If the cluster has enough memory to hold them all, then Exasol will not touch the disk at all. <br><br>  These three concepts, brought together in one DBMS, show high performance regarding the complexity of SQL queries and the hardware used.  We give specific numbers. <br><br>  Now Badoo cluster uses 8 servers with the following characteristics: <br><ul><li>  16 to 20 CPU Cores; </li><li>  768 GB RAM; </li><li>  16x1 TB HDD (RAID 1 - 8 TB); </li><li>  10 Gbps network. </li></ul><br>  The total memory available to Exasol is approximately 5.6 TB. <br>  The total amount of uncompressed data is about 85 TB. <br><br>  The sizes of large tables vary from 500 million to 50 billion rows.  One analytical query processes an average of about 4.5 billion rows. <br><br>  Performance on real queries for the last month: <br><table><tbody><tr><th rowspan="2">  Number of objects in the request </th><th colspan="3">  All requests </th><th colspan="3">  Requests lasting from 1 second </th></tr><tr><th>  Qty </th><th>  Median </th><th>  The average </th><th>  Qty </th><th>  Median </th><th>  The average </th></tr><tr><td>  Until 3 </td><td>  240914 </td><td>  0.021 seconds </td><td>  9 sec </td><td>  34808 </td><td>  29 sec </td><td>  63 seconds </td></tr><tr><td>  4 to 10 </td><td>  45122 </td><td>  13 seconds </td><td>  47 sec </td><td>  30005 </td><td>  34 sec </td><td>  70 seconds </td></tr><tr><td>  From 11 to 30 </td><td>  12642 </td><td>  24 sec </td><td>  69 sec </td><td>  5615 </td><td>  45 seconds </td><td>  156 seconds </td></tr><tr><td>  From 31 and more </td><td>  740 </td><td>  41 sec </td><td>  303 sec </td><td>  740 </td><td>  41 sec </td><td>  303 sec </td></tr></tbody></table><br>  This is not a synthetic test, but real statistics on real requests from live users.  As you can see, even in the most difficult cases, it is most often about seconds and minutes, but not about hours or days. <br><br>  The complexity of the query in this example is conditionally calculated by simply searching for the words FROM and JOIN in the SQL text.  Thus, we find the approximate number of objects used.  The more objects used, the more difficult the request. <br><br>  Separating requests from 1 second into a separate group is necessary in order to reduce the impact of too fast in-memory requests for the result and to show the most realistic picture for those cases when you still need to read something from the disk. <br><br>  Due to this, high performance is achieved, in addition to the above concepts. <br><br><h3>  Joins (eng.) And indices </h3><br>  Exasol can do very fast joins, and it doesn‚Äôt bother at all about their number. <br><br>  An effective join always occurs by index.  Indexes are created automatically at the moment when you first try to merge two tables using specific keys.  If the index is not used for a long time, then it is also automatically deleted. <br><br>  When adding or deleting data in tables with existing indexes, ‚Äúdeltas‚Äù are created that contain only changes.  If there are too many changes (about 20% of the total volume), then INDEX MERGE occurs, which combines the main index with the delta, after which the delta is deleted.  This is much faster than rebuilding the index from scratch.  The mechanism is somewhat similar to Sphinx. <br><br>  Indexes occupy a relatively small amount of memory.  The vast majority of indexes in our database takes less than 100 GB, including the case for multi-billion dollar tables.  The size of the index is determined by the number of columns included in it, their data types and value variability. <br><br><h3>  Global joins vs local joins </h3><br>  Joyns are global and local.  A global join occurs when the data to be merged is physically stored on different nodes. <br><img src="https://habrastorage.org/files/a8b/c21/489/a8bc214897c440e9a069a31970993a10.png"><br><br>  A local join occurs when the merged data is stored on the same node. <br><img src="https://habrastorage.org/files/053/7c4/c75/0537c4c758504468a5d93d9f84225bfe.png"><br><br>  Local joins are much faster than global ones, because in this case the network is not used.  This effect can be achieved by pre-distributing data on nodes in a special way.  In our example, this can be done as follows: <br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> CUSTOMER <span class="hljs-keyword"><span class="hljs-keyword">DISTRIBUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> CITY_ID; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> CITIES <span class="hljs-keyword"><span class="hljs-keyword">DISTRIBUTE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>;</code> </pre> <br>  At the same time, it is guaranteed that for both tables, rows with the same city_id values ‚Äã‚Äãwill always be physically located together on the same node. <br><br>  Also, small tables are automatically replicated (copied entirely) on all nodes, which automatically guarantees fast local joins to them.  This is especially true for numerous small listings. <br><br>  The main difference between Exasol and other distributed DBMS is that you don‚Äôt have to fear global joins and there is no need to create special projections to avoid them.  Of course, global joins are slower than local ones, but not so much that it creates problems.  The vast majority of joins in Badoo are global. <br><br><h3>  Effective join conditions </h3><br>  In order for a join to occur according to the most effective scenario, it is necessary to follow a number of simple rules: <br><br>  <strong>1. Conditions must be in columnA = columnB format only.</strong> <br><br>  Good: <br><pre> <code class="sql hljs">JOIN table2 b ON (a.id=b.id)</code> </pre> <br>  Poorly: <br><pre> <code class="sql hljs">JOIN table2 b ON (a.purchase_date &gt; b.create_date)</code> </pre> <br>  <strong>2. It is undesirable to use expressions.</strong> <br><br>  Good: <br><pre> <code class="sql hljs">JOIN table2 b ON (a.purchase_date=b.purchase_date)</code> </pre> <br>  Poorly: <br><pre> <code class="sql hljs">JOIN table2 b ON (a.purchase_date=TO_DATE(b.purchase_time))</code> </pre> <br>  <strong>3. Several conditions can be combined with AND, but OR should be avoided.</strong> <br><br>  Good: <br><pre> <code class="sql hljs">JOIN table2 b ON (a.id=b.id AND a.name=b.name)</code> </pre> <br>  Poorly: <br><pre> <code class="sql hljs">JOIN table2 b ON (a.id=b.id OR a.name=b.name)</code> </pre> <br>  <strong>4. The types of data columns must match.</strong>  DECIMAL to DECIMAL, VARCHAR to VARCHAR, DATE to DATE and so on. <br><br>  If at least one of the conditions is not met, then the following occurs: <br><ul><li>  or the index will still be created, but after the query is executed, it will be immediately deleted (the so-called Expression Index); </li><li>  or Exasol will do the ‚Äúeverything to everything‚Äù join, and then the filtering.  The latter is not so bad as long as you do not get several trillion rows in the intermediate result.  Billions - quite possible. </li></ul><br><br><h3>  Root filter </h3><br>  The concept of ‚ÄúRoot filter‚Äù makes a significant contribution to the high performance of Exasol.  It cannot be found in the official documentation, but can be seen in secret system "views" and query execution plans. <br><br>  How does the filter work? <br><br>  If the query has a fairly selective WHERE condition with constants, then Exasol will read only those data blocks that fit the specified condition.  He will not read all the other blocks. <br><br>  In these examples, the filter will be used: <br><pre> <code class="sql hljs">WHERE registration_date BETWEEN '2015-01-01' AND '2015-10-01' WHERE foo &gt;= 115 WHERE product_type IN ('book','car','doll')</code> </pre><br>  And in these examples the filter will not be used: <br><pre> <code class="sql hljs">WHERE registration_date BETWEEN CURRENT_DATE ‚Äì INTERVAL '1' YEAR AND CURRENT_DATE WHERE foo &gt; (15 + 17) WHERE email REGEXP_LIKE '(?i)@mail\.ru$'</code> </pre><br>  If Exasol can predefine clear and simple boundaries of exactly which data it needs to read, then it will take advantage of this opportunity and will reduce the number of read operations a dozen or hundreds of times.  The fewer reads and the smaller the size of intermediate results, the faster everything works.  At the same time, no special indexes are needed - only statistics based on the data storage column structure are used. <br><br><h3>  SQL Features and Features </h3><br>  Exasol fully supports basic ANSI SQL.  This includes GROUP BY, HAVING, ORDER BY, LIMIT, OFFSET, MERGE, FULL JOIN, DISTINCT, etc.  - in a word, everything that we used to see. <br><br>  From an analytical SQL perspective, the following is suggested: <br><ol><li>  Window functions, ROW_NUMBER, medians, ranks, percentiles for every taste; </li><li>  Common Table Expressions; </li><li>  CUBE, ROLLUP, GROUPING SETS; </li><li>  GROUP_CONCAT; </li><li>  PCRE regular expressions, including searching, capturing patterns and replacing them; </li><li>  functions for working with dates and time zones; </li><li>  Geospatial-functions. </li></ol><br>  We found it interesting that Exasol treats the empty string as NULL.  It can not be disabled.  Apparently, the transformation occurs somewhere at very deep levels, but this does not create serious problems.  You just need to remember this when importing. <br><br>  Exasol rigidly validates data types.  No automatic type conversions, implicit truncations of lines that are too long, rounding, etc.  not happening.  In such cases, you will always see an error, which is good. <br><br><h3>  Transactions </h3><br>  Exasol - transactional DBMS, <a href="https://en.wikipedia.org/wiki/ACID">full ACID compliant</a> .  Isolation level is <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">serializable</a> .  In practice, in the current implementation, this means that only one writer can write to a table in parallel.  Readers can be any number, and they are not blocked by the writer.  "Parallel writers" will be executed sequentially one after another, or, in case of conflicts and deadlocks, a ROLLBACK will occur. <br><br>  <a href="https://en.wikipedia.org/wiki/Data_definition_language">DDL</a> queries are also transactional.  This means that you can create new tables, views, add columns, etc.  - all this can occur in a single transaction.  If necessary, you can easily make a ROLLBACK and return everything as it was. <br><br>  Due to the storage column structure, the addition and removal of columns occurs almost instantly.  There is no downtime due to long ‚Äúalters‚Äù when changing the table schema in practice. <br><br><h3>  Data import </h3><br>  It is most efficient to import data into Exasol using the built-in exajload utility.  It makes the most of the flow control and parallel connections to several nodes at once. <br><br>  It is allowed to transmit compressed data stream without prior decompression, which significantly reduces the load on the network.  Supported formats: gz, zip, bz2. <br><br>  For analytical DBMS, the issue of effective data loading from Hadoop is relevant.  Exasol allows you to directly load files into multiple streams using WebHDFS, bypassing intermediate servers and reducing overall overhead. <br><br>  Due to the transactionality, you can also load data directly into the production-table, entirely bypassing staging.  If the download is interrupted (for any reason), then ROLLBACK will occur, and you will have an old copy of the table.  If the download completes successfully, the new data will replace the old one. <br><br>  Like in many other analytical DBMSs, the ELT (Extract - Load - Transform) approach in Exasol is much more efficient than the classic ETL (Extract - Transform - Load) approach.  It is better to load the raw data into an intermediate table, and then transform it with the means of the DBMS itself, while using all the advantages of Massive Parallel Processing. <br><br><h3>  Briefly about support </h3><br>  1. In Exasol, there is currently no advanced support for servers with different configurations within a single cluster.  All nodes receive the same amount of data and the same amount of computational tasks.  The entire cluster will operate at the speed of the weakest node.  Therefore, it is better to put 2-4 powerful servers at the very beginning than 10 weak ones.  Expand then you will be much easier. <br><br>  2. Adding a new node takes several minutes.  After that, Exasol can immediately raise and allow users, without waiting for the final redistribution of data on the disks.  In this case, everything will work a little slower due to additional network operations, but as the number of nodes increases, the difference becomes less noticeable.  The data reorganization process can be controlled manually by running the REORGANIZE command for specific schemas or tables.  Thus, it is possible to reorganize more important tables earlier than all the others. <br><br>  3. Fault tolerance.  In our practice, we encountered several accident scenarios.  For example, the free space ended, or someone accidentally physically disconnected part of the working servers from the network.  We did not notice any significant problems with this.  The database writes in advance about the problem, stops and waits for the situation to be corrected.  In some cases, an automatic restart occurs if the problem disappears.  Moreover, if you do not look into the logs, you can not know that something was happening at all. <br><br>  Exasol is able to survive the complete loss of a certain number of nodes without stopping work.  There is a special ‚Äúredundancy‚Äù parameter that determines how many nodes will physically store each data block.  The higher the value of this parameter, the more nodes can be lost.  But for this it is expected to pay a place on the disks. <br><br>  4. SSD drives for Exasol do not play a big role.  The data blocks are very large, they are read and written in large batches one after another.  Random disk access is almost absent.  Instead of SSD it is better to put more memory. <br><br><h3>  Prices </h3><br>  Unfortunately, Exasol is not open source software.  You must pay for the license.  There are no fixed prices - the company agrees individually with each partner.  Most likely, the cost will depend on the amount of RAM used, which is typical for DBMSs that position themselves as in-memory. <br><br>  Exasol also has a <a href="https://www.exasol.com/portal/display/DOWNLOAD/Free%2BTrial">free trial</a> .  It is a version that works only on one node and uses up to 10 GB of RAM.  This is enough for the devel-environment and to check your requests for a small part of the data and make a general impression. <br><br>  In addition, Exasol launched a special <a href="http://www.exasol.com/en/solutions/business/startup/">program for startups</a> , which offers 500 GB of data in the cloud for 500 euros per month.  You do not need to buy expensive iron.  Unfortunately, we can not appreciate the benefits of their clouds, because  we did not work with him. <br><br>  Physically, Exasol is located in the city of Nuremberg (Germany).  You can come to visit them, take training courses, talk with the developers. <br><br><h3>  Conclusion </h3><br>  Overall, Exasol has become a real discovery for us.  You simply load the data and can analyze it immediately at high speed.  It just works. <br><br>  At the same time there is no fuss with indexes, views, some kind of manual optimizations.  You can link together data from completely different sources, and not only those that were previously intended for this.  Any joins at your service. <br><br>  In fact, you are limited only by the ability to formulate your task in the form of a SQL query.  If for some special cases SQL capabilities are not enough, then Exasol allows you to create custom functions in Python, LUA, Java, R. At the same time, all the advantages of column storage, general parallelism of all operations and efficient memory use are preserved. <br><br>  If you are interested in any other aspects of working with Exasol, as well as the organization of an effective ETL process, write in the comments, I will be happy to answer you. <br><br>  Thanks for attention! <br><br><h3>  useful links </h3><br><ol><li>  <a href="http://www.exasol.com/en/">Exasol website</a> </li><li>  <a href="https://www.exasol.com/support/secure/attachment/35839/EXASolution_User_Manual-5.0.11-en.pdf">User Manual (ver 5.0.11)</a> </li><li>  <a href="http://info.exasol.com/whitepaper-exasolution-1-en.html">Technical Whitepaper</a> - explanations about Massive Parallel Processing </li><li>  <a href="https://www.exasol.com/portal/display/DOWNLOAD/Free%2BTrial">Free trial</a> </li><li>  <a href="https://www.exasol.com/portal/display/SOL/Solution%2BCenter">Solution center</a> - mostly useful videos and answers to frequently asked questions. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/271753/">https://habr.com/ru/post/271753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271741/index.html">Welcome to GDG DevFest Omsk 2015</a></li>
<li><a href="../271745/index.html">Successful implementation of SIEM. Part 1</a></li>
<li><a href="../271747/index.html">Asterisk: Prioritizing VoIP traffic and reserving Internet access from two providers on MikroTik</a></li>
<li><a href="../271749/index.html">DotNext - Conference on .NET-technologies, Moscow, December 11</a></li>
<li><a href="../271751/index.html">Deploy Drupal 8 with Docker</a></li>
<li><a href="../271755/index.html">MultiSim: technological SIM-phony for several operators and one subscriber</a></li>
<li><a href="../271757/index.html">Comparative analysis of shopping carts</a></li>
<li><a href="../271759/index.html">Creating The Blacksmith: Staging, Shading and Lighting</a></li>
<li><a href="../27176/index.html">Mobile phones and popcorn</a></li>
<li><a href="../271761/index.html">Development of fast mobile applications on Android. Part one</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>