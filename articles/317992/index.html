<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My acquaintance with ReactiveCocoa</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To be honest, I started using ReactiveCocoa because it is fashionable. I hear iOS developers talking about this framework all the time, and I can hard...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My acquaintance with ReactiveCocoa</h1><div class="post__text post__text-html js-mediator-article">  To be honest, I started using ReactiveCocoa because it is fashionable.  I hear iOS developers talking about this framework all the time, and I can hardly remember iOS Meetup without mentioning ReactiveCocoa. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/722/2a9/e2a/7222a9e2ab5ad976481bf9f56aa483dc.jpg" alt="image"></div><br>  When I first started learning ReactiveCocoa I didn‚Äôt know what it was.  ‚ÄúReactive‚Äù sounds really great, and ‚Äúfunctional‚Äù sounds clever.  But after I succumbed to the temptation to master Reactive Cocoa, I can no longer imagine writing code without using it. <br><br>  ReactiveCocoa is a framework that opens a window into the world of functionally reactive programming.  It allows you to benefit from the practical application of this paradigm, without even requiring a deep theoretical knowledge of FRP. <br><a name="habracut"></a><br>  I mastered ReactiveCocoa on a real project, doing some simple things, at first I used it to solve two problems, which I will tell you in this article.  I will say ‚Äúwhat to do‚Äù and not ‚Äúhow to do‚Äù so that you can get a practical understanding of the framework. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  1. Links </h3><br>  Understanding ReactiveCocoa usually starts with connections.  After all, they are the easiest thing a newbie can understand. <br><br>  The links themselves are only a supplement to the existing KVO mechanism in Objective-C.  Is there anything new that ReactiveCocoa brings to KVO?  This is a more convenient interface, it also adds the ability to describe the rules for linking the state of the model and the state on the UI in a declarative style. <br><br>  Let's look at the connections on the example of a table cell. <br><br>  Typically, a cell is attached to the model and displays its visual state (or ViewModel state for MVVM adepts).  Although, ReactiveCocoa is often viewed in a single context with MVVM and vice versa, it really does not matter.  Communication is simply a way to make your life easier. <br><br><pre><code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)awakeFromNib { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; RAC(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, titleLabel.text) = RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, model.title); }</code> </pre> <br>  This is a declarative style.  ‚ÄúI want the text of my label to always equal the value of the <i>Title of</i> my model‚Äù - in the <i>-awakeFromNib</i> method.  It doesn't really matter when the <i>title</i> or model changes. <br><br>  When we look at how it works internally, we find that <b>RACObserve</b> is a macro that takes a path (" <i>mode.title</i> " from the <i>self</i> object in our case) and converts it to <b>RACSignal</b> .  <b>RACSignal</b> is an object of the ReactiveCocoa framework that represents and provides future data.  In our example, it will deliver data from <i>model.title</i> each time the <i>title</i> or model changes. <br><br>  We will talk about signals a little later, since there is no need to go into details at this stage.  Currently, you can simply ‚Äúlink‚Äù the state of the model with the interface and enjoy the result. <br><br>  Quite often, you will need to transform the state of a model to display its state on the UI.  In this case, you can use the <i>-map</i> operator: <br><br><pre> <code class="objectivec hljs">RAC(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, titleLable.text) = [RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, model.title) map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> stringWithFormat:@‚Äùtitle: %@‚Äù, text]; }]</code> </pre><br>  All operations with UI must be performed in the <b>main thread</b> .  But, for example, the <i>title</i> field can be changed in the background stream (i.e., during data processing).  Here is what you need to add in order for the new <i>title</i> value to be delivered to the subscriber on the main stream: <br><br><pre> <code class="objectivec hljs">RAC(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, titleLabel.text) = [RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, model.title) deliverOnMainThread];</code> </pre><br>  <b>RACObserve</b> is an extended macro <i>-rac_valuesForKeyPath: observer:</i> But here‚Äôs a trick - this macro always captures <b>self</b> as an observer.  If you use <b>RACObserve</b> inside a block, you must make sure that you do not create link cycling and use a weak link.  ReactiveCocoa has convenient <b>@weakify</b> and <b>@strongify macros</b> for these needs. <br><br>  One more detail about which you need to warn about connections is the case when your model state is tied to some significant changes in the user interface, as well as to frequent changes in the model state.  This can adversely affect the performance of the application and, to avoid this, you can use the <i>-throttle</i> operator <i>:</i> - it accepts <b>NSTimeInterval</b> and sends the <b>‚Äúnext‚Äù</b> command to the subscriber after a specified time interval. <br><br><h3>  2. Operations on collections (filter, map, reduce) </h3><br>  Operations on the collections were as follows, which we investigated in ReactiveCocoa.  Working with arrays takes a lot of time, isn't it?  While your application is running, data arrays come to you from the network and require modification so that you can present them to the user in the required form. <br><br>  Raw data from the network must be converted to object or View Models, and displayed to the user. <br><br>  In ReactiveCocoa, collections are represented as a class of <b>RACSequence</b> .  There are categories for all types of Cocoa collections that transform Cocoa collections into ReactiveCocoa collections.  After these transformations, you will get several functional methods, such as <i>map, filter and reduce</i> . <br><br>  Here is a small example: <br><br><pre> <code class="objectivec hljs"> RACSequence *sequence = [[[matchesViewModels rac_sequence] filter:^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(MatchViewModel *match) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [match hasMessages]; }] map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(MatchViewModel *match) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> match.chatViewModel; }];</code> </pre><br>  First, we filter our view models to select those that already have posts ( <i>- (BOOL) hasMessages</i> ).  After that we have to turn them into other view models. <br><br>  After you have finished the sequence, it can be converted back to NSArray: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *chatsViewModels = [sequence array];</code> </pre><br>  Have you noticed that we again use the <i>-map:</i> operator?  This time, though, this applies to <b>RACSequence</b> , not <b>RACSignal</b> , as it was with connections. <br><br>  The most remarkable thing about the RAC architecture is that it has only two main classes - <b>RACSignal</b> and <b>RACSequence</b> , which have one parent - <b>RACStream</b> .  All the flow, and the signal is the impetus driving the flow (new values ‚Äã‚Äãare pushed to the subscribers and cannot be output), and the sequence is a retractable flow drive (provides values ‚Äã‚Äãwhen someone asks for them). <br><br>  Another thing worth noting is how we link operations together.  This is a key concept in <b>RAC</b> , which also applies to <b>RACSignal</b> and <b>RACSequence</b> . <br><br><h3>  3. Work with the network </h3><br>  The next step in understanding the features of the framework is to use it for networking.  When I talked about connections, I mentioned that RACObserve creates RACSignal, which represents the data that will be delivered in the future.  This object is ideal for representing a network request. <br><br>  Signals send three types of events: <br><br><ul><li>  <b>next</b> is the future value / meanings; </li><li>  <b>error</b> - <i>NSError *</i> value, which means that the signal cannot be successfully completed; </li><li>  <b>completed</b> - indicates that the signal was completed successfully. </li></ul><br>  The service life of a signal consists of any number of <i>next</i> events, and then one <i>error</i> or <i>completed</i> (but not both). <br><br>  This is very similar to how we wrote our network requests using blocks.  But what is the difference?  Why replace conventional blocks with signals?  Here are some reasons: <br><br>  <i>1) You get rid of the callback!</i> <br><br>  This nightmare in the code occurs when you have several subqueries and each subsequent uses the result of the previous one. <br><br>  <i>2) You process the error in one place.</i> <br><br>  Here is a small example: <br><br>  Suppose you have two signals <i>- loginUser</i> and <i>fetchUserInfo</i> .  Let's create a signal that ‚Äúlogs in‚Äù the user, and then receives its data: <br><br><pre> <code class="objectivec hljs">RACSignal *signal = [[networkClient loginUser] flattenMap:^RACStream *(User *user) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [networkClient fetchUserInfo:user]; }];</code> </pre><br>  The <i>flattenMap</i> block will be called when the <i>loginUser</i> signal sends the <i>next</i> event, and this value is passed to the block via the user parameter.  In the <i>flattenMap</i> block <i>,</i> we take this value from the previous signal and produce a new signal as a result.  Now, let's subscribe to this signal: <br><br><pre> <code class="objectivec hljs">[signal subscribeError:^(<span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error) { <span class="hljs-comment"><span class="hljs-comment">// error from one of the signals } completed:^{ // side effects goes here. block get called when both signals completed }];</span></span></code> </pre><br>  It is worth noting that the <i>subscribeError</i> block will be called if at least one of the signals does not work.  If the first signal fails, the second signal will fail. <br><br>  <i>3) The signal has a built-in recycling mechanism (cancel).</i> <br><br>  For example, often the user leaves the screen during its loading.  In this case, the download operation must be canceled.  You can implement this logic directly in the signal, and not store a link to this download operation.  For example, a signal to load user data can be created as follows: <br><br><pre> <code class="objectivec hljs">[[RACSignal createSignal:^RACDisposable *(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>&lt;RACSubscriber&gt; subscriber) { __block <span class="hljs-built_in"><span class="hljs-built_in">NSURLSessionDataTask</span></span> *task = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> GET:url parameters:parameters completion:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> response, <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) { [subscriber sendNext:response]; [subscriber sendCompleted]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [subscriber sendError:error]; } }]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [RACDisposable disposableWithBlock:^{ [task cancel]; }]; }]];</code> </pre><br>  I intentionally simplified this code to show the idea, but in real life you shouldn‚Äôt have to grab <i>self</i> in a block. <br><br>  You can determine when a signal should be canceled with a signal reference: <br><br><pre> <code class="objectivec hljs">[[networkClient loadChats] takeUntil:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.rac_willDeallocSignal];</code> </pre><br>  or <br><br><pre> <code class="objectivec hljs">[[networkClient loadChats] takeUntil:[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelButton rac_signalForControlEvents:<span class="hljs-built_in"><span class="hljs-built_in">UIControlEventTouchUpInside</span></span>]];</code> </pre><br>  The most remarkable thing about this approach is that you should not keep references to the operations that you will use, only when you need to complete them.  Therefore, the code looks more declarative, since there is no need to save the intermediate state. <br><br>  Of course, you can also cancel the signal manually - just store the reference to the RACDisposable object (which is returned from the <i>subsribeNext / Error / Completed</i> method) and call the <i>-dispose</i> method directly when necessary. <br><br>  Implementing a network client using signals is quite a broad topic of discussion.  You can look at <a href="">OctoKit</a> - a great example of how Reactive Cocoa is used to solve network issues.  Ash Furrow also covered this topic in his book <a href="https://leanpub.com/iosfrp/">Functional Reactive Programming for iOS</a> . <br><br><h3>  4. Signals in action </h3><br>  In solving some problems, we combined parts of data and events from different parts of the application.  Data appears and changes asynchronously.  If we think about them imperatively, we try to anticipate which additional connections and variables should come in the code and, more importantly, how to synchronize it all in time. <br><br>  When we have formulated an approximate chain of actions that need to be completed, we begin to write code, and various parts of a class or even several classes are contaminated with new lines of code, if statements, useless states that ‚Äúroam‚Äù around our project like gypsy caravans. <br><br>  You know how hard it is to parse such code!  And sometimes the only way to figure out what is going on is to debug step by step. <br><br>  After some time working with Reactive Cocoa, it came to me that the basis for solving all the problems mentioned above (linking, collection operations, networking) represents the application life cycle as a data stream (RACStream).  Then the data coming from the user or from the network must be converted in a certain way.  It turns out you can solve the tasks much easier! <br><br>  Let's look at two examples. <br><br>  <b>Task # 1</b> <br>  This is an example from a real project that we recently completed. <br><br>  We had the ability to exchange messages and one of the tasks was to display the correct number of unread messages on the application icon.  An ordinary task, isn't it? <br><br>  We had a class of <i>ChatViewModel</i> from which stored logical property <i>unread</i> . <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChatViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BOOL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unread</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">other</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">declarations</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre><br>  And somewhere in the code, we had an array of dataSourc containing these view models. <br><br>  What do we want to do?  We want to update the number of unread messages every time the unread property changes.  The number of elements must be equal to the number of YES values ‚Äã‚Äãin all models.  Let's do this with a signal: <br><br><pre> <code class="objectivec hljs">RACSignal *unreadStatusChanged = [[RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, dataSource) map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *models) { RACSequence *sequence = [[models rac_sequence] map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(ChatViewModel *model) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RACObserve(model, unread); }]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[RACSignal combineLatest:sequence] map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(RACTuple *unreadStatuses) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [unreadStatuses.rac_sequence foldLeftWithStart:@<span class="hljs-number"><span class="hljs-number">0</span></span> reduce:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *accumulator, <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *unreadStatus) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @(accumulator.integerValue + unreadStatus.integerValue); }]; }]; }] switchToLatest];</code> </pre><br>  This may look a little tricky for beginners, but it is fairly easy to understand. <br><br>  First, we observe changes in the array: <br><br><pre> <code class="objectivec hljs">RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, dataSource)</code> </pre><br>  This is important because it is assumed that new chats can be created and old ones can be deleted.  Since there is no RAC KVO for variable collections, the DataSource is an immutable array every time an object is added / deleted from / to the dataSource.  RACObserv will return a signal that will return a new array each time a new value is added to the dataSource. <br><br>  Well, we got a signal ... But this is not the signal we wanted, so we have to transform it.  Operator <i>-map:</i> perfect for this task. <br><br><pre> <code class="objectivec hljs">[RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, dataSource) map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *models) { }]</code> </pre><br>  We got a lot of models in the map block.  Since we want to know about every change in the <i>unread</i> property of all models, it seems that we still need a signal, or even an array of signals - one signal for each model: <br><br><pre> <code class="objectivec hljs"> RACSequence *sequence = [[models rac_sequence] map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(ChatViewModel *model) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RACObserve(model, unread); }];</code> </pre><br>  There is nothing new here.  <i>RACSequence, map, RACObserve</i> . <br><br>  <b>Note:</b> <i>In this case, we will convert our sequence of values ‚Äã‚Äãinto a sequence of signals.</i> <br><br>  In fact, we do not need so many signals, we need one, but significant, as constantly changing data must be processed together.  There are several ways to combine signals in RAC, and you can choose the one that suits your needs. <br><br>  <i>+ merge</i> , will forward the values ‚Äã‚Äãfrom our signals to a single stream.  This does not exactly meet our needs, in the next block we will see only the last value (in our case, <i>YES</i> or <i>NO</i> ). <br><br>  Since we want to know all the values ‚Äã‚Äã(in order to get their sum), let's use <i>+ combineLatest</i> : It will monitor the change of signals, and then send the last value of all signals when a change occurs.  In the next block, we can see a ‚Äúsnapshot‚Äù of all our unread values. <br><br><pre> <code class="objectivec hljs">[RACSignal combineLatest:sequence];</code> </pre><br>  Now we can get an array of recent values ‚Äã‚Äãeach time a single value changes.  Almost over!  The only task left is to calculate how many times the value <i>YES</i> occurs in this array.  We can do this with a simple loop, but let's be functional to the end and use the reduce operator.  reduce is a well-known function in functional programming that converts data collection into a single atomic value by a predetermined rule.  In RAC, this function is <i>-foldLeftWithStart: reduce:</i> or <i>-foldLeftWithStart: reduce :</i> . <br><br><pre> <code class="objectivec hljs">[unreadStatuses.rac_sequence foldLeftWithStart:@<span class="hljs-number"><span class="hljs-number">0</span></span> reduce:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *accumulator, <span class="hljs-built_in"><span class="hljs-built_in">NSNumber</span></span> *unreadStatus) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> @(accumulator.integerValue + unreadStatus.integerValue); }];</code> </pre><br>  The last thing that remains unclear is, why do we need <i>switchToLatest</i> ? <br><br>  Without it, we get the signal of the signals (since we convert the value of the array into a signal), and if you subscribe to unreadStatusChanged, you will receive the signal in the next block, not the value.  We can use either <i>-flatten</i> or <i>-switchToLatest</i> (which is <i>flattened</i> , but with a slight difference) to fix this. <br><br>  flatten means that the subscriber who is currently <i>flattened</i> will receive the values ‚Äã‚Äãsent using the signal that is returned from the transformation.  While -flatten receives a signal from a signal and combines them together with the following values ‚Äã‚Äãsent to any of them, <i>-switchToLatest</i> does the same, but only redirects values ‚Äã‚Äãfrom the last signal. <br><br>  In our case, this works better since we do not want to receive changes from the old version of our <i>dataSource</i> .  The signal is ready and we can use it, let's make a side effect: <br><br><pre> <code class="objectivec hljs">RAC([<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span> sharedApplication], applicationIconBadgeNumber) = unreadStatusChanged;</code> </pre><br>  Have you noticed how the problem statement is related to the code?  We just wrote declaratively what we want to do in one place.  We do not need to maintain an intermediate state. <br><br>  Sometimes you have to go into the framework documentation to find the right operators to formulate a custom signal, but it's worth it. <br><br>  <b>Task # 2</b> <br><br>  Here is another task that demonstrates the capabilities of the framework.  We had a chat list screen, and the task was: with the screen open with the chat list, display the latest chat message.  Here is what the generated signal looks like: <br><br><pre> <code class="objectivec hljs">RACSignal *chatReceivedFirstMessage = [[RACObserve(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, dataSource) map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *chats) { RACSequence *sequence = [[[chats rac_sequence] filter:^<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>(ChatViewModel *chat) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ![chat hasMessages]; }] map:^<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>(ChatViewModel *chat) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[RACObserve(chat, lastMessage) ignore:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>] take:<span class="hljs-number"><span class="hljs-number">1</span></span>]; }] ; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [RACSignal merge:sequence]; }] switchToLatest];</code> </pre><br>  Let's see what it consists of. <br><br>  This example is very similar to the previous one.  We observe an array, the map operator converts values ‚Äã‚Äãinto a signal, and taking into account only the latest signals. <br><br>  First we filter our <i>dataSource</i> in the transform block, because we are not interested in chats that have messages. <br><br>  Then we convert the values ‚Äã‚Äãinto signals, again using <i>RACObserve</i> . <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[RACObserve(chat, lastMessage) ignore:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>] take:<span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br>  Since the signal generated by <i>RACObserve</i> will start with an initial property value that is nil, we must ignore it. -Ignore :.  The operator is what we need. <br><br>  The second part of the task is to consider only the first incoming message <i>-Take:.</i>  Will take care of this.  The signal will be completed (and deleted) immediately after receiving the first value. <br><br>  Just to clarify everything.  There are three new signals that we have created in this code.  The first one was created by the <i>RACObserve</i> macro, the second on the <i>-ignore</i> call <i>: the</i> operator on the first newly created signal, and the third on the <i>-take</i> call <i>:</i> on the signal created by <i>-ignore:</i> <br><br>  As in the previous example, we need one signal based on the generated signals.  We use <i>-merge:</i> to create a new merged stream, since we do not care about the values, as in the previous example. <br><br>  Side effect time! <br><br><pre> <code class="objectivec hljs">[chatReceivedFirstMessage subscribeNext:^(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> x) { <span class="hljs-comment"><span class="hljs-comment">// switching to chat screen }];</span></span></code> </pre><br>  <b>Note:</b> <i>We do not use the values ‚Äã‚Äãthat come in the signal.</i>  <i>However, <b>x</b> will contain the received message.</i> <br><br>  Now let's talk a little about the impressions of Reactive Cocoa. <br><br>  <b>What I really like about Reactive Cocoa</b> <br><br>  <b>1.</b> It's easy to start using in projects.  The framework is documented like crazy.  There are many examples on GitHub, with a detailed description of each class and method, a large number of articles, videos and presentations. <br><br>  <b>2.</b> You do not need to completely change your programming style.  First, you can use existing solutions for problems, such as UI bindings, network wrappers, and other solutions with GitHub.  Then, step by step, you can understand all the features of Reactive Cocoa. <br><br>  <b>3.</b> It really changes the way to solve problems from imperative to declarative.  Now that the functional programming style is becoming more and more popular in the IOS community, it is difficult for many to radically change their way of thinking.  Reactive Cocoa helps you make changes because it has many tools that can help you communicate in ‚Äúwhat to do‚Äù style, not ‚Äú <b>how to</b> ‚Äù. <br><br>  <b>What I don't like about Reactive Cocoa</b> <br><br>  <b>1.</b> Extensive use of macros RAC () or RACObserve (). <br><br>  <b>2.</b> Sometimes it can be difficult to debug the code, since using RACSignals leads to deep stack traces. <br><br>  <b>3.</b> Not <i>type-safe</i> (you never know what type to expect in the <i>subscribeNext</i> block).  The best solution in this case is to document the signals in the public interface, as an example: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Returns a signal which will send a User and complete or error. */</span></span> -(RACSignal *)loginUser;</code> </pre><br>  <b>I also can not fail to mention Swift</b> <br><br>  Reactive Cocoa is written in Objective-C and specifically for Objective-C.  But, of course, now, when Swift is gaining popularity, framework developers do not sit idle.  They actually write the Swift API, for use with Reactive Cocoa (Great Swiftening Close).  Modestly, we see the new version 3.0 with blackjack and whores, generics and operator overloading. <br><br>  I'm sure after this the RAC will get even more fans.  Soon, perfectionists who curse macros and non-security types will have no arguments to protect themselves and not use Reactive Cocoa. <br><br><h3>  Conclusion </h3><br>  A functional reactive approach can simplify solutions for your daily tasks.  Perhaps, first, the concept of RAC may seem too complicated, its decisions are too cumbersome, and huge, and the number of operators will confuse you greatly.  But later, it will become clear that all this has a simple idea. <br><br>  You present the data (input or output) as a stream.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flow, as a pipe of events (data, errors, verification). The signal and sequence are stream. Signal controlled flow: when it has something, it will transfer it to you, user input, asynchronous booting from disk, for example. The sequence is a pull-out drive: when you need something, you will draw it from the sequence ‚Äî collections, for example. All other transformation and union operators all of these things together (pre-formation, filter, union, switchToLatest, choke, etc.). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you should remember that all events are delivered to subscribers in the stream in which they were created. If you need to specify that, apply this </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RACScheduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (a class similar to GCD queues, but with the option to cancel) using the </font><i><font style="vertical-align: inherit;">-deliverOn</font></i><font style="vertical-align: inherit;"> operator</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a rule, you only need to explicitly specify [RACScheduler mainThreadScheduler] to update the interface, but you can write your own implementation of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RACSceduler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when you are dealing with something specific, like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoreData</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/317992/">https://habr.com/ru/post/317992/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317982/index.html">Discord. Teaser for the outgoing year - Search, Screenshot, Video chat, Audit logs and Channel Management</a></li>
<li><a href="../317984/index.html">Vacation Basil or the use of MTS traffic accounting errors for a long account lockout</a></li>
<li><a href="../317986/index.html">Delegation rake I stepped on</a></li>
<li><a href="../317988/index.html">New winter internship for developers at Redmadrobot</a></li>
<li><a href="../317990/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 19</a></li>
<li><a href="../317994/index.html">A selection of machine learning frameworks</a></li>
<li><a href="../317996/index.html">Non-computable functions on the example of the Busy Beaver Game</a></li>
<li><a href="../317998/index.html">Bad advice for your startup</a></li>
<li><a href="../318000/index.html">Using Service Worker to create a botnet</a></li>
<li><a href="../318002/index.html">How we met with Agile & Scrum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>