<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>String.Intern makes strings more interesting.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface from translator: 

 Passing / conducting interviews, one has to deal with questions that reveal a general understanding of the work of .NET. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>String.Intern makes strings more interesting.</h1><div class="post__text post__text-html js-mediator-article">  <i>Preface from translator:</i> <br><br>  Passing / conducting interviews, one has to deal with questions that reveal a general understanding of the work of .NET.  In my opinion, questions about the work of a ‚Äúgarbage collector‚Äù are most popular among such questions, but once I was asked a question about string interning.  And he, frankly, put me in a dead end.  The search in runet issued several articles, but they did not give answers to the questions I was looking for.  I hope my translation of the <a href="http://broadcast.oreilly.com/2010/08/understanding-c-stringintern-m.html">article by</a> Andrew Stellman (author of the book <a href="http://shop.oreilly.com/product/0636920000679.do">‚ÄúHead First C #‚Äù</a> ) will fill this gap.  I think this material will be useful for beginner .NET developers and those who were interested in what is interning strings in .NET. <br><br><h4>  String.Intern makes strings more interesting. </h4><br>  One of the first things that every C # novice developer encounters is working with strings.  I show the basics of working with strings at the beginning of Head First C #, as they do in almost every other C # book.  So one shouldn't be surprised that C # junior level and middle level developers feel that they got a pretty good row-by-line basis.  But the lines are more interesting than they seem.  One of the most interesting aspects of strings in C # and .NET is the String.Intern method.  Understanding how this method works can improve your skills in C # development.  In this post, I will do a short tutorial for the String.Intern method to show you how it works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Note:</b> At the end of this post, I'm going to show something ‚Äúunder the hood‚Äù using ILDasm.  If you have never worked with ILDasm before, this will be a good opportunity to get acquainted with a very useful .NET tool. <br><a name="habracut"></a><br><h5>  Some basics of working with strings </h5><br>  Let's start with a brief overview of what is expected from the <i>System.String</i> class.  (I will not go into details - if someone wants a post about the basics of strings in .NET, add a comment or contact me at <a href="http://www.stellman-greene.com/">Building Better Software</a> , and I will be happy to discuss a possible article together!) <br><br>  Create a new console application in Visual Studio.  (Everything works the same way from the command line if you want to use csc.exe to compile the code, but for the sake of ease of perception of the material, let's stick with the development in Visual Studio.) Here is the code for the <i>Main ()</i> method - the entry point of the console application: <br><br>  <b>Program.cs:</b> <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> a = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> b = a; a = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}, {1}"</span></span>, a, b); Console.WriteLine(a == b); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(a, b)); } }</code> </pre> <br>  There should be no surprises in this code.  The program prints three lines to the console (remember, if you are working in Visual Studio, use Ctrl-F5 to start the program outside the debugger; also <b>‚ÄúPress any key ...‚Äù</b> will be added to the program to prevent the console window from closing): <br><br>  <b>hello, hello world</b> <b><br></b>  <b>False</b> <b><br></b>  <b>False</b> <b><br></b> <br>  The first <i>WriteLine ()</i> prints two lines.  The second compares them using the equality operator <i>==</i> , which returns <i>False</i> , because the strings do not match.  And the last one compares them to see if both variables refer to the same <i>String</i> object.  Since this is not the case, the method displays the value <i>False</i> . <br>  Then add these two lines to the end of the <i>Main ()</i> method: <br><br><pre> <code class="cs hljs"> Console.WriteLine((a + <span class="hljs-string"><span class="hljs-string">" world"</span></span>) == b); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals((a + <span class="hljs-string"><span class="hljs-string">" world"</span></span>), b));</code> </pre><br>  And again you get a pretty obvious answer.  The equality operator returns <i>True</i> , since both strings are equal.  But when you used the concatenation of the strings ‚ÄúHello‚Äù and ‚Äúworld‚Äù, the <i>+</i> operator combines them and returns a new instance of <i>System.String</i> .  That is why <i>object.ReferenceEquals ()</i> quite reasonably returns <i>False</i> .  The <i>ReferenceEquals ()</i> method returns <i>True</i> only if both arguments refer to the same object. <br>  This method allows you to work normally with objects.  Two different objects can have the same values.  This behavior is quite practical and predictable.  If you create two ‚Äúhouse‚Äù objects and set all the properties to the same values, you will have two identical objects of the ‚Äúhouse‚Äù type, but these will be different objects. <br><br>  Does it still seem a bit confusing?  If so, I definitely recommend paying attention to the first few chapters of <a href="http://www.headfirstlabs.com/books/hfcsharp/">‚ÄúHead First C #‚Äù</a> , which will give you an idea of ‚Äã‚Äãwriting programs, debugging, and using objects and classes.  You can download them as <a href="http://www.headfirstlabs.com/books/hfcsharp/hfcsharp_free_book.pdf">free scrapbooks from this book</a> . <br>  So while we are working with strings, everything is fine.  But as soon as we start playing links to strings, things get a little weird. <br><br><h5>  Something is wrong with this link ... </h5><br>  Create a new console application.  The code below is for it.  But, before compiling and executing, carefully look at the code.  Try to guess what it will display in the console? <br><br>  <b>Program.cs:</b> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> hello = <span class="hljs-string"><span class="hljs-string">"hello"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> helloWorld = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> helloWorld2 = hello + <span class="hljs-string"><span class="hljs-string">" world"</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}, {1}: {2}, {3}"</span></span>, helloWorld, helloWorld2, helloWorld == helloWorld2, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(helloWorld, helloWorld2)); } }</code> </pre><br>  Now run the program.  Here is what it displays in the console: <br><br>  <b>hello world, hello world: True, False</b> <br><br>  And so, this is exactly what we expected.  In the <i>helloWorld</i> and <i>helloWorld2</i> objects, the strings contain ‚ÄúHello world", so they are equal, but the links are different. <br>  Now add this code to the bottom of your program: <br><br><pre> <code class="cs hljs"> helloWorld2 = <span class="hljs-string"><span class="hljs-string">"hello world"</span></span>; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0}, {1}: {2}, {3}"</span></span>, helloWorld, helloWorld2, helloWorld == helloWorld2, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(helloWorld, helloWorld2));</code> </pre><br>  Run it.  This time the code will display the following line in the console: <br><br>  <b>hello world, hello world: True, True</b> <br><br>  Wait, it turns out that now <i>HelloWorld</i> and <i>HelloWorld2</i> refer to the same line?  Perhaps this behavior may seem strange to some, or at least a little unexpected.  We did not change the value of <i>helloWorld2</i> at all.  Many end up thinking something like this: ‚Äúthe variable was already equal to the‚Äú hello world ‚Äù.  Setting the ‚Äúhello world‚Äù one more time should not change anything. ‚ÄùSo what's the deal?  Let's figure it out. <br><br><h5>  What is String.Intern?  (plunging into the internment pool ...) </h5><br>  When using strings in C #, the CLR does something tricky and this is something called string interning.  This is a way to store one copy of any string.  If you store in a hundred or, even worse, in a million string variables the same value will turn out that the memory for storing the values ‚Äã‚Äãof the strings will be allocated again and again.  String interning is a way around this problem.  The CLR maintains a table called the internment pool.  This table contains one unique link to each row that is either declared or programmatically created during the execution of your program.  The .NET Framework provides two useful methods for interacting with an internment pool: <i>String.Intern ()</i> and <i>String.IsInterned ()</i> . <br><br>  The <i>String.Intern ()</i> method works in a very simple way.  You pass it a string as an argument.  If this string is already in the internment pool, the method returns a reference to this string.  If it is not already, it adds the string to the pool and returns a link to it.  Here is an example: <br><br><pre> <code class="cs hljs"> Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals( String.Intern(helloWorld), String.Intern(helloWorld2)));</code> </pre><br>  This code will display True, even if <i>HelloWorld</i> and <i>HelloWorld2</i> references two different string objects, because they both contain the string "Hello World". <br>  Stop for a minute.  It is worth a little more to sort out <i>String.Intern ()</i> because sometimes the method gives slightly illogical at first glance results.  Here is an example of this behavior: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] {<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-string"><span class="hljs-string">'c'</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o = String.Copy(a); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(o, a)); String.Intern(o.ToString()); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(o, String.Intern(a)));</code> </pre><br>  Running the code will output two lines to the console.  The first <i>WriteLine ()</i> method will show the value <i>False</i> , and this is understandable, since the <i>String.Copy ()</i> method creates a new copy of the string and returns a reference to the new object.  But why by first <i>executing String.Intern (o.ToString ())</i> then <i>String.Intern (a)</i> returns a reference to <i>o</i> ?  Stop for a moment to think about it.  This becomes even more illogical if you add three more lines: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> o2 = String.Copy(a); String.Intern(o2.ToString()); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(o2, String.Intern(a)));</code> </pre><br>  It seems that these lines of code did the same thing, only with the new variable of the object <i>o2</i> .  But in the last, <i>WriteLine ()</i> will print <i>False</i> .  So what happens? <br><br>  This little mess will help us figure out what's going on under the hood of <i>String.Intern ()</i> and the internment pool.  The first thing you need to understand for yourself is that the method of a string object in <i>ToString ()</i> always returns a reference to itself.  The variable o points to a string object containing the value ‚Äúabc‚Äù, so calling your own <i>ToString ()</i> method returns a reference to this string.  So, that's what happens. <br>  At the beginning, <i>a</i> points to the line 1 object, which contains ‚Äúabc‚Äù.  The variable <i>o</i> points to another object of line number 2 which also contains ‚Äúabc‚Äù.  A call to <i>String.Intern (o.ToString ())</i> adds a reference to string No. 2 in the internment pool.  Now that the string object number 2 is in the internment pool, at any time, <i>String.Intern ()</i> calling with the ‚Äúabc‚Äù parameter will return a reference to the string object number 2. <br>  Therefore, when you pass the variable <i>o</i> and <i>String.Intern (a)</i> to the <i>ReferenceEquals ()</i> method, it returns <i>True</i> , because <i>String.Intern (a)</i> returned a reference to the object of string No. 2.  Now we have created a new <i>o2</i> variable and used the <i>String.Copy ()</i> method to create another object of type <i>String</i> .  This will be the object of line number 3, which also contains the string "abc".  The call to <i>String.Intern (o2.ToString ())</i> adds nothing to the internment pool this time, because ‚Äúabc‚Äù is already there, but it returns a pointer to the string # 2. <br>  So this <i>Intern ()</i> call actually returns a reference to line number 2, but we discard it instead of assigning it to a variable.  We could do something like this: <i>string q = String.Intern (o2.ToString ())</i> , which would make the variable <i>q a</i> reference to the string object # 2.  That is why the last <i>WriteLine ()</i> displays <i>False,</i> since this is a comparison of the line 3 reference with a line 2 reference. <br><br><h5>  Use <i>String.IsInterned ()</i> to check whether a string is in an internment pool. </h5><br>  There is another, somewhat paradoxically named method that is useful when dealing with interned strings: <i>String.IsInterned ()</i> .  It takes a reference to the string object.  If this string is in the intern pool, it returns a reference to the interned string of the string; if it is not already in the intern pool, then the method returns <i>null</i> . <br>  The reason why its name sounds a bit illogical is that this method starts with ‚ÄúIs‚Äù but does not return a boolean type, as many programmers expect. <br>  When working with the <i>IsInterned ()</i> method to display the fact that the string is not in the internment pool, it is convenient to use a null-coalescing operator - <i>??</i>  .  For example, writing: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> o = String.IsInterned(str) ?? <span class="hljs-string"><span class="hljs-string">"not interned"</span></span>;</code> </pre><br>  Now the <i>IsInterned ()</i> result is returned to the variable o if it is not null, or the string ‚Äúnot interned‚Äù if the string is not in the intern pool. <br>  If this is not done, then the <i>Console.WriteLine ()</i> method will print empty lines (what this method does when it encounters <i>null</i> ). <br>  Here is a simple example of how String.IsInterned () works: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] {<span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-string"><span class="hljs-string">'z'</span></span>}); Console.WriteLine(String.IsInterned(s) ?? <span class="hljs-string"><span class="hljs-string">"not interned"</span></span>); String.Intern(s); Console.WriteLine(String.IsInterned(s) ?? <span class="hljs-string"><span class="hljs-string">"not interned"</span></span>); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals( String.IsInterned(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>, <span class="hljs-string"><span class="hljs-string">'z'</span></span> })), s));</code> </pre><br>  The first <i>WriteLine ()</i> statement will display <b>"not interned"</b> in the console, because "xyz" is not yet in the internment pool.  The second <i>WriteLine ()</i> statement prints <b>"xyz"</b> because the internment pool already contains "xyz".  And the third <i>WriteLine ()</i> will print <b>True</b> , since the object <i>s</i> points to the object added to the internment pool. <br><br><h5>  Literals are interned automatically. </h5><br>  Add just one line to the end of the method and run the program again: <br><br><pre> <code class="cs hljs"> onsole.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(<span class="hljs-string"><span class="hljs-string">"xyz"</span></span>, ));</code> </pre><br>  something completely unexpected will happen! <br>  The program will never display <b>"not interned"</b> , and the last two <i>WriteLine ()</i> methods will show <b>False</b> !  If we comment out the last line, then the program acts exactly as you expected.  Why?!  How did adding the code at the end of the program change the behavior of the program code over it?  This is very, very strange! <br><br>  It seems really strange the first time you come across this, but this does make sense.  The reason for changing the behavior of the entire program is that the code contains the literal "xyz".  And when you add a literal to your program, the CLR automatically adds it to the internment pool even before the program starts.  Comment on this line, you remove the literal from the program and the internment pool will no longer contain the string "xyz". <br>  Understanding that ‚Äúxyz‚Äù is already in the internment pool when the program is started, since this line appeared in the code in the form of a literal, this change in the behavior of the program immediately becomes understandable.  <i>String.IsInterned (s)</i> no longer returns <i>null</i> .  Instead, it returns a reference to the literal "xyz", which also explains why <i>ReferenceEquals ()</i> returns False.  This is due to the fact that the string <i>s</i> will never be added to the internment pool (‚Äúxyz‚Äù is already in the pool, pointing to another object). <br><br><h5>  The compiler is smarter than you think! </h5><br>  Change the last line of code to this: <br><br><pre> <code class="cs hljs"> Console.WriteLine( <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.ReferenceEquals(<span class="hljs-string"><span class="hljs-string">"x"</span></span> + <span class="hljs-string"><span class="hljs-string">"y"</span></span> + <span class="hljs-string"><span class="hljs-string">"z"</span></span>, s));</code> </pre><br>  Run the program.  It works exactly the same as if you used the literal "xyz"!  Is <i>+</i> not an operator?  Isn't this a method that runs on a CLR runtime?  If this is the case, then there must be code that will prevent the literal "xyz" from being interned. <br>  In fact, that is what happens if you replace <i>‚Äúx‚Äù + ‚Äúy‚Äù + ‚Äúz‚Äù</i> with <i>String.Format ("{0} {1} {2}", 'x', 'y', 'z')</i> .  Both lines of code return "xyz".  Why, using the <i>+</i> operator for concatenation, we get the behavior as if you used the "xyz" literal, although at the same time as <i>String.Format ()</i> runs at runtime? <br>  The easiest way to answer this question is to see what we actually get when compiling the code <i>‚Äúx‚Äù + ‚Äúy‚Äù + ‚Äúz‚Äù</i> . <br><br>  <b>Program.cs:</b> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"x"</span></span> + <span class="hljs-string"><span class="hljs-string">"y"</span></span> + <span class="hljs-string"><span class="hljs-string">"z"</span></span>); } }</code> </pre><br>  The next step is to figure out that the compiler has built an application of the executable type.  For this we will use ILDasm.exe, MSIL disassembler.  This tool is installed with each version of Visual Studio (including Express editions).  And even if you do not know how to read IL, you can understand what is happening. <br><br>  Run Ildasm.exe.  If you are using a 64-bit version of Windows, run the following command: <b>"% ProgramFiles (x86)% \ Microsoft SDKs \ Windows \ v7.0A \ Bin \ Ildasm.exe"</b> (including quotes), either from the <b>Start &gt;&gt; Run window</b> , or from the command line.  If you are using a 32-bit version of Windows, you should run the following command: <b>"% ProgramFiles% \ Microsoft SDKs \ Windows \ v7.0A \ Bin \ ildasm.exe"</b> . <br><br><div class="spoiler">  <b class="spoiler_title">If you have .NET Framework 3.5 or earlier</b> <div class="spoiler_text">  If you have .NET Framework 3.5 or earlier, you may need to search for ildasm.exe in the adjacent folders.  Launch the Explorer window and navigate to the Program Files folder.  As a rule, the necessary program is located in the Microsoft SDKs \ Windows \ vX.X \ bin folder.  In addition, you can run the command line from the ‚ÄúVisual Studio Command Prompt‚Äù which is located in the Start menu, then type ‚ÄúILDASM‚Äù to launch it. </div></div><br><br>  This is how ILDasm looks at the first launch: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/33b/070/e45/33b070e454ca3dca8c1f3e6a05745372.png"><br><br>  Then compile your code into an executable file.  Click on the project in <i>Solution Explorer</i> - the <i>Project Folder</i> field should be located in the <i>Properties</i> window.  Double click on it and copy.  Going to the ILDasm window, select <i>File &gt;&gt; Open</i> in the menu, and paste the path to the folder.  Then go to the bin folder.  Your executable file should be located either in the <i>bin \ Debug</i> or <i>bin \ Release folder</i> .  Open the executable file.  ILDasm should show you the contents of the assembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e56/c95/5ba/e56c955ba8cf97a60fdd879c682927e5.png"><br><br>  (If you need to refresh the memory of how assemblies are created, see this post for an understanding of <a href="http://broadcast.oreilly.com/2010/07/understanding-c-namespaces-and.html">C # and .NET assemblies and namespaces</a> ). <br>  Expand the Program class and double-click the <i>Main ()</i> method.  After these actions, a disassembled method code should appear: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/483/ecd/4bb/483ecd4bb76bb5642976c42f2bff1750.png"><br><br>  You do not need to know IL to see the presence of the literal "xyz" in the code.  If you close ILDasm, and then change the code to use "xyz" instead of "x" + "y" + "z", disassembled the IL code looks exactly the same!  This is because the compiler is smart enough to replace "x" + "y" + "z" with "xyz" during compilation, so you do not have to spend extra operations on method calls that will always return "xyz".  And when a literal is compiled into a program, the CLR adds it to the intern pool when the program starts. <br><br>  The material in this article should give you a good idea of ‚Äã‚Äãstring interning in C # and .NET.  In principle, this is even more than necessary to understand the work of string interning.  If you are interested in learning more, a good springboard is the <b>"Performance Considerations" section</b> on MSDN's <a href="http://msdn.microsoft.com/en-us/library/system.string.intern.aspx">String.Intern pages</a> . <br><br>  <b>PS:</b> Thanks to the team for diligent reading and objective criticism of the translation. </div><p>Source: <a href="https://habr.com/ru/post/224281/">https://habr.com/ru/post/224281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224253/index.html">Competition of flying robots, stage number 2: now not a million, but 5 times 200 thousand times</a></li>
<li><a href="../224255/index.html">Short post about the benefits of search engine optimization</a></li>
<li><a href="../224273/index.html">See you at DevCon 2014!</a></li>
<li><a href="../224275/index.html">Redmine warning plugin</a></li>
<li><a href="../224279/index.html">High-frequency trading and everything you need to know about it. Part 1</a></li>
<li><a href="../224283/index.html">A little useful notes about Steam</a></li>
<li><a href="../224285/index.html">Encryption and generation of random numbers in Android applications. Test cases</a></li>
<li><a href="../224287/index.html">CLRium. How to create any conference + buns for the upcoming St. Petersburg meeting</a></li>
<li><a href="../224289/index.html">Writing MarkerInfoWindow for osmdroid</a></li>
<li><a href="../224291/index.html">MVP for 7 weeks. How it was</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>