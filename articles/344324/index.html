<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Continuous integration and deployment of Docker in GitLab CI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this tutorial, we‚Äôll look at how to configure the continuous integration and deployment of a Flask application on a Docker Swarm through GitLab CI....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Continuous integration and deployment of Docker in GitLab CI</h1><div class="post__text post__text-html js-mediator-article">  In this tutorial, we‚Äôll look at how to configure the continuous integration and deployment of a Flask application on a Docker Swarm through GitLab CI. <br><br>  First we will look at setting up the working environment, including creating servers for Docker Swarm nodes.  Then create a simple Flask application with Redis and prepare GitLab CI for continuous delivery. <br><a name="habracut"></a><br>  Container management and load management is not a trivial topic and requires considerable preparation, especially if you plan to self-tune your orchestration system (for example, using Kubernetes).  However, there are tools such as <a href="https://docs.docker.com/get-started/part4/">Docker Swarm</a> or <a href="https://rancher.com/">Rancher</a> , which take control of containers, internal networks and load distribution, and make it possible to deploy a scalable system on their own servers. <br><br>  In addition, GitLab supports Docker well and allows you to connect your own image storage systems (GitLab Registry) in a few simple steps.  And also to track the status of the project and to manage the deployed versions of the application, allowing, if necessary, roll back to the past in one click. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Prerequisites </h2><br>  Before starting, you must ensure that the following conditions are met: <br><br><ul><li>  server installed with GitLab; </li><li>  GitLab is secured using an SSL certificate; </li><li>  SSH key added to GitLab. </li></ul><br>  The official <a href="https://about.gitlab.com/2016/04/11/tutorial-securing-your-gitlab-pages-with-tls-and-letsencrypt/">guide</a> to setting up https in gitlab. <br><br><h2>  Server installation </h2><br>  To configure and run the application in Swarm mode, we need 2 types of servers - a manager and a slave.  In addition, an additional one server will be allocated under GitLab Runner to perform the task of assembling and running containers. <br><br>  We will create virtual servers on the <a href="https://vscale.io/">Vscale</a> platform, however, if you are a user of another service, for example, <a href="https://www.digitalocean.com/">DigitalOcean</a> , then the actions will be similar to those described below. <br><br>  Create three new servers from the Docker image: <br><br><ul><li>  Runner - for GitLab Runner; </li><li>  Manager - Docker Swarm control node; </li><li>  Node1 ‚Äî Docker Swarm's subordinate node. </li></ul><br><img src="https://habrastorage.org/webt/nt/gd/_7/ntgd_7-_yiylvsschtkwtf_vflu.png" alt="Created virtual machines"><br>  <i>We will use the obtained IP addresses further.</i> <br><br><h2>  Protection of the docker service on the management server with a self-signed certificate </h2><br>  <i>Note.</i>  <i>The use of TLS and certification authority management is a topic that requires considerable preparation.</i>  <i>It is advisable to familiarize yourself with the technologies OpenSSL, x509 and TLS before using them in real projects.</i> <br><br>  At the final stage of application deployment in a working Swarm environment, you need a secure connection between GitLab Runner and the Docker service running on the <b>Manager</b> server, which can be seen in the diagram below: <br><br><img src="https://habrastorage.org/webt/z2/s5/al/z2s5alau7qqyozrtggejzny-pfy.jpeg" alt="Server chart"><br>  <i>The process of deploying an application in a production environment.</i> <br><br>  To do this, you need to use a single client certification center (GitLab Runner) and the Docker service (Manager).  After creating a certificate and key for a client, you can use them to remotely connect to the Docker service and perform various operations.  You should be as careful as possible with the storage of client certificates and keys, since they provide complete control over the Docker service. <br><br><h3>  Updating the Docker service on the Manager machine </h3><br>  We will connect via SSH to the <b>Manager</b> server and update Docker, because in the future we will need additional features available in the older version of the Docker API.  Add a repository from Docker developers to get the latest version: <br><br><pre><code class="bash hljs">$ apt-get update $ apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - $ add-apt-repository \ <span class="hljs-string"><span class="hljs-string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \ </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(lsb_release -cs)</span></span></span><span class="hljs-string"> \ stable"</span></span> $ apt-get update</code> </pre> <br>  Install the latest version of Docker: <br><br><pre> <code class="bash hljs">$ apt-get install docker-ce</code> </pre><br>  To check the installation, run the command: <br><br><pre> <code class="bash hljs">$ docker version</code> </pre><br>  The output of the command may differ, as long as both versions of the client and server API are more than 1.24: <br><br><pre> <code class="bash hljs">Client: Version: 17.09.0-ce API version: 1.32 Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:42:18 2017 OS/Arch: linux/amd64 Server: Version: 17.09.0-ce API version: 1.32 (minimum version 1.12) Go version: go1.8.3 Git commit: afdb6d4 Built: Tue Sep 26 22:40:56 2017 OS/Arch: linux/amd64 Experimental: <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><h3>  Creating a certificate and keys </h3><br>  Staying in the Server <b>Manager</b> , let's start creating a certification center (CA).  Go to the new directory: <br><br><pre> <code class="bash hljs">$ mkdir certificates $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> certificates</code> </pre><br>  First you need to create a private and public RSA-key for CA (you will need to come up with a code word of at least 4 characters in length): <br><br><pre> <code class="bash hljs">$ openssl genrsa -aes256 -out ca-key.pem 4096 Generating RSA private key, 4096 bit long modulus ...............................................................................................................................................................................................................................++ ..................................................++ e is 65537 (0x10001) Enter pass phrase <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ca-key.pem: Verifying - Enter pass phrase <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ca-key.pem:</code> </pre><br>  Let's start creating a local certification center.  The data associated with the identification center will be requested.  At the stage of entering the full qualified domain name (FQDN), you need to enter the domain name of the host for which the <b>Manager</b> server is available, but for the purposes of the example (do not use a similar method in the working machines!) We use the word <b>manager</b> to designate the server: <br><br><pre> <code class="bash hljs">$ openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem Enter pass phrase <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ca-key.pem: You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter <span class="hljs-string"><span class="hljs-string">'.'</span></span>, the field will be left blank. ----- Country Name (2 letter code) [AU]: State or Province Name (full name) [Some-State]: Locality Name (eg, city) []: Organization Name (eg, company) [Internet Widgits Pty Ltd]: Organizational Unit Name (eg, section) []: Common Name (eg server FQDN or YOUR name) []:manager Email Address []:your@email.com</code> </pre><br>  Next, create a private key for the server: <br><br><pre> <code class="bash hljs">$ openssl genrsa -out server-key.pem 4096</code> </pre><br>  Now we have a certification center and we can create an SSL certificate signing request (CSR).  The CN (Common Name) field must match the FQDN value used in the previous step: <br><br><pre> <code class="bash hljs">$ openssl req -subj <span class="hljs-string"><span class="hljs-string">"/CN=manager"</span></span> -sha256 -new -key server-key.pem -out server.csr</code> </pre><br>  Additionally, you must specify the IP address of the Server Manager (the machine in which we are currently working): <br><br><pre> <code class="bash hljs"> $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> subjectAltName = DNS:manager,IP:{ IP-} &gt;&gt; extfile.cnf</code> </pre><br>  Create a signed key for the server: <br><br><pre> <code class="bash hljs">$ openssl x509 -req -days 365 -sha256 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> server.csr -CA ca.pem -CAkey ca-key.pem \ -CAcreateserial -out server-cert.pem -extfile extfile.cnf</code> </pre><br>  Create a client key that we will use to access the Docker service: <br><br><pre> <code class="bash hljs">$ openssl genrsa -out key.pem 4096</code> </pre><br>  Create a signature request and additionally specify the type of key usage - for authorization: <br><br><pre> <code class="bash hljs">$ openssl req -subj <span class="hljs-string"><span class="hljs-string">'/CN=client'</span></span> -new -key key.pem -out client.csr $ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf</code> </pre><br>  Get the signed client key: <br><br><pre> <code class="bash hljs">$ openssl x509 -req -days 365 -sha256 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> client.csr -CA ca.pem -CAkey ca-key.pem \ -CAcreateserial -out cert.pem -extfile extfile.cnf</code> </pre><br>  Now you can delete the request files: <br><br><pre> <code class="bash hljs">$ rm -v client.csr server.csr</code> </pre><br>  As a result, we received the following files: <br><br><pre> <code class="bash hljs">$ ls ca-key.pem ca.srl extfile.cnf server-cert.pem ca.pem cert.pem key.pem server-key.pem</code> </pre><br>  Let's leave the terminal with the session on the <b>Manager</b> server open, since we will need it later. <br><br>  Now we have everything needed to set up secure access between the GitLab Runner and the working Swarm environment. <br><br><h2>  Setting secret variables in GitLab CI </h2><br>  We will not store client key information on a Runner machine for security reasons.  For such tasks, GitLab CI implements the function of secret environment variables. <br>  Create a new project in GitLab: <br><br><img src="https://habrastorage.org/webt/qn/id/ff/qnidffzqetw8-vqrmanbixt1bs0.png" alt="New project in GitLab"><br><br>  After creating the project, go to the <b>CI / CD</b> settings: <br><br><img src="https://habrastorage.org/webt/yz/xi/bs/yzxibsuwxbpdsk_o_ycn2t-iquk.png" alt="CI / CD"><br><br>  Open the secret variables area and work with it: <br><br><img src="https://habrastorage.org/webt/by/uu/pz/byuupzyober7yonn-ut6kafam_w.png" alt="Secret variables"><br><br>  We need to add and save three variables with the following file names and values ‚Äã‚Äãthat we created in the previous step: <br><br><ul><li>  variable <b>TLSCACERT</b> value of the file <b>ca.pem</b> ; </li><li>  variable <b>TLSCERT</b> value of the <b>cert.pem</b> file; </li><li>  variable <b>TLSKEY the</b> value of the file <b>key.pem</b> . </li></ul><br>  Let's go back to the terminal with the session on the <b>Manager</b> server and execute the command: <br><br><pre> <code class="bash hljs">$ cat ca.pem ( ) -----BEGIN CERTIFICATE----- MIIFgTCCA2mgAwIBAgIJAMzFvrYTSMoxMA0GCSqGSIb3DQEBCwUAMFcxCzAJBgNV BAYTAkFVMRMwEQYDVQQIDApTb21lLVN0YXRlMSEwHwYDVQQKDBhJbnRlcm5ldCBX ... bI9XGs39F+r8Si5y6oHqkZHMpRX631i2KRA6k4jBPrZrS0MH3OwsCobuat5T1ONH Kx7TFZSuFO25XIut1WucVn5yPWLTKRniMV7dVws9i9x9Sp2Iamk+w2x1GPO6bHtr BWqdORkUEWMs+DTgX2J989AFh7gnYwHZ2Bo7HKlC6IbOlol7b2E/5p7hWrpe7sf+ oQDn1bhgoauhq2AL4BysJfA3uHoA -----END CERTIFICATE-----</code> </pre><br>  Copy this value and add a new secret variable in GitLab: <br><br><img src="https://habrastorage.org/webt/lh/nx/7w/lhnx7wuwfnjykf4ewpr1kxlejly.png" alt="image"><br><br>  Now, using this example, add the remaining values ‚Äã‚Äãof <b>cert.pem</b> and <b>key.pem</b> . <br><br><h2>  Configuring the Docker service on the Managing Server Manager </h2><br>  By default, only the user who owns the process has access to the Docker service.  To perform application deployment operations from a remote host, we need to allow connection from outside, while using the TLS protocol.  We have already received the necessary certificates and keys, it remains to configure Docker to work with them. <br><br>  We will create a separate configuration file explicitly prescribing the hosts for which Docker will be available, so first we need to remove the standard <b>-H</b> parameter, which prescribe the host.  To do this, create a new directory, <b>docker.service.d</b> , in which we will override the parameters for starting the service: <br><br><pre> <code class="bash hljs">$ mkdir -p /etc/systemd/system/docker.service.d</code> </pre><br>  Create a customization file: <br><br><pre> <code class="bash hljs">$ nano /etc/systemd/system/docker.service.d/<span class="hljs-built_in"><span class="hljs-built_in">exec</span></span>-start.conf</code> </pre><br>  Add the following section, for the <b>ExecStart</b> parameter <b>you</b> first need to clear the previous values ‚Äã‚Äãand then specify new ones: <br><br><pre> <code class="bash hljs">[Service] ExecStart= ExecStart=/usr/bin/dockerd</code> </pre><br>  Create a new configuration file: <br><br><pre> <code class="bash hljs">$ nano /etc/docker/daemon.json</code> </pre><br>  And we will write the following text defining the use of the TLS protocol to access the Docker service, as well as the location of the server key and certificate: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"hosts"</span></span>: [<span class="hljs-string"><span class="hljs-string">"tcp://0.0.0.0:2376"</span></span>,<span class="hljs-string"><span class="hljs-string">"fd://"</span></span>], <span class="hljs-string"><span class="hljs-string">"tlsverify"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"tlscacert"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/certificates/ca.pem"</span></span>, <span class="hljs-string"><span class="hljs-string">"tlscert"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/certificates/server-cert.pem"</span></span>, <span class="hljs-string"><span class="hljs-string">"tlskey"</span></span>: <span class="hljs-string"><span class="hljs-string">"/root/certificates/server-key.pem"</span></span> }</code> </pre><br>  For the changes to take effect, restart the Docker service: <br><br><pre> <code class="bash hljs">$ systemctl daemon-reload $ service docker restart</code> </pre><br>  Now we can connect via TLS to our Docker service at <br><br><pre> <code class="bash hljs">[IP  ]:2376</code> </pre><br><h2>  Activate Swarm mode </h2><br>  To begin with, we recommend studying materials on the Swarm mode, for example, on the official <a href="https://docs.docker.com/get-started/part4/">Docker</a> website.  Swarm is a cluster of Docker services located on different physical or virtual machines and behaving as a whole. <br>  The distribution of requests between the existing Docker services is done according to the <b>ingress load balancing</b> scheme, the essence of which is that any request passes through the internal balancing mechanism and then is redirected to the service that can serve the request at the moment. <br>  Scaling is accomplished by specifying the number of replicas of internal services that we will encounter later. <br>  We will activate the Docker Swarm mode on the <b>Manager</b> server on which the cluster manager will be located.  Then we will add the Docker subordinate service from the <b>Node1</b> machine. <br><br>  In the terminal with an open session on the Server <b>Manager,</b> execute the command: <br><br><pre> <code class="bash hljs">$ docker swarm init Swarm initialized: current node (r1mbxr2dyuf48zpm5ss0kvwv7) is now a manager. To add a worker to this swarm, run the following <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: docker swarm join --token SWMTKN-1-5ihkl37kbs13po7htnj9dzzg3gex4i6iuvjho7910crd0hv895-36jw5epwcw3xwpzmqf1mqgod2 { IP-}:2377 To add a manager to this swarm, run <span class="hljs-string"><span class="hljs-string">'docker swarm join-token manager'</span></span> and follow the instructions.</code> </pre><br>  As you can see from the message, the current Docker service has become a manager and is ready to add subordinate hosts through the execution of the specified command.  Copy this command and connect to <b>Node1</b> server via SSH, to add its addition to Swarm: <br><br><pre> <code class="bash hljs">$ docker swarm join --token SWMTKN-1-1lhmuomvb060rnom4jqj8gxc565f4wgwadjs9ucvqx6huwvbfc-6vt1ljdhldxtetjv2hnct7sh4 { IP-}:2377</code> </pre><br>  The result of the successful execution of the command should be the message: <br><br><pre> <code class="bash hljs">This node joined a swarm as a worker.</code> </pre><br>  The next step is to set up a working server, which will do all the work from GitLab CI. <br><br><h2>  Configure Gitlab Runner </h2><br>  The final step in setting up a continuous integration and deployment environment with Docker is to connect the GitLab CI working service, which will be used to complete all the application building and testing. <br>  You can use joint services to perform work, but in this guide we will consider creating your own service on the <b>Runner</b> server created earlier. <br><br>  Connect via SSH to the <b>Runner</b> server.  First you need to install GitLab Runner and connect this server to GitLab. <br>  Add the GitLab developer repository: <br><br><pre> <code class="bash hljs">$ apt update $ apt install curl $ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | bash $ apt-get install gitlab-runner</code> </pre><br>  Let's go back to the GitLab web interface to get the <b>URL</b> and <b>registration-token.</b>  Let's go back to the project settings in the CI / CD section, where we left off last time.  Open the <b>Runner settings</b> section: <br><br><img src="https://habrastorage.org/webt/vb/bv/dt/vbbvdtt_1egu8hljc-12f6zh5ok.png" alt="Runner settings"><br>  In the <b>Runner settings</b> section there is information on connected working hosts: private and open: <br><br><img src="https://habrastorage.org/webt/wa/80/o2/wa80o25cqux8rkxdv8lxpv0q2_u.png" alt="Runner Settings"><br><br>  The <b>Specific Runners</b> block has the necessary <b>URL</b> and <b>registration token</b> values. <br><br>  Let's return to the terminal with the session on the Runner server and replace the values ‚Äã‚Äãwith our own execute the command: <br><br><pre> <code class="bash hljs">$ gitlab-runner register -n \ --url http:// { IP-}/ \ --registration-token _Kof1SxCHzVNcwuZZEwx \ --executor docker \ --description <span class="hljs-string"><span class="hljs-string">"Docker Prod Runner"</span></span> \ --docker-image <span class="hljs-string"><span class="hljs-string">"docker:latest"</span></span> \ --docker-privileged \ --tag-list docker Registering runner... succeeded runner=_Kof1SxC Runner registered successfully. Feel free to start it, but <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> it<span class="hljs-string"><span class="hljs-string">'s running already the config should be automatically reloaded!</span></span></code> </pre><br>  Now we have a working host registered, which will do all the work sent by GitLab CI. <br>  It remains to configure SSH access for the project Git-repository on GitLab. <br>  Create private and public keys by replacing your email-address and leaving all requested values ‚Äã‚Äãby default: <br><br><pre> <code class="bash hljs">$ ssh-keygen -t rsa -b 4096 -C <span class="hljs-string"><span class="hljs-string">"your_email@example.com"</span></span></code> </pre><br>  Next, you need to add information about the GitLab server where the Git repository is located to the list of known hosts to prevent errors during the connection (the IP address needs to be replaced with the IP address of the GitLab server available in the control panel): <br><br><pre> <code class="bash hljs">$ ssh-keyscan -t rsa { IP-} &gt;&gt; .ssh/known_hosts</code> </pre><br>  Then you need to add the public key in GitLab to allow connections from the <b>Runner</b> server.  Copy the key value: <br><br><pre> <code class="bash hljs">$ cat .ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDMY+G6rmx+AZ6Ow1lVr+4ox0HaAaV4xwthCS3ucyI3KsXVV+ltLU0zkFOP8WZoTXCHo38Fpcu5KwYe3V6L/hZ26fNse6WhJ6EvRmVx7wVHyixhpzKj6Jp9zzAf24SbtrjGgNtN4ASKyouU///a3+gtM+eWQYdxavz6wlJ0xgm8MnDqpbCUv1M7IRWsKhejA9vLSXjfdkxQnxVSCOT/FXb/eDsGRTs7WMXYapqeQ0msTXDCFlNDVQaRWZagXpHLRDkeOhRE2rJ6daj8YNKKx0jaatRKIsICqwUljvPgsrnpF9FiUg8n8PTWyYbz3VpwUoIPnFiFXvbgIn8xLb2/4QkFDoZUgyLI+VgrmZmd0HZPWvW5QbMLZ8vwb/Izi0TG/+qoMm8jas0RaUUp18rQAc4GmCLRsFbzN3DsnME31xFa0y/pwA3LK9ptIRivYq82uP5twq0jXpMSji8w+No7kBI5O9VUHmbRYYYWpn+jeKTxmoVORsrCHpAT7Cub0+Ynyq1M7Em0RMqZgdzLsP9rlLwRkc6ZEgqpVQHDZgwJsnQ5qo/6lr18bD9QHSe5t+SSnUbnkmXkp0xb0ivC4XayxCjYVIOoZV2cqyGa+45s7LY+ngPk0Cg+vSMHV8/enEwu1ABdpoGVjaELJOtw1UBr4y9GCyQ0OhKnrzWmqL6+HnEMDQ== your_email@example.com</code> </pre><br>  And add it to GitLab: <br><br><img src="https://habrastorage.org/webt/cd/tg/os/cdtgoss6nkhm0zzw5bq47wqapw8.png" alt="Adding a key to GitLab"><br><br>  Let's move on to creating and completing a simple Flask application that uses two additional services: Nginx to route requests and Redis to store the page's hit counter. <br><br><h2>  Connecting Docker Registry to GitLab </h2><br>  Before creating the application, we need to activate the Docker image storage feature in our GitLab application in order to effectively manage the deployed versions of the application and provide the ability to roll back to previous versions. <br><br>  Connect via SSH to the <b>GitLab</b> server and open the configuration file: <br><br><pre> <code class="bash hljs">$ nano /etc/gitlab/gitlab.rb</code> </pre><br>  Next, add a new address from where the Docker‚Äôs storage will be available, replacing example.com with the name of your host: <br><br><pre> <code class="bash hljs">registry_external_url <span class="hljs-string"><span class="hljs-string">'https://gitlab.example.com:4567'</span></span></code> </pre><br>  Add two more lines with the location of the certificate and key storage.  Since we are using the same domain name as the main GitLab application (if you have not configured HTTPS for GitLab yet, you can do it <a href="https://about.gitlab.com/2016/04/11/tutorial-securing-your-gitlab-pages-with-tls-and-letsencrypt/">now</a> ): <br><br><pre> <code class="bash hljs">registry_nginx[<span class="hljs-string"><span class="hljs-string">'ssl_certificate'</span></span>] = <span class="hljs-string"><span class="hljs-string">"/etc/letsencrypt/live/gitlab.example.com/fullchain.pem"</span></span> registry_nginx[<span class="hljs-string"><span class="hljs-string">'ssl_certificate_key'</span></span>] = <span class="hljs-string"><span class="hljs-string">"/etc/letsencrypt/live/gitlab.example.com/privkey.pem"</span></span></code> </pre><br>  Restart the GitLab service to activate the repository: <br><br><pre> <code class="bash hljs">$ gitlab-ctl reconfigure</code> </pre><br>  Let's move on to the <b>flask-docker-swarm</b> project created earlier in GitLab.  In case of successful activation of the repository, the <b>Registry</b> section will be available in the project menu: <br><br><img src="https://habrastorage.org/webt/b9/_m/l_/b9_ml_he15gz57wxyh8gu-bwckm.png" alt="Registry Check"><br><br>  For further work with the internal image repository, we will need to use a bunch of login and password to connect to it.  We use the ability to add secret variables in GitLab to add a password.  To do this, go to the <b>Settings</b> section and select the <b>CI / CD</b> block: <br><br><img src="https://habrastorage.org/webt/63/y8/ty/63y8tynqphmjfx6u5x_3fvafoxm.png" alt="Adding secret variables"><br><br>  Open the <b>Runner settings</b> section and add a new variable <b>HUB_REGISTRY_PASSWORD</b> , the value of which is the password from the GitLab user account: <br><br><img src="https://habrastorage.org/webt/ak/p0/l7/akp0l7dsbkhypmywuzwdbsudywy.png" alt="Password setting"><br><br><h2>  Create application </h2><br>  The program will be a simple web application that counts the number of visits and displays information about the container in which it is running.  To do this, we need to create several Dockerfile (Docker image configuration files) for each service used (Nginx, Redis, Flask) and specify how they should interact with each other. <br><br>  Open the page of the project created earlier: <br><br><img src="https://habrastorage.org/webt/qu/77/dd/qu77dd7hzkrrbtzs6t_m94kckms.png" alt="Project page"><br><br>  Run the following command to clone the repository and go to the working directory, replacing the domain name: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git@gitlab.example.ru:root/flask-docker-swarm.git $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> flask-docker-swarm</code> </pre><br>  Create inside three directories for each service: <br><br><pre> <code class="bash hljs">$ mkdir nginx $ mkdir web $ mkdir redis</code> </pre><br><h3>  Creating Nginx Service </h3><br>  For the Nginx service, we will need to create three files - a Dockerfile and two configuration files.  Create and record general settings for the entire web server: <br><br><pre> <code class="bash hljs">$ nano nginx/nginx.conf</code> </pre><br>  And write the following text: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#       Nginx  user nginx; #    ,   - #     worker_processes 1; #          error_log /var/log/nginx/error.log warn; #   ,     PID  Nginx- pid /var/run/nginx.pid; events { #      worker_connections 1024; } # http       Nginx c http- http { #         include /etc/nginx/mime.types; #    - default_type text/html; #   - log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; #         Nginx access_log /var/log/nginx/access.log main; #       sendfile on; tcp_nopush on; tcp_nodelay on; #       keepalive_timeout 65; #    gzip    #gzip on; #       include /etc/nginx/conf.d/*.conf; }</span></span></code> </pre><br>  The following file defines the parameters for the virtual server, directly here is the link to the web service where our application will run: <br><br><pre> <code class="bash hljs">$ nano nginx/flask.conf</code> </pre><br>  And write the text: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  server    / server { #   , IP  / ,     listen 80 default_server; # server_name xxx.yyy.zzz.aaa #      ‚ÄúContent-Type‚Äù    charset utf-8; #  Nginx        #location /static { # alias /usr/src/app/web/static; #} #  Nginx   -      (Gunicorn (WSGI server)) location / { #       proxy_pass http://web:5000; #       proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #      client_max_body_size 5M; client_body_buffer_size 5M; } }</span></span></code> </pre><br>  The block with static content is commented out because there will be no additional files in our application, but in the future you can add a static directory in the web service and open this block to efficiently transfer static files. <br><br>  Create a Dockerfile in which we use the finished Nginx image in DockerHub and modify it to use our customization files: <br><br><pre> <code class="bash hljs">$ nano nginx/Dockerfile</code> </pre><br>  And write the following text: <br><br><pre> <code class="bash hljs">FROM nginx:1.13.6 RUN rm /etc/nginx/nginx.conf COPY nginx.conf /etc/nginx/ RUN rm /etc/nginx/conf.d/default.conf COPY flask.conf /etc/nginx/conf.d</code> </pre><br><h3>  Creating a Redis service </h3><br>  For the Redis service, create a Dockerfile: <br><br><pre> <code class="bash hljs">$ nano redis/Dockerfile</code> </pre><br>  With simple content: <br><br><pre> <code class="bash hljs">FROM redis:3.2.11</code> </pre><br>  We do not make additional changes, but in the future they are quite possible, so we will create a separate service. <br><br><h3>  Creating a service with the Flask application </h3><br>  We start the service with the Flask application by creating the main executable file: <br><br><pre> <code class="bash hljs">$ nano web/main.py</code> </pre><br>  Insert the following code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> redis <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Redis, RedisError <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-comment"><span class="hljs-comment"># Connect to Redis redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2) app = Flask(__name__) @app.route("/") def hello(): try: visits = redis.incr("counter") except RedisError: visits = "&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;" html = "&lt;h3&gt;Hello {name}!&lt;/h3&gt;" \ "&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;" \ "&lt;b&gt;Visits:&lt;/b&gt; {visits}" return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits) if __name__ == "__main__": app.run()</span></span></code> </pre><br>  Create a separate file with the dependencies used: <br><br><pre> <code class="bash hljs">$ nano web/requirements.txt</code> </pre><br>  And we list the software packages used: <br><br><pre> <code class="bash hljs">Flask==0.12.2 Redis==2.10.6 Gunicorn==19.7.1 Nose2 Coverage</code> </pre><br>  Set up a simple unit test example for a demonstration in which we check the accessibility of a page.  Create a test file: <br><br><pre> <code class="bash hljs">$ nano web/test_smoke.py</code> </pre><br>  Copy and paste the text: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> unittest <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> app <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicTests</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(unittest.TestCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># executed prior to each test def setUp(self): app.config['TESTING'] = True app.config['WTF_CSRF_ENABLED'] = False app.config['DEBUG'] = False self.app = app.test_client() self.assertEqual(app.debug, False) # executed after each test def tearDown(self): pass def test_main_page(self): response = self.app.get('/', follow_redirects=True) self.assertEqual(response.status_code, 200) if __name__ == "__main__": unittest.main()</span></span></code> </pre><br>  Create a file that will be the entry point of our application: <br><br><pre> <code class="bash hljs">$ nano web/wsgi.py</code> </pre><br>  In which we specify the name of the imported object that Gunicorn will use: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: app.run(host=<span class="hljs-string"><span class="hljs-string">'0.0.0.0'</span></span>)</code> </pre><br>  The last file in the <b>web</b> directory will be the Dockerfile, which will list the commands for creating an image of our service: <br><br><pre> <code class="bash hljs">$ nano web/Dockerfile</code> </pre><br>  With the following content: <br><br><pre> <code class="bash hljs">FROM python:3.6.3 RUN groupadd flaskgroup &amp;&amp; useradd -m -g flaskgroup -s /bin/bash flask WORKDIR /app ADD . /app RUN pip install -r requirements.txt</code> </pre><br><h2>  Creating services based on Docker containers </h2><br>  To create managed services, we use the <b>docker-compose</b> tool, which allows you to specify on which image the container is launched and determines the behavior of the service as a whole.  To do this, create a <b>docker-compose.yml file</b> : <br><br><pre> <code class="bash hljs">$ nano docker-compose.yml</code> </pre><br>  And we write this text, replacing the domain name: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">"3.4"</span></span> services: web: image: gitlab.example.ru:4567/root/flask-docker-swarm/web:<span class="hljs-variable"><span class="hljs-variable">${CI_COMMIT_SHA}</span></span> deploy: replicas: 4 restart_policy: condition: on-failure <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: gunicorn -w 3 --<span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> 0.0.0.0:5000 wsgi:app nginx: image: gitlab.example.ru:4567/root/flask-docker-swarm/nginx:<span class="hljs-variable"><span class="hljs-variable">${CI_COMMIT_SHA}</span></span> deploy: mode: global restart_policy: condition: on-failure ports: - <span class="hljs-string"><span class="hljs-string">"80:80"</span></span> redis: image: gitlab.example.ru:4567/root/flask-docker-swarm/redis:latest deploy: replicas: 1 placement: constraints: [node.role == manager] restart_policy: condition: on-failure ports: - <span class="hljs-string"><span class="hljs-string">"6379"</span></span></code> </pre><br>  Let's take a closer look at the file structure: <br><br><ul><li>  the <b>services</b> block includes a description of all services created; </li><li>  Each service has an <b>image</b> section that defines the image used to create containers based on it.  This recording format allows you to get images from the repository available at <b>gitlab.example.com:4567</b> .  The final argument <b>$ {CI_COMMIT_SHA}</b> is the environment variable associated with the hash value of the current commit, which we use to distinguish the assemblies from each other in this guide; </li><li>  The <b>deploy</b> block is used only when using the <b>docker stack deploy command</b> .  We use three keywords within this block: <br><ul><li>  <b>replicas</b> - the number of copies of the container; </li><li>  <b>placement</b> - location of containers relative to work nodes; </li><li>  <b>restart_policy</b> - conditions for restarting containers; </li></ul><br></li><li>  the opening of ports for communication between services and the external environment is carried out in the <b>ports</b> section; </li><li>  To execute additional commands at the start of the service, the <b>command</b> block is used. </li></ul><br>  To run on a local machine, we need to create an additional <b>docker-compose</b> configuration file for easy testing of the application without using the <b>Nginx</b> service: <br><br><pre> <code class="bash hljs">$ nano docker-compose.override.yml</code> </pre><br>  Insert the following text: <br><br><pre> <code class="bash hljs">version: <span class="hljs-string"><span class="hljs-string">"3.4"</span></span> services: web: image: web environment: - FLASK_APP=wsgi.py - FLASK_DEBUG=1 build: context: ./web dockerfile: Dockerfile <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>: <span class="hljs-string"><span class="hljs-string">'flask run --host=0.0.0.0'</span></span> links: - redis ports: - <span class="hljs-string"><span class="hljs-string">"5000:5000"</span></span> volumes: - ./web/:/usr/src/app/web redis: image: redis build: context: ./redis dockerfile: Dockerfile ports: - <span class="hljs-string"><span class="hljs-string">"6379:6379"</span></span></code> </pre><br>  By structure, the file resembles the main version, but does not use the <b>Nginx</b> service and there is an additional section for building build containers. <br><br>  <b>GitLab CI is</b> managed via the configuration file: <br><br><pre> <code class="bash hljs">$ nano .gitlab-ci.yml</code> </pre><br>  Let's write the following text, changing <b>example.ru</b> to our domain name: <br><br><pre> <code class="bash hljs">image: docker:17.09.0-ce services: - docker:dind before_script: - apk add --update py-pip &amp;&amp; pip install docker-compose stages: - <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> - build - deploy - stage unittests: stage: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> script: - <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> web - pip install -q -r requirements.txt - nose2 -v --with-coverage tags: - docker docker-build: stage: build script: - docker login -u root -p <span class="hljs-variable"><span class="hljs-variable">$HUB_REGISTRY_PASSWORD</span></span> https://gitlab.example.ru:4567/ - docker build -t gitlab.example.ru:4567/root/flask-docker-swarm/nginx:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_SHA</span></span> ./nginx - docker push gitlab.example.ru:4567/root/flask-docker-swarm/nginx:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_SHA</span></span> - docker build -t gitlab.example.ru:4567/root/flask-docker-swarm/web:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_SHA</span></span> ./web - docker push gitlab.example.ru:4567/root/flask-docker-swarm/web:<span class="hljs-variable"><span class="hljs-variable">$CI_COMMIT_SHA</span></span> - docker build -t gitlab.example.ru:4567/root/flask-docker-swarm/redis:latest ./redis - docker push gitlab.example.ru:4567/root/flask-docker-swarm/redis:latest tags: - docker deploy-to-swarm: stage: deploy variables: DOCKER_HOST: tcp://{manager_ip_address}:2376 DOCKER_TLS_VERIFY: 1 DOCKER_CERT_PATH: <span class="hljs-string"><span class="hljs-string">"/certs"</span></span> script: - mkdir -p <span class="hljs-variable"><span class="hljs-variable">$DOCKER_CERT_PATH</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TLSCACERT</span></span></span><span class="hljs-string">"</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$DOCKER_CERT_PATH</span></span>/ca.pem - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TLSCERT</span></span></span><span class="hljs-string">"</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$DOCKER_CERT_PATH</span></span>/cert.pem - <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TLSKEY</span></span></span><span class="hljs-string">"</span></span> &gt; <span class="hljs-variable"><span class="hljs-variable">$DOCKER_CERT_PATH</span></span>/key.pem - docker login -u root -p <span class="hljs-variable"><span class="hljs-variable">$HUB_REGISTRY_PASSWORD</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_REGISTRY</span></span> - docker stack deploy -c docker-compose.yml env_name --with-registry-auth - rm -rf <span class="hljs-variable"><span class="hljs-variable">$DOCKER_CERT_PATH</span></span> environment: name: master url: http://{manager_ip_address} only: - master tags: - docker</code> </pre><br>     <b>DOCKER_HOST</b>  <b>URL</b>  ,        Docker.         <b>Registry</b>  GitLab. <br><br>          <b>$CI_COMMIT_SHA</b>       .   <b>Redis</b>    <b>latest</b>      . <br><br>    : <br><br><ul><li>     <b>image</b> ,          ; </li><li>   <b>services</b>       Docker,    Docker  Docker; </li><li>  <b>before_script</b>  ,       ; </li><li>  <b>stages</b>          ; </li><li>       , , <b>unittests</b> ,        : <br><ul><li>  <b>stage</b>      ; </li><li>  <b>variables</b>     ,    ; </li><li>  <b>script</b>   ,      ; </li><li>  <b>tags</b>    GitLab Runners    . </li></ul><br></li></ul><br><h2>      </h2><br>       .            .    Docker (    Ubuntu 16.04,  Windows   ).     Docker    : <br><br><pre> <code class="bash hljs">$ sudo apt-get update $ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common $ sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \ <span class="hljs-string"><span class="hljs-string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \ </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$(lsb_release -cs)</span></span></span><span class="hljs-string"> \ stable"</span></span> $ sudo apt-get update</code> </pre><br>    Docker: <br><br><pre> <code class="bash hljs">$ sudo apt-get install docker-ce</code> </pre><br>   : <br><br><pre> <code class="bash hljs">$ sudo docker-compose -f docker-compose.override.yml build</code> </pre><br>     ,   : <br><pre> <code class="bash hljs">$ sudo docker-compose -f docker-compose.override.yml up</code> </pre><br>      : <br><br><pre> <code class="bash hljs">localhost:5000</code> </pre><br>      ,    : <br><br><img src="https://habrastorage.org/webt/ft/sz/uh/ftszuhjye0vanq4knrqktsrumis.png" alt=""><br><br>      ,    ,  hostname  ,       ,     <b>web</b> ,  -. <br><br><h2>     </h2><br>     ‚Äî     .                    : <br><br><pre> <code class="bash hljs">$ git add --all $ git commit -m ‚Äúinit‚Äù $ git push origin master</code> </pre><br>        ,  ‚Äú‚Äù    GitLab,       Docker,     Docker Swarm. <br><br>      GitLab   <b>Pipelines</b>   : <br><br><img src="https://habrastorage.org/webt/_x/ot/q5/_xotq55bfauph-i1cbjcj258kn0.png" alt="Pipelines!"><br><br>      ,    <b>Jobs</b>      ,        . <br><br>    <b>Environments</b> : <br><br><img src="https://habrastorage.org/webt/-e/yf/7d/-eyf7dxtunyh4mda73ljxtzjxua.png" alt="Environments"><br><br>        .      <b>master</b> ,          . <br>         ,        ‚Äî     <b>master</b> ,    : <br><br><img src="https://habrastorage.org/webt/ti/b-/rx/tib-rxagaqea-ujxuvc3xaylsxy.png" alt=""><br><br>         <b>Rollback</b> ,    <b>deploy</b>   . <br><br>          ,           , ,  . <br><br>    .       <b>Manager</b> : <br><br><img src="https://habrastorage.org/webt/7v/fh/dh/7vfhdhyurdsll4sdbxo3lhj_aie.png" alt=" "><br>     ,  ,   <b>hostname</b>    4 ,    ,      <b>web</b> . <br> Docker Swarm            .      <b>web</b>     <i> </i> .           <b>Manager</b> ,     (      docker stack deploy)  : <br><br><pre> <code class="bash hljs">$ docker stack ps env_name</code> </pre><br>       GitLab CI        Docker-.  ,              ‚Äî    ,     Docker Swarm             Docker. </div><p>Source: <a href="https://habr.com/ru/post/344324/">https://habr.com/ru/post/344324/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344306/index.html">Life at the Unity Asset Store. Briefly</a></li>
<li><a href="../344310/index.html">Fake design</a></li>
<li><a href="../344312/index.html">Language Lua and Corona SDK (2/3 part)</a></li>
<li><a href="../344314/index.html">Dagger 2 for novice Android developers. Dagger 2. Part 1</a></li>
<li><a href="../344320/index.html">Sparse matrices: how scientists accelerated machine learning on the GPU</a></li>
<li><a href="../344326/index.html">Introduction to VxLAN</a></li>
<li><a href="../344328/index.html">Accelerate the site. How to understand if this is relevant for your site</a></li>
<li><a href="../344330/index.html">The digest of interesting materials for the mobile developer # 233 (December 4 - December 10)</a></li>
<li><a href="../344332/index.html">How to read technical literature: Quora, Reddit and Hacker News Resident Tips</a></li>
<li><a href="../344338/index.html">The prototype of the payment cryptosystem. Adventure project</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>