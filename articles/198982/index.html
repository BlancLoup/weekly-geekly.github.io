<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate Nginx in 5 minutes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Try to repeat it yourself. 
 As a rule, properly configured Nginx server on Linux can handle 500,000 - 600,000 requests per second. But this figure ca...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate Nginx in 5 minutes</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/798/33b/132/79833b13218bd4dba7669c980d239fe4.jpg" alt="image"><br><blockquote>  Try to repeat it yourself. </blockquote><br>  As a rule, properly configured Nginx server on Linux can handle 500,000 - 600,000 requests per second.  But this figure can be very significantly increased.  I would like to draw attention to the fact that the settings described below were used in a test environment and, perhaps, they are not suitable for your combat servers. <br><br>  A moment of banality. <br><br><pre><code class="bash hljs">yum -y install nginx</code> </pre> <br>  For every fireman, let's create a backup of the original config. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.orig vim /etc/nginx/nginx.conf</code> </pre><br>  And now you can pohimichit! <br><a name="habracut"></a><br>  Let's start with the <i><a href="http://nginx.org/ru/docs/ngx_core_module.html">worker_processes</a></i> directive.  If Nginx does the work of loading a processor (for example, SSL or gzipping), then it is optimal to set this directive to a value equal to the number of processor cores.  Winning at a higher value will be obtained only if a very large amount of static is processed. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># This number should be, at maximum, the number of CPU cores on your system. worker_processes 24;</span></span></code> </pre><br>  Also, the <i>worker_processes</i> directive multiplied by the <i><a href="http://nginx.org/ru/docs/ngx_core_module.html">worker_connections</a></i> from the <i>event</i> section will give the maximum possible number of clients. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Determines how many clients will be served by each worker process. worker_connections 4000;</span></span></code> </pre><br>  The last proletarian directive I want to address is <i><a href="http://nginx.org/ru/docs/ngx_core_module.html">worker_rlimit_nofile</a></i> .  This directive specifies how many file descriptors Nginx will use.  For each connection, you need to allocate two dexryptor, even for static files (images / JS / CSS): one to connect to the client, and the second to open the static file.  Thus, the value of <i>worker_rlimit_nofile</i> should be equal to twice the value of <i>Max Clients</i> .  On the system, this value can be set from the command line <i>ulimit -n 200000</i> or using <i>/etc/security/limits.conf</i> . <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Number of file descriptors used for Nginx. worker_rlimit_nofile 200000;</span></span></code> </pre><br>  Now let's deal with logging.  First, let's leave only critical errors. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Only log critical errors. error_log /var/log/nginx/error.log crit</span></span></code> </pre><br>  If you are completely fearless and want to disable logging errors entirely, remember that <i>error_log off</i> will not help you.  You just get the whole log in the <i>off</i> file.  To disable error logging, do this: <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Fully disable log errors. error_log /dev/null crit;</span></span></code> </pre><br>  But access logs are not so scary to turn off completely. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Disable access log altogether. access_log off;</span></span></code> </pre><br>  Or, at least, enable the read / write buffer. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Buffer log writes to speed up IO. access_log /var/log/nginx/access.log main buffer=16k;</span></span></code> </pre><br>  Nginx supports a number of methods for handling connections.  The most <a href="http://wiki.nginx.org/Optimizations">effective for Linux</a> is the <i>epoll</i> method. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># The effective method, used on Linux 2.6+, optmized to serve many clients with each thread. use epoll;</span></span></code> </pre><br>  In order for Nginx to try to accept the maximum number of connections, you need to enable the <i><a href="http://nginx.org/ru/docs/ngx_core_module.html">multi_accept</a></i> directive.  However, if the <i>worker_connections are</i> too small, their limit can be quickly exhausted. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Accept as many connections as possible, after nginx gets notification about a new connection. multi_accept on;</span></span></code> </pre><br>  Of course, we can not do without caching information about: <ul><li>  recently opened files descriptors: their size and modification date; </li><li>  the existence of directories; </li><li>  errors when searching for files: the absence of the file itself, the lack of rights to read, etc. </li></ul><br>  I advise you not to copy the values ‚Äã‚Äãof the caching directives, but to play with them, choosing the best ones for your environment. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Caches information about open FDs, freqently accessed files. open_file_cache max=200000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on;</span></span></code> </pre><br>  The <i><a href="http_core_module.html">sendfile</a></i> directive activates the copying of data between file descriptors by means of the kernel, which is much more efficient than the <i>read () + write ()</i> binding, which requires the exchange of data with user space. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Sendfile copies data between one FD and other from within the kernel. sendfile on;</span></span></code> </pre><br>  After enabling <i>sendfile</i> , you can force Nginx to send HTTP response headers in a single packet, rather than in separate parts. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Causes nginx to attempt to send its HTTP response head in one packet, instead of using partial frames. tcp_nopush on;</span></span></code> </pre><br>  For <i>keep-alive</i> connections, you can turn off buffering ( <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259D%25D0%25B5%25D0%25B9%25D0%25B3%25D0%25BB%25D0%25B0">Nagle's algorithm</a> ).  This will be useful if you frequently request small amounts of data in real time, without receiving an immediate answer, when timely data delivery is important.  A classic example is mouse hover events. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Don't buffer data-sends (disable Nagle algorithm). tcp_nodelay on;</span></span></code> </pre><br>  It is worth paying attention to two more directives for <i>keep-alive</i> connections.  Their purpose looks obvious. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Timeout for keep-alive connections. Server will close connections after this time. keepalive_timeout 30; # Number of requests a client can make over the keep-alive connection. keepalive_requests 1000;</span></span></code> </pre><br>  To free up additional memory allocated for sockets, enable the <i><a href="http_core_module.html">reset_timedout_connection</a></i> directive.  It will allow the server to close the connection of those customers who have stopped responding. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Allow the server to close the connection after a client stops responding. reset_timedout_connection on;</span></span></code> </pre><br>  You can also significantly reduce the timeouts for the directives <i><a href="http_core_module.html">client_body_timeout</a></i> and <i><a href="http_core_module.html">send_timeout</a></i> (the default value of both is 60 seconds).  The first one limits the time for reading the request body from the client.  The second is the response time to the client.  Thus, if the client does not start reading the data in the specified period of time, then Nginx will close the connection. <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Send the client a "request timed out" if the body is not loaded by this time. client_body_timeout 10; # If the client stops reading data, free up the stale client connection after this much time. send_timeout 2;</span></span></code> </pre><br>  And, of course, data compression.  Plus - the only and obvious: reducing the size of traffic sent.  Minus - the only and obvious: does not work for MSIE 6 and below.  You can disable compression for these browsers with the <i>gzip_disable</i> directive, specifying the special mask ‚Äúmsie6‚Äù as the value, which corresponds to the regular expression ‚ÄúMSIE [4-6] \.‚Äù But works faster (thanks to <a href="http://habrahabr.ru/users/hell0w0rd/" class="user_link">hell0w0rd</a> for the <a href="http://habrahabr.ru/post/198982/">comment</a> ). <br><br><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># Compression. gzip on; gzip_min_length 10240; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml; gzip_disable "msie6";</span></span></code> </pre><br>  Perhaps this is all I wanted to talk about.  Let me just say again that you should not copy the above settings one to one.  I advise you to use them one at a time, each time running some kind of utility for load testing (for example, <a href="http://tsung.erlang-projects.org/">Tsung</a> ).  It is very important to understand what settings really speed up your web server.  Methodical testing will save you a lot of time. <br><br><div class="spoiler">  <b class="spoiler_title">PS All settings in one piece for the fearless lazy</b> <div class="spoiler_text"><pre> <code class="nginx hljs"><span class="hljs-comment"><span class="hljs-comment"># This number should be, at maximum, the number of CPU cores on your system. worker_processes 24; # Number of file descriptors used for Nginx. worker_rlimit_nofile 200000; # Only log critical errors. error_log /var/log/nginx/error.log crit events { # Determines how many clients will be served by each worker process. worker_connections 4000; # The effective method, used on Linux 2.6+, optmized to serve many clients with each thread. use epoll; # Accept as many connections as possible, after nginx gets notification about a new connection. multi_accept on; } http { # Caches information about open FDs, freqently accessed files. open_file_cache max=200000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on; # Disable access log altogether. access_log off; # Sendfile copies data between one FD and other from within the kernel. sendfile on; # Causes nginx to attempt to send its HTTP response head in one packet, instead of using partial frames. tcp_nopush on; # Don't buffer data-sends (disable Nagle algorithm). tcp_nodelay on; # Timeout for keep-alive connections. Server will close connections after this time. keepalive_timeout 30; # Number of requests a client can make over the keep-alive connection. keepalive_requests 1000; # Allow the server to close the connection after a client stops responding. reset_timedout_connection on; # Send the client a "request timed out" if the body is not loaded by this time. client_body_timeout 10; # If the client stops reading data, free up the stale client connection after this much time. send_timeout 2; # Compression. gzip on; gzip_min_length 10240; gzip_proxied expired no-cache no-store private auth; gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml; gzip_disable "msie6"; }</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/198982/">https://habr.com/ru/post/198982/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198964/index.html">Helios Kernel - include in javascript, now for nodejs</a></li>
<li><a href="../198970/index.html">Php.net Resource Restored</a></li>
<li><a href="../198974/index.html">Build a simple cartogram Pandas + Vincent</a></li>
<li><a href="../198978/index.html">A century of play - a century of learning. Computer games learning curve</a></li>
<li><a href="../198980/index.html">Functions in PHP 5.6 - what's new?</a></li>
<li><a href="../198984/index.html">ViPNet Password Generator helps users create strong passwords</a></li>
<li><a href="../198986/index.html">Derby.js Log in</a></li>
<li><a href="../198988/index.html">Published a preliminary program of the conference Cloud OS Summit</a></li>
<li><a href="../198992/index.html">Planning the hardware for your OpenStack cluster: answers to your questions</a></li>
<li><a href="../198994/index.html">Applications are open for the MSIT-SE 2014/15 MSIT program at Innopolis University</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>