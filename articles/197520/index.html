<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lock-free data structures. Basics: Memory Model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we looked inside the processor, albeit hypothetical. We found out that in order to correctly execute parallel code, the proce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lock-free data structures. Basics: Memory Model</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/46c/884/494/46c884494f400822ae4d94edc0117627.jpg" align="right"><br>  In the previous article, we looked inside the processor, albeit hypothetical.  We found out that in order to correctly execute parallel code, the processor needs to be prompted to what extent it is allowed to conduct its own internal read / write optimizations.  These tips are memory barriers.  Memory barriers make it possible in one way or another to order memory accesses (more precisely, the cache ‚Äî the processor interacts with the outside world only through the cache).  The ‚Äúseverity‚Äù of this streamlining may be different - each architecture can provide a whole range of barriers ‚Äúto choose from.‚Äù  Using these or other memory barriers, we can build different memory models - a set of guarantees that will be executed for our programs. <br><br>  In this article we will look at the C ++ 11 memory model. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Historical mini-review</b> <div class="spoiler_text">  At first, manufacturers did not publish an open specification of the processor‚Äôs memory model, that is, a set of rules by which a weakly-ordered processor works with memory, thereby hoping, I think, to gain room for maneuver in the future (really, why limit yourself in the development of architecture, taking Any obligations?) But then the manufacturers released the genie from the bottle, - the gigahertz rested against the ceiling, and the manufacturers began to introduce multi-core everywhere.  As a result, the real multi-threading went to the masses.  The first to beat the alarm was the developers of the operating systems: they need to support multi-core in the kernel, and there are no specifications for the weakly ordered architecture.  Then the standardization bodies of languages ‚Äã‚Äãwere tightened: the programs are becoming more parallelized, it is time to standardize the memory model of the language, to give some guarantees for competitive multi-threaded execution, and there are no specifications for the memory model of the processors.  As a result, today almost all modern processor architectures have open memory model specifications, and work on the Java, .NET, C ++ memory model standards has played a significant role in the emergence of such specifications. <br></div></div><br>  C ++ has been famous since ancient times for its ability to express low-level things at a high level.  When developing the C ++ 11 memory model, the task was not to violate this property, that is, to give programmers maximum flexibility.  After analyzing the memory models of other languages ‚Äã‚Äãthat exist at that time (mainly Java) and typical examples of the internal structure of synchronization primitives and lock-free algorithms, the developers of the standard put forward not one, but <i>three</i> memory models: <br><ul><li>  sequential consistency </li><li>  acquire / release semantics </li><li>  relaxed memory ordering (weak order) </li></ul><br>  All these memory models are defined in C ++ with one enumeration - <code>std::memory_order</code> , which has the following 6 constants: <br><ul><li>  <code>memory_order_seq_cst</code> - points to the sequential consistent model </li><li>  <code>memory_order_acquire</code> , <code>memory_order_release</code> , <code>memory_order_acq_rel</code> , <code>memory_order_consume</code> - refer to the model based on acquire / release semantics </li><li>  <code>memory_order_relaxed</code> - indicates a relaxed model </li></ul><br>  Before considering these models, you should decide how to specify the memory model in the program.  Here we must return to atomic operations again. <br>  The operations that I gave in the <a href="http://habrahabr.ru/company/ifree/blog/195948/">article about atomicity</a> , by and large, have nothing in common with those defined in C ++ 11, since the standard <code>memory_order</code> specified as an argument of an atomic operation.  There are two reasons for this: <br><ul><li>  Semantic: in fact, the desired ordering (memory barrier) refers specifically to the <i>atomic operation</i> that we perform.  The alignment of the barriers in the read / write approach is shamanism precisely because the barrier itself is in no way semantically linked to the code in which it is present ‚Äî just an instruction among equivalent ones.  In addition, the read / write placement of the barriers is very dependent on the architecture. </li><li>  Practical: Intel Itanium has a special, distinct from other architectures, way of specifying memory ordering for read / memory instructions and RMW operations.  In Itanium, the ordering type is indicated as an optional flag of the instruction itself: acquire, release or relaxed.  Moreover, there are no separate instructions (memory barriers) for specifying acquire / release semantics in the architecture; there is only an instruction for a heavy <i>full</i> memory barrier </li></ul><br>  Here‚Äôs what <code>atomic&lt;T&gt;</code> operations actually look like: each specialization of the <code>std::atomic&lt;T&gt;</code> class should have at least the following methods <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T, memory_order = memory_order_seq_cst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(memory_order = memory_order_seq_cst)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exchange</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T, memory_order = memory_order_seq_cst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_exchange_weak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;, T, memory_order = memory_order_seq_cst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_exchange_strong</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;, T, memory_order = memory_order_seq_cst)</span></span></span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Separate memory barriers</b> <div class="spoiler_text">  Of course, C ++ 11 has separate free memory barrier functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">atomic_thread_fence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(memory_order)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">atomic_signal_fence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(memory_order)</span></span></span></span>;</code> </pre><br>  <code>atomic_thread_fence</code> allows, in fact, to use the approach of separate read / write barriers, recognized as obsolete.  Although the <code>memory_order</code> streamlining methods themselves <code>memory_order</code> not provide a way to specify a read barrier (Load / Load) or a write barrier (Store / Store). <br>  <code>atomic_signal_fence</code> intended for use in signal handlers.  As a rule, this function does not generate any code, but is a barrier to the compiler. <br></div></div><br>  As you can see, the default memory model in C ++ 11 is sequential consistency.  We will consider it first.  But first, a few words about the compiler barriers. <br><br><h2>  Compiler barriers </h2><br>  Who can reorder the code we write?  We figured out what the processor can do.  But there is another source of reordering - the compiler. <br>  Many methods of optimization (especially global) and heuristics have been developed (and are being developed to this day) under the assumption (perhaps implicitly) of single-threaded execution.  The compiler is quite difficult (rather, even theoretically impossible) to understand that your code is multi-threaded.  Therefore, the compiler needs hints - barriers.  Such a barrier tells the compiler: do not dare <i>to</i> move the code <i>in front of the</i> barrier (mix) into the code <i>behind the</i> barrier, and vice versa.  The compiler barrier itself does not generate any code. <br>  For MS Visual C ++, the compiler barrier is a pseudo-function <code>_ReadWriteBarrier()</code> (this name has always puzzled me: a complete association with the read / write memory barrier, the heaviest memory barrier).  For GCC and Clang, this is an <s>elegant</s> design. <br> <code>__asm__ __volatile__ ( "" ::: "memory" ) <br></code> <br>  It should be noted that assembler inserts <code>__asm__ __volatile__ ( ‚Ä¶ )</code> are also in some way a barrier for GCC / Clang: the compiler does not have the right to throw out or move them up / down the code (this is indicated by the modifier <code>__volatile__</code> ). <br>  The <code>memory_order</code> affect the compiler supporting C ++ 11 as much as the processor ‚Äî they are the barrier of the compiler, limiting the compiler's ability to reorder (i.e., optimize) our code.  Therefore, specifying special barriers of the compiler is not required, unless, of course, the compiler fully supports the new standard. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/432/95c/200/43295c200411de7bb6e385cc2b85c49b.jpg" align="right"><br><h2>  Sequential consistency </h2><br>  Suppose we implemented a lock-free stack (this is the simplest lock-free data structure), compiled it and tested it.  And we get the crust (core file).  What's the matter?  We will look for an error, driving in our minds (no debugger will help us here) line by line the implementation of our lock-free stack, trying to emulate multithreading and answer the question which fatal combination of execution of string K of stream 1 and simultaneously string N of stream 2 led to crash.  Perhaps, we will find and fix some errors, but all the same - our lock-free stack will fall.  Why? <br>  It turns out that what we are doing, trying to find an error and comparing program lines in mind for simultaneously running threads, is called a guarantee of <i>sequential consistency</i> .  This is a strict memory model, which assumes that the processor does everything exactly in the <i>order</i> it is written in the program.  For example, for such a code: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Thread 1 atomic&lt;int&gt; a, b ; a.store( 5 ); int vb = b.load(); // Thread 2 atomic&lt;int&gt; x,y ; int vx = x.load() ; y.store( 42 ) ;</span></span></code> </pre><br>  Valid for sequential consistency are any execution script, except those that swap <code>a.store / b.load</code> and <code>x.load / y.store</code> .  Note that in this code I do not explicitly <code>memory_order</code> argument in the load / store ‚Äî I rely on the default argument value. <br>  The same guarantee applies to the compiler: the compiler is forbidden to reorder our code in such a way that operations <i>after</i> <code>memory_order_seq_cst</code> would be moved above this barrier, and vice versa, operations <i>before the</i> seq_cst barrier cannot be dropped below the barrier. <br>  The sequential consistency model is intuitively close to man, but has a very significant drawback: it is too strict for modern processors.  It leads to the most severe memory barriers, not allowing the processor to fully implement speculative execution.  Therefore, the new C ++ standard adopted the following compromise: <br><ul><li>  The sequential consistency model should be taken as the default model for atomic operations for its severity and clarity. </li><li>  Introduce into C ++ other, weaker memory models that allow realizing the potential of modern architectures. </li></ul><br>  As an addition to the sequential consistency, a model was proposed based on the acquire / release semantics. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22f/803/cde/22f803cdee1a65d6eddcbfaa61ee6cfb.jpg" align="right"><br><h2>  Acquire / release semantics </h2><br>  From the name of the acquire-release semantics, we can conclude that this semantics is somehow connected with the capture and release of resources.  Indeed it is.  Capture of a resource is its reading from memory to the register, release - writing from register to memory: <br><pre> <code class="cpp hljs">load memory, <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> ; membar #LoadLoad | #LoadStore ; <span class="hljs-comment"><span class="hljs-comment">// acquire- //   acquire/release- ... membar #LoadStore | #StoreStore ; // release- store regiser, memory ;</span></span></code> </pre><br>  As you can see, in this code we <code>#StoreLoad</code> using the <code>#StoreLoad</code> heavy barrier.  It can also be noted that both the acquire-barrier and the release-barrier are <i>semi-</i> barriers: acquire does not order previous store-operations with subsequent load / store, and release does not order the previous load with subsequent, nor does the previous store with subsequent load .  This applies to both the processor and the compiler. <br>  Acquire / release are barriers to all code that is <i>between</i> acquire / release.  Some operations <i>before the</i> acquire-barrier can leak (can be reordered by the processor or compiler) into the acquire / release-section, as well as some operations <i>after the</i> release-barrier can be transferred up (again, by the processor or compiler), inside acquire / release -sections  But operations concluded within the purchase-release will not go beyond its limits. <br><br>  Probably the simplest example of using the acquire / release semantics is spin-lock. <br><div class="spoiler">  <b class="spoiler_title">Lock-free and spin-lock</b> <div class="spoiler_text">  It may seem strange that in the cycle article on lock-free algorithms, I give an example of a lock algorithm.  It is required to explain. <br>  I am not an ardent fan of pure lock-free, by no means.  Yes, a clean lock-free (and even more so a wait-free) algorithm makes me happy, and twice as happy if it turns out to be implemented (this does not always happen).  I am a supporter of a pragmatic approach: everything that is effective is good.  Therefore, I do not disdain to apply locks where they can give benefits.  Spin-lock can give a significant benefit in comparison with ordinary mutexes if it ‚Äúprotects‚Äù a very small piece of code - a few assembler instructions.  In addition, spin-lock, despite its simplicity, is an inexhaustible source of all sorts of interesting optimizations. <br></div></div><br>  Here's what the simplest spin-lock looks at acquire / release (C ++ experts will point out that you need to use a special type of <code>atomic_flag</code> to implement spin-lock, but I will build a spin-lock on an atomic variable (not even a boolean) - so clearer from the point of view articles): <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spin_lock</span></span></span><span class="hljs-class"> {</span></span> atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_spin ; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: spin_lock(): m_spin(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} ~spin_lock() { assert( m_spin.load(memory_order_relaxed) == <span class="hljs-number"><span class="hljs-number">0</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nCur; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { nCur = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !m_spin.compare_exchange_weak( nCur, <span class="hljs-number"><span class="hljs-number">1</span></span>, memory_order_acquire )); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_spin.store( <span class="hljs-number"><span class="hljs-number">0</span></span>, memory_order_release ); } };</code> </pre><br>  Note that in this code, the fact that <code>compare_exchange</code> takes its first argument on the link and changes it, if CAS is unsuccessful, it really bothers me!  You have to write a <code>do-while</code> loop with a non-empty body. <br>  In the <code>lock</code> method of mastering blocking, I use acquire-semantics, and in the <code>unlock</code> method, release-semantics (by the way, the acquire / release semantics led its history just out of synchronization primitives: the standard developers carefully analyzed the implementation of various synchronization primitives and derived a acquire / release pattern. ) As I wrote above, the barriers in this case do not allow the code between <code>lock()</code> and <code>unlock()</code> to leak out - that‚Äôs what we need!  And the <i>atomicity of the</i> <code>m_spin</code> variable guarantees us that as long as <code>m_spin=1</code> , no one will be able to acquire a lock - again, that‚Äôs what is required! <br>  In the algorithm, we see that I use <code>compare_exchange_weak</code> .  What it is? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/a6f/a7a/966a6fa7ac47ca43c91847f1c189b00b.jpg" align="right"><br><h3>  Weak and strong CAS </h3><br>  As you remember, the processor architecture can belong to one of two classes: either the processor implements an atomic primitive CAS (compare-and-swap), or a pair of LL / SC (load-linked / store-conditional).  The LL / SC pair makes it possible to implement atomic CAS, but in itself is not atomic for many reasons.  One of these reasons is that the code running inside the LL / SC can be interrupted by the operating system;  for example, it is at this point that the OS decides to force out the current thread.  Accordingly, the store conditional then, after renewal, will not work.  That is, our CAS will return <code>false</code> , although in reality the reason for this <code>false</code> may not be in the data, but in a third-party event - the interruption of the stream. <br>  It is this consideration that prompted the developers of the standard to introduce two <code>compare_exchange</code> primitives - weak and weak.  These primitives are called <code>compare_exchange_weak</code> and <code>compare_exchange_strong</code> .  A weak version <i>may</i> fail, that is, return <code>false</code> , even if the current value of the variable is equal to the expected one.  That is, a weak CAS can break the semantics of CAS and return <code>false</code> , when in fact it is necessary to return <code>true</code> (but not vice versa!) A strong CAS cannot do this: it strictly follows the semantics of CAS.  Of course, it can cost something. <br>  When should a weak be applied, and when should a strong CAS be applied?  I brought this rule for myself: if CAS is used in a cycle (and this is the basic pattern of using CAS) and there are no frills of operations in the cycle (that is, the body of the cycle is easy), then I use <code>compare_exchange_weak</code> - weak CAS.  Otherwise, a strong <code>compare_exchange_strong</code> . <br><br><h3>  Memory order for acquire / release semantics </h3><br>  As I noted above, the following <code>memory_order</code> values ‚Äã‚Äãare defined for acquire / release semantics: <br><ul><li> <code>memory_order_acquire</code> </li> <li> <code>memory_order_consume</code> </li> <li> <code>memory_order_release</code> </li> <li> <code>memory_order_acq_rel</code> </li> </ul><br>  For reading (load), the values ‚Äã‚Äãare <code>memory_order_acquire</code> and <code>memory_order_consume</code> . <br>  For writing (store) - only <code>memory_order_release</code> . <br>  <code>Memory_order_acq_rel</code> is valid only for RMW operations ‚Äî <code>compare_exchange</code> , <code>exchange</code> , <code>fetch_xxx</code> .  In general, an atomic RMW primitive can have acquire-semantics of <code>memory_order_acquire</code> , release-semantics of <code>memory_order_release</code> or both - <code>memory_order_acq_rel</code> .  For RMW operations, these constants define precisely the <i>semantics</i> , since the read-modify-write primitive simultaneously performs atomic reading and writing.  Semantically, an RMW operation can be considered either as acquire-read, or release-write, or both. <br>  The semantics of an RMW operation can be determined only in the algorithm where it is applied.  Often, in lock-free algorithms, we can distinguish parts with something similar to spin-lock: in the beginning we receive (acquire) a certain resource, do something (usually we calculate a new value) and in the end we set (release) a new value of the resource.  If the acquisition of a resource is performed by an RMW operation (usually a CAS), then such an operation is likely to acquire acquire semantics.  If the new value is set by the RMW-primitive (CAS or <code>exchange</code> ), then it probably has a release-semantics.  ‚ÄúIt is very likely‚Äù is inserted for a reason: a detailed analysis of the algorithm is required before one can understand which semantics is suitable for an RMW operation. <br>  If the RMW primitive is executed separately (it is impossible to distinguish the acquire / release pattern), then 3 options are possible for semantics: <br><ul><li>  <code>memory_order_seq_cst</code> - RMW operation is a key element of the algorithm, reordering of the code, transfer of reading and writing up and down can lead to an error </li><li>  <code>memory_order_acq_rel</code> is somewhat similar to <code>memory_order_seq_cst</code> , but the RMW operation is inside the acquire / release section </li><li>  <code>memory_order_relaxed</code> - transferring an RMW operation (its load and store parts) up and down the code (for example, within the purchase / release section, if the operation is inside such a section) does not lead to errors </li></ul><br>  All these tips should be considered only as an attempt to outline some general principles of hanging one or another semantics on the RMW-primitive.  For each algorithm, a detailed analysis should be carried out. <br><br><h3>  Consume semantics </h3><br>  There is a separate, weaker, kind of acquire-semantics - consume-semantics of reading.  This semantics was introduced as a ‚Äúmemory tribute‚Äù to the DEC Alpha processor. <br>  Alpha architecture has a significant difference from other modern architectures: it could break the data dependency.  In this code example: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y; } ; atomic&lt;foo *&gt; pFoo ; foo * p = pFoo.load( memory_order_relaxed ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = p-&gt;x;</code> </pre><br>  She could re-order reading <code>p-&gt;x</code> and actually getting <code>p</code> (do not ask me how this is possible - this <i>is an</i> Alpha <i>property</i> ; I did not have to work with Alpha, so I cannot confirm or deny it). <br>  To prevent such reordering, the consumption semantics was introduced.  It is applicable for the atomic reading of a pointer to a structure, followed by reading the structure fields.  In this example, the <code>pFoo</code> pointer should read like this: <br><pre> <code class="cpp hljs">foo * p = pFoo.load( memory_order_consume ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = p-&gt;x;</code> </pre><br>  Consume semantics is somewhere in the middle between relaxed- and acquire-semantics of reading.  On many modern architectures, it maps to relaxed reading. <br><br><h3>  And once again about CAS </h3><br>  Above, I cited an <code>atomic&lt;T&gt;</code> interface with two CAS weak and strong.  In fact, there are two more variants of CAS - with the additional argument <code>memory_order</code> : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_exchange_weak</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T&amp;, T, memory_order successOrder, memory_order failedOrder </span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_exchange_strong</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T&amp;, T, memory_order successOrder, memory_order failedOrder </span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  What is this argument - <code>failedOrder</code> ? <br>  Recall that CAS is a read-modify-write primitive.  Even in case of failure, it performs atomic reading.  The <code>failedOrder</code> argument just defines the semantics of this reading in the event of a CAS failure.  The values ‚Äã‚Äãare the same as for normal reading. <br>  In practice, the indication ‚Äúsemantics in case of failure‚Äù is rather rarely required.  Of course, it all depends on the algorithm! <br><br><h2>  Relaxed semantics </h2><br>  Finally, the third type of atomic operations model is relaxed semantics, which is applicable to all atomic primitives ‚Äî load, store, all RMW ‚Äî and which imposes <i>almost</i> no restrictions and therefore allows the processor to reorder <i>almost</i> fully, demonstrating its full power.  Why almost? <br>  First, the standard requirement is to respect the <i>atomicity of</i> relaxed operations.  That is, even a relaxed operation must be indivisible, without partial effects. <br>  Secondly, for atomic relaxed-record, speculative writing is prohibited by the standard. <br>  These requirements may impose restrictions on the implementation of atomic relaxed operations in some weakly ordered architectures.  For example, a relaxed load of an atomic variable on Intel Itanium is implemented as <code>load.acq</code> (acquire-read, do not confuse Itanium acquire with C ++ acquire). <br><div class="spoiler">  <b class="spoiler_title">Requiem for Itanium</b> <div class="spoiler_text">  I often mention Intel Itanium in my articles.  You might get the impression that I am a fan of Itanium architecture, which seems to be slowly dying.  No, I'm not a fan, but ... <br>  Itanium VLIW-architecture is somewhat different from others on the principle of building a system of commands.  Memory ordering is specified as a load / store / RMW instruction suffix ‚Äî this is not the case in other modern architectures.  Even the terms used - acquire, release - suggest whether C ++ 11 is written off from Itanium. <br>  If we recall the story, Itanium is the architecture (or its descendant) that we all would have sat on now, if at one time AMD hadn‚Äôt jumped on and released AMD64 - a 64-bit x86 extension.  Intel at this time slowly developed a <i>new architecture</i> for 64-bit computing.  And vaguely hinted at this new architecture.  From hints it was possible to understand what Itanium is waiting for us on the desktop.  By the way, the Maykrosovtovskiy port of Windows and the Visual C ++ compiler for Itanium also indirectly indicate this (has anyone seen working Windows on Itanium?) But the smartest AMD ruined Intel‚Äôs plans, and the latter had to be quickly caught up by implementing 64 bits in x86.  Itanium remained in the server segment, where it was dying slowly, without receiving adequate resources for development. <br>  Meanwhile, Itanium with its ‚Äúbundle‚Äù of instructions in a ‚Äúvery long word‚Äù (VLIW - very long instruction word) is still an interesting and breakthrough processor.  The fact that modern processors themselves do - load their execution units, reordering operations, - in Itanium was entrusted to the compiler.  But the compilers did not cope with this task and generated (and still generate) not very optimal code.  As a result, Itanium‚Äôs productivity declined several times - and only due to the irrational (from Itanium‚Äôs point of view) distribution of instructions among the ‚Äúbundles‚Äù of the VLIW (I don‚Äôt remember what it‚Äôs called in Itanium, but the translation - ‚Äúbundle‚Äù - was remembered), which led to irrational loading of its executive units. <br>  So Itanium is our unrealized future. <br> ,  ,  ,    ?.. <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Happens-before, synchronized-with and other relationships </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The one who is familiar with the C ++ 11 standard will be asked: ‚ÄúWhere are the relations defining the semantics of atomic operations - what happened before, synchronized-with and others?‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will answer - in the standard. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good review in terms of the standard is given in the book Anthony Williams </font></font><a href="http://www.manning.com/williams/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ Concurrency in Action</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="http://www.ozon.ru/context/detail/id/17636939/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is a Russian translation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), the fifth chapter. </font><font style="vertical-align: inherit;">There are many examples detailed in terms of relationship. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The developers of the standard did an important job - they derived the rules (relations) for the C ++ memory model, and these rules did not describe the placement of memory barriers, but guarantees of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interaction of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> threads. </font><font style="vertical-align: inherit;">The result is a compact axiomatic description of the C ++ memory model.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, it is extremely difficult to apply these relationships in practice because of the huge number of options that need to be considered to prove the correctness of the indication </font></font><code>memory_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a more or less complex lock-free algorithm. That is why the default model is sequential consistency - this model does not require at all to specify any special </font></font><code>memory_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arguments for atomic operations. As noted, this model is the braking itself. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of weaker models - acquire / release or relaxed - requires verification of the algorithm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD: </font></font><a href="https://habrahabr.ru/users/cheremin/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cheremin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rightly pointed out the inaccuracy of the last statement. </font><font style="vertical-align: inherit;">Indeed, sequential consistency does not guarantee anything by itself ‚Äî you can write nonsense with its use. </font><font style="vertical-align: inherit;">Therefore, I clarify: verification of the lock-free algorithm is always required for any memory model, and in the case of weak models it is required </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">especially</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ddb/051/083/ddb051083994b0943d0779fbdcfb4552.jpg" align="right"><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verification of lock-free algorithms </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Until recently, I had known only one verification tool - </font></font><a href="http://www.1024cores.net/home/relacy-race-detector"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dmitry Vyukov relacy library. Unfortunately, this tool requires the construction of a special model. In fact, you should first build a simplified model of the lock-free algorithm in terms of the relacy library (why simplified? ‚ÄîBecause building a model, you usually remove any useful baubles that are not directly related to the algorithm under consideration). This model then needs to be debugged, and only then, when everything is debugged and all atomic operations are supplied with correct </font></font><code>memory_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-arguments, you can write the production-version of the algorithm. This approach is ideal for </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">developers.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock-free algorithms and data structures - those who invent them. Actually, for developers on this model, everything ends. But to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (I like the Russian term ‚Äúincarnator‚Äù - he emphasizes that the subject does not invent anything, but only creatively puts someone‚Äôs thought into practice) such a two-step approach often does not fit (due to natural laziness) - they need everything here and Now, and preferably quickly.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apparently, the author of relacy himself, Dmitry Vyukov, understood this flaw of his brainchild (no irony ‚Äî relacy is really a breakthrough project in his field), and once in an interview on the forum, Intel suggested that it should be done so that the verification tool (relacy or something like that ) was embedded inside the standard library. Then no additional model will be needed. Something that resembles the concept of safe iterators in the STL debug. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recently, Dmitry, together with his colleagues from Google, presented a new tool </font></font><a href="https://code.google.com/p/thread-sanitizer/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadSanitizer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This tool allows you to check the availability of data race (data race) in the program, that is, in fact, the correct use of ordering in atomic operations. </font><font style="vertical-align: inherit;">Moreover, this tool is implemented not even in STL, but even deeper into the compiler (Clang 3.2, and then in </font></font><a href="http://gcc.gnu.org/gcc-4.8/changes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC 4.8</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of ThreadSanitizer is quite simple - just compile the program with certain keys, make a test run - and enjoy the study of extensive logs. </font><font style="vertical-align: inherit;">I </font><font style="vertical-align: inherit;">plan to use this tool in the </font></font><a href="http://libcds.sourceforge.net/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libcds</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">in the near future in order to make sure that </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I am a dummy</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that libcds is ok.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The importance of verification for the x86 architecture</font></font></b> <div class="spoiler_text">  x86, ,     (weakly-ordered)   .   ,          lock-free : ,      x86,        . <br>     ,    <code>memory_order</code> -     null (   nop!), ‚Äî x86     . , release-  ‚Äì    <code>mov</code>    ,   <code>mov</code>   relaxed-. <br>   lock-free ,      ,  x86-  <i></i>  -        . <br></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "I do not understand ..." - Criticism of the standard </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes, I take the liberty to criticize the standard C ++ 11! </font><font style="vertical-align: inherit;">I do not understand why the standard was chosen when semantics is indicated by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argument of an</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atomic operation. </font><font style="vertical-align: inherit;">It would be more logical to use templates and define something like this:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">atomic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;memory_order Order = memory_order_seq_cst&gt; T load() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;memory_order Order = memory_order_seq_cst&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> store( T val ) ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;memory_order SuccessOrder = memory_order_seq_cst&gt; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> compare_exchange_weak( T&amp; expected, T desired ) ; <span class="hljs-comment"><span class="hljs-comment">//    };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me explain why I believe that such a definition is more correct. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As has been repeatedly stated, the semantics of atomic operations affects not only the processor, but also the compiler. </font><font style="vertical-align: inherit;">For the compiler, semantics plays the role of [semi] optimization barriers. </font><font style="vertical-align: inherit;">In addition, the compiler must ensure that atomic operations have been assigned permissible semantics (remember that, for example, the release semantics is not applicable to reading). </font><font style="vertical-align: inherit;">Therefore, semantics must be defined at compile time. </font><font style="vertical-align: inherit;">I have no idea what the compiler will do in this code:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order currentOrder ; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::Atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; atomicInt ; atomicInt.store( <span class="hljs-number"><span class="hljs-number">42</span></span>, currentOrder ) ;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code does not formally contradict the C ++ 11 standard. </font><font style="vertical-align: inherit;">However, all the compiler can do here is:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or to give an error, - then why such an interface of atomic operations is allowed at all, which can lead to an error? </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or apply the sequential consistent semantics - for reasons of "it would not be worse." </font><font style="vertical-align: inherit;">But then the variable is </font></font><code>currentOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simply ignored, and our program gets the brakes we wanted to avoid.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or generate switch / case for all possible values </font></font><code>currentOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, instead of one or two assembly instructions, we get an inefficient code. </font><font style="vertical-align: inherit;">And the problem of semantics suitable for the operation is not solved, it is quite possible to trigger a release-read or acquire-write</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The standard approach is devoid of such shortcomings. In template functions, we must specify </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the compile time constant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from the enumeration </font></font><code>memory_order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yes, the call to atomic operations can be somewhat angular:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::Atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; atomicInt ; atomicInt.store&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::memory_order_release&gt;( <span class="hljs-number"><span class="hljs-number">42</span></span> ) ; <span class="hljs-comment"><span class="hljs-comment">//   : atomicInt.template store&lt;std::memory_order_release&gt;( 42 ) ;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, in my opinion, such ‚Äúangularity‚Äù is compensated for by the advantages of the template approach, the unambiguous indication of the semantics of the operation at compile time. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only explanation of the C ++ 11 approach that comes to my mind is the notorious compatibility with C. After all, in addition to the class, </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the C ++ 11 standard introduces free C-shnye atomic functions </font></font><code>atomic_load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>atomic_store</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and so on. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I note that in libcds in times when C + 11 was still only in the project, I implemented atomic primitives in terms of patterns. </font><font style="vertical-align: inherit;">Then I came to the conclusion that we still need to follow the standard, and shoveled the next version of libcds under the C ++ 11 atomic operations interface.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> End of Essentials </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This article is the conclusion of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basics</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The end of the basics according to Google</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/dc9/905/7a5dc9905e1bdc686e3b7f2334fab9e2.jpg"><br>          ¬´ ¬ª.  , -    ‚Ä¶ <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Further I undertake to tell already ‚Äúon a subject‚Äù - lock-free data structures and the accompanying algorithms. </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lock-free data structures</font></font></b> <div class="spoiler_text">  <a href="http://habrahabr.ru/company/ifree/blog/195770/">Start</a> <br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/195948/">   </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/196548/">    </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/197520/"> </a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/202190/">  </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/206984/">RCU</a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/216013/"> </a> </li><li> <a href="http://habrahabr.ru/company/ifree/blog/219201/"> </a> </li><li> <a href="http://habrahabr.ru/post/230349/"> </a> </li><li> <a href="http://habrahabr.ru/post/250383/">Concurrent maps: </a> </li><li> <a href="http://habrahabr.ru/post/250523/">Concurrent maps: rehash, no rebuild</a> </li><li>  <a href="http://habrahabr.ru/post/250815/">Concurrent maps: skip list</a> </li><li> <a href="https://habrahabr.ru/post/251267/">Concurent maps: </a> </li><li>  <a href="https://habrahabr.ru/post/314948/">Iterators: multi-level array</a> </li><li> <a href="https://habrahabr.ru/post/317882/">Iterable list</a> </li></ul><br> : <br><ul><li> <a href="http://habrahabr.ru/company/ifree/blog/196834/">  libcds</a> </li></ul><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/197520/">https://habr.com/ru/post/197520/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../197508/index.html">ROI website could not withstand the effect of Navalny</a></li>
<li><a href="../197512/index.html">The tale of how the First Channel itself creates prohibited content and complains about it</a></li>
<li><a href="../197514/index.html">Officials rejected the petition to repeal the "anti-piracy" law</a></li>
<li><a href="../197516/index.html">Network for the smallest. Micro Issue number 3. IBGP</a></li>
<li><a href="../197518/index.html">ePayService at Kyiv CasualConnect 2013</a></li>
<li><a href="../197522/index.html">How we did the wiren board</a></li>
<li><a href="../197524/index.html">Symfony CMF. Part 1, data storage</a></li>
<li><a href="../197528/index.html">ABCat: OpenSource catalog and audiobook downloader</a></li>
<li><a href="../197540/index.html">Algorithm of data distribution in a server cluster in dCache</a></li>
<li><a href="../197542/index.html">HTC One max officially presented</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>