<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Solving Japanese crosswords with PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust and WebAssembly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How to make a solver (solver) of nonograms in Python, rewrite it in Rust to run directly in a browser via WebAssembly. 


 TL; DR 
 Start 


 About Ja...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Solving Japanese crosswords with PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust and WebAssembly</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="Rust logo as nonogram"></p><br><p>  How to make a solver (solver) of nonograms in Python, rewrite it in Rust to run directly in a browser via WebAssembly. </p><br><p>  <a href="https://tsionyx.github.io/nono/%3Fid%3D32480">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo">  Start </h2><br><p>  About Japanese crosswords (nonograms) on Habr√© there were already several posts.  <a href="https://habr.com/ru/post/418069/">Example</a> <br>  and <a href="https://habr.com/ru/post/433330/">one more</a> . </p><br><blockquote>  Images are encrypted with numbers to the left of the rows, as well as above the columns.  The number of numbers shows how many groups of black (or their own color, for color crossword puzzles) cells are in the corresponding row or column, and the numbers themselves - how many flat cells each of these groups contains (for example, a set of three numbers - 4, 1, and 3 means that there are three groups in this series: the first is from four, the second is from one, the third is from three black cells).  In a black-and-white crossword, groups should be separated by at least one empty cell, in color this rule applies only to monochrome groups, and multi-colored groups can be located closely (empty cells can be along the edges of the rows).  It is necessary to determine the placement of groups of cells. </blockquote><p>  One of the most common points of view is that only correct ones can be called ‚Äúcorrect‚Äù crossword puzzles.  Usually, this is how a solution method is called, in which the dependencies between different rows and / or columns are not taken into account.  In other words, a solution is a sequence of <strong>independent</strong> decisions of individual rows or columns, until all cells are painted over (for more details about the algorithm, see below).  For example, only such nonograms can be found at <a href="http://nonograms.org/">http://nonograms.org/</a> ( <a href="http://nonograms.ru/">http://nonograms.ru/</a> ).  Nonograms from this site have already been cited as an example in the article <a href="https://habr.com/ru/post/418069/">Solving colored Japanese crosswords with the speed of light</a> .  For comparison and verification purposes, support for downloading and parsing crosswords from this site has also been added to my solver (thanks to <a href="https://habr.com/ru/users/kyberprizrak/" class="user_link">KyberPrizrak</a> for permission to use materials from his site). </p><br><p>  However, it is possible to extend the concept of nonograms to a more general problem, when the usual ‚Äúlogical‚Äù method leads to a dead end.  In such cases, to solve, you have to make an assumption about the color of a cell and then, having proved that this color leads to a contradiction, mark the opposite color for this cell.  The sequence of such steps can (if there is enough patience) give us all the solutions.  About solving such a more general case of crossword puzzles and will be mainly this article. </p><br><h2 id="python">  Python </h2><br><p>  About a year and a half ago, I accidentally stumbled upon <a href="http://window.edu.ru/resource/781/57781">an article</a> in which I was told how to solve one line (as it turned out later, the method was rather slow). </p><br><p>  When I implemented this method in Python (my main working language) and added a sequential update of all lines, I saw that all of this was not solved very quickly.  After studying the materiel, it turned out that there are a lot of works and implementations on this topic that offer different approaches for this task. </p><br><p>  It seemed to me that the most extensive work on the analysis of various implementations of solvers was done by Jan Wolter, publishing on his website (which, as far as I know, remains the largest public repository of nonograms on the Internet) a <a href="https://webpbn.com/survey/">detailed study</a> containing a huge amount of information and links that can help creating your solver. </p><br><p>  Studying numerous sources (will be at the end of the article), I gradually improved the speed and functionality of my solver.  As a result, I was dragged out and I was engaged in the implementation, refactoring, debugging algorithms for about 10 months in the working time. </p><br><h3 id="osnovnye-algoritmy">  Basic algorithms </h3><br><p>  The resulting solver can be represented in the form of four levels of solution: </p><br><ul><li><p>  ( <strong>line</strong> ) linear solver: at the input, a line of cells and a line of description (clues), at the output - a partially solved line.  In the python solution, I implemented 4 different algorithms (3 of them are adapted for color crosswords).  The fastest was the BguSolver algorithm, named after the <a href="https://www.cs.bgu.ac.il/~benr/nonograms/">original source</a> .  This is a very effective and actually standard method for solving nonogram strings using dynamic programming.  Pseudocode of this method can be found for example <a href="https://habr.com/ru/post/418069/">in this article</a> . </p><br></li><li><p>  ( <strong>propagation</strong> ) we add all the rows and columns to the queue, we pass through it with a linear solver, when we receive new information when we solve the row (column) we update the queue, respectively, with new columns (rows).  We continue until the queue is empty. </p><br><div class="spoiler">  <b class="spoiler_title">Example and Code</b> <div class="spoiler_text"><p> We take the next task to solve the queue.  Let it be an empty (unresolved) string of length 7 (we denote it as <code>???????</code> ) with a description of the blocks <code>[2, 3]</code> .  Linear solver will issue a partially resolved string <code>?X??XX?</code>  where <code>X</code> is a filled cell.  When updating the row, we see that the columns with numbers 1, 4, 5 have changed (indexing starts from 0).  This means that new information has appeared in the indicated columns and they can be given back to the ‚Äúlinear‚Äù solver.  We add these columns to the task queue with an increased priority (in order to give them to the linear solver as follows). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>probing</strong> ) for each unresolved cell we <strong>search</strong> through all the color options and try propagation with this new information.  If we get a contradiction, we throw this color out of the color options for the cell and try to benefit from it again with the help of propagation.  If it is solved to the end, we add the solution to the list of solutions, but continue to experiment with other colors (there may be several solutions).  If we come to a situation where it is impossible to solve further, we simply ignore and repeat the procedure with a different color / cell. </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  Returns True if a conflict was obtained as a result of the probe. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>backtracking</strong> ) if, when probing, we do not ignore the partially solved puzzle, but continue to recursively call the same procedure, we will get backtracking (in other words, a complete detour into the depth of the potential decision tree).  Here begins to play a large role, which cell will be selected as the next expansion of the potential solution.  A good study on this topic is <a href="https://ir.nctu.edu.tw/bitstream/11536/22772/1/000324586300005.pdf">in this publication</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><p>  My backtracking is pretty messy, but these two functions roughly describe what happens during a recursive search. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p>  So, we begin to solve our crossword puzzle from the second level (the first one is suitable only for a degenerate case, when there is only one row or column in the whole crossword puzzle) and gradually move up the levels.  As you might guess, each level several times causes the underlying level, so for an effective solution it is extremely necessary to have fast first and second levels, which can be called millions of times for complex puzzles. </p><br><p>  At this stage it turns out (quite expectedly) that python is not at all the tool that is suitable for maximum performance in such a CPU-intensive task: all the calculations in it are extremely inefficient compared to lower-level languages.  For example, the most algorithmically close BGU-solver (in Java) was 7‚Äì17 (sometimes up to 27) times faster on a variety of tasks. </p><br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text"><pre>         pynogram_my BGU_my speedup
 Dancer 0.976 0.141 6.921986      
 Cat 1.064 0.110 9.672727      
 Skid 1.084 0.101 10.732673     
 Bucks 1.116 0.118 9.457627      
 Edge 1.208 0.094 12.851064     
 Smoke 1.464 0.120 12.200000     
 Knot 1.332 0.140 9.514286      
 Swing 1.784 0.138 12.927536     
 Mum 2.108 0.147 14.340136     
 DiCap 2.076 0.176 11.795455     
 Tragic 2.368 0.265 8.935849      
 Merka 2.084 0.196 10.632653     
 Petro 2.948 0.219 13.461187     
 M &amp; M 3.588 0.375 9.568000      
 Signed 4.068 0.242 16.809917     
 Light 3.848 0.488 7.885246      
 Forever 111.000 13.570 8.179808  
 Center 5.700 0.327 17.431193     
 Hot 3.150 0.278 11.330935     
 Karate 2.500 0.219 11.415525     
 9-Dom 510.000 70.416 7.242672      
 Flag 149.000 5.628 26.474769     
 Lion 71.000 2.895 24.525043     
 Marley 12.108 4.405 2.748695      
 Thing 321,000 46.166 6.953169      
 Nature inf 433.138 inf     
 Sierp inf inf NaN      
 Gettys inf inf NaN      
</pre><br><p>  The measurements were taken on my machine, the puzzles are taken from the standard set, which Jan Wolter used in his <a href="https://webpbn.com/survey/">comparison</a> </p></div></div><br><p>  And this is already after I started using PyPy, and on standard CPython the calculation time was 4-5 times higher than on PyPy!  We can say that the performance of a similar Java solver turned out to be higher than CPython code by 28-85 times. </p><br><p>  Attempts to improve the performance of my solver with the help of profiling (cProfile, SnakeViz, line_profiler) led to some acceleration, but they certainly didn‚Äôt give a supernatural result. </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://github.com/tsionyx/pynogram">Results</a> : </h3><br><p>  <strong>+</strong> Solver can solve all puzzles from <a href="https://webpbn.com/">https://webpbn.com</a> , <a href="http://nonograms.org/">http://nonograms.org</a> and its own (ini-based) format </p><br><p>  <strong>+</strong> solves black-and-white and color nonograms with any number of colors (the maximum number of colors that was encountered is 10) </p><br><p>  <strong>+</strong> Solves puzzles with missing block sizes (blotted).  <a href="https://webpbn.com/19407">An example of such a puzzle</a> . </p><br><p>  <strong>+</strong> can render puzzles to the console / to the curses window / to the browser (when installing the additional option <em>pynogram-web</em> ).  For all modes, viewing the progress of the solution in real time is supported. </p><br><p>  <strong>-</strong> slow calculations (in comparison with the implementations described in the article-comparison of solvers, see <a href="https://webpbn.com/survey/">table</a> ). </p><br><p>  <strong>-</strong> ineffective backtracking: some puzzles can be solved for hours (when the decision tree is very large). </p><br><h2 id="rust">  Rusty </h2><br><p>  Earlier this year, I began to study Rust.  I started, as usual, with <a href="https://doc.rust-lang.org/book/">The Book</a> , I learned about WASM, I went through the <a href="https://rustwasm.github.io/docs/book/">proposed tutorial</a> .  However, I wanted some real task in which the strengths of the language could be acted upon (first of all, its super-performance), and not examples invented by someone.  So I went back to the nonograms.  But now I already had a working version of all the algorithms in Python, it remains ‚Äúonly‚Äù to rewrite. </p><br><p>  From the very beginning, the good news was waiting for me: it turned out that Rust, with its type system, perfectly describes the data structures for my task.  For example, one of the basic matches <em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColoredBlock</em> allows <em>you</em> to permanently separate black and white and colored nonograms.  If somewhere in the code we try to solve a color string using ordinary binary description blocks, we get a compilation error about the type mismatch. </p><br><div class="spoiler">  <b class="spoiler_title">Base types look like this.</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p>  When migrating the code, some moments clearly indicated that a statically typed language, such as Rust (or, for example, C ++), is more suitable for this task.  More precisely, generics and traits describe the subject area better than class hierarchies.  So in the Python code, I had two classes for a linear <code>BguSolver</code> , <code>BguSolver</code> and <code>BguColoredSolver</code> which decided, respectively, the black-and-white line and the color line.  In the Rust code, I still have a single generic structure <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> , which can solve both types of tasks, depending on the type transferred during creation ( <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ).  This, of course, does not mean that something similar cannot be done in Python, just in Rust the type system explicitly indicated to me that if you do not go this way, you will have to write a ton of duplicate code. </p><br><p>  In addition, anyone who tried to write on Rust undoubtedly noticed the effect of "trusting" the compiler, when the process of writing code reduces to the following pseudo-meta-algorithm: </p><br><pre> write_initial_code
 while (compiler_hints = $ (cargo check))! = 0;  do
     fix_errors (compiler_hints)
 end
</pre><br><p>  When the compiler stops issuing errors and warnings, your code will be coordinated with the type system and borrow checker and you will warn in advance of a heap of potential bugs (of course, subject to careful design of data types). </p><br><p>  I will give a couple of examples of functions that show how concise Rust code can be (compared to Python analogues). </p><br><div class="spoiler">  <b class="spoiler_title">unsolved_neighbours</b> <div class="spoiler_text"><p>  List the unresolved "neighbors" for a given point (x, y) </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">partial_sums</b> <div class="spoiler_text"><p>  For a set of blocks describing a single line, give partial amounts (taking into account the mandatory intervals between blocks). The resulting indices will indicate the minimum position where the block can end (this information is used further for a linear solver). </p><br><p>  For example, for such a set of blocks <code>[2, 3, 1]</code> we have the output <code>[2, 6, 8]</code> , which means that the first block can be shifted to the left as much as possible so that its right edge occupies the 2nd cell, similarly for the rest blocks: </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^ ^ ^
               |  |  |
 end of block 1 |  |  | 
 end of block 2 -------- |
 end of block 3 ------------
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p>  When porting, I made a few changes. </p><br><ul><li>  the core of the solver (algorithms) has undergone minor changes (primarily to support generic types for cells and blocks) </li><li>  left the only (fastest) algorithm for linear solver </li><li>  instead of ini format introduced a slightly modified TOML format </li><li>  did not add support for blotted crosswords, because, strictly speaking, this is a different class of tasks </li><li><p>  left the only way out - just to the console, but now the colored cells in the console are drawn really colored (thanks to <a href="https://crates.io/crates/colored">this crete</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">like this</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="Jack sparrow"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty">  Useful tools </h3><br><ul><li>  <a href="https://github.com/rust-lang/rust-clippy">clippy</a> - a standard static analyzer, which sometimes can even give tips that slightly increase code performance </li><li>  <a href="http://www.valgrind.org/">valgrind</a> is a tool for dynamic analysis of applications.  I used it as a profiler to search for bottlenecks ( <code>valrgind --tool=callgrind</code> ) and especially voracious parts of the code ( <code>valrgind --tool=massif</code> ).  Tip: set <em>[profile.release] debug = true</em> in Cargo.toml before running the profiler.  This will leave the debug characters in the executable file. </li><li>  <a href="https://github.com/KDE/kcachegrind">kcachegrind</a> for viewing callgrind files.  A very useful tool for finding the most problematic places in terms of performance. </li></ul><br><h3 id="proizvoditelnost">  Performance </h3><br><p>  That for the sake of what was being started and rewriting Rust.  We take crosswords from the already mentioned <a href="https://webpbn.com/survey/">comparison table</a> and run them through the best solvers described in the original article.  Results and description of the runs <a href="https://github.com/tsionyx/nonogrid/tree/dev/benches">here</a> .  We take the resulting <a href="">file</a> and build a couple of graphs on it. Since the solution time varies from milliseconds to tens of minutes, the graph is executed with a logarithmic scale. </p><br><div class="spoiler">  <b class="spoiler_title">run on a jupyter laptop</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  python solver </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="pynogram-performance"><br></a> <br>  (the <em>picture is clickable</em> ) </p><br><p>  We see that the <em>pynogram</em> here is the slowest of all represented solvers.  The only exception to this rule is the <a href="http://bach.istc.kobe-u.ac.jp/copris/puzzles/nonogram/">Tamura / Copris</a> solver, based on the SAT, which solves the simplest puzzles (the left part of the graph) longer than ours.  However, such is the peculiarity of SAT-solvers: they are designed for super complex crosswords, in which an ordinary solver is stuck in backtracking for a long time.  This is clearly visible on the right side of the chart, where <em>Tamura / Copris</em> solves the most difficult puzzles tens and hundreds of times faster than any other. </p><br><h5 id="rust-solver">  rustler </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="nonogrid-performance"><br></a> <br>  (the <em>picture is clickable</em> ) </p><br><p>  This graph shows that <em>nonogrid copes</em> with simple tasks as well or slightly worse than high-performance solvers written in C and C ++ ( <em>Wolter</em> and <em>Syromolotov</em> ).  With the complication of tasks, our solver roughly repeats the trajectory of a <em>BGU</em> solver (Java), but almost always advances it by an order of magnitude.  On the most difficult tasks, <em>Tamura / Copris</em> is always ahead of everyone. </p><br><h5 id="rust-vs-python">  rust vs python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="py-vs-rust-performance"><br></a> <br>  (the <em>picture is clickable</em> ) </p><br><p>  Well, finally, a comparison of our two solvers, described here.  It can be seen that the Rust-solver is almost always ahead of the Piton solver by 1‚Äì3 orders of magnitude. </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://github.com/tsionyx/nonogrid">Results</a> : </h3><br><p>  <strong>+</strong> Solver can solve all puzzles from <a href="https://webpbn.com/">https://webpbn.com</a> (except blotted - with partially hidden block sizes), <a href="http://nonograms.org/">http://nonograms.org</a> and its own (TOML-based) format </p><br><p>  <strong>+</strong> solves black and white and color nonograms with any number of colors </p><br><p>  <strong>+</strong> can render puzzles to console (color c with webpbn.com draws truly color) </p><br><p>  <strong>+</strong> works quickly (in comparison with the implementations described in the article-comparison of solvers, see table). </p><br><p>  <strong>-</strong> backtracking remained inefficient, as in the Python-solution: some puzzles (for example <a href="https://webpbn.com/3620">, such a harmless 20x20</a> ) can be solved for hours (when the decision tree is very large).  Perhaps instead of backtracking, you should use the <a href="https://habr.com/ru/post/433330/">SAT-solvers</a> already mentioned in <a href="https://habr.com/ru/post/433330/">the habr</a> .  True, the only <a href="https://github.com/kmcallister/sat">SAT-solver</a> I found <a href="https://github.com/kmcallister/sat">on Rust</a> at first glance seems to be underdeveloped and abandoned. </p><br><h2 id="webassembly">  WebAssembly </h2><br><p>  So, rewriting the code to Rust has borne fruit: the solver has become much faster.  However, Rust offers us another incredibly cool feature: compiling to WebAssembly and the ability to run your code directly in the browser. </p><br><p>  To implement this feature, there is a special tool for Rust, which provides the necessary binders and generates a boilerplate for you to run Rust functions painlessly in the JS code - this <em>wasm-pack</em> (+ <em>wasm-bindgen</em> ).  Most of the work with it and other important tools is already described in the <a href="https://rustwasm.github.io/docs/book/">Rust and WebAssembly tutorial</a> .  However, there are a couple of things that I had to figure out on my own: </p><br><ul><li><p>  reading gives the impression that the tutorial is primarily written for a JS developer who wants to speed up his code with Rust.  Or at least for someone who is familiar with <em>npm</em> .  For me, as a person far from the front-end, it was a surprise to discover that even the standard book example does not want to work with a third-party web server different from <code>npm run start</code> . </p><br><p>  Fortunately, the wasm-pack has a mode that allows you to generate a regular JS code (which is not an npm module).  <code>wasm-pack build --target no-modules --no-typescript</code> will yield only two files at the output: <em>project-name.wasm</em> - Rust-code binary compiled in WebAssembly and <em>project-name.js</em> .  You can add the latest file to any HTML <code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code> page and use WASM functions without bothering with npm, webpack, ES6, modules and other joys of a modern JS developer.  The <code>no-modules</code> mode is ideal for non-frontenders during the development of a WASM application, as well as for examples and demonstrations, because it does not require any additional frontend infrastructure. </p><br></li><li><p>  WemAssembly is good for tasks that are too heavy for javascript.  First of all, these are tasks that perform many calculations.  And if so, this task can be performed for a long time even with WebAssembly and thus violate the asynchronous principle of the modern web.  I'm talking about all sorts of <em>Warning: Unresponsive script</em> , which I happened to observe while working my solver.  To solve this problem, you can use the mechanism of <em>Web worker</em> .  In this case, the scheme of work with "heavy" WASM-functions may look like this: </p><br><ol><li>  from the main script of the event (for example, clicking on a button) send a message to the worker with the task to start a heavy function. </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://rustwasm.github.io/docs/book/game-of-life/implementing.html">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://tsionyx.github.io/nono/%3Fid%3D6574">6574</a>  <a href="https://tsionyx.github.io/nono/%3Fid%3D8098">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th>  id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td>  5.4 </td><td>  7.4 </td><td> 9.2 </td></tr><tr><td> 8098 </td><td>  21.5 </td><td> 28.4 </td><td>  29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://tsionyx.github.io/nono/"></a> ( <a href="https://github.com/tsionyx/nono"></a> ).            <a href="https://webpbn.com/">https://webpbn.com/</a>  <a href="http://www.nonograms.org/">http://www.nonograms.org/</a> </p><br><h3 id="todo">  Todo </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://github.com/tsionyx/nonogrid/commit/47b48109927e3146455636df2c32efc44232733b"></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi">  Results </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="http://webpbn.com/pbnsolve.html">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="http://webpbn.com/survey/">survey</a> </li><li> <a href="https://www.cs.bgu.ac.il/~benr/nonograms/">The BGU Nonograms Project</a> </li><li> <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.177.76%26rep%3Drep1%26type%3Dpdf">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://ir.nctu.edu.tw/bitstream/11536/22772/1/000324586300005.pdf">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://habr.com/post/418069">      </a> </li><li> <a href="http://www.nonograms.org/">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="http://window.edu.ru/resource/781/57781">      </a> </li><li> <a href="http://www.lancaster.ac.uk/~simpsons/nonogram/howitworks">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://rustwasm.github.io/docs/book/">Rust and WebAssembly</a> </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/454586/">https://habr.com/ru/post/454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454574/index.html">Machine learning in microfinance: building a scoring model for customers with a blank credit history</a></li>
<li><a href="../454576/index.html">GandCrab authors stop working: they claim they stole enough</a></li>
<li><a href="../454578/index.html">How to connect the PhotoSwipe gallery in WebView android</a></li>
<li><a href="../45458/index.html">RESTful routing</a></li>
<li><a href="../454584/index.html">Interface development school: analysis of tasks for Minsk and a new set in Moscow</a></li>
<li><a href="../454588/index.html">Gazprom Neft invites: GPN Data Science Meetup</a></li>
<li><a href="../45459/index.html">Creating splash screen in .net 3.5 SP1</a></li>
<li><a href="../454590/index.html">Zimbra Collaboration Suite and Mobile Device Control with ABQ</a></li>
<li><a href="../454596/index.html">Mental models in information security</a></li>
<li><a href="../454598/index.html">Serverless architecture and microservices: the perfect match?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>