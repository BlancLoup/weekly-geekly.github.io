<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the new architectural components in Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guest article from Google I \ O 2017 participant and one of the leaders of GDG Kazan - Artur Vasilov ( @Arturka ). 

 May 19, ended the conference Goo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the new architectural components in Android</h1><div class="post__text post__text-html js-mediator-article">  Guest article from Google I \ O 2017 participant and one of the leaders of <a href="https://www.meetup.com/GDG-Kazan/">GDG Kazan</a> - Artur Vasilov ( <a href="https://habrahabr.ru/users/arturka/">@Arturka</a> ). <br><br>  May 19, ended the conference Google I / O.  According to the opinion, in spite of the fact that not so many new products were presented this year, from a technical point of view the conference turned out to be interesting. <br><br>  The biggest and most interesting technical update for me personally was the new Architecture Components (not Android O, in which there is not much interesting, and certainly not Kotlin).  Google did what it should have done a long time ago - to develop standards for the architecture and provide them to the developers.  Well, better late than never, and let's understand how useful Google's architecture can be. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/62d/563/9c8/62d5639c8f6b4c36a2c75286690f2ddf.png"><br><a name="habracut"></a><br><h2>  First impression </h2><br>  Personally, the title of the reports didn‚Äôt interest me so much that I didn‚Äôt even visit them, because I didn‚Äôt believe that Google could do something interesting in this area, and not just repeat Mosby / Moxy / &lt;your own bike&gt;.  The same skepticism persisted after a quick scan of the developed libraries.  However, after some time I had to change my opinion, because: <br><br><ul><li>  Google really made a good library with a convenient API; </li><li>  Google did not close, but took into account all modern developments in the field of the architecture of Android applications, taking the best of all; </li><li>  Beginners finally have good documentation that will help them start developing applications with a good architecture, without having to thoroughly understand the meaning of MVP / MVVM, etc. </li></ul><br>  After a deeper immersion, I tried to write an application using this architecture (or rather, rewrite it to assess the complexity of migration), and now I can share this experience. <br><br><h2>  Good architecture </h2><br>  To begin, consider what is generally meant by a good application architecture.  In order not to go into philosophical statements about why architecture is needed at all, and so on, let us immediately designate the requirements for a good application architecture: <br><br><ul><li>  Allows to decompose logic (data acquisition / processing / user interaction, etc.); </li><li>  Scalable.  The word that should be in any article about architecture.  In Android, this is quite simple, since any application can be divided into screens, between which there will be very transparent connections, and making the architecture of a separate screen scalable does not seem difficult; </li><li>  Allows you to write tests for the business logic of the application. </li></ul><br>  All these are general requirements, but in addition to them, it is possible to identify quite specific tasks that should be solved without problems within a specific architecture: <br><br><ol><li>  Processing re-creation Activity.  Probably the most distressful topic in building the architecture of the application, which does not need comments; </li><li>  Execution of HTTP requests (both for receiving data and sending); </li><li>  Support for data streams, for example, when working with sockets / sensors; </li><li>  Data caching; </li><li>  Error processing. </li></ol><br>  Of course, points 2-5 should be carried out taking into account the first point. <br><br>  For quite a long time, Android developers independently solved all these problems, but gradually accumulated experience led to the emergence of <a href="https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/">Clean Architecture</a> .  Clean Architecture's approaches are very good, except that it is often inappropriate in an application to divide logic into UI and business (since one of the layers may contain almost no code), so many developers use an architecture that can be represented by the following scheme (slightly rearranging blocks from Clean Architecture): <br><br><img src="https://habrastorage.org/web/319/7ef/9d1/3197ef9d1a5f4ac39d88a696bd98cf63.png"><br><br>  The only thing that does not take into account the problems of the life cycle, which all solve either <br>  independently or with the help of any libraries.  Now let's see what Google has offered us. <br><br><h2>  Google architecture </h2><br>  Just look at the scheme from Google: <br><br><img src="https://habrastorage.org/web/e05/b49/aae/e05b49aaef88460b9ee86bb68f8acf67.png"><br><br>  Perhaps it seemed to me, but in my opinion, the previous scheme was simply turned vertically.  And I don‚Äôt want to say that Google has appropriated something old, on the contrary, it shows that Google is eyeing the developers' opinion and takes into account all their achievements, which is good news. <br><br>  Let us consider an example of the implementation of a single screen with a single request in terms of the proposed architecture, and at the same time we consider the key classes. <br><br>  One of the big problems in Android is the need to constantly subscribe / unsubscribe from any objects when calling life-cycle methods.  And since lifecycle methods are only in Activity / Fragment, all such objects (for example, GoogleApiClient, LocationManager, SensorManager and others) should be located only in Activity / Fragment, which leads to a large number of lines of code in these files. <br><br>  To solve this and other problems, Google suggested using the class <i>LiveData</i> - a class that is closely related to the life cycle and which implements the Observer pattern.  By and large, this is a very simple class that encapsulates the work with a single object, which can be changed and which changes can be monitored.  And this is again a fairly standard approach. <br><br>  Consider how we can use LiveData, for example, in order to monitor the user's location changes.  Create the following class: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocationLiveData</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LiveData</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Location</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocationManager locationManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocationListener listener = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocationListener(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LocationLiveData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Context context)</span></span></span><span class="hljs-function"> </span></span>{ locationManager = (LocationManager) context.getSystemService(Context.LOCATION_SERVICE); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, listener); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onInactive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ locationManager.removeUpdates(listener); } }</code> </pre> <br>  And now we can write the following code in the Activity: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocationActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> LocationLiveData locationLiveData; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); setContentView(R.layout.activity_movies); <span class="hljs-comment"><span class="hljs-comment">//... locationLiveData = new LocationLiveData(this); locationLiveData.observe(this, location -&gt; { // update your UI }); } //... }</span></span></code> </pre><br>  All the necessary lifecycle methods in LiveData will be invoked by the first parameter in the observe method - LifecycleOwner.  This allows us to know when to subscribe and unsubscribe from various objects (for example, using the onActive and onInactive methods). <br><br>  LifecycleActivity is a class from the library that implements the LifecycleOwner interface.  Unfortunately, it is for some reason inherited from FragmentActivity, and not from AppCompatActivity, and if you want to inherit from AppCompatActivity, you will have to write some code yourself: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseLifecycleActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LifecycleRegistryOwner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LifecycleRegistry lifecycleRegistry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LifecycleRegistry(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LifecycleRegistry </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLifecycle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lifecycleRegistry; } }</code> </pre><br>  In addition to the onActive and onInactive methods in LiveData, you can get callbacks on any lifecycle method. <br><br>  Exactly the same model can be used to implement server queries.  That is, we do not in any way change the way we get the data (also through the Repository), but we delegate the data to LiveData, which is essentially a binding for the View. <br><br>  And now the main question arises - how to deal with the problem of the life cycle?  Of course, Google thought about this and gave developers a component that is experiencing a re-creation of Activity - <i>ViewModel</i> . <br><br>  A few words about the ViewModel: <br><br><ol><li>  All ViewModel instances are stored in a retain Fragment (HolderFragment).  This is a very standard solution, which was also used by many developers. </li><li>  The ViewModel class should store all instances of LiveData so that they survive the re-creation of the Activity. </li><li>  The ViewModel is associated with the View via LiveData, that is, the ViewModel does not explicitly control the View, and this can be considered a variation of the MVVM pattern. </li></ol><br>  Let us analyze how we can implement a server request for a screen.  Create a ViewModel that will control the screen logic: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoviesViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MoviesRepository moviesRepository; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MutableLiveData&lt;List&lt;Movie&gt;&gt; moviesLiveData; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoviesViewModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull MoviesRepository moviesRepository)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moviesRepository = moviesRepository; } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> LiveData&lt;List&lt;Movie&gt;&gt; getMoviesList() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moviesLiveData == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { moviesLiveData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MutableLiveData&lt;&gt;(); moviesRepository.popularMovies() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(moviesLiveData::setValue); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moviesLiveData; } }</code> </pre><br>  Then View can use this ViewModel as follows: <br><br><pre> <code class="java hljs">viewModel.getMoviesList().observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, movies -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (movies != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { adapter.setNewValues(movies); } });</code> </pre><br>  Since the ViewModel is experiencing a re-creation of Activity, LiveData will be created only once and the server request will be executed only once, that is, these problems are solved.  There remains the question of creating a ViewModel. <br><br>  To access the ViewModel, use the ViewModelProviders class: <br><br><pre> <code class="java hljs">MoviesViewModel viewModel = ViewModelProviders.of(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).get(MoviesViewModel.class);</code> </pre> <br>  However, there is a small problem.  When we use a non-default constructor (and in the example above, we passed a Repository object to the constructor), we will have to write our factory to create a ViewModel: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoviesViewModelProviderFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseViewModelFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MoviesRepository repository; MoviesViewModelProviderFactory(<span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> MoviesService moviesService) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.repository = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MoviesRepository(moviesService); } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T extends ViewModel&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Class&lt;T&gt; modelClass)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modelClass.equals(MoviesViewModel.class)) { <span class="hljs-comment"><span class="hljs-comment">//noinspection unchecked return (T) new MoviesViewModel(repository); } return super.create(modelClass); } }</span></span></code> </pre><br>  And now we can create a ViewModel as follows: <br><br><pre> <code class="java hljs">ViewModelProvider.Factory factory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MoviesViewModelProviderFactory(service); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ViewModelProviders.of(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, factory).get(MoviesViewModel.class);</code> </pre> <br>  In this example, we manually transfer to the Factory all the necessary objects to create a ViewModel, but the only normal approach for creating a ViewModel with an increase in the number of parameters is Dagger.  This is where Google actually forces you to use it.  Good or bad, you decide. <br><br>  And this is all - we received the data, displayed them, and all this with the processing of the life cycle.  However, there are a few more points that we will look at next. <br><br><h2>  Progress display and error handling </h2><br>  When I just started to deal with new architectural components, I immediately had a question about how to handle errors using LiveData or get a change in progress.  After all, all that we have is an instance of one class, which we must transfer to Activity / Fragment.  A similar question arises with the display of progress.  Such a problem is a bit like a problem with loaders, however there are two options for how to solve it. <br><br>  First, we can create some class whose object will encapsulate the status of the request, the error message and the data itself, and pass this object to the Activity / Fragment.  This method is recommended in the documentation.  Such a class might look, for example, as follows (for now, we only analyze error handling): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> T data; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Throwable error; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable T data, @Nullable Throwable error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = data; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.error = error; } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Response&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">success</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull T data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response&lt;T&gt;(data, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Response&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Throwable error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, error); } <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Throwable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> error; } }</code> </pre><br>  Then with each change we pass to the View an object of this class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoviesViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MutableLiveData&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; moviesLiveData; <span class="hljs-comment"><span class="hljs-comment">//... @MainThread @NonNull LiveData&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; getMoviesList() { if (moviesLiveData == null) { moviesLiveData = new MutableLiveData&lt;&gt;(); moviesRepository.popularMovies() //... .subscribe( movies -&gt; moviesLiveData.setValue(Response.success(movies)), throwable -&gt; moviesLiveData.setValue(Response.error(throwable)) ); } return moviesLiveData; } }</span></span></code> </pre><br>  And View processes it accordingly: <br><br><pre> <code class="java hljs">viewModel.getMoviesList().observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, moviesResponse -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moviesResponse != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; moviesResponse.getData() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { adapter.setNewValues(moviesResponse.getData()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moviesResponse != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; moviesResponse.getError() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// show error } });</span></span></code> </pre><br>  And secondly, there is a way that in my opinion is more concise.  In the end, the request status and errors are also some changing data.  Then why not put them in LiveData and not subscribe to their changes?  For these purposes, we can write the following code (and in this situation we will consider processing the status of the load): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MutableLiveData&lt;Boolean&gt; loadingLiveData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MutableLiveData&lt;&gt;(); <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-function">LiveData&lt;Boolean&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLoading</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> loadingLiveData; } <span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> LiveData&lt;Response&lt;List&lt;Movie&gt;&gt;&gt; getMoviesList() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moviesLiveData == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { moviesLiveData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MutableLiveData&lt;&gt;(); moviesRepository.popularMovies() <span class="hljs-comment"><span class="hljs-comment">//... .doOnSubscribe(disposable -&gt; loadingLiveData.setValue(true)) .doAfterTerminate(() -&gt; loadingLiveData.setValue(false)) .subscribe(); } return moviesLiveData; }</span></span></code> </pre><br>  And now View will subscribe not to one LiveData, but to several.  This can be very convenient if we write a general handler for displaying progress or errors): <br><br><pre> <code class="java hljs">viewModel.isLoading().observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, isLoading -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isLoading != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; isLoading) { progressDialog.show(getSupportFragmentManager()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { progressDialog.cancel(); } });</code> </pre><br>  As a result, we can say that error handling with LiveData is almost as good as with the usual RxJava. <br><br><h2>  Testing </h2><br>  As mentioned above, a good architecture should allow testing an application.  Since the architecture does not carry any fundamental changes from Google, testing can only be viewed at the ViewModel level (since we know how to test Repository / UI). <br><br>  Testing the ViewModel is always a bit more complicated than testing the Presenter from the MVP pattern, since in MVP the explicit connection between View and Presenter makes it easy to check that the right methods were called on View.  In the case of MVVM, we have to check the work of the bindings or LiveData. <br><br>  Create a test class in which in the setUp method we create a ViewModel: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(JUnit4.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoviesViewModelTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MoviesViewModel viewModel; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MoviesRepository repository; <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ repository = Mockito.mock(MoviesRepository.class); Mockito.when(repository.popularMovies()).thenReturn(Observable.just(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;())); viewModel = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MoviesViewModel(repository); } }</code> </pre><br>  To test the correctness of the ViewModel, we need to make sure that it executes the request to the Repository and sends the data to LiveData: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testLoadingMovies</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Observer observer = Mockito.mock(Observer.class); viewModel.getMoviesList().observeForever(observer); Mockito.verify(repository).popularMovies(); Mockito.verify(observer).onChanged(any(Response.class)); }</code> </pre><br>  Here we omit the extra details, but if necessary, you can use the capabilities of the Mockito to make sure that the data you need came to LiveData. <br><br>  However, such a test will not work, since the setValue method in the LiveData class checks that it is called in the main application thread (of course, using the Looper): <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MainThread</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T value)</span></span></span><span class="hljs-function"> </span></span>{ assertMainThread(<span class="hljs-string"><span class="hljs-string">"setValue"</span></span>); mVersion++; mData = value; dispatchingValue(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); }</code> </pre><br>  As we well know, tests on JUnit do not like this and fall.  But Google developers have foreseen this.  To do this, you need to connect an additional library for tests and add a rule to the test: <br><br><pre> <code class="java hljs">testCompile (<span class="hljs-string"><span class="hljs-string">"android.arch.core:core-testing:$architectureVersion"</span></span>, { exclude group: <span class="hljs-string"><span class="hljs-string">'com.android.support'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>: <span class="hljs-string"><span class="hljs-string">'support-compat'</span></span> exclude group: <span class="hljs-string"><span class="hljs-string">'com.android.support'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>: <span class="hljs-string"><span class="hljs-string">'support-annotations'</span></span> exclude group: <span class="hljs-string"><span class="hljs-string">'com.android.support'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">module</span></span>: <span class="hljs-string"><span class="hljs-string">'support-core-utils'</span></span> }) <span class="hljs-meta"><span class="hljs-meta">@Rule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> InstantTaskExecutorRule instantExecutorRule = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InstantTaskExecutorRule();</code> </pre><br>  Similarly, we can test the display of progress during data loading: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProgressUpdated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Observer observer = Mockito.mock(Observer.class); viewModel.isLoading().observeForever(observer); viewModel.getMoviesList(); Mockito.verify(observer).onChanged(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); Mockito.verify(observer).onChanged(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); }</code> </pre><br>  Thus, we can write tests for all the necessary components without any special problems. <br><br><h2>  Data caching </h2><br>  Strictly speaking, data caching does not change at all with this architecture change, because we all also use a repository that hides all the details of receiving and saving data.  However, data caching is worth mentioning in connection with the new library for working with the database - Room. <br><br>  Everyone knows about the existing huge zoo database libraries in Android.  These are <a href="https://realm.io/products/realm-mobile-database/">Realm</a> , <a href="http://greenrobot.org/greendao/">greenDao</a> , <a href="http://greenrobot.org/objectbox/">ObjectBox</a> , <a href="https://github.com/Raizlabs/DBFlow">DBFlow</a> , <a href="https://github.com/square/sqlbrite">SQLBrite</a> and many others.  Therefore, many developers do not know what to choose for their project, and here Room is the ideal option, at least because it is from Google. <br><br>  Room is a fairly simple library that runs on top of SQLite, uses annotations to generate boilerplate code and has a fairly familiar and convenient API.  However, I do not think that I can tell you about Room something more interesting than it was in the <a href="https://www.youtube.com/watch%3Fv%3DMfHsPGQ6bgE">session</a> on Google I / O and what is in the <a href="https://developer.android.com/topic/libraries/architecture/room.html">documentation</a> .  Therefore, here we will finish the consideration of architectural innovations. <br><br><h2>  Conclusion </h2><br>  In general, Google is doing the right thing, and their architecture is really very thoughtful and convenient.  So you can start using it right now, at least worth trying in new projects.  A small example by which the article was written and which, perhaps, will help you try a new architecture from Google, is available on <a href="https://github.com/ArturVasilov/ArchitecturedMovies">Github</a> .  Also, of course, it is worth looking at <a href="https://github.com/googlesamples/android-architecture-components">examples</a> from Google. </div><p>Source: <a href="https://habr.com/ru/post/330208/">https://habr.com/ru/post/330208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330194/index.html">A review of research in the field of deep learning: natural language processing</a></li>
<li><a href="../330196/index.html">Concepts: set, type, attribute</a></li>
<li><a href="../330198/index.html">Useful utilities when working with Kubernetes</a></li>
<li><a href="../330204/index.html">Preventing Negative Impacts when Developing Artificial Intelligence Systems Beating the Human Mind</a></li>
<li><a href="../330206/index.html">Creating a design ecosystem for dozens of related IT solutions: a word to designers</a></li>
<li><a href="../330210/index.html">Deploying Redmine with Capistrano</a></li>
<li><a href="../330214/index.html">The universal function of creating objects on the example of the implementation of $ injector.instantiate in angularjs</a></li>
<li><a href="../330216/index.html">Results of half a day! Break voting on RIT ++ for 50 stickers. Day two</a></li>
<li><a href="../330218/index.html">We roll the "resin ball" or create your own assembly rules using Qbs</a></li>
<li><a href="../330220/index.html">The append (x) .append (y) call chain in StringBuilder is faster than typical sb.append (x); sb.append (y)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>