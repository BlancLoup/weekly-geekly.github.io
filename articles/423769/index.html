<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Connect OpenSSL to Mono</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, the process of integrating CryptoPro standards with mono was described. In the same detail we will focus on connecting RSA ce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Connect OpenSSL to Mono</h1><div class="post__text post__text-html js-mediator-article"><p>  In the previous article, the process of integrating CryptoPro standards with mono was described.  In the same detail we will focus on connecting RSA certificates. </p><br><p>  We continued to migrate one of our server systems written in C # to Linux, and the turn came to the RSA part.  If last time the difficulties in connecting were easily explained by the interaction of two, initially unrelated to each other systems, then when you connected "normal" RSA certificates from mono, obviously no one expected a trick. </p><br><a name="habracut"></a><br><p>  Installing the certificate and key did not cause any problems, and the system even saw it in the regular storage.  However, neither sign, nor encrypt, or pull the data from the previously formed signature was no longer possible - mono steadily fell with an error.  It was necessary, as in the case of CryptoPro, to connect directly to the encryption library.  For RSA certificates in Linux, the main candidate for such a connection is OpenSSL. </p><br><h2>  Certificate installation </h2><br><p>  Fortunately Centos 7 has a built-in version of OpenSSL - 1.0.2k.  In order not to introduce additional difficulties in the work of the system, we decided to connect to this version.  OpenSSL allows you to create special file certificate stores, however: </p><br><ol><li>  such a store contains certificates and CRLs, not private keys, so they will then have to be stored separately; </li><li>  storing certificates and private keys on a disk in an unprotected form on Windows is ‚Äúextremely insecure‚Äù (those responsible for digital security usually describe it more succinctly and less censorship), frankly, it is not very safe in Linux, but, in fact, is common practice; </li><li>  it is quite problematic to coordinate the location of such storage in Windows and Linux; </li><li>  in the case of manual implementation of the storage, you need a utility to manage a set of certificates; </li><li>  mono itself uses disk storage with the OpenSSL structure, and also stores private keys in the open form nearby; </li></ol><br>  For these reasons, we will use the standard .Net and mono certificate stores for connecting OpenSSL.  To do this in Linux, the certificate and private key must first be placed in the mono repository. <br><br><div class="spoiler">  <b class="spoiler_title">Certificate installation</b> <div class="spoiler_text"> We will use for this a regular utility certmgr.  At the beginning we install the private key from pfx: <br><br> <code>certmgr -importKey -c -p {password} My {pfx file}</code> <br> <br>  Then we put the certificate from this pfx, the private key will automatically connect to it: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>certmgr -add -c My {cer file}</code> <br> <br>  If you want to install the key in the storage for the machine, you must add the option-m. <br><br>  After that, the certificate can be seen in the repository: <br><br> <code>certmgr -list -c -v My</code> <br> <br>  Pay attention to the issue.  It should be noted that the certificate is visible by the system, and is tied to the private key loaded earlier.  After that, you can go to the connection code. <br></div></div><br><h2>  Connection in code </h2><br><p>  In the same way as last time, the system, despite the transfer to Linux, should continue to function in the Windows environment.  Therefore, externally, work with cryptography should be carried out through general methods of the form ‚Äúbyte [] SignData (byte [] _arData, X509Certificate2 _pCert)‚Äù, which should have worked equally in Linux and in Windows. </p><br><p>  Ideally, there should be methods that would work as in Windows - regardless of the type of certificate (on Linux via OpenSSL or CryptoPro, depending on the certificate, and on Windows - via crypt32). </p><br><p>  The analysis of the OpenSSL libraries showed that the main library in Windows is ‚Äúlibeay32.dll‚Äù, and in Linux ‚Äúlibcrypto.so.10‚Äù.  In the same way as last time we form two classes WOpenSSLAPI and LOpenSSLAPI, which contain the list of plug-in library methods: <br><br></p><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">DllImport(CTRYPTLIB, CharSet = CharSet.Auto, SetLastError = true, CallingConvention = CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OPENSSL_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>;</code> </pre><br><p>  Pay attention to the calling convention, unlike CryptoPro - here you must explicitly specify it.  The syntax for connecting each of the methods this time will have to be formed independently based on the * .h source <a href="https://github.com/openssl/openssl/tree/master/include/openssl">files of</a> OpenSSL. </p><br><p>  The basic rules for forming the syntax of a call in C # are based on the data from the .h files: </p><br><ol><li>  Any references to structures, strings, etc. - IntPtr, including links within the structures themselves; </li><li>  links to links - ref IntPtr, if this option does not work, then just IntPtr.  In this case, the link itself will have to be put and removed manually; </li><li>  arrays - byte []; </li><li>  long in C (OpenSSL) is an int in C # (a small, at first glance, error can turn into hours of searching for the source of unpredictable errors); </li></ol><br><p>  In the declaration, you can, by habit, specify SetLastError = true, but the library will ignore this - errors will not be available through Marshal.GetLastWin32Error ().  For access to errors at OpenSSL the methods. </p><br><p>  And then we form the already familiar static class ‚ÄúUOpenSSLAPI‚Äù which, depending on the system, will call the method of one of two classes: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> fpOSSection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OPENSSL_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (pOSSection) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsLinux) LOpenSSLAPI.OPENSSL_init(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> WOpenSSLAPI.OPENSSL_init(); } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> pOSSection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fpOSSection; } } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;**/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsLinux { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iPlatform = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) Environment.OSVersion.Platform; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (iPlatform == <span class="hljs-number"><span class="hljs-number">4</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">6</span></span>) || (iPlatform == <span class="hljs-number"><span class="hljs-number">128</span></span>); } }</code> </pre><br><p>  Just note the presence of a critical section.  OpenSSL <a href="https://www.openssl.org/blog/blog/2017/02/21/threads/">theoretically</a> works in a multi-threaded environment.  But, firstly, the description immediately states that this is not guaranteed: </p><br><blockquote>  But you still can't concurrently use most objects in multiple threads. </blockquote><br><p>  And secondly, the connection method is not the most trivial.  Plain two nuclear VM (server with an Intel Xeon E5649 processor in Hyper-Threading mode) using such a critical section gives about 100 complete cycles (see testing algorithm from the previous <a href="https://habr.com/post/423163/">article</a> ) or 600 signatures per second, which is basically enough for most tasks ( under heavy loads, the microservice or nodal system architecture will still be used rather. </p><br><h2>  Initialization and unloading of OpenSSL </h2><br><p>  Unlike CryptoPro, OpenSSL requires certain actions before starting to use it even after finishing work with the library: <br><br></p><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitOpenSSL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UOpenSSLAPI.OPENSSL_init(); UOpenSSLAPI.ERR_load_crypto_strings(); UOpenSSLAPI.ERR_load_RSA_strings(); UOpenSSLAPI.OPENSSL_add_all_algorithms_conf(); UOpenSSLAPI.OpenSSL_add_all_ciphers(); UOpenSSLAPI.OpenSSL_add_all_digests(); } <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OpenSSL&lt;/summary&gt;**/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CleanupOpenSSL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { UOpenSSLAPI.EVP_cleanup(); UOpenSSLAPI.CRYPTO_cleanup_all_ex_data(); UOpenSSLAPI.ERR_free_strings(); }</code> </pre><br><br><h2>  Error Information </h2><br><p>  OpenSSL stores information about errors in internal structures for access to which, in the library there are special methods.  Unfortunately, some simple methods, such as ERR_error_string, are unstable, so you have to use more complex methods: </p><br><div class="spoiler">  <b class="spoiler_title">Getting Error Information</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;param name="_iErr"&gt; &lt;/param&gt; * &lt;param name="_iPart"&gt;&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetErrStrPart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iErr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iPart</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    IntPtr hErrStr = IntPtr.Zero; switch (_iPart) { case 0: hErrStr = UOpenSSLAPI.ERR_lib_error_string(_iErr); break; case 1: hErrStr = UOpenSSLAPI.ERR_func_error_string(_iErr); break; case 2: hErrStr = UOpenSSLAPI.ERR_reason_error_string(_iErr); break; } // 1)   return PtrToFirstStr(hErrStr); } /**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;param name="_iErr"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/ public static string GetErrStr(ulong _iErr ) { return UCConsts.S_GEN_LIB_ERR_MAKRO.Frm(_iErr, GetErrStrPart(_iErr, 0), GetErrStrPart(_iErr, 1), GetErrStrPart(_iErr, 2)); } /**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;returns&gt; &lt;/returns&gt; * **/ public static string GetErrStrOS() { return GetErrStr(UOpenSSLAPI.ERR_get_error()); }</span></span></code> </pre></div></div><br><p>  An error in OpenSSL contains information about the library in which it occurred, the method and the reason.  Therefore, after receiving the error code itself, it is necessary to extract all these three parts separately and put them together in a text string.  The lengths of each line, according to the OpenSSL <a href="https://www.openssl.org/docs/man1.0.2/crypto/ERR_lib_error_string.html">documentation,</a> do not exceed 120 characters, and since we use managed code, the line must be carefully extracted by reference: </p><br><div class="spoiler">  <b class="spoiler_title">Getting a string by IntPtr</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    PChar     _iLen&lt;/summary&gt; * &lt;param name="_hPtr"&gt;    &lt;/param&gt; * &lt;param name="_iLen"&gt;  &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PtrToFirstStr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hPtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iLen = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">256</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_hPtr == IntPtr.Zero) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arStr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[_iLen]; Marshal.Copy(_hPtr, arStr, <span class="hljs-number"><span class="hljs-number">0</span></span>, arStr.Length); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] arRes = Encoding.ASCII.GetString(arStr).Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span> }, StringSplitOptions.RemoveEmptyEntries); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arRes.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arRes[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; }<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>; } }</code> </pre></div></div><br><p>  Errors when checking certificates are not in the general list, and they must be extracted by a separate method, according to the verification context: </p><br><div class="spoiler">  <b class="spoiler_title">Getting certificate verification error</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hStoreCtx"&gt; &lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCertVerifyErr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hStoreCtx</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iErr = UOpenSSLAPI.X509_STORE_CTX_get_error(_hStoreCtx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PtrToFirstStr(UOpenSSLAPI.X509_verify_cert_error_string(iErr)); }</code> </pre></div></div><br><h2>  Certificate search </h2><br><p>  As always, cryptography begins with a certificate search.  We use a staff repository, so we will look for regular methods: </p><br><div class="spoiler">  <b class="spoiler_title">Certificate search</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  (   )&lt;/summary&gt; * &lt;param name="_pFindType"&gt; &lt;/param&gt; * &lt;param name="_pFindValue"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_pName"&gt; &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_fVerify"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindCertificateOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _pFindValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser, StoreName _pName = StoreName.My, X509FindType _pFindType = X509FindType.FindByThumbprint, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerify = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (UOpenSSLAPI.pOSSection) { <span class="hljs-comment"><span class="hljs-comment">// 0)    _pCert = null; X509Store pStore = new X509Store(_pName, _pLocation); X509Certificate2Collection pCerts = null; try { // 1)   pStore.Open(OpenFlags.ReadOnly); // 2)    ( , .. Verify  Linux  false) pCerts = pStore.Certificates.Find(_pFindType, _pFindValue, false); if (pCerts.Count == 0) return UConsts.E_NO_CERTIFICATE; // 3)     if (!_fVerify) { _pCert = ISDP_X509Cert.Create(pCerts[0], TCryptoPath.cpOpenSSL); return UConsts.S_OK; } // 4)       foreach (X509Certificate2 pCert in pCerts) { ISDP_X509Cert pISDPCert = ISDP_X509Cert.Create(pCert, TCryptoPath.cpOpenSSL); if (pISDPCert.ISDPVerify()) { _pCert = pISDPCert; return UConsts.S_OK; } } return UConsts.E_NO_CERTIFICATE; } finally { if(pCerts != null) pCerts.Clear(); pStore.Close(); } } }</span></span></code> </pre></div></div><br><p>  Pay attention to the critical section.  Mono with certificates also works through OpenSSL, but not via UOpenSSLAPI.  If it is not done here, you can get memory leaks and floating incomprehensible errors under load. </p><br><p>  The main feature is the creation of a certificate.  Unlike the version for CryptoPro, in this case from the repository we get the certificate itself (X509Certificate2), and the link in the Handle in it already points to the OpenSSL structure X509_st.  It would seem that this is what is needed, but there is no pointer to EVP_PKEY (link to the private key structure in OpenSSL). <br></p><p>  The private key itself, as it turned out, is stored in clear text in the internal field of the certificate - impl / fallback / _cert / _rsa / rsa.  This is a RSAManaged class, and a quick glance at its code (for example, the <a href="">DecryptValue</a> method) shows how bad mono is with cryptography.  Instead of honestly using OpenSSL cryptography methods, they seem to have implemented several algorithms manually.  This assumption is supported by an empty search result for their project using OpenSSL methods such as CMS_final, CMS_sign or CMS_ContentInfo_new.  And without them, it is difficult to imagine the formation of a standard CMS signature structure.  At the same time, the work with certificates is partially conducted through OpenSSL. </p><br><p>  This suggests that the private key will have to be unloaded from mono and loaded into EVP_PKEY via pem.  Because of this, we again need a class derived from X509Certificate, which will store all additional links. </p><br><p>  However, as in the case of CryptoPro, attempts to create a new certificate from Handle do not lead to success either (mono crashes with an error), and creating a certificate based on the resulting certificate leads to memory leaks.  Therefore, the only option is to create a certificate based on the byte array containing pem.  PEM certificate can be obtained as follows: </p><br><div class="spoiler">  <b class="spoiler_title">PEM certification</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_fBase64"&gt; Base64&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToCerFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fBase64 = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span></span><span class="hljs-function">)</span></span> { _arData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arData = _pCert.Export(X509ContentType.Cert); <span class="hljs-comment"><span class="hljs-comment">// 0) DER if (!_fBase64) { _arData = arData; return UConsts.S_OK; } // 1) Base64 using (TextWriter pWriter = new StringWriter()) { pWriter.WriteLine(UCConsts.S_PEM_BEGIN_CERT); pWriter.WriteLine(Convert.ToBase64String(arData, Base64FormattingOptions.InsertLineBreaks)); pWriter.WriteLine(UCConsts.S_PEM_END_CERT); // 1.2)   _arData = Encoding.UTF8.GetBytes(pWriter.ToString()); } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_TO_PEM_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>  The certificate is obtained without the private key and we connect it ourselves, forming a separate field for the link to ENV_PKEY: </p><br><div class="spoiler">  <b class="spoiler_title">Generating an ENV_PKEY based on the PEM private key</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; OpenSSL    (EVP_PKEY)    &lt;/summary&gt; * &lt;remarks&gt;      PEM&lt;/remarks&gt; * &lt;param name="_arData"&gt;   &lt;/param&gt; * &lt;returns&gt;   (EVP_PKEY)&lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetENV_PKEYOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData</span></span></span><span class="hljs-function">)</span></span> { IntPtr hBIOPem = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   BIO hBIOPem = UOpenSSLAPI.BIO_new_mem_buf( _arData, _arData.Length); if (hBIOPem == IntPtr.Zero) return IntPtr.Zero; IntPtr hKey = IntPtr.Zero; // 1)     UOpenSSLAPI.PEM_read_bio_PrivateKey(hBIOPem, ref hKey, IntPtr.Zero, 0); return hKey; } finally { if(hBIOPem != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOPem); } }</span></span></code> </pre></div></div><br><p>  Uploading a private key to a PEM is a much more complicated task than a PEM certificate, but it is already described <a href="https://gist.github.com/therightstuff/aa65356e95f8d0aae888e9f61aa29414">here</a> .  Note that unloading the private key is an ‚Äúextremely unsafe‚Äù case, and this should be avoided in every way.  And since this work becomes mandatory for working with OpenSSL, on Windows it is better to use crypt32.dll methods or regular .Net classes to use this library.  On Linux, you‚Äôll have to work this way for now. </p><br><p>  It is also worth remembering that the generated links point to an unmanaged memory area and they must be freed.  Since  in .Net 4.5 X509Certificate2 is not Disposable, then this should be done in the destructor </p><br><h2>  Signing </h2><br><p>  To sign OpenSSL, you can use the simplified CMS_sign method, but it is based on the configuration file, which will be the same for all certificates, in the choice of algorithm.  Therefore, relying on the <a href="">code of</a> this method is better to implement a similar signature generation: </p><br><div class="spoiler">  <b class="spoiler_title">Data signature</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arData"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt; &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignDataOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlags = UCConsts.CMS_DETACHED; IntPtr hData = IntPtr.Zero; IntPtr hBIORes = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   ISDP_X509Cert pCert = ISDP_X509Cert.Convert(_pCert, TCryptoPath.cpOpenSSL); // 1)  BIO   int iRes = GetBIOByBytesOS(_arData, out hData, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)   BIO hBIORes = UOpenSSLAPI.BIO_new(UOpenSSLAPI.BIO_s_mem()); // 3)    hCMS = UOpenSSLAPI.CMS_ContentInfo_new(); if (hCMS == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_CR_ERR); if (!UOpenSSLAPI.CMS_SignedData_init(hCMS)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_INIT_ERR); // 4)   if(UOpenSSLAPI.CMS_add1_signer(hCMS, pCert.hRealHandle, pCert.hOSKey, pCert.hOSDigestAlg, iFlags) == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_SET_SIGNER_ERR); // 5)   -   if (!UOpenSSLAPI.CMS_set_detached(hCMS, 1)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_SET_DET_ERR); // 6)    if (!UOpenSSLAPI.CMS_final(hCMS, hData, IntPtr.Zero, iFlags)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_FINAL_ERR); // 7)    BIO if (!UOpenSSLAPI.i2d_CMS_bio_stream(hBIORes, hCMS, IntPtr.Zero, iFlags)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_EXP_TO_BIO_ERR); // 8)     BIO return ReadFromBIO_OS(hBIORes, out _arRes, ref _sError); } catch (Exception E) { _sError = UCConsts.S_SIGN_OS_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hBIORes != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIORes); if(hData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>  The flow of the algorithm is as follows.  First we convert the incoming certificate (if it is X509Certificate2) into our type.  Since  we work with links to the unmanaged memory area, then they must be closely monitored.  .Net after some time after the reference to the certificate from the scope is released, it will start the destructor itself.  And in it, we have precisely prescribed the methods necessary for cleaning all the unmanaged memory associated with it.  Such an approach will allow us not to waste time on tracking these links directly inside the method. </p><br><p>  Having dealt with the certificate we form BIO with the data and the structure of the signature.  Then we add the signer's data, set the signature detachment flag and start the final signature generation.  The result is transferable to BIO.  It remains only to extract the byte array from BIO.  Converting a BIO into a set of bytes and back is often used, so it is better to put them into separate methods: </p><br><div class="spoiler">  <b class="spoiler_title">BIO in byte [] and back</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  BIO    OpenSSL&lt;/summary&gt; * &lt;param name="_hBIO"&gt; BIO&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_iLen"&gt; ,  0 -    &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadFromBIO_OS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hBIO, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _iLen = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; IntPtr hRes = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iLen = _iLen; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iLen == <span class="hljs-number"><span class="hljs-number">0</span></span>) iLen = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   iLen = UOpenSSLAPI.BIO_read(_hBIO, IntPtr.Zero, int.MaxValue); // 1)      hRes = Marshal.AllocHGlobal((int)iLen); if (UOpenSSLAPI.BIO_read(_hBIO, hRes, iLen) != iLen) { _sError = UCConsts.S_OS_BIO_READ_LEN_ERR; return UConsts.E_CRYPTO_ERR; } // 2)   _arRes = new byte[iLen]; Marshal.Copy(hRes, _arRes, 0, _arRes.Length); return UConsts.S_OK;; } catch (Exception E) { _sError = UCConsts.S_OS_BIO_READ_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hRes != IntPtr.Zero) Marshal.FreeHGlobal(hRes); } } /**&lt;summary&gt; BIO   &lt;/summary&gt; * &lt;param name="_arData"&gt;&lt;/param&gt; * &lt;param name="_hBIO"&gt;   BIO&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/ internal static int GetBIOByBytesOS(byte[] _arData, out IntPtr _hBIO, ref string _sError) { _hBIO = UOpenSSLAPI.BIO_new_mem_buf( _arData, _arData.Length); if (_hBIO == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_OS_CM_BIO_CR_ERR); return UConsts.S_OK; }</span></span></code> </pre></div></div><br><p>  As in the case of CryptoPro, it is necessary to extract information about the signature hashing algorithm from the certificate.  But in the case of OpenSSL, it is stored directly in the certificate: </p><br><div class="spoiler">  <b class="spoiler_title">Extract Hash Algorithm</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;      OpenSSL&lt;/summary&gt; * &lt;param name="_hCert"&gt;  (X509)&lt;/param&gt; * &lt;returns&gt; &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDigestAlgOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert</span></span></span><span class="hljs-function">)</span></span> { x509_st pCert = (x509_st)Marshal.PtrToStructure(_hCert, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(x509_st)); X509_algor_st pAlgInfo = (X509_algor_st)Marshal.PtrToStructure(pCert.sig_alg, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(X509_algor_st)); IntPtr hAlgSn = UOpenSSLAPI.OBJ_nid2sn(UOpenSSLAPI.OBJ_obj2nid(pAlgInfo.algorithm)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UOpenSSLAPI.EVP_get_digestbyname(hAlgSn); }</code> </pre></div></div><br><p>  The method turned out pretty tricky, but it works.  In the 1.0.2 documentation, you can find the <a href="https://www.openssl.org/docs/man1.0.2/crypto/EVP_get_digestbynid.html">EVP_get_digestbynid</a> method, but the libraries of the version we use do not export it.  Therefore, we first form a nid, and based on it a short name.  And already by the short name, you can extract the algorithm using the standard method of searching by name. </p><br><h2>  Signature verification </h2><br><p>  The received signature needs verification.  OpenSSL verifies the signature as follows: </p><br><div class="spoiler">  <b class="spoiler_title">Signature verification</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arData"&gt;,   &lt;/param&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pLocation"&gt;&lt;/param&gt; * &lt;param name="_fVerifyOnlySign"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * &lt;remarks&gt;   &lt;/remarks&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckSignOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _fVerifyOnlySign = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, StoreLocation _pLocation = StoreLocation.CurrentUser</span></span></span><span class="hljs-function">)</span></span>{ _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; IntPtr hBIOData = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; IntPtr hTrStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)  BIO     int iRes = GetBIOByBytesOS(_arData, out hBIOData, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 1)   CMS iRes = GetCMSFromBytesOS(_arSign, out hCMS, ref _sError); if (iRes != UConsts.S_OK) return iRes; uint iFlag = UCConsts.CMS_DETACHED; // 2)    if (!_fVerifyOnlySign) { iRes = GetTrustStoreOS(_pLocation, out hTrStore, ref _sError); if (iRes != UConsts.S_OK) return iRes; } else iFlag |= UCConsts.CMS_NO_SIGNER_CERT_VERIFY; // 3)   if (!UOpenSSLAPI.CMS_verify(hCMS, IntPtr.Zero, hTrStore, hBIOData, IntPtr.Zero, iFlag)) return RetErrOS(ref _sError, UCConsts.S_OS_CM_CHECK_ERR); return UConsts.S_OK; } finally { if(hBIOData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); if(hTrStore != IntPtr.Zero) UOpenSSLAPI.X509_STORE_free(hTrStore); } }</span></span></code> </pre></div></div><br><p>  First, the signature data is converted from the byte array into the CMS structure: <br></p><br><div class="spoiler">  <b class="spoiler_title">Formation of the CMS structure</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; CMS   &lt;/summary&gt; * &lt;param name="_arData"&gt; CMS&lt;/param&gt; * &lt;param name="_hCMS"&gt;    CMS&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCMSFromBytesOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hCMS, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _hCMS = IntPtr.Zero; IntPtr hBIOCMS = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CMS hCMS = UOpenSSLAPI.CMS_ContentInfo_new(); if (hCMS == IntPtr.Zero) return RetErrOS(ref _sError); if (!UOpenSSLAPI.CMS_SignedData_init(hCMS)) return RetErrOS(ref _sError); // 1)    BIO hBIOCMS = UOpenSSLAPI.BIO_new_mem_buf(_arData, _arData.Length); if (hBIOCMS == IntPtr.Zero) return RetErrOS(ref _sError); // 2)   CMS if (UOpenSSLAPI.d2i_CMS_bio(hBIOCMS, ref hCMS) == IntPtr.Zero) return RetErrOS(ref _sError); // 3)   - ,    _hCMS = hCMS; hCMS = IntPtr.Zero; return UConsts.S_OK; } finally { if(hBIOCMS != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOCMS); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>     ,     BIO.    ,    ,        (  )      : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    &lt;/summary&gt; * &lt;param name="_hStore"&gt;   &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTrustStoreOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">StoreLocation _pLocation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hStore, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _hStore = IntPtr.Zero; IntPtr hStore = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { List&lt;X509Certificate2&gt; pCerts = GetCertList(_pLocation, StoreName.Root, TCryptoPath.cpOpenSSL); pCerts.AddRange(GetCertList(_pLocation, StoreName.AuthRoot, TCryptoPath.cpOpenSSL)); <span class="hljs-comment"><span class="hljs-comment">// 1)   hStore = UOpenSSLAPI.X509_STORE_new(); foreach (X509Certificate2 pCert in pCerts) { //      (    ) UOpenSSLAPI.X509_STORE_add_cert(hStore, pCert.getRealHandle()); } // 2)   UOpenSSLAPI.ERR_clear_error(); _hStore = hStore; hStore = IntPtr.Zero; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_FORM_TRUST_STORE_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if (hStore != IntPtr.Zero) UOpenSSLAPI.X509_STORE_free(hStore); }</span></span></code> </pre></div></div><br><p>         ,         (   ,    ).     CMS_Verify,    . </p><br><p>       (,       CRL),      iFlag   . </p><br><h2>    </h2><br><p>               .        ,   ,           .  .Net    ‚Äî SignedCms,                   . </p><br><p>        (   ,     )        .         ‚Äî     ,    . </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_arSign"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_arContent"&gt;  &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arSign, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arContent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hBIOData = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; IntPtr hCerts = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    MS int iRes = UCUtils.GetCMSFromBytesOS(_arSign, out hCMS, ref _sError); if(iRes != UConsts.S_OK) return iRes; iRes = UCUtils.GetBIOByBytesOS(_arContent, out hBIOData, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 1)   uint iFlags = UCConsts.CMS_NO_SIGNER_CERT_VERIFY; if(_arContent.Length == 0) iFlags |= UCConsts.CMS_NO_CONTENT_VERIFY; // 2)  CMS if (!UOpenSSLAPI.CMS_verify(hCMS, IntPtr.Zero, IntPtr.Zero, hBIOData, IntPtr.Zero, iFlags)) return UCUtils.RetErrOS(ref _sError, UCConsts.S_OS_CMS_VERIFY_ERR); // 3)   hCerts = UOpenSSLAPI.CMS_get0_signers(hCMS); int iCnt = UOpenSSLAPI.sk_num(hCerts); for (int i = 0; i &lt; iCnt; i++) { IntPtr hCert = UOpenSSLAPI.sk_value(hCerts, i); byte[] arData; iRes = UCUtils.GetCertBytesOS(hCert, out arData, ref _sError); if(iRes != UConsts.S_OK) return iRes; fpCertificates.Add(ISDP_X509Cert.Create(arData, TCryptoPath.cpOpenSSL)); } // 4)   IntPtr hSigners = UOpenSSLAPI.CMS_get0_SignerInfos(hCMS); iCnt = UOpenSSLAPI.sk_num(hSigners); for (int i = 0; i &lt; iCnt; i++) { IntPtr hSignerInfo = UOpenSSLAPI.sk_value(hSigners, i); // 4.1)    ISDPSignerInfo pInfo = new ISDPSignerInfo(this); iRes = pInfo.DecodeOS(hSignerInfo, ref _sError); if(iRes != UConsts.S_OK) return iRes; fpSignerInfos.Add(pInfo); } return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_OS_CMS_DECODE.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hCerts != IntPtr.Zero) UOpenSSLAPI.sk_free(hCerts); if(hBIOData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIOData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>     ,      BIO     ( )   CMS,    .    ,          ‚Äî        . </p><br><p>         (STACK_OF(X509)),      sk_pop,       .     ,          sk_value. </p><br><p>  ,         CMS_get0_signers  CMS_get1_certs.     ,   .      ,       ,         : </p><br><pre> <code class="hljs lisp">CRYPTO_add(<span class="hljs-name"><span class="hljs-name">&amp;cch-&gt;d</span></span>.certificate-&gt;references, <span class="hljs-number"><span class="hljs-number">1</span></span>, CRYPTO_LOCK_X509)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>   <a href="">1.1.0</a>    X509_up_ref,      . <br>         : </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hSignerInfo"&gt;Handler    (OpenSSL)&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hSignerInfo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)    int iRes = UCUtils.GetSignerInfoCertOS(_hSignerInfo, fpSignedCMS.pCertificates, out fpCertificate, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 1)    uint iPos = UOpenSSLAPI.CMS_signed_get_attr_by_NID(_hSignerInfo, UCConsts.NID_pkcs9_signingTime, 0); IntPtr hAttr = UOpenSSLAPI.CMS_signed_get_attr(_hSignerInfo, iPos); IntPtr hDateTime = UOpenSSLAPI.X509_ATTRIBUTE_get0_data(hAttr, 0, UCConsts.V_ASN1_UTCTIME, IntPtr.Zero); asn1_string_st pDate = (asn1_string_st)Marshal.PtrToStructure(hDateTime, typeof(asn1_string_st)); // 2)   Pkcs9SigningTime byte[] arDateAttr = new byte[pDate.iLength]; Marshal.Copy(pDate.hData, arDateAttr, 0, (int)pDate.iLength); arDateAttr = new byte[] { (byte)UCConsts.V_ASN1_UTCTIME, (byte)pDate.iLength}.Concat(arDateAttr).ToArray(); fpSignedAttributes.Add(new Pkcs9SigningTime(arDateAttr)); return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_CMS_SIGNER_DEC_OS_ER.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>  ,    ,     .          ASN.1.      asn1_string_st         Pkcs9SigningTime. </p><br><p>    : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_hSignerInfo"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_pCerts"&gt;   &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSignerInfoCertOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hSignerInfo, X509Certificate2Collection _pCerts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)     IntPtr hKey = IntPtr.Zero; IntPtr hIssuer = IntPtr.Zero; IntPtr hSNO = IntPtr.Zero; if (!UOpenSSLAPI.CMS_SignerInfo_get0_signer_id(_hSignerInfo, ref hKey, ref hIssuer, ref hSNO)) return RetErrOS(ref _sError, UCConsts.S_GET_RECEIP_INFO_ERR); // 1)    string sSerial; int iRes = GetBinaryHexFromASNOS(hSNO, out sSerial, ref _sError); if(iRes != UConsts.S_OK) return iRes; X509Certificate2Collection pResCerts = _pCerts.Find(X509FindType.FindBySerialNumber, sSerial, false); if(pResCerts.Count == 0) return RetErrOS(ref _sError, UCConsts.S_NO_CERTIFICATE, UConsts.E_NO_CERTIFICATE); _pCert = pResCerts[0]; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_GET_SIGN_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>        ,          .       asn1_string_st,         hex : </p><br><div class="spoiler"> <b class="spoiler_title"> hex    ANS.1</b> <div class="spoiler_text"><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; Hex     ASN.1&lt;/summary&gt; * &lt;param name="_hASN"&gt;   ASN.1&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_sHexData"&gt;   Hex&lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBinaryHexFromASNOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hASN, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sHexData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _sHexData = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asn1_string_st pSerial = (asn1_string_st)Marshal.PtrToStructure(_hASN, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(asn1_string_st)); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] arStr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[pSerial.iLength]; Marshal.Copy(pSerial.hData, arStr, <span class="hljs-number"><span class="hljs-number">0</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)pSerial.iLength); _sHexData = arStr.ToHex().ToUpper(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.S_OK; } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception E) { _sError = UCConsts.S_HEX_ASN_BINARY_ERR.Frm(E.Message); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> UConsts.E_GEN_EXCEPTION; } }</code> </pre></div></div><br><p>      ,      ,    . </p><br><h2>  </h2><br><p>   OpenSSL    : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_pReceipients"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;   ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncryptDataOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, List&lt;X509Certificate2&gt; _pReceipients, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlags = UCConsts.CMS_BINARY; IntPtr hData = IntPtr.Zero; IntPtr hReceipts = IntPtr.Zero; IntPtr hBIORes = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)  BIO     int iRes = GetBIOByBytesOS(_arInput, out hData, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 1)     iRes = GetCertsStackOS(_pReceipients, out hReceipts, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 2)  CMS hCMS = UOpenSSLAPI.CMS_encrypt(hReceipts, hData, UOpenSSLAPI.EVP_des_ede3_cbc(), iFlags); if (hCMS == IntPtr.Zero) return RetErrOS(ref _sError, UCConsts.S_ENC_CMS_ERR); // 3)  CMS  BIO hBIORes = UOpenSSLAPI.BIO_new(UOpenSSLAPI.BIO_s_mem()); if (!UOpenSSLAPI.i2d_CMS_bio_stream(hBIORes, hCMS, IntPtr.Zero, iFlags)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_EXP_TO_BIO_ERR); // 4)   BIO    return ReadFromBIO_OS(hBIORes, out _arRes, ref _sError); } catch (Exception E) { _sError = UCConsts.S_ENC_OS_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hBIORes != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIORes); if(hData != IntPtr.Zero) UOpenSSLAPI.BIO_free(hData); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); if(hReceipts != IntPtr.Zero) UOpenSSLAPI.sk_free(hReceipts); } }</span></span></code> </pre></div></div><br><p>    BIO      ‚Äî .        .    ,       BIO    . OpenSSL      ,    ,    ,   .          EVP_des_ede3_cbc,       . </p><br><p>         , . .           OpenSSL: </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt;* &lt;param name="_hStack"&gt; &lt;/param&gt; * &lt;param name="_pCerts"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCertsStackOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;X509Certificate2&gt; _pCerts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IntPtr _hStack, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _hStack = IntPtr.Zero; IntPtr hStack = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { hStack = UOpenSSLAPI.sk_new_null(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (X509Certificate2 pCert <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _pCerts) { <span class="hljs-comment"><span class="hljs-comment">// 0)  ,     ISDP_X509Cert pLocCert = ISDP_X509Cert.Convert(pCert, TCryptoPath.cpOpenSSL); // 1)  UOpenSSLAPI.sk_push(hStack, pLocCert.hRealHandle); } _hStack = hStack; hStack = IntPtr.Zero; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_GEN_CERT_STACK_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hStack != IntPtr.Zero) UOpenSSLAPI.sk_free(hStack); } }</span></span></code> </pre></div></div><br><h2>  </h2><br><p>     ,        .      : </p><br><ol><li> ,       ; </li><li>   ; </li><li>           ; </li><li>     ; </li><li>      BIO    ; </li></ol><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt; &lt;/summary&gt; * &lt;param name="_arInput"&gt;  &lt;/param&gt; * &lt;param name="_arRes"&gt;&lt;/param&gt; * &lt;param name="_pLocation"&gt; ,  &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;param name="_pCert"&gt;&lt;/param&gt; * &lt;returns&gt;  ,  UCOnsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecryptDataOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arInput, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] _arRes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError, StoreLocation _pLocation = StoreLocation.CurrentUser </span></span></span><span class="hljs-function">)</span></span> { _arRes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlag = UCConsts.CMS_BINARY; IntPtr hBIORes = IntPtr.Zero; IntPtr hCMS = IntPtr.Zero; X509Certificate2 pCert; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   CMS int iRes = GetCMSFromBytesOS(_arInput, out hCMS, ref _sError); if (iRes != UConsts.S_OK) return iRes; // 1)     IntPtr hReceipts = UOpenSSLAPI.CMS_get0_RecipientInfos(hCMS); int iCnt = UOpenSSLAPI.sk_num(hReceipts); for(int i = 0; i &lt; iCnt; i++) { IntPtr hRecep = UOpenSSLAPI.sk_value(hReceipts, i); iRes = GetRecepInfoCertOS(hRecep, _pLocation, out pCert, ref _sError); if (iRes != UConsts.S_OK &amp;&amp; iRes != UConsts.E_NO_CERTIFICATE) return iRes; // 1.1)   if (iRes == UConsts.E_NO_CERTIFICATE) continue; ISDP_X509Cert pLocCert = ISDP_X509Cert.Convert(pCert); // 1.2)    if (pLocCert.hOSKey == IntPtr.Zero) continue; // 1.3)   if (!UOpenSSLAPI.CMS_RecipientInfo_set0_pkey(hRecep, pLocCert.hOSKey)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_SET_DEC_KEY_ERR); try { // 1.4)  if (!UOpenSSLAPI.CMS_RecipientInfo_decrypt(hCMS, hRecep)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_REC_DEC_ERR); } finally { // !!      UOpenSSLAPI.CMS_RecipientInfo_set0_pkey(hRecep, IntPtr.Zero); } // 1.5)   hBIORes = UOpenSSLAPI.BIO_new(UOpenSSLAPI.BIO_s_mem()); if (!UOpenSSLAPI.CMS_decrypt(hCMS, IntPtr.Zero, pLocCert.hRealHandle, IntPtr.Zero, hBIORes, iFlag)) return RetErrOS(ref _sError, UCConsts.S_OS_CMS_FULL_DEC_ERR); _pCert = pLocCert; // 2)     BIO return ReadFromBIO_OS(hBIORes, out _arRes, ref _sError); } _sError = UCConsts.S_DEC_NO_CERT_ERR; return UConsts.E_NO_CERTIFICATE; } catch (Exception E) { _sError = UCConsts.S_DEC_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } finally { if(hBIORes != IntPtr.Zero) UOpenSSLAPI.BIO_free(hBIORes); if(hCMS != IntPtr.Zero) UOpenSSLAPI.CMS_ContentInfo_free(hCMS); } }</span></span></code> </pre></div></div><br><p>        .   ,          CMS_RecipientInfo_set0_pkey,       CMS,            . </p><br><p>  ,   ,       .        ,        .        : </p><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;  &lt;/summary&gt; * &lt;param name="_hRecep"&gt;  &lt;/param&gt; * &lt;param name="_pCert"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt;   &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRecepInfoCertOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hRecep, StoreLocation _pLocation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X509Certificate2 _pCert, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { _pCert = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)     IntPtr hKey = IntPtr.Zero; IntPtr hIssuer = IntPtr.Zero; IntPtr hSNO = IntPtr.Zero; if (!UOpenSSLAPI.CMS_RecipientInfo_ktri_get0_signer_id(_hRecep, ref hKey, ref hIssuer, ref hSNO)) return RetErrOS(ref _sError, UCConsts.S_GET_RECEIP_INFO_ERR); // 1)    string sSerial; int iRes = GetBinaryHexFromASNOS(hSNO, out sSerial, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 2)   iRes = FindCertificateOS(sSerial, out _pCert, ref _sError, _pLocation, StoreName.My, X509FindType.FindBySerialNumber); if(iRes != UConsts.S_OK) return iRes; return UConsts.S_OK; } catch (Exception E) { _sError = UCConsts.S_GET_RECEIP_INFO_GEN_ERR.Frm(E.Message); return UConsts.E_GEN_EXCEPTION; } }</span></span></code> </pre></div></div><br><p>  CMS_RecipientInfo_ktri_get0_signer_id     ,        hSNO        .      . </p><br><p> C  ,  ,   <a href="https://tools.ietf.org/html/rfc3211"></a> .          ktri ‚Äî      .      OpenSSL    : CMS_RecipientInfo_kari_*, CMS_RecipientInfo_kekri_*   CMS_RecipientInfo_set0_password  pwri. </p><br><h2>   </h2><br><p>      ,          .               .        , . .         .  OpenSSL     .         (    ),      ,      . <br></p><p> ,  ,   ,           : </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;    OpenSSL&lt;/summary&gt; * &lt;param name="_iRevFlag"&gt; &lt;/param&gt; * &lt;param name="_iRevMode"&gt; &lt;/param&gt; * &lt;param name="_hCert"&gt; &lt;/param&gt; * &lt;param name="_rOnDate"&gt; &lt;/param&gt; * &lt;param name="_pLocation"&gt; &lt;/param&gt; * &lt;param name="_sError"&gt;   &lt;/param&gt; * &lt;returns&gt;  ,  UConsts.S_OK   &lt;/returns&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyCertificateOS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hCert, X509RevocationMode _iRevMode, X509RevocationFlag _iRevFlag, StoreLocation _pLocation, DateTime _rOnDate, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _sError</span></span></span><span class="hljs-function">)</span></span> { IntPtr hStore = IntPtr.Zero; IntPtr hStoreCtx = IntPtr.Zero; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// 0)   int iRes = GetTrustStoreOS(_pLocation, out hStore, ref _sError); if(iRes != UConsts.S_OK) return iRes; // 1)    hStoreCtx = UOpenSSLAPI.X509_STORE_CTX_new(); if (!UOpenSSLAPI.X509_STORE_CTX_init(hStoreCtx, hStore, _hCert, IntPtr.Zero)) { _sError = UCConsts.S_CRYPTO_CONTEXT_CER_ERR; return UConsts.E_CRYPTO_ERR; } // 2)       SetStoreCtxCheckDate(hStoreCtx, _rOnDate); // 3)  if (!UOpenSSLAPI.X509_verify_cert(hStoreCtx)) { _sError = UCConsts.S_CRYPTO_CHAIN_CHECK_ERR.Frm(GetCertVerifyErr(hStoreCtx)); return UConsts.E_CRYPTO_ERR; } return UConsts.S_OK; } finally { if (hStore != IntPtr.Zero) UOpenSSLAPI.X509_STORE_free(hStore); if (hStoreCtx != IntPtr.Zero) UOpenSSLAPI.X509_STORE_CTX_free(hStoreCtx); } }</span></span></code> </pre></div></div><br><p>     (X509_STORE_CTX)     .      : </p><br><div class="spoiler"> <b class="spoiler_title">    </b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/**&lt;summary&gt;   &lt;/summary&gt; * &lt;param name="_hStoreCtx"&gt; &lt;/param&gt; * &lt;param name="_rDate"&gt;&lt;/param&gt; * **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetStoreCtxCheckDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr _hStoreCtx, DateTime _rDate</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> iFlags = UCConsts.X509_V_FLAG_USE_CHECK_TIME | UCConsts.X509_V_FLAG_X509_STRICT | UCConsts.X509_V_FLAG_CRL_CHECK_ALL; <span class="hljs-comment"><span class="hljs-comment">//   UOpenSSLAPI.X509_STORE_CTX_set_flags(_hStoreCtx, iFlags); //   UOpenSSLAPI.X509_STORE_CTX_set_time(_hStoreCtx, iFlags, (uint)_rDate.ToUnix()); //   -   UOpenSSLAPI.X509_STORE_CTX_set_trust(_hStoreCtx, UCConsts.X509_TRUST_TRUSTED); }</span></span></code> </pre></div></div><br><p>     ,           . </p><br><h1>  Conclusion </h1><br><p>     ,      .       X509Certificate2 (mono)      .      . </p><br><p>   ,  Windows              .       .  Linux ,        ,        . </p><br><p>       <a href="https://www.cryptopro.ru/products/csp_5_0">CSP 5.0</a> ,     RSA .      ,     ,   ,          RSA, ,    . </p><br><h1>  Links </h1><br><ol><li> OpenSSL 1.0.2 <a href="https://www.openssl.org/docs/man1.0.2/crypto/">ManPages</a> ; </li><li>   OpenSSL <a href="https://www.openssl.org/docs/faq.html">1</a>  <a href="https://www.openssl.org/blog/blog/2017/02/21/threads/">2</a> ; </li><li>  <a href="https://github.com/openssl/openssl/tree/32f803d88ec3df7f95dfbf840c271f7438ce3357">OpenSSL</a> : <br><ol><li> <a href="">cms_smime.c;</a> </li></ol></li><li> <a href="https://wiki.openssl.org/index.php/Libcrypto_API">Wiki OpenSSL</a> ; </li><li>  mono: <ol><li>  <a href="">RSAManaged</a> ; </li></ol><br></li></ol></div><p>Source: <a href="https://habr.com/ru/post/423769/">https://habr.com/ru/post/423769/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423759/index.html">Fintech Digest: personal data of citizens of the Russian Federation, Central Bank marketplace, new service from CloudFlare</a></li>
<li><a href="../423761/index.html">The court for 15 seconds decided on the claim TgVPN to Roskomnadzor</a></li>
<li><a href="../423763/index.html">What Uber Cash Teaches Innovators</a></li>
<li><a href="../423765/index.html">Writing an application for remote control of the MPV player from RetroOrangePi</a></li>
<li><a href="../423767/index.html">Hackers attacked the airline British Airways: stolen data 380,000 customer bank cards</a></li>
<li><a href="../423771/index.html">Once again, the PVS-Studio analyzer was more attentive than a human</a></li>
<li><a href="../423773/index.html">Roskomnadzor threatens to send a letter to Facebook</a></li>
<li><a href="../423775/index.html">I wanted a beautiful piece of iron. Happened</a></li>
<li><a href="../423777/index.html">Keystone Project: Trusted Environment for Running Applications Based on RISC-V</a></li>
<li><a href="../423779/index.html">Cloud-to-cloud backup: what it is and why it is needed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>