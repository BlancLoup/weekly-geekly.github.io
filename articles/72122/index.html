<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Oracle RAC. General Description / Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Highly loaded sites, availability of "5 nines". In the background (backend) a bunch of processed information in the database. And what if the iron goe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Oracle RAC. General Description / Part 1</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="http://img185.imageshack.us/img185/4262/introy.png">  Highly loaded sites, availability of "5 nines".  In the background (backend) a bunch of processed information in the database.  And what if the iron goes berserk, if some long-time non-existent error in the OS crashes, the network interface drops?  What will happen to the availability of information?  Out of pure curiosity, I decided to consider what solutions Oracle offers to solve the problems listed above.  The latest versions, unlike Oracle 9i, are called Oracle 10g (or 11g), where g means ‚Äúgrid‚Äù, distributed computing.  The basis of distributed computing "whatever one may say" is the cluster, and additional data replication technologies (DataGuard, Streams).  This article outlines how the cluster is based on Oracle 10g.  It is called <strong>Real Application Cluster</strong> ( <strong>RAC</strong> ). <br><br>  The article does not claim to be complete and comprehensive, also it excludes settings (so as not to increase in volume).  The point is just to give an idea of ‚Äã‚ÄãRAC technology. <br><br>  <em>PS Beware of the multi-book</em> <br>  <a href="http://habrahabr.ru/blogs/oracle/72121/">Article continuation</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  The article wanted to write as accessible as possible, to read it was interesting even for a person who was not familiar with Oracle DBMS.  Therefore, I would venture to begin the description with aspects of the most common database configuration - single-instance, when one Oracle server (RDBMS) resides on the same physical server.  This is not directly related to the cluster, but the basic requirements and principles of operation will be the same. <br><br><h3>  Introduction  Single-instance. </h3><br>  The most common database installed on a single physical server is called <strong>single-instance</strong> .  I have not betrayed the special meaning of the difference in concepts between: the instance of the database and the database itself (as a whole).  Now I want to especially note that an instance means software (processes, threads, services) which is located in RAM and processes data (sorting, buffering, maintenance) received directly from the disk.  Thus, a database means a combination of: <ul><li>  data storage area, i.e.  physical files on disk (datastorage) (the database itself) </li><li>  database instance (receiving and processing this data in RAM) (DBMS) </li></ul><br><div style="text-align:center;"><img src="http://img245.imageshack.us/img245/1827/tablespace.jpg"></div><br><br>  In all modern relational databases, data is stored in tables.  Tables, indexes and other objects in Oracle are stored in logical containers - table spaces ( <strong>tablespace</strong> ).  Physically, the tablespace is located in one or more files on the disk.  They are stored as follows: <br>  Each database object (tables, indexes, rollback segments, etc.) is stored in a separate <strong>segment</strong> ‚Äî a disk area that can take up space in one or more files.  Segments in turn consist of one or more extents.  <strong>An extent</strong> is a continuous piece of space in a file.  Extents consist of blocks.  <strong>A block</strong> is the smallest unit of space allocation in Oracle, the default is 8K.  Blocks store data rows, indexes, or intermediate results of locks.  It is in blocks that Oracle server usually reads and writes to disk.  Blocks have an address, the so-called <strong>DBA</strong> ( <strong>Database Block Address</strong> ). <br><br><div style="text-align:center;"><img src="http://img245.imageshack.us/img245/8986/cachek.jpg"></div><br><br>  Whenever DML (Data Manipulation Language) accesses the database, Oracle loads the appropriate blocks from disk into RAM, namely into the <strong>buffer cache</strong> .  Although it is possible that they are already there, and then the disk does not need to be addressed.  If the request changed the data (update, insert, delete), then the changes to the blocks occur directly in the buffer cache, and they are marked as dirty.  But blocks are not immediately flushed to disk.  After all, the disk is the bottleneck of any database, so Oracle tries to access it as little as possible.  Dirty blocks will be flushed to disk automatically by the background <strong>DBWn</strong> process when passing a checkpoint (checkpoint) or when switching logs. <br><br><div style="text-align:center;"><img src="http://img245.imageshack.us/img245/5913/sessions.jpg"></div><br>  Suppose that one long-running transaction was started reading data, and somewhere in the process of its execution another transaction was launched with the intention to change one of the read blocks.  How will the server coordinate these requests?  In fact, the question is divided into two: <br><ol><li>  What happens if Oracle falls somewhere in the middle of a long transaction (if it made changes)? </li><li>  What data will the first transaction read when in the cache ‚Äúunder the nose‚Äù another transaction has changed the block? </li></ol><br><br>  To answer these questions, we consider a mechanism for ensuring consistent <strong>CR</strong> reading ( <strong>consistency read</strong> ).  It's all about the <strike>magic bubbles</strike> transaction logs, which in Oracle are represented by two types: <ul><li>  redo log </li><li>  undo segment </li></ul><br><div style="text-align:center;"><img src="http://img203.imageshack.us/img203/9453/redoundo.jpg"></div><br>  When a change request arrives at the database, Oracle applies it in the buffer cache, in parallel, entering information sufficient to repeat this action into the <strong>redo log buffer</strong> in RAM.  As soon as the transaction is completed, it is confirmed, and the server flushes the contents of the redo buffer log to disk in <strong>redo log</strong> in append-write mode and commits the transaction.  Such an approach is much less expensive than writing a directly modified block to a disk.  If the server crashes, the cache and all changes in it will be lost, but the redo log files will remain.  When enabled, Oracle will start by looking at them and re-doing changes to the tables (transactions) that were not reflected in the datafiles.  This is called "rolling" changes from redo, roll-forward.  Online redo log is flushed to disk ( <strong>LGWR</strong> ) when confirming a transaction, passing a checkpoint or every 3 seconds (default). <br><br>  With <strong>undo a</strong> little more complicated.  An associated <strong>cancel</strong> segment is stored with each table in the adjacent segment.  When requesting DML along with the table blocks, the data from the rollback segment is necessarily loaded and also stored in the buffer cache.  When the data in the table is changed in the cache, the undo data also changes in the cache, ‚Äúcounteractions‚Äù are entered there.  That is, if insert was inserted into the table, then delete is inserted into the rollback segment, delete - insert, update - the previous value of the string is entered.  The blocks (and the corresponding undo data) are marked as dirty and go to the redo log buffer.  Yes, yes, not only instructions are recorded in the redo log, which changes should be made (redo), but also what countermeasures (undo) they have.  Since the LGWR resets the redo log buffer every 3 seconds, if the long transaction fails (for a couple of minutes), when after a minute the server crashes, the redo records will not complete commit.  Oracle, as it wakes up, rolls them (roll-forward), and on the recovered data rollback segments (from the redo log) in memory, roll-back cancels all uncommitted transactions.  Justice restored. <br><br>  Briefly worth mentioning is another indisputable advantage of the undo segment.  In the second scenario (from the diagram), when select reaches the block read (DBA) 500, it suddenly finds that this block in the cache has already been changed (marked dirty), and therefore will turn to the rollback segment in order to get the corresponding previous block state.  If there was no such previous state (flashback) in the cache, it will read it from the disk and continue the execution of select.  Thus, even with a long ‚Äúselect count (money) from bookkeeping,‚Äù the debit and credit will converge.  Coordinated reading (CR). <br><br><h5>  Distracted.  It's time to look for approaches to the cluster configuration.  =) </h5><br><br><h2>  Level of access to data.  ASM. </h2><br><br><div style="text-align:center;"><img src="http://img245.imageshack.us/img245/7548/asm.jpg"></div><br>  Storage ( <strong>datastorage</strong> ) in large databases is almost always <strong>SAN</strong> ( <strong>Storage Area Network</strong> ), which provides a transparent interface for servers to disk arrays. <br>  Third-party vendors (Hitachi, HP, Sun, Veritas) offer comprehensive solutions for organizing such SANs based on a number of protocols (the most common is Fiber Channel), with additional functionality: mirroring, load balancing, connecting disks on the fly, partitioning space between partitions and .t.p. <br>  The position of Oracle Corporation in building a database of any scale comes down to the fact that you only need the appropriate software from Oracle (with the appropriate licenses), and the selected equipment - if possible (if the funds remain after the purchase of Oracle :).  Thus, to build a high-load database, you can do without expensive SPARC servers and stuffed SANs using servers on free Linux and cheap RAID arrays. <br><br>  At the level of access to data and disks, Oracle offers its solution - <strong>ASM</strong> ( <strong>Automatic Storage Management</strong> ).  This is a separately installed Oracle mini-instance (INSTANCE_TYPE = ASM) that provides disk services for each node of the cluster. <br><br>  Oracle is trying to avoid disk access because  this is probably the main bottleneck of any database.  Oracle performs data caching functions, but after all, file systems also buffer write to the disk.  And why double buffer data?  Moreover, if Oracle has confirmed the transaction and received notifications that the changes have been made to the files, it is desirable that they were already there, and not in the cache, in case the database is ‚Äúdropped‚Äù.  Therefore, it is recommended to use RAW devices (disks without a file system), which makes ASM. <br><br>  ASM runs on top of the RAW device, its advantages are: <ul><li> no need for separate disk partition management software </li><li>  no need for file system </li></ul><br>  <strong>Disk group</strong> - combining multiple disks.  When writing files to disks, data is recorded in extents of 1 MB in size, distributing them across all disks in a group.  This is done in order to ensure high availability, because parts of the same table (from the tablespace) are scattered across different physical disks. <br><br>  ASM Abilities: <ul><li>  Data Mirroring: <br>  as a rule, 2 or 3-step, i.e.  data is simultaneously recorded on 2 or 3 disks.  For disk mirroring, no more than 8 partner disks are specified, to which copies of data will be distributed. </li><li>  Automatic disk load balancing (ensuring high availability): <br>  if the tablespace data is placed on 10 disks and, at some point in time, reading data from certain disks will go off-scale, ASM itself will access the same extents, but residing on mirrored disks. </li><li>  Automatic rebalancing: <br>  When you remove a disk, ASM on the fly duplicates the extents that it contained on the other disks remaining in the group.  When added to a group of disk, will move the extents in the group so that on each disk will be approximately equal number of extents. </li></ul><br>  Suppose that several disks are connected to a specific controller ‚Äî and thus represent SPF ‚Äî single point of failure (if the controller fails, we lose the entire disk array).  ASM has a technology for defining <strong>Failure Groups</strong> within the Disk Group.  With this mechanism, mirroring will scatter copies of extents across disks in different failure groups to avoid <strong>SPF</strong> ( <strong>Single Point of Failure</strong> ), for example, when a SAN or a RAID controller dies. <br><br>  Thus, the cluster can now store and read data from a shared file storage. <br><h5>  It's time to level up. </h5><br><br><h2>  Clusterware.  CRS. </h2><br><br>  At this level, it is necessary to ensure coordination and joint work of cluster nodes, i.e.  clusterware layer: somewhere between the database instance itself and disk storage: <br><br>  <strong>CRS</strong> ( <strong>Cluster-Ready Services</strong> ) is a set of services that ensures the joint operation of nodes, fault tolerance, high system availability, and system recovery after a failure.  CRS looks like a ‚Äúmini-instance‚Äù of the database (software) installed on each node of the cluster.  Installing CRS is mandatory for building Oracle RAC.  In addition, CRS can be integrated with third-party clusterware solutions such as HP or Sun. <br><br>  Again a bit of "terminology" ... <br><br>  CRS consists of 3 main components: <ul><li>  CSSD - Cluster Synchronization Service Daemon </li><li>  CRSD - Cluster Ready Services Daemon </li><li>  EVMD - Event Monitor Daemon </li></ul><table><tbody><tr><td>  x </td><td>  Assignment (in brief) </td><td>  What rights does it work with? </td><td>  When the process dies, it reboots: </td></tr><tr><td>  CSSD </td><td>  A synchronization mechanism for communicating nodes in a clustered environment. </td><td>  user </td><td>  process </td></tr><tr><td>  CRSD </td><td>  The main "engine" to support the availability of resources </td><td>  root </td><td>  host </td></tr><tr><td>  EVMD </td><td>  The process of notification of events occurring in the cluster </td><td>  user </td><td>  process </td></tr></tbody></table>  Cluster settings are stored in <strong>OCR</strong> ( <strong>Oracle Cluster Registry</strong> ).  OCR is a special file of database node profiles that stores their current configuration: node availability, service distribution (several databases can be supported by different groups of nodes in a cluster), network settings, etc.  Physically, OCR is stored in general datastorage.  When a cluster is running, each node stores OCR in memory, and only one node (master) directly updates the OCR on the disk. <br><br>  As it became clear from the tablet, the most important process, the ‚Äúmost powerful demon‚Äù, is <strong>CRSD</strong> ( <strong>Cluster Ready Services Daemon</strong> ).  His responsibilities include: starting, stopping the node, generating failure logs, reconfiguring the cluster in case of a node falling, he is also responsible for recovering from failures and maintaining the OCR profile file.  If the daemon crashes, the node reboots completely.  CRS manages OCR resources: Global Service Daemon (GSD), ONS Daemon, Virtual Internet Protocol (VIP), listeners, databases, instances, and services. <br><br>  The responsibilities of the <strong>CSSD</strong> ( <strong>Cluster Synchronization Service Daemon</strong> ) service include coordinating the interaction of cluster nodes, synchronizing nodes and resources between them, determining their availability through the following functions: <ul><li>  <strong>Node Membership (NM).</strong>  Every second checks the heartbeat between the nodes.  NM also shows the rest of the sites that it has access to the so-called <strong>voting disk</strong> (if there are several, then at least to the majority), making regular entries there.  If the node does not respond to the heartbeat or does not leave a recording on the voting disk within a few seconds (10 for Linux, 12 for Solaris), then the master node excludes it from the cluster. </li><li>  <strong>Group Membership (GM).</strong>  The function is responsible for the timely notification when adding / removing / dropping a node from the cluster, for subsequent reconfiguration of the cluster. </li></ul><br>  CSSD provides dynamic information about the nodes and instances that are currently part of it, and is responsible for locking resources in a cluster. <br><br>  <strong>EVMD</strong> ( <strong>Event Manager Daemon</strong> ) acts as an informant in the cluster, which notifies nodes about events: that the node has been started, has lost communication, is restored.  It acts as a link between CRSD and CSSD.  Alerts are also sent to ONS (Oracle Notification Services), Oracle's universal gateway through which alerts can be sent, for example, as an SMS or e-mail. <br><br>  The cluster starts approximately as follows: CSSD reads from the shared storage OCR, from where it reads the cluster configuration, to identify where the voting disk is located, reads the voting disk, to find out how many nodes (ascended) in the cluster and their names, establishes connections with neighboring nodes IPC protocol.  By exchanging heartbeat, it checks whether all neighboring nodes have risen, and finds out who in the current configuration has been defined as master.  <strong>The master node becomes the first starting node</strong> .  After the start, all running nodes are registered with the master, and will subsequently provide it with information about their resources. <br><br>  Levels above CRS on the nodes are database instances. <br>  With each other nodes communicate over a private network - <strong>Cluster Interconnect</strong> , using <strong>IPC</strong> ( <strong>Interprocess Communication</strong> ) protocol.  To her requirements: high bandwidth and low latency.  It can be built on the basis of high-speed versions of Ethernet, third-party solutions (HP, Veritas, Sun), or <a href="http://ru.wikipedia.org/wiki/InfiniBand">InfiniBand</a> , which is gaining popularity.  The latter, in addition to high bandwidth, writes and reads directly from the application buffer, without the need for making kernel-level calls.  Over IP, Oracle recommends using UDP for Linux, and TCP for Windows.  Also, when transferring packets via interconnect, Oracle recommends a set of 6-15 ms for delays. <br><br>  <a href="http://habrahabr.ru/blogs/oracle/72121/">Article continuation</a> </div><p>Source: <a href="https://habr.com/ru/post/72122/">https://habr.com/ru/post/72122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../72113/index.html">Solar battery for e-book</a></li>
<li><a href="../72117/index.html">Firefox Extensions - Working with Settings</a></li>
<li><a href="../72118/index.html">Browsers and Pixels</a></li>
<li><a href="../72119/index.html">12 hours without recharging!</a></li>
<li><a href="../72121/index.html">Oracle RAC. General Description / Part 2</a></li>
<li><a href="../72123/index.html">Broken iPod or what to do hard drive</a></li>
<li><a href="../72125/index.html">Twig, Smarty and Quicky Renderers for Yii</a></li>
<li><a href="../72126/index.html">DIY: KAP (Kite aerial photography)</a></li>
<li><a href="../72127/index.html">Create Rich Internet Applications with OpenLaszlo. Sample development framework for Vkontakte applications</a></li>
<li><a href="../72128/index.html">A-DATA SH93: Waterproof External Drive</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>