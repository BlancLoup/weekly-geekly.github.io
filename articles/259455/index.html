<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Attackers use Linux / Moose to compromise Linux-embedded systems, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last part of our analysis of the Linux / Moose malware, we elaborated on the general schemes of its operation, statistics on the use of proxies...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Attackers use Linux / Moose to compromise Linux-embedded systems, part 2</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/company/eset/blog/259175/">last part of</a> our analysis of the <b>Linux / Moose</b> malware, we elaborated on the general schemes of its operation, statistics on the use of proxies, and also provided information on the search engine for new routers for infection.  In this part, we will focus more on the mechanism of infection of routers, as well as consider the implementation of a proxy, through which botnet operators use the compromised router as a tunnel to transmit traffic. <br><br><img src="https://habrastorage.org/files/654/66e/c53/65466ec537b24c35a23971ea39b54f17.jpeg"><br><br>  Unlike other messages that a bot exchanges with a C &amp; C server in the format of a special binary protocol using port number 81, the standard HTTP protocol on the same port is used to notify the server of the detected target for infection.  Below is a screenshot of this message. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/484/358/c41/484358c41fc641da822242d49de531c3.png"><br>  Fig.  The bot sends to the C &amp; C server a message about the detection of a target for infection. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The format of the string sent by the bot data is presented below. <br><br><img src="https://habrastorage.org/files/1a8/5da/f2f/1a85daf2feb94b358e848e1173b53cb8.png"><br><br>  It can be seen that the format line contains three parts: <br><br><ul><li>  obfuscated IP address; </li><li>  the byte order used in the OS (0 for big-endian and 1 for little-endian); </li><li>  The type of IP address scan in which the host was detected (0 for scanning addresses adjacent to the external IP address of the router and 1 for randomly selected addresses). </li></ul><br>  In the format string, the IP address is obfuscated by applying a fixed key XOR operation.  It can be normalized using the following Python code snippet (p is the GET request string parameter). <br><br><img src="https://habrastorage.org/files/47c/e15/aed/47ce15aed6e743a59b78ee4871958255.png"><br><br>  If the open port scanner stream cannot detect the open 10073rd port on the remote system, it tries to connect to the Telnet port (port 23) on the same IP address.  Further, if an open port is present, it will attempt to log in by bruteforce the various combinations of passwords that it received from the C &amp; C configuration server.  In case of successful login, he will report this to the reporting C &amp; C server.  Otherwise, it moves to the next IP address. <br><br>  Upon successful login, Moose sends a report to the server in the following format. <br><br><img src="https://habrastorage.org/files/c66/6a4/6aa/c666a46aa6a241f29f621a07a81380b2.png"><br><br><img src="https://habrastorage.org/files/75f/c55/3a5/75fc553a5cbf4843a3bd5db251da6b34.png"><br>  Fig.  An example of a real message sent to a C &amp; C server. <br><br>  The server response to this report is as follows. <br><br><img src="https://habrastorage.org/files/1a8/24e/68e/1a824e68e434456e9589a371afbef745.png"><br><br>  After a successful Telnet login, the infection process begins.  The picture below presents a general view of this process. <br><br><img src="https://habrastorage.org/files/8f4/ec8/add/8f4ec8add2a840c394efa52b92eb4c18.png"><br>  Fig.  General scheme of the process of infection of devices Linux / Moose. <br><br><ul><li>  Using a Telnet connection, Moose collects information about the victim. </li><li>  This information is sent to the reporting C &amp; C server using the binary protocol (1). </li><li>  Reporting C &amp; C server returns a set of obfuscated commands back to the bot (2). </li><li>  The bot decrypts the commands received from the C &amp; C server (3), and then executes them on the victim's device via a Telnet connection. </li></ul><br>  Commands are usually used to perform a load and execute function.  Depending on what status will be returned by the victim system after the command is executed, the command can be re-executed until it receives the status of successful execution OK.  Receiving such a command indicates a successful launch of a malicious program on a remote device.  Below is a fragment of the bot's interaction with the infected device via Telnet.  Commands are sent by the bot automatically without the participation of the botnet operator. <br><br><img src="https://habrastorage.org/files/bdf/514/bb4/bdf514bb4db148eb8b33c75b6898afde.png"><br>  Fig.  Executed by the bot commands on the infected system. <br><br>  The bot executes the following commands: <br><ul><li>  Gains access to the command line (shell) on the infected device. </li><li>  Checks the execution of the <i>echo</i> command. </li><li>  Gets a list of running processes ( <i>ps</i> ) to check its presence in the system and the presence of other malicious programs. </li><li>  Checks the presence of the <i>chmod command</i> . </li><li>  Gets the contents of <i>/ proc / cpuinfo</i> . </li></ul><br>  At this point, Moose still has not infected the remote system.  It sends a message to the reporting C &amp; C server, which contains information about the victim received via Telnet. <br><br><img src="https://habrastorage.org/files/7fb/d39/d26/7fbd39d2676b4e7b88665fbd47914e4e.png"><br><br>  Below is the bit field (see table above), which characterizes the state of the infected system (Information about the victim). <br><br><img src="https://habrastorage.org/files/7fc/22b/49d/7fc22b49d2a343d4bf54c281b040110b.png"><br><br>  The reporting C &amp; C server responds with obfuscated commands for their execution in the victim's system. <br><br><img src="https://habrastorage.org/files/95e/860/666/95e860666ccc43f0938adae9ed542487.png"><br><br>  In the second stage of the system infection, Linux / Moose decrypts the batch of commands from the C &amp; C server message and tries to execute them in Telnet.  We observed only commands like ‚Äúload and execute‚Äù in use, but the architecture itself is flexible and allows attackers to execute any command they need.  One of these commands is shown below; the <i>wget</i> tool is used to download malicious content onto a device. <br><br><img src="https://habrastorage.org/files/db2/b2f/ede/db2b2fede7ae42eaab55651e7a03629b.png"><br>  Fig.  Download and execute a malicious file on the victim's computer. <br><br>  The attackers use another approach to execute malicious code in the system. To do this, the output of the <i>echo</i> command is written to a specific file, and the binary data (executable code) is input to it. <br><br><img src="https://habrastorage.org/files/0c5/b49/834/0c5b4983476f4a608b599cecf811492e.png"><br>  Fig.  Download and execute a malicious file on the victim's computer. <br><br>  At this stage, the device is already infected with malware.  Further, Linux / Moose may receive additional configuration parameters from the C &amp; C server and continue its malicious activity on the device. <br><br>  This two-stage infection mechanism allows the reporting C &amp; C server to transfer to the bot exactly the type of ELF file being executed that will correspond to the type of architecture being infected, since at the first stage the bot sends information about the device's environment type to the server.  It also gives an advantage to operators in adding the ability to compromise a new platform without updating the entire botnet.  To do this, a C &amp; C server just needs to specify the required file. <br><br>  Below are the configuration flags with which the C &amp; C server can configure the bot. <br><br><img src="https://habrastorage.org/files/b80/f7f/91b/b80f7f91be4c49b995da32808f271459.png"><br><br>  Three more parameters require a more detailed explanation: <i>cnccfg_flag_hijackdns</i> , <i>cnccfg_hijackdns1_ip</i> , <i>cnccfg_hijackdns2_ip</i> .  They are used to install the malicious DNS configuration of the router.  If the first flag is activated, the following commands will be executed by the bot in the Telnet console before entering the command interpreter. <br><br><img src="https://habrastorage.org/files/39b/078/ca7/39b078ca7ab14f00a150b6b3048b0fb9.png"><br><br>  It can be seen that the malware is trying to overwrite the addresses of legitimate DNS servers used by the router to malicious addresses.  Different types of routers support different user interfaces or commands ( <i>text-based user interfaces</i> ), so the bot executes several such commands.  Router manufacturers such as TP-Link, Zyxel, Zhone, and Netgear support at least one of these commands.  The bot does not provide for handling various situations when executing commands; instead, it simply continues execution regardless of the success of the above-mentioned DNS hijacking operations. <br><br>  <b>Firewall bypass</b> <br><br>  One of the most interesting aspects of Linux / Moose is its ability to infect computers on the network, while bypassing the protection of outdated firewalls.  Two different mechanisms are used for this: the first relies on weak firewall settings and the second on <a href="https://en.wikipedia.org/wiki/NAT_traversal">NAT traversal</a> . <br><br>  As we have indicated earlier, the bot knows the public IP address of the router that it compromised.  Then this IP address is used as a basis for further scanning of close to it by a range of IP addresses with an open Telnet port to infect devices on the same subnet.  The bot goes through different IP addresses inside the same subnet of the external address of the router with the mask / 15.  This allows the bot to effectively bypass firewalls and allow the worm to distribute copies of its body. <br><br><img src="https://habrastorage.org/files/535/1dd/239/5351dd239e7c4e27997cad2e3a1fbc2f.png"><br>  Fig.  A scheme for compromising devices on the same subnet or on the Internet. <br><br>  The diagram above shows that operators focus on scanning a range of IP addresses close to the address of the router.  The black lines indicate the network connection, and the yellow network connection.  These steps are listed below. <br><br><ol><li>  A bot in an infected router tries to infect another device on the global network, but its attempts are stopped by a firewall. </li><li>  A bot in an infected router tries to infect a device on the global network and successfully bypasses the firewall due to the weak security settings it uses. </li><li>  A bot in an infected router is more likely to succeed when infecting other routers from the same ISP subnet if its firewall allows it to connect to routers via Telnet from the same subnet. </li></ol><br>  During our monitoring of an infected router, we noticed that Telnet access to new devices was 3 times more successful when the bot used scanning IP addresses close to the router's address than in the case of scanning arbitrary addresses in the global network.  In our opinion, this trend is due to the use of NAT and the presence of routers with weak settings.  This is not surprising, given the complexity of modern networks and the number of rules that must be configured for firewalls that serve them.  In addition, a <a href="https://www.eng.tau.ac.il/~yash/05440153.pdf">study of firewall rules by a</a> specialist named Avishai Wool demonstrates a clear correlation between the complexity and the number of firewall rules and the number of errors that are allowed when they are configured.  The study indicates that providing open access via Telnet is one of the common mistakes. <br><br>  The malicious program also launches an additional stream, which scans address ranges on each IP interface represented in the system, while avoiding addresses with the / 32 subnet and special addresses such as loopback (127.0.0.1). <br><br><img src="https://habrastorage.org/files/5b2/372/37f/5b237237f653424781ed48204873e30e.png"><br>  Fig.  Check loopback address. <br><br><img src="https://habrastorage.org/files/7d6/60d/50f/7d660d50f80b41d4b2847c61766210ba.png"><br>  Fig.  Check subnet mask. <br><br>  As indicated in the diagram above, in the presence of one of the incorrectly configured firewalls that control the entrance to the local ISP network (LAN), Moose can infect one of the routers on this network.  After its successful infection, this new infected router launches its process of scanning new victims, which significantly increases its chances of success in this network, since the firewall rules in relation to its traffic are much lower than the outside. <br><br>  This type of automatic network penetration ( <a href="http://en.wikipedia.org/wiki/Exploit_(computer_security)">pivoting</a> ) is very interesting for the following reasons: <br><br><ul><li>  Some networks leave weak security settings for firewalls inside the network itself, unlike their settings when working outside. </li><li>  Routers can be represented as nodes or vertices of the Internet graph.  Access to one vertex paves the way for many follow-ups. </li><li>  All types of networks can be identified by botnet operators: various third-party vendors, business partners, private clouds, extranet, etc. </li><li>  Servers of network equipment providers are also traditionally controlled via Telnet. </li><li>  Home routers and other devices, as a rule, are returned to the factory settings by the user, which makes them more vulnerable with the default security settings, even if the ISP changed them to necessary before transferring them to the client. </li></ul><br>  <b>NAT traversal</b> <br><br>  Another interesting feature of the malware, which relates to network penetration (network penetration), is the implementation of the <a href="https://ru.wikipedia.org/wiki/NAT_traversal">NAT Traversal</a> function.  For this, the bot uses the <b>Session Traversal Utilities for NAT</b> ( <a href="http://en.wikipedia.org/wiki/STUN">STUN</a> ) and <b>Traversal Using Relays around NAT</b> ( <a href="http://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT">TURN</a> ) protocols, which allow broadcasting network packets from a local network behind NAT, beyond its limits. <br><br>  The configuration C &amp; C server provides the bot with the necessary information to transfer network packets outside NAT: the public address of the router and the address of the relay server (relay C &amp; C server).  During our research, the IP address of the relay server has always been one: 93.190.140.221.  Below are the bot configuration values ‚Äã‚Äãthat affect the performance of the NAT Traversal function. <br><br><img src="https://habrastorage.org/files/3f1/f9c/452/3f1f9c4521924281a8ac05d020ff76d2.png"><br><br>  If the bot uses the NAT Traversal function, it creates two threads of execution that will interact with the C &amp; C relay server.  The packet transfer operation itself (retransmission) is requested by the bot from the C &amp; C server at short intervals (the <i>cnccfg_relaycnc_sleep</i> parameter).  The server responds to such a request with a pair or a set of IP_address-port pairs. <br><br>  The first packet that the bot sends to the C &amp; C relay server is hard-wired malware in the body. <br><br><img src="https://habrastorage.org/files/482/850/e07/482850e0745246bea346c0ad0816135c.png"><br><br>  The server response has the following structure. <br><br><img src="https://habrastorage.org/files/0b0/34d/9cc/0b034d9cc3a5411da2654a6a566699ce.png"><br><br>  Below are the NAT traversal operation commands that the bot can handle. <br><br><img src="https://habrastorage.org/files/927/019/706/927019706f994cb6b105127eefc4f435.png"><br><br>  Below is an example of such a response. <br><br><img src="https://habrastorage.org/files/522/9a1/861/5229a18613774b59b4cfa64c60061f95.png"><br><br><ol><li>  The mode of operation that is requested by the C &amp; C relay server, for example, TCP tunneling (TCP Tunnel), 0. </li><li>  Remote tunnel port (network byte order), 80. </li><li>  Remote IP tunnel address (network byte order), 192.168.1.1. </li></ol><br>  Next, the bot connects to the destination address of the tunnel.  After a successful connection, one of the bot threads will support two sockets that will serve the transfer of traffic to and from the C &amp; C relay server. <br><br><img src="https://habrastorage.org/files/67c/307/45d/67c30745d6694f7980d9ebf199fcbf41.png"><br>  Fig.  NAT traversal tunneling in action. <br><br>  Such tunneling allows botnet operators to access the infected router, even if it is not accessible from the global network due to firewall settings or NAT.  Our study of this threat showed that the tunneling mechanism is used by the bot for fraudulent actions on social networks, which we described earlier.  We often observed a response from a server with a TCP-reset (RST) status, as well as commands like <i>Sleep</i> . <br><br>  <b>Proxy Organization</b> <br><br>  One of the first things Linux / Moose does is to create an incoming port 10073 to receive incoming proxy connections.  The presence of such an open port on the router indicates that the device has been compromised, which is what the bot uses when trying to find and infect new devices.  When a bot accesses this open port on another device, it will result in a TCP handshake without transferring any useful data.  Below is the code Moose, which specializes in processing incoming connections and checking IP addresses for belonging to the "white list" allowed to connect. <br><br><img src="https://habrastorage.org/files/ee7/850/b92/ee7850b925be4107a4586f6a6a406863.png"><br>  Fig.  Check the IP-address in the list of allowed to connect. <br><br>  The <i>is_in_whitelist</i> function checks the IP address of the connection source in the ‚Äúwhite list‚Äù that was provided by the configuration C &amp; C server earlier.  If the address is present in this list, the socket descriptor with parameters is passed to a separate thread for further processing. <br><br>  The proxy server workflow is responsible for handling proxy connections for whitelisted IP addresses.  After connecting, the proxy server (bot) reads from the socket one byte, which regulates the protocol or function used. <br><br><img src="https://habrastorage.org/files/9b3/f6c/f58/9b3f6cf583e246c0acfa9321ccfa6ecd.png"><br><br>  All of the above protocols are classic for organizing a proxy connection, i.e. for a situation where someone is trying to secretly use the resource of a compromised device or computer to generate traffic.  Since, in this case, the IP address of the device has a good reputation, attackers use it to perform such operations as generating ad clicks, sending spam, and performing fraudulent actions in social services.  Ultimately, this IP address will lose its positive reputation and will be blacklisted, leading to an investigation of this situation. <br><br>  The malicious program uses the standard implementation of the SOCKS 4 protocol. It allows you to organize TCP tunneling of traffic from an infected device to a host that was specified by the configuration parameter.  After the initial handshake, the traffic will be transparently transmitted in both directions between the infected device and the server (host) on the other side. <br><br><img src="https://habrastorage.org/files/d55/336/5d8/d553365d87894ff581ca1b059fc0d647.png"><br>  Fig.  SOCKS 4 tunneling example. <br><br>  It is seen that in the first stage (1), the so-called.  SOCKS exchange, when the bot is informed about the protocol used.  As soon as the bot (proxy server) responds with a successful connection status (0x5A), then the proxy client (botnet operator) sends an HTTP request to the target server (2) for the initial proxy on the infected router.  In response to this request, the bot returns the response that was received from the destination server (Instagram) (3).  In this case, the request was to put the connection into HTTPS safe mode via the HTTP protocol's Location field. <br><br>  The SOCKS 4 protocol was used by hackers more often than anyone else. <br><br>  Another version of the protocol - SOCKS 5, is also used to establish a TCP tunnel between the server and the host.  Moose does not fully implement this protocol version and supports only one authentication method called ‚ÄúNo authentication‚Äù.  This partial protocol support is sufficient for operators, as they already use the whitelist method to prevent unwanted clients from connecting to the bot.  Using this approach allows you to support a wide range of different client applications. <br><br>  The bot also contains an implementation of another proxy protocol - HTTP / 1.1.  The implementation code for this protocol scans the HTTP headers, accesses the destination host, connects to it, and sends the data back to the client.  It also handles the CONNECT method if it is present using the secure version of the protocol - HTTPS. <br><br><img src="https://habrastorage.org/files/880/fae/44e/880fae44ec704364881b1405f5c0a4a0.png"><br>  Fig.  CONNECT method check. <br><br>  It should be noted that the configuration C &amp; C server sends the bot a white list of IP address configuration that includes special flags; setting this flag allows the IP address to use a proxy connection on ports with the numbers 25 (SMTP), 465 (SMTPS), 587 (submission).  For most IP addresses, this flag is cleared. <br><br>  Obviously, the mechanisms described above allow the botnet operator to use the positive reputation of IP addresses of compromised devices in a very flexible and inconspicuous way. <br><br>  <b>Sniffer functions</b> <br><br>  Linux / Moose contains the capabilities of a sniffer, i.e. it can listen to traffic passing through a router.  Such a function is enabled by two different configuration flags: <i>cnccfg_flag_scanner_sniffer</i> and <i>cnccfg_flag_thd_sniffer</i> .  If these flags are active, the malware creates a separate execution thread for each network interface that received at least 101 packets.  Such a check is performed in order to avoid creating threads for interfaces through which traffic does not pass. <br><br>  The thread doing the job of listening to traffic is fairly simple.  It creates a raw socket and sets the network interface in <a href="https://ru.wikipedia.org/wiki/Promiscuous_mode">promiscuous mode to</a> capture all packets.  After that, the loop executes the <i>recvfrom</i> function to read data from the socket. <br><br><img src="https://habrastorage.org/files/f7d/760/c5b/f7d760c5b36a4a1b808ac7368bafbd01.png"><br>  Fig.  Listening to network traffic. <br><br>  The malicious program is only interested in TCP packets, in which it searches for various strings specified by operators through the configuration parameter <i>snfcfg_id_needle</i> , which were sent to the bot by the C &amp; C configuration server.  The samples we analyzed were configured to search for the following lines: <br><ul><li>  twll = </li><li>  twid = </li><li>  LOGIN_INFO = </li><li>  c_user = </li><li>  ds_user_id = </li><li>  SAPISID = </li><li>  APISID = </li><li>  PLAY_ACTIVE_ACCOUNT = </li></ul><br>  As mentioned earlier, these lines are HTTP cookie files that refer to social service websites. <br><br>  As soon as the bot detects the specified data, the entire network packet, including the Ethernet, IP, TCP headers, and the packet data are sent to the reporting C &amp; C server in the obfuscated form.  The format of such a message is shown below. <br><br><img src="https://habrastorage.org/files/356/e50/7e6/356e507e6a69407c9d1ca0d73f36118e.png"><br><br>  The server responds with a packet with the following structure. <br><br><img src="https://habrastorage.org/files/ce7/553/210/ce75532107544fb7aa67947fb9180bba.png"></div><p>Source: <a href="https://habr.com/ru/post/259455/">https://habr.com/ru/post/259455/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259441/index.html">DevExpress 15.1: what's new and interesting?</a></li>
<li><a href="../259447/index.html">The onset of the era of hyperconvergence</a></li>
<li><a href="../259449/index.html">Windows SSH support by Microsoft</a></li>
<li><a href="../259451/index.html">Why buy monsters? - The practice of domestic import substitution software</a></li>
<li><a href="../259453/index.html">STM32 training for the masses</a></li>
<li><a href="../259457/index.html">How did jQuery start</a></li>
<li><a href="../259459/index.html">Understanding x64 support in WPE Pro</a></li>
<li><a href="../259463/index.html">We calculate gamemasters characters in World of Warcraft using Python</a></li>
<li><a href="../259465/index.html">Modeling objects for animation on Canvas</a></li>
<li><a href="../259467/index.html">How to write your NIF in Elixir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>