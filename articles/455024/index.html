<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>5 principles of common sense for creating cloud-native apps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Cloud-oriented" (cloud native) or simply "cloud" applications are created specifically for work in cloud infrastructures. Usually they are built as a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>5 principles of common sense for creating cloud-native apps</h1><div class="post__text post__text-html js-mediator-article">  "Cloud-oriented" (cloud native) or simply "cloud" applications are created specifically for work in cloud infrastructures.  Usually they are built as a set of loosely coupled microservices packed into containers, which, in turn, are managed by a cloud platform.  Such applications are by default ready for failures, which means they work reliably and scale even with serious infrastructure failures.  The other side of the coin is sets of restrictions (contracts) that the cloud platform imposes on container applications in order to be able to manage them automatically. <br><br><img src="https://habrastorage.org/webt/i4/jg/_8/i4jg_8cdsmt7yazeyaz_e2lclmo.png" width="100%"><br><br>  Well aware of the need and importance of switching to cloud applications, many organizations still do not know where to start.  In this post, we will look at a number of principles, the observance of which in the development of container applications will allow to realize the potential of cloud platforms and to achieve reliable operation and scaling of applications, even with serious failures at the IT infrastructure level.  The ultimate goal of the principles outlined here is to learn how to build applications that can be automatically managed by cloud platforms, such as Kubernetes. <br><a name="habracut"></a><br><h3>  Principles of software design </h3><br>  In the programming world, principles are understood as quite general rules that must be followed when developing software.  They can be used when working with any programming language.  Each principle has its own goals, the tools for achieving which usually serve patterns and practices.  There are also a number of fundamental principles for creating high-quality software, from which all the rest flow.  Here are some examples of fundamental principles: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://ru.wikipedia.org/wiki/KISS_(%25D0%25BF%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF)">KISS</a> (Keep it simple, stupid) - do not complicate; </li><li>  <a href="https://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself">DRY</a> (Don't repeat yourself) - do not repeat; </li><li>  <a href="https://ru.wikipedia.org/wiki/YAGNI">YAGNI</a> (You are not gonna need it) - not to create something that there is no immediate need; </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D0%25B7%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BE%25D1%2582%25D0%25B2%25D0%25B5%25D1%2582%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">SoC</a> (Separation of concerns) - share responsibility. </li></ul><br>  As you can see, these principles do not set any specific rules, but belong to the category of so-called common sense considerations based on practical experience, which are shared by many developers and to which they regularly refer. <br>  In addition, there is <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID</a> - a set of the first five principles of object-oriented programming and design, formulated by Robert Martin.  SOLID incorporates mutually reinforcing and open-ended, mutually reinforcing principles that, when used in combination, help create better software systems and better support them in the long term. <br><br>  The SOLID principles are related to OOP and are formulated in the language of such concepts and concepts as classes, interfaces, and inheritance.  By analogy, for cloud applications, you can also formulate the principles of development, only the base element here will not be a class, but a container.  Following these principles, you can create container applications that better meet the goals and objectives of cloud platforms like Kubernetes. <br><br><h3>  Cloud-oriented containers: Red Hat approach </h3><br>  Today, almost any application can be packaged into containers relatively easily.  But in order for applications to be effectively automated and orchestrated within a cloud platform like Kubernetes, additional efforts are required. <br>  The basis for the ideas outlined below was the methodology of <a href="https://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">The Twelve-Factor App</a> and many other works on various aspects of creating web applications, from source code management to scaling models.  The principles described relate only to the development of container applications that are based on microservices and are intended for cloud platforms such as Kubernetes.  The basic element in our reasoning is the image of the container, and the target environment for the execution of containers is the container orchestration platform.  The purpose of the proposed principles is to create containers for which on most orchestration platforms it is possible to automate scheduling tasks (scheduling ‚Äî select a host for running the container instance), scaling and monitoring.  Principles are presented in arbitrary order. <br><br><h3>  Single Concern Principle (SCP) </h3><br>  This principle is in many ways similar to the Single Responsibility Principle ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BE%25D1%2582%25D0%25B2%25D0%25B5%25D1%2582%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">SRP</a> ) principle, which is included in the SOLID set and states that each object must have one duty, and this duty must be fully encapsulated in a class.  The essence of SRP is that every duty is a reason for a change, and a class must have one and only one reason for a change. <br><br>  In SCP, instead of the word ‚Äúresponsibility‚Äù (responsibility) we use the word ‚Äútask‚Äù (concern) to indicate a higher level of abstraction and a wider purpose of the container compared to the OOP class.  And if the goal of the SRP is to have only one reason for the change, then the SCP has a desire to expand the reuse and replacement of containers.  By following SRP and creating a container that solves one single task and makes it functionally complete, you increase the chances of reusing the image of this container in different application contexts. <br><br>  The SCP principle states that each container must solve one single task and do it well.  Moreover, SCP in the container world is achieved easier than SRP in the OOP world, since containers usually perform one single process, and most of the time this process solves one single task. <br><br>  If a container microservice has to solve several tasks at once, then it can be divided into single-task containers and merged them within one pod (units of container platform deployment) using sidecar templates and init containers.  In addition, SCP makes it easy to replace the old container (for example, a web server or a message broker) with a new one, which solves the same problem, but has enhanced functionality or scales better. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/4j/3o/ud4j3okts2jt7hdfr68-tdjlkw4.png"></div><br><br><h3>  The principle of convenience monitoring (High Observability Principle, HOP) </h3><br>  When using containers as a unified way to package and launch applications, the applications themselves are considered as a ‚Äúblack box‚Äù.  However, if they are cloud containers, they must provide the runtime with special APIs to monitor the health of the containers and, if necessary, take appropriate measures.  Without this, it will not be possible to unify the automation of updating containers and managing their life cycle, which, in turn, will worsen the stability and usability of the software system. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/_y/lh/nm_ylhsfix0alpq7uwqmjy8smf0.png"></div><br>  In practice, a container application should, at a minimum, have an API for various types of health checks: liveness tests and readiness tests.  If the application claims to be more, it should provide other means of controlling its state.  For example, recording important events via STDERR and STDOUT to aggregate logs using Fluentd, Logstash and other similar tools.  As well as integration with the libraries of trace and collection of metrics, such as OpenTracing, Prometheus, etc. <br><br>  In general, an application can still be viewed as a ‚Äúblack box‚Äù, but it should be provided with all the APIs that the platform needs in order to monitor and manage it in the best possible way. <br><br><h3>  Life-cycle Conformance Principle (LCP) </h3><br>  LCP is the antithesis of HOP.  If the HOP says that the container must provide the platform with APIs for reading, then the LCP requires the application to be able to perceive information from the platform.  Moreover, the container must not only receive events, but also adapt itself, in other words, respond to them.  Hence the name of the principle, which can be viewed as a requirement to provide APIs for writing to the platform. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bd/3s/p8/bd3sp8v4heoylqg4rzjmk5oiyue.png"></div><br>  Platforms have different types of events that help manage the life cycle of a container.  But deciding which ones to perceive and how to react should the application itself. <br><br>  It is clear that some events are more important than others.  For example, if an application does not tolerate abnormal termination, it must accept signal: terminate (SIGTERM) messages and initiate its termination procedure as soon as possible in order to arrive at signal: kill (SIGKILL), which comes after SIGTERM. <br><br>  In addition, events such as PostStart and PreStop may be important for the application lifecycle.  For example, after starting an application it may take some time to ‚Äúwarm up‚Äù before it can respond to requests.  Or, the application must in some special way release resources at the completion of work. <br><br><h3>  The principle of immutability of the container image (Image Immutability Principle, IIP) </h3><br>  It is generally accepted that container applications should remain unchanged after assembly, even if they run in different environments.  Hence the need to externalize data storage at the execution stage (in other words, to use external means for this), and also to rely on external configurations configured for a specific execution environment, instead of modifying or creating unique containers for each environment.  After any changes to the application, the container image must be reassembled and deployed in all the environments used.  By the way, the management of IT systems uses a similar principle, known as the principle of the immutability of servers and infrastructure. <br><br>  The goal of IIP is to prevent the creation of separate container images for different runtime environments and to use the same image everywhere along with the appropriate configuration for a specific environment.  Following this principle allows you to implement such important in terms of automation of cloud systems practices such as rollback (roll-back) and roll-forward (roll-forward) application updates. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hl/rr/t9/hlrrt9r4lw4f7wcik19j3o5zmou.png"></div><br><h3>  Process Disposability Principle (PDP) </h3><br>  One of the most important characteristics of the container is its ephemerality: a container instance is easily created and easily destroyed, so it can be easily replaced with another one at any time.  The reasons for this replacement can be mass: failure of the test for serviceability, scaling of the application, transfer to another host, exhaustion of platform resources, or other situations. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tk/qw/lq/tkqwlqu9-qyusgg6n-wpgl0hxks.png"></div><br>  As a result, container applications must retain their state using some external means, or use internal distributed circuits with redundancy for this.  In addition, the application should start quickly and shut down quickly, as well as be ready for a sudden fatal failure of the equipment. <br><br>  One of the practices that helps to implement this principle is to create small containers.  Cloud environments can automatically select a host to launch a container instance, so the smaller the container size, the faster it will start ‚Äî it will simply be copied to the target host over the network. <br><br><h3>  Self-containment Principle, S-CP </h3><br>  According to this principle, at the assembly stage all necessary components are included in the container.  The container must be built with the expectation that there is only a pure Linux kernel in the system, so all the necessary additional libraries should be located in the container itself.  Such things as the runtime for the corresponding programming language, the application platform (if necessary) and other dependencies that are required during the operation of the container application should be located there. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/ia/qb/p7iaqbxksacennpuyk5vvhzdnw4.png"></div><br><br>  Exceptions are made only for configurations that vary from environment to environment, and should be provided at runtime, for example, through Kubernetes ConfigMap. <br><br>  An application can include several containerized components, for example, a separate database container as part of a container web application.  According to the S-CP principle, these containers should not be combined into one, but the DBMS container should contain everything necessary for the database operation, and the web application container - everything necessary for the web application, the same web server .  As a result, at run time, the web application container will depend on the DBMS container and access it as needed. <br><br><h3>  The principle of restrictions at runtime (Runtime Confinement Principle, RCP) </h3><br>  The principle of S-CP determines how a container should be assembled and what a binary image file should contain.  But the container is not just a ‚Äúblack box‚Äù, which has only one characteristic - the file size.  At runtime, the container acquires other dimensions: the amount of used memory, processor time and other system resources. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/e5/v5/vb/e5v5vbk3witcr7oe1bgs23forks.png"></div><br>  And here the RCP principle is useful, according to which the container must decapitate its requirements for system resources and transfer them to the platform.  With the resource profiles of each container (how much CPU, memory, network, and disk system resources it needs), the platform can optimally perform dispatching and autoscaling, manage IT capacities, and maintain SLA levels for containers. <br><br>  In addition to meeting the requirements for container resources, it is also important for an application not to go beyond the framework designated by it.  Otherwise, in case of a shortage of resources, the platform is more likely to include it in the list of applications that need to be interrupted or migrated. <br><br>  Speaking of cloud orientation, we primarily mean the way of working. <br>  Above, we formulated a number of general principles that set the methodological foundation for building high-quality container applications for cloud environments. <br><br>  Note that in addition to these general principles, you will also need additional advanced methods and techniques for working with containers.  In addition, we have several short recommendations that are more specific and should be applied (or not) depending on the situation: <br><br><ul><li>  Try to reduce the size of the images: delete temporary files and do not put unnecessary packages - the smaller the container size, the faster it is assembled and copied to the target host over the network. </li><li>  Focus on arbitrary User-IDs: do not use the sudo command or any special userid to launch your containers. </li><li>  Mark important ports: you can also set port numbers at runtime, but it‚Äôs better to specify them using the EXPOSE command ‚Äî it will be easier for other people and programs to use your images. </li><li>  Store permanent data on volumes: the data that should remain after the destruction of the container should be recorded on the volume. </li><li>  Write metadata images: tags, tags and annotations facilitate the use of images - other developers will be grateful to you. </li><li>  Synchronize host and images: for some container applications, container synchronization with the host is required for certain attributes, such as time or machine id. </li><li>  In conclusion, we share templates and best practices that will help to more effectively implement the principles listed above: <br>  <a href="https://www.slideshare.net/luebken/container-patterns">www.slideshare.net/luebken/container-patterns</a> <br>  <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices">docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices</a> <br>  <a href="http://docs.projectatomic.io/container-best-practices">docs.projectatomic.io/container-best-practices</a> <br>  <a href="https://docs.openshift.com/enterprise/3.0/creating_images/guidelines.html">docs.openshift.com/enterprise/3.0/creating_images/guidelines.html</a> <br>  <a href="https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf">www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf</a> <br>  <a href="https://leanpub.com/k8spatterns/">leanpub.com/k8spatterns</a> <br>  <a href="https://12factor.net/">12factor.net</a> </li></ul><br>  <a href="https://events.redhat.com/profile/form/index.cfm%3Fintcmp%3D701f20000012s47AAA%26PKFormID%3D0x5789474c4"><b>Webinar on the new version of OpenShift Container Platform - 4</b></a> <br>  June 11 at 11:00 <br><br>  What you will learn: <br><br><ul><li>  Immutable Red Hat Enterprise Linux CoreOS </li><li>  OpenShift service mesh </li><li>  Operator framework </li><li>  Knative framework </li></ul></div><p>Source: <a href="https://habr.com/ru/post/455024/">https://habr.com/ru/post/455024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455010/index.html">Asynchronous user scripts on pure Rust without frameworks and SMS</a></li>
<li><a href="../455012/index.html">Cellular interception FAQ: what are IMSI interceptors / SCATs, and is it possible to protect against them</a></li>
<li><a href="../455014/index.html">Israeli Techsomed, who developed an image analysis system for cancer treatment, received $ 2.6 million in venture capital investment</a></li>
<li><a href="../455016/index.html">We create the most inaccessible website with the perfect Lighthouse rating.</a></li>
<li><a href="../455018/index.html">Post big love for small business</a></li>
<li><a href="../455038/index.html">How Plesk visited KubeCon</a></li>
<li><a href="../45504/index.html">How am I looking for a job</a></li>
<li><a href="../455040/index.html">Improving the work of Wi-Fi. Part 2. Features of equipment</a></li>
<li><a href="../455042/index.html">Kotlin DSL, fixtures and elegant UI tests in Android</a></li>
<li><a href="../455046/index.html">N + 7 useful books</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>