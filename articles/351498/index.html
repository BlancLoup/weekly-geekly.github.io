<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use Reflection.Emit to precompile expressions in MSIL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to your attention the translation of the article " Using Reflection.Emit to Precompile Expressions to MSIL " by Steve Marsh. 

 In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use Reflection.Emit to precompile expressions in MSIL</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  I present to your attention the translation of the article " <a href="https://www.codeproject.com/Articles/32308/Using-Reflection-Emit-to-Precompile-Expressions-to">Using Reflection.Emit to Precompile Expressions to MSIL</a> " by Steve Marsh. <br><br><h4>  Introduction </h4><br>  The classes in this project allow you to analyze text expressions entered by the user and compile them into a .NET assembly.  This build can be performed on the fly or stored in a DLL.  Preliminary compilation of expressions allows for a high level of portability and makes it very efficient to evaluate user-entered logic.  In addition, we can use Microsoft's ildasm.exe tool to open and check the generated MSIL base code.  There are many interesting features that come with the .NET platform, in my opinion the Reflection.Emit namespace offers much more than you can find.  The Reflection.Emit namespace allows you to create your own .NET code at runtime by dynamically creating .NET types and inserting MSIL instructions into the body.  MSIL is the Microsoft intermediate language for the .NET platform.  IL is what your C # code and VB.NET compiles and sends to the JIT compiler when you run .NET programs.  MSIL is a very low-level language that is very fast, and working with it gives you exceptional control over your programs.  I will not go into details about MSIL in this article, but there are several other resources available on the Internet, and if you are interested in learning more, I have included some links at the end of this article. <br><a name="habracut"></a><br><h4>  reference Information </h4><br>  Let's take a quick look at what our parser / compiler will do.  The user enters a string expression corresponding to the grammar of our parser.  This expression will be turned into a tiny .NET program that will run and <br>  output the result. For this, the analyzer will read the sequential list of characters and break it into a hierarchical tree, as shown below.  Nodes are evaluated in the indicated order.  When a node is matched, the corresponding command is invoked for this type of node.  For example, when the number matches, we send this number to the stack.  When the token "*" is matched, we invoke the multiplication instruction and so on.  Adding all the instructions in the correct order gives us the ‚Äúprogram‚Äù shown on the right. <br><br><img src="https://habrastorage.org/webt/lg/kg/5m/lgkg5mwpe6ku7z0vv5w7-cv_xn0.jpeg" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now let's see how our program executes and compares it with the original text expression.  The first two teams insert integers 3 and 2 onto the stack.  The multiply command extracts these two values ‚Äã‚Äãfrom the stack, multiplies them and sends the result 6 back to the stack.  Instruction No. 4 sends an integer 1 to the stack.  Instruction No. 5 prints two values ‚Äã‚Äã(6 and 1), adds them and returns the result (7) back to the stack.  Finally, the return command returns the value 7 from the stack and returns it as a result. Brilliant!  This may seem simple and obvious to most programmers, but this clever idea is largely the basis for programming and compiling, and I think it‚Äôs worth a look.  This is what this program looks like in MSIL.  For example, ldc.r8 is a load constant command and loads double 3.0 onto the stack. <br><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0000</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.r8</span></span> 3. <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0009</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.r8</span></span> 2. <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0012</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0013</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.r8</span></span> 1. <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_001c</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0023</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre> <br><h4>  Code usage </h4><br>  This project contains two classes for parsing an expression and compiling it in MSIL.  The first class is RuleParser, which is an abstract parsing class that contains all the lexing and parsing logic for our particular grammar.  This class parses the message, but takes no action.  The above code snippet shows that when the ttAdd token is detected, the parser calls the matchAdd () method, which is an abstract method defined in the RuleParser class.  The implementation of the class method and the corresponding semantic action depends on the particular class.  This template allows us to implement a separate concrete class for processing semantic actions and means that we can implement different specific classes depending on what we are trying to perform.  This code was previously configured to evaluate expressions on the fly by calculating nodes as they were found.  Now we can exchange our MsilParser for compiling an expression into an IL program using the same parser class. MsilParser does this by implementing all the necessary functions of the token and emitting the appropriate IL instructions.  For example, the matchAdd () function simply inserts an Add command.  When a variable is matched, we load the variable name with the Ldstr command, and then call the GetVar method. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchAdd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.il.Emit(OpCodes.Add); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matchVar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s = tokenValue.ToString(); il.Emit(OpCodes.Ldstr, s); il.Emit(OpCodes.Call, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MsilParser).GetMethod( <span class="hljs-string"><span class="hljs-string">"GetVar"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Type[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) })); }</code> </pre> <br>  After installing all the tokens, we can call the CompileMsil () method of our MsilParser class, which runs the parser and returns the compiled .NET type using the AssemblyBuilder classes in the Relection.Emit namespace. <br><br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// Builds <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> a dynamic assembly /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> CompileMsil(string expr) { // Build the dynamic assembly string assemblyName = "Expression"; string modName = "expression.dll"; string typeName = "Expression"; string methodName = "RunExpression"; AssemblyName <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AssemblyName(assemblyName); AppDomain <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Threading.Thread.GetDomain(); AssemblyBuilder builder = <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span>.DefineDynamicAssembly( <span class="hljs-type"><span class="hljs-type">name</span></span>, AssemblyBuilderAccess.RunAndSave); ModuleBuilder module = builder.DefineDynamicModule (modName, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); TypeBuilder typeBuilder = module.DefineType(typeName, TypeAttributes.<span class="hljs-built_in"><span class="hljs-built_in">Public</span></span> | TypeAttributes.<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>); MethodBuilder methodBuilder = typeBuilder.DefineMethod(methodName, MethodAttributes.HideBySig | MethodAttributes.Static | MethodAttributes.<span class="hljs-built_in"><span class="hljs-built_in">Public</span></span>, typeof(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>[] { }); // <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> the ILGenerator <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> code <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> our <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> body ILGenerator ilGenerator = methodBuilder.GetILGenerator(); this.il = ilGenerator; // Parse the expression. This will <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> MSIL instructions this.Run(expr); // Finish the <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> boxing the result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-type"><span class="hljs-type">Double</span></span> this.il.Emit(OpCodes.Conv_R8); this.il.Emit(OpCodes.Box, typeof(<span class="hljs-type"><span class="hljs-type">Double</span></span>)); this.il.Emit(OpCodes.Ret); // <span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> save the Assembly <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> myClass = typeBuilder.CreateType(); builder.Save(modName); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> myClass; }</code> </pre> <br>  The end result is a .NET build that can be executed, cached, or saved to disk.  Look at the IL code for our method, which was created by our compiler: <br><br><pre> <code class="hljs pgsql">.<span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> hidebysig static <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> RunExpression() cil managed { // Code size <span class="hljs-number"><span class="hljs-number">36</span></span> (<span class="hljs-number"><span class="hljs-number">0x24</span></span>) .maxstack <span class="hljs-number"><span class="hljs-number">2</span></span> IL_0000: ldc.r8 <span class="hljs-number"><span class="hljs-number">3.</span></span> IL_0009: ldc.r8 <span class="hljs-number"><span class="hljs-number">2.</span></span> IL_0012: mul IL_0013: ldc.r8 <span class="hljs-number"><span class="hljs-number">1.</span></span> IL_001c: <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> IL_001d: conv.r8 IL_001e: <span class="hljs-type"><span class="hljs-type">box</span></span> [mscorlib]<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Double IL_0023: ret } // <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> Expression::RunExpression</code> </pre> <br>  The main advantage of this approach is that parsing the expression takes much more time than just executing instructions.  By precompiling an expression in IL, we only need to parse the expression once, not every time it is evaluated.  Although this example uses only one expression, the actual implementation may include thousands of expressions precompiled and executed on demand.  In addition, we also have our code packed in a good .NET DLL, and we can do whatever we want.  This example can be estimated more than 1 million times in less than 3 hundredths of a second! <br><br><h4>  Sample Project Use </h4><br>  The sample project allows you to enter an expression in the upper left text box.  When you click Analysis, the form will parse the expression and create a .NET assembly with your compiled code in the RunExpression () function.  Then the program will call this function a certain number of times and show how long it took to execute it.  Finally, the program will save the assembly as expression.dll and run Microsoft's ildasm.exe file to output the complete MSIL code for the assembly, so that you can see the code that was generated for your program. <br><br><h4>  Matters of interest </h4><br>  How our dynamic method is called will significantly affect performance.  For example, simply using the Invoke () method in a dynamic method will significantly slow performance when called 1 million times.  Using a generic delegate subscription, as in the code below, gives us about a 20-fold increase in performance. <br><br><img src="https://habrastorage.org/webt/ry/k_/pv/ryk_pvydsizx3l6nh9gcrqq54ai.jpeg" alt="image"><br><br><pre> <code class="hljs pgsql">// Parse the expression <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> build our dynamic <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> MsilParser em = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MsilParser(); <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> t = em.CompileMsil(textBox1.Text); // <span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> a typed delegate reference <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> our <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>. This <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> very // important <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> efficient calls! MethodInfo m = t.GetMethod("RunExpression"); Delegate d = Delegate.CreateDelegate(typeof(MsilParser.ExpressionInvoker&lt;&gt;), m); MsilParser.ExpressionInvoker&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> = (MsilParser.ExpressionInvoker&lt;&gt;)d; // <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>();</code> </pre> <br>  * in empty angle brackets must be Object. <br><br><h4>  Call ILDASM.EXE </h4><br>  The sample project will also allow you to view the entire MSIL code for your newly created assembly.  It does this by calling ildasm.exe in the background and outputting the result in a text field.  Ildasm.exe is a very useful tool for those who work with IL code or the System.Reflection.Emit namespace.  The code below shows how to use this executable file in your program using the System.Diagnostics namespace.  Check out the Microsoft documentation for ildasm.exe at the links below. <br><br><pre> <code class="hljs vhdl">// Save the Assembly <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">generate</span></span> the MSIL code <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ILDASM.EXE <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> modName = <span class="hljs-string"><span class="hljs-string">"expression.dll"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Process</span></span>(); p.StartInfo.FileName = <span class="hljs-string"><span class="hljs-string">"ildasm.exe"</span></span>; p.StartInfo.Arguments = <span class="hljs-string"><span class="hljs-string">"/text /nobar \""</span></span> + modName; p.StartInfo.UseShellExecute = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; p.StartInfo.CreateNoWindow = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p.StartInfo.RedirectStandardOutput = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden; p.Start(); <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s = p.StandardOutput.ReadToEnd(); p.WaitForExit(); p.Close(); txtMsil.<span class="hljs-literal"><span class="hljs-literal">Text</span></span> = s;</code> </pre> <br><h4>  References: </h4><br><ul><li>  <a href="http://msdn.microsoft.com/en-us/library/system.reflection.emit.aspx">MSDN: The Reflection.Emit Namespace</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/f7dy01k1(VS.80).aspx">MSIL Disassembler (Ildasm.exe)</a> </li><li>  <a href="http://www.codeguru.com/csharp/.net/net_general/il/article.php/c4635">MSIL tutorial</a> </li><li>  <a href="http://www.devx.com/dotnet/Article/28783">Get Drunk of the Power of Reflection.Emit</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">Wikipedia: Compiling and Parsing</a> </li><li>  <a href="https://www.codeproject.com/Articles/32308/Using-Reflection-Emit-to-Precompile-Expressions-to">Original article</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/351498/">https://habr.com/ru/post/351498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351486/index.html">Video conferencing in 7 steps</a></li>
<li><a href="../351488/index.html">Digital events in Moscow from March 19 to March 25</a></li>
<li><a href="../351490/index.html">KOMPAS-3D Home - professional CAD software for home and hobby</a></li>
<li><a href="../351492/index.html">C ++ 20 is getting closer. Meeting in jacksonville</a></li>
<li><a href="../351496/index.html">Writing celestial bees on Cloud Haskell</a></li>
<li><a href="../351500/index.html">SellAnyCar: how auto auctions work in the desert</a></li>
<li><a href="../351504/index.html">Introduction to Angular Modules - Root Module</a></li>
<li><a href="../351506/index.html">Where worlds are created: jobs 22 game developers</a></li>
<li><a href="../351510/index.html">Rather simple and effective algorithm for recognition and tracking of movement</a></li>
<li><a href="../351512/index.html">A note about the new linux kernel interface - gpio uapi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>