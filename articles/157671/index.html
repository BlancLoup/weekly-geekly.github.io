<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Is there a simple assessment of the quality of optimization of the application?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The quieter you go, the further you'll get...? Performance evaluation 

 For more than 7 years I have been doing performance analysis as part of the P...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Is there a simple assessment of the quality of optimization of the application?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/9de/48e/2eb/9de48e2eb5b76fa049fb30a28f76ac3c.png" alt="image"><br><br><h4>  The quieter you go, the further you'll get...?  Performance evaluation </h4><br><br>  For more than 7 years I have been doing performance analysis as part of the Performance Analysis group of the Novosibirsk branch of Intel.  We are working to improve the performance of various applications, or rather, we are looking for ways in which our compiler could improve it.  During this time, a useful experience has been accumulated, which, in my opinion, would be of interest to visitors of the esteemed Habr.  In this case, it will not be about algorithmic optimization of applications, but about various modifications of applications without a fundamental change in their algorithms.  It is clear that algorithmic program optimization also has the right to life, but this is a completely different task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  I am the developer of the Intel compiler, so all my research is related to various compiler optimizations, comparing different compilers (on Windows, this is usually a comparison of the Intel compiler with the Microsoft Visual Studio compiler).  Actually, therefore, please do not treat my posts as advertising or anti-advertising.  To illustrate my thoughts, I will use various tools, including those developed in our company.  I hope that this post will grow into a series of articles on optimizing applications. <br><br><h4>  Is there a simple criterion for assessing the optimality of an application? </h4><br><br>  It is clear that any problem and task, including the task of improving application performance, begins with an examination of the current state of affairs.  Evaluation is needed: how optimized the application is, and whether it makes sense to make efforts to speed it up.  At first glance, the problem has a simple solution.  It is enough to measure the CPU load to get such an estimate.  Various performance analyzers make it possible not only to measure the execution time of various program sections, but also to calculate and link to the program code all intraprocessor events that occur during its execution.  Using this information, you can estimate the load on the computational core.  For example, to determine how many processor cycles on average it took to execute one instruction, and what reasons caused the execution delays.  The proposed criterion links the efficiency of the kernel with the ability to improve application performance.  Namely, if the kernel works efficiently, then there is no cause for concern - the program works optimally, otherwise the application can be improved and it makes sense to engage in its analysis.  As a result of using such a criterion, works appear in which some processor events are analyzed, and the authors based on this analysis make assumptions about the possibilities of improving application performance.  Probably, such methods of work are really useful for architects of computing systems and give them an opportunity to dream up about improving the architecture of the processor.  But, unfortunately, for a programmer who thinks about improving the performance of his application, this method is extremely dubious, rarely works and does not answer the eternal question of the Russian intelligentsia: ‚ÄúWhat should I do?  and is it possible to eat chicken with your hands? <br>  In many cases, the maximum load on the computational core does not mean at all that it is impossible to improve the performance of the program and vice versa. <br>  Let's look at a simple testik with the multiplication of rectangular matrices.  Creating small working examples, in my opinion, is the best method of obtaining interesting information about the device of the universe, including the work of compilers and processors.  In such tests, it is important that the execution time of the code being examined is long enough that it is not affected by the program load time and any random events, so you can execute the code being investigated many times. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N 200 #define T 100 void matrix_mul_matrix(int t, int n, double *C, float *A, float *B) { int i,j,k; for (i=0; i&lt;t; i++) for (j=0; j&lt;t; j++) for(k=0;k&lt;n;k++) C[i*t+j]+=(double)A[i*n+k] * (double)B[k*t+j]; } int main() { float *A,*B; double *C; int i,j; //...      for(i=0;i&lt;10000;i++) matrix_mul_matrix(T,N,C,A,B); printf("%f %f %f\n",C[0],C[1],C[100]); free(A); free(B); free(C); }</span></span></span></span></code> </pre> <br><br>  On my lab machine with Windows Server 2008 R2 Enterprise and an Intel Xeon X5570 processor, I compile this program using the Microsoft VS 10.0 compiler.  and Intel Parallel Studio XE2013.  For simplicity, I work with the command line and take options corresponding to the release version of the compilation used by default in Visual Studio. <br><br>  cl matrix.c / O2 / GL / GS / GR / W3 / nologo / Wp64 / Zi -Ob0 -Fematrix_cl <br>  icl matrix.c / O2 / GL / GS / GR / W3 / nologo / Wp64 / Zi -Ob0 -Fematrix <br><br>  It turns out that the operation time of matrix_cl is ~ 21.9 s, while the operating time of matrix is ‚Äã‚Äã~ 9.3 s. <br><br>  Now let's see what Amplifier tells us about CPU usage.  Intel VTune Amplifier XE 2011 is just a performance assessment tool that allows you to work with Intel processor processors. <br>  Let's create two projects for the received applications in Amplifier and make a preliminary analysis - general exploration.  So what do we see as a result?  Here are the results of the "intelligence" application matrix_cl: <br><br><img src="http://habrastorage.org/storage2/479/049/2e8/4790492e8ad0900c35502bef8395e53c.png" alt="image"><br><br>  Pay attention to the CPI Rate (Clock per instruction, the average number of cycles per instruction).  For my processor, the theoretical minimum of this value is 0.25.  (Parallel execution of 4 instructions on 4 actuators).  The number of CPI 0.546 is considered very good.  There are of course delays.  But, like there is nothing critical.  The computing core works with a good load, and everything looks quite decent.  Is it possible to understand from this assessment that the performance of the application can actually be more than doubled? <br>  The results of the study for the matrix: <br><br><img src="http://habrastorage.org/storage2/a98/67a/ccd/a9867accde587c95842430fd0fd166de.png"><br><br>  The magical performance improvement more than doubled, with virtually no effect on the main "ratings" of the computations collected by Intel VTune Amplifier XE 2011. That is,  the study of the processor in this case did not give us any signals that the performance can be drastically improved. <br><br>  This performance improvement was achieved through auto-vectorization.  This is easy to see if you add -Qvec_report to the options for the Intel compiler.  The compiler will issue <br>  ... <br>  ... \ matrix.c (9): (col. 5) remark: PERMUTED LOOP WAS VECTORIZED. <br><br>  Those.  application performance has been improved by applying cyclic permutation optimization.  In order to understand that such optimization could be applied, it was necessary to investigate the matrix multiplication algorithm. <br><br>  Now take an example of another kind and create a program that will bypass a long chain of objects: <br><br><pre> <code class="hljs rust">#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define N <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_planet</span></span></span></span> { float x; float y; float z; double m; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_planet</span></span></span></span> *prev; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_planet</span></span></span></span> *next; } ; typedef <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_planet</span></span></span></span> planet; planet* init_chain() {     } int main() { planet *planet_chain; planet *cur; int i; double sum=<span class="hljs-number"><span class="hljs-number">0.0</span></span>; planet_chain=init_chain(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>;i++) { cur=planet_chain; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(cur) { sum += cur-&gt;m; cur=cur-&gt;next; } } printf(<span class="hljs-string"><span class="hljs-string">"%f\n"</span></span>,sum); }</code> </pre><br><br>  Both compiler optimizers created applications running ~ 6.2s.  Amplifier reports that everything is bad in this application: <br><br><img src="http://habrastorage.org/storage2/a12/15a/bfe/a1215abfe1ac7484dd5b4ef0b54a3d13.png" alt="image"><br><br>  The CPI rate is very bad, and most of the time the compute core is waiting for data to be processed. <br>  So what to do with it?  Suppose we continue research and establish that the reason for the poor loading of the computational core is the delay in the operation of the memory subsystem.  Obviously, the kernel is badly loaded.  But then this sacred knowledge helps us?  What are the methods to improve the performance of the memory subsystem?  Does the specificity of our application allow us to apply already known methods? <br>  This is an example of an application in which everything is bad, and the situation cannot be radically rectified without changing the algorithm. <br><br><h4>  conclusion </h4><br><br>  Thus, simple calculations of various processor coefficients provide little information for evaluating the effectiveness of an application. <br><br>  In this case, a simple analogue of the task of assessing the effectiveness of a running application is an athlete moving from point A to point B. If we take as a criterion for an athlete to perform optimally, the load on his muscles or compare his average speed on the track and the maximum speed with which a given athlete can move, then how far will we go with such criteria?  If the athlete is bad, albeit very strong, and constantly breaks through the thicket, instead of running across the path, then you just need a smarter athlete.  Conversely, if an athlete ran slowly, but his path ran through the swamp, where he had to stop, grope for a path and even go back periodically, then is the athlete to blame?  You can get a more trained and fast athlete (for big money) to solve the problem, or you can get a competent coach who will analyze the race course at the start, the runner‚Äôs strengths and weaknesses, and then suggest the optimal route for the runner, and perhaps teach him to take it on the go the right decision in some simple situations. <br>  In short, without analyzing the path that needed to be overcome and the knowledge of the strengths and weaknesses of the athlete, it is difficult to assess how good he really was at a distance. <br><br>  Therefore, in my opinion, there is no simple universal working method for evaluating the effectiveness of the application and, therefore, simple ways to improve it.  To solve this problem, you need to connect the brain and analyze a variety of situations, applying to them the well-known methods of improving performance.  As in any business, a brain connection methodology is needed.  To successfully solve a problem, he must know some things, for example: <br><br>  1.) The main problems affecting the performance of the processor, and optimization methods that affect these problems. <br>  2.) The main methods of compiler optimization.  As a rule, all those methods that can help improve the performance of a program are already somehow taken into account and implemented in existing optimizing compilers.  It is useful to know the tool that you use in your work.  Perhaps success is simply adding another option.  It is interesting to find out if your compiler can do this or that optimization, and why hasn‚Äôt it done for your code? <br>  3.) Many of the well-known optimizations can effectively be made by hand.  When can I try them?  When is the application of this or that optimization profitable and why? <br><br>  Accordingly, in the future, I will try to provide a sample of such a methodology and tell you about useful useful application optimization methods known to me. </div><p>Source: <a href="https://habr.com/ru/post/157671/">https://habr.com/ru/post/157671/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../157655/index.html">Handspring Visor Edge or Short adaptation course for time travelers</a></li>
<li><a href="../157657/index.html">ShuttlePRO v2 controller from Contour Design: Overview, appointment and first impressions of use</a></li>
<li><a href="../157661/index.html">Return small graphics</a></li>
<li><a href="../157663/index.html">Apple may refuse Intel processors</a></li>
<li><a href="../157665/index.html">Lumia 920 and Lumia 820 in Moscow</a></li>
<li><a href="../157673/index.html">Lo-dash</a></li>
<li><a href="../157675/index.html">One day of the Internet: statistics, figures, facts</a></li>
<li><a href="../157677/index.html">A couple of words about debugging applications from the App Store</a></li>
<li><a href="../157683/index.html">Calls from VimpelCom FMC</a></li>
<li><a href="../157685/index.html">Backing up user data in Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>