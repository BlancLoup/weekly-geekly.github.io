<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Part 2: Networking - Writing a blockchain in less than 200 lines of Go code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you read the first part of this series? If not, it's worth a look. Don't worry, we will wait ... 


 Welcome! 


 We were stunned by the feedback...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Part 2: Networking - Writing a blockchain in less than 200 lines of Go code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/6n/bz/q9/6nbzq9ptgropjb-ejnwlbur9q9g.png" alt="image"><br><p>  Have you read the <a href="https://habrahabr.ru/post/347930/">first part</a> of this series?  If not, it's worth a look.  Don't worry, we will wait ... </p><a name="habracut"></a><br><p>  Welcome! </p><br><p>  We were stunned by the feedback from our first post: "Writing a blockchain in less than 200 lines of Go code."  What was intended for a small lesson for novice developers on blockchain has acquired a new life.  We were overwhelmed with requests to make a post where we add network interaction. </p><br><p>  Before we begin, you can join our chat in <a href="https://t.me/joinchat/FX6A7UThIZ1WOUNirDS_Ew">Telegram</a> !  This is the best place to ask us questions, give feedback and ask for new lessons.  If you need help with your code, then this is the perfect place to ask! </p><br><p>  The last post showed you how to create your own blockchain with hashing and validating each new block.  But all this was done on the same node.  How can we connect another node to our main application and create new blocks, and update the entire block chain on all the other nodes? </p><br><h2>  The working process </h2><br><img src="https://habrastorage.org/webt/8j/bc/qa/8jbcqass8xws_aspo-ugpiyehik.png" alt="image"><br><ul><li>  The first terminal creates the first base unit and a TCP server to which new nodes can connect. </li></ul><br><p>  <em>Step 1</em> </p><br><ul><li>  Additional terminals open and TCP connections to the first terminal </li><li>  The new terminal writes the block to the first terminal. </li></ul><br><p>  <em>Step 2</em> </p><br><ul><li>  The first terminal checks the block </li><li>  The first terminal sends a new block chain to each new node. </li></ul><br><p>  <em>Step 3</em> </p><br><ul><li>  All terminals are synchronized! </li></ul><br><p>  After the lesson, try to do it yourself: each new terminal also acts as the ‚Äúfirst‚Äù terminal, but with different TCP ports and each has connections for the correct operation of the network. </p><br><h2>  What can you do </h2><br><ul><li>  Run a terminal that provides the first base unit. </li><li>  Run a lot of new additional terminals as you want and let them write the blocks to the first terminal </li><li>  The first terminal should send updated blocks for new terminals. </li></ul><br><h2>  What you can not do </h2><br><p>  As in the previous post, the goal of this lesson is to get the core network out of the nodes, so that you can further study the blockchain yourself.  You will not be able to add computers from another network that will write to your first terminal, but this can be achieved by running the binary in the cloud.  In addition, the block chain will be modeled for each of the nodes.  Don't worry, we'll explain everything soon. </p><br><h2>  Let's start the code! </h2><br><p>  Places will review the previous post.  Let's leave a lot of functions, such as block generation, hashing, validation.  We will not use HTTP functionality, but we will view the result in the console, and we will use TCP to work on the network. </p><br><p>  What are the differences between TCP and HTTP? </p><br><p>  We will not go into details, but all you need to know is that TCP is the basic protocol that transmits data.  HTTP is built on top of the TCP stack to use this data transfer between the Internet and the browser.  When you view a website, you use the HTTP protocol.  In this lesson we will work with TCP, since we do not need to view anything in the browser.  Go has a good <a href="https://golang.org/pkg/net/">network</a> packet that provides all the TCP connection functions we need. </p><br><h2>  Installation, Import and Review </h2><br><p>  Some implementation has already been considered in the <a href="https://habrahabr.ru/post/347930/">first</a> part.  To generate and test the block chain, we will use the functions from the previous article. </p><br><p>  <em>Installation</em> </p><br><p> Create a <code>.env</code> file in your main directory and add the line: </p><br><pre> <code class="hljs">ADDR=9000</code> </pre> <br><p>  Save the TCP port number that we want to use (in our case, 9000) in the environment variable called <code>ADDR</code> . </p><br><p>  If you have not done so already, install the following packages: </p><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/davecgh/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>-spew/spew</code> </pre> <br><p>  for beautiful print of our block chain to console </p><br><pre> <code class="hljs swift">go <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> github.com/joho/godotenv</code> </pre> <br><p>  to read variables from our <code>.env</code> file. <br>  Create an empty <code>main.go</code> file.  There we place our code. </p><br><p>  <em>Imports</em> </p><br><p>  Package declaration and import we need: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"crypto/sha256"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/hex"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/davecgh/go-spew/spew"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/joho/godotenv"</span></span> )</code> </pre> <br><p>  <em>Overview</em> <br>  The following code snippets are well described in the <a href="https://habrahabr.ru/post/347930/">first</a> part. </p><br><p>  Let's create our <code>Block</code> structure and declare a slice of blocks, this will be our block chain. </p><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Block <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Index <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Timestamp <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BPM <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Hash <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PrevHash <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Blockchain []Block</code> </pre> <br><p>  We will also declare our hashing function, which we will need when creating new blocks. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">calculateHash</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">block</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Block</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">record </span></span>:= <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(block.Index) + block.Timestamp + <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(block.BPM) + block.PrevHash h := sha256.<span class="hljs-built_in"><span class="hljs-built_in">New</span></span>() h.<span class="hljs-built_in"><span class="hljs-built_in">Write</span></span>([]byte(record)) hashed := h.<span class="hljs-built_in"><span class="hljs-built_in">Sum</span></span>(nil) return hex.<span class="hljs-built_in"><span class="hljs-built_in">EncodeToString</span></span>(hashed) }</code> </pre> <br><p>  And the function of creating blocks: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(oldBlock Block, BPM </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Block, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newBlock Block t := time.Now() newBlock.Index = oldBlock.Index + <span class="hljs-number"><span class="hljs-number">1</span></span> newBlock.Timestamp = t.String() newBlock.BPM = BPM newBlock.PrevHash = oldBlock.Hash newBlock.Hash = calculateHash(newBlock) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newBlock, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  We can make sure that our new block is correct, for this we check that the <code>PrevHash</code> field refers to the <code>Hash</code> field from the previous block. </p><br><pre> <code class="hljs kotlin">func isBlockValid(newBlock, oldBlock Block) bool { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oldBlock.Index+<span class="hljs-number"><span class="hljs-number">1</span></span> != newBlock.Index { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oldBlock.Hash != newBlock.PrevHash { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> calculateHash(newBlock) != newBlock.Hash { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre> <br><p>  Now we guarantee that we take the longest chain as the correct one: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">replaceChain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(newBlocks []Block)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(newBlocks) &gt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Blockchain) { Blockchain = newBlocks } }</code> </pre> <br><p>  Wonderful!  Got the basic functionality for working with a chain of blocks.  Now we can go on to create a network interaction. </p><br><h2>  Networking </h2><br><p>  Let's create a network that can transmit new blocks, integrate them into a chain and broadcast a new chain for the network. </p><br><p>  Let's start with the main function, but before that let's declare the global variable <code>bcServer</code> , which is the channel that accepts incoming blocks. </p><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcServer <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> []Block</code> </pre> <br><p>  <em>Note: Channels are one of the most popular tools in Go and provide a nice implementation of reading / writing data and are most often used to prevent race conditions.</em>  <em>They become a powerful tool when several Go-rutins competitively (not to be confused with parallelism) are written in the same channel.</em>  <em>Usually in Java and other C-like languages ‚Äã‚Äãyou will have to block and unlock a mutex to access data.</em>  <em>The channels in Go make this much easier, although there are also mutexes in Go.</em>  <em>You can read more about it <a href="https://golangbot.com/channels/">here</a> .</em> </p><br><p>  Now let's declare our main function and load the environment variables from our <code>.env</code> file, which is in the root directory.  And also we will launch a copy of our <code>bcServer</code> in the function main. </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { err := godotenv.Load() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } bcServer = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> []Block) <span class="hljs-comment"><span class="hljs-comment">// create genesis block t := time.Now() genesisBlock := Block{0, t.String(), 0, "", ""} spew.Dump(genesisBlock) Blockchain = append(Blockchain, genesisBlock) }</span></span></code> </pre> <br><p>  Now we need to create a TCP server.  Remember that TCP servers are similar to HTTP servers, but not enough to work with the TCP browser.  All data will be displayed via the console.  We will handle several connections to our TCP port.  Add this to our main function: </p><br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">server</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">":"</span></span>+os.Getenv(<span class="hljs-string"><span class="hljs-string">"ADDR"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> != nil { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Fatal(<span class="hljs-built_in"><span class="hljs-built_in">err</span></span>) } defer <span class="hljs-built_in"><span class="hljs-built_in">server</span></span>.Close()</code> </pre> <br><p>  This code will launch our TCP server on port 9000. It is important to do <code>defer server.Close()</code> so that the connection is closed when there is no longer a need for it.  You can read more about <code>defer</code> <a href="https://blog.golang.org/defer-panic-and-recover">here</a> . </p><br><p>  Now we need to create a new connection every time we receive a request to establish a connection, and we will need to process it.  Add more code: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { conn, <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> := <span class="hljs-built_in"><span class="hljs-built_in">server</span></span>.Accept() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> != nil { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Fatal(<span class="hljs-built_in"><span class="hljs-built_in">err</span></span>) } go handleConn(conn) }</code> </pre> <br><p>  We create an infinite loop in which we accept new connections.  For competitive processing, we start each connection in the handler in Go by the <code>go handleConn(conn)</code> routine, so do not stop our cycle.  Thus, we can simultaneously listen to several connections concurrently. </p><br><p>  The attentive reader will notice that the <code>handleConn</code> handler <code>handleConn</code> not declared.  We have so far created our main function, <code>main</code> .  The whole thing looks like this: </p><br><pre> <code class="hljs pgsql">func main() { err := godotenv.<span class="hljs-keyword"><span class="hljs-keyword">Load</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { <span class="hljs-keyword"><span class="hljs-keyword">log</span></span>.Fatal(err) } bcServer = make(chan []Block) // <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> genesis block t := <span class="hljs-type"><span class="hljs-type">time</span></span>.Now() genesisBlock := Block{<span class="hljs-number"><span class="hljs-number">0</span></span>, t.String(), <span class="hljs-number"><span class="hljs-number">0</span></span>, "", ""} spew.Dump(genesisBlock) Blockchain = append(Blockchain, genesisBlock) // <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> TCP <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> serve TCP <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, err := net.<span class="hljs-keyword"><span class="hljs-keyword">Listen</span></span>("tcp", ":"+os.Getenv("ADDR")) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { <span class="hljs-keyword"><span class="hljs-keyword">log</span></span>.Fatal(err) } defer <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Close</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { conn, err := <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.Accept() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { <span class="hljs-keyword"><span class="hljs-keyword">log</span></span>.Fatal(err) } go handleConn(conn) } }</code> </pre> <br><p>  Let's write our <code>handleConn</code> function <code>handleConn</code> .  It takes only one argument, this is the <code>net.Conn</code> interface.  In our opinion, the interfaces in Go are striking and they distinguish it from all C-like languages.  Competitiveness and Go routines advertise a language, but the interfaces and the fact that they can not implement the interface explicitly is the most powerful function of the language.  If you are not yet using Go interfaces, familiarize yourself with them as soon as you can.  Interfaces are your next step to becoming a Go Developer. </p><br><p>  Place a deferred closing of the connection <code>defer</code> in the handler function's workpiece, so as not to forget to close it when we finish the work. </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleConn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(conn net.Conn)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> conn.<span class="hljs-type"><span class="hljs-type">Close</span></span>() }</code> </pre> <br><p>  Now we need to allow the client to add new blocks to the chain.  For the data we will use the pulse rate, as in the <a href="https://habrahabr.ru/post/347930/">first</a> part.  Measure your pulse for a minute and remember this number.  This will be the BPM parameter (beats per minute) </p><br><p>  To implement the above, we need: </p><br><ul><li>  ask the customer to enter their BPM </li><li>  request this value from client via <code>stdin</code> </li><li>  create a new block with this data using the generateBlock, isBlockValid and replaceChain functions </li><li>  put a new chain of blocks in the channel created earlier for transmission over the network </li><li>  allow the client to enter a new BMP value </li></ul><br><p>  The code that implements the above described functionality: </p><br><pre> <code class="hljs go">io.WriteString(conn, <span class="hljs-string"><span class="hljs-string">"Enter a new BPM:"</span></span>) scanner := bufio.NewScanner(conn) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { bpm, err := strconv.Atoi(scanner.Text()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"%v not a number: %v"</span></span>, scanner.Text(), err) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } newBlock, err := generateBlock(Blockchain[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Blockchain)<span class="hljs-number"><span class="hljs-number">-1</span></span>], bpm) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(err) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isBlockValid(newBlock, Blockchain[<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(Blockchain)<span class="hljs-number"><span class="hljs-number">-1</span></span>]) { newBlockchain := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(Blockchain, newBlock) replaceChain(newBlockchain) } bcServer &lt;- Blockchain io.WriteString(conn, <span class="hljs-string"><span class="hljs-string">"\nEnter a new BPM:"</span></span>) } }()</code> </pre> <br><p>  Create a new scanner.  <code>for scanner.Scan()</code> is a loop that works competitively in the Go routine and separately from other connections.  We make a quick string conversion of the BMP value (which will always be an <code>integer</code> type, so we check it).  We perform standard block generation, block validation and adding a new block to the chain. </p><br><p>  The <code>bcServer &lt;- Blockchain</code> syntax simply means that we are throwing our new chain into the channel we created earlier.  Then we offer the customer to enter a new BPM value to create the next block. </p><br><p>  <em>Broadcast channel</em> <br>  We need to send out a new block chain for all connections on our TCP server.  Since we are programming on one computer, we need to simulate how data will be transmitted to all clients.  In the <code>handleConn</code> function we need to add: </p><br><ul><li>  converting our block chain into json format that it was readable </li><li>  writing a new block chain to the console for each of the connections </li><li>  setting a timeout period so that our block chain does not constantly spam.  In existing systems, this happens every X minutes.  We will use 30 seconds </li><li>  outputting the main block chain at the first terminal so that we can see what is happening.  So we will make sure that the blocks added by different nodes are really integrated into the main block chain. </li></ul><br><p>  Here is the code that does everything in the right order: </p><br><pre> <code class="hljs vbscript">go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.Sleep(<span class="hljs-number"><span class="hljs-number">30</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">Second</span></span>) output, <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> := json.Marshal(Blockchain) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> != nil { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Fatal(<span class="hljs-built_in"><span class="hljs-built_in">err</span></span>) } io.WriteString(conn, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(output)) } }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ = range bcServer { spew.Dump(Blockchain) }</code> </pre> <br><p>  Wonderful!  Our <code>handleConn</code> function <code>handleConn</code> ready.  In fact, the whole program is ready and we have kept its compactness in 200 lines of code.  This is nice, isn't it? </p><br><p>  Entirely with all the code, can be found <a href="">here</a> ! </p><br><h2>  Interesting stuff </h2><br><p>  Let's move to the directory with our code and run our program by running: <code>go run main.go</code> </p><br><img src="https://habrastorage.org/webt/vz/jl/yi/vzjlyiro3g-mgc4xybyuzladihc.png" alt="image"><br><p>  As expected, we see our base unit.  At the same time, we launched a TCP server on port 9000, which can accept several connections. </p><br><p>  Open a new terminal window and connect to our TCP server using <code>nc localhost 9000</code> .  We will use a different color in the terminals, so that it would be clear that these are different clients.  Do this several times with different terminal sessions to run multiple clients. </p><br><img src="https://habrastorage.org/webt/hx/m7/2f/hxm72fj5zigqqz6276__bocuof0.png" alt="image"><br><img src="https://habrastorage.org/webt/vz/jl/yi/vzjlyiro3g-mgc4xybyuzladihc.png" alt="image"><br><img src="https://habrastorage.org/webt/nt/6w/qn/nt6wqn6lprwpm_m6l6ljm257zio.png" alt="image"><br><p>  Now enter BPM on any of the clients.  We see that the new unit is added to the first terminal!  The network is working! </p><br><img src="https://habrastorage.org/webt/a_/sv/wg/a_svwgyuipnki7pv-_eryb-6of0.png" alt="image"><br><img src="https://habrastorage.org/webt/wq/1q/y5/wq1qy56bauup-tkwl-djeqvrfbq.png" alt="image"><br><p>  We are waiting for 30 seconds.  Go to one of the other clients, and you will see that the new block chain has been transferred to all clients, even if these clients have never entered BPM! </p><br><img src="https://habrastorage.org/webt/kx/pz/qx/kxpzqxnecf4ff4n0n44brzzen7e.png" alt="image"><br><h2>  Next steps </h2><br><p>  Congratulations!  You not only created your own blockchain from the last lesson, but also added networking.  Now there are several directions to move on: </p><br><ul><li>  To get a large network running locally, create several directories that store a copy of the application.  Each copy should have different TCP ports.  For each terminal session, listen to the TCP port and connect to another one so that you can receive and send your data. </li><li>  Combine data from multiple ports.  This is a topic for another lesson, but it is done easily.  All this is blockchain.  It must receive data as well as transmit data. </li><li>  You can try it with friends, set up a server in the cloud using your favorite hosting provider.  Ask your friends to connect to it and send data.  At this point you can add a bit of security.  If there are requests, we will make a tutorial on this material. <br>  You already understand many aspects of blockchain.  We recommend reading algorithms like Proof of Work or Proof of Stake. <br>  Or you can just wait while we write a new blog post :-) <br>  Recall that to tell us what you want to see, join our <a href="https://t.me/joinchat/FX6A7UThIZ1WOUNirDS_Ew">Telegram</a> chat!  You may be able to change our opinion on what to write in the further lessons.  You can follow us on <a href="https://twitter.com/myCoralHealth">Twitter</a> as well. <br>  To learn more about Coral Health and how we use blockchain in medical research, visit our <a href="https://mycoralhealth.com/">website</a> . </li></ul><br><p>  <em>PS The author of the translation will be grateful for the errors and inaccuracies of the translation.</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348624/">https://habr.com/ru/post/348624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348614/index.html">Why you should be bored at work</a></li>
<li><a href="../348616/index.html">5 new anti-spam plugins from CleanTalk</a></li>
<li><a href="../348618/index.html">Comindware Business Application Platform System Overview</a></li>
<li><a href="../348620/index.html">As we turned the calendar and made it an art object</a></li>
<li><a href="../348622/index.html">Ask me anything. Avito. Android</a></li>
<li><a href="../348626/index.html">Review Support Library Android SDK v26</a></li>
<li><a href="../348628/index.html">The concept of a 3D printer printing metal with high resolution and great speed</a></li>
<li><a href="../348630/index.html">Android development news to subscribe to</a></li>
<li><a href="../348632/index.html">Canceled Promises in EcmaScript6</a></li>
<li><a href="../348634/index.html">Why is it so difficult in St. Petersburg to build a career of VP of engineering?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>