<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>I wrote the fastest hash table</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the end I had to come to this. Once I published an article " I wrote a fast hash table, " and then another one, " I wrote an even faster hash table...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>I wrote the fastest hash table</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/ae9/0bc/82c/ae90bc82ce48463b84451d079dcc4a8c.jpg" alt="image"></p><br><p>  In the end I had to come to this.  Once I published an article " <a href="https://probablydance.com/2014/05/03/i-wrote-a-fast-hash-table/">I wrote a fast hash table,</a> " and then another one, " <a href="https://probablydance.com/2014/05/31/i-wrote-a-faster-hash-table/">I wrote an even faster hash table</a> ."  Now I have completed the fastest hash table.  And by this I mean that I implemented the fastest search compared to all the hash tables I could find.  At the same time, insert and delete operations also work very quickly (although not faster than competitors). </p><br><p>  I used Robin Hood hashing with a limit on the maximum number of sets.  If an element should be at a distance more than X positions from its ideal position, then we increase the table and hope that in this case each element can be closer to its desired position.  This approach seems to work really well.  The value of X may be relatively small, which allows for some optimization of the internal search cycle on the hash table. </p><br><p>  If you only want to try it at work, you can download it <a href="">from here</a> .  Or scroll down to the ‚ÄúSource Code and Usage‚Äù section.  Want details - read on. </p><a name="habracut"></a><br><h2 id="tip-hesh-tablicy">  Hash Table Type </h2><br><p>  There are many types of hash tables.  For my, I chose: </p><br><ul><li>  Open Addressing. </li><li>  Linear placement. </li><li>  Hashing Robin Hood. </li><li>  The number of slots is a prime number (but I realized the possibility of using numbers for this purpose, which are powers of two). </li><li>  Limit the maximum number of sets. </li></ul><br><p>  I think the last point is a novelty in the field of hash tables.  This is the main reason for the high performance of my solution.  But first I would like to talk about the previous points. </p><br><p> <strong>Open addressing</strong> means that the hash table uses a continuous array as data storage.  This is not an analogue of <code>std::unordered_map</code> , when each element is in a separate heap. </p><br><p>  <strong>Linear placement</strong> means that if you try to insert an element into an array, and the current slot is already full, then you simply go to the next slot.  If it is also filled, then the next slot is taken, and so on.  This simple approach has known flaws, but I believe that they are corrected by limiting the maximum number of sets. </p><br><p>  <strong>Hashing Robin Hood</strong> means that with linear placement you try to position each element as close as possible to its ideal position.  This is done by moving the surrounding elements when inserting or deleting an element.  The principle is this: we take from rich elements (rich elements) and transfer to poor elements (poor elements).  Hence the name Robin Hood.  An element that has received a slot in the vicinity of its ideal insertion point is called rich.  The poor element is far away from the ideal insertion point.  By inserting a new element, you count how far it is from the ideal position.  If it is further than the current element, then you put a new one in place of the current one, and then try to find a new place for it. </p><br><p>  <strong>The number of slots is a prime number</strong> : the size of the array underlying the hash table is a prime number.  This means that it can grow, for example, from 5 slots to 11, then to 23, to 47, and so on.  When you need to find the insertion point, then the modulo operator is used to assign the element's hash value to the slot.  Another option is to make the size of the array equal to the power of two.  Below we will talk about why by default I use simple numbers and when it is advisable to use both options. </p><br><h2 id="ogranichenie-maksimalnogo-kolichestva-naborov">  Limit the maximum number of sets </h2><br><p>  We've figured out the basics, let's now discuss my solution: limiting the maximum number of slots in which the table will perform a search, after which it spits and increases the size of the array. </p><br><p>  First, the idea was to make this number very small, for example, equal to 4. That is, when inserting, I first try the perfect slot, if it does not work, then I turn to the next, then to the next, then to the next, and if all of them are filled then I enlarge the table and try again to insert the element.  This works great on small tables.  But when I insert a random value into a large table, I will always fail with these four sets; I will have to increase the size of the table, even if it is mostly empty. </p><br><p>  In the end, I found that with the upper limit equal to log2 (n), where n is the number of slots in the table, reallocation is performed only when it is approximately 2/3 full.  This is when inserting a random value.  And if you insert consecutive values, then you can fill the table as a whole, and only then it will be redistributed. </p><br><p>  But despite the empirically found threshold of 2/3, from time to time the redistribution was launched at 60% of the table filling.  Occasionally - even at 55% m.  Therefore, I assigned a <code>max_load_factor</code> table value of 0.5.  This means that the table will increase when filled to 50%, even if the limit on the number of sets has not been reached.  I did this so that you can trust the table redistribution, when you really increase its size: if you insert a thousand items, then delete a couple of them, and then insert the same number again, you can be almost completely sure that the table will not be redistributed.  I do not have exact statistics, but I drove a simple test in which I built thousands of tables of various sizes and filled them with random numbers.  In sum, I performed the insertion of hundreds of billions of numbers, and only once was the redistribution with a load factor (less than 0.5) (the table increased when filling 48%).  So you can trust such a mechanism: it very rarely redistributes when you don‚Äôt wait. </p><br><p>  In general, if you do not need to control the increase in the table, freely <code>max_load_factor</code> value higher.  Safely set up to 0.9: high speed of all operations is provided by a combination of Robin Hood and restrictions on the number of sets.  But do not assign a value of 1.0: a situation may arise when, when inserting, the movement of <strong>each</strong> element of the table begins to fill the last remaining slot.  For example, all slots in which the last element wants to be are already occupied, except for the last empty one.  Then you insert the element in the first slot in which he wants to be, but he is already busy.  You will have to move the existing element to the second slot, from there evict the element to the third, and so on by the chain to the end of the table.  As a result, you get a table in which all the elements, with the exception of the very first one, are in one slot from their ideal positions.  The search will still be fast, but the last insertion will take a long time.  If you have several free slots nearby, then the inserted element will move not so many neighbors. </p><br><p>  If you set <strong>max_load_factor</strong> such a low value that the limit on the number of sets will never be reached, then why limit anything at all?  Thanks to this limitation, you can implement a fine optimization: let's say you re-cache the table to get 1000 slots.  In my case, the table will grow to 1009, this is the nearest prime number.  The binary logarithm of 1009 is rounded to 10, so I limit the number of sets to ten.  Now apply the trick: instead of an array on 1009 slots, we will create an array on 1019. But all other hashing operations will assume that we have only 1009 slots.  Now, if two elements are hashed into the index 1008, then I can go to the end and insert into the index 1009. I do not need to check the range of indexes (bounds checking), because limiting the number of sets will not let me go beyond the index 1018. If If there are 11 elements that I want to get into the last slot, then the table will increase and all these elements will be combined into different slots.  Due to the absence of boundary checking, I have compact inner loops.  Here‚Äôs what the search function looks like: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">iterator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FindKey &amp; key)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index = hash_policy.index_for_hash(hash_object(key)); EntryPointer it = entries + index; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span> distance = <span class="hljs-number"><span class="hljs-number">0</span></span>;; ++distance, ++it) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;distance_from_desired &lt; distance) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> end(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compares_equal(key, it-&gt;value)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { it }; } }</code> </pre> <br><p>  In essence, this is a linear search.  The code is beautifully converted to assembler.  This approach is better than simple linear placement for two reasons: </p><br><ol><li>  There is no check of the range of variation of indices.  Empty slots have a <code>distance_from_desired</code> value of ‚Äì1, so this is similar to finding another item. </li><li>  In the loop, no more log2 (n) iterations are performed.  Usually when searching in hash tables, the worst time complexity is O (n).  In my table - O (log n).  This is a big difference.  Especially given the fact that with linear placement, the worst option is preferable, since the elements tend to be grouped. </li></ol><br><p>  My memory overhead is 1 byte per item.  I store <code>distance_from_desired</code> in <code>int8_t</code> .  That is, when aligning the type (alignment of the type) of the inserted element will be padded (padded out) 1 byte.  So if you insert integer values, then 1 byte will receive another 3 bytes of padding, resulting in 4 bytes of overhead for each element.  If you insert pointers, then padding will be already 7 bytes, we get 8 bytes of overhead.  To solve this problem, I am considering the option of changing the memory usage scheme, but I fear that then I will have two cache misses for each search instead of one.  So the memory overhead is 1 byte per element + padding.  And with the <code>max_load_factor</code> value <code>max_load_factor</code> to 0.5, your table will be filled only by 25‚Äì50%, so the total overhead is even higher.  Let me remind you that, in order to save memory, you can safely increase <code>max_load_factor</code> to 0.9, this will only lead to a slight decrease in speed. </p><br><h2 id="proizvoditelnost-poiska">  Search performance </h2><br><p>  It‚Äôs not so easy to figure out the performance of hash tables.  At a minimum, you need to measure speed in such situations: </p><br><ol><li>  Search for an item in a table. </li><li>  Search for an element that is not in the table. </li><li>  Insert a group of random numbers. </li><li>  Inserts a group of random numbers after calling <code>reserve()</code> . </li><li>  Removing items. </li></ol><br><p>  And each of these situations needs to be run with different keys and values ‚Äã‚Äãof different sizes.  I use an integer or string value as a key, and 4, 32, and 1024 value types. I prefer integer values, because with string values ‚Äã‚Äãyou mostly measure the overhead of the hash function and the comparison operator, the same for all hash tables. </p><br><p>  It is necessary to test the search both in the presence of an element in the table, and in its absence, because in these cases the performance can be completely different.  For example, I faced a difficult situation when I inserted all the numbers from 0 to 500,000 into <code>google::dense_hash_map</code> (not random numbers), and then I searched for the missing element.  Unexpectedly, the hash table is 500 times slower than usual.  This is an extreme case - using the power of two to set the size of the table.  Probably, it was necessary to take measurements with random numbers and with consecutive ones, but then there would be too many graphs.  So I will confine myself to random numbers, they eliminate the occurrence of unsuccessful performance situations due to specific patterns. </p><br><p>  The first chart is the search for an element present in the table: </p><br><p><img src="https://habrastorage.org/files/9eb/bd5/135/9ebbd513532d44caa5599eb68291958a.png" alt="image"></p><br><p>  The graphics are pretty tight.  <code>flat_hash_map</code> is my new hash table.  <code>flat_hash_map_power_of_two</code> is the same table, but the size of the array is determined by a power of two, not a prime number.  As you can see, the second option is much faster, I will explain the reason later.  <code>dense_hash_map</code> is <code>google::dense_hash_map</code> , the fastest hash table I found.  <code>sherwood_map</code> is the old table from ‚ÄúI wrote a faster hash table‚Äù.  To my confusion, she showed mediocre results ... <code>std::unordered_map</code> and <code>boost::unordered_map</code> - everything is clear from the names.  <code>multi_index</code> is <code>boost::multi_index</code> . </p><br><p>  We will discuss this schedule a bit.  Y axis - the number of nanoseconds spent on the search for a single element.  I used Google Benchmark, which call the <code>table.find()</code> function time after time, and then it calculates how many times it has been able to do it.  The total duration of the iterations is divided by their number, resulting in nanoseconds.  All required keys are present in the table.  For the X axis, I took the logarithmic scale, because it describes well the change in performance.  In addition, this scale allows us to estimate the performance for tables of different sizes: if you are interested in small tables, then look at the left side of the graph. </p><br><p>  Immediately striking jagged graphs.  The point is that all the tables have different performance depending on the current fill factor (load factor), that is, the degree of filling.  At 25%, the search will be performed faster than at 50%: the larger the table, the more hash collisions occur.  The cost of the search grows, and at some point the table decides that it has filled too much and it is time to reallocate, which again results in faster search. </p><br><p>  This would be obvious if I displayed the fill factor graphs for each table.  Also, you would immediately see that the lower graphs are obtained at <code>max_load_factor</code> , equal to 0.5, and the upper ones - at 1.0.  The question immediately arises: would the tables in the upper graphs be faster than the lower ones for the same value - 0.5?  There would be, but very slightly.  Next we look at this situation more fully.  The graph shows that the lower point of the upper graphs, when the tables have just been redistributed and have a fill factor of just over 0.5, is located much higher than the upper point of the lower graphs just before the redistribution, due to the fact that their fill factor approaches 0.5 . </p><br><p>  You also see that on the left side all the graphs are relatively flat.  The reason is that the tables are completely sent to the cache.  Only when the data ceases to fit in the L3 cache does the graphics noticeably diverge.  I think this is a big problem.  In my opinion, the right side of the graphs reflects the situation much more accurately than the left one: you will get results similar to the left side only when the desired item is already in the cache. </p><br><p>  Therefore, I tried to come up with a test that would show the speed of the table, which is not in the cache.  I created so many tables so that they did not fit in L3, and used different tables for each element sought.  Suppose I want to measure the speed of a table containing 32 elements of 8 bytes each.  The size of my L3 cache is 6 MB, so approximately 25 thousand such tables fit into it.  To make sure that the tables in the cache are missing, I created them with a margin of 75 thousand pieces.  And each search was performed in a separate table. </p><br><p><img src="https://habrastorage.org/files/371/4d2/df2/3714d2df2c2b4e54a3c2ee198e14c915.png" alt="image"></p><br><p>  I removed a couple of lines, because they were uninformative.  <code>boost::unordered_map</code> and <code>std::unordered_map</code> usually show the same performance, and no one cares about my old slow <code>sherwood_map</code> table.  Now we have left: <code>std::unordered_map</code> as a regular container based on nodes (node ‚Äã‚Äãbased container), <code>boost::multi_index</code> as a fast container based on nodes (I think that <code>std::unordered_map</code> can be no less fast), <code>google::dense_hash_map</code> as a fast open addressing container and my new container in two versions - based on prime numbers and powers of two. </p><br><p>  In the new benchmark graphics immediately began to vary greatly.  The pattern that appeared on the graph of the first benchmark on the graph of the second benchmark became noticeable very early, starting with 10 elements.  Impressive: all tables show stable performance in a very large range of the number of elements. </p><br><p>  Let's look at the charts of a failed search ‚Äî that is, a search for an element that is not in the table. </p><br><p><img src="https://habrastorage.org/files/90d/a28/e67/90da28e677cc4029af1fdb97feafc495.png" alt="image"></p><br><p>  Serration is even more pronounced, the fill factor plays a prominent role.  The stronger the table is, the more elements you have to look through before the system decides that the element is missing.  But I really like the results of my table: it looks like the limit on the number of sets works.  My table shows more stable performance than others. </p><br><p>  These graphs convinced me that my new table is a big step forward.  The red line shows the operation of my table, configured in the same way as <code>dense_hash_map: max_load_factor 0,5</code> , and the choice to determine the size of a power of two allows you to place a hash in the slot simply by the <code>dense_hash_map: max_load_factor 0,5</code> bits.  The only big difference: my table uses an extra byte for storage (plus padding) for each slot, that is, it consumes slightly more memory than <code>dense_hash_map</code> . </p><br><p>  At the same time, my table is not inferior in speed even when using simple numbers to determine the size of the table.  Let's talk about this in more detail. </p><br><h2 id="prostye-chisla-ili-stepen-dvoyki">  Prime numbers or power of two </h2><br><p>  Finding an item in a table goes through three expensive steps: </p><br><ol><li>  Key Hashing </li><li>  Placement of the key in the slot. </li><li>  Getting memory for this slot. </li></ol><br><p>  Stage 1 can be cheap if the key is an integer: just drop it in <code>size_t</code> .  But with other types of keys, such as string, the stage will be more expensive. </p><br><p>  Stage 2 - integer modulo. </p><br><p>  Stage 3 - pointer dereference.  In the case of <code>std::unordered_map</code> this is a dereferencing of several pointers. </p><br><p>  It may seem that if you have a not too slow hash function, then stage 3 is the most expensive of all.  But if you do not have cache misses on every single search, then the second is most likely the most expensive step.  The integer modulo is processed slowly, even on powerful hardware.  <a href="https://software.intel.com/sites/default/files/managed/9e/bc/64-ia-32-architectures-optimization-manual.pdf">According to Intel</a> , this takes from 80 to 95 cycles. <br>  This is the main reason why really fast hash tables usually use a power of two to determine the size of the array.  Because then it will be enough for you to remove the high bits, which can be done in one cycle. </p><br><p>  But the power of two has a big drawback: quite a few patterns of input data create numerous collisions of hashes when using a power of two.  Here is a graph of the second benchmark, but this time I did not use random numbers: </p><br><p><img src="https://habrastorage.org/files/9ce/d6c/fb8/9ced6cfb889f42ba9005785e8066d709.png" alt="image"></p><br><p>  Yes, that's right: <code>google::dense_hash_map</code> went into the stratosphere.  For this, it was enough to give her a set of numbers in order: [0, 1, 2, ..., n - 2, n - 1].  If you do this and look for a key that is not in the table, the search will be extremely slow.  If there is a key, then everything is fine, it works quickly.  In this case, the difference in performance between successful and unsuccessful search can reach thousands of times. </p><br><p>  Another example of the problem is due to the power of two: the standard hash table in Rust began to <a href="http://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion">demonstrate quadratic behavior</a> (quadratic) when inserting keys from one table to another.  So using a power of two can lead to unpleasant surprises. </p><br><p>  It so happened that my table avoided all these problems by limiting the number of sets.  There was not even unnecessary redistribution.  But this does not mean that my table is invulnerable to side effects of using a power of two.  For example, I somehow came across the fact that when inserting pointers into such a table, some slots were constantly empty.   ,         16- ,     -,        <code>reinterpret_casted  size_t</code> . -         .              -. </p><br><p>    ,      -,      .     :      -.     ,     . ,   ,    .               (    ). </p><br><p>      ?       ,   ,         ,    . ,    ,    32 ,       16-  (      16).                  : 0  16.  32  16,       .        ,     . ,   37 ,       16     37 . </p><br><p>           ?     <code>boost::multi_index</code> :         (compile time constant).            .     ,      .        .     -      ,   : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(prime_index) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">2l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">3l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">5l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">7l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">11l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">13l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">17l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">23l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">29l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">37l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">47l</span></span>lu; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash % <span class="hljs-number"><span class="hljs-number">59l</span></span>lu; <span class="hljs-comment"><span class="hljs-comment">// // ...   // case 185: return hash % 14480561146010017169llu; case 186: return hash % 18446744073709551557llu; }</span></span></code> </pre><br><p>    ‚Äî        .  What is good?   ,        .         ,     ,     .   ,     . </p><br><p>       :       ,         -,         . ,   .     ,     <code>std::map</code>     .    ,        ,    .          ,       . </p><br><p>       .  -       ,      .   ?   ,  -     -,       ,       .         -    . ,   ,   <code>dense_hash_map</code> ,      ,        ,     . </p><br><p>  ,               .      :   ,        ,        ,           .       .      -,     ,   .   ,    -  ,     ,    <code>std::hash</code>   -,       (stateful),       .   ,    ,      ,          . </p><br><p> , ,  ,   -    ,            .        .      <code>typedef</code>   <code>hash_policy</code>   -.       ,         . </p><br><p> ,   <code>typedef</code>     -: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomHashFunction</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> YourStruct &amp; foo) { <span class="hljs-comment"><span class="hljs-comment">//  - } typedef ska::power_of_two_hash_policy hash_policy; }; // : ska::flat_hash_map&lt;YourStruct, int, CustomHashFunction&gt; your_hash_map;</span></span></code> </pre> <br><p>   -   <code>hash_policy</code>  <code>ska::power_of_two_hash_policy</code> .   <code>flat_hash_map</code>     .       <code>std::hash</code> ,     <code>power_of_two_std_hash</code> ,    <code>std::hash</code> ,    <code>power_of_two_hash_policy</code> : </p><br><pre> <code class="cpp hljs">ska::flat_hash_map&lt;K, V, ska::power_of_two_std_hash&lt;K&gt;&gt; your_hash_map;</code> </pre> <br><p>          -,  ,      . </p><br><h2 id="proizvoditelnost-vstavki-i-udaleniya">     </h2><br><p>            .   ,       .  ,      N ,      .        <code>reserve()</code>   : </p><br><p><img src="https://habrastorage.org/files/439/77e/28a/43977e28a9ce43269a5560c1f32b1917.png" alt="image"></p><br><p>   ,     .     ,    .   ,      . </p><br><p>  ,      ,       L3.            ,     ,       ,     ‚Äî    . </p><br><p>    <code>google::dense_hash_map</code>    ,   .   ,  <code>dense_hash_map</code>     .         .    Robin Hood        ,    ¬´          ¬ª.        .   ,      . </p><br><p>  ,    ,    <code>reserve()</code> : </p><br><p><img src="https://habrastorage.org/files/9a6/766/276/9a67662765934a10847e6966e8b91207.png" alt="image"></p><br><p>  ,         .    ,     . ,     malloc     (Linux gcc).             ,          . </p><br><p>       ,     - ,  <code>reserve</code>    .     ,   ,  <code>google::dense_hash_map</code> . </p><br><p>  ,      .       N           .      N: </p><br><p><img src="https://habrastorage.org/files/d1e/01a/79b/d1e01a79bc4b4a5eadc43847b95f48b7.png" alt="image"></p><br><p>        ,     .      23 ,  <code>dense_hash_map</code> ‚Äî  20.      . </p><br><p>       :  <code>dense_hash_map</code>  ,     ¬´¬ª (tombstone).       ,       . ¬´¬ª      (quadratic probing),  <code>google::dense_hash_map</code>    :        ,    .   Robin Hood          ,     :     ,         .       ,    .               .      ¬´¬ª,     .       . </p><br><p>   ,      ¬´¬ª,      .     <code>dense_hash_map</code>      .     ,   ,     :        : </p><br><p><img src="https://habrastorage.org/files/a1a/534/46f/a1a53446fe574f7093781fb9a1224386.png" alt="image"></p><br><p>      .     -, ,  .      . ,      : 1, 2, 3  4.    ¬´, ,  ¬ª :  1,  3,  1,  2,  4,  4,  4,  1,  2,  3,  3,  2.   ,    ,    .             .    ‚Äî    .  ‚Äî   ,      (  ).    ‚Äî , , , , .     .  And so on. </p><br><p>  <code>dense_hash_map</code>     ,       .        ,    ‚Äî .  6             .     ,     ,      .        ,         500 . .      --,      .     ,   <code>dense_hash_map</code>  ¬´¬ª,   .       <code>dense_hash_map</code>   : </p><br><p><img src="https://habrastorage.org/files/ebb/a1f/1ba/ebba1f1ba46c4c79a8f10847802c6f99.png" alt="image"></p><br><p>   ,     <code>dense_hash_map</code>  ,     ¬´¬ª.           .      Robin Hood      :     ,     .     ,       . </p><br><h2 id="sravnenie-tablic-s-raznym-max_load_factor">     max_load_factor() </h2><br><p>  ,       <code>std::unordered_map</code>  <code>boost::multi_index</code>  max_load_factor,  1,0,        <code>google::dense_hash_map</code>  0,5.          <code>max_load_factor</code> ?   ,      ( ),     <code>max_load_factor</code> 0,5.        . </p><br><p><img src="https://habrastorage.org/files/0b0/d0d/927/0b0d0d927cfe41639030d74881fd5ab4.png" alt="image"></p><br><p> , <code>max_load_factor</code>    0,5,      ,        ,        .      ,  ,        . ,   ,      - ,     <code>max_load_factor</code>   . </p><br><p>  <code>flat_hash_map</code>   <code>dense_hash_map</code> ,     . ,    <code>dense_hash_map</code>  ,      :      L3,  <code>flat_hash_map</code>  . </p><br><p>          <code>boost::multi_index</code>  <code>std::unordered_map</code> ,  <code>max_load_factor</code> 1,0,  <code>flat_hash_map</code>  <code>dense_hash_map</code> ,  <code>max_load_factor</code> ‚Äî 0,5.  ,    flat-  . </p><br><p>  ,   ,      .  ,      -,           .        ,           <code>max_load_factor</code> .            ,    ,     -     .    ‚Äî    .         :        . </p><br><h2 id="raznye-klyuchi-i-znacheniya">     </h2><br><p>              (map from int to int).            .   ‚Äî             : </p><br><p><img src="https://habrastorage.org/files/f55/df2/137/f55df21370ce4106976379cfc1e7b024.png" alt="image"></p><br><p>     ,    .   .  ,       .   ,        -    .    : </p><br><p><img src="https://habrastorage.org/files/b26/2e9/95f/b262e995fb5f4c1d99c5928654d0a50e.png" alt="image"></p><br><p>  : ,       <code>google::dense_hash_map</code>  ,   <code>boost::multi_index</code> .   :   <code>dense_hash_map</code>     ,   ,     ,    ¬´¬ª.  , , <code>std::string(1, 0)</code>  <code>std::string(1, 255)</code> .   ,      ,  ,   .        . </p><br><p>          ,      .  ,      .       ,           .       : </p><br><p><img src="https://habrastorage.org/files/cdf/5ce/0c4/cdf5ce0c4f354bcfaa3da75d2e128c23.png" alt="image"></p><br><p>      , <code>dense_hash_map</code>           (  ).    . </p><br><p>      .           (map from int to int),     32- ?     1024- ?      12  ([, 32-, 1024-] √ó [, ] √ó [ ,  ]),        ,   :         ,       .   :      1024- : </p><br><p><img src="https://habrastorage.org/files/bd7/da6/550/bd7da6550d2b44eb86891d1a805dd5ca.png" alt="image"></p><br><p>  ,  1024-  <code>multi_index</code>    flat-.   ,         ,     -  prefetcher    .      ,   1024       . </p><br><p>       ,                :     .    flat-      .     <code>max_load_factor</code>  0,5,      .      :        ,  ,     .       ,   ‚Äî  .      ,           (prefetch)       . </p><br><p>             (size of the type),       .         32-    : </p><br><p><img src="https://habrastorage.org/files/692/74a/bd1/69274abd1a5c493c8e621ccd9bbb3e91.png" alt="image"></p><br><p>    ,       flat-,       :     ,     .         ,  <code>boost::multi_index</code>    .  ,     1024- : </p><br><p><img src="https://habrastorage.org/files/a46/2db/80e/a462db80e2e1461f8816a637033afddc.png" alt="image"></p><br><p>  : flat-  ,     ,        .        . </p><br><p>    :  <code>dense_hash_map</code>      (   ).   ,      32        - (default constructed value type).     - ‚Äî 1024 ,     32 <strong></strong> . ,     ,       . </p><br><p>     <code>dense_hash_map</code>    .     ,  ,            -,       -   ,  ,     . </p><br><p>   , ,    ,        <code>reserve()</code> . ,  ,      ,     <code>reserve()</code> : </p><br><p><img src="https://habrastorage.org/files/f20/7e1/0b4/f207e10b452e48d1abb624f01de281a0.png" alt="image"></p><br><p>         ,   -  <code>boost::multi_index</code>  . <code>dense_hash_map</code>   ,  ,   , -         ,       ¬´¬ª  /   . ,   ,   ¬´¬ª     ,         1024 ?           ,           . </p><br><p>    ,     :  16 385     .  16 384     .      1028 , ,     16 ,    .   ,      -     .    ,       ,      . ,  ,    :         ,   <code>clear_page_c_e</code> .      <a href="https://randomascii.wordpress.com/2014/12/10/hidden-costs-of-memory-allocation/"></a> ,      ,       <code>clear_page_c_e</code> .  -              .      ,        . </p><br><p>    ,       .            .    ,    . </p><br><p>      : </p><br><p><img src="https://habrastorage.org/files/33c/24a/211/33c24a21128a445aba2bfe3144abe497.png" alt="image"></p><br><p> <code>dense_hash_map</code>    .   ,       (  Ubuntu 16.04)     ,      . </p><br><p>                ,        .       .     <code>reserve()</code> : </p><br><p><img src="https://habrastorage.org/files/758/13d/887/75813d88727e4919a77bdc83db6de04d.png" alt="image"></p><br><p>  ,   ,     .      ,      .  :      ,        ,     -    ,   .       -      : </p><br><p><img src="https://habrastorage.org/files/b35/a13/1ee/b35a131ee7b94cf0a33a2743490eeb4d.png" alt="image"></p><br><p> <code>dense_hash_map</code>   -    .           .  ,   <code>flat_hash_map_power_of_two</code>        16 385  -     <code>clear_page_c_e</code> . </p><br><p> :    -  ,       ,     <code>reserve()</code> .             ,  . </p><br><p>     .             :    4, 32  1024 .      4- .  32    ,       .   1024   : </p><br><p><img src="https://habrastorage.org/files/2a9/9d8/858/2a99d88584804342862a0feaa0e06285.png" alt="image"></p><br><p> <code>dense_hash_map</code>   .    :         ,   no-op   ,  <code>dense_hash_map</code>   ¬´¬ª  /,     ,    1024  . </p><br><p>   :    <code>flat_hash_map</code>          .      ,           ,      . ,   ,      <code>flat_hash_map</code>    ,    ,    1028  . </p><br><p>           ,      .  Here is one of them: </p><br><p><img src="https://habrastorage.org/files/aa3/736/365/aa373636512a42ad8367c7b9d529c17c.png" alt="image"></p><br><p>     1024 ,         . </p><br><p>   ‚Äî ¬´, ,  ¬ª   .      10 .,    10       .     10 .    .   -  32 : </p><br><p><img src="https://habrastorage.org/files/88e/563/8a1/88e5638a18ef48519c0c8d3fe4ae26d2.png" alt="image"></p><br><p> <code>flat_hash_map</code>  <code>dense_hash_map</code> .         . </p><br><p><img src="https://habrastorage.org/files/0ae/b0b/c3a/0aeb0bc3a37e464cb37b7b9da9f34e0f.png" alt="image"></p><br><p>    -    <code>dense_hash_map</code> .       ,     .   ,       <code>reserve()</code> ,          .  flat-   ,       ‚Äî .          ,    <code>unordered_map</code>   - , ,   <code>multi_index</code> .    ,  <code>multi_index</code>   : </p><br><p><img src="https://habrastorage.org/files/7cb/a08/671/7cba0867177f49c783b23b84e152d85c.png" alt="image"></p><br><p>       ,           ,   1028      .        ,     :          .         ,     ,      <code>multi_index</code> : </p><br><p><img src="https://habrastorage.org/files/746/5d6/a5c/7465d6a5c99147f384dc97a4f29b66e2.png" alt="image"></p><br><p>          .  32- -    .    -  1024 ,     ,    ,   ,   . </p><br><h2 id="itogi-po-proizvoditelnosti">    </h2><br><p>   ,  ,   -   .   ,               .    .        :   ,     ,    ,   .     .         ,   ,   : </p><br><ul><li>         ,    . </li><li>        .     . </li><li>            ,     ,     .     flat-.    flat-          . </li><li>           ,   .   -    . </li><li> <code>google::dense_hash_map</code>       . </li><li> <code>boost::multi_index</code> ‚Äî   -.          . </li><li>   ,   -    ,       ,   -,       . </li></ul><br><h2 id="isklyucheniya">  Exceptions </h2><br><p>            ,   ,  -,     (equality function)   .       (move constructor)   .   ,         .      ,        . </p><br><h2 id="ishodnyy-kod-i-ispolzovanie">     </h2><br><p>   <a href="">   Github</a> .    Boost-.      <code>ska::flat_hash_map</code>  <code>ska::flat_hash_set</code> .   ,   <code>std::unordered_map</code>  <code>std::unordered_set</code> . </p><br><p>       ,       .    ,   ska::power_of_two_hash_policy. </p><br><p>     ,  <code>max_load_factor</code>      0,5.        0,9.    ,         .      ,    70 %,        .        ,       <code>max_load_factor</code>  ,      . </p><br><h2 id="itog">  Total </h2><br><p> ,     -.             .  ‚Äî     .     log2(n),            O(log(n))  O(n).   .        Robin Hood        . </p><br><p> -   Boost-    hash_map  hash_set.  ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323242/">https://habr.com/ru/post/323242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323232/index.html">Put this info-style in your text: 22 commandments of a strong editor</a></li>
<li><a href="../323234/index.html">Painless resolution of Merge conflicts in Git</a></li>
<li><a href="../323236/index.html">Why at the age of forty I decided to change my profession and become a Python programmer</a></li>
<li><a href="../323238/index.html">Implementing in Python multithreaded data processing for parsing sites</a></li>
<li><a href="../323240/index.html">ua-hosting.company: welcome to Los Angeles at HostingCon Global, giving the All Access Pass / E5-2650v4 from $ 29 to NL / US</a></li>
<li><a href="../323244/index.html">The digest of interesting materials for the mobile developer # 193 (February 27 - March 5)</a></li>
<li><a href="../323246/index.html">I prepare CentOS 6.8 for work</a></li>
<li><a href="../323250/index.html">PVS-Studio security research</a></li>
<li><a href="../323252/index.html">Python program for statistical text analysis</a></li>
<li><a href="../323254/index.html">Backbone projects of telecommunications giants and maps of underwater communication channels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>