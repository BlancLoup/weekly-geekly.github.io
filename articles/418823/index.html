<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Python is slow. Why?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, one can observe the growing popularity of the Python programming language. It is used in DevOps, in data analysis, in web development, in se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Python is slow. Why?</h1><div class="post__text post__text-html js-mediator-article">  Recently, one can observe the growing popularity of the Python programming language.  It is used in DevOps, in data analysis, in web development, in security, and in other areas.  But here‚Äôs the speed ... There‚Äôs nothing for this language to boast about.  The author of the material, the translation of which we are publishing today, decided to find out the reasons for the sluggishness of Python and find the means to accelerate it. <br><br> <a href="https://habr.com/company/ruvds/blog/418823/"><img src="https://habrastorage.org/webt/tv/zp/uz/tvzpuzzfhsgdyegpe8ri3pbl3mw.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">General provisions</font> </h2><br>  How does Java, in terms of performance, relate to C or C ++?  How to compare C # and Python?  Answers to these questions seriously depend on the type of applications analyzed by the researcher.  There is no perfect benchmark, but studying the performance of programs written in different languages ‚Äã‚Äãcan be a good <a href="http://algs4.cs.princeton.edu/faq/">starting point</a> for the project The Computer Language Benchmarks Game. <br><br>  I refer to The Computer Language Benchmarks Game for more than ten years.  Python, in comparison with other languages ‚Äã‚Äãsuch as Java, C #, Go, JavaScript, C ++, is one of <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/python.html">the slowest</a> .  This includes languages ‚Äã‚Äãthat use <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">JIT</a> compilation (C #, Java), and <a href="https://en.wikipedia.org/wiki/Ahead-of-time_compilation">AOT</a> compilation (C, C ++), as well as interpreted languages ‚Äã‚Äãsuch as JavaScript. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here I would like to note that saying ‚ÄúPython‚Äù, I mean the reference implementation of the Python interpreter - CPython.  In this article we will touch on its other implementations.  In fact, here I want to find the answer to the question of why Python takes 2-10 times longer than other languages ‚Äã‚Äãto solve comparable tasks, and whether it can be done faster. <br><br>  Here are the main theories trying to explain the reasons behind Python's slow work: <br><br><ul><li>  The reason for this is in GIL (Global Interpreter Lock, global interpreter lock). </li><li>  The reason is that Python is an interpretable, not a compiled language. </li><li>  The reason is dynamic typing. </li></ul><br>  Let us analyze these ideas and try to find the answer to the question of what has the greatest impact on the performance of Python applications. <br><br><h2>  <font color="#3AC1EF">GIL</font> </h2><br>  Modern computers have multi-core processors, and sometimes multiprocessor systems are also found.  In order to use all this computational power, the operating system uses low-level structures, called threads, while processes (for example, the Chrome browser process) can run multiple threads and use them accordingly.  As a result, for example, if a process is particularly in need of processor resources, its execution can be divided among several cores, which allows most applications to quickly solve the problems they face. <br><br>  For example, my Chrome browser, at the moment when I write this, has 44 open threads.  Here it is worth considering that the structure and API of the threading system differs in operating systems based on Posix (Mac OS, Linux) and in the Windows operating system family.  The operating system is also involved in scheduling work flows. <br><br>  If you have never met with multithreaded programming, now you need to get acquainted with the so-called locks.  The meaning of locks is that they allow to provide such a system behavior when, in a multi-threaded environment, for example, when a variable in a variable changes, access to the same memory area (for reading or change) cannot receive several threads simultaneously. <br><br>  When the CPython interpreter creates variables, it allocates memory, and then counts the number of existing references to these variables.  This concept is known as reference counting.  If the number of links equals zero, then the corresponding section of memory is freed.  That is why, for example, the creation of "temporary" variables, say, within the scope of cycles, does not lead to an excessive increase in the amount of memory consumed by the application. <br><br>  The most interesting thing begins when several threads share the same variables, and the main problem here is how CPython performs reference counting.  This is where the ‚Äúglobal interpreter blocking‚Äù action manifests itself, which carefully controls the execution of threads. <br><br>  An interpreter can perform only one operation at a time, no matter how many threads there are in the program. <br><br><h3>  <font color="#3AC1EF">‚ñçHow does GIL affect Python application performance?</font> </h3><br>  If we have a single-threaded application running in the same Python interpreter process, then GIL does not affect performance in any way.  If, for example, get rid of GIL, we will not notice any difference in performance. <br><br>  If, within the same Python interpreter process, you need to implement parallel data processing using multi-threading mechanisms, and the threads used will heavily use an I / O subsystem (for example, if they work with a network or with a disk), then you can observe the consequences how GIL manages threads.  Here is how it looks in case of using two threads, intensively loading processes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9e/379/f47/f9e379f4724ba48881f53b489ca5ed1d.png"></div><br>  <i><font color="#999999">Visualization of the work of GIL (taken <a href="http://dabeaz.blogspot.com/2010/01/python-gil-visualized.html">from here</a> )</font></i> <br><br>  If you have a web application (for example, based on the Django framework), and you use WSGI, then each request to the web application will be serviced by a separate Python interpreter process, that is, we have only 1 block per request.  Since the Python interpreter starts up slowly, some WSGI implementations have a so-called ‚Äúdaemon mode‚Äù, using which <a href="https://www.slideshare.net/GrahamDumpleton/secrets-of-a-wsgi-master">the interpreter processes are</a> maintained, which allows the system to serve requests faster. <br><br><h3>  <font color="#3AC1EF">‚ñç How do other Python interpreters behave?</font> </h3><br>  <a href="http://doc.pypy.org/en/latest/faq.html">PyPy</a> has GIL, it is usually more than 3 times faster than CPython. <br><br>  There is no GIL in Jython, since Python streams in Jython are represented as Java streams.  Such threads use JVM memory management capabilities. <br><br><h3>  <font color="#3AC1EF">‚ñç How is flow control organized in javascript?</font> </h3><br>  If we talk about JavaScript, then, first of all, it should be noted that all JS-engines use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management">mark-and-sweep</a> garbage collection algorithm.  As already mentioned, the main reason for using GIL is the memory management algorithm used in CPython. <br><br>  There is no GIL in JavaScript, however, JS is a single-threaded language, so there is no need for such a mechanism in it.  Instead of parallel code execution in JavaScript, asynchronous programming techniques are used, based on the event loop, promises and callbacks.  In Python, there is something similar presented by the <code>asyncio</code> module. <br><br><h2>  <font color="#3AC1EF">Python - Interpretable Language</font> </h2><br>  I have often heard that the poor Python performance is due to the fact that it is an interpreted language.  Such statements are based on a gross simplification of how CPython actually works.  If, in the terminal, enter a command like <code>python myscript.py</code> , then CPython will begin a long sequence of actions, which consists of reading, lexical analysis, parsing, compiling, interpreting and executing script code.  If you are interested in the details - take a look at <a href="https://hackernoon.com/modifying-the-python-language-in-7-minutes-b94b0a99ce14">this</a> material. <br><br>  When considering this process, it is particularly important for us that here, at the compilation stage, a <code>.pyc</code> file is created, and the bytecode sequence is written to a file in the <code>__pycache__/</code> directory, which is used in both Python 3 and Python 2 <br><br>  This applies not only to the scripts we write, but also to the imported code, including third-party modules. <br><br>  As a result, most of the time (unless you are writing code that runs only once) Python performs the execution of the finished bytecode.  If we compare this with what is happening in Java and in C #, it turns out that Java code is compiled into ‚ÄúIntermediate Language‚Äù, and the Java virtual machine reads the byte code and performs its JIT compilation into machine code.  The "intermediate language" .NET CIL (this is the same as the .NET Common-Language-Runtime, CLR), uses JIT compilation to go to the machine code. <br><br>  As a result, both in Java and in C # a certain ‚Äúintermediate language‚Äù is used and there are similar mechanisms.  Why, then, does Python show much worse results in benchmarks than Java and C #, if all these languages ‚Äã‚Äãuse virtual machines and some kind of bytecode?  First of all, due to the fact that in .NET and in Java JIT compilation is used. <br><br>  JIT compilation (Just In Time compilation, ‚Äúon-the-fly‚Äù or ‚Äújust-in-time‚Äù compilation) requires an intermediate language in order to allow breaking the code into fragments (frames).  AOT-compilation systems (Ahead Of Time compilation, compilation before execution) are designed to ensure that the code is fully operational before the interaction of this code with the system begins. <br><br>  By itself, the use of JIT does not speed up the execution of the code, since, as in Python, some bytecode fragments arrive at execution.  However, JIT allows you to perform code optimizations during its execution.  A good JIT optimizer is able to identify the most loaded parts of an application (such a part of an application is called a ‚Äúhot spot‚Äù) and optimize the corresponding code fragments, replacing them with optimized and more efficient variants than those used previously. <br><br>  This means that when an application again and again performs certain actions, such optimization can significantly speed up the execution of such actions.  Also, keep in mind that Java and C # are strongly typed languages, so the optimizer can make more code for the code to improve program performance. <br><br>  The JIT compiler is in PyPy, and, as already mentioned, this implementation of the Python interpreter is much faster than CPython.  Details regarding the comparison of different Python interpreters can be found in <a href="https://hackernoon.com/which-is-the-fastest-version-of-python-2ae7c61a6b2b">this</a> article. <br><br><h3>  <font color="#3AC1EF">‚ñç Why not use the JIT compiler in CPython?</font> </h3><br>  JIT compilers have drawbacks.  One of them is launch time.  CPython starts up relatively slowly, and PyPy is 2-3 times slower than CPython.  The long launch time of a JVM is also a well-known fact.  The .NET CLR bypasses this problem, starting up during the boot process, but here it should be noted that both the CLR and the operating system in which the CLR runs are developed by the same company. <br><br>  If you have one Python process that runs for a long time, while in such a process there is code that can be optimized, since it contains heavily used areas, then you should seriously look at the interpreter that has the JIT compiler. <br><br>  However, CPython is an implementation of a general-purpose Python interpreter.  Therefore, if you are developing, using Python, a command line application, the need to wait a long time for the JIT compiler to run every time you start this application will slow down greatly. <br><br>  CPython is trying to provide support for as many Python usage options as possible.  For example, there is the possibility of connecting the JIT compiler to Python, however, the <a href="https://www.slideshare.net/AnthonyShaw5/pyjion-a-jit-extension-system-for-cpython">project</a> , in which this idea is implemented, is not developing very actively. <br><br>  As a result, it can be said that if you, using Python, write a program whose performance can improve when using the JIT compiler, use the PyPy interpreter. <br><br><h2>  <font color="#3AC1EF">Python - dynamically typed language</font> </h2><br>  In statically typed languages, when declaring variables, it is necessary to specify their types.  Among such languages ‚Äã‚Äãare C, C ++, Java, C #, Go. <br><br>  In dynamically typed languages, the concept of a data type has the same meaning, but the type of a variable is dynamic. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> a = <span class="hljs-string"><span class="hljs-string">"foo"</span></span></code> </pre> <br>  In this simplest example, Python first creates the first variable <code>a</code> , then the second with the same name, of type <code>str</code> , and frees the memory that was allocated to the first variable <code>a</code> . <br><br>  It may seem that writing in languages ‚Äã‚Äãwith dynamic typing is more convenient and easier than in languages ‚Äã‚Äãwith static typing, however, such languages ‚Äã‚Äãare not created by whim.  In their development, the features of the operation of computer systems have been taken into account.  Everything that is written in the text of the program, as a result, comes down to the processor instructions.  This means that the data used by the program, for example, in the form of objects or other types of data, is also converted to low-level structures. <br><br>  Python performs such conversions automatically, the programmer does not see these processes, and he does not need to take care of such conversions. <br><br>  The lack of need to specify the type of a variable when it is declared is not a feature of the language that makes Python slow.  The architecture of the language allows you to make almost anything dynamic.  For example, at run time, you can replace the methods of objects.  Again, during the execution of the program, you can use the technique of "monkey patches" as applied to low-level system calls.  In Python, almost everything is possible. <br><br>  It is the Python architecture that makes it extremely difficult to optimize. <br><br>  In order to illustrate this idea, I'm going to use a tool for tracing system calls in MacOS, which is called DTrace. <br><br>  There is no DTrace support mechanism in the finished CPython distribution, so CPython will need to be recompiled with the appropriate settings.  Version 3.6.6 is used here.  So, we use the following sequence of actions: <br><br><pre> <code class="hljs ruby">wget <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/github.com/python</span></span><span class="hljs-regexp"><span class="hljs-regexp">/cpython/archive</span></span><span class="hljs-regexp"><span class="hljs-regexp">/v3.6.6.zip unzip v3.6.6.zip cd v3.6.6 ./configure</span></span> --with-dtrace make</code> </pre> <br>  Now, using <code>python.exe</code> , you can use DTRace to trace the code.  You can read about using DTrace with Python <a href="https://github.com/paulross/dtrace-py">here</a> .  And <a href="https://github.com/paulross/dtrace-py/tree/master/toolkit">here</a> you can find scripts to measure using DTrace various performance indicators of Python-programs.  Among them are the parameters for calling functions, program execution time, processor usage time, information about system calls, and so on.  Here is how to use the <code>dtrace</code> command: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> dtrace -s toolkit/&lt;tracer&gt;.d -c <span class="hljs-string"><span class="hljs-string">'../cpython/python.exe script.py'</span></span></code> </pre> <br>  This is how the <code>py_callflow</code> tracing <code>py_callflow</code> shows the function calls in the application. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13e/bd4/926/13ebd492636a94b23400305293aec346.gif"></div><br>  <i><font color="#999999">DTrace tracing</font></i> <br><br>  Now let's answer the question of whether dynamic typing affects Python performance.  Here are some thoughts on this: <br><br><ul><li>  Type checking and conversion are difficult operations.  Each time a variable is accessed, read or written, the type is checked. </li><li>  A language with such flexibility is difficult to optimize.  The reason why other languages ‚Äã‚Äãare so much faster than Python is because they make some compromises, choosing between flexibility and performance. </li><li>  The <a href="http://cython.org/">Cython</a> project combines Python and static typing, which, for example, as shown in <a href="http://notes-on-cython.readthedocs.io/en/latest/std_dev.html">this material</a> , results in a 84-fold increase in performance compared to using conventional Python.  Pay attention to this project if you need speed. </li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  The reason for the poor performance of Python is its dynamic nature and versatility.  It can be used as a tool for solving various tasks.  To achieve the same goals, you can try to search for more productive, better optimized tools.  Perhaps it will be possible to find them, perhaps not. <br><br>  Applications written in Python can be optimized using the capabilities of asynchronous code execution, profiling tools, and by choosing the right interpreter.  So, in order to optimize the speed of applications that run without any importance, and whose performance can benefit from using the JIT compiler, consider using PyPy.  If you need maximum performance and are ready for the limitations of static typing, take a look at Cython. <br><br>  <b>Dear readers!</b>  How do you solve poor Python performance problems? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/418823/">https://habr.com/ru/post/418823/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418809/index.html">A corporation that DIY challenges you to a duel</a></li>
<li><a href="../418815/index.html">Common mistakes that developers make when learning - and how to avoid them</a></li>
<li><a href="../418817/index.html">Phased progressive disclosure in mobile UX: how it works</a></li>
<li><a href="../418819/index.html">On board the ISS created ultracold substance</a></li>
<li><a href="../418821/index.html">New features Angular 6.1</a></li>
<li><a href="../418825/index.html">Methods and tools for developing styles of web pages</a></li>
<li><a href="../418829/index.html">As the only line of the ancient code, half a year drove the MMORPG developers crazy</a></li>
<li><a href="../418833/index.html">Nodejs and IoT: made for each other</a></li>
<li><a href="../418837/index.html">Life in Germany through the eyes of my wife</a></li>
<li><a href="../418839/index.html">Kivy - framework for cross-platform development ‚Ññ1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>