<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Protected methods in javascript ES5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot of great articles have been written about the object model in JavaScript. Yes, and about the various ways to create private class members on the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Protected methods in javascript ES5</h1><div class="post__text post__text-html js-mediator-article">  A lot of great articles have been written about the object model in JavaScript.  Yes, and about the various ways to create private class members on the Internet is full of decent descriptions.  But about protected methods - there is very little data.  I would like to fill this gap and tell you how to create protected methods without libraries on pure JavaScript ECMAScript 5. <br><br>  In this article: <br><br><ul><li>  <a href="https://habr.com/ru/post/425521/">Why do we need protected members of the class</a> </li><li>  <a href="https://habr.com/ru/post/425521/">What you need to understand the method presented</a> </li><li>  <a href="https://habr.com/ru/post/425521/">Helper class ProtectedError</a> </li><li>  <a href="https://habr.com/ru/post/425521/">Implementing protected members (methods and properties) for classes declared as a function (ECMAScript 5)</a> </li></ul><br>  <a href="https://github.com/Basim108/js-oop-protected">Link to git-hub repository with source code and tests.</a> <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Why do we need protected members of the class </h2><br>  In short, <br><br><ul><li>  easier to understand the work of the class and find errors in it.  (You can immediately see in which cases the class members are used. If the private ones, then only the given class should be analyzed, well, and if the protected ones, then only the given and derived classes.) </li><li>  easier to manage change.  (For example, you can remove private members without fear of breaking something outside of the class being edited.) </li><li>  decreases the number of requests in the bug-tracker, because  Library or control users can ‚Äúbind‚Äù to our ‚Äúprivate‚Äù members, who in the new version of the class we decided to remove or change the logic of their work. </li><li>  And in general, protected class members are a design tool.  It‚Äôs good to have it handy and well-tested. </li></ul><br>  Recall that the main idea of ‚Äã‚Äãprotected members is to hide methods and properties from users of an instance of a class, but still allow derived classes to have access to them. <br><br>  Using TypeScript will not allow you to call protected methods, however, after compilation in JavaScript, all private and protected members become public.  For example, we are developing a control or library that users will install on their sites or applications.  These users will be able to do whatever they want with the protected members, violating the integrity of the class.  As a result, our bug tracker breaks down from complaints that our library or controls are not working properly.  We spend time and effort on sorting out - <i>‚Äúthis is how the object turned out to be in that state at the client, which led to an error ?!‚Äù</i> .  Therefore, in order to make life easier for all, we need such protection that will not give the opportunity to change the meaning of private and protected members of a class. <br><br><h2>  What you need to understand the method under consideration </h2><br>  To understand the method of declaring the protected members of a class, you need to know for sure <br><br><ul><li>  device classes and objects in javascript. </li><li>  ways to create private members of a class (at least through a closure). </li><li>  Object.defineProperty and Object.getOwnPropertyDescriptor methods </li></ul><br>  About the object model device in JavaScript, I can recommend, for example, an excellent article by Andrey Akinshin ( <a href="https://habr.com/users/dreamwalker/" class="user_link">DreamWalker</a> ) <a href="https://habr.com/company/enterra/blog/153365/">‚ÄúUnderstanding the OOP in JS [part ‚Ññ1]‚Äù</a> . <br>  About private properties there is a good and, in my opinion, fairly complete description of <a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Add-on_SDK/Guides/Contributor_s_Guide/Private_Properties">as many as 4 different ways of creating private class members</a> on the MDN website. <br><br>  As for the Object.defineProperty method, it will allow us to hide properties and methods from for-in loops, and, as a result, from serialization algorithms: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(MyClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedNumber'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicNumber = <span class="hljs-number"><span class="hljs-number">25</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj1){ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'property:'</span></span> prop); <span class="hljs-comment"><span class="hljs-comment">//prop     'protectedNumber' } console.log(JSON.stringify(obj1)); //  { 'publicNumber': 25 }</span></span></code> </pre> <br>  Such a concealment is necessary, but this, of course, is not enough.  it is still possible to call the method / property directly: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj1.protectedNumber); <span class="hljs-comment"><span class="hljs-comment">//  12.</span></span></code> </pre><br><h2>  Helper class ProtectedError </h2><br>  To begin, we need the ProtectedError class, which inherits from Error, and which will be thrown out if there is no access to a protected method or property. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProtectedError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = <span class="hljs-string"><span class="hljs-string">"Encapsulation error, the object member you are trying to address is protected."</span></span>; } ProtectedError.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(); ProtectedError.prototype.constructor = ProtectedError;</code> </pre><br><h2>  Implementing protected class members in ES5 </h2><br>  Now that we have a ProtectedError class and we understand what Object.defineProperty does with enumerable: false, let's look at creating a base class that wants to share the protectedMethod method with all its derived classes, but hide it from everyone else: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   ,        /** @summary       */ function checkAccess() { if (!(this instanceof BaseClass)) throw new ProtectedError(); if (this.constructor === BaseClass) throw new ProtectedError() } Object.defineProperty(_self, 'protectedMethod', { enumerable: false, //    for-in  configurable:false, //     value: function(){ //   , ,          Base,     checkAccess.call(this); //  . protectedMethod(); } }); function protectedMethod(){ //       , //       this,   _self return 'example value'; } this.method = function (){ protectedMethod(); //          BaseClass //this.protectedMethod(); //   , ..      ProtectedError } }</span></span></code> </pre><br><h3>  Description of the BaseClass class constructor </h3><br>  You might be confused by the check: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass();</code> </pre>  This check is "an amateur."  You can remove it, it is not related to protected methods.  However, I personally leave it in my code, since  it is needed for those cases when an instance of the class is created incorrectly, i.e.  without the keyword new.  For example, like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = BaseClass(); <span class="hljs-comment"><span class="hljs-comment">//  : var obj2 = BaseClass.call({});</span></span></code> </pre><br>  In such cases, do what you want.  You can, for example, generate an error: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'Wrong instance creation. Maybe operator "new" was forgotten'</span></span>);</code> </pre><br>  Or you can simply create an instance correctly, as is done in BaseClass. <br><br>  Next, we save the new instance in the _self variable (why I need to explain it a little later). <br><br><h3>  A description of a public property named protectedMethod </h3><br>  Entering the method, we call the context check on which we were called.  It is better to put the check into a separate method, for example, checkAccess, since  the same check will be needed in all protected methods and class properties.  So, first of all, we check the context type of the ‚Äúthis‚Äù call.  If this has a type other than BaseClass, then the type is neither BaseClass itself, nor any of its derivatives.  We prohibit such calls. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BaseClass)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  How can this happen?  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someObject = {}; b.protectedMethod.call(someObject); <span class="hljs-comment"><span class="hljs-comment">//   ,  protectedMethod this   someObject    , .. someObject instanceof BaseClass  </span></span></code> </pre><br>  In the case of derived classes, the expression this instanceof BaseClass will be true.  But for BaseClass instances, the expression of this instanceof BaseClass will be true.  Therefore, to distinguish instances of the BaseClass class from instances of derived classes, check the constructor.  If the constructor matches BaseClass, then our protectedMethod is called on the BaseClass instance, as is the usual public method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); b.protectedMethod();</code> </pre><br>  We prohibit such calls: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === BaseClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError();</code> </pre><br>  Next comes the call to the protectedMethod closed method, which, in fact, is the method we are protecting.  Inside the method, if there is a need to refer to the members of the BaseClass class, you can do this using a saved instance of _self.  It was for this reason that _self was created to have access to class members from all closed / private methods.  Therefore, if in your protected method or property you do not need to access the members of the class, then you can not create the _self variable. <br><br><h3>  Calling a protected method inside the BaseClass class </h3><br>  Inside the BaseClass class, a protectedMethod should be accessed only by name, and not through this.  Otherwise, inside protectedMethod we will not be able to distinguish whether we were called as a public method or from inside the class.  In this case, the closure saves us - protectedMethod behaves like a normal private method, closed inside a class and visible only inside the scope of the BaseClass function. <br><br><h3>  DerivedClass Derived Class Description </h3><br>  Now let's look at the derived class and how to make it access to the protected method of the base class. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protectedMethod.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">/** @summary       */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError(); } <span class="hljs-comment"><span class="hljs-comment">//     Object.defineProperty(this, 'protectedMethod', { enumerable: false, // ..       this configurable: false,//         for-in  //      value: function(){ checkAccess.call(_self); return _base.protectedMethod(); } }); //        this.someMethod = function(){ console.log(_base.protectedMethod()); } } DerivedClass.prototype = new BaseClass(); Object.defineProperty(DerivedClass.prototype, 'constructor', { value : DerivedClass, configurable: false });</span></span></code> </pre><br><h3>  Derived Class Constructor Description </h3><br>  In a derived class, we create an _base object in which we place a reference to the protectedMethod method of the base class, closed to the context of the derived class via the standard bind method.  This means that the _base.protectedMethod () call;  inside protectedMethod this is not an _base object, but an instance of the DerivedClass class. <br><br><h3>  Description of the protectedMethod method inside the DerivedClass class </h3><br>  In the DerivedClass class, you must declare the protectedMethod public method in the same way as we did in the base class via Object.defineProperty and check access in it by calling the checkAccess method or performing the check directly in the method: <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'protectedMethod'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.constructor === DerivedClass) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProtectedError() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _base.protectedMethod(); } });</code> </pre><br>  We check - <i>‚Äúdidn‚Äôt they</i> call <i>us as a simple public method?‚Äù</i> Instances of the class DerivedClass constructor will be equal to DerivedClass.  If so, then we generate an error.  Otherwise, we send it to the base class and it will already do all the other checks. <br><br>  So, in the derived class, we have two functions.  One is declared via Object.defineProperty and is needed for classes derived from DerivedClass.  It is public and therefore there is a check prohibiting public calls.  The second method is in the _base object, which is closed inside the DerivedClass class and therefore not visible to anyone from the outside and it is used to access the protected method from all the DerivedClass methods. <br><br><h3>  Property Protection </h3><br>  With properties, the work happens a little differently.  The properties in BaseClass are defined as usual via Object.defineProperty, only in getters and setters you need to first add our check, i.e.  call checkAccess: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _protectedProperty; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); _protectedProperty = value; }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); }</code> </pre><br>  Inside the BaseClass class, we access the protected property not through this, but to the closed variable _protectedProperty.  In case it is important for us to work the getter and setter when using the property inside the BaseClass class, then we need to create private getProtectedPropety and setProtectedProperty methods, inside which there will be no checks, and already call them. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _protectedProperty; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getProtectedProperty(); }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ checkAccess.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); setProtectedProperty(value); }, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getProtectedProperty</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    return _protectedProperty; } function setProtectedProperty(value){ //    _protectedProperty = value; } }</span></span></code> </pre><br>  In derived classes, working with properties is a bit more complicated, since  property cannot be replaced by context.  Therefore, we will use the standard Object.getOwnPropertyDescriptor method to get the getter and setter as a function from the base class property, which can already change the calling context: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DerivedClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _base = { <span class="hljs-attr"><span class="hljs-attr">protectedMethod</span></span>: _self.protectedMethod.bind(_self), }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _baseProtectedPropertyDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(_self, <span class="hljs-string"><span class="hljs-string">'protectedProperty'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      _base //    DerivedClass     Object.defineProperty(_base, 'protectedProperty', { get: function() { return _baseProtectedPropertyDescriptor.get.call(_self); }, set: function(value){ _baseProtectedPropertyDescriptor.set.call(_self, value); } }) //      ,      DerivedClass      . Object.defineProperty(_self, 'protectedProperty', { get: function () { checkAccess.call(_self); return base.protectedProperty; }, set: function (value) { checkAccess.call(_self); _base.protectedProperty = value; }, enumerable: false, configurable: false }); }</span></span></code> </pre><br><h3>  Inheritance description </h3><br>  And the last thing I would like to comment on is the inheritance of DerivedClass from BaseClass.  As you probably know, DerivedClass.prototype = new BaseClass ();  not only creates a prototype, but also rewrites its constructor property.  Because of this, for each instance of DerivedClass, the constructor property becomes equal to BaseClass.  To fix this, usually, after prototyping, the constructor property is rewritten: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); DerivedClass.prototype.constructor = DerivedClass;</code> </pre><br>  However, so that no one rewrites this property after us, use the same Object.defineProperty.  The configurable property: false prevents the property from being redefined again: <br><br><pre> <code class="javascript hljs">DerivedClass.prototype = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseClass(); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(DerivedClass.prototype, <span class="hljs-string"><span class="hljs-string">'constructor'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span> : DerivedClass, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> });</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/425521/">https://habr.com/ru/post/425521/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425511/index.html">Unobvious features of Rotativa for generating PDF in an ASP.NET MVC application</a></li>
<li><a href="../425513/index.html">Deputies seriously undertook the taxation of miners</a></li>
<li><a href="../425515/index.html">Apple blocks the possibility of independent repair of new MacBook models</a></li>
<li><a href="../425517/index.html">How Yandex created a global precipitation forecast using radars and satellites</a></li>
<li><a href="../425519/index.html">Our problems with space are the result of making the wrong decisions.</a></li>
<li><a href="../425525/index.html">Tim Berners-Lee goes on the warpath: "One small step for the web ..."</a></li>
<li><a href="../425527/index.html">Lists in Kotlin. Haskell approach</a></li>
<li><a href="../425529/index.html">Sans Forgetica: a font that allows you to memorize what you read</a></li>
<li><a href="../425531/index.html">Liquid cooling brakes. System development options</a></li>
<li><a href="../425533/index.html">How to work in the cloud: from checking the reliability of the data center to managing the virtual infrastructure</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>