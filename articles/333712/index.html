<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What's new in Swift 4.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Practical examples that will help you learn about what's new for us in Swift 4. 

 Swift 4.0 is a new version of many of your favorite programming lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What's new in Swift 4.0</h1><div class="post__text post__text-html js-mediator-article">  Practical examples that will help you learn about what's new for us in Swift 4. <br><br>  Swift 4.0 is a new version of many of your favorite programming language with new features that allow us to write simpler and safer code.  You will be pleased to learn that this is not as dramatic as the epic changes in Swift 3.0 and most of the changes are backward compatible with your existing Swift code.  Of course, you will need some time to make changes, but this should not take a lot of time. <a name="habracut"></a><br><br><div class="spoiler">  <b class="spoiler_title">From the translator:</b> <div class="spoiler_text">  I apologize in advance for the design and maybe some minor flaws in the translation, because  This is my first experience of a full-fledged translation of a technical article, not for myself, but for the benefit of others. <br></div></div><br>  <b>WARNING:</b> Swift 4 at the time of writing and preparing the translation of the article is in active development and the author of the original selected only some of the most interesting and useful new features for discussion.  Please keep in mind that more features will be available closer to the release. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Swift encoding and decoding </h3><br>  We know that the types of values ‚Äã‚Äãare great, but we also know that they interact terribly with the Objective-C API, such as <i>NSCoding</i> - you need to write a certain layer or use classes, and both options are unpleasant.  Worse, even if you switch to classes, you need to write manual encoding and decoding methods, the writing of which is painful and error prone. <br><br>  Swift 4 introduces the <i>Codable</i> protocol, which allows you to serialize and deserialize your own data types without writing additional code and not worry about losing your data types.  Moreover, you can choose how you want to serialize data: use the classic property list format or JSON. <br><br>  <b>Yes, you read everything correctly: Swift 4 allows you to serialize your own data types to JSON without writing any special code.</b> <br><br>  Let's see how beautiful it is.  First, here are the custom data type and some of its instances: <br><br><pre><code class="hljs pgsql">struct <span class="hljs-keyword"><span class="hljs-keyword">Language</span></span>: Codable { var <span class="hljs-type"><span class="hljs-type">name</span></span>: String var <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> } let swift = <span class="hljs-keyword"><span class="hljs-keyword">Language</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Swift", <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span>) let php = <span class="hljs-keyword"><span class="hljs-keyword">Language</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "PHP", <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-number"><span class="hljs-number">7</span></span>) let perl = <span class="hljs-keyword"><span class="hljs-keyword">Language</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Perl", <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre> <br>  As you can see, I connected the <i>Codable</i> protocol to the <i>Language</i> structure.  With this tiny addition, we can convert it to JSON, represented as <i>Data in the</i> following way: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encoder = <span class="hljs-type"><span class="hljs-type">JSONEncoder</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encoded = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? encoder.encode(swift) { <span class="hljs-comment"><span class="hljs-comment">//  `encoded` - }</span></span></code> </pre><br>  Swift automatically encodes all the properties within your data type, you do not need to do additional actions. <br><br>  Now you, if you, like me, have used <i>NSCoding</i> for a long time, probably have some doubts: is this really what we need and how can we be sure that it works?  Let's add some code to try to convert the <i>Data</i> object so that we can display it in the console, then we need to decode it back into a new instance of the <i>Language</i> structure: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> encoded = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? encoder.encode(swift) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> json = <span class="hljs-type"><span class="hljs-type">String</span></span>(data: encoded, encoding: .utf8) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(json) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoder = <span class="hljs-type"><span class="hljs-type">JSONDecoder</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> decoded = <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>? decoder.decode(<span class="hljs-type"><span class="hljs-type">Language</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, from: encoded) { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(decoded.name) } }</code> </pre><br>  Both JSONEncoder and PropertyListEncoder have many customization options.  For more information on other options, see <a href="">suggestions for developing this new functionality</a> . <br><br><h3>  Multiline String Literals </h3><br>  Writing multi-line strings in Swift has always meant adding <i>\ n</i> inside your lines to add line breaks where you want them.  In the code, this does not look very good, but at least correctly displays information for users.  Fortunately, Swift 4 adds a new syntax for multi-line string literals, which allows you to add line breaks and use quotation marks without escaping, while at the same time useful functionality such as string interpolation is available. <br><br>  To start a string literal, you need to: write three double quotes <i>"" "</i> and press <i>[Enter]</i> . Then you can continue to write the string for as many times as you want including variables and line breaks, until you finish your line by pressing <i>[Enter]</i> and writing three double quotes <i>" " "</i> . <br><br>  I would like to clarify about pushing a line break because string literals have two important rules: <br><br>  1) when you open a line using <i>"" "the</i> contents of your line should begin on a new line; <br>  2) when you close a line using <i>"" "</i> this designation should also be at the beginning of a new line. <br><br>  Here it is in action: <br><br><pre> <code class="hljs sql">let longString = """ When you write a string that spans multiple lines make sure you <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> its <span class="hljs-keyword"><span class="hljs-keyword">content</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a line all <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> its own, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> three quotes also <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a line <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> their own. Multi-line strings also let you write <span class="hljs-string"><span class="hljs-string">"quote marks"</span></span> freely inside your strings, which <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> great! <span class="hljs-string"><span class="hljs-string">"""</span></span></code> </pre><br>  This creates a new line with several line breaks right in the definition - it is much easier to read and write. <br><br>  For more information, see <a href="">suggestions for the development of this new functionality</a> . <br><br><h3>  Improved keypaths in KVC (Key-Value Coding) </h3><br>  One of the most favorite features of Objective-C is the ability to refer to a property dynamically, rather than directly ‚Äî that is, to be able to say <i>‚Äúthis is an X object, here is its property that I would like to read‚Äù</i> without reading it at all.  These links, called <i>keypaths</i> , are different from direct access to properties, because they don‚Äôt actually read or write the value, they just hide them to use later. <br><br>  If you haven't used <i>keypaths before,</i> let me show you an analogy of how they work using conventional Swift methods.  We are going to define the Starship and Crew structures, then create one instance of each: <br><br><pre> <code class="hljs pgsql">//    struct Crew { var <span class="hljs-type"><span class="hljs-type">name</span></span>: String var rank: String } //  ,      struct Starship { var <span class="hljs-type"><span class="hljs-type">name</span></span>: String var maxWarp: <span class="hljs-type"><span class="hljs-type">Double</span></span> var captain: Crew func goToMaximumWarp() { print("\(name) is now travelling at warp \(maxWarp)") } } //     let janeway = Crew(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Kathryn Janeway", rank: "Captain") let voyager = Starship(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Voyager", maxWarp: <span class="hljs-number"><span class="hljs-number">9.975</span></span>, captain: janeway) //    `goToMaximumWarp()`  let enterWarp = voyager.goToMaximumWarp //   enterWarp()</code> </pre><br>  Since the functions in Swift are first-class types, the last two lines can create a reference to the <i>goToMaximumWarp ()</i> method and call it later when we need it.  The problem is that we cannot do the same for properties ‚Äî we cannot say <i>‚Äúcreate a link to the property of the captain‚Äôs name, which I can check when the inevitable rebellion happens‚Äù</i> , because Swift will just read the property directly and you will just get the original value. <br><br>  This is fixed by <i>keypaths</i> : they are property references like our <i>enterWarp ()</i> code.  If you call the link now you get the current value, but if you call the link later, you will get the latest value.  You can get through any number of properties and Swift uses its output type to ensure that you return the correct type. <br><br>  The Swift development community spent a lot of time discussing the correct syntax for <i>keypaths</i> because it must be something visually different from other Swift code and in the end this syntax uses backslashes: <i>\ Starship.name</i> , <i>\ Starship.maxWarp</i> , and <i>\ Starship .captain.name</i> .  You can assign these values ‚Äã‚Äãto variables and use them when you want them to any instance of the <i>Starship</i> structure.  For example: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nameKeyPath = \<span class="hljs-type"><span class="hljs-type">Starship</span></span>.name <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> maxWarpKeyPath = \<span class="hljs-type"><span class="hljs-type">Starship</span></span>.maxWarp <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> captainName = \<span class="hljs-type"><span class="hljs-type">Starship</span></span>.captain.name <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> starshipName = voyager[keyPath: nameKeyPath] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> starshipMaxWarp = voyager[keyPath: maxWarpKeyPath] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> starshipCaptain = voyager[keyPath: captainName]</code> </pre><br>  This will make <i>starshipName</i> as a <i>String</i> , and <i>starshipMaxWarp</i> will make <i>Double</i> because Swift is capable of displaying data types correctly.  The third example takes the property property and Swift also correctly defines it. <br><br>  For more information, see <a href="">suggestions for the development of this new functionality</a> . <br><br><h3>  Improved dictionary functionality </h3><br>  One of the most intriguing suggestions for Swift 4 was the addition of some new functionality to the dictionaries to make them more powerful, as well as make their behavior more predictable in certain situations. <br><br>  Let's start with a simple example: filtering dictionaries in Swift 3 does not return a new dictionary.  Instead, as a result of filtering, we get an array of tuples with key-value labels.  For example: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cities = [<span class="hljs-string"><span class="hljs-string">"Shanghai"</span></span>: <span class="hljs-number"><span class="hljs-number">24_256_800</span></span>, <span class="hljs-string"><span class="hljs-string">"Karachi"</span></span>: <span class="hljs-number"><span class="hljs-number">23_500_000</span></span>, <span class="hljs-string"><span class="hljs-string">"Beijing"</span></span>: <span class="hljs-number"><span class="hljs-number">21_516_000</span></span>, <span class="hljs-string"><span class="hljs-string">"Seoul"</span></span>: <span class="hljs-number"><span class="hljs-number">9_995_000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> massiveCities = cities.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.value &gt; <span class="hljs-number"><span class="hljs-number">10_000_000</span></span> }</code> </pre><br>  After this code is executed, you cannot use the following entry to get the necessary data: <br><br><pre> <code class="hljs objectivec">massiveCities[<span class="hljs-string"><span class="hljs-string">"Shanghai"</span></span>]</code> </pre> <br>  because it is no longer a dictionary.  Instead, you need to use this code: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">massiveCities</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.value</span></span></code> </pre> <br>  and that's not very cool. <br><br>  Beginning with Swift 4, this code behaves as you would expect - filtering will return a new dictionary. <br>  Yes, it is obvious that it will break any existing code that uses an array of tuples as the return value. <br><br>  Similarly, the <i>map ()</i> method with dictionaries did not work as many people had hoped: you received a transmitted key-value tuple; moreover, it could be one value added to the array.  For example: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> populations = cities.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> { $<span class="hljs-number"><span class="hljs-number">0</span></span>.value * <span class="hljs-number"><span class="hljs-number">2</span></span> }</code> </pre><br>  This is currently not modified in Swift 4, but a new method, <i>mapValues ‚Äã‚Äã()</i> , has <i>emerged</i> , which should be much more useful because this method allows you to convert values ‚Äã‚Äãand put them back into the dictionary using the original keys. <br><br>  For example, this code will convert a numeric value and convert the data on the population of cities to a string and add it back to a new dictionary with the same keys: Shanghai, Karachi, and Seoul: <br><br><pre> <code class="hljs bash">&lt;<span class="hljs-built_in"><span class="hljs-built_in">let</span></span> roundedCities = cities.mapValues { <span class="hljs-string"><span class="hljs-string">"\(</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$0</span></span></span><span class="hljs-string"> / 1_000_000) million people"</span></span> }</code> </pre><br>  <i>(If you're interested, mapping the dictionary keys is not safe, since you can accidentally create duplicates.)</i> <br><br>  My favorite dictionary add-on is a grouping initializer, which converts a sequence into a sequence dictionary, which are grouped according to your wishes.  Continuing our example with cities, we could use <i>cities.keys</i> to return an array of city names, and then group them by the first letter: <br><br><pre> <code class="hljs bash"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> groupedCities = Dictionary(grouping: cities.keys) { <span class="hljs-variable"><span class="hljs-variable">$0</span></span>.characters.first! } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(groupedCities)</code> </pre><br>  This will output the following to the console: <br><br><pre> <code class="hljs json">[<span class="hljs-string"><span class="hljs-string">"B"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Beijing"</span></span>], <span class="hljs-string"><span class="hljs-string">"S"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Shanghai"</span></span>, <span class="hljs-string"><span class="hljs-string">"Seoul"</span></span>], <span class="hljs-string"><span class="hljs-string">"K"</span></span>: [<span class="hljs-string"><span class="hljs-string">"Karachi"</span></span>]]</code> </pre><br>  Or we could group cities based on the length of their names: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> groupedCities = <span class="hljs-type"><span class="hljs-type">Dictionary</span></span>(grouping: cities.keys) { $<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(groupedCities)</code> </pre><br>  This will output the following to the console: <br><br><pre> <code class="hljs json">[<span class="hljs-number"><span class="hljs-number">5</span></span>: [<span class="hljs-string"><span class="hljs-string">"Seoul"</span></span>], <span class="hljs-number"><span class="hljs-number">7</span></span>: [<span class="hljs-string"><span class="hljs-string">"Karachi"</span></span>, <span class="hljs-string"><span class="hljs-string">"Beijing"</span></span>], <span class="hljs-number"><span class="hljs-number">8</span></span>: [<span class="hljs-string"><span class="hljs-string">"Shanghai"</span></span>]]</code> </pre><br>  Finally, it is now possible to access the dictionary key and provide a default value if the specified key is missing: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> person = [<span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Taylor"</span></span>, <span class="hljs-string"><span class="hljs-string">"city"</span></span>: <span class="hljs-string"><span class="hljs-string">"Nashville"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-string"><span class="hljs-string">"Anonymous"</span></span>]</code> </pre><br>  Now, any experienced developer may argue that a similar result can be achieved easier and I agree with that.  We could write it this way in the current version of Swift: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = person[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] ?? <span class="hljs-string"><span class="hljs-string">"Anonymous"</span></span></code> </pre><br>  However, this does not work if you change the meaning of the dictionary, and not just get it.  You cannot immediately change the value of the dictionary, because access by this key returns an optional type - the key may not exist.  Using the default dictionary values ‚Äã‚Äãin Swift 4, you can write more concise code, for example: <br><br><pre> <code class="hljs markdown">var favoriteTVShows = [<span class="hljs-string"><span class="hljs-string">"Red Dwarf", "Blackadder", "Fawlty Towers", "Red Dwarf"</span></span>] var favoriteCounts = [<span class="hljs-string"><span class="hljs-string">String: Int</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) for show in favoriteTVShows { favoriteCounts[show, default: 0] += 1 }</code> </pre><br>  This loop iterates through each line in <i>favoriteTVShows</i> and uses the <i>favoriteCocation</i> dictionary to track how often each element appears.  We can change the dictionary in one line of code, because we know that it will always have a value: either 0 as the default or some larger number based on the previous count. <br><br>  For more information, see <a href="">suggestions for the development of this new functionality</a> . <br><br><h3>  Lines again collection! </h3><br>  This small change, but guaranteed will make many people happy: the strings are collections again.  This means that you can now reverse them, iterate over the characters, use <i>map ()</i> and <i>flatMap ()</i> , etc.  For example: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> quote = <span class="hljs-string"><span class="hljs-string">"It is a truth universally acknowledged that new Swift versions bring new features."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> reversed = quote.reversed() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> letter <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> quote { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(letter) }</code> </pre><br>  This change was made as part of a set of amendments, called the <a href="">"Manifest String"</a> . <br><br><h3>  One-way ranges </h3><br>  Last but not least, in Swift 4, there is a Python-like one-way cutting of collections, where the missing side of the range is automatically defined as the beginning or end of the collection.  This does not affect the existing code, because it is a new approach to the existing operator, so you can not worry about potential breakage in the code.  Examples: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> characters = [<span class="hljs-string"><span class="hljs-string">"Dr Horrible"</span></span>, <span class="hljs-string"><span class="hljs-string">"Captain Hammer"</span></span>, <span class="hljs-string"><span class="hljs-string">"Penny"</span></span>, <span class="hljs-string"><span class="hljs-string">"Bad Horse"</span></span>, <span class="hljs-string"><span class="hljs-string">"Moist"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> bigParts = characters[..&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> smallParts = characters[<span class="hljs-number"><span class="hljs-number">3</span></span>...] <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(bigParts) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(smallParts)</code> </pre><br>  This code first displays in the console: <br><br><pre> <code class="hljs json">[<span class="hljs-string"><span class="hljs-string">"Dr Horrible"</span></span>, <span class="hljs-string"><span class="hljs-string">"Captain Hammer"</span></span>, <span class="hljs-string"><span class="hljs-string">"Penny"</span></span>]</code> </pre><br>  and then this: <br><br><pre> <code class="hljs json">[<span class="hljs-string"><span class="hljs-string">"Bad Horse"</span></span>, <span class="hljs-string"><span class="hljs-string">"Moist"</span></span>]</code> </pre><br>  For more information, see <a href="">suggestions for the development of this new functionality</a> . <br><br><h3>  More to come ... </h3><br>  At the time of the translation of the article, developers are already available Xcode 9 Beta 3 (from 10.07.2017) along with iOS 11, tvOS 11, watchOS 4, and the new version of macOS.  What we have already seen is promising, because it is clear that the team is working hard to make Swift 4 as good as possible.  This is primarily about adding new functions, and not about changing existing ones and this should make it easier to switch to a new stable version of the language. <br><br>  Despite the fact that the development of Swift can sometimes be chaotic, Swift 4 again confirms the approach of the Apple community.  I added a few sentences, each of the proposals was widely discussed by the community to reach agreement - these are not just Apple engineers who force changes simply because they can, instead they have a sensible and thoughtful approach to improve what is already a smart and elegant language. . <br><br>  One of the functions that was postponed is ABI compatibility, which would allow developers to distribute compiled libraries - one of the few key missing features that remain in Swift today.  I hope we get to this in Swift 5 ... </div><p>Source: <a href="https://habr.com/ru/post/333712/">https://habr.com/ru/post/333712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333702/index.html">Generics and Converters in Nim</a></li>
<li><a href="../333704/index.html">Corporate governance: how is a company legally built?</a></li>
<li><a href="../333706/index.html">Come on, girls! Ada lovelace dedicated</a></li>
<li><a href="../333708/index.html">3D Blockchain. Face Proof (PoF)</a></li>
<li><a href="../333710/index.html">K-sort: a new algorithm that exceeds the pyramid when n <= 7 000 000</a></li>
<li><a href="../333714/index.html">We do applications with search on Go</a></li>
<li><a href="../333716/index.html">Creating Angular 2+ components with the ability to switch themes</a></li>
<li><a href="../333718/index.html">Creating a GLSL smoke shader</a></li>
<li><a href="../333722/index.html">Current activity around MIPSfpga and not only</a></li>
<li><a href="../333724/index.html">Currency exchange: fix the course for offline online. VTB24 experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>