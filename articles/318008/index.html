<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PHP 7 performance improvement</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP is software written in C. The PHP codebase contains about 800 thousand lines of code and in the seventh version has been significantly reworked. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PHP 7 performance improvement</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/977/2b3/84d/9772b384d145495590574912075d713a.jpg"><br><br>  PHP is software written in C. The PHP codebase contains about 800 thousand lines of code and in the seventh version has been significantly reworked. <br><br>  In this article we will look at what has changed in the Zend engine of the seventh version compared to the fifth one, and also consider how to effectively use internal optimizations.  Take PHP 5.6 as a starting point.  Often, much depends on how certain things are written and presented to the engine.  When writing critical code, you need to pay attention to its performance.  By changing a few little things, you can greatly speed up the engine, often without prejudice to other aspects like readability of the code or debug control.  I will prove my reasoning with the Blackfire profiler. <br><a name="habracut"></a><br>  If you want to improve PHP performance by migrating to version 7, you will need: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Migrate the code base without making changes to it (or just convert it into code compatible with PHP 7).  This will be enough to increase the speed of work. </li><li>  Use the tips below to understand how different parts of the PHP Virtual Machine code have changed and how to use them to further increase performance. </li></ol><br><h1>  Packaged Arrays </h1><br>  Packed arrays are the first of the great optimizations in PHP 7. They consume less memory and in many cases work much faster than traditional arrays.  Packed arrays must meet the criteria: <br><br><ul><li>  Keys are integer values ‚Äã‚Äãonly; </li><li>  Keys are inserted into the array only in ascending order. </li></ul><br>  Example 1: <br><br><pre><code class="php hljs">$a = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>];</code> </pre> <br>  Example 2: <br><br><pre> <code class="php hljs">$a = [<span class="hljs-number"><span class="hljs-number">12</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'baz'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-number"><span class="hljs-number">67</span></span> =&gt; [] ];</code> </pre> <br>  These arrays are internally very well optimized.  But it is obvious that on a three-cell array you will not feel a difference compared to PHP 5. <br><br>  For example, in the symfony framework, packed arrays exist only in a class map generator, which creates code like: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">array</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Bundle\\FrameworkBundle\\EventListener\\SessionListener'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Storage\\PhpBridgeSessionStorage'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Storage\\Handler\\NativeFileSessionHandler'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Storage\\Proxy\\AbstractProxy'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Storage\\Proxy\\SessionHandlerProxy'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Session'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span></code> </pre> <br>  If you execute this code on PHP 5 and PHP 7 and analyze using Blackfire, you get: <br><br><img src="https://habrastorage.org/files/213/f15/9e2/213f159e215d4a77836ff0ea0f551c4d.png"><br><br>  As you can see, the total compilation and execution time for this array declaration has decreased by about 72%.  In PHP 7, such arrays become similar to NOPs, and in PHP 5, significant time is spent on compiling and loading during runtime. <br><br>  Let's take a larger array, for 10,000 cells: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>; $i++) { $a[] = $i; }</code> </pre> <br>  The same comparison: <br><br><img src="https://habrastorage.org/files/ecc/90f/c51/ecc90fc51600443ea4aaa76ae97124e4.png"><br><br>  Duration of processor usage has decreased about 10 times, and memory consumption has decreased from 3 MB to 0.5 MB. <br><br>  The PHP development team has spent a lot of effort on optimizing arrays, because arrays are one of the main structures on which the language is based (the second most important structure is objects that are internally implemented using the same model). <br><br>  The memory consumption of arrays in PHP 7 is much lower than in PHP 5. And when using packaged arrays, the savings are even higher. <br><br>  Do not forget: <br><br><ul><li>  If you need a list, then do not use strings in the keys (this will prevent the optimization of packed arrays); </li><li>  If the keys in the list are only integer, try to distribute them in ascending order (otherwise the optimization will not work either). </li></ul><br>  Such lists can be used in different parts of your application: for example, for enumeration (like a class map in Symfony) or for extracting results from a database in a specific order and with numeric data in a column.  This is often necessary in web applications ( <code>$pdo-&gt;query("SELECT * FROM table LIMIT 10000")-&gt;fetchAll(PDO::FETCH_NUM)</code> ). <br><br><h1>  Integer and floating point values ‚Äã‚Äãin PHP 7 are free. </h1><br>  In PHP 7, a completely different way of placing variables in memory.  Instead of heaps, they are now stored in stack memory pools.  This has a side effect: you can reuse variable variable containers for free, no memory is allocated.  This is not possible in PHP 5, there is a need to allocate some memory for each creation / assignment of a variable (which impairs performance). <br><br>  Take a look at this code: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>; $i++) { $$i = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; }</code> </pre> <br>  Here 10,000 variables are created with names from $ 0 to $ 10,000 with 'foo' as a string value.  Of course, during the initial creation of a container variable (as in our example) some memory is consumed.  But what if we now reuse these variables to store integer values? <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">/* ...  ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">10000</span></span>; $i++) { $$i = <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre> <br>  Here we simply reused the variables already allocated in memory.  In PHP 5, this would require re-allocating memory for all 10,000 containers, and PHP 7 simply takes the finished ones and puts the number 42 in them, which does not affect the memory.  In the seventh version, the use of integer and floating-point values ‚Äã‚Äãis completely free: the required size of memory is already allocated for the variable containers themselves. <br><br>  Let's see what Blackfire says: <br><br><img src="https://habrastorage.org/files/d52/3fc/3d6/d523fc3d66fb4f668c783b5ab957a8a0.png"><br><br>  In PHP 7, rejecting additional memory access when a variable changes leads to savings in processor cycles in the second <code>for</code> loop.  As a result, processor usage is reduced by 50%.  And assigning an integer value further reduces memory consumption compared to PHP 5. In the fifth version, 80,000 bytes are spent on allocating 10,000 integers in memory (on the LP64 platform), as well as a bunch of additional memory per allocator.  In PHP 7, these costs are not. <br><br><h1>  Optimization with encapsed strings </h1><br>  Encapsed strings are values ‚Äã‚Äãthat internally scan for variables.  They are declared using double quotes, or Heredoc syntax.  The algorithm analyzes the value and separates the variables from the strings.  For example: <br><br><pre> <code class="php hljs">$a = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; $b = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; $c = <span class="hljs-string"><span class="hljs-string">"  $a  $b"</span></span>;</code> </pre> <br>  When analyzing the line $ c, the engine should get the line: ‚ÄúI like foo and bar‚Äù.  This process in PHP 7 has also been optimized. <br><br>  This is what PHP 5 does: <br><br><ul><li>  Allocates a buffer for "Like"; </li><li>  Allocate buffer for "I like foo"; </li><li>  Adds (copies in memory) to the last ‚ÄúLike‚Äù and ‚Äúfoo‚Äù buffer, returns its temporary contents; </li><li>  Allocates a new buffer for ‚ÄúI like foo and‚Äù; </li><li>  Adds (copies in memory) "I like foo" and "and" to this last buffer and returns its temporary contents; </li><li>  Allocates a new buffer for ‚ÄúI like foo and bar‚Äù; </li><li>  Adds (copies in memory) ‚ÄúI like foo and‚Äù and ‚Äúbar‚Äù to this last buffer and returns its contents; </li><li>  Frees all intermediate used buffers; </li><li>  Returns the value of the last buffer. </li></ul><br>  Lots of work, right?  Such an algorithm in PHP 5 is similar to what is used when working with strings in C. But the fact is that it does not scale well.  This algorithm is not optimal when working with very long encapsed strings including a large number of variables.  But encapsed strings are often used in PHP. <br><br>  In PHP 7, everything works differently: <br><br><ul><li>  A stack is created; </li><li>  It contains all the elements that need to be added; </li><li>  When the algorithm reaches the end of the encapsed line, memory of the necessary size is allocated at the same time, in which all parts of the data are moved to the right places. </li></ul><br>  Body movements with memory remained, however, no intermediate buffers, as in PHP 5, are already used.  In PHP 7, memory is allocated only once for the final line, regardless of the number of parts of the line and variables. <br><br>  Code and result: <br><br><pre> <code class="php hljs">$w = md5(rand()); $x = md5(rand()); $y = md5(rand()); $z = md5(rand()); $a = str_repeat(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>); $b = str_repeat(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $i++) { $$i = <span class="hljs-string"><span class="hljs-string">"    $a,    $b,  : $w - $x - $y - $z"</span></span>; }</code> </pre> <br>  We created 1000 encapsed strings in which we find static string parts and six variables, two of which weigh 1 KB each. <br><br><img src="https://habrastorage.org/files/a81/8ac/097/a818ac09754c4f438126ba5734f671e1.png"><br><br>  As you can see, in PHP 7, processor utilization decreased by 10 times compared to PHP 5. Note that using the Blackfire Probe API (not shown in the example), we only profiled a loop, not the whole script. <br><br>  In PHP 7: <br><br><pre> <code class="php hljs">$bar = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> $a = <span class="hljs-string"><span class="hljs-string">"foo  $bar"</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> $a = <span class="hljs-string"><span class="hljs-string">"foo  "</span></span> . $bar;</code> </pre> <br>  Concatenation operation is not optimized.  If you use string concatenation, you will end up doing the same strange things as in PHP 5. And encapsed strings will help you take advantage of the new analysis algorithm that performs estimated concatenation using the ‚Äú <a href="https://en.wikipedia.org/wiki/Rope_%2528data_structure%2529">Rope</a> ‚Äú structure. <br><br><h1>  Reference mismatch </h1><br>  Reference mismatch arises when you pass a non-reference variable (non-ref variable) to the function as an argument passed by reference (passed-by-ref), or vice versa.  For example: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$arg)</span></span></span><span class="hljs-function"> </span></span>{ } $var = <span class="hljs-string"><span class="hljs-string">'str'</span></span>; foo($var);</code> </pre> <br>  Do you know what a nightmare is going on in the PHP 5 engine?  If a link mismatch occurs, the engine has to duplicate the variable before passing it to the function as an argument.  If the variable contains something large, like an array of several thousand records, then copying will take a lot of time. <br><br>  The reason is in how PHP 5 works with variables and links.  Moving to the body of the function, the engine still does not know whether you change the value of the argument.  If you change it, passing the argument by reference should result in a reflection of the change made to the outside when passing the reference variable. <br><br>  And if you do not change the value of the argument (as in our example)?  Then the engine should create a link from a non-reference variable that you pass during the function call.  In PHP 5, the engine completely duplicates the contents of a variable (with a very small number of pointers, calling <code>memcpy()</code> many times, which leads to a lot of slow memory accesses). <br><br>  When the PHP 7 engine wants to create a link from a non-reference variable, it simply wraps it in a newly created former link (former).  And no copying to memory.  The thing is that in PHP 7, work with variables is built quite differently, and the links are significantly reworked. <br><br>  Take a look at this code: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;$a)</span></span></span><span class="hljs-function"> </span></span>{ $f = $a; } $var = range(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1024</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i=<span class="hljs-number"><span class="hljs-number">0</span></span>; $i&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; $i++) { bar($var); }</code> </pre> <br>  Here is a double mismatch.  When you call <code>bar()</code> you force the engine to create a link from <code>$var</code> to <code>$a</code> , as the <code>&amp;$a</code> signature says.  Since <code>$a</code> now part of the reference set ( <code>$var-$a</code> ) in the body of <code>bar()</code> , you can influence it with the value of <code>$f</code> : this is another mismatch.  The link does not affect <code>$f</code> , so <code>$a-$f-$var</code> can not be connected to each other.  However, <code>$var-$a</code> connected in one part, and <code>$f</code> is alone in the second part, until you force the engine to create copies.  In PHP 7, you can quite easily create variables from links and turn them into links, only as a result copy-on-write can occur. <br><br><img src="https://habrastorage.org/files/693/0b5/75a/6930b575a7ce41179e19431a8f5663bf.png"><br><br>  Remember that if you have not fully understood the links in PHP (and not many people can boast of this), then it is better not to use them at all. <br><br>  We have seen that PHP 7 again saves a lot of resources compared to PHP 5. But in our examples we didn‚Äôt deal with copying cases when writing.  Here everything would be different, and PHP would have to do a memory dump for our variable.  However, using PHP 7 facilitates situations where mismatches may not be performed on purpose, for example, if you call <code>count($array)</code> , when part of the link is <code>$array</code> .  In this case, there will be no additional expenses in PHP 7, but in PHP 5 the processor will become hot (with a sufficiently large array, for example, when collecting data from SQL queries). <br><br><h1>  Immutable arrays </h1><br>  The concept of immutable arrays appeared in PHP 7, they are part of the OPCache extension.  An unchangeable is an array that is filled with immutable elements whose values ‚Äã‚Äãdo not require calculations and become known at compile time: string values, integer values, floating point values, or containing all of the above arrays.  In short, no dynamic elements and variables: <br><br><pre> <code class="php hljs">$ar = [ <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">9.87</span></span> ];</code> </pre> <br>  Immutable arrays were optimized in PHP 7. In PHP 5, no difference is made between arrays containing dynamic elements ( <code>$vars</code> ) and static when compiled.  In PHP 7, immutable arrays are not copied, not duplicated, but remain read-only. <br><br>  Example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; $i++) { $var[] = [ <span class="hljs-number"><span class="hljs-number">0</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Bundle\\FrameworkBundle\\EventListener\\SessionListener'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Symfony\\Component\\HttpFoundation\\Session\\Storage\\NativeSessionStorage'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* ... go to many immutable items here */</span></span> ]; }</code> </pre> <br>  This code creates one and the same array a thousand times (cut off, it can be represented as an array of hundreds or thousands of cells). <br><br>  In PHP 5, such an array is duplicated in memory a thousand times.  If it weighs several hundred kilobytes or even megabytes, then with a thousandfold duplication we will take up a large amount of memory. <br><br>  In PHP 7, OPCache marks these arrays as immutable.  The array is created once, and where necessary, a pointer to its memory is used, which leads to huge memory savings, especially if the array is large, as in the above example (taken from the Symfony 3 framework). <br>  Let's see how performance changes: <br><br><img src="https://habrastorage.org/files/548/cc5/d7e/548cc5d7eadd4f9a9d82e9b2ef3ec4ab.png"><br><br>  Again, there is a huge difference between PHP 5 and PHP 7. PHP 5 needs to create an array 1000 times, which takes 27 MB of memory.  In PHP 7 with OPCache only 36 Kb are involved! <br><br>  If it is convenient for you to use immutable arrays, do not hesitate.  Just do not violate the immutability by issuing a similar code: <br><br><pre> <code class="php hljs">$a = <span class="hljs-string"><span class="hljs-string">'value'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> $ar = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, $a]; <span class="hljs-comment"><span class="hljs-comment">/*  : */</span></span> $ar = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">'value'</span></span>];</code> </pre> <br><h1>  Other considerations </h1><br>  We looked at some internal tricks to explain why PHP 7 is much faster than PHP 5. But for many workloads, this is micro-optimization.  To get a noticeable effect from them, you need to use huge amounts of data or multiple cycles.  This happens most often when PHP processes (workers) are started in the background instead of processing HTTP requests. <br><br>  In such cases, you can greatly reduce the consumption of resources (processor and memory), just by writing code in a different way. <br><br>  But do not believe your forebodings about possible performance optimizations.  Do not blindly patch the code, use profilers to confirm or refute your hypotheses and check the actual performance of the code. </div><p>Source: <a href="https://habr.com/ru/post/318008/">https://habr.com/ru/post/318008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317998/index.html">Bad advice for your startup</a></li>
<li><a href="../318000/index.html">Using Service Worker to create a botnet</a></li>
<li><a href="../318002/index.html">How we met with Agile & Scrum</a></li>
<li><a href="../318004/index.html">Balancing outgoing calls via GSM gateway</a></li>
<li><a href="../318006/index.html">Development and publication of the first game for Android on Unity3D</a></li>
<li><a href="../318010/index.html">Hello dear Megaphone</a></li>
<li><a href="../318012/index.html">Intel Software Guard Extensions tutorial. Part 3, Design for Intel SGX</a></li>
<li><a href="../318014/index.html">Huawei router + hypervisor in one package. Starting from scratch</a></li>
<li><a href="../318016/index.html">Consumer psychology - free book and lecture with HSE</a></li>
<li><a href="../318018/index.html">Entertaining tasks and an excerpt from the book "Career Programmer"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>