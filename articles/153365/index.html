<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding OOP in JavaScript [Part 1]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Prototype inheritance is fine 
 JavaScript is an object-oriented (OO) language, rooted in the Self language, despite the fact that it looks like Jav...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding OOP in JavaScript [Part 1]</h1><div class="post__text post__text-html js-mediator-article">  <b><i>- Prototype inheritance is fine</i></b> <br>  JavaScript is an object-oriented (OO) language, rooted in the <a href="http://selflanguage.org/">Self</a> language, despite the fact that it looks like Java.  This circumstance makes the language really powerful due to some nice features. <br><br>  One of these features is the implementation of prototype inheritance.  This simple concept is flexible and powerful.  It allows you to make the inheritance and behavior of first-class entities, as well as functions are first-class objects in functional languages ‚Äã‚Äã(including JavaScript). <br><br>  Fortunately, <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript 5 has</a> a lot of things that allowed you to put the language on the right path (some of them are covered in this article).  There will also be talked about the disadvantages of JavaScript design and a small comparison with the classical prototype OO model (including its advantages and disadvantages) will be made. <br><a name="habracut"></a><br>  The article assumes that you are already familiar with the basics of JavaScript, have an idea about functions (including the concepts of closure and first-class functions), primitive values, operators, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  1. Objects </h4><br>  An object in JavaScript is simply a collection of key-value pairs (and sometimes a bit of internal magic). <br><br>  However, there is no class concept in JavaScript.  For example, an object with <b>{name: Linda, age: 21}</b> properties is not an instance of any class or class <b>Object</b> .  Both <b>Object</b> and <b>Linda</b> are instances of themselves.  They are determined directly by their own behavior.  There is no meta-data layer (ie classes) that would tell these objects how to behave. <br><br>  You may ask, ‚ÄúYes, how so?‚Äù, Especially if you come from the world of classical object-oriented languages ‚Äã‚Äã(such as Java or C #).  ‚ÄúBut if each object has its own behavior (instead of inheriting it from a general class), then if I have 100 objects, then they correspond to 100 different methods?‚Äù  Isn't it dangerous?  And how do I know that, for example, an object is really an <b>Array</b> ? ‚Äù <br><br>  To answer all these questions, you need to forget about the classic OO approach and start everything from scratch.  Believe me, it's worth it. <br><br>  The prototype OO model brings several new dynamic and expressive ways to solve old problems.  It also presents powerful models for extending and reusing code (and this is what interests people who are talking about object-oriented programming).  However, this model gives less guarantees.  For example, it cannot be assumed that an object <b>x</b> will always have the same set of properties. <br><br><h5>  1.1.  What are objects? </h5><br>  It was previously mentioned that objects are simply pairs of unique keys with corresponding values ‚Äã‚Äã‚Äî such pairs are called properties.  For example, you want to describe several aspects of your old friend (let's call him Misha, he's <b>Mikhail</b> ), such as age, name and gender: <br><img src="https://habrastorage.org/getpro/habr/post_images/607/55c/717/60755c717c01b8c03d7ad3d4c9004cb2.png"><br>  An object in JavaScript is created using the <b>Object.create</b> function.  This function from the parent and optional property set creates a new entity.  For now, we will not worry about the parameters. <br><br>  An empty object is an object without a parent, without properties.  Let's look at the syntax for creating such an object in JavaScript: <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mikhail = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><br><h5>  1.2.  Creating properties </h5><br>  So, then we already have an object, but it does not have any properties yet - we have to correct this situation to describe our object <b>Mikhail</b> . <br><br>  JavaScript properties are dynamic.  This means that we can create or delete them at any time.  Properties are unique in the sense that the property key inside an object matches exactly one value. <br><br>  Create new properties through the <b>Object.defineProperty</b> function, which uses the object as arguments, the name of the property to create and a descriptor that describes the semantics of the property. <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(mikhail, <span class="hljs-string"><span class="hljs-string">'name'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'Mikhail'</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(mikhail, <span class="hljs-string"><span class="hljs-string">'age'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(mikhail, <span class="hljs-string"><span class="hljs-string">'gender'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'Male'</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre><br>  The <b>Object.defineProperty</b> function creates a new property if a property with a given key did not previously exist (otherwise, the semantics and values ‚Äã‚Äãof the existing property will be updated). <br><br>  By the way, you can also use <b>Object.defineProperties</b> when you need to add more than one property to an object: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(mikhail, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'Mikhail'</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } , <span class="hljs-attr"><span class="hljs-attr">age</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } , <span class="hljs-attr"><span class="hljs-attr">gender</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'Male'</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> , <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }})</code> </pre><br>  Obviously, both calls are similar, they are completely configurable, but not intended for the end user of the code.  It is better to create a level of abstraction over them. <br><br><h5>  1.3.  Descriptors </h5><br>  Small objects that contain semantics are called descriptors (we used them when calling <b>Object.defineProperty</b> ).  Descriptors are one of two types - data descriptors and access descriptors. <br><br>  Both types of descriptors contain flags that define how the property will be considered by the language.  If the flag is not set, then its default value is <b>false</b> (unfortunately this is not always a good default value, which leads to an increase in the amount of descriptor descriptions). <br><br>  Consider some flags: <br><ul><li>  <b>writable</b> - the property value can be changed, used only for data descriptors. </li><li>  <b>configurable</b> - the property type can be changed or the property can be deleted. </li><li>  <b>enumerable</b> - the property is used in the general enumeration. <br>  Data descriptors are such that they define a specific value that corresponds to an additional <b>value</b> parameter that describes the specific data associated with the property: </li><li>  <b>value</b> - the value of the property </li></ul><br><br>  Access descriptors define access to a specific value through getters and setters of functions.  If not set, then defaults to <b>undefined</b> . <br><ul><li>  <b>get ()</b> - the function is called without arguments when a request is made to the property value. </li><li>  <b>set (new_value)</b> - the function is called with an argument - a new value for the property when the user tries </li></ul><br>  modify the value of the property. <br><br><h5>  1.4.  Strive for conciseness </h5><br>  Fortunately, property descriptors are not the only way to work with properties in JavaScript ‚Äî you can create them more succinctly. <br><br>  JavaScript also understands property references using a so-called bracket entry.  The basic rule is written as follows: <br><pre> <code class="javascript hljs">&lt;bracket-access&gt; ::= &lt;identifier&gt; "[" &lt;expression&gt; "]"</code> </pre><br>  Here <b>identifier</b> is a variable that stores an object containing a property whose value we want to set, and <b>expression</b> is any valid JavaScript expression that defines the name of the property.  There are no restrictions on what name a property can have; everything is allowed. <br><br>  Thus, we can rewrite the previous example: <br><pre> <code class="javascript hljs">mikhail[<span class="hljs-string"><span class="hljs-string">'name'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Mikhail'</span></span> mikhail[<span class="hljs-string"><span class="hljs-string">'age'</span></span>] = <span class="hljs-number"><span class="hljs-number">19</span></span> mikhail[<span class="hljs-string"><span class="hljs-string">'gender'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Male'</span></span></code> </pre><br>  Note: all property names are ultimately converted to a string, i.e.  the <b>object [1]</b> , <b>object [[1]]</b> , <b>object ['1'],</b> and <b>object [variable]</b> records (where the <b>variable</b> value is 1) are equivalent. <br><br>  There is another way to refer to a property called a point entry.  It looks simpler and more concise than the bracket alternative.  However, with this method, the property name must comply with the rules of a <a href="http://es5.github.com/">valid JavaScript identifier</a> and cannot be represented by an expression (that is, variables cannot be used). <br><br>  The general rule for point recording is: <br><pre> <code class="javascript hljs">&lt;dot-access&gt; ::= &lt;identifier&gt; "." &lt;identifier-name&gt;</code> </pre><br>  Thus, the previous example has become even more beautiful: <br><pre> <code class="javascript hljs">mikhail.name = <span class="hljs-string"><span class="hljs-string">'Mikhail'</span></span> mikhail.age = <span class="hljs-number"><span class="hljs-number">19</span></span> mikhail.gender = <span class="hljs-string"><span class="hljs-string">'Male'</span></span></code> </pre><br>  Both syntaxes perform the equivalent process of creating properties, setting semantic flags to <b>true</b> . <br><br><h5>  1.5.  Access to properties </h5><br>  It is very easy to get the value stored in a given property - the syntax is very similar to creating a property with the only difference being that there is no assignment in it. <br>  For example, if we want to know the age of Misha, then we will write: <br><pre> <code class="javascript hljs">mikhail[<span class="hljs-string"><span class="hljs-string">'age'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// =&gt; 19</span></span></code> </pre><br>  But if we try to get the value of a property that does not exist in our object, we will get <b>undefined</b> : <br><pre> <code class="javascript hljs">mikhail[<span class="hljs-string"><span class="hljs-string">'address'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// =&gt; undefined</span></span></code> </pre><br><br><h5>  1.6.  Removing properties </h5><br>  To delete a property from an object, a <b>delete</b> operator is provided in JavaSCript.  For example, if you want to remove the <b>gender</b> property from our <b>mikhail</b> object: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> mikhail[<span class="hljs-string"><span class="hljs-string">'gender'</span></span>] <span class="hljs-comment"><span class="hljs-comment">// =&gt; true mikhail['gender'] // =&gt; undefined</span></span></code> </pre><br>  The <b>delete</b> operator will return <b>true</b> if the property has been deleted, and <b>false</b> otherwise.  We will not delve into how this operator works.  But if you're still interested, then you can read the <a href="http://perfectionkills.com/understanding-delete/">most beautiful article on how delete works</a> . <br><br><h5>  1.6.  Getters and setters </h5><br>  Getters and setters are commonly used in classical object-oriented languages ‚Äã‚Äãto provide encapsulation.  They are not really needed in JavaScript, but, we have a dynamic language, and <s>I am against this functionality</s> . <br><br>  But, from any point of view, they allow you to provide proxies for read and write requests for properties.  For example, we had separate slots for a name and a surname, but we want to have a convenient way to read and install them. <br><br>  To begin with, we will create the name and surname of our friend, describing the corresponding properties: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(mikhail, <span class="hljs-string"><span class="hljs-string">'first_name'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'Mikhail'</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }) <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(mikhail, <span class="hljs-string"><span class="hljs-string">'last_name'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'Wei√ü'</span></span> , <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })</code> </pre><br>  Then we describe the general way of getting and setting two properties at once at once - let's call their union <b>name</b> : <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// () ‚Üí String // Returns the full name of object. function get_full_name() { return this.first_name + ' ' + this.last_name } // (new_name:String) ‚Üí undefined // Sets the name components of the object, from a full name. function set_full_name(new_name) { var names names = new_name.trim().split(/\s+/) this.first_name = names[‚Å£'0'] || '' this.last_name = names['1'] || '' } Object.defineProperty(mikhail, 'name', { get: get_full_name , set: set_full_name , configurable: true , enumerable: true })</span></span></code> </pre><br>  Now, every time we try to find out the value of our friend‚Äôs <b>name</b> property, the get_full_name function will actually be <b>called</b> : <br><pre> <code class="javascript hljs">mikhail.name <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Mikhail Wei√ü' mikhail.first_name // =&gt; 'Mikhail' mikhail.last_name // =&gt; 'Wei√ü' mikhail.last_name = 'White' mikhail.name // =&gt; 'Mikhail White'</span></span></code> </pre><br>  We can also set the <b>name of the</b> object by accessing the corresponding property, but in fact the call to <b>set_full_name</b> will do all the dirty work: <br><pre> <code class="javascript hljs">mikhail.name = <span class="hljs-string"><span class="hljs-string">'Michael White'</span></span> mikhail.name <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Michael White' mikhail.first_name // =&gt; 'Michael' mikhail.last_name // =&gt; 'White'</span></span></code> </pre><br>  There are scenarios in which it is really convenient to do this, but it is worth remembering that such a mechanism works <a href="http://jsperf.com/getter-setter/8">very slowly</a> . <br>  In addition, it should be noted that getters and setters are usually used in other languages ‚Äã‚Äãfor encapsulation, and in ECMAScript 5 you still cannot do this ‚Äî all properties of the object are public. <br><br><h5>  1.8.  Enumeration of properties </h5><br>  Due to the fact that the properties are dynamic, JavaScript provides functionality for checking the set of object properties.  There are two ways to list all the properties of an object, depending on what kind of properties you are interested in. <br><br>  The first way is to call the <b>Object.getOwnPropertyNames</b> function, which will return an <b>Array</b> containing the names of all the properties set for this object ‚Äî we will call these properties <i>our own</i> .  For example, let's see what we know about Misha: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(mikhail) <span class="hljs-comment"><span class="hljs-comment">// =&gt; [ 'name', 'age', 'gender', 'first_name', 'last_name' ]</span></span></code> </pre><br>  The second way is to use <b>Object.keys</b> , which returns a list of its own properties, which are marked with the <b>enumerable</b> flag: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(mikhail) <span class="hljs-comment"><span class="hljs-comment">// =&gt; [ 'name', 'age', 'gender' ]</span></span></code> </pre><br><br><h5>  1.9.  Literals </h5><br>  A simple way to create an object is to use the literal syntax of JavaScript.  A literal object defines a new object, the parent of which is an <b>Object.prototype</b> (we'll talk about parents a little later). <br><br>  In any case, the syntax of literal objects allows you to define simple objects and initialize their properties.  Let's rewrite the example of creating the <b>Mikhail</b> object: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mikhail = { <span class="hljs-attr"><span class="hljs-attr">first_name</span></span>: <span class="hljs-string"><span class="hljs-string">'Mikhail'</span></span> , <span class="hljs-attr"><span class="hljs-attr">last_name</span></span>: <span class="hljs-string"><span class="hljs-string">'Wei√ü'</span></span> , <span class="hljs-attr"><span class="hljs-attr">age</span></span>: <span class="hljs-number"><span class="hljs-number">19</span></span> , <span class="hljs-attr"><span class="hljs-attr">gender</span></span>: <span class="hljs-string"><span class="hljs-string">'Male'</span></span> <span class="hljs-comment"><span class="hljs-comment">// () ‚Üí String // Returns the full name of object. , get name() { return this.first_name + ' ' + this.last_name } // (new_name:String) ‚Üí undefined // Sets the name components of the object, // from a full name. , set name(new_name) { var names names = new_name.trim().split(/\s+/) this.first_name = names['0'] || '' this.last_name = names['1'] || '' } }</span></span></code> </pre><br><br>  Invalid property names can be enclosed in quotes.  Note that the entry for getter / setter is defined literally by anonymous functions.  If you want to associate a previously declared function with getter / setter, then you must use the <b>Object.defineProperty</b> method. <br><br>  Let's look at the general rules of literal syntax: <br><pre> <code class="javascript hljs">&lt;object-literal&gt; ::= <span class="hljs-string"><span class="hljs-string">"{"</span></span> &lt;property-list&gt; <span class="hljs-string"><span class="hljs-string">"}"</span></span> ; &lt;property-list&gt; ::= &lt;property&gt; ["," &lt;property&gt;]* ; &lt;property&gt; ::= &lt;data-property&gt; | &lt;getter-property&gt; | &lt;setter-property&gt; ; &lt;data-property&gt; ::= &lt;property-name&gt; ":" &lt;expression&gt; ; &lt;getter-property&gt; ::= "get" &lt;identifier&gt; : &lt;function-parameters&gt; : &lt;function-block&gt; ; &lt;setter-property&gt; ::= "set" &lt;identifier&gt; : &lt;function-parameters&gt; : &lt;function-block&gt; ; &lt;property-name&gt; ::= &lt;identifier&gt; | &lt;quoted-identifier&gt; ;</code> </pre><br>  Literal objects can appear inside expressions in javascript.  Due to some ambiguity, newbies are sometimes confused: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// This is a block statement, with a label: { foo: 'bar' } // =&gt; 'bar' // This is a syntax error (labels can't be quoted): { "foo": 'bar' } // =&gt; SyntaxError: Invalid label // This is an object literal (note the parenthesis to force // parsing the contents as an expression): ({ "foo": 'bar' }) // =&gt; { foo: 'bar' } // Where the parser is already expecting expressions, // object literals don't need to be forced. Eg: var x = { foo: 'bar' } fn({foo: 'bar'}) return { foo: 'bar' } 1, { foo:</span></span></code> </pre><br><br><h4>  2. Methods </h4><br>  Until now, the <b>Mikhail</b> object had only data storage slots (well, except for getter / setter for the <b>name</b> property).  The description of actions that can be done with an object is done in JavaScript very simply.  Simple - because in JavaScript there is no difference between manipulating things like <b>Function</b> , <b>Number</b> , <b>Object</b> .  Everything is done in the same way (do not forget that functions in JavaScript are first-class entities). <br><br>  We describe the action on this object by simply setting the function as the value of our property.  For example, we want Misha to greet other people: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// (person:String) ‚Üí String // Greets a random person mikhail.greet = function(person) { return this.name + ': Why, hello there, ' + person + '.' }</span></span></code> </pre><br>  After setting the property value, we can use a similar method to set specific data associated with the object.  Thus, access to properties will return a reference to the function stored in it, which we can call: <br><pre> <code class="javascript hljs">mikhail.greet(<span class="hljs-string"><span class="hljs-string">'you'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Michael White: Why, hello there, you.' mikhail.greet('Kristin') // =&gt; 'Michael White: Why, hello there, Kristin.'</span></span></code> </pre><br><br><h5>  2.1.  Dynamic <b>this</b> </h5><br>  One thing to consider when describing the <b>greet</b> function is that this function should refer to the getter / setter of the <b>name</b> property, and for this it uses the magic variable <b>this</b> . <br><br>  It stores a reference to the object to which the executing function belongs.  This does not necessarily mean that <b>this is</b> always equal to the object in which the function <i>is stored</i> .  No, JavaScript is not so selfish. <br><br>  Functions are <a href="http://en.wikipedia.org/wiki/Generic_function">generic</a> .  Those.  in javascript, the variable <b>this</b> defines a dynamic reference that is resolved when the function is executed. <br><br>  This dynamic resolution process provides an incredibly powerful mechanism for dynamizing JavaScript's object-oriented nature and compensates for the lack of strict correspondence to specified structures (that is, classes).  This means that you can apply a function to any object that meets the launch requirements, regardless of how the object is structured (as in <a href="http://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a> ). <br><br><h5>  2.2.  Permission <b>this</b> </h5><br>  There are four different ways to allow <b>this</b> in a function, depending on how the function is called: directly, as a method, explicitly applied as a constructor.  We will look at the first three, and will return to the designers later. <br><br>  For the following examples, you will take: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Returns the sum of the object's value with the given Number function add(other, yet_another) { return this.value + other + (yet_another || 0) } var one = { value: 1, add: add } var two = { value: 2, add: add }</span></span></code> </pre><br><br><h6>  2.2.1 Call as a method </h6><br>  If the function is called as an object method, then <b>this</b> inside the function refers to the object itself.  Those.  when we explicitly specify which object performs the action, the object will be the value of <b>this</b> in our function. <br><br>  This will happen when we call <b>mikhail.greet ()</b> .  This entry tells the javascript that we want to apply the <b>greet</b> action to the <b>mikhail</b> object. <br><pre> <code class="javascript hljs">one.add(two.value) <span class="hljs-comment"><span class="hljs-comment">// this === one // =&gt; 3 two.add(3) // this === two // =&gt; 5 one['add'](two.value) // brackets are cool too // =&gt; 3</span></span></code> </pre><br><br><h6>  2.2.2 Direct Call </h6><br>  When the function is called directly, <b>this is</b> resolved to the global engine object ( <b>window</b> in browser, <b>global</b> in Node.js) <br><pre> <code class="javascript hljs">add(two.value) <span class="hljs-comment"><span class="hljs-comment">// this === global // =&gt; NaN // The global object still has no `value' property, let's fix that. value = 2 add(two.value) // this === global // =&gt; 4</span></span></code> </pre><br><br><h6>  2.2.3.  Explicit application </h6><br>  Finally, the function can be explicitly applied to any object, regardless of whether the object has a corresponding property or not.  This functionality is achieved using <b>call</b> or <b>apply</b> methods. <br><br>  The difference between the two methods lies in the parameters passed to the function and the execution time ‚Äî <b>apply</b> works about 55 times slower than an immediate call, but <b>call is</b> usually not particularly worse.  Everything depends on the current engine, so use <a href="http://jsperf.com/">Perf test</a> to be sure - do not optimize the code ahead of time. <br><br>  In any case, <b>call</b> expects an object as the first parameter of the function, followed by the usual arguments of the original function: <br><pre> <code class="javascript hljs">add.call(two, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// this === two // =&gt; 6 add.call(window, 4) // this === global // =&gt; 6 add.call(one, one.value) // this === one // =&gt; 2</span></span></code> </pre><br>  On the other hand, <b>apply</b> allows the second parameter to describe an array of parameters of the original function: <br><pre> <code class="javascript hljs">add.apply(two, [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) <span class="hljs-comment"><span class="hljs-comment">// equivalent to two.add(2, 2) // =&gt; 6 add.apply(window, [ 4 ]) // equivalent to add(4) // =&gt; 6 add.apply(one, [one.value]) // equivalent to one.add(one.value) // =&gt; 2</span></span></code> </pre><br>  On a note.  Note that the resolution of <b>this</b> in <b>null</b> or <b>undefined</b> depends on the semantics of the engine used.  The result is usually the same as applying a function to a global object.  But if the engine runs in <a href="https://developer.mozilla.org/en/JavaScript/Strict_mode">strict mode</a> , then <b>this</b> will be allowed as expected - exactly to the thing to which it is applied: <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.value = <span class="hljs-number"><span class="hljs-number">2</span></span> add.call(<span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// this === window // =&gt; 3 void function() { "use strict" add.call(undefined, 1) // this === undefined // =&gt; NaN // Since primitives can't hold properties. }()</span></span></code> </pre><br><br><h5>  2.3.  Method binding </h5><br>  Let us distract from the dynamic essence of functions in JavaScript, go along the path of creating functions, associating them with certain objects, so that <b>this</b> inside a function always points to this object, whether it is called as an object method or directly. <br><br>  The function provides the functionality called <b>bind</b> : the object is taken and an additional parameter (very similar to the call <b>call</b> ) and a new function is returned, which will apply the parameters to the original function when calling: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> one_add = add.bind(one) one_add(<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// this === one // =&gt; 3 two.one_adder = one_add two.one_adder(2) // this === one // =&gt; 3 one_add.call(two) // this === one // =&gt; 3</span></span></code> </pre><br><br><h4>  3. Inheritance </h4><br>  So far, we have seen how objects can define their behavior and how we can use their actions on other objects, but, we still have not seen the normal way to reuse code and its extensibility. <br><br>  This is where inheritance comes in handy.  It will allow separating tasks in which objects define specialized behavior from creating common behavior for other objects. <br><br>  The prototyping model goes further.  Although it supports technologies such as ‚Äúselective extensibility‚Äù and ‚Äúbehavior sharing‚Äù, we will not particularly study them.  The sad thing: the specific prototype OO models implemented in JavaScript are somewhat limited.  We can bypass these restrictions, but the overhead will be great. <br><br><h5>  3.1.  Prototypes </h5><br>  Inheritance in JavaScript is done through cloning the behavior of an object and expanding it with specialized behavior.  An object whose behavior is cloned is called a <i>prototype</i> . <br><br>  A prototype is an ordinary object that shares its behavior with other objects ‚Äî in this case, it acts as a parent. <br><br>  The concept of cloning behavior does not mean that you will have two different copies of the same function or data.  In fact, JavaScript implements inheritance through delegation, i.e.  All properties are stored in the parent, and access to them is extended through the child. <br><br>  As mentioned earlier, the parent (or <b>[[Prototype]]</b> ) of an object is determined by calling <b>Object.create</b> with the first argument referring to the parent object. <br><br>  Let's go back to the example of Misha.  We single out his name and the ability to greet people in a separate object that will share his behavior with Misha.  Here is how our model will look like: <br><img src="https://habrastorage.org/getpro/habr/post_images/89b/265/696/89b265696f2aa9f88e22d8f09642ebca.png"><br>  We implement it in javascript: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(<span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Here we are reusing the previous getter/setter functions Object.defineProperty(person, 'name', { get: get_full_name , set: set_full_name , configurable: true , enumerable: true }) // And adding the `greet' function person.greet = function (person) { return this.name + ': Why, hello there, ' + person + '.' } // Then we can share those behaviours with Mikhail // By creating a new object that has it's [[Prototype]] property // pointing to `person'. var mikhail = Object.create(person) mikhail.first_name = 'Mikhail' mikhail.last_name = 'Wei√ü' mikhail.age = 19 mikhail.gender = 'Male' // And we can test whether things are actually working. // First, `name' should be looked on `person' mikhail.name // =&gt; 'Mikhail Wei√ü' // Setting `name' should trigger the setter mikhail.name = 'Michael White' // Such that `first_name' and `last_name' now reflect the // previously name setting. mikhail.first_name // =&gt; 'Michael' mikhail.last_name // =&gt; 'White' // `greet' is also inherited from `person'. mikhail.greet('you') // =&gt; 'Michael White: Why, hello there, you.' // And just to be sure, we can check which properties actually // belong to `mikhail' Object.keys(mikhail) // =&gt; [ 'first_name', 'last_name', 'age', 'gender' ]</span></span></code> </pre><br><br><h5>  3.2 But how does <b>[‚Å£ [Prototype] ‚Å£]</b> work? </h5><br>  As you saw in the last example, we did not explicitly define any of the properties defined in <b>Person</b> explicitly in <b>Mikhail</b> , but we were still able to access them.  This is due to the fact that JavaScript implements the delegation of access to properties, i.e.  property is searched through all parents of the object. <br><br>  This chain of parents is defined by a hidden slot in each object, which is called <b>[‚Å£ [Prototype]]</b> .  You cannot change it directly, there is only one way to set a value for it - when creating a new object. <br><br>  When a property is requested from an object, the engine first tries to get the property from the target object.  If the property is not found, then the immediate parent of the object is considered, then the parent of the parent, etc. <br><br>  This means that we can change the behavior of the prototype in the middle of the program, then the behavior of all objects that were inherited from it will automatically change.  For example, suppose we want to change the default greeting: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// (person:String) ‚Üí String // Greets the given person person.greet = function(person) { return this.name + ': Harro, ' + person + '.' } mikhail.greet('you') // =&gt; 'Michael White: Harro, you.'</span></span></code> </pre><br><br><h5>  3.3.  Property overload </h5><br>  So, prototyping (i.e., inheritance) is used so that you can share data with other objects.  Moreover, this method works quickly and is economical with respect to memory, since  we always have only one instance of the data used. <br><br>        ,        ?           ,      ‚Äî      . <br><br>    ,  <b>Person</b>    ,    <b>Person</b>     .       ,      : <br><img src="https://habrastorage.org/getpro/habr/post_images/05c/d21/55c/05cd2155cf15cca2842289e9e7d60df9.png"><br><br> ,   <b>mikhail</b> ,  <b>kristin</b>     <b>greet</b> .       <b>greet</b>     ,     <b>greet</b> ,   <b>Person</b> : <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Here we set up the greeting for a generic person // (person:String) ‚Üí String // Greets the given person, formally person.greet = function(person) { return this.name + ': Hello, ' + (person || 'you') } // And a greeting for our protagonist, Mikhail // (person:String) ‚Üí String // Greets the given person, like a bro mikhail.greet = function(person) { return this.name + ': \'sup, ' + (person || 'dude') } // And define our new protagonist, Kristin var kristin = Object.create(person) kristin.first_name = 'Kristin' kristin.last_name = 'Wei√ü' kristin.age = 19 kristin.gender = 'Female' // Alongside with her specific greeting manners // (person:String) ‚Üí String // Greets the given person, sweetly kristin.greet = function(person) { return this.name + ': \'ello, ' + (person || 'sweetie') } // Finally, we test if everything works according to the expected mikhail.greet(kristin.first_name) // =&gt; 'Michael White: \'sup, Kristin' mikhail.greet() // =&gt; 'Michael White: \'sup, dude' kristin.greet(mikhail.first_name) // =&gt; 'Kristin Wei√ü: \'ello, Michael' // And just so we check how cool this [[Prototype]] thing is, // let's get Kristin back to the generic behaviour delete kristin.greet // =&gt; true kristin.greet(mikhail.first_name) // =&gt; 'Kristin Wei√ü: Hello, Michael'</span></span></code> </pre><br><br>  <i>To be continued...</i> </div><p>Source: <a href="https://habr.com/ru/post/153365/">https://habr.com/ru/post/153365/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../153349/index.html">NIST made the decision: SHA-3 will use the Keccak algorithm</a></li>
<li><a href="../153351/index.html">User agreements: the rules have changed, and now it will be SO!</a></li>
<li><a href="../153357/index.html">Master-key for Onity locks on the Arduino in the usual marker</a></li>
<li><a href="../153359/index.html">Code Inspection. Results</a></li>
<li><a href="../153361/index.html">Android firmware on personal experience</a></li>
<li><a href="../153369/index.html">Report from the presentation of Samsung GALAXY Note II</a></li>
<li><a href="../153373/index.html">Books that a Java programmer should read: from beginner to professional</a></li>
<li><a href="../153375/index.html">"Java-Oscar" has found its new owner</a></li>
<li><a href="../153377/index.html">Catalog of services for searching contacts of customers and performers on free-lance.ru</a></li>
<li><a href="../153379/index.html">Interview with astrophysicist Neil Tyson</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>