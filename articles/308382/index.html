<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Trello Clone on Phoenix and React. Parts 8-9</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of Contents (current material is highlighted) 

1. Introduction and selection of technology stack 
2. Initial setup of the Phoenix Framework pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Trello Clone on Phoenix and React. Parts 8-9</h1><div class="post__text post__text-html js-mediator-article"><p> <a href="https://habrahabr.ru/post/308382/"><img src="https://habrastorage.org/files/86e/e8d/293/86ee8d2930024c60a834695276f5de15.jpg"></a> </p><br><div class="spoiler">  <b class="spoiler_title">Table of Contents (current material is highlighted)</b> <div class="spoiler_text"><ol><li>  <a href="https://habrahabr.ru/post/308056/">Introduction and selection of technology stack</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">Initial setup of the Phoenix Framework project</a> </li><li>  <a href="https://habrahabr.ru/post/308056/">User Model and JWT Authentication</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Front-end for registration on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308100/">Initial database population and controller to enter the application</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">Front-end authentication on React and Redux</a> </li><li>  <a href="https://habrahabr.ru/post/308248/">We configure sockets and channels</a> </li><li>  <strong>We display the list and create new boards</strong> </li><li>  <strong>Add new board users</strong> </li><li>  <a href="https://habrahabr.ru/post/316108/">We trace the connected users of boards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">Add lists and cards</a> </li><li>  <a href="https://habrahabr.ru/post/316108/">We spread the project on Heroku</a> </li></ol></div></div><br><a name="8"></a><br><h2 id="vyvodim-spisok-i-sozdayom-novye-doski">  We display the list and create new boards </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-8">Original</a> </p><br><p>  At the moment, we have implemented all the important aspects of user registration and authentication management, as well as connecting to a socket and entering channels, so we are ready to go to the next level and allow the user to list and create their own boards. </p><a name="habracut"></a><br><p>  <em>Particularly long listings hidden under spoiler - approx.</em>  <em>translator</em> </p><br><h3 id="migraciya-dlya-modeli-dosok">  Migration for the board model </h3><br><p>  First we need to create a migration and a model.  To do this, simply run: </p><br><pre><code class="hljs pgsql">$ mix phoenix.gen.model Board boards user_id:<span class="hljs-keyword"><span class="hljs-keyword">references</span></span>:users <span class="hljs-type"><span class="hljs-type">name</span></span>:string</code> </pre> <br><p>  This will create a new migration file that looks like: </p><br><pre> <code class="hljs pgsql"># priv/repo/migrations/<span class="hljs-number"><span class="hljs-number">20151224093233</span></span>_create_board.exs defmodule PhoenixTrello.Repo.Migrations.CreateBoard <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Ecto.Migration def change <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:boards) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :<span class="hljs-type"><span class="hljs-type">name</span></span>, :string, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :user_id, <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>(:users, on_delete: :delete_all), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(:boards, [:user_id]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The new table under the name of <code>boards</code> will receive, in addition to the <code>id</code> and <code>timestamps</code> fields ( <em>in fact, the latter is a macro for creating a pair of <code>inserted_at</code> and <code>created_at</code> fields with a type similar to the corresponding <code>created_at</code> type in the base</em> ), the <code>name</code> field and the foreign key to the table <code>users</code> .  Please note that we rely on the database to clear the list of boards related to the user in case of deletion.  An index is also added to the migration file to speed up the <code>user_id</code> field and a <code>null</code> limit for the <code>name</code> field. </p><br><p>  Having completed the modification of the migration file, you need to run: </p><br><pre> <code class="hljs ruby">$ mix ecto.migrate</code> </pre> <br><h3 id="model-board">  Model Board </h3><br><p>  Take a look at the model <code>board</code> : </p><br><pre> <code class="hljs pgsql"># web/models/board.ex defmodule PhoenixTrello.Board <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> __MODULE__ @derive {Poison.Encoder, <span class="hljs-keyword"><span class="hljs-keyword">only</span></span>: [:id, :<span class="hljs-type"><span class="hljs-type">name</span></span>, :<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>]} <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "boards" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> field :<span class="hljs-type"><span class="hljs-type">name</span></span>, :string belongs_to :<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @required_fields ~w(<span class="hljs-type"><span class="hljs-type">name</span></span> user_id) @optional_fields ~w() @doc """ Creates a changeset based on the `model` and `params`. If no params are provided, an invalid changeset is returned with no validation performed. """ def changeset(model, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model |&gt; cast(params, @required_fields, @optional_fields)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">translator</b> <div class="spoiler_text"><p>  <em>I remind every fireman that models are now being generated a little differently, so I recommend making edits to the generated model, rather than copying the code one-on-one.</em> </p></div></div><br><p>  While there is something worth mentioning, there is a need to update the <code>User</code> model to add a link to your own boards: </p><br><pre> <code class="hljs vbscript"># web/models/user.ex defmodule PhoenixTrello.User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model # ... schema <span class="hljs-string"><span class="hljs-string">"users"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... has_many :owned_boards, PhoenixTrello.Board # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Why exactly <code>owned_boards</code> (own boards)?  To distinguish user-made boards from boards to which it has been added by other users;  but let's not worry about it yet, we will dive deeper into this question later. </p><br><h3 id="kontroller-boardcontroller">  BoardController Controller </h3><br><p>  So, to create new boards, you will need to update the route file in order to add the corresponding entry for processing requests: </p><br><pre> <code class="hljs lua"># web/router.ex defmodule PhoenixTrello.Router <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :router # ... scope <span class="hljs-string"><span class="hljs-string">"/api"</span></span>, PhoenixTrello <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... scope <span class="hljs-string"><span class="hljs-string">"/v1"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... resources <span class="hljs-string"><span class="hljs-string">"boards"</span></span>, BoardController, only: [:index, :<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  We added resource <code>boards</code> , limiting the action handlers to the list from <code>:index</code> and <code>:create</code> , so the <code>BoardController</code> will serve the following requests: </p><br><pre> <code class="hljs pgsql">$ mix phoenix.routes board_path <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> /api/v1/boards PhoenixTrello.BoardController :<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> board_path POST /api/v1/boards PhoenixTrello.BoardController :<span class="hljs-keyword"><span class="hljs-keyword">create</span></span></code> </pre> <br><p>  Create a new controller: </p><br><div class="spoiler">  <b class="spoiler_title">web / controllers / board_controller.ex</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"># web/controllers/board_controller.ex defmodule PhoenixTrello.BoardController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :controller plug Guardian.Plug.EnsureAuthenticated, <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>: PhoenixTrello.SessionController <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{Repo, Board} def <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(conn, _params) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">current_user</span></span> = Guardian.Plug.current_resource(conn) owned_boards = <span class="hljs-built_in"><span class="hljs-built_in">current_user</span></span> |&gt; assoc(:owned_boards) |&gt; Board.preload_all |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">all</span></span> render(conn, "index.json", owned_boards: owned_boards) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(conn, %{"board" =&gt; board_params}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">current_user</span></span> = Guardian.Plug.current_resource(conn) changeset = <span class="hljs-built_in"><span class="hljs-built_in">current_user</span></span> |&gt; build_assoc(:owned_boards) |&gt; Board.changeset(board_params) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Repo.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(changeset) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, board} -&gt; conn |&gt; put_status(:created) |&gt; render("show.json", board: board ) {:error, changeset} -&gt; conn |&gt; put_status(:unprocessable_entity) |&gt; render("error.json", changeset: changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Note that we are adding a plug <code>EnsureAuthenticated</code> from <strong>Guardian</strong> , so that only authenticated connections will be allowed in this controller.  In the <code>index</code> handler, we retrieve the current user data from the connection and query the database for a list of the boards belonging to it in order to be able to display them using <code>BoardView</code> .  In the <code>create</code> handler, almost the same thing happens: we create the changeset of the <code>owned_board</code> using the data of the current user, and add it to the database, displaying <code>board</code> as an answer if everything went as expected. </p><br><p>  Create <code>BoardsView</code> : </p><br><pre> <code class="hljs pgsql"># web/views/board_view.ex defmodule PhoenixTrello.BoardView <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :<span class="hljs-keyword"><span class="hljs-keyword">view</span></span> def render("index.json", %{owned_boards: owned_boards}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> %{owned_boards: owned_boards} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def render("show.json", %{board: board}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> def render("error.json", %{changeset: changeset}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> errors = Enum.map(changeset.errors, fn {field, detail} -&gt; %{} |&gt; Map.put(field, detail) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) %{ errors: errors } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h3 id="komponent-predstavleniya-view-react">  View component (view) React </h3><br><p>  Now that the back-end is ready to process requests for getting a list of boards, as well as creating them, it's time to focus on the front-end.  After authenticating the user and logging in to the application, the first thing we want is to show a list of his boards and a form for adding a new one, so let's create a <code>HomeIndexView</code> : </p><br><div class="spoiler">  <b class="spoiler_title">HomeIndexView</b> <div class="spoiler_text"><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ web/static</span></span><span class="hljs-regexp"><span class="hljs-regexp">/js/views</span></span><span class="hljs-regexp"><span class="hljs-regexp">/home/index</span></span>.js import React from <span class="hljs-string"><span class="hljs-string">'react'</span></span>; import { connect } from <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; import classnames from <span class="hljs-string"><span class="hljs-string">'classnames'</span></span>; import { setDocumentTitle } from <span class="hljs-string"><span class="hljs-string">'../../utils'</span></span>; import Actions from <span class="hljs-string"><span class="hljs-string">'../../actions/boards'</span></span>; import BoardCard from <span class="hljs-string"><span class="hljs-string">'../../components/boards/card'</span></span>; import BoardForm from <span class="hljs-string"><span class="hljs-string">'../../components/boards/form'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeIndexView</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">componentDidMount</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setDocumentTitle</span></span></span><span class="hljs-class">('</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Boards</span></span></span><span class="hljs-class">');</span></span> const { dispatch } = this.props; dispatch(Actions.fetchBoards()); } _renderOwnedBoards() { const { fetching } = this.props; let content = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; const iconClasses = classnames({ <span class="hljs-symbol"><span class="hljs-symbol">fa:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">'fa-user'</span></span>: !fetching, <span class="hljs-string"><span class="hljs-string">'fa-spinner'</span></span>: fetching, <span class="hljs-string"><span class="hljs-string">'fa-spin'</span></span>: fetching, }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!fetching) { content = ( &lt;div className=<span class="hljs-string"><span class="hljs-string">"boards-wrapper"</span></span>&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:this</span></span>._renderBoards(this.props.ownedBoards)} {<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:this</span></span>._renderAddNewBoard()} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ); } return ( &lt;section&gt; &lt;header className="view-header"&gt; &lt;h3&gt;&lt;i className={iconClasses} /</span></span>&gt; My boards&lt;<span class="hljs-regexp"><span class="hljs-regexp">/h3&gt; &lt;/header</span></span>&gt; {content} &lt;<span class="hljs-regexp"><span class="hljs-regexp">/section&gt; ); } _renderBoards(boards) { return boards.map((board) =&gt; { return &lt;BoardCard key={board.id} dispatch={this.props.dispatch} {...board} /</span></span>&gt;; }); } _renderAddNewBoard() { let { showForm, dispatch, formErrors } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!showForm) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this._renderAddButton(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;BoardForm dispatch={dispatch} errors={formErrors} onCancelClick={<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:this</span></span>._handleCancelClick}/&gt; ); } _renderAddButton() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className=<span class="hljs-string"><span class="hljs-string">"board add-new"</span></span> onClick={<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:this</span></span>._handleAddNewClick}&gt; &lt;div className=<span class="hljs-string"><span class="hljs-string">"inner"</span></span>&gt; &lt;a id=<span class="hljs-string"><span class="hljs-string">"add_new_board"</span></span>&gt;Add new board...&lt;<span class="hljs-regexp"><span class="hljs-regexp">/a&gt; &lt;/div</span></span>&gt; &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ); } _handleAddNewClick() { let { dispatch } = this.props; dispatch(Actions.showForm(true)); } _handleCancelClick() { this.props.dispatch(Actions.showForm(false)); } render() { return ( &lt;div className="view-container boards index"&gt; {::this._renderOwnedBoards()} &lt;/div</span></span>&gt; ); } } const mapStateToProps = (state) =&gt; ( state.boards ); export default connect(mapStateToProps)(HomeIndexView);</code> </pre> </div></div><br><p>  There is a lot going on here, so let's take it in order: </p><br><ul><li>  To begin with, remember that this component is connected to the storage (store) and in case of changes it will receive its parameters ( <code>props</code> ) using the converter <code>boards</code> , which we will soon create. </li><li>  When connected, the component changes the title of the document to the <em>Boards</em> and asks the action constructor to get a list of boards from the back-end. </li><li>  So far, only the display of the <code>owned_boards</code> array, as well as the <code>BoardForm</code> component, will <code>BoardForm</code> . </li><li>  Before displaying these two elements, it will be checked whether the <code>fetching</code> property is set to <em>true</em> .  If so, it will mean that the list is still being downloaded, so that the download indicator appears.  Otherwise a list of boards and a button to add a new one will be shown </li><li>  When you click the <em>Add new</em> button, a <em>new</em> action constructor will be requested to hide this button and display the form. </li></ul><br><p>  Now add the <code>BoardForm</code> component: </p><br><div class="spoiler">  <b class="spoiler_title">Boardform</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// web/static/js/components/boards/form.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { PropTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PageClick <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-page-click'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/boards'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {renderErrorsFor} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../utils'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> BoardForm extends React.Component { componentDidMount() { this.refs.name.focus(); } _handleSubmit(e) { e.preventDefault(); const { dispatch } = this.props; const { <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.refs; const data = { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, }; dispatch(Actions.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(data)); } _handleCancelClick(e) { e.preventDefault(); this.props.onCancelClick(); } render() { const { errors } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;PageClick onClick={::this._handleCancelClick}&gt; &lt;div className="board form"&gt; &lt;div className="inner"&gt; &lt;h4&gt;<span class="hljs-built_in"><span class="hljs-built_in">New</span></span> board&lt;/h4&gt; &lt;form id="new_board_form" onSubmit={::this._handleSubmit}&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="name" id="board_name" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="text" placeholder="Board name" required="true"/&gt; {renderErrorsFor(errors, <span class="hljs-string"><span class="hljs-string">'name'</span></span>)} &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit"&gt;<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span> board&lt;/button&gt; <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> &lt;a href="#" onClick={::this._handleCancelClick}&gt;cancel&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/PageClick&gt; ); } }</code> </pre> </div></div><br><p>  This component is extremely simple.  It displays the form and when sending it requests the action constructor to create a new board with the provided name.  <code>PageClick</code> is an <a href="https://github.com/nkbt/react-page-click">external component</a> that I found that tracks clicks on a page outside the container element.  In our case, we will use it to hide the form and again show the <em>Add new</em> button. </p><br><h3 id="konstruktory-deystviya">  Action constructors </h3><br><div class="spoiler">  <b class="spoiler_title">action creators</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// web/static/js/actions/boards.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { routeActions } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-router-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { httpGet, httpPost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../utils'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CurrentBoardActions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./current_board'</span></span>; const Actions = { fetchBoards: () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.BOARDS_FETCHING }); httpGet(<span class="hljs-string"><span class="hljs-string">'/api/v1/boards'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>((data) =&gt; { dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.BOARDS_RECEIVED, ownedBoards: data.owned_boards }); }); }; }, showForm: (<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.BOARDS_SHOW_FORM, <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>, }); }; }, <span class="hljs-keyword"><span class="hljs-keyword">create</span></span>: (data) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { httpPost(<span class="hljs-string"><span class="hljs-string">'/api/v1/boards'</span></span>, { board: data }) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>((data) =&gt; { dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.BOARDS_NEW_BOARD_CREATED, board: data, }); dispatch(routeActions.push(`/boards/${data.id}`)); }) .catch((error) =&gt; { error.response.json() .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>((<span class="hljs-type"><span class="hljs-type">json</span></span>) =&gt; { dispatch({ <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: Constants.BOARDS_CREATE_ERROR, errors: <span class="hljs-type"><span class="hljs-type">json</span></span>.errors, }); }); }); }; }, }; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Actions;</code> </pre> </div></div><br><ul><li>  <code>fetchBoards</code> : for starters, it will issue an action of type <code>BOARDS_FETCHING</code> , which the previously mentioned load indicator will display.  I will also send an http request to the back-end to get a list of the boards owned by the user, which will be processed using <code>BoardController:index</code> .  When a response is received, the boards will be redirected to the repository. </li><li>  <code>showForm</code> : this constructor is very simple and will set the <code>BOARDS_SHOW_FORM</code> action to show whether we want to display the form or not. </li><li>  <code>create</code> : send a <code>POST</code> request to create a new board.  If the result is positive, it will send the <code>BOARDS_NEW_BOARD_CREATED</code> action along with the data on the created board, so that it will be added to the boards in the repository, and then displaying the contents of the board will redirect the user along the appropriate route.  In case of any errors, an action will be sent to <code>BOARDS_CREATE_ERROR</code> . </li></ul><br><h3 id="preobrazovatel">  Converter </h3><br><p>  The last piece of the puzzle will be a very simple converter: </p><br><div class="spoiler">  <b class="spoiler_title">web / static / js / reducers / boards.js</b> <div class="spoiler_text"><pre> <code class="hljs bash">// web/static/js/reducers/boards.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { ownedBoards: [], showForm: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, formErrors: null, fetching: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> default <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reducer(state = initialState, action = {}) { switch (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Constants.BOARDS_FETCHING: <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> { ...state, fetching: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Constants.BOARDS_RECEIVED: <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> { ...state, ownedBoards: action.ownedBoards, fetching: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Constants.BOARDS_SHOW_FORM: <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> { ...state, showForm: action.show }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Constants.BOARDS_CREATE_ERROR: <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> { ...state, formErrors: action.errors }; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Constants.BOARDS_NEW_BOARD_CREATED: const { ownedBoards } = state; <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> { ...state, ownedBoards: [action.board].concat(ownedBoards) }; default: <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> state; } }</code> </pre> </div></div><br><p>  Note that when the boards are finished loading, we set the <code>fetching</code> attribute to <em>false</em> , as well as how we merge ( <code>concat</code> ) the new board created with the existing ones. </p><br><p>  Enough work for today!  In the next part, we will build a view to display the contents of the board and add functionality to add new participants to the board, to send board data to its associated users, so that it appears in the list of boards that you have been invited to join;  this list is also to be created. </p><br><a name="9"></a><br><h2 id="dobavlyaem-novyy-polzovateley-dosok">  Add new board users </h2><br><p>  <a href="https://blog.diacode.com/trello-clone-with-phoenix-and-react-pt-9">Original</a> </p><br><p>  In the previous section, we created a table for storing boards, a model <code>Board</code> and generated a controller responsible for enumerating and creating new boards for authenticated users.  We also programmed the front-end, so that the existing boards and the form for adding a new board can be shown.  Let me remind you, not what we stopped: after receiving confirmation from the controller after creating a new board, we want to redirect the user to her presentation so that he can see all the details and add existing users as participants.  Let's do it! </p><br><h3 id="komponent-predstavleniya-react">  React presentation component </h3><br><p>  Before continuing, take a look at the <strong>React</strong> routes: </p><br><pre> <code class="hljs xml">// web/static/js/routes/index.js import { IndexRoute, Route } from 'react-router'; import React from 'react'; import MainLayout from '../layouts/main'; import AuthenticatedContainer from '../containers/authenticated';; import BoardsShowView from '../views/boards/show'; // ... export default ( <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">component</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{MainLayout}</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">component</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{AuthenticatedContainer}</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IndexRoute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">component</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{HomeIndexView}</span></span></span><span class="hljs-tag"> /&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/boards/:id"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">component</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{BoardsShowView}/</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Route</span></span></span><span class="hljs-tag">&gt;</span></span> );</code> </pre> <br><p>  The route <code>/boards/:id</code> will be processed by the <code>BoardsShowView</code> component to create: </p><br><div class="spoiler">  <b class="spoiler_title">BoardsShowView</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// web/static/js/views/boards/<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {PropTypes} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-redux'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/current_board'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { setDocumentTitle } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../utils'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BoardMembers <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../components/boards/members'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> BoardsShowView extends React.Component { componentDidMount() { const { socket } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!socket) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } this.props.dispatch(Actions.connectToChannel(socket, this.props.params.id)); } componentWillUnmount() { this.props.dispatch(Actions.leaveChannel(this.props.currentBoard.channel)); } _renderMembers() { const { connectedUsers, showUsersForm, channel, error } = this.props.currentBoard; const { dispatch } = this.props; const members = this.props.currentBoard.members; const currentUserIsOwner = this.props.currentBoard.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.id === this.props.currentUser.id; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;BoardMembers dispatch={dispatch} channel={channel} currentUserIsOwner={currentUserIsOwner} members={members} connectedUsers={connectedUsers} error={error} <span class="hljs-keyword"><span class="hljs-keyword">show</span></span>={showUsersForm} /&gt; ); } render() { const { fetching, <span class="hljs-type"><span class="hljs-type">name</span></span> } = this.props.currentBoard; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fetching) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="view-container boards show"&gt; &lt;i className="fa fa-spinner fa-spin"/&gt; &lt;/div&gt; ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="view-container boards show"&gt; &lt;<span class="hljs-keyword"><span class="hljs-keyword">header</span></span> className="view-header"&gt; &lt;h3&gt;{<span class="hljs-type"><span class="hljs-type">name</span></span>}&lt;/h3&gt; {::this._renderMembers()} &lt;/<span class="hljs-keyword"><span class="hljs-keyword">header</span></span>&gt; &lt;div className="canvas-wrapper"&gt; &lt;div className="canvas"&gt; &lt;div className="lists-wrapper"&gt; {::this._renderAddNewList()} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } } const mapStateToProps = (state) =&gt; ({ currentBoard: state.currentBoard, socket: state.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.socket, currentUser: state.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.currentUser, }); export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(mapStateToProps)(BoardsShowView);</code> </pre> </div></div><br><p>  When connected, the component will connect to the board channel using the custom socket we created in <a href="https://habrahabr.ru/post/308248/">Part 7</a> .  When displayed, it first checks whether the <code>fetching</code> attribute is set to <code>true</code> , and if the data is still being downloaded, the loading indicator will be shown.  As we can see, it receives its parameters from the <code>currentBoard</code> element stored in the state, which is created by the following converter. </p><br><h3 id="preobrazovatel-i-konstruktory-deystviy">  Transducer and action constructors </h3><br><p>  As a starting point of the current board state, we need to store only the <code>board</code> , channel and <code>fetching</code> data: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web/static/js/reducers/current_board.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Constants <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const initialState = { channel: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, fetching: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> function reducer(state = initialState, action = {}) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { case Constants.CURRENT_BOARD_FETHING: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, fetching: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; case Constants.BOARDS_SET_CURRENT_BOARD: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, fetching: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, ...action.board }; case Constants.CURRENT_BOARD_CONNECTED_TO_CHANNEL: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, channel: action.channel }; default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br><p>  Let's take a look at the <code>current_board</code> action constructor to check how to connect to the channel and process all the required data: </p><br><pre> <code class="hljs bash">// web/static/js/actions/current_board.js import Constants from <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; const Actions = { connectToChannel: (socket, boardId) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> dispatch =&gt; { const channel = socket.channel(`boards:<span class="hljs-variable"><span class="hljs-variable">${boardId}</span></span>`); dispatch({ <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Constants.CURRENT_BOARD_FETHING }); channel.join().receive(<span class="hljs-string"><span class="hljs-string">'ok'</span></span>, (response) =&gt; { dispatch({ <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Constants.BOARDS_SET_CURRENT_BOARD, board: response.board, }); dispatch({ <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Constants.CURRENT_BOARD_CONNECTED_TO_CHANNEL, channel: channel, }); }); }; }, // ... }; <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> default Actions;</code> </pre> <br><p>  Just like with <code>UserChannel</code> , we use a socket to create and connect to a new channel, defined as <code>boards:${boardId}</code> , and receive as a response the presentation of the board as <strong>JSON</strong> , which will be sent to the repository along with the <code>BOARDS_SET_CURRENT_BOARD</code> action.  From this point on, the constructor will be connected to the channel, receiving all changes made on the board by any participant, automatically displaying these changes on the screen thanks to <strong>React</strong> and <strong>Redux</strong> .  But first you need to create a <code>BoardChannel</code> . </p><br><h3 id="boardchannel">  Board channel </h3><br><p>  Although almost all the remaining functionality will be implemented in this module, we are currently implementing a very simple version of it: </p><br><pre> <code class="hljs pgsql"># web/channels/board_channel.ex defmodule PhoenixTrello.BoardChannel <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :channel <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.Board def <span class="hljs-keyword"><span class="hljs-keyword">join</span></span>("boards:" &lt;&gt; board_id, _params, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board = get_current_board(socket, board_id) {:ok, %{board: board}, assign(socket, :board, board)} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> defp get_current_board(socket, board_id) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> socket.assigns.<span class="hljs-built_in"><span class="hljs-built_in">current_user</span></span> |&gt; assoc(:boards) |&gt; Repo.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(board_id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  The <code>join</code> method gets the current board associated with the user assigned to the socket, returns it and assigns it to the socket, with the result that it will be available for further messages ( <em>without additional queries to the database - comment of the translator</em> ). </p><br><img src="https://habrastorage.org/files/4ad/c60/5c9/4adc605c98eb431e99a7f9b78e9257f9.jpg"><br><p><br></p><br><h3 id="uchastniki-doski">  Board members </h3><br><p>  Once the board is shown to the user, the next step is to allow him to add existing users as participants so that they can work on it together.  To link the board to other users, we need to create a new table to hold this relationship.  Switch to the console and run: </p><br><pre> <code class="hljs pgsql">$ mix phoenix.gen.model UserBoard user_boards user_id:<span class="hljs-keyword"><span class="hljs-keyword">references</span></span>:users board_id:<span class="hljs-keyword"><span class="hljs-keyword">references</span></span>:boards</code> </pre> <br><p>  You need to slightly update the resulting migration file: </p><br><pre> <code class="hljs pgsql"># priv/repo/migrations/<span class="hljs-number"><span class="hljs-number">20151230081546</span></span>_create_user_board.exs defmodule PhoenixTrello.Repo.Migrations.CreateUserBoard <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Ecto.Migration def change <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span>(:user_boards) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :user_id, <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>(:users, on_delete: :delete_all), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> :board_id, <span class="hljs-keyword"><span class="hljs-keyword">references</span></span>(:boards, on_delete: :delete_all), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(:user_boards, [:user_id]) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>(:user_boards, [:board_id]) <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> unique_index(:user_boards, [:user_id, :board_id]) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  In addition to the <code>null</code> restrictions, we will add a unique index for <code>user_id</code> and <code>board_id</code> , so <code>User</code> cannot be added to the same <code>Board</code> twice.  After running <code>mix ecto.migrate</code> let's move on to the <code>UserBoard</code> model: </p><br><pre> <code class="hljs pgsql"># web/models/user_board.ex defmodule PhoenixTrello.UserBoard <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> PhoenixTrello.{<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, Board} <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> "user_boards" <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> belongs_to :<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> belongs_to :board, Board timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> @required_fields ~w(user_id board_id) @optional_fields ~w() def changeset(model, params \\ :empty) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> model |&gt; cast(params, @required_fields, @optional_fields) |&gt; unique_constraint(:user_id, <span class="hljs-type"><span class="hljs-type">name</span></span>: :user_boards_user_id_board_id_index) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  There is nothing unusual here, but you also need to add a new relationship to the <code>User</code> model: </p><br><pre> <code class="hljs vbscript"># web/models/user.ex defmodule PhoenixTrello.User <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :model # ... schema <span class="hljs-string"><span class="hljs-string">"users"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... has_many :user_boards, UserBoard has_many :boards, through: [:user_boards, :board] # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  We have two more relationships, but the most important one is <code>:boards</code> , which we will use to control access.  Also add to the <code>Board</code> model: </p><br><pre> <code class="hljs vbscript"># web/models/board.ex defmodule PhoenixTrello.Board <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... schema <span class="hljs-string"><span class="hljs-string">"boards"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... has_many :user_boards, UserBoard has_many :members, through: [:user_boards, :user] timestamps <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Now, thanks to these changes, we can distinguish the boards created by the user and the boards to which he was invited.  This is very important, because in the board view we want to show the form for adding participants only to its creator.  In addition, we want to automatically add the creator as a member in order to show it by default, so we will make small changes to the <code>BoardController</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Boardcontroller</b> <div class="spoiler_text"><pre> <code class="hljs lua"># web/controllers/api/v1/board_controller.ex defmodule PhoenixTrello.BoardController <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use PhoenixTrello.Web, :controller #... def <span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(conn, %{<span class="hljs-string"><span class="hljs-string">"board"</span></span> =&gt; board_params}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> current_user = Guardian.Plug.current_resource(conn) changeset = current_user |&gt; build_assoc(:owned_boards) |&gt; Board.changeset(board_params) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> changeset.valid? <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board = Repo.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>!(changeset) board |&gt; build_assoc(:user_boards) |&gt; UserBoard.changeset(%{user_id: current_user.id}) |&gt; Repo.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>! conn |&gt; put_status(:created) |&gt; render(<span class="hljs-string"><span class="hljs-string">"show.json"</span></span>, board: board ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> conn |&gt; put_status(:unprocessable_entity) |&gt; render(<span class="hljs-string"><span class="hljs-string">"error.json"</span></span>, changeset: changeset) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  Note how we create the <code>UserBoard</code> union and add it after checking for correctness. </p><br><h3 id="komponent-uchastnikov-doski">  Component board members </h3><br><p>  This component will show the avatars of all participants and the form for adding a new participant: </p><br><img src="https://habrastorage.org/files/074/0aa/f2f/0740aaf2f30c4c258d489bfefcb5adc2.jpg"><br><p><br>  As you can see, thanks to the previous changes in <code>BoardController</code> , the owner is now shown as the only member.  Let's see how this component will look like: </p><br><div class="spoiler">  <b class="spoiler_title">Component board members</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// web/static/js/components/boards/members.js <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {PropTypes} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactGravatar <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-gravatar'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> classnames <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'classnames'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> PageClick <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-page-click'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Actions <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../actions/current_board'</span></span>; export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> BoardMembers extends React.Component { _renderUsers() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.props.members.map((member) =&gt; { const <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = this.props.connectedUsers.findIndex((cu) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cu === member.id; }); const classes = classnames({ connected: <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> != <span class="hljs-number"><span class="hljs-number">-1</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;li className={classes} key={member.id}&gt; &lt;ReactGravatar className="react-gravatar" email={member.email} https/&gt; &lt;/li&gt; ); }); } _renderAddNewUser() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!this.props.currentUserIsOwner) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;li&gt; &lt;a onClick={::this._handleAddNewClick} className="add-new" href="#"&gt;&lt;i className="fa fa-plus"/&gt;&lt;/a&gt; {::this._renderForm()} &lt;/li&gt; ); } _renderForm() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!this.props.<span class="hljs-keyword"><span class="hljs-keyword">show</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;PageClick onClick={::this._handleCancelClick}&gt; &lt;ul className="drop-down active"&gt; &lt;li&gt; &lt;form onSubmit={::this._handleSubmit}&gt; &lt;h4&gt;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> members&lt;/h4&gt; {::this._renderError()} &lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span>="email" <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="email" required={<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} placeholder="Member email"/&gt; &lt;button <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>="submit"&gt;<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> member&lt;/button&gt; <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> &lt;a onClick={::this._handleCancelClick} href="#"&gt;cancel&lt;/a&gt; &lt;/form&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/PageClick&gt; ); } _renderError() { const { error } = this.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;div className="error"&gt; {error} &lt;/div&gt; ); } _handleAddNewClick(e) { e.preventDefault(); this.props.dispatch(Actions.showMembersForm(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)); } _handleCancelClick(e) { e.preventDefault(); this.props.dispatch(Actions.showMembersForm(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)); } _handleSubmit(e) { e.preventDefault(); const { email } = this.refs; const { dispatch, channel } = this.props; dispatch(Actions.addNewMember(channel, email.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;ul className="board-users"&gt; {::this._renderUsers()} {::this._renderAddNewUser()} &lt;/ul&gt; ); } }</code> </pre> </div></div><br><p>  In essence, we will iterate through the <code>members</code> parameter, displaying their avatars.  The component will also show the <em>Add new</em> button if the current user is the owner of the board.  Clicking this button will show the form requesting the participant's e-mail and when sending the form, the calling action constructor <code>addNewMember</code> . </p><br><h3 id="konstruktor-deystviya-addnewmember">  Action constructor addNewMember </h3><br><p>  From now on, instead of using the controller to create and retrieve the data necessary for our <strong>React</strong> front-end, we will transfer the responsibility for this to <code>BoardChannel</code> , so that any changes will be sent to each connected user.  Not forgetting this, we add the required action constructors: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web<span class="hljs-regexp"><span class="hljs-regexp">/static/js/actions/current_board.js import Constants from '../constants'; const Actions = { /</span></span>/ ... showMembersForm: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(show)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { dispatch({ type: Constants.CURRENT_BOARD_SHOW_MEMBERS_FORM, show: show, }); }; }, addNewMember: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(channel, email)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { channel.push(<span class="hljs-string"><span class="hljs-string">'members:add'</span></span>, { email: email }) .receive(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ type: Constants.CURRENT_BOARD_ADD_MEMBER_ERROR, error: data.error, }); }); }; }, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Actions;</code> </pre> <br><p> <code>showMembersForm</code>      ,   .  ,        e-mail,  .   http-,      ,    <code>channel</code>  <code>"members:add"</code>  e-mail   .      ,    .      ?     ,     . </p><br><h3 id="boardchannel-1"> BoardChannel </h3><br><p>  ,      <code>BoardChannel</code> : </p><br><pre> <code class="hljs vbscript"># web/channels/board_channel.ex defmodule PhoenixTrello.BoardChannel <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> # ... def handle_in(<span class="hljs-string"><span class="hljs-string">"members:add"</span></span>, %{<span class="hljs-string"><span class="hljs-string">"email"</span></span> =&gt; email}, socket) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> try <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> board = socket.assigns.board user = User |&gt; Repo.get_by(email: email) changeset = user |&gt; build_assoc(:user_boards) |&gt; UserBoard.changeset(%{board_id: board.id}) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Repo.insert(changeset) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {:ok, _board_user} -&gt; broadcast! socket, <span class="hljs-string"><span class="hljs-string">"member:added"</span></span>, %{user: user} PhoenixTrello.Endpoint.broadcast_from! self(), <span class="hljs-string"><span class="hljs-string">"users:#{user.id}"</span></span>, <span class="hljs-string"><span class="hljs-string">"boards:add"</span></span>, %{board: board} {:noreply, socket} {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, _changeset} -&gt; {:reply, {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: <span class="hljs-string"><span class="hljs-string">"Error adding new member"</span></span>}}, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> catch _, _-&gt; {:reply, {:<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, %{<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>: <span class="hljs-string"><span class="hljs-string">"User does not exist"</span></span>}}, socket} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> # ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  <strong>Phoenix</strong>       <code>handle_in</code>      ,   <strong>Elixir</strong> .       <code>members:add</code> ,      email,     .      ,  e-mail      <code>UserBoard</code>    .    ,      ( <code>broadcast</code> )  <code>member:added</code> ,    .     : </p><br><pre> <code class="hljs ruby">PhoenixTrello.Endpoint.broadcast_from! <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>(), <span class="hljs-string"><span class="hljs-string">"users:</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{user.id}</span></span></span><span class="hljs-string">"</span></span>, <span class="hljs-string"><span class="hljs-string">"boards:add"</span></span>, <span class="hljs-string"><span class="hljs-string">%{board: board}</span></span></code> </pre> <br><p>       <code>boards:add</code>      <code>UserChannel</code>  ,         ,    .  ,           ,          . </p><br><div class="spoiler">  <b class="spoiler_title">Note</b>  <b class="spoiler_title">translator</b> <div class="spoiler_text"><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I have noticed in various sources, sometimes people have a misunderstanding of the differences between different options for sending messages and returning results to the channel. </font><font style="vertical-align: inherit;">I will try to describe in general each of the possibilities.</font></font></em> </p><br><p> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When sending from any channel function:</font></font></em> </p><br><ul><li> <em>        <code>{:reply, :ok, socket}</code> , <code>{:reply, {:ok, message}, socket}</code>  <code>{:reply, {:error, message}, socket}</code> ,  <code>message</code> ‚Äî    ,      ( ).             ,   ,            callback -  ;</em> </li><li> <em><code>push(socket, event, message)</code> ,  <code>event</code> ‚Äî     :       (                   .     front-end    <code>channel.on(...)</code> );</em> </li><li> <em><code>broadcast(socket, event, message)</code> :    ,    ;</em> </li><li> <em><code>broadcast_from(socket, event, message)</code> :  ,   <strong></strong>     </em> . </li></ul><br><p> <em>    (,  ):</em> </p><br><ul><li> <em><code>AppName.Endpoint.broadcast(topic, event, message)</code> ,  <code>topic</code> ‚Äî  :    ,     (       (,  , ),    ,   )</em> </li></ul><br><p> <em> ,  <code>push</code> ,   ""      .      -     ,   ""   "",     <code>try do ... end</code> ,       (      Elixir,  <strong></strong>  ,    ).</em> </p></div></div><br><p>    front-end  <code>member:added</code>    <code>channel</code>   ,      : </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> web<span class="hljs-regexp"><span class="hljs-regexp">/static/js/actions/current_board.js import Constants from '../constants'; const Actions = { /</span></span>/ ... connectToChannel: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket, boardId)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatch =&gt; { const channel = socket.channel(`<span class="javascript"><span class="javascript">boards:${boardId}</span></span>`); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... channel.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'member:added'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg)</span></span></span><span class="hljs-function"> =&gt;</span></span> { dispatch({ type: Constants.CURRENT_BOARD_MEMBER_ADDED, user: msg.user, }); }); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... } }, }; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> Actions;</code> </pre> <br><p>          <code>boards:add</code> ,   : </p><br><pre> <code class="hljs lua">// web/static/js/actions/sessions.js export <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setCurrentUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dispatch, user)</span></span></span></span> { channel.on(<span class="hljs-string"><span class="hljs-string">'boards:add'</span></span>, (msg) =&gt; { // ... dispatch({ <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: Constants.BOARDS_ADDED, board: msg.board, }); }); };</code> </pre> <br><p> ,   ,    ,        (state) : </p><br><pre> <code class="hljs lua">// web/static/js/reducers/current_board.js export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = initialState, action = {})</span></span></span></span> { // ... case Constants.CURRENT_BOARD_MEMBER_ADDED: const { members } = state; members.push(action.user); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, members: members, showUsersForm: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; } // ... }</code> </pre> <br><pre> <code class="hljs lua">// web/static/js/reducers/boards.js export default <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reducer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state = initialState, action = {})</span></span></span></span> { // ... switch (action.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>) { case Constants.BOARDS_ADDED: const { invitedBoards } = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...state, invitedBoards: [action.board].<span class="hljs-built_in"><span class="hljs-built_in">concat</span></span>(invitedBoards) }; } // ... }</code> </pre> <br><p>       ,               . </p><br><img src="https://habrastorage.org/files/3e4/f09/096/3e4f090964204d388fdd00f5a2310da2.jpg"><br><p><br>       <code>BoardMembers</code> , <code>className</code>    ,   id     <code>connectedUsers</code> .    id         .             (longtime running stateful process) <strong>Elixir</strong> ,      . </p><br><p>        <a href="https://phoenix-trello.herokuapp.com/"> </a>  <a href="https://github.com/bigardone/phoenix-trello"> </a>  . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/308382/">https://habr.com/ru/post/308382/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308372/index.html">We saw monolith</a></li>
<li><a href="../308374/index.html">Is Typescript worth the effort?</a></li>
<li><a href="../308376/index.html">Books on typography: everything you need to know about the art of fonts</a></li>
<li><a href="../308378/index.html">5 UI chips for modern Android applications. Code, ideas and a live example</a></li>
<li><a href="../308380/index.html">Laravel 5.3 release released</a></li>
<li><a href="../308386/index.html">7 helpful morning habits of psychologically enduring people</a></li>
<li><a href="../308388/index.html">How to keep healthy relationships by being a developer</a></li>
<li><a href="../308392/index.html">Back to basics or a step forward? HPE StoreVirtual VSA</a></li>
<li><a href="../308394/index.html">Programs become more important than iron</a></li>
<li><a href="../308398/index.html">How we wrote a chat for the application of the bank "Opening"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>