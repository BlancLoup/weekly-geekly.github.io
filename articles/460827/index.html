<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PGP problem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Crypto engineers have been shouting about PGP shortcomings for decades . When ordinary developers hear this, they are extremely surprised. How, PGP is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PGP problem</h1><div class="post__text post__text-html js-mediator-article">  Crypto engineers have <a href="https://blog.cryptographyengineering.com/2014/08/13/whats-matter-with-pgp/">been shouting about PGP shortcomings for decades</a> .  When ordinary developers hear this, they are extremely surprised.  How, PGP is no good?  Why then advise to use it?  The answer is, PGP is really worthless, and should never be recommended to anyone.  He must disappear. <br><br>  As you will soon see, PGP has a lot of problems.  If you do not go into details, the main reason is that the program was developed in the 90s, before the emergence of serious modern cryptography.  No competent crypto engineer today will develop a system in this form and will not tolerate most of its defects in any other system.  Serious cryptographers basically abandoned PGP and no longer spend time on it (with some <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-poddebniak.pdf">notable exceptions</a> ).  Therefore, the well-known problems in PGP remain unresolved for more than ten years. <br><a name="habracut"></a><br>  Two small notes.  First, the article is written for engineers, not lawyers and activists.  Secondly, ‚ÄúPGP‚Äù can mean a lot of things, from the OpenPGP standard to the reference implementation in GnuPG.  We use the term ‚ÄúPGP‚Äù for all of this. <br><br><h1>  Problems </h1><br><h3>  Absurd complexity </h3><br>  For reasons that no one understands now, PGP is package-based.  The PGP message (in the .asc file) is an archive of typed packages.  There are at least eight different ways to encode the length of a packet, depending on whether you use ‚Äúnew‚Äù or ‚Äúold‚Äù format packets.  Packets of the ‚Äúnew format‚Äù like BER have a variable length (try writing a PGP implementation, and the ASN.1 coding standard will seem sweet to you).  Packages may have subpackages.  Some package options overlap with each other.  The last attack on the key server is due to the fact that due to this irresponsible format, GnuPG key parsing <a href="https://threadreaderapp.com/thread/1147162583969009664.html">accidentally leaves in quadratic time</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And this is just an encoding.  The real system is much more complicated.  There are keys and plug.  Key identifiers, key servers, and key signatures.  Keys are only for signature and only for encryption.  Numerous keychains.  Certificate Revocation.  Three different compression formats.  That we have not yet reached the support of smart cards. <br><br><h3>  Swiss army knife design </h3><br>  If you get lost in the forest and ... I don‚Äôt know, for example, you need to trim the lapels on jeans - yes, it‚Äôs very convenient that you have scissors on your knife.  But for serious work, no one will regularly use such scissors. <br><br>  A Swiss army knife does a ton of things, and everything is bad.  PGP is a very mediocre document signing tool, it encrypts relatively poorly with passwords, and works very poorly with public keys.  PGP is not particularly good for secure file transfers.  This is a clumsy way to sign packages.  It is not very good for protecting backups.  This is an extremely dangerous way to exchange secure messages. <br><br>  Back in the era of MC Hammer, when PGP appeared, ‚Äúencryption‚Äù was a special thing in itself;  there was one tool for sending files, backups, for encrypting and signing files.  Modern cryptography doesn‚Äôt work like that, we need specialized tools.  Cryptography for secure messaging is different from cryptography for backing up or signing packages. <br><br><h3>  Backward compatibility swamp </h3><br>  PGP precedes modern cryptography and is very outdated during this time.  If you're lucky, your GnuPG will by default have a 2048-bit RSA key, a 64-bit CAST5 cipher in CFB and an OpenPGP MDC checksum (about which later).  If encryption is done with a password rather than a public key, the OpenPGP protocol will set the key generation algorithm S2K for PGP.  To put it mildly, these are not the primitives that a crypto engineer will choose for a modern system. <br><br>  We have learned a lot since the <a href="https://en.wikipedia.org/wiki/Steve_Urkel">nerd Steve Urkel</a> decorated the prime time on ABC.  We learned that encrypted texts should be authenticated (and CFB mode should be avoided), that 64-bit block ciphers are bad, that RSA is not perfect, that a combination of compression and encryption is dangerous, and that KDFs must be strictly generated both in time and in memory. <br><br>  No matter what the OpenPGP RFC says, you are probably not doing anything from this list if you are using PGP, and it is impossible to tell when the recommendations will begin to be implemented.  Take AEAD Ciphers: Sequoia PGP in Rust defaulted to AES-EAX AEAD mode.  It's great.  But now no one can read their messages, because most versions of PGP do not know what EAX mode is, and this is not very cool.  In every bad cryptosystem, the end result is an RFC extension that supports elliptic curves or AEAD, so that its supporters can shout in the forums that they support modern cryptography.  RFC does not matter: only real settings.  We invented authenticated encryption 20 years ago, and PGP will soon retire;  enough excuses. <br><br>  Either you have backward compatibility with the program of the 90s, or you have good cryptography;  <i>you cannot get both</i> . <br><br><h3>  Nasty UX </h3><br>  It‚Äôs hard to formulate it better than Ted Unangst: <br><br><blockquote>  A few years ago, a PGP usability study was conducted, in which a group of technical experts was placed in a room with a computer and asked to configure PGP.  Two hours later, none of them had yet responded. </blockquote><br>  If you need your own empirical data to confirm this, here is an experiment you can do: find a lawyer who is far from computers and help him install Signal by phone.  He will probably cope without hysteria.  Now try to do this with PGP. <br><br><h3>  Long-term secrets </h3><br>  PGP asks users to keep the root key tied to their identity almost forever.  Key generation and exchange is cumbersome with these ‚Äúkey signing parties‚Äù and the ‚Äútrust network‚Äù, where the keys depend on other keys. <br><br>  <a href="https://blog.filippo.io/giving-up-on-long-term-pgp/">Long-term keys are almost always uncomfortable</a> .  If you continue to use the key, it eventually becomes public.  From the point of view of a competent system design, it is necessary to minimize damage and ensure that the user will not hesitate for a second when thinking about generating a new key, if there are at least some concerns about the security of the current one. <br><br>  PGP fans will immediately answer: "That's why you need to keep the keys on Yubikey."  But according to a quick rough estimate, almost no one in the world uses expensive Yubikeys, and this is unlikely to change in the future (we can barely deploy U2F, and those keys are disposable).  We cannot accept bad cryptosystems just to make Unix nerds more comfortable playing with their toys. <br><br><h3>  Broken Authentication </h3><br>  More about PGP archaic primitives: back in 2000, the OpenPGP working group realized that it was necessary to authenticate encrypted text and that PGP signatures did not.  Therefore, OpenPGP invented <a href="https://tools.ietf.org/html/rfc4880">the MDC system</a> : PGP messages with MDC attach the plaintext SHA-1 to the plaintext itself, which is then encrypted (as usual) in CFB mode. <br><br>  If you're curious how PGP handles this when modern systems use relatively sophisticated AEAD schemes (because they can't just attach SHA-1 to plaintext), then this is a good question.  How would you describe this cartoon?  PGP MDC can be cleared of messages - it is encoded in such a way that it is quite simple to cut off the last 22 bytes of the ciphertext.  To maintain backward compatibility with unsafe old messages, PGP introduced a new type of package that signals the need for MDC verification.  If you use the wrong type, then MDC is not checked.  Even if you do, the new SEIP packet format is pretty close to the unsafe SE format, which could potentially trick the recipient with a lower cipher;  <a href="https://mailarchive.ietf.org/arch/msg/openpgp/tB00vO5r-qneX9wz1xz3netpXVU">Trevor Perrin has reduced SEIP to just 16 bits of security</a> . <br><br>  Finally, even if everything goes right, the PGP reference implementation will produce unauthenticated plaintext on request, <i>even if the MDC does not match</i> . <br><br><h3>  Inconsistent Identities </h3><br>  PGP is both an application, and a set of integrations with other applications, and a file format, and a social network, and a subculture. <br><br>  PGP puts forward the concept of cryptographic identity.  You create a key, save it in a keychain, print its fingerprint on a business card and publish it on the key server.  You sign someone else's keys.  They, in turn, may or may not rely on your signatures to verify other keys.  Some people try to meet other PGP users in person to exchange keys and more securely register in this ‚Äútrust network‚Äù.  Others organize key signing parties.  If you imagine all this activity, it becomes clear how difficult it is for dedicated PGP fans to switch to new technologies. <br><br>  But this whole system does not work in practice.  Neither a trust network with key signatures, nor key servers, nor parties.  Ordinary people will trust everything that looks like a PGP key, no matter where it came from - how can they not trust, even if it is difficult for an expert to formulate how to evaluate the key?  Experts do not trust keys that they did not personally receive.  Everyone else relies on centralized key distribution services.  PGP key distribution mechanisms are a circus. <br><br><h3>  Metadata leaks </h3><br>  For a second, forget about the email debacle (we'll come back to this later).  PGP itself allows metadata leakage.  In normal use, messages are directly associated with key identifiers that are associated with a user identifier throughout the PGP trust network.  In addition, a fairly large proportion of PGP users use key servers that themselves issue to the network which PGP users exchange messages with each other. <br><br><h3>  No direct secrecy </h3><br>  Case in point: cryptography for secure messaging requires forward secrecy.  Direct secrecy means that if an attacker receives your key, he still will not be able to read previous messages.  In modern cryptography, we assume that the adversary writes everything to infinite storage.  Opponents of PGP include world governments.  Of course, some of them do this.  Against serious opponents, hacking cryptography without direct secrecy is only a matter of time. <br><br>  To ensure direct secrecy in practice, you usually keep two secret keys: a short-term session key and a long-term trusted key.  The session key is ephemeral (usually a DH exchange product), and the trusted key signs it, so that the person in the middle cannot use his own key.  Theoretically, direct secrecy can be realized with PGP tools.  Of course, almost no one does this. <br><br><h3>  Ax keys </h3><br>  The OpenBSD signify public key is a Base64 string short enough to fit in the middle of a sentence in an email;  a private key that is not an exchange format is just a string or so.  And the PGP public key is a gigantic Base64 document;  if you used them often, you are probably already used to sticking them in an attachment rather than pasting them in messages so as not to damage them.  The signify key is generated by the advanced Ed25519 algorithm, and PGP by the weaker RSA. <br><br>  You might think that it does not matter, but it is important;  orders of magnitude more people use SSH and manage SSH keys than PGP.  SSH keys are trivial to process;  PGP - no. <br><br><h3>  Matching </h3><br>  PGP supports ElGamal, RSA, NIST p-curves, Brainpool, Curve25519, SHA-1, SHA-2, RIPEMD160, IDEA, 3DES, CAST5, AES.  This is not a complete list of what PGP supports. <br><br>  If in the last 20 years we have learned three important things about cryptography, at least two of them, it is that reconciliation and compatibility are evil.  As a rule, the shortcomings of cryptosystems appear in implementations, rather than primitives, and expansive cryptocompatibility increases the number of implementations.  Modern protocols, such as TLS 1.3, seek to get rid of backward compatibility with archaisms like RSA, rather than add it.  Newer systems <i>only</i> support <i>one set of primitives</i> and a simple version number.  If one of these primitives fails, you get rid of this version and immediately drop the entire old protocol. <br><br>  If we are not lucky and after 20 years people will still use PGP, it will remain the only reason why the CAST5 standard is applied at least somewhere.  We cannot say this more clearly, and we need to repeat it many times: either you have backward compatibility with the program of the 90s, or you have good cryptography;  you cannot get both. <br><br><h3>  Trash code </h3><br>  The de facto standard implementation of PGP is GnuPG.  This program is not very neatly written.  There is an extensive code base in C - language with duplication of functionality (for example, in the description of a recent denial of service attack on SKS parsing it is said that it has several key parsers) with a long CVE track record, ranging from memory corruption to cryptographic attacks through third-party channels.  Sometimes authentication could be removed from messages, but GnuPG did not notice this.  You could feed him the keys without the correct fingerprint.  In 2018, the Efail vulnerability was caused by the fact that GnuPG provided unauthenticated plaintext upon request.  GnuPG is not good. <br><br>  GnuPG is both a reference implementation for PGP and the foundation for most other PGP cryptography integration tools.  He is not going anywhere.  Relying on PGP means relying on GPG. <br><br><h1>  The answers </h1><br>  To convince a person to give up PGP, it is important to explain to him that PGP has nothing to replace, <i>and this is normal</i> .  An alternative tool depends on the task. <br><br><h3>  Conversations </h3><br>  Use Signal.  Or Wire, or WhatsApp, or some other secure messenger based on the Signal protocol. <br><br>  Modern secure messengers are designed specifically for messaging.  They use confidential authentication handshakes, message cancellations, <i>cryptographic ratchets</i> , which give the key to each message exchange, and, of course, modern encryption primitives.  Messengers are trivially easy to use, no fuss with keys and subkeys.  If you use Signal, you get even more: you get a system so paranoid about saving private metadata from servers that it even tunnels Giphy search queries to avoid traffic analysis attacks, and until recently did not even support user profiles. <br><br><h3>  Email Encryption </h3><br>  Do not do this. <br><br>  <a href="https://news.ycombinator.com/item%3Fid%3D16088386">Email is not secure</a> .  Even with PGP, this is plain text by default, that is, even if you do everything correctly, some completely reasonable recipient of the letter, doing absolutely reasonable things, will necessarily quote the plain text of your encrypted message to someone else in CC (we don‚Äôt know the email user PGP mail, which did not come across this).  There is no direct secrecy in the PGP email.  Email metadata, including the subject (which is literally the content of the message), is always transmitted in clear text. <br><br>  If you need another reason, read the <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-poddebniak.pdf">Efail vulnerability article</a> .  The GnuPG community, which <a href="https://flaked.sockpuppet.org/2018/05/16/a-unified-timeline.html">failed to disclose information about Efail</a> , criticizes this article violently, but it was accepted at Usenix Security (one of the top academic centers for software security), as well as at the Black Hat USA conference (the leading software security conference).  This is one of the best cryptographic attacks in the last five years - and a pretty destructive bomb against the PGP ecosystem.  As you will see from the article, S / MIME is no better. <br><br>  It will never be fixed.  To make really secure email, you have to tunnel another protocol via email (you will still be vulnerable to an attack with traffic analysis).  That's just the point, why pretend? <br><br>  Encrypting email is clicking trouble.  Encouraging users to encrypt email if something threatens them is exceptional negligence.  Anyone who tells you about the security of email communication with PGP encryption puts their strange preferences above your security. <br><br><h3>  Sending files </h3><br>  Use the <a href="https://github.com/warner/magic-wormhole">Magic Wormhole</a> .  Wormhole clients use one-time key authentication with password authentication (PAKE) to encrypt files.  It is easy (at least for nerds), safe and fun: everyone to whom we showed the ‚Äúmole hole‚Äù immediately began to pass through it all the files in a row, as we do. <br><br>  Someone immediately launches the installer for Windows on Rust or Go, this is too cool a program to not use it. <br><br>  If you talk to lawyers, not engineers, Signal does a great job of file transfer.  For error reporting, publish the Signal number, not the PGP key. <br><br><h3>  Backup encryption </h3><br>  Use Tarsnap.  <a href="https://www.tarsnap.com/design.html">Colin will explain how Tarsnap is optimized for protecting backups</a> .  Or really, take any other backup encryption tool;  it won't be as good as Tarsnap, but it will still be better than PGP. <br><br>  Need offline backups?  Use disk image encryption;  it is built into modern versions of Windows, Linux, and macOS.  Full disk encryption is not very good, but it does an excellent job of this task, and it is simpler and safer than PGP. <br><br><h3>  Package signature </h3><br>  Use Signify / Minisign.  <a href="https://www.openbsd.org/papers/bsdcan-signify.html">Ted Unangst will tell you everything</a> .  This tool is used to sign packages in OpenBSD.  It is very simple and applies modern signatures.  Frank Denis <a href="https://jedisct1.github.io/minisign/">Minisign</a> (one of libsodium developers) implements the same design on Windows and macOS;  It has bindings to Go, Rust, Python, Javascript and .NET;  It is even compatible with Signify. <br><br><h3>  Application data encryption </h3><br>  Use <a href="https://github.com/jedisct1/libsodium">libsodium</a> : this is a universal library with an interface in which it is difficult to make a mistake, and you do not need a binary to work. <br><br><h3>  File encryption </h3><br>  This is really a problem.  If you have / not / backup, / not / archive for long-term offline storage, / not / file encryption for transfer and / not / encryption of virtual disks that you mount / unmount as needed, then there is not a good tool to encrypt files.  For other purposes, Filippo Walsorda is developing an <a href="https://docs.google.com/document/d/11yHom20CrsuX8KQJXBBw04s80Unjv8zCg_A7sPAX_9Y/view">age</a> tool, it seems promising, but not yet ready. <br><br>  Hopefully this is a pretty narrow use case.  We work in the field of software security and process confidential data, including error reports (another very common case when they shout ‚ÄúWe need PGP!‚Äù), But almost never use PGP. </div><p>Source: <a href="https://habr.com/ru/post/460827/">https://habr.com/ru/post/460827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460815/index.html">Inventing the vusb library</a></li>
<li><a href="../460819/index.html">WorldSkills: Review from the participant of the Olympiad</a></li>
<li><a href="../460821/index.html">The digest of interesting materials for the mobile developer # 307 (July 15 - 21)</a></li>
<li><a href="../460823/index.html">Digital events in Moscow from July 22 to July 28</a></li>
<li><a href="../460825/index.html">Introduction to Screen Capture API - Scan QR codes in a browser</a></li>
<li><a href="../460831/index.html">The dangers of designers</a></li>
<li><a href="../460833/index.html">Physics and Economics. Gnoseological difference and its manifestation in IT</a></li>
<li><a href="../460837/index.html">Beginner Podcast Handbook</a></li>
<li><a href="../460839/index.html">Releasing Predator - Precompiled Data Repositories</a></li>
<li><a href="../46084/index.html">Zend Framework Tuning + Doctrine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>