<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Remove images from cartridges for Dendy / Famicom / NES</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's no secret that now you can easily download the emulator of almost any 80s-90s game console and play classic games on your computer, phone, and ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Remove images from cartridges for Dendy / Famicom / NES</h1><div class="post__text post__text-html js-mediator-article">  It's no secret that now you can easily download the emulator of almost any 80s-90s game console and play classic games on your computer, phone, and many other platforms.  In the network you can easily find the ROMs of these same games.  Often people shake them and do not even think about how someone once read them from a cartridge.  In this article I will try to tell you how this was done in the case of NES / Famicom, which we had more known as ‚ÄúDandy‚Äù, and show you how to do it yourself. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/096/3f0/4230963f0de564eca88630503b8dc8ec.jpg" alt="image"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I have to say right away that I was persuaded to be filmed on the whole multi-part show on how the game consoles work and work.  Therefore, the publication today in two versions at once: in the form of a video and in the old manner as an article.  Those who like it more, especially the target audience for each option is clearly different.  In the article I will try to reveal more technical details when the video is more entertaining. <br><br><h4>  Video: </h4><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/gPSpk2gbAD4%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700191,15700253&amp;usg=ALkJrhiBTeMnjAdhXhcIuyYY9-E4NQJ6mg" frameborder="0" allowfullscreen=""></iframe><br>  (Link: <a href="http://www.youtube.com/watch%3Fv%3DgPSpk2gbAD4">www.youtube.com/watch?v=gPSpk2gbAD4</a> ) <br><br><h4>  Article: </h4><br>  So, how does the Famicom cartridge work?  Many will immediately say that this is just a ROM-memory with parallel access, and there should be nothing difficult in its reading, but this is not quite so.  First, there are two types of memory in the cartridge: with the code of the game, and with images from the game.  Each of them is included directly on the console data bus.  The first is in parallel with the RAM and the processor (CPU), and the second in parallel with the video memory and video chip (PPU).  Thus, the cartridge is something like RAM, where the game is already loaded. <br><br><h5>  Consider the same pinout slot cartridge, and how it works. </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/1aa/76c/10a/1aa76c10aa403c889fcaccb5cb1c40d6.png" alt="image"><br>  View of the console above.  Left - the front part. <br><br>  <b>‚Üí CPU A0-A14</b> - contacts through which the address is set to read the CPU memory <br>  <b>CPU D0-D7</b> - contacts through which we transfer data to the CPU memory <br>  <b>‚Üí PPU A0-A13</b> - contacts through which the address is set to read the PPU memory <br>  <b>PPU D0-D7</b> - contacts through which we transmit PPU memory data <br>  <b>‚Üí M2</b> - local clock signal, takes a high level when accessing the CPU memory. <br>  <b>‚Üí / ROMSEL</b> - logical NAND between M2 and CPU A15, which is not directly accessible <br>  <b>‚Üí CPU R / W</b> - determines the type of operation: high - read, low - write <br>  <b>‚Üê / IRQ</b> - allows the cartridge to generate an interrupt, inside the console will be pulled to + 5V <br>  <b>‚Üí PPU / RD</b> - takes a low level when the console reads PPU memory <br>  <b>‚Üí PPU / WR</b> - takes a low level when the console writes to PPU memory <br>  <b>‚Üí PPU / A13</b> - simply the inverted signal from PPU A13 <br>  <b>‚Üê CIRAM A10</b> - allows the cartridge to determine the principle of mirroring video memory in the console <br>  <b>‚Üê CIRAM / CE</b> - at low level turns on the video memory inside the console <br>  <b>‚Üí Sound (input)</b> - here comes the sound from the audio chip <br>  <b>‚Üê Sound (input)</b> - here comes a sound from the cartridge in the form in which we already hear it <br>  <b>* Earth and power</b> - no comment, voltage 5 volts <br><br><h6>  Now more, some technical information. </h6><br>  The console's CPU memory lies in the range between <i>0</i> and <i>$ FFFF</i> (16 bits of addressing).  The cartridge usually includes addresses <i>$ 8000- $ FFFF</i> .  Please note that in this case we do not have a <b>CPU A15</b> contact, which must respond to the most significant bit of the address.  Instead, there is <b>/ ROMSEL</b> , which accepts a low level only in the case when <b>M2</b> and theoretical <b>CPU A15</b> simultaneously accept a high level.  Those.  when the console reads or writes to addresses <i>$ 8000- $ FFFF</i> .  Therefore, it can usually be directly connected to the / CE foot of the ROM memory.  Reading or writing are selected through the <b>CPU R / W.</b>  Why do I need to write to the cartridge?  Yes, a lot of why, but more on that below. <br><br>  PPU memory has addresses from <i>0</i> to <i>$ 3FFF</i> (14 bits of addressing), while the cartridge usually refers to <i>0- $ 1FFF</i> .  It is in this range that images are stored, and it can be both ROM and RAM, but the cartridge itself determines which addresses belong to it and which to the inside of the console, this is <b>what CIRAM / CE is used for</b> .  Usually (almost always) it is closed directly to <b>PPU / A13</b> , i.e.  console memory is activated when <b>A13</b> is equal to one - in the range from <i>$ 2000</i> to <i>$ 3FFF</i> .  Please note that inside Famicom and NES memory below <i>$ 2000</i> and not at all, it must be in the cartridge.  PPU uses separate pins for reading and writing: <b>PPU / RD</b> and <b>PPU / WR</b> .  Separately, it should be said about the <b>CIRAM A10</b> - this contact determines how the memory is mirrored in the range between <i>$ 2000</i> and <i>$ 2FFF</i> inside the console.  This is usually important to determine depending on how the game moves vertically or horizontally.  In older games, this was hard set with a jumper on the board, in newer ones it can usually be changed programmatically during the game. <br><br>  Yes, in the original Famikome there were also audio input and audio output, which allowed the cartridge to be an additional source of sound.  It was rarely used, but it made music in games much nicer due to additional sound synthesizers.  The NES did not have these contacts.  In modern Chinese "Dandy" and other clones, they also do not solder.  Of course, the sound chip from the cartridge can not be dumped. <br><br>  At NES, the principle of operation does not differ, although there are already 72 contacts in the cartridges: several go directly to the socket at the bottom of the console (never used in any game), plus four go to the chip for protection against piracy. <br><br><h5>  Let's go to practice. </h5><br>  So, it seems there is nothing particularly complicated.  You just need to somehow read all the data for all the addresses and save them in the NES file.  For this, I decided to take two ATMEGA64 microcontrollers.  Yes, it is very redundant, but I just need a huge number of legs - the cartridge still has 60 of them. Although the CPU and PPU memory do not need to be read simultaneously, and they could be connected to the same legs, but for the first experiment I decided to isolate them.  Moreover, it is much easier to make a fee, I did not want to do two-sided. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71f/a1e/272/71fa1e272ba904b3ed3ab8d99f90ab0a.png" alt="image"><br><br>  You can buy a slot for cartridges, this is a standard edge connector for 60 legs, but for some reason it was everywhere only under the order, so I just dropped it from the cheap new-made dandy. <br><br>  After assembling and printing the case, the device turned out like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5e/7ad/e51/e5e7ade51f0293c35c9573eb79278e81.jpg" alt="image"><br><br>  I will not go into the details of the firmware, the principles of working with memory have already been outlined above, and the sources will be at the end of the article. <br><br>  Is everything so simple?  Alas, not really.  The life span of NES and Famicom was quite long, and game developers very quickly (already in the 85th year) were faced with the fact that with this approach very little information could be crammed into the cartridge.  And not at all because of its small size, but because the address space for the code was limited to these same $ 8000- $ FFFF, and this is only 32 kilobytes.  Only the simplest games like Battle City, Ice Climber, Duck Hunt, Tetris, Lode Runner fit into this size.  Simply put, all that we used to see on collections of the type "9999999 in 1" with repetitive games. <br><br>  So mappers started to put in cartridges. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f68/f37/0a3/f68f370a37d010e8d714df35cba4ab4e.jpg" alt="image"><br><br>  These are the microcircuits that are responsible for switching memory banks, as a result of which it became possible to significantly expand the address space.  Imagine that the code for the first level of the game is stored at some address.  You pass it, the mapper switches the memory bank, and as a result, the code of not the first level, but of the second level, is read at the very same address.  Similarly with video memory. <br><br>  It turns out that in order to dump a cartridge, you need to know in advance what the mapper is in it, and what commands you need to send it to switch memory banks.  And all this would still be easy if all the cartridges had the same mapper, or if there were only a few of them.  But there are hundreds of different mappers and ways to connect them.  Sometimes they got along with a simple logic circuit, and sometimes they put on very sophisticated chips with a bunch of registers and additional functions.  It was not uncommon that they took some popular mapper, but connected it in an unusual way, which radically changed the principles of interaction with it. <br><br>  The pioneers had to dump the first memory bank, disassemble it and engage in reverse engineering in order to understand how to access the rest of the data.  At the same time, the generally accepted number of the mapper is indicated in the header of the NES-file, and a full-fledged emulator must emulate not only the console itself, but also the entire zoo of iron that was put into cartridges.  It turns out that theoretically there may be a cartridge that is not only difficult to dump, but which will not be emulated by any existing emulator.  You don‚Äôt need to go far: inside the popular pirated multi-game cartridges that are just not worth it.  And the Chinese are still releasing new games on their own hardware, which has become even harder to figure out. <br><br>  By the way, in the cartridges that just was not.  In addition to ROM-memory and mappers, additional RAM was installed there (sometimes with a battery to be able to remain in the game), all sorts of time counters, sound synthesizers described above and much more up to the modem.  Alas, in our country in the ninetieth license cartridges it was not possible to find fire during the day, and the pirates did not bother much, and games with such bells and whistles were not sold here. <br><br>  I decided to implement at least reading games on the most popular mappers.  I write the client part to the dumper in C #, so I just described the IMapper interface and the class that corresponds to each mapper: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ca/0de/ee9/5ca0deee9b93c3d4794febe7df30119f.png" alt="image"><br><br>  Each implemented methods for dumping data.  Here is how the MMC3 mapper program memory reading method looks: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DumpPrg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FamicomDumperConnection dumper, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size</span></span></span><span class="hljs-function">)</span></span> { dumper.WritePrg(<span class="hljs-number"><span class="hljs-number">0xA001</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> banks = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(size / <span class="hljs-number"><span class="hljs-number">0x2000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> bank = <span class="hljs-number"><span class="hljs-number">0</span></span>; bank &lt; banks<span class="hljs-number"><span class="hljs-number">-2</span></span>; bank += <span class="hljs-number"><span class="hljs-number">2</span></span>) { Console.Write(<span class="hljs-string"><span class="hljs-string">"Reading PRG banks #{0} and #{1}... "</span></span>, bank, bank+<span class="hljs-number"><span class="hljs-number">1</span></span>); dumper.WritePrg(<span class="hljs-number"><span class="hljs-number">0x8000</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); dumper.WritePrg(<span class="hljs-number"><span class="hljs-number">0x8001</span></span>, bank); dumper.WritePrg(<span class="hljs-number"><span class="hljs-number">0x8000</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); dumper.WritePrg(<span class="hljs-number"><span class="hljs-number">0x8001</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(bank | <span class="hljs-number"><span class="hljs-number">1</span></span>)); data.AddRange(dumper.ReadPrg(<span class="hljs-number"><span class="hljs-number">0x8000</span></span>, <span class="hljs-number"><span class="hljs-number">0x4000</span></span>)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"OK"</span></span>); } Console.Write(<span class="hljs-string"><span class="hljs-string">"Reading PRG banks #{0} and #{1}... "</span></span>, banks<span class="hljs-number"><span class="hljs-number">-2</span></span>, banks<span class="hljs-number"><span class="hljs-number">-1</span></span>); data.AddRange(dumper.ReadPrg(<span class="hljs-number"><span class="hljs-number">0xC000</span></span>, <span class="hljs-number"><span class="hljs-number">0x4000</span></span>)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"OK"</span></span>); }</code> </pre> <br>  If anyone is interested, the description of this mapper can be read here: <a href="http://wiki.nesdev.com/w/index.php/MMC3">wiki.nesdev.com/w/index.php/MMC3</a> <br><br>  I decided to try to be at the place of the pioneers and dump the cartridge with such an unusual menu: <br><br><img src="//habrastorage.org/files/0c7/665/f76/0c7665f7673e4e73a9ebe4fa8db1f242.png"><br><br>  To do this, I first read the cartridge as if there was no mapper, I ran it on the emulator and started disassembling it.  Soon I found the instructions I needed: <br><br><img src="//habrastorage.org/files/673/2fe/9a2/6732fe9a2a0c4b4698cefce80d188cf9.png"><br><br>  After that, I read the cartridge again, having previously made an entry at $ B600, and received a fully functional <a href="">ROM</a> .  Of course, the games in it do not start, because for this you need to switch the memory banks again.  And even if I follow what happens at the moment when the game is selected in the menu, and read the entire cartridge, the emulator most likely will not be able to start all this. <br><br>  I also got a license cartridge from one of the most iconic games of those times - ‚ÄúThe Legend of Zelda‚Äù.  It works without problems with both the dumper and Famikom through a simple passive adapter.  It makes no sense to dump this game, she interested me in others.  This cartridge is worth additional RAM memory and battery, which allows you to remain in the game.  This memory is in the range of $ 6000- $ 7FFF.  I tried to read it and feed it to the emulator.  He understood her without any problems.  After that, for the sake of experiment, I decided to increase the number of hearts in it and write it back into the cartridge.  It worked. <br><br><img src="//habrastorage.org/files/c7e/aa9/849/c7eaa9849b134c7c8ba5ccb6c4eb322a.jpg"><br><br>  It turned out a fun opportunity to transfer save between the emulator and the real console. <br><br>  Many will probably be asked why I even took this up when almost any ROM can be found on the net.  Yes, out of curiosity and self-education.  It was interesting to see what was going on inside these cartridges, and how it all works.  In addition, they can both read and write cartridges.  But more about that next time. <br><br>  Links to sources: <br>  <a href="http://github.com/ClusterM/famicom-dumper">github.com/ClusterM/famicom-dumper</a> - the dumper itself (C source, board layout, 3D case models) <br>  <a href="http://github.com/ClusterM/famicom-dumper-client">github.com/ClusterM/famicom-dumper-client</a> - client in C # </div><p>Source: <a href="https://habr.com/ru/post/248459/">https://habr.com/ru/post/248459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248449/index.html">(Kiev) from 3 to 6 February, the course "Advanced Switch Operation, Configuration and Management"</a></li>
<li><a href="../248451/index.html">(Belarus) Foundation for data center: Juniper MetaFabric architecture</a></li>
<li><a href="../248453/index.html">Automated testing of services using the MQ protocol using JMeter</a></li>
<li><a href="../248455/index.html">CrystaX NDK 10.1 release</a></li>
<li><a href="../248457/index.html">Introduction to the development of web-applications on PSGI / Plack. Part 4. Asynchrony</a></li>
<li><a href="../248463/index.html">How to quickly assess what is in the infrastructure and how is it used (for how much)?</a></li>
<li><a href="../248465/index.html">How we were friends Neo4j and Meteor</a></li>
<li><a href="../248467/index.html">Opened vacancies in the laboratory of software engineering</a></li>
<li><a href="../248469/index.html">(Kiev) From January 27 to January 30 the course ‚ÄúENA 15.3: Switch Operation, Configuration & Management‚Äù will take place</a></li>
<li><a href="../248475/index.html">C raffle for the C ++ Russia conference ticket from JetBrains</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>