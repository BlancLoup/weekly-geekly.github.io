<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We develop frontend Dnevnik.ru. Part one. Build and validate JavaScript code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 During its existence, Dnevnik.ru (and this is more than 4 years) has accumulated a huge amount of JavaScript code: some were in a separ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We develop frontend Dnevnik.ru. Part one. Build and validate JavaScript code</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  During its existence, Dnevnik.ru (and this is more than 4 years) has accumulated a huge amount of JavaScript code: some were in a separate project as connected files, some were determined right on the controls layout, and some were collected directly in the code-behind using <code>StringBuilder</code> .  To this were added: <br><ul><li>  a growing number of HTTP requests for receiving static content ‚Äî for example, on all pages only 11 JavaScript files were loaded in the <code>&lt;head&gt;</code> tag; </li><li>  global variables that sometimes overlap each other; </li></ul><br>  Deciding that it‚Äôs time to do something, we set ourselves the primary task: to remove all separately connected files from the <code>&lt;head&gt;</code> into one minified package.  At the same time, the code was divided into third-party and ‚Äúour‚Äù, which was planned to be checked with some kind of parser. <br><br>  In this article we will tell you about how you solved this problem. <br><a name="habracut"></a><br><h4>  What to use? </h4><br>  First of all, we had to decide on the means by which we would organize the automatic assembly of this package.  Of course, you could use any build system, from Ant to MSBuild;  you could write your own simple script ‚Äî for example, in Ruby or Python.  As a result, we decided not to write our bikes and not to hammer nails with a tractor, but to use <a href="http://gruntjs.com/">Grunt</a> .  For those who do not know: Grunt is a JavaScript task runner, it works on <a href="http://nodejs.org/">node.js</a> , and is distributed under the free <a href="https://github.com/gruntjs/grunt/blob/master/LICENSE-MIT">MIT license</a> .  Despite the relative "youth" of this solution, it has already managed to establish itself as a great tool - it is used to build jQuery and QUnit, Tweetdeck on Twitter and Brackets in Adobe.  In addition to these recommendations, we also had our own reasons for choosing Grunt: <br><ul><li>  Ease of use - in order to start working with it, you just need to install node.js. </li><li>  All tasks can be solved using JavaScript on node.js, JSHint can be used for syntactical testing, UglifyJS for code minification, and if you look into the future, node.js will be indispensable for unit testing, testing and building styles. </li><li>  Large selection of plug-ins to run various tools, as well as a simple API for writing your plug-ins. </li></ul><br>  By the way, it's no secret for anyone that our project works on ASP.NET, therefore we considered the possibility of using the <a href="http://aspnetoptimization.codeplex.com/">Web Optimization Framework</a> <a href="http://bundletransformer.codeplex.com/">Bundle Transformer</a> derived from it.  However, we abandoned these solutions for the following reasons: <br><ul><li>  using these tools, it is impossible to perform a syntactic check of the code; </li><li>  the content given to the client is dynamically generated upon request, and this operation is in any case more difficult than the return by the web server of a static file.  Someone may say that this is a match-saving, but: <br>  <i>Firstly</i> , we do not agree with this - there are quite heavy operations in our project, which already burden the server; <br>  <i>secondly</i> , it was technically impossible to do this, since the project in which JavaScript files are stored is not a web application, <br>  In addition, we needed static files in connection with the transition to the CDN in the near future. </li></ul><br>  However, if in the future these tools rise to the level of <a href="https://github.com/sstephenson/sprockets">sprockets</a> from Ruby on Rails, then I do not rule out that we will return to their consideration. <br><br><h4>  Go! </h4><br>  So, the system for the assembly has been chosen and it‚Äôs time to act, but before further narration you should make a reservation.  Since the application is written in ASP.NET, the majority of developers work on Windows (which is not surprising), and the continuous integration process that was built with TeamCity (we wrote about this in a previous <a href="http://habrahabr.ru/company/dnevnik_ru/blog/169329/">article</a> ) also occurs on Windows  Therefore, the author asks fans of the Unix-way to forgive him for the fact that the following will be described exactly within the framework of the Windows ecosystem, and to take the entire experience below as a challenge. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Installing node.js on Windows has long been a problem.  All you need to do is download a binary file from the official <a href="http://nodejs.org/download/">site</a> , launch it and poke it in the ‚ÄúNext‚Äù button.  Together with node.js, npm, the package manager, will be installed, with which we will install both Grunt and everything needed for its operation.  To begin with, we will create a <code>package.json</code> file in the project, in which we will write the name of our project, its version, dependencies, and the node.js version.  It will look like this: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Dnevnik"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"private"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: { <span class="hljs-string"><span class="hljs-string">"grunt"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"grunt-cli"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1.6"</span></span>, <span class="hljs-string"><span class="hljs-string">"grunt-contrib-concat"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1.3"</span></span>, <span class="hljs-string"><span class="hljs-string">"grunt-contrib-jshint"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.2.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"grunt-contrib-uglify"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1.1"</span></span>, <span class="hljs-string"><span class="hljs-string">"grunt-hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.2.2"</span></span>, <span class="hljs-string"><span class="hljs-string">"grunt-contrib-clean"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.4.0"</span></span> }, <span class="hljs-string"><span class="hljs-string">"engines"</span></span>: { <span class="hljs-string"><span class="hljs-string">"node"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.10.0"</span></span> } }</code> </pre><br>  In the dependencies, we specify Grunt and its version, as well as the necessary plugins.  At the initial stage, we used only six plugins: <br><ul><li>  <code>grunt-cli</code> - plugin for running Grunt from the command line </li><li>  <code>grunt-contrib-concat</code> - plugin for concatenating the file list into one </li><li>  <code>grunt-contrib-jshint</code> - plugin for testing JavaScript code using the <a href="http://www.jshint.com/">JSHint</a> utility </li><li>  <code>grunt-contrib-uglify</code> - plugin for minifying JavaScript code using <a href="https://github.com/mishoo/UglifyJS2">UglifyJS2</a> </li><li>  <code>grunt-hash</code> - a plugin for adding hash sums to file names (in order to flush the cache when the file contents change) </li><li>  <code>grunt-contrib-clean</code> - plugin for cleaning directory from temporary files and artifacts </li></ul><br>  To install all packages with their dependencies, you need to execute just one command in the console relative to the directory where <code>package.json</code> is located: <br><br><pre> <code class="bash hljs">&gt; npm install</code> </pre><br>  After successful completion, a folder will appear in it <code>.\node_modules</code> , which will contain all the necessary modules (this is the standard folder name for modules installed via npm). <br>  Next you need to create <code>Gruntfile.js</code> in the root directory of the application, it will contain all the logic of Grunt.  Its structure is very simple: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">grunt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>; grunt.initConfig({}); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-contrib-jshint'</span></span>); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-contrib-concat'</span></span>); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-contrib-uglify'</span></span>); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-hash'</span></span>); grunt.loadNpmTasks(<span class="hljs-string"><span class="hljs-string">'grunt-contrib-clean'</span></span>); grunt.registerTask(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, [<span class="hljs-string"><span class="hljs-string">'jshint'</span></span>, <span class="hljs-string"><span class="hljs-string">'concat'</span></span>, <span class="hljs-string"><span class="hljs-string">'uglify'</span></span>, <span class="hljs-string"><span class="hljs-string">'hash'</span></span>, <span class="hljs-string"><span class="hljs-string">'clean'</span></span>]); };</code> </pre><br>  In essence, this is a javascript script for node.js, consisting of: <br><ul><li>  a wrapper function that accepts the grunt parameter, </li><li>  the <code>grunt.initConfig()</code> function, into which a JavaScript object with the configuration of all tasks is passed, </li><li>  functions <code>grunt.loadNpmTasks()</code> , which loads tasks from npm packages, </li><li>  functions <code>grunt.registerTask()</code> , which registers its own tasks. </li></ul><br>  When a task starts, it tries to find an attribute with its name in the object that was passed to the <code>grunt.initConfig()</code> function, and it gets all the settings through the <code>option</code> attribute and the target through the other attributes.  There can be an unlimited number of goals in a task, and each goal can override some settings for itself.  More information about the configuration of tasks can be found in the <a href="http://gruntjs.com/configuring-tasks">official documentation</a> . <br><br>  In order to start Grunt, you need to run the following command in the console relative to the application root directory: <br><br><pre> <code class="bash hljs">&gt; .\node_modules\.bin\grunt.cmd</code> </pre><br>  Optionally, you can pass a parameter with the name of the task and the goal to be executed.  If it starts without parameters, the task with the name <code>default</code> will be executed. <br>  Next, we had to split those notorious 11 files containing various libraries and jQuery plug-ins into separate atomic files.  Some of them were compressed, and for the convenience of development I wanted to have all the code in a normal, readable form.  And if it was easy to find a non-minified version of jQuery, then finding the right version of some ancient plugin was no longer so trivial, it was necessary to tinker with it.  However, the result was worth the effort: now there was no minified code in the project, and it was possible to get into a debugger even in the jQuery source code without any problems. <br><br>  In order for each of the developers to not need to install node.js and build the package, we made a simple mapping file in JSON format (of course, not the most beautiful solution, but we decided to make everything as simple as possible), in which the package name corresponded to from several files: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"package.js"</span></span>: [<span class="hljs-string"><span class="hljs-string">"jquery.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"foo.js"</span></span>, ‚Ä¶ <span class="hljs-string"><span class="hljs-string">"bar.js"</span></span>]}</code> </pre> <br>  When the application started, this file was read, deserialized, and the files were added to the page.  And when building, Grunt received information about which packages to build from which files, and at the final stage transformed it.  So instead of a set of files in the list there was one name of the assembled package. <br><br>  After the code for running Grunt was written, and the tasks were prepared, it was necessary to install node.js on all build agents in TeamCity and try it in action by running a script through PowerShell.  In order not to download the necessary dependencies from the network each time (do not think it‚Äôs not about our stinginess for traffic, we just don‚Äôt want to depend on the stability of the Internet or the npm repository), we decided to save them to a separate folder on each build agent in the right place before use.  ‚ÄúCheap and angry,‚Äù we thought (for what this led to, read below).  However, in this situation it should be <code>.\node_modules</code> in mind that the paths in the folder <code>.\node_modules</code> can be much longer than the maximum 260 characters allowed in Windows (Hi, MS-DOS), so the copy and xcopy commands will crash with an error, can that <a href="http://technet.microsoft.com/ru-ru/library/cc733145(v%3Dws.10).aspx">robocopy</a> with the / e flag. <br><br><h4>  What problems we faced and how they were solved. </h4><br>  The first Grunt pig slipped to us immediately after launching on TeamCity - we could not get a log of its work.  Digging into our PowerShell scripts and realizing that the problem is not on our side, we began to watch the issue tracker in the Grunt repository and found there a remarkable <a href="https://github.com/gruntjs/grunt/issues/510">message</a> .  It turns out that such a problem appeared not only in our country and it is connected with a <a href="https://github.com/joyent/node/issues/3584">bug</a> in node.js, in which the stdin / stdout / stderr threads are not blocked in Windows.  They promise to fix it in version 0.12.0, but in order to make Grunt work for us, we had to resort to a not very nice hack: we started Grunt twice - the first time we received the correct exit code, and the second redirected the flow output to file, after which output the contents of this file. <br><br>  Not so long ago, a patch for Grunt appeared, correcting this error, but it is not yet located in the main repository.  So we had to download the <a href="https://github.com/adamstallard/grunt">fork</a> directly from Github, and then we faced another nuisance.  The fact is that when we first started working with Grunt, there were only three cars in our park of build agents.  Now there are eight of them, and copying a new package to each of them is tedious.  Without thinking twice, we decided to set up a local npm repository, where we could always quickly pick up the packages and where we could put our own, regardless of the connection and availability of the official repository. <br><br>  The official npm repository works with <a href="http://couchdb.apache.org/">CouchDB</a> , and to create a local repository, we just needed to create its replication.  We quickly picked up the virtual machine (again, running Windows) and installed CouchDB on it - the benefit is no more difficult than installing node.js.  Further, in order to be able to access the repository from the local network, in the CouchDB configuration file <code>&lt;CouchDB install directory&gt;\etc\couchdb\local.ini</code> you need to change two values: <br><br><pre> <code class="apache hljs"><span class="hljs-attribute"><span class="hljs-attribute">secure_rewrites</span></span> = false bind_adress = 0.0.0.0</code> </pre><br>  You can check the correctness of the setting by sending a normal GET request to the 5984 port of the virtual machine and receiving approximately the following JSON answer: <br><br><pre> <code class="javascript hljs">{<span class="hljs-string"><span class="hljs-string">"couchdb"</span></span>:<span class="hljs-string"><span class="hljs-string">"Welcome"</span></span>,<span class="hljs-string"><span class="hljs-string">"version"</span></span>:<span class="hljs-string"><span class="hljs-string">"1.2.1"</span></span>}</code> </pre> <br>  After that, it remains only to obtain information about all the modules used in the project and replicate them.  To do this, in the root directory of the project, you can run the following command: <br><br><pre> <code class="bash hljs">&gt; npm shrinkwrap</code> </pre><br>  It will create the file <code>npm-shrinkwrap.json</code> , which will contain all the information about the project, including all dependencies.  But, since we will only need their names, we will have to work a little more by writing a small recursive script that will get them from the resulting file (I will not give its code, since it is incredibly trivial).  Having received the list with the names of the packages, we need to execute the usual HTTP request to CouchDB for their replication.  We will use the <code>curl</code> utility for this (although you can use any other) and for convenience we will create a JSON file called <code>deps.json</code> with the following content: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://isaacs.iriscouch.com/registry/"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"registry"</span></span>, <span class="hljs-string"><span class="hljs-string">"create_target"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"doc_ids"</span></span>: [<span class="hljs-string"><span class="hljs-string">"_design/app"</span></span>, <span class="hljs-string"><span class="hljs-string">"_design/ghost"</span></span>] }</code> </pre><br>  where the value of the attribute <code>"doc_ids"</code> needs to be supplemented with a list of necessary dependencies (packages <code>"_design/app"</code> , <code>"_design/ghost"</code> organize the work of the database as a repository).  And now we just execute the following command in the console: <br><br><pre> <code class="bash hljs">&gt; .\curl.exe -X POST http://user:password@npm:5984/_replicate -d@deps.json -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span></code> </pre><br>  The response from the server will again be in JSON format, and it is worth paying attention to two attributes: <code>"ok"</code> and <code>"doc_write_failures"</code> .  If the first value is <code>true</code> and the second is <code>0</code> , then the replication of the packets was successful. <br><br>  All we had to do after that was to publish the fork received from Github with the Grunt patch.  To do this, you need to change the version name in the <code>package.json</code> file of the fork, register the user in the local repository with the command: <br><br><pre> <code class="bash hljs">&gt; npm adduser --registry=<span class="hljs-string"><span class="hljs-string">"http://npm:5984/registry/_design/app/_rewrite/"</span></span></code> </pre><br>  And publish the package: <br><br><pre> <code class="bash hljs">&gt; npm publish --registry=<span class="hljs-string"><span class="hljs-string">"http://npm:5984/registry/_design/app/_rewrite/"</span></span></code> </pre><br>  Everything is done, the package is published in our local repository, you just need to remember to change its version in the project <code>package.json</code> . <br>  Now to install all the packages you can (and should) use the following command: <br><br><pre> <code class="bash hljs">&gt; npm install --registry=<span class="hljs-string"><span class="hljs-string">"http://npm:5984/registry/_design/app/_rewrite/"</span></span></code> </pre><br>  By the way, not so long ago we abandoned the use of the PowerShell script to run Grunt on TeamCity and switched to using the plugin for it.  The plugin is called <a href="">TeamCity.Node</a> and allows you to run node.js scripts, npm, Grunt and PhantomJS on TeamCity, while it checks whether node.js and npm are installed on the build agent.  So far, we are absolutely satisfied with his work, if only because it was with his help that we learned that we forgot to put node.js on one of the agents. <br><br><h4>  What's next? </h4><br>  We are waiting for the release of node.js 0.12 and Grunt 0.5, in which the errors described above should be corrected.  And our plan for the future is like this: first, we need to abandon the use of the file mapping, second, we need to move all the JavaScript code from the controls to separate files in order to reduce the amount of code and improve its support. <br><br>  But we will tell about it in our next articles. </div><p>Source: <a href="https://habr.com/ru/post/181352/">https://habr.com/ru/post/181352/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../18134/index.html">Just</a></li>
<li><a href="../181342/index.html">Using artificial immune systems to solve symbolic regression</a></li>
<li><a href="../181344/index.html">A little more about 2D graphics for Android</a></li>
<li><a href="../18135/index.html">Fans of KDE2 under FreeBSD Yushchenko advises "Do not fool yourself"</a></li>
<li><a href="../181350/index.html">Warner Bros. and NBC Universal demanded the removal of the address of the file hosting Mega from the Google search results</a></li>
<li><a href="../181354/index.html">Scalable networks in Openstack. Part 2: VlanManager</a></li>
<li><a href="../181356/index.html">Fundamental problems of the economy on Bitcoin</a></li>
<li><a href="../181362/index.html">Overview of the Philips Shoqbox SB7300 Portable Audio System</a></li>
<li><a href="../181366/index.html">Runetology (200): Maxim Spiridonov, CEO of the Netology Education Center</a></li>
<li><a href="../181368/index.html">The secret ingredient is a good architect.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>