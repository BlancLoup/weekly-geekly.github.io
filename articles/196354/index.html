<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>"Boost.Asio C ++ Network Programming". Chapter 5: Synchronous vs. Asynchronous</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". 

 Content: 


- Chapter 1: Getting Started with Boost....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>"Boost.Asio C ++ Network Programming". Chapter 5: Synchronous vs. Asynchronous</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I continue to translate the book of John Torjo "Boost.Asio C ++ Network Programming". <br><br>  Content: <br><ul><li>  <a href="http://habrahabr.ru/post/192284/">Chapter 1: Getting Started with Boost.Asio</a> </li><li>  Chapter 2: Boost.Asio Basics <br><ul><li>  <a href="http://habrahabr.ru/post/193038/">Part 1: The Basics of Boost.Asio</a> </li><li>  <a href="http://habrahabr.ru/post/195006/">Part 2: Asynchronous Programming</a> </li></ul></li><li>  <a href="http://habrahabr.ru/post/195386/">Chapter 3: Echo Server / Client</a> </li><li>  <a href="http://habrahabr.ru/post/195794/">Chapter 4: Client and Server</a> </li><li>  <b>Chapter 5: Synchronous vs. Asynchronous</b> </li><li>  <a href="http://habrahabr.ru/post/196888/">Chapter 6: Boost.Asio - Other Features</a> </li><li>  <a href="http://habrahabr.ru/post/197392/">Chapter 7: Boost.Asio - additional topics</a> </li></ul><br><br>  The authors of Boost.Asio did a wonderful job, giving us the opportunity to choose what suits our applications more by choosing a synchronous or asynchronous path. <br>  In the previous chapter, we saw frameworks for all types of applications, such as a synchronous client, a synchronous server, as well as their asynchronous variants.  You can use each of them as a basis for your application.  If there is a need to delve into the details of each type of application, then read on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Mixing synchronous and asynchronous programming </h4><br>  Library Boost.Asio allows you to mix synchronous and asynchronous programming.  Personally, I think this is a bad idea, but Boost.Asio, like C ++ as a whole, allows you to shoot yourself in the foot if you want. <br>  You can easily fall into the trap, especially if your application is asynchronous.  For example, in response to an asynchronous write operation, you say, you make an asynchronous read operation: <br><br><pre><code class="cpp hljs">io_service service; ip::tcp::<span class="hljs-function"><span class="hljs-function">socket </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(boost::system::error_code err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> read_buff[<span class="hljs-number"><span class="hljs-number">512</span></span>]; read(sock, buffer(read_buff)); } async_write(sock, buffer(<span class="hljs-string"><span class="hljs-string">"echo"</span></span>), on_write);</code> </pre> <br>  Surely a synchronous read operation will block the current thread, so any other incomplete asynchronous operations will be in standby mode (for this thread).  This is a bad code and can cause the application to slow down or block at all (the whole point of using the asynchronous approach is to avoid blocking, so using synchronous operations, you deny it).  If you have a synchronous application, it is unlikely that you will use asynchronous read or write operations, since to think synchronously means to think in a linear fashion (to do A, then B, then C, and so on). <br>  The only case, in my opinion, when synchronous and asynchronous operations can work together is when they are completely separated from each other, for example, a synchronous network and asynchronous input and output operations from the database. <br><br><h4>  Delivery of messages from the client to the server and vice versa </h4><br>  A very important part of a good client / server application is delivering messages back and forth (from server to client and from client to server).  You must specify that identifies the message.  In other words, when an incoming message is being read, how can we know that the message has been completely read? <br>  You need to determine the end of the message (the beginning is easy to determine, this is the first byte that came after the end of the last message), but you will see that it is not so easy. <br>  You can: <br><ul><li>  Make a fixed-size message (this is not a good idea; what to do when you need to send more data?) </li><li>  Make a specific character terminating the message, such as '\ n' or '\ 0' </li><li>  Specify the length of the message as a prefix of the message, and so on. </li></ul><br>  Throughout the book, I decided to use "the character '\ n' as the end of each message."  So, reading messages will show the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buff_[<span class="hljs-number"><span class="hljs-number">512</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// synchronous read read(sock_, buffer(buff_), boost::bind(&amp;read_complete, this, _1, _2)); // asynchronous read async_read(sock_ buffer(buff_),MEM_FN2(read_complete,_1,_2), MEM_FN2(on_read,_1,_2)); size_t read_complete(const boost::system::error_code &amp; err, size_t bytes) { if ( err) return 0; already_read_ = bytes; bool found = std::find(buff_, buff_ + bytes, '\n') &lt; buff_ + bytes; // we read one-by-one until we get to enter, no buffering return found ? 0 : 1; }</span></span></code> </pre><br>  Leaving the length indication as the prefix of the message as an exercise for the reader, is pretty easy. <br><br><h4>  Synchronous I / O in client applications </h4><br>  A synchronous client, as a rule, is of two types: <br><ul><li>  It requests something from the server, reads and processes the response.  Then asks for something else and so on.  This is essentially a synchronous client, which was discussed in the previous chapter. </li><li>  Reads the incoming message from the server, processes it and writes a response.  Then reads the next incoming message, and so on. </li></ul><br><br><img src="http://habrastorage.org/storage3/94f/d0b/4bb/94fd0b4bbadefcba262c76c27d2a410a.png"><br><br>  Both scenarios use the following strategy: make a request - read the answer.  In other words, one side makes a request, to which the other side responds.  This is an easy way to implement a client / server application and this is what I recommend to you. <br>  You can always create a Mambo Jambo client / server where each side writes at any time, but it‚Äôs very likely that this path will lead to disaster (how do you know what happened when the client or server is blocked?). <br>  The previous scenarios may look the same, but, they are very different: <br><ul><li>  In the first case, the server responds to requests (the server waits for requests from clients and responds to them).  This is a pull-like connection when the client receives what he needs on request from the server. </li><li>  In the latter case, the server sends the client events to which it responds.  This is a push-like connection when the server pushes notifications / events to clients. </li></ul><br>  Basically you will encounter pull-like client / server applications that facilitate development, as well as, as a rule, are the norm. <br>  You can mix these two approaches: get on demand (client-server) and push request (server-client), however, it is difficult and better to avoid it.  There is a problem of mixing these two approaches, if you use a strategy to make a request - read the answer;  the following may occur: <br><ul><li>  The client writes (makes a request) </li><li>  Server writes (sends notification to client) </li><li>  The client reads what the server wrote and interprets it as a response to its request. </li><li>  The server blocks waiting for a response from the client, which will come when the client makes a new request. </li><li>  Client writes (makes new request) </li><li>  The server will interpret this request as a response that it was waiting for. </li><li>  The client is blocked (the server does not send a response back because it interpreted the client's request as a response to its notification). </li></ul><br>  In a pull-like client / server application, the previous scenario could easily have been avoided.  You can simulate push-like behavior by implementing the ping process, when a client checks the connection to the server, say, every 5 seconds.  The server may respond with something like ping_ok if there is nothing to report or ping_ [event_name] if there is an event to alert.  The client can then initiate a new request to handle this event. <br>  Again, the previous script illustrates the synchronous client from the previous chapter.  Its main loop is: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// read answer to our login write("login " + username_ + "\n"); read_answer(); while ( started_) { write_request(); read_answer(); ... } }</span></span></code> </pre><br>  Let change to fit the latest scenario: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( started_) { read_notification(); write_answer(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_notification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ already_read_ = <span class="hljs-number"><span class="hljs-number">0</span></span>; read(sock_, buffer(buff_), boost::bind(&amp;talk_to_svr::read_complete, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, _1, _2)); process_notification(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_notification</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... see what the notification is, and prepare answer }</span></span></code> </pre><br><br><h4>  Synchronous I / O in server applications </h4><br>  Servers, like clients, are of two types, they correspond to the two scenarios from the previous section.  Again, both scenarios use a strategy: create a request - read the answer. <br><br><img src="http://habrastorage.org/storage3/054/d43/023/054d430230ba77c2fa018d5fb70ac9cd.png"><br><br>  The first scenario is a synchronous server, which we implemented in the previous <a href="http://habrahabr.ru/post/195794/">chapter</a> .  Reading the request completely is not easy if you are working synchronously, since you want to avoid locks (you always read as much as you can). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sock_.available()) already_read_ += sock_.read_some(buffer(buff_ + already_read_, max_msg ‚Äìalready_read_)); }</code> </pre><br>  After the message has been completely read, simply process it and respond to the client: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> found_enter = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find(buff_, buff_ + already_read_, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) &lt; buff_ + already_read_; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !found_enter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// message is not full size_t pos = std::find(buff_, buff_ + already_read_, '\n') - buff_; std::string msg(buff_, pos); ... if ( msg.find("login ") == 0) on_login(msg); else if ( msg.find("ping") == 0) on_ping(); else ... }</span></span></code> </pre><br>  If we wanted our server to become a push-like server, we would change it as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;client_ptr&gt; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> clients; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> notify; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> notify_msg; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// on a new client, we notify all clients of this event notify = clients; std::ostringstream msg; msg &lt;&lt; "client count " &lt;&lt; clients.size(); notify_msg = msg.str(); notify_clients(); } void notify_clients() { for ( array::const_iterator b = notify.begin(), e = notify.end(); b != e; ++b) { (*b)-&gt;sock_.write_some(notify_msg); } }</span></span></code> </pre><br>  The <code>on_new_client()</code> function is a function of a single event, where we must notify all clients about it.  <code>notify_clients</code> is a function that will notify clients that are subscribed to this event.  The server sends a message, but does not wait for a response from each client, as this can lead to blocking.  When a response comes from the client, the client can tell us that this is exactly the answer to our notification (and we can process it correctly). <br><br><h4>  Streams in the synchronous server </h4><br>  This is a very important factor: how many streams will we allocate for processing clients? <br>  For a synchronous server, we will need at least one stream that will handle new connections: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ip::tcp::<span class="hljs-function"><span class="hljs-function">acceptor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">acceptor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, ip::tcp::endpoint(ip::tcp::v4(),</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-function"><span class="hljs-function">client_ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> talk_to_client)</span></span></span></span>; acceptor.accept(new_-&gt;sock()); boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs)</span></span></span></span>; clients.push_back(new_); } }</code> </pre><br>  For existing customers: <br><ul><li>  We can go one way.  This is the easiest way and we chose it when we implemented the synchronous server in <a href="http://habrahabr.ru/post/195794/">Chapter 4</a> .  It can easily handle 100-200 simultaneous connections, and sometimes it can be more, which is enough for the vast majority of cases. </li><li>  We can make a stream for each client.  This is very rarely a good option, it will spend a lot of threads, making debugging sometimes difficult, and although it will probably handle more than 200 concurrent users, soon after this it will reach its limit. </li><li>  We can make a fixed number of threads for processing existing customers. </li></ul><br>  The third option is very difficult to implement in a synchronous server.  The entire <code>talk_to_client</code> class <code>talk_to_client</code> become thread safe.  Then you will need a special mechanism to know which threads handle which clients.  To do this, you have two options: <br><ul><li>  Assign a specific client to a specific thread;  for example, the first thread processes the first 20 clients, the second thread processes clients from 21 to 40, and so on.  When a client is used, we extract it from a variety of existing customers.  After we have worked with this client, put it back into the list.  Each thread will loop around all existing clients, and take the first client to process the full request (we have completely read the incoming message from the client) and respond to it. </li><li>  The server may stop responding: <br><ul><li>  In the first case, several clients processed in one stream simultaneously create requests, and one stream can process only one request at a time.  However, we can do nothing in this case. </li><li>  In the second case, we simultaneously receive more requests than we have threads.  In this case, we can simply create new threads to cope with the load. </li></ul><br></li></ul><br>  The following code, which is similar to the original <code>answer_to_client</code> function, shows how the last script can be implemented: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_client</span></span></span><span class="hljs-class"> :</span></span> boost::enable_shared_from_this&lt;talk_to_client&gt; { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">answer_to_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read_request(); process_request(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> ( boost::system::system_error&amp;) { stop(); } } };</code> </pre><br>  We will modify it as shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">talk_to_client</span></span></span><span class="hljs-class"> :</span></span> boost::enable_shared_from_this&lt;talk_to_client&gt; { boost::recursive_mutex cs; boost::recursive_mutex cs_ask; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> in_process; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">answer_to_client</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_ask)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( in_process) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; in_process = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { read_request(); process_request(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> ( boost::system::system_error&amp;) { stop(); } } { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_ask)</span></span></span></span>; in_process = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } };</code> </pre><br>  As long as we process the client, its <code>in_process</code> instance will be set to <code>true</code> , and other threads will ignore this client.  An added bonus is that the <code>handle_clients_thread()</code> function cannot be modified;  you can simply create as many <code>handle_clients_thread()</code> functions as you like. <br><br><h4>  Asynchronous I / O in client applications </h4><br>  The main workflow is somewhat similar to the same process in a synchronous client application, with the difference that Boost.Asio is between each <code>async_read</code> and <code>async_write</code> . <br><br><img src="http://habrastorage.org/storage3/091/141/0ae/0911410aea0dac0986814fb88bf67ae0.png"><br><br>  The first scenario is the same as the asynchronous client in <a href="http://habrahabr.ru/post/195794/">Chapter 4</a> .  Remember that at the end of each asynchronous operation, you must start another asynchronous operation so that the <code>service.run()</code> function does not complete its activity. <br>  To bring the first script to the second, we need to use the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ do_read(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ async_read(sock_, buffer(read_buffer_), MEM_FN2(read_complete,_1,_2), MEM_FN2(on_read,_1,_2)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( err) stop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(read_buffer_, bytes)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( msg.find(<span class="hljs-string"><span class="hljs-string">"clients"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) on_clients(msg); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ... } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> on_clients(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; msg) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> clients = msg.substr(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; username_ &lt;&lt; <span class="hljs-string"><span class="hljs-string">", new client list:"</span></span> &lt;&lt; clients ; do_write(<span class="hljs-string"><span class="hljs-string">"clients ok\n"</span></span>); }</code> </pre><br>  Note that as soon as you successfully connect, you start reading from the server.  Each <code>on_[event]</code> function ends it and writes a response to the server. <br>  The beauty of the asynchronous approach is that you can mix network I / O operations with any other asynchronous operations using Boost.Asio to organize it all.  Even though the flow is not as clear as the synchronous flow, you can practically think of it as synchronous. <br>  Let's say you read a file from a web server and save it to a database (asynchronously).  You can practically think about it, as shown in the following flowchart: <br><br><img src="http://habrastorage.org/storage3/612/aea/422/612aea422c2547dd1ed847cc6d4ea4e1.png"><br><br><h4>  Asynchronous I / O in server applications </h4><br>  Again, there are two ubiquitous cases, the first scenario (pull) and the second scenario (push): <br><br><img src="http://habrastorage.org/storage3/6ab/e2d/071/6abe2d07138578ca3d46db5d42281c87.png"><br><br>  The first asynchronous server script was implemented in the previous <a href="http://habrahabr.ru/post/195794/">chapter</a> .  At the end of each asynchronous operation, you must start another asynchronous operation so that <code>service.run()</code> does not stop its operation. <br>  Here is the code frame, which is trimmed.  Below are all the members of the <code>talk_to_client</code> class: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... do_read(); <span class="hljs-comment"><span class="hljs-comment">// first, we wait for client to login } void on_read(const error_code &amp; err, size_t bytes) { std::string msg(read_buffer_, bytes); if ( msg.find("login ") == 0) on_login(msg); else if ( msg.find("ping") == 0) on_ping(); else ... } void on_login(const std::string &amp; msg) { std::istringstream in(msg); in &gt;&gt; username_ &gt;&gt; username_; do_write("login ok\n"); } void do_write(const std::string &amp; msg) { std::copy(msg.begin(), msg.end(), write_buffer_); sock_.async_write_some( buffer(write_buffer_, msg.size()), MEM_FN2(on_write,_1,_2)); } void on_write(const error_code &amp; err, size_t bytes) { do_read(); }</span></span></code> </pre><br>  In a nutshell, we always wait for the read operation, as soon as it is completed, we process the message and reply back to the client. <br>  Let's convert the previous code to the push server: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... on_new_client_event(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_new_client_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">ostringstream</span></span> msg; msg &lt;&lt; <span class="hljs-string"><span class="hljs-string">"client count "</span></span> &lt;&lt; clients.size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>::const_iterator b = clients.begin(), e = clients.end();b != e; ++b) (*b)-&gt;do_write(msg.str()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(read_buffer_, bytes)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// basically here, we only acknowledge // that our clients received our notifications } void do_write(const std::string &amp; msg) { std::copy(msg.begin(), msg.end(), write_buffer_); sock_.async_write_some( buffer(write_buffer_, msg.size()), MEM_FN2(on_write,_1,_2)); } void on_write(const error_code &amp; err, size_t bytes) { do_read(); }</span></span></code> </pre><br>  When an event occurs, say <code>on_new_client_event</code> , messages will be sent to all clients that need to be informed about this event.  When they answer, we will understand that they have processed the received event.  Please note that we will never finish waiting for events asynchronously (therefore <code>service.run()</code> will not finish working), since we are always waiting for new customers. <br><br><h4>  Asynchronous Server Streams </h4><br>  The asynchronous server was shown in Chapter 4, it is single-threaded, since everything happens in the <code>main()</code> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ talk_to_client::ptr client = talk_to_client::new_(); acc.async_accept(client-&gt;sock(), boost::bind(handle_accept,client,_1)); service.run(); }</code> </pre><br>  The beauty of the asynchronous approach lies in the simplicity of the transition from a single-stream to a multi-stream variant.  You can always go one way, at least until your customers are over 200 at the same time or so.  Then, to go from one thread to 100 threads, you will need to use the following code snippet: <br><br><pre> <code class="cpp hljs">boost::thread_group threads; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listen_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ service.run(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_listen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> thread_count)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; thread_count; ++i) threads.create_thread( listen_thread); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ talk_to_client::ptr client = talk_to_client::new_(); acc.async_accept(client-&gt;sock(), boost::bind(handle_accept,client,_1)); start_listen(<span class="hljs-number"><span class="hljs-number">100</span></span>); threads.join_all(); }</code> </pre><br>  Of course, once you start using multi-threading, you should think about thread-safe.  Even if you call <code>async_*</code> in thread A, the procedure for its completion can be called in thread B (as long as thread B calls <code>service.run()</code> ).  This in itself is not a problem.  As long as you follow the logical sequence, that is, from <code>async_read()</code> to <code>on_read()</code> , from <code>on_read()</code> to <code>process_reques</code> t, from <code>process_request</code> to <code>async_write()</code> , from <code>async_write()</code> to <code>on_write()</code> , from <code>on_write()</code> to <code>async_read()</code> and there are no <code>public</code> functions that would call your <code>talk_to_client</code> class, although different functions can be called in different threads, they will still be called sequentially.  Thus, mutexes are not needed. <br>  This, however, means that there can be only one asynchronous operation pending for a client.  If at some point the client has two deferred asynchronous functions, then you need mutexes.  Because the two deferred operations can end at about the same time and eventually we could call their handlers simultaneously in two different threads.  Thus, there is a need for thread-safety, thus, in mutexes. <br>  In fact, our asynchronous server actually has two pending operations at the same time: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ async_read(sock_, buffer(read_buffer_), MEM_FN2(read_complete,_1,_2), MEM_FN2(on_read,_1,_2)); post_check_ping(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post_check_ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ timer_.expires_from_now(boost::posix_time::millisec(<span class="hljs-number"><span class="hljs-number">5000</span></span>)); timer_.async_wait( MEM_FN(on_check_ping)); }</code> </pre><br>  When performing a read operation, we will wait asynchronously for its completion for a certain period.  Thus, there is a need for flow-safety.  My advice, if you plan on choosing a multi-stream option, make your class thread safe from the very beginning.  This usually does not hurt performance (you can certainly check it out).  In addition, if you plan to go multi-line, then go on it from the very beginning.  Thus, you will encounter possible problems at an early stage.  As soon as you find a problem, the first thing you have to check is whether it happens with one thread running?  If so, it's easy, just debug it.  Otherwise, you probably forgot to mutex a function. <br>  Since our example needs thread-safe, we changed <code>talk_to_client</code> using mutexes.  In addition, we have an array of clients that we refer to several times in the code, which also needs its own mutex. <br>  It‚Äôs not so easy to avoid deadlock and memory damage.  Here's how to <code>update_clients_changed()</code> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_clients_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> copy; { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(clients_cs)</span></span></span></span>; copy = clients; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>::iterator b = copy.begin(), e = copy.end(); b != e; ++b) (*b)-&gt;set_clients_changed(); }</code> </pre><br>  What we want to avoid is that two mutexes are locked at the same time (which can lead to a deadlock situation).  In our case, we do not want the <code>clients_cs</code> and client <code>cs_</code> mutex to be locked at the same time. <br><br><h4>  Asynchronous operations </h4><br>  Boost.Asio also allows you to perform any of your functions asynchronously.  Just use the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } service.post(my_func);</code> </pre><br>  You can make sure that <code>my_func</code> is called on one of the threads that call <code>service.run()</code> .  You can also run an asynchronous function and make a terminating handler that will tell you when the function ends.  The pseudocode will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... service.post(on_complete); } async_call(my_func);</code> </pre><br>  There is no <code>async_call</code> function <code>async_call</code> , you have to create your own.  Fortunately, this is not so difficult.  See the following code snippet: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">async_op</span></span></span><span class="hljs-class"> :</span></span> boost::enable_shared_from_this&lt;async_op&gt;, ... { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(boost::system::error_code)&gt; completion_func; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::function&lt;boost::system::error_code ()&gt; op_func; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operation</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( started_) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; started_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } boost::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( boost::bind(&amp;async_op::run,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op_func op, completion_func completion, io_service &amp;service)</span></span></span><span class="hljs-function"> </span></span>{ self_ = shared_from_this(); boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_)</span></span></span></span>; ops_.push_back( operation(service, op, completion)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started_) start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_)</span></span></span></span>; started_ = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; ops_.clear(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: boost::recursive_mutex cs_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;operation&gt; ops_; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> started_; ptr self_; };</code> </pre><br>   <code>async_op</code>   ,    ( <code>run()</code> )    ,    ( <code>add()</code> )  .      - ,       : <br><ul><li>   . </li><li> <code>completion</code>       </li><li>  <code>io_service</code> ,    <code>completion</code> .  ,      .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">async_op</span></span></span><span class="hljs-class"> :</span></span> boost::enable_shared_from_this&lt;async_op&gt; , <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> boost::noncopyable { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operation</span></span></span><span class="hljs-class"> {</span></span> operation(io_service &amp; service, op_func op, completion_func completion): service(&amp;service), op(op)completion(completion), work(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> o_service::work(service)){} operation() : service(<span class="hljs-number"><span class="hljs-number">0</span></span>) {} io_service * service; op_func op; completion_func completion; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;io_service::work&gt; work_ptr; work_ptr work; }; ... };</code> </pre><br></li></ul><br>  ,        ,    <code>io_service::work</code> ,  <code>service.run()</code>      ,        (  ,    <code>io_service::work, service.run()</code>  ,     ).    : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">async_op</span></span></span><span class="hljs-class"> :</span></span> ... { <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;async_op&gt; ptr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> async_op); } ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( <span class="hljs-literal"><span class="hljs-literal">true</span></span>) { { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !started_) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } boost::this_thread::sleep( boost::posix_time::millisec(<span class="hljs-number"><span class="hljs-number">10</span></span>)); operation cur; { boost::recursive_mutex::<span class="hljs-function"><span class="hljs-function">scoped_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cs_)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !ops_.empty()) { cur = ops_[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ops_.erase( ops_.begin()); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cur.service) cur.service-&gt;post(boost::bind(cur.completion, cur.op() )); } self_.reset(); } };</code> </pre><br>  <code>run()</code>     ,   ,   ;  ,      .         . <br>   ,    <code>compute_file_checksum</code> ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> checksum = <span class="hljs-number"><span class="hljs-number">0</span></span>; boost::system::<span class="hljs-function"><span class="hljs-function">error_code </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compute_file_checksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file_name)</span></span></span><span class="hljs-function"> </span></span>{ HANDLE file = ::CreateFile(file_name.c_str(), GENERIC_READ, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="hljs-number"><span class="hljs-number">0</span></span>); windows::<span class="hljs-function"><span class="hljs-function">random_access_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">h</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service, file)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> buff[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; checksum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes = <span class="hljs-number"><span class="hljs-number">0</span></span>, at = <span class="hljs-number"><span class="hljs-number">0</span></span>; boost::system::error_code ec; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( (bytes = read_at(h, at, buffer(buff), ec)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { at += bytes; bytes /= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bytes; ++i) checksum += buff[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> boost::system::error_code(<span class="hljs-number"><span class="hljs-number">0</span></span>, boost::system::generic_category()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_checksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file_name, boost::system::error_code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"checksum for "</span></span> &lt;&lt; file_name &lt;&lt; <span class="hljs-string"><span class="hljs-string">"="</span></span> &lt;&lt; checksum &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> fn = <span class="hljs-string"><span class="hljs-string">"readme.txt"</span></span>; async_op::new_()-&gt;add( service, boost::bind(compute_file_checksum,fn), boost::bind(on_checksum,fn,_1)); service.run(); }</code> </pre><br>  ,           .    ,    ,      <code>io_service</code> ,     ( <code>post()</code> )   .       . <br>     ,       (,  ).   ,       -,   . <br><br><h4>   </h4><br>       .     ,   ,     .      ,   ,    . <br><br><img src="http://habrastorage.org/storage3/676/6b1/05c/6766b105c887e39ba2bb3573d4db02f1.png"><br><br>     -?     ,         ,   ,   .      . <br>        ,   ;       (   ),           (  ).  ,      ,     ,        ,            ,  ,        . <br>       : <br><ul><li>     ,    .    , ,  -     . </li><li>  ,    ,   -: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">proxy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;proxy&gt; { proxy(ip::tcp::endpoint ep_client, ip::tcp::endpoint ep_server) : ... {} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::endpoint ep_client, ip::tcp::endpoint ep_svr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ptr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">new</span></span></span></span><span class="hljs-function"><span class="hljs-params"> proxy(ep_client, ep_svr))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... connect to both endpoints return new_; } void stop() { // ... stop both connections } bool started() { return started_ == 2; } private: void on_connect(const error_code &amp; err) { if ( !err) { if ( ++started_ == 2) on_start(); } else stop(); } void on_start() { do_read(client_, buff_client_); do_read(server_, buff_server_); } ... private: ip::tcp::socket client_, server_; enum { max_msg = 1024 }; char buff_client_[max_msg], buff_server_[max_msg]; int started_; };</span></span></code> </pre><br></li></ul><br>    .            ( <code>on_start()</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">proxy</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::enable_shared_from_this&lt;proxy&gt; { ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::socket &amp; sock, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code&amp; err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * buff = &amp;sock == &amp;client_ ? buff_client_ : buff_server_; do_write(&amp;sock == &amp;client_ ? server_ : client_, buff, bytes); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::socket &amp; sock, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error_code &amp;err, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( &amp;sock == &amp;client_) do_read(server_, buff_server_); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> do_read(client_, buff_client_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::socket &amp; sock, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buff)</span></span></span><span class="hljs-function"> </span></span>{ async_read(sock, buffer(buff, max_msg), MEM_FN3(read_complete,ref(sock),_1,_2), MEM_FN3(on_read,ref(sock),_1,_2)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ip::tcp::socket &amp; sock, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * buff, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ sock.async_write_some(buffer(buff,size), MEM_FN3(on_write,ref(sock),_1,_2)); } <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> read_complete(ip::tcp::socket &amp; sock, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> error_code &amp; err, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> bytes) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( sock.available() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sock.available(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } };</code> </pre><br>     (on_read)     .       (on_write),    . <br>   ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[])</span></span></span><span class="hljs-function"> </span></span>{ ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep_c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8001</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; ip::tcp::<span class="hljs-function"><span class="hljs-function">endpoint </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ep_s</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ip::address::from_string(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"127.0.0.1"</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">8002</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; proxy::start(ep_c, ep_s); service.run(); }</code> </pre><br>  ,      ( <code>buff_client_</code>  <code>buff_server_</code> )    .    ,         ,         .   ,         .   ,         ,       (            ).    ,    ,   : <br><ul><li>        </li><li>     ,      ,     (  ). </li><li>       (  ) . </li></ul><br>       . <br><br><h4>  Summary </h4><br>    ,     ,    :   . <br>     : <br><ul><li>   ,       </li><li>       </li><li>    (pull-like  push-like)     </li><li>       ,      </li></ul><br>          Boost.Asio,       Boost.Asio ‚Äì <code>co-routines</code> ,        . <br><br>  Resources for this article: <a href="https://github.com/Vasilui/habrahabr/tree/master/Boost.Asio_C%252B%252B_Network_Programming/Chapter_5">link</a> <br><br>  Thank you all for your attention, until we meet again! </div><p>Source: <a href="https://habr.com/ru/post/196354/">https://habr.com/ru/post/196354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196338/index.html">Dell Solutions Forum 2013: 10 days left!</a></li>
<li><a href="../196340/index.html">Radio RSS for iPhone and iPad: all the latest news behind the wheel. Two years already!</a></li>
<li><a href="../196346/index.html">Seagate is working on creating 20 TB hard drives</a></li>
<li><a href="../196348/index.html">Alabama University proposes to launch a ‚Äúwomb‚Äù ship into orbit to fight dangerous space bodies.</a></li>
<li><a href="../196352/index.html">ARPU, or a few tenths of a dollar</a></li>
<li><a href="../196358/index.html">Frontend performance. Part 1 - concatenation, compression, caching (4th of 12 articles about Mozilla‚Äôs Node.js)</a></li>
<li><a href="../196360/index.html">Using Oracle RESULT_CACHE "not for its intended purpose"</a></li>
<li><a href="../196362/index.html">AlfabankAPI to work with Alpha Client On-line</a></li>
<li><a href="../196364/index.html">The number of false positive positives of the Bloom filter [translation]</a></li>
<li><a href="../196366/index.html">How I wanted to run away from Admob. Story about advertising networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>