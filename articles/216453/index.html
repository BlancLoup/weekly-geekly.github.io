<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Autotest without pain</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habra! 

 I will not offer you another trendy framework for tests, but just show you the approach to tests and documentation that I use in projects...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Autotest without pain</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/34d/7c3/beb/34d7c3beb48e07860fe13ad7f1d3b7e7.jpg" alt="image" align="left">  Hi Habra! <br><br>  I will not offer you another trendy framework for tests, but just show you the approach to tests and documentation that I use in projects developed in i-Free.  Perhaps you will like it and you will start organizing projects in the same way or point me to obvious problems. <br><br>  Many web developers do not like writing tests, and I am no exception.  But tests reduce the number of bugs, and if your application gets bigger and bigger, you won‚Äôt leave the tests.  In addition, in small companies I often met juniors, who generally prefer to write code in text editors (this increases the number of errors, because the editors do not check the code).  How to start slowly using tests without pain and suffering ?!  There is a way out - connect autotests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The essence of the post in the picture on the left.  This is what I used to lack in my daily work.  I wanted to have a tool that you can very easily poke into the code and make a general conclusion about its vitality and suitability. <br><a name="habracut"></a><br><h3>  Auto tests </h3><br>  <b>Problems:</b> <br><ul><li>  The developer is too lazy to write the tests themselves. </li><li>  Developer too lazy to write extra code for tests </li><li>  Developer is generally too lazy to think about tests. </li></ul><br>  <b>Solution:</b> Connect to the application through the API of any framework that the developer used, and run the auto-tests through it. <br><br>  <b>Where to connect:</b> <br><ul><li>  Event hook functions (like $ ("# button) .click (), core.addEvent (), helper.onClick (), etc.) </li><li>  Listener functions (like $ ("# button) .on (), event.listen (), mediator.listen (), etc.) </li><li>  Initialization functions (like $ (body). Ready (), utils.ready (), etc.) </li><li>  Callback functions in AJAX requests </li></ul><br>  <b>What to check:</b> <br><ul><li>  Performance with invalid arguments </li><li>  The presence of random bugs due to typos (such as missed;) </li><li>  Presence of all DOM elements necessary for the script </li></ul><br>  You can call all functions in try / catch with a bunch of random parameters and without them.  See which of the functions fall off.  In addition, run through all the links and queries of DOM elements and check their presence in the layout. <br><br>  <b>What does this give us:</b> <br>  It is clear that this is quite meaningless testing from the point of view of the logic of the web application.  But on the other hand, we can effortlessly and quickly recheck the assembly from the already stupid typos and absurdities. <br><br>  <b>Bonuses:</b> <br><ul><li>  It can be argued that this autotest can cover 90% of the functions of the application </li><li>  Such a test requires absolutely no effort from the developer in terms of support, updates, etc.  Roughly speaking, he may not think about them at all. </li><li>  There will still be bugs, so there is no unnecessary check. </li><li>  To test, we don‚Äôt need to change the structure of our application at all. </li></ul><br><br>  <b>Once again:</b> <br><ul><li>  This does not cancel unit tests! </li><li>  This is meaningless in terms of application logic! </li><li>  Tests for the sake of tests - bad </li></ul><br><br>  <b>But!</b>  It is free and easy, and it's better than nothing.  If you show this to your juniors, they will make sure that it is actually simple and without pain, which means they will be more loyal to the tests, which means they will come to the thought of writing unit tests faster. <br><br>  <b>Scheme of work:</b> <br><img src="https://habrastorage.org/getpro/habr/post_images/b72/36e/bbb/b7236ebbbde62b19eb363ab45ad21a11.png" alt="image" align="left"><br><br>  We have our application consisting of heaps of modules.  To check its work, we need to write a unit test for each module.  It is good if we do this, but, in fact, most developers will not waste time on it, especially in small applications.  Also, if you take any ready-made solution for testing that requires changing the code of the modules - no one will do that.  On the other hand, it is very easy to insert a couple of functions into the layer between the libraries and the application (if you do not have such a layer, you can insert these functions into the library itself).  And at the exit, we already get at least some testing (you can call it ‚Äúfool testing‚Äù, which will poke every button).  Well, if you still had a layer - generally wonderful.  And you can also make a substitution of the function AJAX requests. <br><br>  If your code is broken into modules and is designed as: <br><br><pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">global</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = { <span class="hljs-attr"><span class="hljs-attr">_methodA</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">_methodB</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">_methodC</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} } <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.init(); })(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br>  or similar structures - then the whole module can be exported to experiments at once. <br><br>  I got a test object in my room and everything that I could - I started shoving it: <br><br><pre> <code class="javascript hljs">test.add(); <span class="hljs-comment"><span class="hljs-comment">//       test.addFunction(); //    </span></span></code> </pre><br>  And then everything is simple.  Inside this test there are several arrays in which a bunch of callbacks and modules are collected.  At the exit there is another method: <br><pre> <code class="javascript hljs">test.start();</code> </pre><br>  At this point, the test starts all that gathered in the arrays.  And this is all checked in try / catch constructs.  If someone is dying, a notification pops up in the console and the next victim is taken from the array. <br><br>  If we check functions, then besides a simple call, they are also called with parameters.  In fact, there is a search from zero to 4 parameters.  Each parameter takes a series of values ‚Äã‚Äãin order (-1, 0, 1, ‚Äústring‚Äù, true, false, [], {}, etc.) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ed4/ed7/119/ed4ed7119a249708e49200a87f282bfc.png" alt="image"><br><br>  If we take a module, then it is an object.  We run over the properties of the object, and if we stumble upon a function, we check it using the algorithm above.  Since  all my modules have the same structure, you can check a few more points.  For example, find out if all DOM elements were found / created.  References to them are stored in the _nodes property, which almost all modules have.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = { <span class="hljs-attr"><span class="hljs-attr">_nodes</span></span>: { <span class="hljs-attr"><span class="hljs-attr">table</span></span>: DOM_element, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: DOM_element }, <span class="hljs-attr"><span class="hljs-attr">_methodA</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">_methodB</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">_methodC</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} }</code> </pre><br>  If, running over the module._nodes object, we suddenly find out null, then something has prevented the module.  Probably, initialization did not work, or some elements disappeared in the DOM structure of the page.  Immediately I will make a reservation that I only pull the link to the item once.  The rest of the time it is stored inside the module and instead of: <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"#name"</span></span>).html(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br>  I will have: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nodes.name; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(node) node.innerHTML = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/5a5/b1d/6f1/5a5b1d6f1515eabef26abd140551c518.png" alt="image"><br><br><h3>  Stubs and Moki </h3><br>  I will quote Sergey Teplyakov: <br><blockquote>  Honestly, I'm not a big fan of design changes just for the sake of code ‚Äútestability‚Äù.  As practice shows, a normal OO design either is already sufficiently ‚Äútestable‚Äù or requires only minimal gestures to make it so.  Some additional thoughts about this can be found in the article ‚ÄúIdeal architecture‚Äù. </blockquote><br>  The original can be viewed here <a href="http://habrahabr.ru/post/134836/">http://habrahabr.ru/post/134836/</a> <br><br>  If you have never heard of them, then a stub is like a server, or some external fake object that produces different results when it is accessed.  So say the object is a stub for tests.  Moki is the same thing, only they still consider the statistics that they jerked and how many times. <br><br>  <b>Need to change something on the test server?</b> <br>  - No, we just put the stub in place of the AJAX request. <br><br>  <b>Need to change something in the place of an AJAX request in the application code?</b> <br>  - No, we can change the request function in the library without touching our code.  And therefore it doesn‚Äôt matter where and how many times the function will be called - it will always pull the stub. <br><br>  For example, you have the code: <br><br><pre> <code class="javascript hljs">$.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">"ajax/test.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ alert(data.message); } });</code> </pre><br>  Instead of parsing it for tests and pulling out a callback, it's better to parse ajax.  We again come from the library API, without touching our code.  Yes, of course, it is not easy to disassemble jQuery or another library and ‚Äústick‚Äù our probes into it, but you can always write your own thin layer between the library and the code.  This will not only allow you to push through tests without pain and make the substitution of real objects for stubs, but with an additional bonus you will be able to roll from one framework to another. <br><br>  It is clear that such tests are hardcorn and can only show some obvious bugs.  But this is better than nothing.  In addition, they do not require any effort to support them and writing.  Launched for a tick, made sure that everything seems to have worked, write on.  Another plus of such autotests is that they can be taught juniors, and when they get used and stop being afraid of tests, start writing normal unit tests. <br><br><h3>  Auto documentation </h3><br>  Getting yourself to write documentation is difficult.  Making others write documentation is almost impossible.  But you can start small, make reasonable arguments and give tools that will slowly help.  In my projects in i-Free, I added another solution.  As mentioned above, all modules have test.add () at the end;  And after the application is initialized, a certain array is obtained that stores references to all modules.  You can run through this array, and since the modules are objects, make up their tree.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> _methodA -&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_methodB</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_methodC</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span></span></code> </pre><br>  And also get information on statistics: a list of external methods, a list of internal methods, etc.  In the simplest case, we just need to sign this tree: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> _methodA -&gt;  . _methodB -&gt;     . _methodC -&gt;    . init -&gt;  .</code> </pre><br>  Since  we also have access to the list of all assigned events, we can filter them and get lists of what the module listens and publishes.  An example of how it looks in life: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f12/e80/3c0/f12e803c0b695f6b356bd50565b08c89.png" alt="image"><br><br>  According to the received logs, you can briefly compile a module description: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e8/dba/fae/5e8dbafae7c3d4ef9cf3f57b57d216be.png" alt="image"><br><br>  By such an analysis of the code, you can show Junior the moments that he should describe in the documentation and explain in the code.  And viewing the structure of a module in a short form can show you and colleagues that, perhaps, some methods of the object should be swapped, because  their order is somewhat not logical for understanding the process. </div><p>Source: <a href="https://habr.com/ru/post/216453/">https://habr.com/ru/post/216453/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216435/index.html">Compare reflection performance in JDK8 and JDK7</a></li>
<li><a href="../216437/index.html">Autonomous quadcopter from scratch: PID and rake</a></li>
<li><a href="../216441/index.html">GOG.com ported classic Linux games</a></li>
<li><a href="../216445/index.html">Infographic Voyager 1: 36 years on the road, distance from the Earth 19'010'023'115 km</a></li>
<li><a href="../216449/index.html">Parsing formulas in 40 lines</a></li>
<li><a href="../216455/index.html">As a programmer from Russia to enter Stanford University in California</a></li>
<li><a href="../216457/index.html">MirrorMoon EP - in search of the cherished planet</a></li>
<li><a href="../216461/index.html">Samba4 + GlusterFS</a></li>
<li><a href="../216463/index.html">Habr, hello!</a></li>
<li><a href="../216465/index.html">Use of the developer RAWTherapee in applied tasks of the amateur photographer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>