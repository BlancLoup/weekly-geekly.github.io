<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java serialization: how to look inside the black box</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From time immemorial in Java there is a wonderful serialization mechanism that allows, without any special mental effort, to save as a sequence of byt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java serialization: how to look inside the black box</h1><div class="post__text post__text-html js-mediator-article">  From time immemorial in Java there is a wonderful serialization mechanism that allows, without any special mental effort, to save as a sequence of bytes arbitrarily complex object graphs.  The storage format is well documented, there are a lot of examples, serialized objects ‚Äúweigh‚Äù quite a bit, are sent over the network at times, there are a lot of possibilities for customization ... It all sounds great, but only until you are left alone. some multi-megabyte binary file containing very, very valuable and necessary data right now. <br><br>  How to get into this file with your bare hands and understand what is stored inside this huge serialized object graph, without having the source code?  These and many other questions can be answered by <a href="https://weblogs.java.net/blog/emcmanus/archive/2007/06/disassembling_s.html">Serialysis</a> - a library that will allow you to analyze in detail serialized java-objects (the <i>serialized form</i> is my version of the translation of the expression serial forms, decided not to go far from the original).  In this way, you can get information about an object that is not available through its public API.  The library is also a useful tool for testing the serialization of your own classes. <br><a name="habracut"></a><br><br>  <i><b>From the translator:</b></i> <br>  Saturday.  Evening.  Nothing foreshadowed the work on this day, but suddenly I remember that it would be nice to check how our job at the hadoop cluster was doing, just like that, to calm the conscience - because the problem was solved ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>&lt;Lyrical digression&gt;</i> <br>  In the past few days, quite a lot of tasks began to end with OutOfMemoryError on our hadoop cluster in production, there was no more possibility to increase the amount of allocated memory, and we with the IT department spent a fair amount of time trying to find the cause.  It ended with the fact that our American colleague thoughtfully looked at the configs, corrected a couple of lines, and said that the problem was solved. <br>  And indeed, everything was fine on Friday, and we once again rejoiced at having <a href="http://university.cloudera.com/certification/CCDH">Cloudera Certified Developer</a> in the team. <br>  <i>&lt;/ Lyrical digression&gt;</i> <br><br>  But it was not there! <br>  Khadup showed that not a single task was fulfilled on this ill-fated Saturday. <br>  The cause of the crashes was somewhat different from the previous one: the task tracker could not start the task because it did not have enough memory to load the task's xml-file. <br><br>  Of course, I immediately wondered what kind of monstrous configurations are stored there?  Alas, most of it was a serialized blob of about fifty megabytes.  A blob consists of a graph of objects of a dozen different classes for which I certainly do not have source codes. <br><br>  So what can be done with this multi-megabyte binary on a Saturday night with the help of improvised means only? <br><br>  This is where my savior comes on the scene: Serialysis.  A couple of lines of code - and in my hands there is a complete dump of the internals of a serialized object, with the names of classes and fields.  Having a full dump in my hands, I find the problem, turn on gzip compression for the dictionary of strings, patch classes using <a href="http://set.ee/jbe/">JBE</a> .  Voila - the problem is solved! <br><br>  This is a hack, of course, but sometimes without hacks - nowhere. <br><br>  PS The library is long-standing, but at the moment it turned out to be most welcome.  To admit, some of the applications that the author has found for the library, seem to me very strange.  For God's sake, well, they did not let me know the port, which means it is not very necessary!  In my opinion, the best use of this technology is debugging and troubleshooting of all kinds, in this area there really isn‚Äôt any equal. <br><br>  <b>Actually, the article:</b> <br><br><h5>  When a public API is not enough </h5><br>  The reason for writing the Serialysis library is that I ran into some tasks when I needed information about the object, which I could not get through the public API, but it was available through a serialized form. <br><br>  For example, you have a stub for a remote RMI object, and you want to know what address or port it will connect to, or which <a href="http://java.sun.com/javase/6/docs/api/java/rmi/server/RMIClientSocketFactory.html">RMI socket factory (RMIClientSocketFactory)</a> will use.  The standard RMI API does not provide a way to extract information from a stub.  In order for the stub to function after deserialization, this information must be present in serialized form.  Therefore, we could get the necessary information if only we could somehow disassemble the serialized stub. <br><br>  The second example is taken from the <a href="http://java.sun.com/javase/6/docs/api/javax/management/package-frame.html">JMX API</a> .  Requests to the MBean server are represented by the <a href="http://java.sun.com/javase/6/docs/api/javax/management/QueryExp.html">QueryExp</a> interface.  The QueryExp examples are built using the methods of the <a href="http://java.sun.com/javase/6/docs/api/javax/management/Query.html">Query class</a> .  If your object belongs to QueryExp, how do you know which queries it performs?  The JMX API does not offer any way to find out.  Information must be presented in a serialized form so that when a client makes a request to a remote server, it may be restored on the server.  If we can see the serialized form, we can determine what the request was. <br><br>  The second example prompted me to write this library.  Existing standard JMX connectors are based on Java serialization, so they do not require any special handling of QueryExps.  But in the new web services <br>  The connector introduced in <a href="http://jcp.org/en/jsr/detail%3Fid%3D262">JSR 262 is</a> used by XML for serialization.  How to analyze QueryExp, then to convert it to XML?  The answer is simple: the WS connector uses the version of this library to look inside the serialized QueryExp. <br><br>  All these examples have one thing in common: they show gaps in the corresponding APIs.  So, we need methods to extract information from the RMI stub.  Just as you need a way to convert QueryExp back to the original Query method that spawned it.  (Even standard parsing toString () is enough for parsing).  But there are no such methods now, and if we want code that will work with these APIs in their current form, we need a different approach. <br><br><h5>  We penetrate into private fields of objects </h5><br>  If you have the source code of the classes you are interested in, then there is a great temptation to just get in and get the desired data.  In the example with the RMI stub, we can find out by experiment that the <a href="http://java.sun.com/javase/6/docs/api/java/rmi/server/RemoteObject.html">getRef ()</a> stub method returns sun.rmi.server.UnicastRef, and examining the JDK sources, we find out that this class contains a field of the ref type sun.rmi.transport.LiveRef, like Once with the information that we need.  So we‚Äôll get something like this (but I‚Äôll say in advance, don‚Äôt do it): <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.rmi.server.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sun.rmi.transport.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.rmi.*; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.rmi.server.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StubDigger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RemoteStub stub)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ RemoteRef ref = stub.getRef(); UnicastRef uref = (UnicastRef) ref; Field refField = UnicastRef.class.getDeclaredField(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>); refField.setAccessible(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); LiveRef lref = (LiveRef) refField.get(uref); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lref.getPort(); } }</code> </pre> <br>  Perhaps the result will suit you perfectly, but, I repeat, I do not advise doing this - this code is no good.  First, never use the dependency on the classes sun. *, Because no one can guarantee that they will not change beyond recognition with any update of the JDK, moreover, your code will definitely not be easy to port to other JDK platforms.  Secondly, when you see something like <a href="http://java.sun.com/javase/6/docs/api/java/lang/reflect/AccessibleObject.html">Field.setAccessible</a> , then you should take it as a stop sign.  This means that your code depends on undocumented fields, which may change from release to release, or worse, which may persist, but with modified semantics. <br><br>  (This code was written for JDK 5. As it turned out, LiveRef acquired the public getPort () method in JDK 6, so you no longer need Field.setAccessible. But in any case, you shouldn‚Äôt depend on sun. * Classes.) <br><br>  Of course, sometimes it will not work to find a better solution.  But if those classes that you are seriously interested in turned out to be serializable, then it is quite possible that you will succeed.  The fact is that the serialized form of a class is part of its contract.  If the API is not completely lost, then its external contract will be compatible with its previous versions.  This is a very important condition, in particular for the JDK platform. <br><br>  So if the necessary information is not available through the public methods of the classes, but at least it is part of a documented serialized form, then it can be hoped that it will continue to remain unchanged in serialized form. <br><br>  The description of the serialized form is included in the Javadoc in the "See Also" section for each class being sold.  You can find the serialized forms of all publicly available JDK classes <a href="http://java.sun.com/javase/6/docs/api/serialized-form.html">here</a> on one huge page. <br><br><h5>  Hello, Serialysis! </h5><br>  My library for receiving metadata of serialized objects is called Serialysis, from the connection of the words ‚Äúserial analysis‚Äù. <br><br>  Let me give you a simple example of how this works.  This code ... <br><br><pre> <code class="java hljs"> SEntity sint = SerialScan.examine(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">5</span></span>)); System.out.println(sint);</code> </pre><br>  ... will bring this ... <br><br><pre> <code class="java hljs">SObject(java.lang.Integer){ value = Prim(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>){<span class="hljs-number"><span class="hljs-number">5</span></span>} }</code> </pre> <br>  This suggests that an object of type java.lang.Integer, which we passed to SerialScan.examine, is serialized as an object with a single field of type int inside.  If we check the <a href="http://java.sun.com/javase/6/docs/api/serialized-form.html">documented serialized java.lang.Integer form</a> , we will see that this is exactly what was expected. <br><br>  If you look at the java.lang.Integer source code, you will see that the class itself also has a single value field of type int: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * The value of the &lt;code&gt;Integer&lt;/code&gt;. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@serial</span></span></span><span class="hljs-comment"> */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value;</code> </pre><br>  But private fields are implementation details.  In the update, the field can be renamed or replaced with a new one inherited from the parent class <a href="http://java.sun.com/javase/6/docs/api/java/lang/Number.html">java.lang.Number</a> , or any other.  And there is no guarantee that this will not happen, but there is a guarantee that the serialized form will remain unchanged.  Serialization provides a <a href="http://java.sun.com/javase/6/docs/platform/serialization/spec/serial-arch.html">mechanism to save the serialized form</a> in its original form, even if the class fields have changed. <br><br>  Here is a more complex example.  Suppose that for some reason we want to know how big the array is inside an <a href="http://java.sun.com/javase/6/docs/api/java/util/ArrayList.html">ArrayList</a> .  The API does not give us the necessary information, although it allows us <a href="http://java.sun.com/javase/6/docs/api/java/util/ArrayList.html">to force</a> us <a href="http://java.sun.com/javase/6/docs/api/java/util/ArrayList.html">to select an array of not less than the specified one.</a> <br><br>  If we look at the <a href="http://java.sun.com/javase/6/docs/api/serialized-form.html">serialized form of ArrayList</a> , we will see that it contains the information we are looking for.  It indicates the serialized size field, which is the number of items in the list, but this is not what we need.  But the binary data in the WriteObject method just contains what you need: <br><br>  <i><b>Serial Data:</b></i> <br>  <i>contains the length of the ArrayList internal array, followed by all the elements (each as an object) in the specified order.</i> <br><br>  If we run this code ... <br><br><pre> <code class="java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;Integer&gt;(); list.add(<span class="hljs-number"><span class="hljs-number">5</span></span>); SObject slist = (SObject) SerialScan.examine(list); System.out.println(slist);</code> </pre><br>  ... then we get the following conclusion ... <br><br><pre> <code class="java hljs">SObject(java.util.ArrayList){ size = SPrim(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>){<span class="hljs-number"><span class="hljs-number">1</span></span>} -- data written by <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">writeObject</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SBlockData</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blockdata</span></span></span><span class="hljs-class">)</span></span>{<span class="hljs-number"><span class="hljs-number">4</span></span> bytes of binary data} SObject(java.lang.Integer){ value = SPrim(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>){<span class="hljs-number"><span class="hljs-number">5</span></span>} } }</code> </pre><br>  Here we fall into the dark jungle of serialization.  In addition to serializing the fields of an object, or instead of it, a class can have a writeObject (ObjectOutputStream) method that writes arbitrary data to a stream using methods of the type <a href="http://java.sun.com/javase/6/docs/api/java/io/ObjectOutputStream.html">ObjectOutputStream.writeInt</a> .  The class must also contain the corresponding readObject method, which reads the same data, and with the help of the <a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/javadoc.html">@serialData</a> tag, <a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/solaris/javadoc.html">you</a> should document what the WriteObject method writes, just as done in ArrayList. <br><br>  The writeObject data in Serialysis can be obtained through the SObject.getAnnotations () method, which returns a List.  Each object written using the <a href="http://java.sun.com/javase/6/docs/api/java/io/ObjectOutputStream.html">ObjectOutputStream.writeObject (Object)</a> method is represented in this list as a SObject.  Each piece of data written by one or more consecutive calls to ObjectOutputStream methods inherited from <a href="http://java.sun.com/javase/6/docs/api/java/io/DataOutput.html">DataOutput</a> ( <a href="http://java.sun.com/javase/6/docs/api/java/io/ObjectOutputStream.html">writeInt</a> , <a href="http://java.sun.com/javase/6/docs/api/java/io/ObjectOutputStream.html">writeUTF,</a> and so on) is represented as SBlockData.  The serialized stream does not allow to separate individual elements inside this piece;  this information is an agreement between the writer and the reader, documented in the @serialData tag. <br><br>  Based on the ArrayList documentation, we can get the size of the array in this way: <br><br><pre> <code class="java hljs">SObject slist = (SObject) SerialScan.examine(list); List&lt;SEntity&gt; writeObjectData = slist.getAnnotations(); SBlockData data = (SBlockData) writeObjectData.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); DataInputStream din = data.getDataInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> alen = din.readInt(); System.out.println(<span class="hljs-string"><span class="hljs-string">"Array length: "</span></span> + alen);</code> </pre><br><h5>  How Serialysis solves my test problems </h5><br>  Omitting the full source code, I‚Äôll only give a sketch of the solution to the QueryExp problem, which I mentioned at the beginning.  Suppose I have QueryExp built like this: <br><br><pre> <code class="java hljs">QueryExp query = Query.or(Query.gt(Query.attr(<span class="hljs-string"><span class="hljs-string">"Version"</span></span>), Query.value(<span class="hljs-number"><span class="hljs-number">5</span></span>)), Query.eq(Query.attr(<span class="hljs-string"><span class="hljs-string">"SupportsSpume"</span></span>), Query.value(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)));</code> </pre><br>  This means: ‚Äúgive me MBeans with a Version attribute greater than 5 or a SupportsSpume attribute equal to true‚Äù.  The toString () for this request in the JDK looks like this: <br><br><pre> <code class="java hljs">((Version) &gt; (<span class="hljs-number"><span class="hljs-number">5</span></span>)) or ((SupportsSpume) = (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>))</code> </pre><br>  And this is what the result of SerialScan.examine looks like: <br><br><pre> <code class="java hljs">SObject(javax.management.OrQueryExp){ exp1 = SObject(javax.management.BinaryRelQueryExp){ relOp = SPrim(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>){<span class="hljs-number"><span class="hljs-number">0</span></span>} exp1 = SObject(javax.management.AttributeValueExp){ attr = SString(String){<span class="hljs-string"><span class="hljs-string">"version"</span></span>} } exp2 = SObject(javax.management.NumericValueExp){ val = SObject(java.lang.Long){ value = SPrim(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>){<span class="hljs-number"><span class="hljs-number">5</span></span>} } } } exp2 = SObject(javax.management.BinaryRelQueryExp){ relOp = SPrim(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>){<span class="hljs-number"><span class="hljs-number">4</span></span>} exp1 = SObject(javax.management.AttributeValueExp){ attr = SString(String){<span class="hljs-string"><span class="hljs-string">"supportsSpume"</span></span>} } exp2 = SObject(javax.management.BooleanValueExp){ val = SPrim(<span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span>){<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>} } } }</code> </pre><br>  It is easy to imagine code that is immersed in this structure, creating an XML equivalent.  Each compatible JMX API implementation is required to create exactly the same serialized form, so the code that analyzes it is guaranteed to work anywhere. <br><br>  Now the code that solves the problem of <b>the port number in the RMI stub</b> : <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RemoteStub stub)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ SObject sstub = (SObject) SerialScan.examine(stub); List&lt;SEntity&gt; writeObjectData = sstub.getAnnotations(); SBlockData sdata = (SBlockData) writeObjectData.get(<span class="hljs-number"><span class="hljs-number">0</span></span>); DataInputStream din = sdata.getDataInputStream(); String type = din.readUTF(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.equals(<span class="hljs-string"><span class="hljs-string">"UnicastRef"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPortUnicastRef(din); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type.equals(<span class="hljs-string"><span class="hljs-string">"UnicastRef2"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPortUnicastRef2(din); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Can't handle ref type "</span></span> + type); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPortUnicastRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataInputStream din)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ String host = din.readUTF(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> din.readInt(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPortUnicastRef2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DataInputStream din)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> hasCSF = din.readByte(); String host = din.readUTF(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> din.readInt(); }</code> </pre><br>  To understand it, take a look at the description of the <a href="http://java.sun.com/javase/6/docs/api/serialized-form.html">serialized form of RemoteObject</a> . <br><br>  This code is, of course, difficult, but it is easy to port and promising to use.  I think it makes no sense to explain how to extract all other data from the RMI stubs - use the same method. <br><br><h5>  Conclusion </h5><br>  Most likely, you do not want to dig into serialized forms until there is a serious need.  But if you can not do without it, Serialysis is able to significantly simplify your task. <br><br>  In addition, it is a good way to check that your own classes are being serialized exactly as you would expect. <br><br>  Download the Serialysis library from here: <a href="">http://weblogs.java.net/blog/emcmanus/serialysis.zip</a> . </div><p>Source: <a href="https://habr.com/ru/post/195736/">https://habr.com/ru/post/195736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195720/index.html">Welding of optical fibers. Part 2: welding machines and cleavers, mechanical and welded splicing, measuring and laying fibers</a></li>
<li><a href="../195722/index.html">Romo: pet</a></li>
<li><a href="../195724/index.html">RWpod. 28 release 01 of the season. Details about Ruby 2.1.0, HTTP 2.0 gem, Semantic UI, Framer.js, etc.</a></li>
<li><a href="../195730/index.html">Macro for balancing outgoing calls to GSM in Asterisk</a></li>
<li><a href="../195732/index.html">The Good, the Bad and the Ugly code</a></li>
<li><a href="../195738/index.html">Create a private cloud using System Center Virtual Machine Manager 2012 R2</a></li>
<li><a href="../195740/index.html">Azul Zulu - JVM for the cloud or just the OpenJDK port on Windows?</a></li>
<li><a href="../195742/index.html">We give the project in good hands</a></li>
<li><a href="../195744/index.html">Review of the Apple MacBook Air mid 2013 laptop on the Haswell processor</a></li>
<li><a href="../195746/index.html">Give the remote multicopter!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>