<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Online algorithms in high-frequency trading: problems of competition</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="High Frequency Trading [eng. High-frequency trading, HFT-trading] today has a big impact on modern financial markets. Twenty years ago, most of the tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Online algorithms in high-frequency trading: problems of competition</h1><div class="post__text post__text-html js-mediator-article"> <a href="http://habrahabr.ru/company/itinvest/blog/270813/"><img src="https://habrastorage.org/files/c21/14a/94c/c2114a94c81b40cbaf9fe4a523a7febd.jpg"></a> <br><br>  High Frequency Trading [eng.  High-frequency trading, HFT-trading] today has a big impact on modern financial markets.  Twenty years ago, most of the trading took place on stock exchanges, for example, on the New York Stock Exchange, where people dressed in bright costumes actively gesticulated and shouted their offers to buy or sell securities.  Today, trading is usually carried out using electronic servers in data centers, where computers exchange offers to buy and sell by sending messages over the network.  This transition from trading in the operational building of the exchange to electronic platforms was especially beneficial for HFT companies, which invested a lot in the necessary infrastructure for trading. <br><br>  In spite of the fact that the place and participants of trade externally changed a lot, the goal of traders - both electronic and ordinary - remained unchanged - to acquire an asset from one company / trader and sell it to another company / trader at a higher price.  The main difference between a traditional trader and a HFT trader is that the latter can trade faster and more often, and the retention time of such a trader‚Äôs portfolio is very low.  One operation of a standard HFT algorithm takes a fraction of a millisecond, which traditional traders cannot match, since a person blinks about once every 300 milliseconds.  As HFT algorithms compete with each other, they face two problems: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Every microsecond they process a large amount of data; </li><li>  They need to be able to react very quickly on the basis of these data, because the profit they can extract from the signals they receive decreases very quickly. </li></ul><br>  <i>Online algorithms</i> are a common class of algorithms that can be used in HFT trading.  In such algorithms, new input variables arrive sequentially.  After each new input variable is processed, the algorithm must make a specific decision, for example, whether to place a buy / sell request.  This is the main difference between online algorithms and offline algorithms, in which it is assumed that all input data is available at the time of decision making.  Most of the problems of practical optimization in such areas as computer science and methods of research of operations are exactly online tasks [1]. <a name="habracut"></a><br><br>  In addition to solving online problems, HFT algorithms also need to respond extremely quickly to market changes.  To respond to a situation faster, an online trading algorithm must work efficiently with memory.  Storing a large amount of data reduces the speed of any computer, so it is important that the algorithm uses the minimum amount of data and parameters that can be stored in high-speed memory, for example, in the first-level cache memory (L1).  In addition, this set of parameters should reflect the current state of the market and be updated as new variables become available in real time.  Thus, the smaller the number of parameters that need to be stored in memory, and the less calculations need to be made for each of these parameters, the faster the algorithm will be able to respond to market changes. <br><br>  Given the speed requirements and the online nature of HFT trading tasks, the class of single-pass algorithms can be successfully applied in HFT trading.  At each selected point in time, these input algorithms receive one data element and use it to update the set of available parameters.  After the update, one of the data elements is discarded, and thus only the updated parameters are stored in memory. <br><br>  When developing an HFT algorithm, three problems may arise.  The first is to estimate the moving average liquidity: solving this problem can help the HFT algorithm determine the size of the order that is most likely to be successfully executed on this electronic exchange.  The second is to estimate rolling volatility: solving this problem helps determine the short-term risk for a given position.  The third problem is based on the concept of linear regression, which can be used in pair trading of related assets. <br>  Each of these problems can be easily solved with the help of a single-pass online algorithm.  This article describes how to back-test a single-pass algorithm based on data taken from the book of limit orders for highly liquid stock investment funds, and gives recommendations on how to regulate the operation of these algorithms. <br><br><h4>  Online algorithms in HFT trading </h4><br>  One of the advantages of HFT traders over other market participants is the speed of reaction.  HFT companies can track any movement in the market - that is, the information contained in the book of limit orders - and on its basis make an appropriate decision within a few microseconds.  Although the actions of some HFT algorithms may be based on data from a source outside the market (say, when analyzing news reports, measuring temperature, or evaluating market trends), most make decisions solely on the basis of messages received directly from the market.  According to some estimates, quotes on the New York Stock Exchange are updated approximately 215,000 times per second [2].  The main task of HFT algorithms is to process the received data so that you can make the right decisions, for example, when you need to set a position or reduce risk.  The examples in this article take into account that HFT algorithms can see any price updates of the best bid or ask, including data on their sizes.  Such a subclass of data contained in the book of limit orders is often called information from the book of orders of the first level (Level-1). <br><br>  This article details three examples of online algorithms, each of which is intended for use in HFT trading: <br><br><ul><li>  <b>Online algorithm for calculating the expectation</b> .  Designed to find a parameter based on which you can predict the available liquidity, calculated as the sum of the size of the best bid and ask, over a fixed period of time in the future.  Determining this value can help estimate the size of the application, which will most likely be executed at the best price given this delay. </li><li>  <b>Online algorithm for calculating variance</b> .  It is intended to find a parameter, on the basis of which the realized volatility can be predicted at a fixed time interval in the future.  Determining this value can help assess the short-term risk of stockpiling. </li><li>  <b>Online algorithm for calculating the regression coefficient</b> .  Designed to find a parameter based on which you can predict the expected profit from holding the long and short positions of a pair of related assets.  Determining this value can help in creating a signal that is supplied in the case when a long and short position is most likely to be profitable. </li></ul><br>  In each of the three cases, the algorithm contains a single parameter, "alpha", that regulates the speed with which unnecessary information is discarded.  In Figure 1, blue indicates the approximate change in liquidity (the sum of the bid and ask values).  Red and green are the changes in the liquidity parameter with the values ‚Äã‚Äãof the parameter ‚Äúalpha‚Äù equal to 0.9 and 0.99, respectively.  Please note that as the alpha approaches unity, the signal level becomes more uniform and more accurately reflects the trend in the source data. <br><br><img src="https://habrastorage.org/files/b89/fcb/1c8/b89fcb1c89ff45f1839cbfb1d11084ad.png"><br><br>  <i>Fig.</i>  <i>1: Crude and online liquidity</i> <br><br>  Figure 2 shows the change in volatility for different values ‚Äã‚Äãof the alpha parameter in real time.  Note that, as in the previous case, as the alpha increases, the graph curve becomes smoother.  A higher alpha value gives a more even signal, but a high load of past data causes a lag from the current trend.  As will be shown later, the choice of a suitable alpha value will either give a more even signal, or reduce the lag from the trend. <br><br><img src="https://habrastorage.org/files/af3/110/0c2/af31100c2ba14e1c8eec55f31aebb764.png"><br><br>  <i>Fig.</i>  <i>2: Online volatility measurement for different alpha values</i> <br><br>  To show how the online regression algorithm works, we looked at time series composed of average prices for SPY and SSO shares ‚Äî two related exchange-traded investment funds (SSO ‚Äî the same SPY, but the amount of its borrowed funds is twice as large).  As shown in Figure 3, the relationship between these two assets in the process of their change during the day is close to linear.  Figure 4 shows the change in the expectation and the free term for two values ‚Äã‚Äãof "alpha". <br><br><img src="https://habrastorage.org/files/168/dfb/894/168dfb894b314f3aaecaca344e1c10de.png"><br><br>  <i>Fig.</i>  <i>3: Online Regression Algorithm</i> <br><br><img src="https://habrastorage.org/files/1d6/ebe/9a0/1d6ebe9a08094968bfd529c3bfccab1a.png"><br><br>  <i>Fig.</i>  <i>4: Change in expectation and idle for two alpha values</i> <br><br><h4>  Single Pass Algorithms </h4><br>  As the name implies, the single-pass algorithm reads an input variable exactly once and then discards it.  This type of algorithm effectively allocates memory, as it saves the minimum amount of data.  This section provides three important examples of single-pass algorithms: an exponentially moving average, an exponentially weighted variance, and an exponentially weighted regression.  The next section will discuss the use of these algorithms in HFT trading. <br><br>  To begin with, let's briefly review the concept of a simple moving average for a given time series.  It is an estimate of the mathematical expectation for a time series with a ‚Äúsliding‚Äù window of constant size.  In the financial sphere, this estimate is often used to determine the price trend, in particular, when comparing two values ‚Äã‚Äãof a simple moving average - in the case of a ‚Äúlong‚Äù window and in the case of a ‚Äúshort‚Äù window.  As an application, you can also consider a situation where the average trade volume over the past five minutes helps to predict the trade volume in the next minute.  In contrast to the exponential moving average, a simple moving average cannot be determined using a single-pass algorithm. <br><br>  Let (X <sub>t</sub> ) <sub>t</sub> = X <sub>0</sub> , X <sub>1</sub> , X <sub>2</sub> , ... be the sequence of received input variables. <br><br>  For each individual point in time t, we need to predict the value of the next variable X <sub>t + 1</sub> .  For M&gt; 0 and t ‚â• M, a simple moving average with a window of size M is defined as the mathematical expectation of the last M observations for the time series (X <sub>t</sub> ) <sub>t</sub> , i.e. <img src="https://habrastorage.org/files/a00/7fb/a49/a007fba49d13424f92753f0457d09c58.png">  .  The moving average can also be calculated using the following recursion: <br><br><img src="https://habrastorage.org/files/7f0/baa/52d/7f0baa52dddc4f56b45129c38e58b443.png">  .  (one) <br><br>  Although it is an online algorithm, however, it is not one-pass, because it has to process each input element twice: when it should be taken into account when calculating the moving average and when it should be excluded from the estimate.  Such an algorithm is called a two-pass algorithm and requires storage in memory of an entire array of size M. <br><br><h5>  Example 1: Single-pass algorithm of exponentially weighted average </h5><br>  Unlike the average <img src="https://habrastorage.org/files/3a9/d5e/a87/3a9d5ea8776240238ecba6d4fbd04f49.png">  The exponentially weighted average determines the exponentially decreasing values ‚Äã‚Äãof the weighting factors of previous observations: <br><br><img src="https://habrastorage.org/files/34c/50a/5b6/34c50a5b65044ff8ab6d2a56d9abe07e.png"><br><br>  Here Œ± is a weighted parameter that is chosen by the user and must satisfy the condition 0 &lt;Œ± ‚â§ 1. Due to the fact that the most recent input parameters play an important role for an exponentially weighted average, compared to earlier data elements, it is often considered to be quite accurate approximation of a simple moving average. <br><br>  Unlike a simple moving average, the exponentially weighted average takes into account all previous data, not just the latest M observations.  Moreover, if we continue to compare simple moving average and exponentially weighted average, in Figure 5 you can see how many data elements 80%, 90%, 95%, 99% and 99.9% of the weight function depends on Œ± are obtained during the assessment.  For example, if Œ± = 0.95, then the last M = 90 received data elements constitute 99% of the estimated value.  It should be noted that if the time series of (Xt) t is very ‚Äúheavy tails‚Äù, then the exponentially smoothed average may consist mainly of extreme observations, while the moving average less often depends on extreme observations, since they are ultimately excluded from the observation window.  Frequent repetition of the evaluation procedure can solve the problem of long-term data storage in memory with exponential smoothing. <br><br><img src="https://habrastorage.org/files/c25/b48/5d1/c25b485d1dc340bd87e6f2b2894cf66b.png"><br><br>  <i>Fig.</i>  <i>5: Moving average and weight parameter</i> <br><br>  The reason for choosing an exponentially moving average instead of a simple moving average for use in the HFT algorithm is that it can be determined using the single-pass algorithm first mentioned in the work of R.G.  Brown (1956) [3]. <br><br><img src="https://habrastorage.org/files/389/a97/d41/389a97d411fc49cfb07005000c5707af.png">  .  (2) <br><br>  This formula also indicates that using the parameter Œ± you can adjust the weights of the last observations by comparing them with the previous ones. <br><br><h5>  Example 2: One-pass algorithm of exponentially weighted variance </h5><br>  The exponential smoothing described in the previous section allows us to estimate the moving average for time series.  In finance, the volatility of time series often plays an important role.  In other words, volatility should reflect the frequency of fluctuations of time series relative to their average level.  In the financial theory of HFT trading there is no unique definition of volatility.  In this section, the volatility is treated as the standard deviation (square root of the variance) of the data element for time series (X <sub>t</sub> ) <sub>t</sub> .  As in the case of the exponentially weighted moving average from the previous section, you can develop a single-pass online algorithm that will estimate the volatility for time series based on a scheme of exponentially weighted coefficients. <br><br>  The variance of a random variable is determined by the formula Var (X) = E [X - E [X]) <sup>2</sup> ].  In order to estimate the exponentially weighted variance of time series, it is necessary first to estimate two parameters - the expectation E [X] and the variance: <br><br><img src="https://habrastorage.org/files/11d/e03/443/11de034430a34975ae2c9e807c9e4088.png"><br><br>  The standard deviation of each subsequent control point X <sub>t + 1</sub> is estimated as <img src="https://habrastorage.org/files/e09/610/a2f/e09610a2f5da4e70b66da09adece2b50.png">  .  In this example, the input parameter Œ± ‚àà (0,1) is also selected by the user and determines the values ‚Äã‚Äãof the weights of the past data, which are compared with the last of the received input data.  In this case, we take the initial value of the statistical estimate to be 1 - it [estimate], generally speaking, can take any value.  Another way is to enter a trial period during which the time series is monitored and, as an initial estimate, use the standard deviation estimate for time series in this ‚Äútest‚Äù window.  Of course, a similar method can also be used in determining the evaluation of an exponentially weighted average. <br><br><h5>  Example 3: Single-pass exponentially weighted linear regression algorithm </h5><br>  The latest example is a single-pass online algorithm based on an exponentially weighted linear regression model.  This model is similar to the model of ordinary linear regression, but unlike it, it focuses more attention (in accordance with exponential weighting) on ‚Äã‚Äãrecent observations than on earlier ones.  As already shown, such regression methods play an important role in HFT strategies and help determine the relationship between different assets, in particular, they can be used in pair trading strategies. <br><br>  In our model, we consider two-dimensional time series (X <sub>t</sub> , Y <sub>t</sub> ) <sub>t</sub> and assume that the variables X and Y are related by a linear relationship, which also includes the random error Œµ <sub>t</sub> with zero expectation, that is: <br><br><img src="https://habrastorage.org/files/072/af1/ca1/072af1ca19c64757a152c20d1cb8cd66.png">  .  (3) <br><br>  The variable Y is called the response variable, and the variable X is the explanatory variable.  For simplicity, we assume that we have one explanatory variable, although a generalization to several explanatory variables is not so difficult to make.  With the standard approach to the definition of linear regression using an offline algorithm, the parameters Œ≤ <sub>0</sub> and Œ≤ <sub>1 are</sub> selected after all the observations.  The data elements of each individual observation are recorded in a separate vector Y = (Y <sub>0</sub> , Y <sub>1</sub> , ..., Y <sub>t</sub> ) <sup>T</sup> or matrix <br><br><img src="https://habrastorage.org/files/bab/a74/ba4/baba74ba4d7d41e8a69c408f5c6b0e28.png"><br><br>  A column of units in the matrix X corresponds to the free term in equation 3. If we write the parameters Œ≤ <sub>0</sub> and Œ≤ <sub>1</sub> as the vector Œ≤ = (Œ≤ <sub>0</sub> , Œ≤ <sub>1</sub> ) <sup>T</sup> , then the ratio between Y and X can be compactly written in the matrix form: <br><br> <code>Y = XŒ≤ + Œµ</code> <br> <br>  where Œµ is the vector of stochastic errors, each of which has zero expectation. <br><br>  The most common approach to estimating the parameter Œ≤ is to use the standard method of least squares, that is, Œ≤ is chosen so that the sum of the squares of the remainder terms <img src="https://habrastorage.org/files/31c/989/1e3/31c9891e36b84fb095f3b0324eb3f2ef.png">  was minimal.  The solution to this minimization problem will be <img src="https://habrastorage.org/files/502/cbf/d55/502cbfd551cc499f90162c99be99c7fa.png">  . <br><br>  As in the estimation of the expectation and variance, later observations should play an important role in the estimation of the parameter Œ≤.  In addition, a single-pass algorithm for finding Œ≤ values ‚Äã‚Äãis necessary for performing calculations. <br><br>  Next, consider a recursive method that sequentially updates the values ‚Äã‚Äãof the vector Œ≤ and minimizes the expression: <br><br><img src="https://habrastorage.org/files/002/cb4/3a8/002cb43a845641fd8e55cc225d96e8bc.png"><br><br>  Recall that the parameter must be in the interval (0,1) and selected by the user.  The Œ≤ <sub>0 and</sub> Œ≤ <sub>1</sub> parameters using the weighted least squares method can be calculated using an efficient one-pass online algorithm.  At each step of the algorithm, the matrix M <sub>t of</sub> dimension 2 √ó 2 and the vector V <sub>t of</sub> dimension 2 √ó 1 must be stored in memory and updated as new data is received in accordance with the following recursive expressions: <br><br><img src="https://habrastorage.org/files/bcc/16a/d5b/bcc16ad5b3bc492abe1bfbd0ca040c25.png"><br><br>  As for the estimation of the expectation and variance, for them the initialization of recursion variables can be carried out in a trial period.  As a result, by the time t, the best estimate of Œ≤ will be calculated by the formula <img src="https://habrastorage.org/files/94f/78e/9c0/94f78e9c0def40e285ff0e8e77c5b46e.png">  .  In the literature, this method is called the recursive least squares method with exponential forgetting [2]. <br><br><h4>  Alpha score </h4><br>  How to determine the optimal value of "alpha", the only parameter used in each of the above models of online algorithms?  Our approach in each of the three models was to determine the response function, the value of which we want to predict, and to minimize the square of the difference between the response ri and our parameter f <sub>i</sub> : <br><br><img src="https://habrastorage.org/files/7ce/a4c/5bb/7cea4c5bb07c410b8db7f1e9fc427502.png"><br><br>  This method allows you to determine the optimal value of "alpha" on the basis of historical time series.  Another approach is to estimate the optimal value of "alpha", which is also carried out in real time.  However, it requires more work and is beyond the scope of this article. <br><br>  Now let's take a closer look at the described estimates of online algorithms and estimate the optimal value of ‚Äúalpha‚Äù on a particular data set. <br>  1. The estimate of the average liquidity is calculated by the formula: <br><br><img src="https://habrastorage.org/files/5ba/a86/eef/5baa86eefa1d4345ac538726474f3ffb.png"><br><br>  where the index i denotes the point in time when the quote was set.  The response function is defined as liquidity, which is observed after ten seconds: <br><br><img src="https://habrastorage.org/files/dd9/c22/568/dd9c22568e0448dcac176a2950935743.png"><br><br>  where the term b <sub>si</sub> (10) is the bid size ten seconds after setting the i-th quotation.  After the optimization with the alpha parameter, it was shown that the optimal alpha value for our data is 0.97.  It is presented in Figure 6 as a scatterplot for the desired parameter and response function: <br><br><img src="https://habrastorage.org/files/cf4/e8b/382/cf4e8b382ee842ae8d028b63bf4ca3cb.png"><br><br>  <i>Fig.</i>  <i>6: The scatterplot for the desired parameter and the response function for the value of "alpha" 0.97</i> <br><br>  2. The estimation of volatility is determined by the formulas: <br><br><img src="https://habrastorage.org/files/d70/b54/24f/d70b5424fc8f426f93815d96f3db56b4.png"><br><br><img src="https://habrastorage.org/files/487/31e/124/48731e124f5944749f097988da4ecad0.png"><br><br><img src="https://habrastorage.org/files/0f9/a3f/ace/0f9a3facede94cf0adb943610a43e839.png"><br><br>  where the index i denotes the current time in seconds.  The magnitude of the response is defined as the realized volatility for the last minute: <br><br><img src="https://habrastorage.org/files/f08/a39/23e/f08a3923ed2f467ca8658632c016baf6.png"><br><br>  As in the previous case, as a result of sorting the values ‚Äã‚Äãof the alpha parameter, the optimal value for our data set turned out to be 0.985.  Figure 7 shows the scatterplot for the desired parameter and response function: <br><br><img src="https://habrastorage.org/files/62a/611/1fa/62a6111faa894c3c8313c839541402b6.png"><br><br>  <i>Fig.</i>  <i>7: Scatterplot and Response Function for Alpha 0.985</i> <br><br>  3. The regression estimate for pair trading is found by the formulas: <br><br><img src="https://habrastorage.org/files/041/c1a/6fd/041c1a6fdb1f4504952eb762bbab3dae.png"><br><br><img src="https://habrastorage.org/files/26d/094/6b0/26d0946b02c34205ab196d866c473e6f.png"><br><br><img src="https://habrastorage.org/files/44d/353/001/44d353001de54e42845485d3f35138e1.png"><br><br><img src="https://habrastorage.org/files/d21/b70/2fe/d21b702fe59a4d9597225949150b5b3c.png"><br><br>  where the index i denotes the point in time when the quote was set.  Parameter <img src="https://habrastorage.org/files/e73/f69/4b1/e73f694b15744ea1a43a879480f0ef6c.png">  denotes the value of SPY stocks compared to SSO stocks, that is, if their difference is positive, then SPY stocks are relatively cheaper, and holding a long position on SPY is likely to be profitable. <br><br>  The response function is defined as the profit received in the last minute from the transaction, which consists of holding a long position per SPY share and a short position on Œ≤ SSO shares: <br><br><img src="https://habrastorage.org/files/99b/0e0/88b/99b0e088b87e4e3b99a0ede40bef8724.png"><br><br>  Where <img src="https://habrastorage.org/files/01f/a18/abd/01fa18abdce24878aa7b5519654c5395.png">  represents the value of the SPY stock 60 seconds after setting the value <img src="https://habrastorage.org/files/7e2/026/fcd/7e2026fcde094ebb87d5c5856282ca11.png">  .  The response r <sub>i</sub> indicates the profitability of the following strategy for holding a long and short position: ‚ÄúBuy one share of SPY and sell Œ≤ shares of SSO at time i, close the position after 60 seconds‚Äù. <br><br>  The alpha value of 0.996 turned out to be optimal on the studied data set.  Figure 8 shows the scatterplot for the desired parameter and response function: <br><br><img src="https://habrastorage.org/files/b61/658/d38/b61658d38f5c4086b3952bd0f3558980.png"><br><br>  <i>Fig.</i>  <i>8: Scatter diagram and response function for alpha 0.996</i> <br><br><h4>  Conclusion </h4><br>  Single-pass online algorithms are an effective tool in HFT trading, where every microsecond they have to process large amounts of data and make decisions based on them very quickly.  In this article, three problems faced by HFT algorithms were considered: the estimation of the moving average liquidity needed to determine the size of the order that is most likely to be executed successfully on a specific electronic exchange;  estimation of volatility required to calculate the short-term risk of a transaction;  sliding linear regression, which can be used in pair trade related assets.  Single-pass online algorithms can play a key role in solving these problems. <br><br>  Another important factor for HFT merchants, which we often write about in a blog on Habr√©, is the speed of work.  One of the frequently used technologies to increase the speed of data acquisition and processing is <a href="http://www.itinvest.ru/services/access/">direct access to the exchange</a> , which is organized using various financial information transfer protocols.  We considered the technology of direct access in <a href="http://habrahabr.ru/company/itinvest/blog/204620/">this article</a> , and wrote about data transfer protocols here ( <a href="http://habrahabr.ru/company/itinvest/blog/242789/">one</a> , <a href="http://habrahabr.ru/company/itinvest/blog/243657/">two</a> , <a href="http://habrahabr.ru/company/itinvest/blog/261709/">three</a> ). <br><br><h5>  Notes: </h5><br><ol><li>  Albres S. 2003. Online Algorithms: Analysis.  Mathematical programming 97 (1-2): 3-26. </li><li>  Clark K. 2011. Improving the speed and transparency of market data.  Exchange.  <a href="https://whatheheckaboom.wordpress.com/2013/10/20/acm-articles-on-hft-technology-and-algorithms/">whatheheckaboom.wordpress.com/2013/10/20/acm-articles-on-hft-technology-and-algorithms</a> , <a href="http://www.utpplan.com/">www.utpplan.com</a> . </li><li>  Brown, R. G. 1956. Exponential smoothing for demand forecasting.  Arthur D. Little Inc., p.  15. </li><li>  Astrom A., Wittenmark B. 1994. Adaptive management, second edition.  Addison Wesley. </li></ol><br><br>  <b>About the authors:</b> <br><br>  <b>Jacob Loveless</b> is the executive director of Lucera and former head of high-frequency trading at Cantor Fitzgerald.  Over the past ten years, Mr. Loveless managed to try himself in electronic commerce with virtually every asset in various HFT companies and on various exchanges.  Prior to his career in the financial field, Mr. Lavless was in the position of a special contractor for the US Department of Defense, where he specialized in heuristic analysis of secret data.  Prior to that, he was also the Chief Technical Officer (CTO) and founder of Data Scientific.  The founder of the analysis of distributed systems. <br><br>  <b>Sasha Stoikov</b> is a senior researcher at Cornell Financial Engineering Manhattan (CFEM) and a former vice president of high frequency trading at Cantor Fitzgerald.  He worked as a consultant to the Galleon Group and Morgan Stanley, and also lectured at the Institute.  Courant at New York University and at the Department of Production Management and Operations Research at Columbia University.  He received a Ph.D.  at the University of Texas and a bachelor's degree from the Massachusetts Institute of Technology. <br><br>  <b>Rolf Waeber</b> is a quantitative analyst at Lucera, and in the past he was engaged in quantitative research in the high-frequency trading department of Cantor Fitzgerald.  He participated in liquidity risk management research as part of the development of Basel II / III documents at the German Federal Bank.  In 2013, Rolf received a Ph.D. degree in Operations Research and Information Engineering from Cornell University.  In addition, he received bachelor's and master's degrees in mathematics from the higher technical school in Zurich, Switzerland. </div><p>Source: <a href="https://habr.com/ru/post/270813/">https://habr.com/ru/post/270813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270801/index.html">Was there anyone on the server?</a></li>
<li><a href="../270803/index.html">Lab penetration testing "Test lab v.8": welcome to hell</a></li>
<li><a href="../270805/index.html">Use Carthage to manage dependencies</a></li>
<li><a href="../270807/index.html">Microsoft has released a major update for Windows 10</a></li>
<li><a href="../270809/index.html">Voice control multimedia center</a></li>
<li><a href="../270815/index.html">Security Week 46: Versatile Java Bug, Life for Crypto-Folders, 17 Adobe Flash Patches</a></li>
<li><a href="../270821/index.html">Pirate metrics: how to create an email campaign based on the AARRR principle. Part 4</a></li>
<li><a href="../270823/index.html">First article about checking C # project</a></li>
<li><a href="../270825/index.html">Component-oriented C # engine</a></li>
<li><a href="../270827/index.html">PostgreSQL on multicore servers Power 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>