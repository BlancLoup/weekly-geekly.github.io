<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Var, let or const? Problems scopes variables and ES6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scopes in JavaScript have always been a difficult topic, especially when compared to more strictly organized languages, such as C and Java. For many y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Var, let or const? Problems scopes variables and ES6</h1><div class="post__text post__text-html js-mediator-article"> Scopes in JavaScript have always been a difficult topic, especially when compared to more strictly organized languages, such as C and Java.  For many years, the areas of visibility in JS have not been widely discussed, since the language simply did not have the means to significantly influence the current situation.  But in ECMAScript 6 some new features have appeared that allow developers to better control the scopes of variables.  These features nowadays support browsers very well, they are quite accessible to most developers.  However, new keywords for declaring variables, given the fact that the old <code>var</code> keyword has not gone away, mean not only new opportunities, but also the emergence of new questions.  When to use the keywords <code>let</code> and <code>const</code> ?  How do they behave?  In what situations is the <code>var</code> keyword still relevant?  The material, the translation of which we are publishing today, is aimed at studying the problem of the scope of variables in JavaScript. <br><br> <a href="https://habr.com/company/ruvds/blog/420359/"><img src="https://habrastorage.org/webt/v4/6q/as/v46qas_2e_rx9sypmgyz4trnhr0.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Variable scope: overview</font> </h2><br>  The scope of a variable is an important programming concept that, however, may confuse some developers, especially newbies.  The scope of a variable is the part of the program where this variable can be accessed. <br><br>  Take a look at the following example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs matlab">var myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  What will the <code>console.log</code> method display?  The answer to this question will not surprise anyone: it will output <code>2</code> .  The variable <code>myVar</code> declared outside of any function, which tells us that it is declared in the global scope.  Therefore, any function declared in the same scope can refer to <code>myVar</code> .  In fact, if we are talking about code executed in the browser, functions declared in other files connected to the page will even have access to this variable. <br><br>  Now take a look at the following code: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myVar</span></span></span><span class="hljs-function"> = 2; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMyVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(myVar)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Externally, its changes, compared with the previous example, are insignificant.  Namely, we just put the variable declaration inside the function.  What will <code>console.log</code> display now?  In fact, nothing, since this variable is not declared, and when you try to access it, you will get a message about the raw <code>ReferenceError</code> error.  This is because the variable, using the <code>var</code> keyword, is declared inside the function.  As a result, the scope of this variable is limited to the internal scope of the function.  It can be accessed in the body of this function; functions embedded in this function can work with it, but it is not available from the outside.  If we need a certain variable to be used by several functions that are on the same level, we need to declare this variable in the same place where these functions are declared, that is, one level above their internal scope. <br><br>  Here is one interesting observation: the code of most websites and web applications does not apply to the work of any one programmer.  Most software projects are the results of team development, and, moreover, they use third-party libraries and frameworks.  Even if one programmer is involved in the development of a certain site, he usually uses external resources.  Because of this, it is usually not recommended to declare variables in the global scope, since it is not possible to know in advance which variables will be declared by other developers whose code will be used in the project.  In order to circumvent this problem, you can use some techniques, in particular, the ‚Äú <a href="https://alistapart.com/article/the-design-of-code-organizing-javascript">Module</a> ‚Äù and <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IIFE patterns</a> when applying an object-oriented approach to JavaScript development, although the same effect allows you to achieve data and function encapsulation in ordinary objects.  In general, it can be noted that variables, the scope of which goes beyond the limits that they need, usually represent a problem with which to do something. <br><br><h2>  <font color="#3AC1EF">Var keyword problem</font> </h2><br>  So, we figured out the concept of "scope".  We now turn to more complex things.  Take a look at the following code: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(var i = 0; i &lt; 3; i++)</span></span></span><span class="hljs-function"> {   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i)</span></span></span><span class="hljs-function">; } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">varTest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  What gets to the console after it is executed?  It is clear that inside the loop the values ‚Äã‚Äãof the increasing counter <code>i</code> will be displayed: <code>0</code> , <code>1</code> and <code>2</code> .  After the cycle ends, the program continues to run.  Now we are trying to access the same counter variable that was declared in the <code>for</code> loop, outside of this loop.  What will come of it? <br><br>  After accessing <code>i</code> outside the loop, the console will get 3, since the <code>var</code> keyword is valid at the function level.  If you declare a variable using <code>var</code> , then you can access it in a function after exiting the construction where it was declared. <br><br>  This can become a problem when the functions become more complex.  Consider the following example: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  What gets to the console now?  <code>2</code> and <code>2</code> .  We declare the variable, initialize it with the number 1, and then try to override the same variable inside the <code>if</code> expression.  Since these two declarations exist in the same scope, we cannot declare a new variable with the same name, even though we obviously want to do just that.  As a result, the first variable is overwritten inside an <code>if</code> expression. <br><br>  This is the biggest disadvantage of the <code>var</code> keyword.  The scope of variables declared using it is too large.  This can lead to inadvertent overwriting of data and other errors.  Large scopes often lead to sloppy programs.  In general, a variable should have a scope that is limited by its needs, but not exceeding them.  It would be good to be able to declare variables whose scope is not as large as when using <code>var</code> , which would allow, if necessary, to use more stable and better error-protected software constructs.  In fact, ECMAScript 6 provides us with such opportunities. <br><br><h2>  <font color="#3AC1EF">New ways to declare variables</font> </h2><br>  The ECMAScript 6 standard (a new set of JavaScript capabilities, also known as ES6 and ES2015) gives us two new ways of declaring variables that are limited, compared to <code>var</code> , with a scope and some other features.  These are the <code>let</code> and <code>const</code> keywords.  Both that and another gives us a so-called block scope.  This means that when used, the scope can be limited to a block of code, such as a <code>for</code> loop or an <code>if</code> expression.  This gives the developer more flexibility in the choice of scopes of variables.  Consider new keywords. <br><br><h3>  <font color="#3AC1EF">‚ñçUsing the let keyword</font> </h3><br>  The <code>let</code> keyword is very similar to <code>var</code> , the main difference is the limited scope of variables declared with it.  Rewrite one of the above examples, replacing <code>var</code> with <code>let</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } doSomething();</code> </pre> <br>  In this case, the numbers <code>2</code> and <code>1</code> will go to the console.  This happens because the <code>if</code> expression specifies a new scope for a variable declared with the <code>let</code> keyword.  This leads to the fact that the second declared variable is a completely independent entity, not connected with the first one.  You can work with them independently.  However, this does not mean that nested blocks of code, such as our <code>if</code> expression, are completely cut off from the variables declared with the <code>let</code> keyword in the scope in which they themselves are located.  Take a look at the following code: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  In this example, the number <code>1</code> will appear in the console.  The code inside the <code>if</code> expression has access to the variable we created outside of it.  Therefore, he displays its value in the console.  What happens if you try to shuffle the scopes?  For example, do this: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar);   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>;   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); } } doSomething();</code> </pre> <br>  It may seem that the first call of <code>console.log</code> will display <code>1</code> , but in fact, when you try to execute this code, a <code>ReferenceError</code> error will appear, which tells us that the <code>myVar</code> variable for this scope is not defined or not initialized (the text of this error differs in different browsers).  In JavaScript, there is such a thing as raising variables to the upper part of their scope.  That is, if a variable is declared in some scope, JavaScript reserves space for it even before the command for its declaration is executed.  How exactly this happens is different when using <code>var</code> and <code>let</code> . <br><br>  Consider the following example: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(varTest); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> varTest = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letTest); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> letTest = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br>  In both cases, we try to use the variable before it is declared.  But the commands to output data to the console behave differently.  The first, using a variable that will later be declared using the <code>var</code> keyword, will output <code>undefined</code> - that is, what will be written to this variable.  The second command, which tries to access a variable that will later be declared using the <code>let</code> keyword, will issue a <code>ReferenceError</code> and tell us that we are trying to use the variable before it is declared or initialized.  What's the matter? <br><br>  But the point is that before executing the code, the mechanisms responsible for its execution look through this code, find out whether any variables will be declared in it, and, if so, they are lifted with space reserved for them.  At the same time, variables declared with the <code>var</code> keyword are initialized to <code>undefined</code> within their scope, even if they are accessed before they are declared.  The main problem here is that the value <code>undefined</code> in a variable does not always indicate that the variable is attempted to be used before it is declared.  Take a look at the following example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var1; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var1); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(var2); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  In this case, although <code>var1</code> and <code>var2</code> declared differently, both <code>console.log</code> calls will display <code>undefined</code> .  The point here is that the variables declared with <code>var</code> but not initialized are automatically written to the value <code>undefined</code> .  In this case, as we have said, variables declared with <code>var</code> , which are accessed before they are declared, also contain <code>undefined</code> .  As a result, if something goes wrong in such a code, it will not be possible to understand what exactly is the source of the error ‚Äî the use of an uninitialized variable or the use of a variable prior to its declaration. <br><br>  The place for variables declared with the <code>let</code> keyword is reserved in their block, but before they are declared they fall into the Temporal Dead Zone (TDZ).  This leads to the fact that they, before their declaration, cannot be used, and an attempt to access such a variable leads to an error.  However, the system knows the exact cause of the problem and reports this.  This is clearly seen in this example: <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var1; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var1); console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(var2); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> var2 = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Here, the first call of <code>console.log</code> will display <code>undefined</code> , and the second will cause a <code>ReferenceError</code> error, telling us that the variable has not yet been declared or initialized. <br><br>  As a result, if using <code>var</code> appears with <code>undefined</code> , we do not know the reason for this behavior of the program.  A variable can either be declared and uninitialized, or it may not yet be declared in this scope, but will be declared in code that is located below the command to access it.  When using the <code>let</code> keyword, we can understand what is happening, and this is much more useful for debugging. <br><br><h3>  <font color="#3AC1EF">‚ñçUsing the const keyword</font> </h3><br>  The <code>const</code> keyword is very similar to <code>let</code> , but they have one important difference.  This keyword is used to declare constants.  Values ‚Äã‚Äãof constants after their initialization cannot be changed.  It should be noted that this applies only to the values ‚Äã‚Äãof primitive types, water strings or numbers.  If a constant is something more complicated, for example, an object or an array, the internal structure of such an entity can be modified, you cannot just replace it with another.  Take a look at the following code: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">let</span></span> mutableVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> immutableVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">mutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">immutableVar</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  This code will be executed up to the last line.  Attempting to assign a new value to a constant will result in a <code>TypeError</code> error.  This is how constants behave, but, as already mentioned, the objects with which constants are initialized can be changed, they can undergo mutations, which can lead to <a href="https://alistapart.com/article/why-mutation-can-be-scary">surprises</a> . <br><br>  Perhaps you, as a JavaScript developer, wonder why immunity of variables is important.  Constants are a new phenomenon in JavaScript, while they are an essential part of languages ‚Äã‚Äãlike C or Java.  Why is this concept so popular?  The fact is that the use of constants makes us think about exactly how our code works.  In some situations, a change in the value of a variable may disrupt the operation of the code, for example, if it contains the number Pi and it is constantly being accessed, or if the variable has a link to some HTML element that you need to work with all the time.  Say, here is a constant in which a link to a certain button is written: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myButton = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#my-button'</span></span>);</code> </pre> <br>  If the code depends on the link to the HTML element, then we need to ensure that the link remains unchanged.  As a result, we can say that the <code>const</code> keyword goes not only along the path of improvements in the scope of visibility, but also along the path of limiting the possibility of modifying the values ‚Äã‚Äãof constants declared using this keyword.  Remember how we talked about the fact that a variable should have exactly the scope that it needs.  This idea can be continued by putting forward a recommendation that the variable should only have the opportunity to change, which is necessary for proper work with it, and nothing more.  <a href="https://zellwk.com/blog/dont-reassign/">Here is a</a> good material on the topic of immunity, from which an important conclusion can be drawn, according to which the use of immutable variables forces us to think more carefully about our code, which leads to an improvement in the purity of the code and to a decrease in the number of unpleasant surprises arising from its work. <br><br>  When I first started using the keywords <code>let</code> and <code>const</code> , I basically applied <code>let</code> , resorting to <code>const</code> only when writing a new value to a variable declared with <code>let</code> could harm the program.  But, learning more about programming, I changed my mind on this issue.  Now my main tool is <code>const</code> , and <code>let</code> me use <code>let</code> only when the value of a variable needs to be rewritten.  It makes me think about whether it is really necessary to change the value of some variable.  In most cases, this is not necessary. <br><br><h2>  <font color="#3AC1EF">Do we need the var keyword?</font> </h2><br>  The keywords <code>let</code> and <code>const</code> promote a more responsible approach to programming.  Are there any situations in which the <code>var</code> keyword is still needed?  Yes, there are.  There are several situations in which this keyword is still useful to us.  Think about what we are going to talk about before changing <code>var</code> to <code>let</code> or <code>const</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçvar level of keyword support by browsers</font> </h3><br>  Variables declared using the <code>var</code> keyword have one very important feature missing from <code>let</code> and <code>const</code> .  Namely, we are talking about the fact that this keyword is supported by absolutely all browsers.  Although the <a href="https://caniuse.com/">let</a> and <a href="https://caniuse.com/">const</a> browsers support is very good, however, there is a risk that your program will get into a browser that does not support them.  In order to understand the consequences of such an incident, you need to consider how browsers treat unsupported JavaScript code, as opposed to, for example, how they react to incomprehensible CSS code. <br><br>  If the browser does not support any CSS feature, then this basically leads to some distortion of what will be displayed on the screen.  A site in a browser that does not support any of the styles used by the site will not look as expected, but it is very likely you can use it.  If you use, for example, <code>let</code> , and the browser does not support this keyword, then your JS code will simply not work there.  It will not be - that's all.  Considering the fact that JavaScript is one of the important components of the modern web, this can be a very serious problem if you need your programs to work in outdated browsers. <br><br>  When they talk about the support of sites by browsers, they usually ask themselves in which browser the site will work optimally.  If we are talking about a site whose functionality is based on using <code>let</code> and <code>const</code> , then a similar question will have to be put differently: ‚ÄúIn which browsers will our site not work?‚Äù.  And this is much more serious than talking about whether or not to use <code>display: flex</code> .  For most websites, the number of users with outdated browsers will not be large enough to be worth worrying about.  However, if we are talking about something like an online store, or sites whose owners buy advertising, this can be a very important consideration.  Before using new opportunities in such projects, assess the level of risk. <br><br>  If you need to support really old browsers, but you want to use <code>let</code> , <code>const</code> and other new features of ES6 while doing this, one of the solutions to this problem is to use a JavaScript transpiler like <a href="https://babeljs.io/">Babel</a> .  Transporters provide a translation of the new code into what will be clear to the old browsers.  Using Babel, you can write modern code that uses the latest features of the language, and then convert it to code that older browsers can perform. <br><br>   ,   ?   ,        . ,      ,     ,     ,   .  ,   .  ,      ,      .     ES6-,     Babel,   Babel   ,      ,   .      ,      ,      .     .     ?   -  IE8     ? ,           ,  ,   ,  ,     . <br><br><h3> <font color="#3AC1EF">‚ñç var     </font> </h3><br>    ,     <code>var</code>  ,    .    .   : <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,     myVar    ! }</span></span></code> </pre> <br> ,     <code>myVar</code>    ,      ,        .  ,         .     ,    , ,    ,      .     ,        .        <code>var</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(window.myVar); // 1 }</span></span></code> </pre> <br>          <code>var</code> ,       <code>window</code> .   <code>let</code>  <code>const</code>   .       ,     JS-   ,          (,  ,     )  ,     . <br><br>  ,         .       ,           .    ,  ,   ,    : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myGlobalVars = {}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">1</span></span>; myGlobalVars.myVar = myVar; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myVar = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myVar); <span class="hljs-comment"><span class="hljs-comment">// 2 console.log(myGlobalVars.myVar); // 1 }</span></span></code> </pre> <br> ,     ,     ,      , .   ,  ,      <code>var</code>  , ,     ,   ,  ,   . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br> ,  ?   ?      : <br><br><ul><li>    IE10  -  ?              ‚Äî       <code>var</code> . </li><li>         JavaScript,    ,  ,      <code>var</code> ,  <code>const</code> .  -      (,      ,        ) ‚Äî  <code>let</code> . </li></ul><br>    <code>let</code>  <code>const</code> ,   ECMAScript 6,           ( )   -  -.       ,    ,       ,    . ,    - ,    ¬´¬ª  ¬´¬ª     , ,  <code>let</code>  <code>const</code> ,          . <br><br>  <b>Dear readers!</b>     ,       <code>const</code>       <code>var</code> ,   <code>let</code>    ,   ,   ,  ? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/420359/">https://habr.com/ru/post/420359/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420349/index.html">Checklist IT-outsourcing: working without risks</a></li>
<li><a href="../420351/index.html">How to search for users on GitHub using Vue</a></li>
<li><a href="../420353/index.html">Making Shrimp More Useful: Adding Recoding Images to Other Formats</a></li>
<li><a href="../420355/index.html">Pebble smartwatch: how to become a rarity overnight</a></li>
<li><a href="../420357/index.html">Vuex: structuring large projects and working with modules</a></li>
<li><a href="../420361/index.html">Bug when working TextBox.GetLineText in .NET WPF</a></li>
<li><a href="../420363/index.html">HPE webinars in August-October: new topics (+ storage, AI practice, turnkey petabyte storage)</a></li>
<li><a href="../420367/index.html">Air-conditioned apocalypse: blackout scenario of the grid using smart climate instruments</a></li>
<li><a href="../420369/index.html">Extreme Extended Edge, or IEEE 802.1BR based switching</a></li>
<li><a href="../420371/index.html">To the issue of bicycle engineering in the field of electromail posting</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>