<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The DataBanding Revolution with Object.Observe ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Revolution is coming. There is a new addition to JavaScript, which will change everything that you have ever known about date-buying. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The DataBanding Revolution with Object.Observe ()</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Revolution is coming.  There is a new addition to JavaScript, which will change everything that you have ever known about date-buying.  In addition, your MVC libraries' approach to observing editing and updating models will also change.  You are ready? <br><br>  Good good.  We will not pull.  I'm glad to introduce Object.observe (), which appeared in the beta version of Chrome 36. [CROWD ELIMINATES] <br><br>  Object.observe () is part of the following ECMAScript standard.  It allows you to asynchronously track changes to JavaScript objects ... without using any third-party libraries, it allows the observer to track changes in the state of an object over time. <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,        var model = {}; //      Object.observe(model, function(changes){ //     , changes.forEach(function(change) { //   ,   console.log(change.type, change.name, change.oldValue); }); });</span></span></code> </pre> <br>  Every time an object changes, we receive an alert: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/075/d65/8ec/075d658ecde4ceb5a08a76c6272b2af4.png"><br>  Using Object.observe () (I like to call it Oo () or Oooooooo), you can implement two-way data-binding without having to use the framework. <br><br>  This does not mean that you should not use it.  For large projects with complex business logic, frameworks are necessary, and I‚Äôm not going to dissuade you from using them.  They are aimed at simplifying work for new developers, require less code for support, and introduce specific templates for working on common tasks.  When you do not need this functionality, you can use more lightweight solutions, such as polymer (which, by the way, already uses Oo ()). <br><br>  Even if you use frameworks or MV * libraries in full, Oo () will allow them to get a good performance boost, which is achieved through a quick, simplified implementation, and at the same time continues to use the same API.  For example, last year, the Angular development team conducted a comparative analysis and found that dirty-checking takes about 40ms, while O.O () takes about 1-2ms (it turns out that it is 20-40 times faster). <br>  Date-buying without having to use tons of complex code!  But this also means that you no longer have to poll the model to receive changes! <br><br>  If you already understand what OO () is doing, you can immediately flip to the description of the new functionality, or you can read what problems this approach solves. <br><br><h4>  What are we going to watch? </h4><br>  When we talk about observing data, we usually mean tracking several types of changes: <br><ul><li>  Modifying Native JavaScript Objects </li><li>  Adding, changing or deleting properties </li><li>  When data is deleted or added to an array </li><li>  Changes in object prototype </li></ul><br><h4>  About the importance of data-buying </h4><br>  Date-buying starts becoming an important part of your application when you begin to affect the interaction between the model and the view.  HTML is a great declarative mechanism, but it is completely static.  Ideally, you just want to associate your data with the DOM and keep it up-to-date.  The solution with Oo () allows you to save a lot of time, due to the lack of need to write large chunks of repeating code that will simply send new data to the DOM, and vice versa. <br><br>  Date-buying is really useful when you create a comprehensive user interface, where you need to build a large number of links between the various properties of your models and the UI elements that reflect them.  This is one of the most common tasks when creating SPA (Single Page Application) applications. <br><br>  Initially, we had no mechanism for observing the data, and we shifted responsibility for this to various JavaScript frameworks (or wrote small libraries), relying on various slow hacks that the world uses to this day. <br><br><h4>  What is the world like today? </h4><br><h5>  Dirty-checking </h5><br>  Where have you seen date-buying until now?  Well, if you use modern MV * libraries to build your web applications (Angular, Knockout), then you may have already used model data binding to your DOM.  To refresh it in memory, here is an example of the ‚ÄúPhonebook‚Äù application, where we add the number of each phone from the array of numbers to the list item, and thus maintain constant synchronization between them: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-app</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"angular.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"controller.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-controller</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PhoneListCtrl"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-repeat</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"phone in phones"</span></span></span><span class="hljs-tag">&gt;</span></span> {{phone.name}} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>{{phone.snippet}}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  and JavaScript for the controller: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> phonecatApp = angular.module(<span class="hljs-string"><span class="hljs-string">'phonecatApp'</span></span>, []); phonecatApp.controller(<span class="hljs-string"><span class="hljs-string">'PhoneListCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.phones = [ {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'Nexus S'</span></span>, <span class="hljs-string"><span class="hljs-string">'snippet'</span></span>: <span class="hljs-string"><span class="hljs-string">'Fast just got faster with Nexus S.'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'Motorola XOOM with Wi-Fi'</span></span>, <span class="hljs-string"><span class="hljs-string">'snippet'</span></span>: <span class="hljs-string"><span class="hljs-string">'The Next, Next Generation tablet.'</span></span>}, {<span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'MOTOROLA XOOM'</span></span>, <span class="hljs-string"><span class="hljs-string">'snippet'</span></span>: <span class="hljs-string"><span class="hljs-string">'The Next, Next Generation tablet.'</span></span>} ]; });</code> </pre><br>  <a href="http://angular.github.io/angular-phonecat/step-2/app/">(Demo)</a> <br><br>  Each time the model data changes, our DOM list will be updated.  How does Angular achieve this?  Well, behind the scenes, he performs what we call dirty-checking. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ae/f25/21c/6aef2521c439004bf36bc479a7c1431b.png"><br><br>  The underlying idea of ‚Äã‚Äãdirty-checking is that at any given time the data can be changed, and the library needs to check how it has changed.  In the case of an angular, this happens through the registration of the states of all the model data that needs to be monitored.  He knows about the previous values ‚Äã‚Äãof the model and if they change, the corresponding event occurs.  For the developer, the main profit lies in the fact that we work with native JS objects that are easy to maintain and merge.  On the other hand, to the extent that the algorithm is very voracious, it can be a very expensive solution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e4/77b/f7b/5e477bf7b7d20a5e95ec44e5f7a6d9fb.png"><br><br>  The costs of such operations are proportional to the total number of objects observed.  I may need to do a lot of these checks.  It is also possible that I will need a way to trigger dirty-checking events when the model ‚Äúpossibly‚Äù has changed.  There are quite a few tricky tricks that the framework uses to implement such solutions.  It is still not clear whether this decision will bring to mind. <br><br>  The web ecosystem should have more opportunities to improve and develop its declarative mechanisms, for example <br><ul><li>  Systems of models based on containers with external access to attributes through setters / getters </li><li>  Systems with autosave (saving changes to IndexedDB or localStorage) </li><li>  Container objects (for example, Backbone, Ember) </li></ul><br>  Container objects are a data storage mechanism in which the framework creates objects that store data inside themselves, access to which is provided by accessors (getters / setters), and also implements the ability to subscribe to any changes.  This works quite well: the algorithm provides a fairly fast operation.  An example of using such objects in Ember can be found below: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// - MyApp.president = Ember.Object.create({ name: "Barak Obama" }); MyApp.country = Ember.Object.create({ //  "Binding"     Ember  , //        presidentNameBinding: "MyApp.president.name" }); // ,    Ember   MyApp.country.get("presidentName"); // " " //      , // ..     .</span></span></code> </pre><br>  The cost of detecting changes in this case is proportional to the number of properties that change.  Another problem is that you use objects of different types.  Simply put, you convert the data that you receive from the server to install it into the observed object. <br><br>  This is not particularly compatible with the existing JS code, since  Most of the code assumes that it can interact with ordinary data (not wrapped in a container object, <i>etc., lane</i> ), but not with these specialized objects. <br><br><h4>  Introduction to Object.observe () </h4><br>  It would be really cool if we could get the best from these two universes: take the opportunity to observe data changes with support for ordinary objects (native JavaScript objects) and remove dirty-checking, and instead add some algorithm with good characteristics.  Any one that will combine all these positive qualities and will be built into the platform.  So, meet - Object.observe (), already ready to use! <br><br>  It allows us to observe the object, change properties, and observe the change through change reports.  But enough theory, let's look at the code! <br><img src="https://habrastorage.org/getpro/habr/post_images/e54/4b9/3b9/e544b93b97e28aae9332d3688b8ccd39.png"><br><br><h4>  Object.observe () and Object.unobserve () </h4><br>  Let's imagine that we have a native JS object representing the model: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       var todoModel = { label: 'Default', completed: false };</span></span></code> </pre><br>  We can also declare a return function that will be called as soon as the object changes. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changes</span></span></span><span class="hljs-function">)</span></span>{ changes.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">change, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'what property changed? '</span></span> + change.name); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'how did it change? '</span></span> + change.type); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'whats the current value? '</span></span> + change.object[change.name]); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(change); <span class="hljs-comment"><span class="hljs-comment">// all changes }); }</span></span></code> </pre><br>  Note: When the return function is called for the observer, the observed objects can be changed several times, so for each change, the new value and the current value are not necessarily the same. <br><br>  We can observe such changes using Oo (), passing the observed object as the first argument and the return function as the second: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.observe(todoModel, observer);</code> </pre><br>  Let's try to do something with our model: <br><br><pre> <code class="javascript hljs">todoModel.label = <span class="hljs-string"><span class="hljs-string">'Buy some more milk'</span></span>;</code> </pre><br>  Look in the console, we got some useful information!  We know which property has changed, how it has been changed and what new value has been assigned to it. <br><img src="https://habrastorage.org/getpro/habr/post_images/63b/435/648/63b43564808ec6f970860609fecfe755.png"><br>  Wow  Goodbye dirty-checking!  The inscription on your tombstone will be carved by Comic Sans.  Let's change another property.  This time completeBy: <br><br><pre> <code class="javascript hljs">todoModel.completeBy = <span class="hljs-string"><span class="hljs-string">'01/01/2014'</span></span>;</code> </pre><br>  As we see, we again successfully received the change report: <br><img src="https://habrastorage.org/getpro/habr/post_images/342/ab6/9cb/342ab69cbafc504d17bea96aefd56b85.png"><br>  Great, but what if now we decide to remove the ‚Äúcompleted‚Äù property from our object: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> todoModel.completed;</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/5ad/d72/7bf/5add727bfdcd351ede7b04fadf8cffce.png"><br>  Now, as we can see, the change report includes the deletion information.  As expected, the new property value is now undefined.  So, now we know that we can track when new properties have been added or deleted.  Simply put, a number of properties of an object (‚Äúnew‚Äù, ‚Äúdeleted‚Äù, ‚Äúreconfigured‚Äù) and its prototype chains. <br><br>  As in any surveillance system, there must be a method for stopping the observation of changes in the object.  In our case, this is Object.unobserve (), which has the same signature as Oo (), but can be called like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.unobserve(todoModel, observer);</code> </pre><br>  As we can see below, any changes that were made after the last method call will no longer display a change report to the console. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/ab6/fe7/794ab6fe701fe17732944c3763ecee8a.png"><br><h4>  Focus on properties </h4><br>  So, when we got acquainted with the basics, let's go back to the list of changes of the observed object. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.observe(obj, callback, opt_acceptList)</code> </pre><br>  Let's go straight to the example to see how this can be used: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,       var todoModel = { label: 'Default', completed: false }; //        // ,    function observer(changes){ changes.forEach(function(change, i){ console.log(change); }) }; //         , //    ,    Object.observe(todoModel, observer, ['delete']); //        //      todoModel.label = 'Buy some milk'; //  ,    !</span></span></code> </pre><br>  Now, if we remove the ‚Äúlabel‚Äù property, a change notification will occur: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> todoModel.label;</code> </pre><br>  If you do not specify a list of applicable types for Oo (), then by default the ‚Äúinternal‚Äù object is transferred, which regulates the changes ‚Äúadd‚Äù, ‚Äúupdate‚Äù, ‚Äúdelete‚Äù, ‚Äúreconfigure‚Äù, ‚ÄúpreventExtensions‚Äù (if the object cannot be changed, it will not observable). <br><br><h4>  Notifications </h4><br>  Oo () also has the notion of notifications (alerts).  They have nothing to do with those annoying things that pop up on your phone, they are much more useful.  Notifications are similar to <a href="https://developer.mozilla.org/en/docs/Web/API/MutationObserver">Mutation Observers</a> (and a great <a href="http://habrahabr.ru/post/202366/">article on</a> <a href="https://habrahabr.ru/users/zag2art/" class="user_link">zag2art in Habr√©</a> ).  They occur during the completion of microtasks.  In the context of the browser, they almost always occur at the end of the current event handler. <br><br>  This time is extremely convenient due to the fact that the main work has already been done, and observers can begin to do their work without interfering with the basic logic.  This is a great model for step-by-step event handling. <br><br>  A workflow built using alerts looks something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/48b/a96/8aa48ba96c5710f97992dd2be934c6b3.png" alt="image"><br><br>  And now let's look at an example of how notifications can be used to notify about a change in the state of an object.  Pay attention to the comments: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    var model = { a: {} }; //   ,      //     var _b = 2; //    "b"    "a" //       Object.defineProperty(model.a, 'b', { get: function () { return _b; }, set: function (b) { //   "b"   , //       // ,   .    //     Object.getNotifier(this).notify({ type: 'update', name: 'b', oldValue: _b }); //        //  -   console.log('set', b); _b = b; } }); //    function observer(changes) { changes.forEach(function (change, i) { console.log(change); }) } //     model.a Object.observe(model.a, observer);</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/663/20d/f34/66320df347d0d4ca7415f69bdf2eaaa0.png"><br><br>  Here we display an alert when data changes (‚Äúupdate‚Äù), and everything, anything, actually, if this is indicated in the call to the notifier.notifyChange () method. <br><br>  Years of experience in web development have taught us that synchronous operations are the first thing we learn, because  the easiest way to manage just such operations.  The problem is that it creates a potentially dangerous processing model (data processing model, <i>etc. trans.</i> ).  If you write code and, say, write ‚Äúupdate object property‚Äù, you hardly want this to lead to the triggering of some arbitrary code in the middle of a function that can do whatever it wants. <br><br>  Even on the part of the observer, you do not want any third-party function to be called from the middle of the current function, etc.  Inconsistency and disconnection of function call sites is annoying, right?  And add to this more error checking, and other situations that can make life difficult with this approach.  As a result, we see that it is really difficult to work with such a model.  The asynchronous approach is more difficult to understand, but still, today, there is nothing better than it. <br><br>  The solution to this problem can be a synthetic record change. <br><br><h4>  Synthetic change of records </h4><br>  Simply put, if you need to access an accessor or a calculated property (you can read about calculating properties <a href="http://emberjs.com/guides/object-model/computed-properties/">here</a> ), you are responsible for creating an alert when this property changes.  This adds a bit of work, but is rather a feature than an inconvenience.  Your alerts will be delivered along with alerts about changes to other properties and will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/077/224/c82/077224c82b050a62e32aff5171299fc4.png"><br><br>  Monitoring accessors and changes to computed properties can be done using notifier.notify (this is also included in the Object.observe specification).  Many systems for monitoring changes should provide information about the changed values, and, frankly, we have quite a few ways to do this.  Object.observe does not impose the "right" path on us. <br><br>  I think that web developers can expect any ready-made solutions from libraries to help with the notification of changes in calculated properties. <br><br>  Now let's move on to the following example, which illustrates the creation of the ‚ÄúCircle‚Äù class.  The bottom line is that we have a circle and its radius property.  In our example, the radius will be an accessor, and when its value changes, an event will occur, notifying of this.  It will be delivered along with all other object change alerts. <br><br>  Let's see how our code will work in DevTools: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Circle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> radius = r; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notifier = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getNotifier(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">notifyAreaAndRadius</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radius</span></span></span><span class="hljs-function">) </span></span>{ notifier.notify({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'update'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'radius'</span></span>, <span class="hljs-attr"><span class="hljs-attr">oldValue</span></span>: radius }) notifier.notify({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'update'</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'area'</span></span>, <span class="hljs-attr"><span class="hljs-attr">oldValue</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(radius * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, <span class="hljs-number"><span class="hljs-number">2</span></span>) }); } <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'radius'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> radius; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (radius === r) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; notifyAreaAndRadius(radius); radius = r; } }); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">'area'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(radius, <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI; }, <span class="hljs-attr"><span class="hljs-attr">set</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ r = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(a)/<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI; notifyAreaAndRadius(radius); radius = r; } }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changes</span></span></span><span class="hljs-function">)</span></span>{ changes.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">change, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(change); }) }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d4e/905/bf2/d4e905bf247dc7e77940ffd83876aaf5.png"><br><h4>  Properties of accessors </h4><br>  A small note about the properties of the accessor.  Earlier, we talked only about observing changes in property values, but did not at all mention such behavior for accessors or calculated properties.  The reason for this is the fact that JavaScript actually does not have the ability to track changes in values ‚Äã‚Äãfor the accessors, because in fact they are only a collection of functions. <br><br>  If you‚Äôve already worked with accessories, you can imagine how they work: they simply provide a set of functions that give access to properties, and nothing more. <br><br><h4>  Monitoring multiple objects with one return function </h4><br>  Another possible pattern when working with Oo () is the notation for using object monitoring with a single return function.  This allows you to use this function as an observer function for any number of different objects.  The returned function will provide each time a complete set of changes for all the objects that it tracks (this will occur at the end of all microtasks, see Mutation Observers). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/824/d67/1f0/824d671f0723e914c3ed49eedbdaafd7.png"><br><h4>  Major changes </h4><br>  Perhaps you are working on a truly great project and are regularly forced to face major changes. <br>  Oo () helps with this by using two specific functions: notifier.performChange () and notifier.notify (), which we have already mentioned. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9d/51a/903/e9d51a90310fed3f29d628a731440a2b.png"><br><br>  Let's look at an example of how large-scale changes could be described using a Thingy object using some mathematical functions (multiply, increment, incrementAndMultiply).  Every time we use a function, it tells the system that the work collection includes a certain type of change. <br><br>  For example: notifier.performChange ('foo', performFooChangeFn); <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Thingy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.a = a; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.b = b; } Thingy.MULTIPLY = <span class="hljs-string"><span class="hljs-string">'multiply'</span></span>; Thingy.INCREMENT = <span class="hljs-string"><span class="hljs-string">'increment'</span></span>; Thingy.INCREMENT_AND_MULTIPLY = <span class="hljs-string"><span class="hljs-string">'incrementAndMultiply'</span></span>; Thingy.prototype = { <span class="hljs-attr"><span class="hljs-attr">increment</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">amount</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notifier = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getNotifier(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,       //   : // notifier.performChange('foo', performFooChangeFn); // notifier.notify('foo', 'fooChangeRecord'); notifier.performChange(Thingy.INCREMENT, function() { this.a += amount; this.b += amount; }, this); notifier.notify({ object: this, type: Thingy.INCREMENT, incremented: amount }); }, multiply: function(amount) { var notifier = Object.getNotifier(this); notifier.performChange(Thingy.MULTIPLY, function() { this.a *= amount; this.b *= amount; }, this); notifier.notify({ object: this, type: Thingy.MULTIPLY, multiplied: amount }); }, incrementAndMultiply: function(incAmount, multAmount) { var notifier = Object.getNotifier(this); notifier.performChange(Thingy.INCREMENT_AND_MULTIPLY, function() { this.increment(incAmount); this.multiply(multAmount); }, this); notifier.notify({ object: this, type: Thingy.INCREMENT_AND_MULTIPLY, incremented: incAmount, multiplied: multAmount }); } }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We declare two observers for our facility: one to monitor all changes and another to report on specific changes that we described above (Thingy.INCREMENT, Thingy.MULTIPLY, Thingy.INCREMENT_AND_MULTIPLY). </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer, observer2 = { <span class="hljs-attr"><span class="hljs-attr">records</span></span>: <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-attr"><span class="hljs-attr">callbackCount</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.records = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.callbackCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; }, }; observer.callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(r); observer.records = r; observer.callbackCount++; }; observer2.callback = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Observer 2'</span></span>, r); } Thingy.observe = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">thingy, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Object.observe(obj, callback, optAcceptList) Object.observe(thingy, callback, [Thingy.INCREMENT, Thingy.MULTIPLY, Thingy.INCREMENT_AND_MULTIPLY, 'update']); } Thingy.unobserve = function(thingy, callback) { Object.unobserve(thingy); }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, now we can play around a bit with the code. </font><font style="vertical-align: inherit;">Let's announce the new thingy:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> thingy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thingy(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Put it under surveillance and make a few changes. </font><font style="vertical-align: inherit;">Cool, cool!</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   thingy (,     "  ") Object.observe(thingy, observer.callback); Thingy.observe(thingy, observer2.callback); //  ,    thingy thingy.increment(3); // { a: 5, b: 7 } thingy.b++; // { a: 5, b: 8 } thingy.multiply(2); // { a: 10, b: 16 } thingy.a++; // { a: 11, b: 16 } thingy.incrementAndMultiply(2, 2); // { a: 26, b: 36 }</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f22/97c/10e/f2297c10ec8e861d333b6b28ced7a475.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything that is inside the ‚Äúfunction performed‚Äù will be considered work with ‚Äúa large number of changes‚Äù. </font><font style="vertical-align: inherit;">Observers who accept "big changes" will receive only them. </font><font style="vertical-align: inherit;">The remaining observers will receive the remaining changes.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Array Monitoring </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We talked about observing object changes, but what about arrays? Great question! By the way, every time they say ‚ÄúAn excellent question‚Äù to me, I never hear the answer, because too focused on congratulating ourselves on such a good question, but we digress :) We have new methods for working with arrays! </font></font><br><br> <code>Array.observe()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a method that works with a large number of changes to the object itself, for example splice, unshift, or something else that changes its length, such as splice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this, he uses the </font></font><code>notifier.performChange("splice",...)</code> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">following example of where we observe the ‚Äúarray‚Äù model and in the same way we get back the list of changes when actions are performed on the model that change its data:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = [<span class="hljs-string"><span class="hljs-string">'Buy some milk'</span></span>, <span class="hljs-string"><span class="hljs-string">'Learn to code'</span></span>, <span class="hljs-string"><span class="hljs-string">'Wear some plaid'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.observe(model, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">changeRecords</span></span></span><span class="hljs-function">) </span></span>{ count++; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array observe'</span></span>, changeRecords, count); }); model[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'Teach Paul Lewis to code'</span></span>; model[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'Channel your inner Paul Irish'</span></span>;</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c06/831/9cd/c068319cdd4987537b0c13dc2fb329ba.png"><br><h4>  Performance </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About computational speed Oo () can be thought of as the speed of reading the cache. </font><font style="vertical-align: inherit;">Generally speaking, a cache is an excellent choice when (in order of importance):</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Read frequency is higher than write frequency </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When you have the opportunity to create a cache that will sacrifice write time in the direction of a fixed time for read operations </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Constant latency for write operations is acceptable. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oo () is designed for use cases like the first. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dirty-checking requires you to keep copies of all the data you are watching. </font><font style="vertical-align: inherit;">This means that you get a memory drawdown that you never get with Oo (). </font><font style="vertical-align: inherit;">Dirty-checking is a kind of gag, which also creates a kind of unnecessary abstraction, which as a result creates unnecessary complexity in applications.</font></font><br><br>  Why?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Because dirty-checking is started every time the data "could" be changed. This is not a reliable method of such verification and has significant drawbacks, for example, the race between the rendering code (and so on) and the computational code (after all, everyone knows that in JS one stream is used for both the interface and the calculations?). For dirty-checking, a global registry of observers is also required, thereby creating the risk of memory leaks, etc., which Oo () allows to avoid. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a look at some numbers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The benchmarks below (available on </font></font><a href="https://github.com/Polymer/observe-js/tree/master/benchmark"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) allow us to compare dirty-checking and Oo (). They are represented as a graph with the Observed-Object-Set-Size abscissa and the Number-Of-Mutations ordinate.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The main results are that the performance of dirty-checking is proportional to the number of objects observed, while the performance of Oo () is proportional to the number of mutations that we made. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dirty-checking </font></font></h6><br><img src="https://habrastorage.org/getpro/habr/post_images/37d/60c/140/37d60c14060836f0ee9815754d3fd4ba.png"><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object.observe () </font></font></h6><br><img src="https://habrastorage.org/getpro/habr/post_images/699/c08/3e6/699c083e65c48806f1578beb7c102c7f.png"><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Object.observe () for older browsers </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cool, Oo () can be used in Chrome 36 beta, but what about other browsers? We will help you. Observe-JS is a polymer for Polymer that will use the native implementation as soon as it appears, but it also includes some useful things on top of this. He proposes to use a generalized view of the objects of observation and reports on general changes. Here are a couple of useful things he suggests: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) You can watch the ‚Äúways‚Äù. This means that you can say "hey, I want to monitor foo.bar.baz" for the selected object and it will notify you of the change in properties as soon as it happens. If the path is unavailable, it will return </font></font><code>undefined</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example of observing the value along the path of the specified object:</font></font><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: { <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-string"><span class="hljs-string">'baz'</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathObserver(obj, <span class="hljs-string"><span class="hljs-string">'foo.bar'</span></span>); observer.open(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newValue, oldValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,   obj.foo.bar   });</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) It will alert you about changing the length of the arrays. </font><font style="vertical-align: inherit;">In our case, changing the array length is the minimum number of splice operations we need to do with the array in order to transfer it from the old state to the new (changed) state. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of notification of such changes regarding an array as the minimum set of splice operations:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayObserver(arr); observer.open(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">splices</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      splices.forEach(function(splice) { splice.index; //  ,    splice.removed; //  ,   ,    splice.addedCount; //  ,    }); });</span></span></code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Framework and Object.observe () </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we have said, Oo () gives frameworks and libraries great opportunities to improve the performance of their data-buying mechanism in browsers that support this innovation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yehuda Katz and Eric Brin from Ember approved Oo () support in Ember‚Äôs nearest roadmaps. Misko Hervey (from Angular) also wrote in the draft of his Angular 2.0 documentation about improving change detection. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yehuda Katz and Erik Bryn from Ember confirmed that he was in Ember's near-term roadmap. Angular's Misko Hervy wrote a design doc on Angular 2.0's improved change detection. I think that it is most likely to expect movement in this direction when this feature appears in the Chrome 36 stable package.</font></font><br><br><h4>  Results </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oo () is a powerful innovation for the web platform that you can use today. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We hope that this functionality will soon appear in other browsers, allowing JavaScript frameworks to get some performance benefits with new native features of objects and monitoring them. </font><font style="vertical-align: inherit;">In addition to Chrome 36, this functionality will also be available in the next release of Opera. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, now you can go and tell JS frameworks about Object.observe () and how they can use it to improve their data-binding mechanism. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like really amazing times are coming!</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resources used: </font></font></h4><br><ul><li> <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:observe"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Object.observe () from Harmony wiki</font></font></a> </li><li> <a href="http://bocoup.com/weblog/javascript-object-observe/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data-binding with Object.observe () by Rick Waldron</font></font></a> </li><li> <a href="http://addyosmani.com/blog/the-future-of-data-binding-is-object-observe/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything you wanted to know about Object.observe () - JSConf</font></font></a> </li><li> <a href="http://georgestefanis.com/blog/2014/03/25/object-observe-ES7.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why Object.observe () is a better feature of ES7</font></font></a> </li></ul><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúBinding‚Äù turned into ‚Äúbinding‚Äù </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD 2:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comments were translated into Russian </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD 3:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Corrected grammatical and punctuation errors. </font><font style="vertical-align: inherit;">Thank you, </font></font><a href="https://habrahabr.ru/users/mingun/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mingun</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/225065/">https://habr.com/ru/post/225065/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225055/index.html">Youvend personal experience: IT product sales guidelines</a></li>
<li><a href="../225057/index.html">A robot in every family. Intel announced the designer to create your own robot</a></li>
<li><a href="../225059/index.html">Exploiting the conceptual flaws of wireless networks</a></li>
<li><a href="../225061/index.html">Ups and downs of Windows Phone: an inside view</a></li>
<li><a href="../225063/index.html">New functionality nanoCAD 6.0: regulatory audit</a></li>
<li><a href="../225067/index.html">Need more Landing Page</a></li>
<li><a href="../225069/index.html">The first Tizen smartphone Samsung Z will appear in Russia in the autumn</a></li>
<li><a href="../225077/index.html">The author of the banker Trojan Zeus is wanted</a></li>
<li><a href="../225079/index.html">How to build WhatsApp for the day. Part 1</a></li>
<li><a href="../225083/index.html">June 5, 2014 - World Day Against Internet Surveillance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>