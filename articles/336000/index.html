<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Myriads of running C # tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, two articles from the same author on C # async / await functionality were published on the Medium resource. 


 The main conclusions were: 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Myriads of running C # tasks</h1><div class="post__text post__text-html js-mediator-article"><p>  Recently, <a href="https://medium.com/%40alexyakunin/async-recursion-and-some-weirdness-of-design-of-asynchronous-api-in-c-vs-f-a5760a00a26a">two</a> <a href="https://medium.com/%40alexyakunin/go-vs-c-part-1-goroutines-vs-async-await-ac909c651c11">articles</a> from the same author on C # async / await functionality were published on the Medium resource. </p><br><p>  The main conclusions were: </p><br><ul><li>  recursive calling an asynchronous method in C # is subject to StackOverflowException </li><li>  goroutine's are better than tasks (tasks) in .NET in terms of performance </li></ul><br><p>  But the main problem of the above publications is the absolute misunderstanding of the cooperative multitasking model in C # with the introduction of misleading readers.  The benchmarks themselves are <strong>meaningless</strong> , as we will see later. </p><br><p>  Further in the article I will try to reveal the essence of the problem in more detail with examples of solutions. </p><br><div class="spoiler">  <b class="spoiler_title">TL; DR</b> <div class="spoiler_text"><p>  After a little editing of the source code, the benchmark implementation on .NET turns out to be faster than the Go option.  Along the way, we solve the stack overflow problem for recursive asynchronous methods. </p></div></div><br><p>  <strong>NB</strong> : Freshly released .NET Core 2.0 and Go 1.8.3 will be used. </p><a name="habracut"></a><br><h2 id="stack-overflow--async">  Stack overflow &amp; async </h2><br><p>  We proceed immediately to the consideration of example # 1: </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">CSharpAsyncRecursion</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Counted to {0}."</span></span>, CountRecursivelyAsync(<span class="hljs-number"><span class="hljs-number">10000</span></span>).Result); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountRecursivelyAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> count; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> CountRecursivelyAsync(count - <span class="hljs-number"><span class="hljs-number">1</span></span>); } } }</code> </pre> <br><p>  The console will <code>StackOverflowException</code> with <code>StackOverflowException</code> .  Sorrow! </p><br><p>  The implementation of tail-call optimization is not suitable here, because  we are not going to edit the compiler, rewrite bytecode, etc. </p><br><p>  Therefore, the solution should be suitable for the most general case. </p><br><p>  Usually, the recursive algorithm is replaced by an iterative one.  But in this case it does not suit us either. </p><br><p>  The delayed execution mechanism comes to the rescue. <br>  We implement a simple method <code>Defer</code> : </p><br><pre> <code class="cs hljs">Task&lt;T&gt; Defer&lt;T, TState&gt;(Func&lt;TState, Task&lt;T&gt;&gt; task, TState state) =&gt; Task.Factory.StartNew(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> s =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task((TState)s), state).Unwrap();</code> </pre> <br><p>  In order to put a task in the queue, it is necessary to specify the scheduler. <br>  The <code>Task.Run</code> and <code>Task.Factory.StartNew</code> allow you to use it (By default, <code>TaskScheduler.Default</code> , which is suitable for this example), and the latter allows you to pass a state object to the delegate. </p><br><blockquote>  Currently, <code>Task.Factory.StartNew</code> does not support generalized overloads and is <a href="https://social.msdn.microsoft.com/Forums/en-US/1988294c-de41-476a-a104-aa550b7409f5/tpl-api-task-create-methods-signature-should-be-different%3Fforum%3Dparallelextensions">unlikely to happen</a> .  If you need to pass a state, then either <code>Action&lt;object&gt;</code> or <code>Func&lt;object, TResult&gt;</code> . </blockquote><p>  Rewrite the example using the new <code>Defer</code> method: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Task&lt;T&gt; Defer&lt;T, TState&gt;(Func&lt;TState, Task&lt;T&gt;&gt; task, TState state) =&gt; Task.Factory.StartNew(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> s =&gt; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> task((TState)s), state).Unwrap(); <span class="hljs-function"><span class="hljs-function">Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountRecursivelyAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Defer(seed =&gt; CountRecursivelyAsync(seed - <span class="hljs-number"><span class="hljs-number">1</span></span>).ContinueWith(rec =&gt; rec.Result + <span class="hljs-number"><span class="hljs-number">1</span></span>), count); } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Counted to </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">await</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> CountRecursivelyAsync(</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">100000</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">."</span></span>); }</code> </pre> <br><h2 id="ono-ne-to-chem-kazhetsya">  It is not what it seems. </h2><br><p>  First, let's take a look at the benchmark code from this <a href="https://medium.com/%40alexyakunin/go-vs-c-part-1-goroutines-vs-async-await-ac909c651c11">article</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Go code:</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"flag"</span></span>; <span class="hljs-string"><span class="hljs-string">"fmt"</span></span>; <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { elapsed := time.Since(start) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%s took %s"</span></span>, name, elapsed) fmt.Println() } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxCount = flag.Int(<span class="hljs-string"><span class="hljs-string">"n"</span></span>, <span class="hljs-number"><span class="hljs-number">1000000</span></span>, <span class="hljs-string"><span class="hljs-string">"how many"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(output, input </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { output &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> + &lt;-input } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Started, sending %d messages."</span></span>, *maxCount) fmt.Println() flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> measure(time.Now(), fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"Sending %d messages"</span></span>, *maxCount)) finalOutput := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> left, right <span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, finalOutput <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; *maxCount; i++ { left, right = right, <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> f(left, right) } right &lt;- <span class="hljs-number"><span class="hljs-number">0</span></span> x := &lt;-finalOutput fmt.Println(x) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { test() test() }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">C # code:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Diagnostics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks.Channels; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ChannelsTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Measure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> title, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; test, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> warmupCount = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span></span><span class="hljs-function">)</span></span> { test(warmupCount, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Warmup var sw = new Stopwatch(); GC.Collect(); sw.Start(); test(count, false); sw.Stop(); Console.WriteLine($"{title}: {sw.Elapsed.TotalMilliseconds:0.000}ms"); } static async void AddOne(WritableChannel&lt;int&gt; output, ReadableChannel&lt;int&gt; input) { await output.WriteAsync(1 + await input.ReadAsync()); } static async Task&lt;int&gt; AddOne(Task&lt;int&gt; input) { var result = 1 + await input; await Task.Yield(); return result; } static void Main(string[] args) { if (!int.TryParse(args.FirstOrDefault(), out var maxCount)) maxCount = 1000000; Measure($"Sending {maxCount} messages (channels)", (count, isWarmup) =&gt; { var firstChannel = Channel.CreateUnbuffered&lt;int&gt;(); var output = firstChannel; for (var i = 0; i &lt; count; i++) { var input = Channel.CreateUnbuffered&lt;int&gt;(); AddOne(output.Out, input.In); output = input; } output.Out.WriteAsync(0); if (!isWarmup) Console.WriteLine(firstChannel.In.ReadAsync().Result); }, maxCount); Measure($"Sending {maxCount} messages (Task&lt;int&gt;)", (count, isWarmup) =&gt; { var tcs = new TaskCompletionSource&lt;int&gt;(); var firstTask = AddOne(tcs.Task); var output = firstTask; for (var i = 0; i &lt; count; i++) { var input = AddOne(output); output = input; } tcs.SetResult(-1); if (!isWarmup) Console.WriteLine(output.Result); }, maxCount); } } }</span></span></code> </pre> </div></div><br><p>  What immediately thrown into the eyes: </p><br><ol><li>  The example itself (for Go, for C #) is rather strange.  It all comes down to emulating a chain of actions and their avalanche-like 'descent'.  Moreover, Go creates a chan int for each iteration of 1 million. <em>Is this generally best-practice</em> ?? </li><li>  The author uses <code>Task.Yield()</code> , justifying it by the fact that otherwise the example will fall from StackOverflowException.  With the same success, Task.Delay could also be used.  Why trifle something?  But, as they saw earlier, everything stems from the 'unfortunate' experience with recursive calls to asynchronous methods. </li><li>  Initially, the examples also feature a beta version of <a href="https://github.com/dotnet/corefxlab/tree/master/src/System.Threading.Tasks.Channels">System.Threading.Tasks.Channels</a> for comparison with channels in Go.  I decided to leave only an example with tasks, since  The System.Threading.Tasks.Channels library has <strong>not</strong> yet <strong>been</strong> officially released. </li><li>  Call GC.Collect () after warming up.  I'm afraid I will give up this dubious advantage. </li></ol><br><blockquote>  Go uses the concept of goroutine - lightweight threads.  Accordingly, each Gorutin has its own stack.  Currently the stack size is 2KB.  Therefore, when starting benchmarks, be careful (more than <strong>4GB is</strong> needed)! <br><br>  On the one hand, this can be useful for CLR JIT, and on the other hand, Go re-uses the already created gorutines, which makes it possible to exclude measurements of expenditure on memory allocation by the system. </blockquote><br><h2 id="rezultaty-do-optimizacii">  Results before optimization </h2><br><p>  Testing Environment: </p><br><ul><li>  Core i7 6700HQ (3.5 GHz) </li><li>  8 GB DDR4 (2133 MHz) </li><li>  Win 10 x64 (Creators Update) </li></ul><br><p>  Well, I got the following results: </p><br><table><thead><tr><th></th><th>  Warmup (s) </th><th>  Benchmark (s) </th></tr></thead><tbody><tr><td>  Go </td><td>  9.3531 </td><td>  1.0249 </td></tr><tr><td>  C # </td><td>  - </td><td>  1.3568 </td></tr></tbody></table><br><p>  <strong>NB</strong> : Because  If the example implements just a call chain, then neither GOMAXPROCS nor the size of the channel does not affect the result (already tested experimentally).  We take into account the best time.  Fluctuations are not quite important, because  big difference. </p><br><blockquote>  Yes, indeed: Go is ahead of C # by ~ 30%. <br>  Challange accepted! </blockquote><br><h2 id="ispolzuy-taskscheduler-luke">  Use TaskScheduler, Luke! </h2><br><p>  If you do not use something like <code>Task.Yield</code> , then again there will be a StackOverflowException. </p><br><p>  This time <strong>we</strong> will not use <code>Defer</code> ! </p><br><p>  The idea of ‚Äã‚Äãimplementation is simple: run add.  a thread that listens / processes tasks in turn. </p><br><p>  In my opinion, it is easier to implement your own scheduler than the synchronization context. <br>  The <code>TaskScheduler</code> class <code>TaskScheduler</code> looks like this: </p><br><pre> <code class="hljs pgsql">// Represents an <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> that handles the low-<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> queuing tasks onto threads. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TaskScheduler { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> virtual <span class="hljs-type"><span class="hljs-type">int</span></span> MaximumConcurrencyLevel { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static TaskScheduler FromCurrentSynchronizationContext(); protected abstract IEnumerable&lt;Task&gt; GetScheduledTasks(); protected <span class="hljs-type"><span class="hljs-type">bool</span></span> TryExecuteTask(Task task); protected abstract <span class="hljs-type"><span class="hljs-type">bool</span></span> TryExecuteTaskInline(Task task, <span class="hljs-type"><span class="hljs-type">bool</span></span> taskWasPreviouslyQueued); protected <span class="hljs-type"><span class="hljs-type">internal</span></span> abstract <span class="hljs-type"><span class="hljs-type">void</span></span> QueueTask(Task task); protected <span class="hljs-type"><span class="hljs-type">internal</span></span> virtual <span class="hljs-type"><span class="hljs-type">bool</span></span> TryDequeue(Task task); }</code> </pre> <br><p>  As we can see, <code>TaskScheduler</code> already implements a semblance of a queue: <code>QueueTask</code> and <code>TryDequeue</code> . </p><br><p>  In order not to reinvent the wheel, we will use the ready-made <a href="https://code.msdn.microsoft.com/ParExtSamples">planners</a> from <a href="https://blogs.msdn.microsoft.com/pfxteam/2010/04/04/a-tour-of-parallelextensionsextras/">the</a> .NET <a href="https://blogs.msdn.microsoft.com/pfxteam/2010/04/04/a-tour-of-parallelextensionsextras/">team</a> . </p><br><h2 id="vnimanie-kamera-motor">  Attention!  Camera!  Motor! </h2><br><p>  Rewrite this case in C # 7, making it as close as possible to Go: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Measure</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> title, Action&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; test, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> warmupCount = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sw = new Stopwatch(</span></span></span><span class="hljs-function">)</span></span>; sw.Start(); test(count, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); sw.Stop(); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{title}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{sw.Elapsed.TotalMilliseconds:</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0.000</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">ms"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Task&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> input; <span class="hljs-comment"><span class="hljs-comment">// return output } await Task.Factory.StartNew(() =&gt; { if (!int.TryParse(args.FirstOrDefault(), out var maxCount)) maxCount = 1000000; Measure($"Sending {maxCount} messages (Task&lt;int&gt;)", (count, isWarmup) =&gt; { var tcs = new TaskCompletionSource&lt;int&gt;(); (var left, var right) = ((Task&lt;int&gt;)null, f(tcs.Task)); for (var i = 0; i &lt; count; i++) { left = f(right); right = left; } tcs.SetResult(-1); if (!isWarmup) Console.WriteLine(right.Result); }, maxCount); }, CancellationToken.None, TaskCreationOptions.None, new StaTaskScheduler(2)); }</span></span></code> </pre> <br><p>  Here you need to make a couple of remarks: </p><br><ul><li>  <code>GC.Collect()</code> remove as mentioned above. </li><li>  We use <code>StaTaskScheduler</code> with <strong>two</strong> auxiliary threads to avoid blocking: one <strong>waits for the</strong> result from the main / last task, and the other handles <strong>the task chain itself</strong> . </li></ul><br><p>  The problem of recursive calls disappears automatically.  Therefore, we boldly remove the <code>Task.Yield()</code> call from the <code>f(input)</code> <code>Task.Yield()</code> .  If this is not done, then we can expect a slightly better result compared to the original, because  The default scheduler uses ThreadPool. </p><br><p>  Now we publish the release assembly: <br> <code>dotnet publish -c release -r win10-x64</code> </p> <br><p>  And run ... </p><br><p><img src="https://habrastorage.org/web/208/e93/e4e/208e93e4e40348249d0b7c02d9780b9d.png"></p><br><p>  Suddenly we get about 600 ms instead of the previous 1300 ms.  Not bad! <br>  Go, I will remind, fulfilled at the level of 1000 ms.  But the feeling of <strong>irrelevance of</strong> using channels as a means of cooperative multitasking in the original examples does not leave me. </p><br><p>  ps <br>  I did not do a huge number of test runs with full statistics of the distribution of measurement values <em>specifically</em> . <br>  The purpose of the article was to highlight a specific use-case as an async / await and simultaneously dispel the myth of the impossibility of recursive calling asynchronous methods in C #. </p><br><p>  pps <br>  The cause of the initial C # lag was the use of <code>Task.Yield()</code> .  Constant context switching is not gud! <br></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/336000/">https://habr.com/ru/post/336000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335988/index.html">Replace and Conquer - the SOLID approach to developing reusable components on the web</a></li>
<li><a href="../335990/index.html">The digest of interesting materials for the mobile developer # 217 (August 14 - August 20)</a></li>
<li><a href="../335992/index.html">Edge hates your attributes</a></li>
<li><a href="../335994/index.html">Blockchain</a></li>
<li><a href="../335998/index.html">How to make a project on the recognition of handwritten numbers with additional training online. Hyde for not quite beginners</a></li>
<li><a href="../336002/index.html">How to complete the first project</a></li>
<li><a href="../336006/index.html">Liscript - web REPL: kisses, bikes and excavators</a></li>
<li><a href="../336010/index.html">React Native: from simple animation to interactive at 60 FPS</a></li>
<li><a href="../336012/index.html">Support for system errors in C ++</a></li>
<li><a href="../336016/index.html">CrowdSourcing Accelerator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>