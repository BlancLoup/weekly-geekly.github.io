<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript Optimization: time-tested experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 I have long wanted to write. Thoughts are there, desire is there, there is no time ... But now it was found, so hello, Habra. 
 Here I gath...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript Optimization: time-tested experience</h1><div class="post__text post__text-html js-mediator-article"><h4>  Foreword </h4><br>  I have long wanted to write.  Thoughts are there, desire is there, there is no time ... But now it was found, so hello, Habra. <br>  Here I gathered all the ideas that helped and helped in the development of web applications.  For convenience, I divided them into groups: <br><ol><li>  Memory </li><li>  Operations optimization </li><li>  Highlighting critical areas </li><li>  Loops and object properties </li><li>  Little about dom </li><li>  DocumentFragment as intermediate buffer </li><li>  About conversions to objects </li><li>  Code break </li><li>  Drag and Drop Events </li><li>  Other tips </li></ol><br>  Now we will not talk about any libraries.  I will try to transfer knowledge about the mechanisms of the language itself, and not their implementations in libraries. <br><br><h5>  Memory </h5><br>  Although this should not worry the client programmer, we don‚Äôt forget that the memory is still not infinite and may someday end, for example, when several massive programs are running: office, image editor, compilation of a large program, etc. Despite that this example is trivial, I really had this happen, although not because of the browser, but it also played its role: 1.3 GB of operatives (debugger, about 30 tabs), the brakes started to overload the pages of the OP into the paging file. <br>  To reduce memory consumption, I suggest several ways: <br><a name="habracut"></a><br>  1) reducing the number of local variables. <br>  You ask what it means?  I explain, in my practice I saw how code monkey students wrote similar code: <br><br><pre><code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      - for(var i=0,n=1;i&lt;10;i++) //      n+=n; alert(n); //  for(var i=0,m=1;i&lt;10;i++) m*=m; alert(m); })();</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Maybe you don‚Äôt immediately see where the trick is, but: why create new variables if we have old variables used and already storing unnecessary values?  In this example, for a normal solution, it is necessary to replace all m with n, which will save memory. <br>  This method is best manifested in recursive functions, because each call of such a function provokes the creation and, note, deletion of local variables after the function completes, which also requires CPU time and memory. <br>  For visual perception, you can bring an analogy with the lockers: you have 6 lockers, three of which can be filled;  Why then do you need three more lockers, if in this case you have to open all 6 and then close all 6? <br><br>  2) reducing the number of closures. <br>  The closures cause significant memory consumption (3 MB per 1000 objects for chromium, perhaps in new versions, a different amount), so use them as little as possible.  I use them in two cases: <br><ol><li>  It is necessary to hide data inside some interface, not to give access from the outside; </li><li>  During recursion, when you need to make some notes in one common object (for example, when traversing HTML, add all nodes that have the custom dragndrop property to the array) if the selection by selectors is not appropriate. </li></ol><br>  Both cases imply some particular, unique cases.  It means that single interfaces are created. <br>  An example of the first case: <br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> INTERNAL_NUMBER=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-comment"><span class="hljs-comment">//  return { get:function get(){return INTERNAL_NUMBER;},//,     set:function set(value){ //,        if(typeof value==‚Äùnumber‚Äù) INTERNAL_NUMBER=value; return INTERNAL_NUMBER; } } })();</span></span></code> </pre><br><br>  This is how I create SINGLE interfaces. <br>  If the first is already, I think, everything is clear, then the second case should be clarified: in fact, it refers to the previous item, because we replace the variable that could be passed as an argument to the function with a closure, thereby reducing the number of local variables inside this functions and at the same time observe the principle of minimum closures: this closure is characteristic only for this recursive function (although this is how you want it), because the same function is used during recursion (new closures are not created). <br>  Example: <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> found=[]; (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">html</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=html.firstChild;i;i=i.nextSibling) <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> html.dragndrop==‚Äùobject‚Äù) found.push(html); })(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> found; })();</code> </pre><br><br>  As you can see from the example, the recursive function contains 2 local variables (html, i) instead of three (html, i, found).  In practice, the gain in speed is insignificant (at least from the closure of only one variable), but it gives an indication of the gain in memory. <br>  And, please, do not blame for nextSibling, and not for nextElementSibling, everything was done primarily to clarify the essence of the closure within the recursive function. <br>  ATTENTION: Never make a loop through a loop - this causes excessive memory consumption.  Exceptions are cases when the script logic requires unconditional data hiding (but in any case, if I have a debugger, will I get there?).  An example of improper use of closures: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEvents2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">divs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;divs.length; i++) { divs[i].innerHTML = i divs[i].onclick = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ alert(x) } }(i); } }</code> </pre><br><br>  Yes Yes.  This is the very example from Ilya Kantor's article about closures.  For an explanation of the essence - yes, it is normal, but for practical use it is absolutely wrong: several functions are created, each with its own closure.  Well, if a few pieces.  But if thousands ... The best way out in this case is to create only one function WITHOUT CLOSING and use the this property: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addEvents2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">divs</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f=<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$i)}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;divs.length; i++) { divs[i].innerHTML = i; divs[i].$i=i; divs[i].onclick = f; } }</code> </pre><br>  And it is best to use the handler on the parent element (note <a href="https://habrahabr.ru/users/egorinsk/" class="user_link">egorinsk</a> ). <br><br><h5>  Operations optimization </h5><br>  I once wrote about this, but I repeat once again: for each type of operation, among all possible options there is one of the fastest, which is preferable to use. <br>  Let us have a variable v, the content of which depends on the context of the consideration;  there is also a variable k, which has the same meaning. <br><table><tbody><tr><td>  Operation </td><td>  Source </td><td>  Comment </td></tr><tr><td>  Cast to boolean </td><td>  !! v </td><td>  Probably everyone knows that. </td></tr><tr><td>  Cast to integer </td><td>  v-0 </td><td>  Just subtract zero </td></tr><tr><td>  Fractional reduction </td><td>  v-0.0 </td><td>  Small but win </td></tr><tr><td>  Cast to string </td><td>  v + ‚Äù‚Äù </td><td>  Add an empty string </td></tr><tr><td>  Object creation </td><td>  {} </td><td>  Indeed faster than through the operator new.  Winning is the ability to specify properties </td></tr><tr><td>  Creating an array </td><td>  [] </td><td>  An array is also an object, so it is this kind of creation that is faster. </td></tr><tr><td>  Comparison </td><td>  v === k </td><td>  Comparison without coercion (if script logic allows it) </td></tr><tr><td>  Injection / Decrement operation, assignment operation with arithmetic action </td><td>  v + = 1; v / = 5; </td><td>  It may seem strange, but this way is faster, and in all browsers </td></tr><tr><td>  Division / multiplication operations by numbers that are <a href="https://habrahabr.ru/users/dzuba/" class="user_link">powers of</a> two ( <a href="https://habrahabr.ru/users/dzuba/" class="user_link">Dzuba</a> remark) </td><td>  v &lt;&lt; 2 </td><td>  Operations are replaced by a bitwise shift.  Winning is also characteristic of other languages. </td></tr></tbody></table><br>  Using these operations is recommended, but the script logic does not always allow you to put them in one place or another, so be vigilant. <br><br><h5>  Highlighting critical areas </h5><br>  I would advise theoretically to estimate how much a given section (for example, a cycle) would be critical for a given scope, i.e.  with an increase in the number of iterations for this section, its execution time will also increase linearly or the dependence will already be in the form of a power function, where the degree is greater than one.  And after optimization of all operations in this area, it is necessary to optimize the area as a whole, for example, to introduce an additional variable that would store the intermediate result used more than once. <br>  Simply put, the critical section is the code on which the processor will work the longest, and noticeably for the page.  For example, 100k operations when interpolating, if the application for applied mathematics. <br>  In the subsections, I will give an example and indicate the essence. <br><br><h5>  Loops and object properties </h5><br>  The speed of the for and while loops is about the same.  However, their difference is most pronounced in IE, where the for loop is many times faster, so I recommend using it.  The for-in cycle NEVER use for arrays, in this case you will lose performance dramatically: not only does it work slower due to accessing the table of properties, there will also be losses and enumeration of properties that are unnecessary in a cycle, such as for example, length. <br>  Probably, you already know about the technique of the reverse passage through the array, due to which the passage execution time is actually reduced.  It is not always applicable, but in most cases is valid.  I propose to consider an example in order to understand why ‚Äúacceleration‚Äù occurs: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr=[]; arr.length=<span class="hljs-number"><span class="hljs-number">100500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;arr.length;i++) ‚Ä¶;<span class="hljs-comment"><span class="hljs-comment">//- </span></span></code> </pre><br><br>  Here you need to introduce the concept of <i>object conversion</i> - this is getting or setting the specified property of the current object or the value of a variable. <br>  Thus, in the example above, for one iteration of the cycle (without taking into account the actions inside the cycle), 4 object hits occur (getting i, getting arr, getting arr.length, increasing i).  In the best way back, these 4 hits are replaced by one: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=arr.length;i--;) ‚Ä¶;<span class="hljs-comment"><span class="hljs-comment">//- </span></span></code> </pre> <br><br>  It should be noted that the postdecrement operator immediately returns the value, as a result of which there is no need to refer to i again. <br>  As for the logic of cycles, try to complete the cycle as early as possible: for example, there is a test for the truth of each object in the array (by condition, everyone should be true);  break as soon as you reach the first untrue element. <br><br><h5>  Little about dom </h5><br>  Lyrical digression: before writing this article, I checked if there are any similar ones here.  It turned out that <a href="http://habrahabr.ru/blogs/javascript/109477/">there is</a> .  I went to read, and, OH GOD, what I saw there: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'elem'</span></span>).propertyOne = <span class="hljs-string"><span class="hljs-string">'value of first property'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'elem'</span></span>).propertyTwo = <span class="hljs-string"><span class="hljs-string">'value of second property'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'elem'</span></span>).propertyThree = <span class="hljs-string"><span class="hljs-string">'value of third property'</span></span>;</code> </pre><br><br>  And now the point: NEVER REPEAT ALREADY IMPLEMENTED ACTIONS, especially if they are related to DOM! <br>  By the action taken in this case, I mean getting the item by ID.  The larger the document, the slower the search is performed, and in this case the search is performed three times.  Correct solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'elem'</span></span>); item.propertyOne = <span class="hljs-string"><span class="hljs-string">'value of first property'</span></span>; item.propertyTwo = <span class="hljs-string"><span class="hljs-string">'value of second property'</span></span>; item.propertyThree = <span class="hljs-string"><span class="hljs-string">'value of third property'</span></span>;</code> </pre><br><br>  First, the speed increases, and second, the code is reduced.  The same design can be screwed to cycles: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=arr.length,c;i--;){ c=arr[i]; ‚Ä¶ }</code> </pre><br><br><h5>  --- </h5><br>  Developing the theme of cycles: how to quickly remove subitems of a node, knowing that object references exist?  That's right, like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> z,node=<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(z=node.lastChild) node.removeChild(z);</code> </pre><br><br>  In fact, this code will be a critical section within the function, which is due to the large number of calls to DOM objects. <br>  It is worth noting that DOM interfaces are ten times slower than embedded JavaScript objects.  Therefore, if we are talking about performing calls to DOM properties, then the number of such calls should be minimized, especially if they occur in a cycle.  In the previous example, there are only 2 DOM calls in the loop: to the lastChild property and removeChild functions;  calls to z and node do not apply here, because they are ordinary variables.  But perhaps I am mistaken. <br>  Performance is also lost if, in the previous case, DOM event handlers were placed in the document.  Try to keep them as small as possible and make them as simple as possible.  In some cases, their code may be critical. <br><br><h5>  DocumentFragment as intermediate buffer </h5><br>  If you need to insert several sub-elements into the element one by one, do not rush to do it directly.  After all at each insertion DOM event will be generated.  To circumvent this problem, there is a DocumentFragment - an intermediate buffer that allows you to collect items and insert them in the right place ONE TIME, which significantly improves performance.  To verify this, create a 200 by 100 table with and without using a DocumentFragment.  For this experience, a special thanks to Ilya Kantor. <br>  And all operations on objects (class assignment, id, attribute setting) are also better done in DocumentFragment.  This approach does not allow the generation of events already inside the document, which does not cause a load. <br><br><h5>  About conversions to objects </h5><br>  On large volumes of JSON data, eval works VERY slowly, but since values ‚Äã‚Äãare undefined and functions are not included in JSON, you can create such an object only with eval. <br>  For real JSON format, use JSON.parse.  But the lack of the latter is that it requires full compliance with the JSON specification: double quotes for keys, no comments (although they should be). <br><br><h5>  Code break </h5><br>  To understand the text below, you will need to know about the JS call stack (note <a href="https://habrahabr.ru/users/spmbt/" class="user_link">spmbt</a> ): roughly speaking, this is the <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2582%25D0%25B5%25D0%25BA">stack</a> where all currently executing functions are placed in the order of the call.  Putting the first function on the stack can be caused in several ways: 1) by calling from the global execution area;  2) running the function by timer / timeout;  3) the execution of a custom event handler.  When the function completes its work, it is removed from the stack.  It is also removed from the stack if an error has occurred inside it that has not been processed. <br><br>  Did you know that redrawing a document (for example, when you change some element styles) only happens when the call stack is cleared?  Now you know for sure.  JavaScript does not allow you to create constructs of the type wait (2000);  with the continuation of the code of the same function without sacrificing performance.  Therefore, the code is divided into separate functions that control the elements.  The advice is to try to evenly distribute the load across different functions with this code breakdown into functions.  After all, it may happen that one function changes almost all styles of most elements of a document, the other computes a complex mathematical task, and the rest do almost nothing, as a result, the page ‚Äúhangs‚Äù. <br>  Uniformity can be achieved by setting the execution interval.  As for effects, the longer the interval between the launch of functions, the more time to redraw the document and the less load on the processor.  But if the interval is too large, it will be noticeable "twitching effect."  The optimal interval is 20ms.  The minimum interval is 4 ms, except Opera (1ms) and IE (15 ms).  Even if you set the interval to 0, the actual function call will still occur after the minimum interval. <br><br><h5>  Drag and Drop Events </h5><br>  Such events are critical because they are triggered EVERY TIME as soon as a drag is detected.  To reduce the load, it is better to replace them with timeout functions by means of a closure ( <a href="https://habrahabr.ru/users/egorinsk/" class="user_link">egorinsk</a> remark): <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">//    ,        . //   var MODE_MOUSE_MOVE=true; var move_listener=function move_listener (evnt){ if(!MODE_MOUSE_MOVE) return; ev=evnt||window.event;//for IE8 timeout=setTimeout(move_handler,10); }, ev=null, move_handler=function move_handler(){ timeout=0; MODE_MOUSE_MOVE=true; if(typeof document.$onmousemove=="function") document.$onmousemove(ev); }, timeout=0; document.onmousemove=move_listener; })();</span></span></code> </pre><br><br>  If you assign the function document. $ Onmousemove, then it will be executed every time a drag is detected, and its criticality will be reduced by using a timer.  The timer timer is assigned in case you suddenly have to make it possible to interrupt this timer. <br>  This also applies to the window resizing event. <br><br><h5>  Other tips </h5><br>  Try to use wrapper functions: they add code modularity and isolate the local variables of one module from the local variables of the other module.  This reduces the likelihood of using an already declared variable that already has a certain role assigned to it. <br>  In principle, everything is said.  Maybe, optimize not only the code, but also its readability.  In unfused source codes, make the names of functions and their parameters logical, prefix type (s - string, n - number, etc.).  I do that, and the code is understood even after a year. <br><br><h4>  Afterword </h4><br>  I'm glad you read this article.  I hope you enjoyed it in terms of presentation and accessibility.  It may be bad that there are no examples of working with popular libraries, but I believe that you need to be able to use JS without libraries, especially if you are a client developer. <br><br>  Maybe most of the councils have already become "Boyans" for you, but I think that you have learned something useful from here.  thank <br><br>  UPD 1. Taking into account the advice given in the comments, I correct all the found flaws </div><p>Source: <a href="https://habr.com/ru/post/137318/">https://habr.com/ru/post/137318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137309/index.html">Carberp, Facebook and ddos.plug</a></li>
<li><a href="../137311/index.html">Google+ information flow on Ruby, Rails, Sinatra</a></li>
<li><a href="../137313/index.html">Price high availability</a></li>
<li><a href="../137316/index.html">Collisions in 512-bit MD5 blocks</a></li>
<li><a href="../137317/index.html">18 facts about John Skyte</a></li>
<li><a href="../137322/index.html">Where to store user settings</a></li>
<li><a href="../137324/index.html">Cheat Sheet for Django 1.3</a></li>
<li><a href="../137327/index.html">Forwarding a video card to a virtual machine</a></li>
<li><a href="../137329/index.html">E1 + iPhone</a></li>
<li><a href="../137331/index.html">Review of programs for monitoring the consumption of mobile Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>