<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fetching data from ORM is easy! Or not?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 Virtually any information system interacts with external data warehouses in one way or another. In most cases, this is a relational d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fetching data from ORM is easy! Or not?</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/uv/4h/wb/uv4hwblmcfkf-f6018hxpbkf1s8.jpeg"></p><br><h2 id="vvedenie">  Introduction </h2><br><p>  Virtually any information system interacts with external data warehouses in one way or another.  In most cases, this is a relational database, and, often, an ORM framework is used to work with data.  ORM eliminates most of the routine operations, instead offering a small set of additional abstractions for working with data. </p><br><p>  Martin Fowler published an interesting <a href="https://dzone.com/articles/martin-fowler-orm-hate">article</a> , one of the key thoughts there: “ORMs help us solve a large number of tasks in enterprise applications ... This tool is not pretty, but the problems with which it deals are also not pretty.  I think ORM deserve more respect and more understanding. ” </p><br><p>  We use ORM very intensively in the <a href="https://cuba-platform.com/">CUBA</a> framework, so we know firsthand about the problems and limitations of this technology, since CUBA is used in various projects around the world.  There are many topics that can be discussed in connection with ORM, but we will focus on one of them: the choice between “lazy” (lazy) and “greedy” (eager) ways of sampling data.  Let's talk about different approaches to solving this problem with illustrations from JPA API and Spring, and also tell you how (and why exactly) ORM is used in CUBA and what kind of work we are doing to improve the work with the data in our framework. </p><a name="habracut"></a><br><h2 id="vyborka-dannyh-lenivaya-ili-net">  Data sampling: lazy or not? </h2><br><p> If there is only one entity in your data model, then you most likely will not notice any problems when working with ORM.  Let's look at a small example.  Suppose we have a <code>User ()</code> entity, which has two attributes: <code>ID</code> and <code>Name ()</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  To pull an instance of this entity from the database, we only need to call one method of the <code>EntityManager</code> object: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, id);</code> </pre> <br><p>  Things get a little more interesting when the one-to-many relationship appears: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  If we need to extract a user instance from the database, the question arises: “Do we also choose addresses?”.  And the “right” answer is here: “Depends on ...” In some cases, we will need addresses, in some - not.  Ordinarily, ORM provides two ways to fetch dependent records: lazy and greedy.  By default, most ORMs use the lazy method.  But, if we write this code: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>); em.close(); System.out.println(user.getAddresses().get(<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre> <br><p>  ... then we get an exception <code>“LazyInitException”</code> , which terribly confuses newbies who have just started working with ORM.  And here comes the moment when you need to begin a story about what “Attached” and “Detached” are instances of an entity, what are sessions and transactions. <br>  Yeah, then the entity must be “attached” to the session so that you can select dependent data.  Well, let's not immediately close the transaction, and life will immediately become easier.  And here another problem arises - transactions become longer, which increases the risk of interlocking.  Make transactions shorter?  It’s possible, but if you create many, many small transactions, you’ll get a <a href="https://deti-online.com/skazki/skazki-mamina-sibirjaka/pro-komara-komarovicha-dlinnyi-nos-i-pro-mohnatogo-mishu-korotkii-hvost/">“Tale about Komar Komarovich - a long nose and a hairy Misha - a short tail”</a> about how a horde of bear bear mosquitoes won - so it’s with the database.  If the number of small transactions increases significantly, then performance problems will arise. <br>  As it was said, when retrieving data about a user, the addresses may or may not be required, therefore, depending on the business logic, one must either select the collection or not.  We need to add new conditions to the code ... Hmmm ... Something somehow all gets complicated. </p><br><p>  So, and if to try other type of selection? </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.EAGER) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Well ... I can not say that it will help a lot.  Yes, we’ll get rid of the hated <code>LazyInit</code> and don’t need to check if the entity is attached to the session or not.  But now we may have performance problems, because we don’t always need addresses, and we still select these objects in the server’s memory. <br>  Any more ideas? </p><br><h2 id="spring-jdbc">  Spring jdbc </h2><br><p>  Some developers are so tired of ORM that they switch to alternative frameworks.  For example, on Spring JDBC, which provides the ability to convert relational data into object data in “semi-automatic” mode.  The developer writes requests for each case where one or another set of attributes is needed (or the same code is reused for cases where the same data structures are needed). </p><br><p>  This gives us more flexibility.  For example, you can select only one attribute without creating the corresponding entity object: </p><br><pre> <code class="java hljs">String name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, String.class);</code> </pre> <br><p>  Or choose an object in its usual form: </p><br><pre> <code class="java hljs">User user = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.jdbcTemplate.queryForObject( <span class="hljs-string"><span class="hljs-string">"select id, name from t_user where id = ?"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object[]{<span class="hljs-number"><span class="hljs-number">1L</span></span>}, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RowMapper&lt;User&gt;() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ResultSet rs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowNum)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ User user = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> User(); user.setName(rs.getString(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)); user.setId(rs.getInt(<span class="hljs-string"><span class="hljs-string">"id"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> user; } });</code> </pre> <br><p>  You can also select a list of addresses for the user, you just need to write a little more code and correctly compile a SQL query to avoid the <a href="https://www.javacodegeeks.com/2018/04/jpa-tips-avoiding-the-n-1-select-problem.html">problem of n + 1 queries</a> . </p><br><p>  Soooo, again complicated.  Yes, we control all queries and how data is mapped to objects, but you need to write more code, learn SQL and know how queries are executed in the database.  Personally, I think that knowledge of SQL is an obligatory skill for an application programmer, but not everyone thinks so, and I'm not going to engage in controversy.  After all, knowledge of the x86 assembly instructions these days is also optional.  Let's better think about how to make life easier for programmers. </p><br><h2 id="jpa-entitygraph">  JPA EntityGraph </h2><br><p>  And let's take a step back and think about what we need at all?  It seems that we just need to specify what attributes we really need in each particular case.  Well, let's do it!  JPA 2.1 has a new API - EntityGraph (entity graph).  The idea is very simple: we use annotations to describe what we will choose from the base.  Here is an example: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraphs</span></span>({ <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-only-entity-graph"</span></span>), <span class="hljs-meta"><span class="hljs-meta">@NamedEntityGraph</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>, attributeNodes = {<span class="hljs-meta"><span class="hljs-meta">@NamedAttributeNode</span></span>(<span class="hljs-string"><span class="hljs-string">"addresses"</span></span>)}) }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> <span class="hljs-meta"><span class="hljs-meta">@GeneratedValue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String name; <span class="hljs-meta"><span class="hljs-meta">@OneToMany</span></span>(fetch = FetchType.LAZY) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Set&lt;Address&gt; addresses; <span class="hljs-comment"><span class="hljs-comment">//Getters and Setters here }</span></span></code> </pre> <br><p>  Two graphs are described for this entity: the <code>user-only-entity-graph</code> does not select the <code>Addresses</code> attribute (labeled lazy), while the second graph tells ORM to select this attribute.  If we mark <code>Addresses</code> as eager, the count will be ignored and addresses will be selected anyway. </p><br><p>  So, in JPA 2.1 you can do data sampling like this: </p><br><pre> <code class="java hljs">EntityManager em = entityManagerFactory.createEntityManager(); EntityGraph graph = em.getEntityGraph(<span class="hljs-string"><span class="hljs-string">"user-addresses-entity-graph"</span></span>); Map&lt;String, Object&gt; properties = Map.of(<span class="hljs-string"><span class="hljs-string">"javax.persistence.fetchgraph"</span></span>, graph); User user = em.find(User.class, <span class="hljs-number"><span class="hljs-number">1</span></span>, properties); em.close();</code> </pre> <br><p>  This approach greatly simplifies the work, you do not need to think separately about the lazy attributes, and the length of the transaction.  An additional bonus is the graph applied at the SQL query level, so “extra” data is not selected in a Java application.  But there is one small problem: you cannot say which attributes were selected and which were not.  To check there is an API, this is done using the <code>PersistenceUtil</code> class: </p><br><pre> <code class="java hljs">PersistenceUtil pu = entityManagerFactory.getPersistenceUnitUtil(); System.out.println(<span class="hljs-string"><span class="hljs-string">"User.addresses loaded: "</span></span> + pu.isLoaded(user, <span class="hljs-string"><span class="hljs-string">"addresses"</span></span>));</code> </pre> <br><p>  But it is rather sad and not everyone is ready to do such checks.  Is it possible to simplify something and just not show attributes that were not selected? </p><br><h2 id="proekcii-spring">  Spring projections </h2><br><p>  There is a great thing in the Spring Framework called “ <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">Projections</a> ” (and this is not the same thing as the <a href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html">projections in Hibernate</a> ).  If you need to select only some attributes of an entity, an interface is created with the necessary attributes, and Spring selects the “instances” of this interface from the database.  As an example, consider the following interface: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NamesOnly</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  You can now define the Spring JPA repository to select User entities as follows: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Collection&lt;NamesOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String lastname)</span></span></span></span>; }</code> </pre> <br><p>  In this case, after calling the findByName method, in the resulting list we will get entities that have access open only to attributes that are defined in the interface!  By the same principle, it is possible to choose dependent entities, i.e.  We immediately select the “master-detail” relationship.  Moreover, Spring generates the “correct” SQL in most cases, i.e.  Only those attributes that are described in the projection are selected from the database; this is very similar to how entity graphs work. <br>  This is a very powerful API, when defining interfaces you can use SpEL expressions, use classes with some built-in logic instead of interfaces, and much more, the <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">documentation</a> describes everything in great detail. <br>  The only problem with the projections is that inside they are implemented as “key-value” pairs, i.e.  are read only.  And this means that even if we define the setter method for the projection, we will not be able to save the changes either through the CRUD repository or through the EntityManager.  So the projections are those DTOs that can be converted back to Entity and saved only if you write your own code for this. </p><br><h2 id="kak-vybirayutsya-dannye-v-cuba">  How data is selected in CUBA </h2><br><p>  From the very beginning of the development of the CUBA framework, we tried to optimize a part of the code that works from the database.  In CUBA, we use <a href="https://www.eclipse.org/eclipselink/">EclipseLink</a> as the basis for the data access API.  What is good about EclipseLink is that it supported partial loading of entities from the very beginning, and this was a decisive factor in the choice between it and Hibernate.  In EclipseLink, it was possible to specify attributes to load long before the JPA 2.1 standard appeared.  CUBA has its own way of describing an entity graph, called <a href="https://doc.cuba-platform.com/manual-7.0/views.html">CUBA Views (CUBA views)</a> .  Views CUBA is a rather advanced API, you can inherit some views from others, combine them, applying both to the master and to the detail entities.  Another motivation for creating CUBA views is that we wanted to use short transactions so that we could work with detached entities in the user web interface. <br>  In CUBA, views are described in an XML file, as in the example below: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.sample.User"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">extends</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"_minimal"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user-minimal-view"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"addresses"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">view</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"address-street-only-view"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">property</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">view</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  This view selects the <code>User</code> entity and its local <code>name</code> attribute, and also selects addresses by applying the <code>address-street-only-view</code> representation to them.  All this happens (attention!) At the SQL query level.  When a view is created, you can use it in retrieving data using the DataManager class: </p><br><pre> <code class="java hljs">List&lt;User&gt; users = dataManager.load(User.class).view(<span class="hljs-string"><span class="hljs-string">"user-edit-view"</span></span>).list();</code> </pre> <br><p>  This approach works fine, while economically consuming network traffic, since unused attributes are simply not transferred from database to application, but, as in the case of JPA, there is a problem: you cannot say which attributes of the entity were loaded.  And in CUBA there is an exception <code>“IllegalStateException: Cannot get unfetched attribute [...] from detached object”</code> , which, like <code>LazyInit</code> , must have been met by everyone who writes using our framework.  As in JPA, there are ways to check which attributes have been loaded and which are not, but, again, writing such checks is a tedious, painstaking exercise, which is very frustrating for developers.  We need to come up with something else in order not to burden people with work that, in theory, machines can do. </p><br><h2 id="koncept---cuba-view-interfaces">  Concept - CUBA View Interfaces </h2><br><p>  But what if all the same to try to combine the graphs of entities and projections?  We decided to try to do this and developed interfaces for representing entities (entity view interfaces) that repeat the approach from the Spring projections.  These interfaces are translated to CUBA views when the application is started and can be used in DataManager.  The idea is simple: we describe the interface (or set of interfaces), which is the entity graph. </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserMinimalView</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String val)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;AddressStreetOnly&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAddresses</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressStreetOnly</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseEntityView</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Address</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStreet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String street)</span></span></span></span>; } }</code> </pre> <br><p>  It should be noted that for some specific cases, you can make local interfaces, as in the case of <code>AddressStreetOnly</code> from the example above, in order not to “pollute” the public API of your application. </p><br><p>  In the process of starting the CUBA application (most of which is the initialization of the Spring context), we programmatically create CUBA views and put them into the internal bin repository in the context. <br>  Now, we need to slightly change the implementation of the DataManager class so that it accepts interface views, and you can select entities as follows: </p><br><pre> <code class="java hljs">List&lt;UserMinimalView&gt; users = dataManager.load(UserMinimalView.class).list();</code> </pre> <br><p>  Under the hood, a proxy object is generated that implements the interface and wraps the entity instance selected from the database (in much the same way as in Hibernate).  And, when the developer requests an attribute value, the proxy delegates the method call to the “real” instance of the entity. </p><br><p>  When developing this concept, we are trying to kill two birds with one stone: </p><br><ul><li>  Data that is not described in the interface is not loaded into the application, thereby we save server resources. </li><li>  The developer can use only those attributes that are accessible via the interface (and, therefore, selected from the database), thereby <code>UnfetchedAttribute</code> exceptions, about which we wrote above. </li></ul><br><p>  Unlike the Spring projections, we wrap the entities in proxy objects; in addition, each interface inherits the standard CUBA interface - <code>Entity</code> .  This means that the attributes of the Entity View can be changed, and then save these changes to the database using the standard CUBA API for working with data. <br>  And, by the way, “the third hare” - you can make attributes read-only if you define an interface with getter methods only.  Thus, we are already at the API level of the entity, we set the modification rules. <br>  In addition, you can do some local operations for detached entities using the available attributes, for example, name string conversion, as in the example below: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MetaProperty</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNameLowercase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getName().toLowerCase(); }</code> </pre> <br><p>  Note that computed attributes can be removed from the entity class model and transferred to interfaces that apply to specific business logic. </p><br><p>  Another interesting feature is interface inheritance.  You can make several representations with different sets of attributes, and then combine them.  For example, you can create an interface for a User entity with name and email attributes, and another with name and addresses attributes.  Now, if you need to choose name, email and addresses, then you do not need to copy these attributes to the third interface, you just need to inherit from the first two views.  And yes, instances of the third interface can be passed to methods that take parameters with the type of parent interface, the OOP rules are the same for everyone. </p><br><p>  A conversion between views was also implemented - in each interface there is a reload () method, to which you can pass the view class as a parameter: </p><br><pre> <code class="java hljs">UserFullView userFull = userMinimal.reload(UserFullView.class);</code> </pre> <br><p>  The UserFullView may contain additional attributes, so the entity will be reloaded from the database, if necessary.  And this process is deferred.  A call to the database will be made only when the first call to the attributes of the entity occurs.  This will slightly slow down the first call, but this approach was deliberately chosen - if an entity instance is used in the “web” module, which contains the UI and its own REST controllers, then this module can be deployed on a separate server.  This means that the forced overload of the entity will create additional network traffic - access to the core module and then to the database.  Thus, postponing overload until the moment when it is necessary, we save traffic and reduce the number of queries to the database. </p><br><p>  The concept is designed as a module for CUBA, an example of use can be downloaded from <a href="https://github.com/cuba-rnd/entity-views-sample">GitHub</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  It seems that in the near future we will still be massively using ORM in enterprise applications simply because we need something that will turn relational data into objects.  Of course, for complex, unique, super-loaded applications, some specific solutions will be developed, but it seems that ORM frameworks will live as much as relational databases. <br>  In CUBA, we try to simplify the work with ORM to the maximum, and in the next versions we will introduce new features for working with data.  Whether it will be interface-representations or something else is difficult to say now, but I am sure of one thing: we will continue to simplify working with data in future versions of the framework. </p><cut></cut></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/451986/">https://habr.com/ru/post/451986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451970/index.html">Thrangrycat: a critical vulnerability in the firmware of Cisco devices allows hackers to install backdoors on them</a></li>
<li><a href="../451974/index.html">The history of AMD: 50 years of rapid development</a></li>
<li><a href="../451976/index.html">How much is a "sovereign" Runet?</a></li>
<li><a href="../45198/index.html">States vs Chinese Hackers</a></li>
<li><a href="../451982/index.html">The sooner you forget OOP, the better for you and your programs.</a></li>
<li><a href="../451990/index.html">FAQ about transfers and connecting flights: what's the difference that a passenger can and cannot do</a></li>
<li><a href="../451996/index.html">My experience of mistakes</a></li>
<li><a href="../451998/index.html">Problems of precision farming and how to live with them</a></li>
<li><a href="../452/index.html">Oleg Divov wrote a book about Habr</a></li>
<li><a href="../4520/index.html">Orthodox activists want "Runet Award"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>