<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interception of Linux kernel functions using exceptions (do-it-yourself kprobes)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intercepting kernel functions is a basic method that allows you to redefine (complement) its various mechanisms. Taking into account the fact that, wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interception of Linux kernel functions using exceptions (do-it-yourself kprobes)</h1><div class="post__text post__text-html js-mediator-article">  Intercepting kernel functions is a basic method that allows you to redefine (complement) its various mechanisms.  Taking into account the fact that, with the exception of small architecture-dependent parts, the Linux kernel is written almost entirely in C, it can be argued that to embed into most of the kernel components, it is enough to have the ability to intercept the relevant ULA functions that implement this or that logic. <br><br>  This article is a practical generalization of the articles presented earlier: <br><ol><li>  <a href="http://habrahabr.ru/post/196952/">Managed by PageFault in the Linux kernel</a> </li><li>  <a href="http://habrahabr.ru/post/207122/">A kosher way to modify write-protected areas of the Linux kernel</a> </li></ol><br>  Further, it will be discussed how the use of these materials can be applied in providing the ability to intercept functions of the Linux kernel. <br><a name="habracut"></a><br><h4>  Short about interception </h4><br><br>  The purpose of intercepting any function is to get control at the time it is called.  Further actions depend on specific tasks.  In some cases, it is necessary to replace the system implementation of the algorithm with its own, in others - to supplement it.  In this case, it is important to leave the possibility of using the intercepted function for its own purposes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The traditional approach to intercepting is to use the concept of ‚Äúwrappers‚Äù, which allows pre-and post-processing to be implemented while preserving the ability to access the original functionality represented by the intercepted function. <br><br>  As is known, the basis of most methods for intercepting functions is patching - modifying the kernel code so that it can transfer control to the interceptor function when the target function is called.  In this case, due to the developed command system of the x86 architecture, it is possible that there are many options for changing the flow <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <h4> <code><code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code></code> </h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <ul><li> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </li> <li> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </li> <li> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </li> </ul> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <pre> <code class="hljs haskell"><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code><span class="hljs-type"><span class="hljs-type">JMP</span></span> -    : ). <br> <br>        ,       ,    ,      .  ,      ,         <span class="hljs-string"><span class="hljs-string">" "</span></span>. <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              <span class="hljs-type"><span class="hljs-type">UD2</span></span></code>         .       ( <code>#<span class="hljs-type"><span class="hljs-type">UD</span></span></code> )     .       <span class="hljs-type"><span class="hljs-type">Linux</span></span> <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code><span class="hljs-type"><span class="hljs-type">INT3</span></span></code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">55</span></span> push %rbp ffffffff8118dd81: <span class="hljs-number"><span class="hljs-number">48</span></span> <span class="hljs-number"><span class="hljs-number">89</span></span> e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: <span class="hljs-number"><span class="hljs-number">0</span></span>f b0 ud2 =&gt;  #<span class="hljs-type"><span class="hljs-type">UD</span></span> ffffffff8118dd82: <span class="hljs-number"><span class="hljs-number">89</span></span> e5 ??? ffffffff8118dd84: e8 f7 b7 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">00</span></span> callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: <span class="hljs-number"><span class="hljs-number">40</span></span> f6 c6 <span class="hljs-number"><span class="hljs-number">02</span></span> test $<span class="hljs-number"><span class="hljs-number">0x2</span></span>,%sil</code> <br> <br>       <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(inode_permission); ... result = <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(inode_permission, inode, mode); ... <span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href=""><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span></a>    <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span></a>      <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span></a>  <a href=""><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span></a> <br>         ,       . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(...)</code>     () ,         ,           . <br> <br>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_INC</span></span>(...)</code>  <code><span class="hljs-type"><span class="hljs-type">KHOOK_USAGE_DEC</span></span>(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  <span class="hljs-string"><span class="hljs-string">""</span></span>,      . <br> <br>     <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias(<span class="hljs-string"><span class="hljs-string">"khook_"</span></span>#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ <span class="hljs-string"><span class="hljs-string">".rept 0x20\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".byte 0x90\n"</span></span> \ <span class="hljs-string"><span class="hljs-string">".endr\n"</span></span> \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(<span class="hljs-string"><span class="hljs-string">".khook"</span></span>),aligned(<span class="hljs-number"><span class="hljs-number">1</span></span>))) __khook_##t #define <span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = <span class="hljs-type"><span class="hljs-type">ATOMIC_INIT</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (<span class="hljs-number"><span class="hljs-number">32</span></span> nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (<span class="hljs-string"><span class="hljs-string">".khook"</span></span>).        <code><span class="hljs-type"><span class="hljs-type">DECLARE_KHOOK</span></span>(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = <span class="hljs-number"><span class="hljs-number">0</span></span>; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (extable == <span class="hljs-type"><span class="hljs-type">NULL</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"Memory allocation failed\n"</span></span>); return -<span class="hljs-type"><span class="hljs-type">ENOMEM</span></span>; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); s-&gt;origin_map = map_writable(s-&gt;origin, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (init_origin_stub(s) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* <span class="hljs-type"><span class="hljs-type">OK</span></span>, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug(<span class="hljs-string"><span class="hljs-string">"Failed to initalize \"%s\" hook"</span></span>, s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;extable = extable; <span class="hljs-type"><span class="hljs-type">THIS_MODULE</span></span>-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, <span class="hljs-type"><span class="hljs-type">NULL</span></span>, <span class="hljs-type"><span class="hljs-type">NULL</span></span>); return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atomic_read(&amp;s-&gt;usage) == <span class="hljs-number"><span class="hljs-number">1</span></span>) x86_put_ud2(s-&gt;target_map); } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code><span class="hljs-type"><span class="hljs-type">UD2</span></span></code>       . <br> <br>        ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,           - - ( <code>khook_origin_...</code> ).  ,        ( <code><span class="hljs-type"><span class="hljs-type">JMP</span></span></code> )   <span class="hljs-string"><span class="hljs-string">""</span></span>   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, <span class="hljs-type"><span class="hljs-type">BITS_PER_LONG</span></span>, \ <span class="hljs-type"><span class="hljs-type">UD_VENDOR_ANY</span></span>, (void *)s-&gt;target, <span class="hljs-number"><span class="hljs-number">32</span></span>); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != <span class="hljs-type"><span class="hljs-type">UD_Iret</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iud2</span></span> || ud.mnemonic == <span class="hljs-type"><span class="hljs-type">UD_Iint3</span></span>) { debug(<span class="hljs-string"><span class="hljs-string">"It seems that \"%s\" is not a hooking virgin\n"</span></span>, s-&gt;name); return -<span class="hljs-type"><span class="hljs-type">EINVAL</span></span>; } #define <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> s-&gt;length += ud_insn_len(&amp;ud); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s-&gt;length &gt;= <span class="hljs-type"><span class="hljs-type">UD2_INSN_LEN</span></span>) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define <span class="hljs-type"><span class="hljs-type">KHOOK_ORIGIN</span></span>(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     <span class="hljs-type"><span class="hljs-type">Linux</span></span>.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </pre> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> <h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </h4> <code><a href="http://jbremer.org/x86-api-hooking-demystified/"></a> <a href="http://habrahabr.ru/post/196952/"></a> <code>JMP -    : ). <br> <br>        ,       ,    ,      .  ,      ,         " ". <br> <br>    <br> <br> ,          ,       ,       ,     . <br> <br>  ,              UD2</code>         .       ( <code>#UD</code> )     .       Linux <a href="https://www.kernel.org/doc/Documentation/kprobes.txt">kprobes</a> ,   ,       <code>INT3</code> . <br> <br> ,     <a href="">inode_permission</a>  : <br> <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 55 push %rbp ffffffff8118dd81: 48 89 e5 mov %rsp,%rbp ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>        ,       <br> <code class="cpp">ffffffff8118dd80 &lt;inode_permission&gt;: ffffffff8118dd80: 0f b0 ud2 =&gt;  #UD ffffffff8118dd82: 89 e5 ??? ffffffff8118dd84: e8 f7 b7 4f 00 callq ffffffff81689580 &lt;mcount&gt; ffffffff8118dd89: 40 f6 c6 02 test $0x2,%sil</code> <br> <br>       <code>UD2</code>     ,   <a href="http://habrahabr.ru/post/196952/"></a>      <code>ffffffff8118dd80</code>  ,     ,       . <br> <br>     <br> <br>  ,       ,            .  ,     ,               .         (),   -    . ,         ,    ,    ,   . <br> <br> ,          <a href=""></a> : <br> <br> <code class="cpp">#include &lt;linux/fs.h&gt; // inode_permission() prototype lives here DECLARE_KHOOK(inode_permission); int khook_inode_permission(struct inode * inode, int mode) { int result; KHOOK_USAGE_INC(inode_permission); ... result = KHOOK_ORIGIN(inode_permission, inode, mode); ... KHOOK_USAGE_DEC(inode_permission); return result; }</code> <br> <br>   ,       <a href="">inode_permission</a> .  ,     : <br>   <a href="">DECLARE_KHOOK</a>    <a href="">KHOOK_ORIGIN</a>      <a href="">KHOOK_USAGE_INC</a>  <a href="">KHOOK_USAGE_DEC</a> <br>         ,       . <br> <br>  <code>DECLARE_KHOOK(...)</code>        ,      ,        -,     ,    <code>khook_...</code> <br> <br>  <code>KHOOK_ORIGIN(...)</code>     () ,         ,           . <br> <br>  <code>KHOOK_USAGE_INC(...)</code>  <code>KHOOK_USAGE_DEC(...)</code>      ,      ,   ,        . <br> <br>     <br> <br> ,     <code>DECLARE_KHOOK(...)</code>     <a href=""></a> : <br> <br> <code class="cpp">typedef struct { /* tagret's name */ char * name; /* target's insn length */ int length; /* target's handler address */ void * handler; /* target's address and rw-mapping */ void * target; void * target_map; /* origin's address and rw-mapping */ void * origin; void * origin_map; atomic_t usage; } khookstr_t;</code> <br> <br>   : <code>name</code> -   , <code>length</code> -     , <code>handler</code> -  -, <code>target</code> -    , <code>target_map</code> -       , <code>origin</code> -  -,      , <code>origin_map</code> -       , <code>usage</code> -  "",      . <br> <br>     <code>DECLARE_KHOOK(...)</code> ,            : <br> <br> <code class="cpp">#define __DECLARE_TARGET_ALIAS(t) \ void __attribute__((alias("khook_"#t))) khook_alias_##t(void) #define __DECLARE_TARGET_ORIGIN(t) \ void notrace khook_origin_##t(void) { \ asm volatile ( \ ".rept 0x20\n" \ ".byte 0x90\n" \ ".endr\n" \ ); \ } #define __DECLARE_TARGET_STRUCT(t) \ khookstr_t __attribute__((unused,section(".khook"),aligned(1))) __khook_##t #define DECLARE_KHOOK(t) \ __DECLARE_TARGET_ALIAS(t); \ __DECLARE_TARGET_ORIGIN(t); \ __DECLARE_TARGET_STRUCT(t) = { \ .name = #t, \ .handler = khook_alias_##t, \ .origin = khook_origin_##t, \ .usage = ATOMIC_INIT(0), \ }</code> <br> <br>   <code>__DECLARE_TARGET_ALIAS(...)</code> , <code>__DECLARE_TARGET_ORIGIN(...)</code>     (32 nop').     <code>__DECLARE_TARGET_STRUCT(...)</code> ,   <code>section</code>      (".khook").        <code>DECLARE_KHOOK(...)</code> . <br> <br>  ,         ,     .      : <br> <br> <code class="cpp">extern khookstr_t __khook_start[], __khook_finish[]; #define khook_for_each(item) \ for (item = __khook_start; item &lt; __khook_finish; item++)</code> <br> <br> ,          .         ,     ,      .     <a href=""></a> : <br> <br> <code class="cpp">static int init_hooks(void) { khookstr_t * s; int num_exentries = 0; struct exception_table_entry * extable; extable = (void *)pfnModuleAlloc(sizeof(*extable) * (__khook_finish - __khook_start)); if (extable == NULL) { debug("Memory allocation failed\n"); return -ENOMEM; } khook_for_each(s) { s-&gt;target = get_symbol_address(s-&gt;name); if (s-&gt;target) { s-&gt;target_map = map_writable(s-&gt;target, 32); s-&gt;origin_map = map_writable(s-&gt;origin, 32); if (s-&gt;target_map &amp;&amp; s-&gt;origin_map) { if (init_origin_stub(s) == 0) { struct exception_table_entry * entry = &amp;extable[num_exentries++]; /* OK, the stub is initialized */ atomic_inc(&amp;s-&gt;usage); extable_make_insn(entry, (unsigned long)s-&gt;target); extable_make_fixup(entry, (unsigned long)s-&gt;handler); continue; } } } debug("Failed to initalize \"%s\" hook", s-&gt;name); } pfnSortExtable(extable, extable + num_exentries); THIS_MODULE-&gt;extable = extable; THIS_MODULE-&gt;num_exentries = num_exentries; /* apply patches */ stop_machine(do_init_hooks, NULL, NULL); return 0; }</code> <br> <br>     ,     <a href="http://habrahabr.ru/post/207122/"></a> ,             <code>stop_machine</code> : <br> <br> <code class="cpp">static int do_init_hooks(void * arg) { khookstr_t * s; khook_for_each(s) { if (atomic_read(&amp;s-&gt;usage) == 1) x86_put_ud2(s-&gt;target_map); } return 0; }</code> <br> <br>    <code>do_init_hooks</code> ,       . ,     -   <code>UD2</code>       . <br> <br>        ,     "",           - - ( <code>khook_origin_...</code> ).  ,        ( <code>JMP</code> )   ""   .   ,      ,      ,     <a href=""></a> : <br> <br> <code class="cpp">static int init_origin_stub(khookstr_t * s) { ud_t ud; ud_initialize(&amp;ud, BITS_PER_LONG, \ UD_VENDOR_ANY, (void *)s-&gt;target, 32); while (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { if (ud.mnemonic == UD_Iud2 || ud.mnemonic == UD_Iint3) { debug("It seems that \"%s\" is not a hooking virgin\n", s-&gt;name); return -EINVAL; } #define UD2_INSN_LEN 2 s-&gt;length += ud_insn_len(&amp;ud); if (s-&gt;length &gt;= UD2_INSN_LEN) { memcpy(s-&gt;origin_map, s-&gt;target, s-&gt;length); x86_put_jmp(s-&gt;origin_map + s-&gt;length, s-&gt;origin + s-&gt;length, s-&gt;target + s-&gt;length); break; } } return 0; }</code> <br> <br>          <a href=""></a> ,  : <br> <br> <code class="cpp">#define KHOOK_ORIGIN(t, ...) \ ((typeof(t) *)__khook_##t.origin)(__VA_ARGS__)</code> <br> <br>  <br> <br>    ,                     Linux.            ,    <a href="https://github.com/milabs/kmod_hooking/">github</a>       ,    .</code> </div><p>Source: <a href="https://habr.com/ru/post/206778/">https://habr.com/ru/post/206778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206754/index.html">Delphi XE5 + Android: First Impressions</a></li>
<li><a href="../206758/index.html">What to write in the subject of the letter: choose words wisely</a></li>
<li><a href="../206762/index.html">A beta version of the product for the visual creation of Windows 8.1 applications Microsoft Project Siena</a></li>
<li><a href="../206768/index.html">About Vagrant, its plugins, and other life stories of vagrants</a></li>
<li><a href="../206770/index.html">Technical Details on BitTorrent Secure P2P Chat</a></li>
<li><a href="../206780/index.html">Five innovations that will change our lives in the next five years</a></li>
<li><a href="../206782/index.html">Christmas Raspberry - Screw the HD44780 to Raspberry Pi</a></li>
<li><a href="../206786/index.html">New Year's Report Habrapost - 2014</a></li>
<li><a href="../206788/index.html">Programming for Android. For professionals</a></li>
<li><a href="../206790/index.html">Android We work with MS SQL without intermediaries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>