<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Time constraints and static time analysis FPGA on the example of Microsemi SmartTime</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Even while studying at the university, designing various test gadgets and performing laboratory work on digital circuitry, I got into a situation wher...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Time constraints and static time analysis FPGA on the example of Microsemi SmartTime</h1><div class="post__text post__text-html js-mediator-article">  Even while studying at the university, designing various test gadgets and performing laboratory work on digital circuitry, I got into a situation where the seemingly correct rechecked project several times refuses to work ‚Äúin hardware‚Äù.  At that time, at the dawn of learning programmable logic, I somehow very rarely got to get to the last points of Design Flow, in which, probably, the trouble lay.  If I accidentally clicked Timing Analyzer with an accidental click, then after a few seconds, a quick glance became boring, and I would return to the bullying over the debug board and write new frenzy on VHDL. <br><br>  When the time came for more or less adequate and serious projects, there were more problems, respectively, I began to use Google more intensively and search for answers to my questions.  Then I increasingly began to come across such terrible phrases as ‚Äútiming analysis‚Äù and ‚Äúdesign constraints‚Äù, when I read and penetrated a little, I realized that I had missed something very important.  At first, I was terribly afraid of these unknown constraints, and without them, the first projects worked successfully, since the frequency there was no more than a couple of tens of MHz.  But when it comes to higher frequencies and more complex projects, we can‚Äôt do without thorough time analysis and optimization. <a name="habracut"></a>  As I communicated with people, I was surprised to find that not all of our developers are sufficiently familiar with these processes, which is probably due to the very small amount of documentation and explanations in Russian.  Therefore, I decided to share what I had accumulated during the work with the FPGA, using tools from the company Microsemi (probably better known as Actel).  This post in no case claims 100% completeness and accuracy, just the result of the desire to decompose knowledge on the shelves and, perhaps, help someone to do the same.  All comments and suggestions are welcome. <br><br><h3>  Synchronous schemes and basic definitions </h3><br>  So, as a rule, we are dealing with synchronous circuits.  Such schemes consist of the following elements: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  I / O ports; </li><li>  consecutive elements (triggers); </li><li>  combinational logic (gates). </li></ul><br>  The connections of these elements constitute the paths of the signals that pass through the device during operation.  Actually, I have already identified the key concept - the <i>way</i> .  They just determine the performance of the device, in particular, they determine the maximum clock frequency, one of the basic requirements of the project and what developers have been fighting for so long. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/files/89d/823/4f8/89d8234f8e26485f848b7cf198a156a0.png"></div><br>  The signals begin their journey from the input pins of the microcircuit, pass through sequential and combinational elements and arrive at the output pins.  The clock frequency source (CLK) clocks all the triggers of the circuit, which remember the state at its input by the edge of the clock signal (most often on the front).  Between the triggers (as well as between I / O ports) is the combinational logic.  On the way the signal is prevented by two types of delays: <br><br><ul><li>  cell delay; </li><li>  propagation delay; </li></ul><br><br>  Usually their ratio is 50/50, that is, the path in the wilds of combinational circuits in half is divided between the delay from the next gate's input to its output and the propagation of the signal along the communication lines.  The maximum delay in the circuit corresponds to the <i>critical path</i> , that is, the longest path, which determines the longest period and, accordingly, the maximum frequency of the device.  Here it is necessary to consider a few basic concepts. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/files/0c2/eef/6a5/0c2eef6a5a91436da54e72d498223d7a.png"></div><br><br>  Naturally, when transmitting a signal, two sides of the interaction appear in an obvious way - the source and the receiver.  These are the <i>end points of the</i> path.  Endpoints can be I / O ports and triggers.  Let's stop on triggers.  In our case, they are clocked by one clock signal, and the path runs from the output Q of one trigger to the input D of the second.  Although the clock signal is one, in this example we give it two names: <br><br><ul><li>  Launch clock - on the front, new data arrive at output Q of trigger 1; </li><li>  Latch clock - on the front trigger 2 remembers what is currently at input D. </li></ul><br><br>  Since the data is distributed with a delay caused by the above factors, the signal at the input D of trigger 2 does not appear immediately.  This implies the following characteristics: <br><br><ul><li>  Setup time (t <sub>su</sub> ) - the time for which the signal should be set to the front of clk receiver; </li><li>  Hold time (t <sub>h</sub> ) - the time that the signal should be held after the front clk of the receiver; </li><li>  Slack determines <i>the time margin</i> for t <sub>su</sub> and t <sub>h</sub> . </li></ul><br><br>  t <sub>su</sub> and t <sub>h</sub> form a kind of corridor, the core of which is the front latch clock.  Now the requirements for the signal at the input D of the receiver are simple - it should not change within this corridor.  That is, in the ideal case, to be established long before its left border and change the value to a new one some time after the right border.  This very time reserve is called Slack.  If Slack is a positive number, then everything is in order, and the data will have time to arrive at the receiver input at the required time, if negative - the specified path does not satisfy the time characteristics, that is, the data arrive at the input outside the required time interval, which means the device will not work correctly . <br><br>  Actually, here the difficulties begin.  If you do not have a training scheme with a couple of dozen triggers, but a complicated HDL description that causes headaches when viewing a graphical RTL model, the likelihood of such long paths that dramatically undermine performance increases significantly.  In order to control this process and tell the IDE your wishes regarding the project‚Äôs time characteristics, the latter contain several handy tools. <br><br><h3>  Timing Constraints </h3><br>  Before starting to design a new device, the developer should have as much information as possible about the requirements for this device and its performance.  First of all, it is the time characteristics of this system.  And when they are known to him, you need to report this to the design tool, and then <i>time limits</i> or <i>time lines</i> come to the <i>rescue</i> .  Time constraints are information about the requirements for the project‚Äôs time characteristics, set out in a language that is understandable, most often <i>Synopsis Design Constraints, SDC</i> .  This is the de facto standard for describing temporal (and not only) constraints for FPGAs, based on Tcl, which, by the way, is in itself commonly used to automate equipment development. <br><br>  These descriptions are placed in the * .sdc file and attached to the project.  Consumers of this file are all kinds of optimizers, who are trying to dilute the crystal so that it meets the requirements of the developer, as well as the time analyzers, which will be discussed further.  Sdc files are simple; in fact, this is a list of commands with arguments and their values.  When describing, you can (and should) use the Tcl syntax, including special characters, for example, to place a single command on several lines. <br><br>  So, we list a few basic commands and see what they describe.  The first team and definitely must have for absolutely any design: <br><br><pre><code class="hljs pgsql">create_clock -<span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> -period period_value [-waveform edge_list] source</code> </pre> <br>  This command defines the clock signal in the circuit and describes its characteristics: <br><br>  Name of the string <br><pre> <code class="hljs pgsql">-<span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span></code> </pre><br>  Period <br><pre> <code class="hljs diff"><span class="hljs-deletion"><span class="hljs-deletion">-period period_value</span></span></code> </pre><br>  Duty ratio (default is 2), square brackets indicate an optional argument <br><pre> <code class="hljs json">[-waveform edge_list]</code> </pre><br>  Signal source (pin, port) <br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">source</span></span></code> </pre><br>  Knowledge of CAD tools on the clock signal is most important, since without this there can be no analysis and optimization of speech.  Then you can further refine the information about the clock signal using the commands set_clock_latency, set_clock_uncertainty, etc., but here we will not consider this, relying on the default values ‚Äã‚Äãset in the environment.  As an example: <br><br><pre> <code class="hljs objectivec">create_clock -name {my_clock} ‚Äìperiod <span class="hljs-number"><span class="hljs-number">6</span></span> ‚Äìwaveform {<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>} {<span class="hljs-built_in"><span class="hljs-built_in">CLK</span></span>}</code> </pre><br>  This command creates a clock signal with a period of 6 ns, within which the front will be at 0 ns, and the decay at the 3rd. <br><br><div style="text-align:center;"><img width="500" src="https://habrastorage.org/files/de4/6bf/9e9/de46bf9e9c18428392b88c9c5eafe7fc.png"></div><br><br>  Another useful command related to the clock signal: <br><br><pre> <code class="hljs pgsql">create_generated_clock -<span class="hljs-type"><span class="hljs-type">name</span></span> {<span class="hljs-type"><span class="hljs-type">name</span></span> -source reference_pin [-divide_by divide_factor] [-multiply_by multiply_factor] [-invert] source</code> </pre> <br>  It describes the clock signal that is generated inside the chip, usually in phase-locked loop (PLL) circuits.  Actually, the arguments for the most part repeat the settings specified in the PLL ‚Äî the source of the original signal, the division and multiplication coefficients, the signal inversion, etc.  Since PLL is used everywhere, this is also quite an important command, which is common. <br><br>  Let us proceed to the consideration of the commands that set the limitations and design requirements.  The first pair of teams: <br><br><pre> <code class="hljs lua">set_input_delay delay_value -<span class="hljs-built_in"><span class="hljs-built_in">clock</span></span> clock_ref [‚Äì<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>] [‚Äì<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>] [‚Äìclock_fall] input_list set_output_delay delay_value -<span class="hljs-built_in"><span class="hljs-built_in">clock</span></span> clock_ref [‚Äì<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>] [‚Äì<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>] [‚Äìclock_fall] output_list</code> </pre> <br>  Important limitations if the design interacts with external devices (and this is always the case).  Sets the delay for the external to the FPGA signal (input or output) with reference to the clock signal.  Interacting with other devices, we must take into account their temporal characteristics, for which these two constructions serve.  For example, there is our FPGA, any device that exchanges data with us, a clock generator that serves as a common source of clock pulses.  In order to effectively conduct a time analysis and tracing, it would be nice to know how the signal will come to us and how we give it to the outside.  Usually such information is described in the corresponding datasheets for products, so the task usually comes down to viewing the documentation and rewriting the characteristics into our * .sdc file. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/files/f52/30c/1f4/f5230c1f4c8643fca4487d91a8b9e432.png"></div><br><br>  The arguments here are simple - the value of the delay in nanoseconds, the clock signal, optionally indicating whether the delay is maximum or minimum, we can indicate that the binding is declining, and the last is a list of ports to which to apply. <br><br>  The next pair of commands sets the minimum and maximum delay on the internal path, respectively: <br><br><pre> <code class="hljs pgsql">set_min_delay delay_value [-<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> from_list] [-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> to_list] set_max_delay delay_value [-<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> from_list] [-<span class="hljs-keyword"><span class="hljs-keyword">to</span></span> to_list]</code> </pre> <br>  The arguments are, again, simple - the value of the delay in nanoseconds, the starting point and the ending point.  Typically, such restrictions apply to purely combinational paths from chip inputs to outputs.  This takes into account set_input_delay and set_output_delay and create_clock, if at least one of the end points is a synchronous element.  It can also be used for circuits with several clock domains, providing a reliable transition between them. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/files/ba6/48f/3cd/ba648f3cdee1472d8df2c5c06d11ec75.png"></div><br><br>  We will finish the consideration of the timelines by two teams, which serve to determine the paths, the passage of which takes more than one clock cycle and the false paths.  Here it is necessary to retreat again to tell what these paths are. <br><br>  <i>Multicycle path</i> is a path whose endpoints are triggers, which require more than one clock period for the data passing through it to reach the destination point.  It is very important to identify such paths, since by default all optimization tools consider the circuit as one-cycle, that is, they try to bring all paths like a trigger-trigger to one clock cycle.  For example, some source provides data with a frequency of two times less than the clock frequency.  Then there is no point in catching data on every clock cycle, so this path is marked as multicycle and the signals passing through it are given the privilege to stay at 2 clock cycles.  If this is not done, our instrument will try in vain to optimize this path, while others may suffer, who just require a pass in one measure. <br><br><div style="text-align:center;"><img width="700" src="https://habrastorage.org/files/54f/771/386/54f7713868914b03a64356a1a66dcdac.png"></div><br><br>  <i>Flase path</i> - false paths, such paths even though they physically exist, but there is a reason why we want to exclude them from the optimization and time analysis processes, for example, if during the operation of the device the signal never passes through them.  A simple example: we have a 4-bit counter, but we only need to count to 9, then the counter is always reset.  But it turns out that the increment on larger numbers involves paths with significant delays.  They are present, but, in fact, not needed.  Such paths are marked as a false path and are thus excluded from optimization and temporal analysis.  As in the example with multicycle, if you leave everything as it is, these paths will be optimized with all the ensuing consequences for the rest of the paths. <br><br>  Commands to tame the above paths: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">set_multicycle_path</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ncycles</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[-from from_list]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[‚Äìthrough through_list]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[-to to_list]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">set_false_path</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[-from from_list]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[-through through_list]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[-to to_list]</span></span></code> </pre> <br>  In both teams, the end points are specified as arguments, and in the case of multicycle, the number of ticks, which are given to the signal to go through the path. <br><br>  So, we have considered some commands with which you can set time limits and describe the requirements for the time characteristics of the project.  Their correct task and attentiveness are the key to success when developing devices on an FPGA, but they might as well create significant difficulties and mistakes that are difficult to track down and fix if you describe unrealistic requirements.  Of course, the above is only a drop in the ocean, but it also gives an initial idea and foundation for future study.  More information about these commands and their keys can be read for example in <a href="http://www.microsemi.com/index.php%3Foption%3Dcom_docman%26task%3Ddoc_download%26gid%3D131597">[2]</a> .  We now turn to the practical part and see how the time analysis looks in Libero SoC, the design tool for the Microsemi / Actel FPGA. <br><br><h3>  Time Analysis in Libero SoC SmartTime </h3><br>  Create requirements and introduce time constraints - this is still half the problem.  In this place begins a long and complex process of temporary analysis and the struggle for megahertz.  With more or less adequate complexity of the project from the first time to achieve the desired result will not work.  Therefore, you will have to revise the requirements, make changes to the constraint file and modify the project itself.  Sometimes it is possible to change the FPGA, for example, with the same one, but with greater speedgrade.  But in order not to change and immediately understand which chip meets the needs of the project, there are means of static time analysis. <br><br>  Now the <i>timing analyzer (timing analyzer) is</i> included in every modern CAD equipment development.  With the help of this program, the developer can find out whether his aspirations correspond to the capabilities of the newly born (or maybe already a hundred times recompiled) devices before the FPGA firmware and tests on the full-scale sample.  In modern CAD systems, they have a convenient graphical interface and are amenable to quick mastering. <br><br>  Consider the time analyzer on the example of SmartTime enabled in Libero SoC.  To do this, we will create in the Libero SoC environment a variation of the classic hello world project for the FPGA with a counter and, using his example, let's look at what the time analyzer allows. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5ef/ae9/732/5efae9732df54d2bbcbbee6f62f3efbc.png"></div><br><br>  The project selected a simple crystal of the third generation of FPGA Microsemi - ProASIC3 A3P600 with standard speedgrade in the PQ 208 package. To begin with, let's get the project through Design Flow as it is.  At the same time in the settings of Place &amp; Route you need to select the optimization criteria for time characteristics (Timing-driven). <br><br><img src="https://habrastorage.org/files/c51/665/60d/c5166560d19c43b28e7cc2450dea2e03.png"><img src="https://habrastorage.org/files/658/df0/af1/658df0af13f44dfe8f45d9e228fb1193.png"><br><br>  After that, we will have the Designer tool available, which, among other things, contains a shell for managing time constraints and temporal analysis - SmartTime.  It is represented by two subsystems - Constraints Editor and Timing Analyzer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ce9/9bc/291/ce99bc2917ec404f91c0eedd45861878.png"></div><br><br>  Having opened the Constraints Editor, we can use the user-friendly graphical interface to set the very requirements and restrictions mentioned above and then export the * .sdc file.  So do.  As indicated above, the first and, of course, the necessary construction is the creation of clock signals with the required characteristics.  We have just one, to describe it, follow the menu: Actions -&gt; Constraint -&gt; Clock. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f89/fcf/97e/f89fcf97e2ed4176886220fa1d559a6b.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/files/082/50e/1e4/08250e1e4d0f45e9b6ffd397278bdd84.png"></div><br><br>  We indicate the pin from which the signal should come and imagine that we need the project to operate at 200 MHz.  After clicking OK we will see how the shred appeared in the editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/025/3bf/ca9/0253bfca963d4e789a1af010ad529168.png"></div><br><br>  In order for the changes to take effect, click File -&gt; Commit, and from the Designer window, export the file of restrictions by File -&gt; Export -&gt; Constraint Files ....  By default, it is placed in the constraint folder in the project root.  Let's go back to Design Flow and mark the appeared file top.sdc as used in the Synthesize and Compile sub-items and open it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/28f/f1b/35b/28ff1b35b72940e4ae273a6b9b436de6.png"></div><br><br><pre> <code class="hljs pgsql">################################################################################ # SDC WRITER <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> "3.1"; # DESIGN "top"; # <span class="hljs-keyword"><span class="hljs-keyword">Timing</span></span> constraints scenario: "Primary"; # <span class="hljs-type"><span class="hljs-type">DATE</span></span> "Mon Feb 16 10:48:26 2015"; # VENDOR "Actel"; # PROGRAM "Microsemi Libero Software Release v11.4 SP1"; # <span class="hljs-keyword"><span class="hljs-keyword">VERSION</span></span> "11.4.1.17" Copyright (C) <span class="hljs-number"><span class="hljs-number">1989</span></span><span class="hljs-number"><span class="hljs-number">-2014</span></span> Actel Corp. ################################################################################ <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> sdc_version <span class="hljs-number"><span class="hljs-number">1.7</span></span> ######## Clock Constraints ######## create_clock -<span class="hljs-type"><span class="hljs-type">name</span></span> { Clock } -period <span class="hljs-number"><span class="hljs-number">5.000</span></span> -waveform { <span class="hljs-number"><span class="hljs-number">0.000</span></span> <span class="hljs-number"><span class="hljs-number">2.500</span></span> } { Clock } ######## <span class="hljs-keyword"><span class="hljs-keyword">Generated</span></span> Clock Constraints ######## ######## Clock Source Latency Constraints ######### ######## <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> Delay Constraints ######## ######## Output Delay Constraints ######## ######## Delay Constraints ######## ######## Delay Constraints ######## ######## Multicycle Constraints ######## ######## <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-type"><span class="hljs-type">Path</span></span> Constraints ######## ######## Output <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> Constraints ######## ######## <span class="hljs-keyword"><span class="hljs-keyword">Disable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Timing</span></span> Constraints ######### ######## Clock Uncertainty Constraints #########</code> </pre><br>  We see a specially formatted file, in which our create_clock is present, and the rest of the fields are empty (the corresponding commands can be in their place if you specify them).  Well, we launch Design Flow once again, to the Verify Timing point.  Open Designer again and launch the second subsystem - Timing Analyzer.  By default, the Maximum Delay Analysis View opens, that is, the time delays calculated based on the worst conditions.  Look at the results. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/739/5b8/eea/7395b8eeac244157a68402ea5b9bf51a.png"></div><br><br>  Many have long developed a reflex: red color is bad.  There are exceptions, but not in this case.  Let's go to the Register-to-Register sub-paragraph, which contains information about the paths between the triggers in the only created clock domain in tabular form.  We have some bad results on such paths, a negative Slack has appeared, the time of arrival of the signal at the trigger receiver is more than the calculated maximum allowed.  How this threatens is described in the theoretical part at the beginning of the post.  The benefit here is not so bad - only five ways showed a negative result.  The Slack distribution can be seen in the histogram in the lower left of the window.  Let's start to understand.  To begin with, let's remember what conditions we asked and see what the analyzer said to that. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b84/f06/12c/b84f0612c3664a0ab009bab200998297.png"></div><br><br>  So, we got excited, and our 200 MHz were lowered to 172 MHz f <sub>max</sub> for this project.  Now let's take a closer look at one of the bad ways, for this we will double click on it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c2e/05a/8cf/c2e05a8cf5ef452aa9e618152d58660c.png"></div><br><br>  This opens detailed path information.  We are shown information about the required time of arrival of data (Data Required Time), time of actual arrival of data (Data Arrival Time) and time margin (Slack).  In this case, the path is disclosed in the form of a table with a detailed indication of where and how much the signal is delayed, as well as an image of the connections between the source trigger and the trigger trigger.  The tool also shows how it calculates Data Required Time.  In the upper right corner you can also see a pie chart showing the ratio of the delays on the valves and the delays on the lines of connections. <br><br>  Analyzing the results, we come to the conclusion that the delays on the valves of the combination chain on the way from the trigger of the 2nd digit to the trigger of the 7th digit of the counter do not allow the circuit as a whole to operate at the specified frequency.  Too long and complex combinational way, data do not have time to arrive at the right time, Slack has a negative value.  Such a situation arises at the higher digits for an obvious reason - in order to establish one, the seventh digit needs to make sure that all the others have already been established, respectively there are 8 ways (from all digits, including feedback), and some of them will be unacceptable. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0b7/d66/6cd/0b7d666cd9574d4b9c070653cdba3049.png"></div><br><br>  Thus, because of just a few ways, the design does not work at the desired frequency.  It's a shame.  How to deal with this?  The most common way to improve the performance of synchronous circuits is to eliminate a large number of combinational logic between triggers by dividing the process into stages, this is called <i>pipelining</i> .  In the general case, with this approach, the input data stream arrives as usual, passes through several stages of the conveyor and appears at the exit after a time dependent on the depth of the conveyor.  Depth, that is, the number of steps, is selected based on performance requirements. <br><br>  Let's return to our project and try to apply this approach to achieve the goal that was set.  We divide one 8-bit timer into two 4-bit ones, add a transfer output and a clock enable input.  Connect the transfer output of the first timer with the enable input clock of the second timer via a D-flip-flop.  We get a two-stage pipeline, the first timer represents the lower digits, the second timer represents the older ones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ebf/666/44d/ebf66644dfa94caf9b891dc37f21b164.png"></div><br><br>  Launch the compilation and go to SmartTime.  Voila  Negative Slacks are gone, there are no errors, the frequency has risen to 227 MHz, which is even much more than we needed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ec4/77c/00e/ec477c00e3b747ce8f80a89eb54afc8f.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/files/573/744/1a9/5737441a9fc04a8790191208f2eb073a.png"></div><br><br>  So, using the conveyor technique, we overclocked the frequency of the project with the counter from 172 MHz to 227 MHz, while the functionality was fully preserved, as was the used crystal. <br><br><h3>  Conclusion </h3><br>  Of course, we looked at a very simple case, and this is all very far from real projects and the actual optimization process, when the red head in the time analyzer window starts to hurt, and it takes days to debug the project.  When the example becomes a bit more complicated, a lot of new questions will appear.  How to effectively catch multicycle and false paths?  How to deal with multiple clock domains?  Maybe you can somehow fix the wiring of some elements and fix their temporal characteristics? <br>  But this is a good starting point for beginners to master this difficult task.  And, of course, you should try to do the same thing yourself and try to optimize a more complex project. <br><br><h4>  References: </h4><br>  1. <a href="http://www.microsemi.com/">www.microsemi.com</a> , <a href="http://actel.ru/">actel.ru</a> - the official website of Microsemi with documentation, the site of the official distributor (information in Russian) <br>  2. <a href="http://www.microsemi.com/index.php%3Foption%3Dcom_docman%26task%3Ddoc_download%26gid%3D131597">www.microsemi.com/index.php?option=com_docman&amp;task=doc_download&amp;gid=131597</a> - about lines. <br>  3. <a href="http://www.vlsi-expert.com/p/static-timing-analysis.html">www.vlsi-expert.com/p/static-timing-analysis.html</a> - about static time analysis. <br>  4. <a href="http://vhdlguru.blogspot.ru/2011/01/what-is-pipelining-explanation-with.html">vhdlguru.blogspot.ru/2011/01/what-is-pipelining-explanation-with.html</a> - about pipelining. <br>  5. <a href="http://www.microsemi.com/index.php%3Foption%3Dcom_docman%26task%3Ddoc_download%26gid%3D130940">www.microsemi.com/index.php?option=com_docman&amp;task=doc_download&amp;gid=130940</a> - SmartTime tutorial. </div><p>Source: <a href="https://habr.com/ru/post/252247/">https://habr.com/ru/post/252247/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252229/index.html">Vladimir Ivanov, Oracle - Deep immersion in invokedynamic</a></li>
<li><a href="../252233/index.html">DDoS as a current security issue for a business</a></li>
<li><a href="../252237/index.html">3 best tools for describing RESTful API</a></li>
<li><a href="../252239/index.html">Automate and speed up the process of setting up cloud servers with Ansible. Part 4: working with modules</a></li>
<li><a href="../252245/index.html">New version of Vivaldi Technical Preview 2</a></li>
<li><a href="../252249/index.html">When this == null: the untamed story from the world of the CLR</a></li>
<li><a href="../252255/index.html">Apple's environmental care, IMGA international award, Google Play success - and other news of the week for a mobile developer</a></li>
<li><a href="../252259/index.html">Who earned the most money in the mobile market in 2014</a></li>
<li><a href="../252261/index.html">FPGA - my first steps</a></li>
<li><a href="../252263/index.html">Distributed Captive Portal in public places and Apple issues</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>