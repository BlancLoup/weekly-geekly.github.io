<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing qualifying rounds Technocup</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On March 23 and 26, online, on the IT.Mail.Ru platform together with Codeforces , two qualifying rounds of the Technocup-2016 Programming Olympiad for...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing qualifying rounds Technocup</h1><div class="post__text post__text-html js-mediator-article">  On March 23 and 26, online, on the <a href="https://it.mail.ru/">IT.Mail.Ru</a> platform together with <a href="http://codeforces.com/">Codeforces</a> , two qualifying rounds of the <a href="https://it.mail.ru/technocup/">Technocup-2016</a> Programming Olympiad for pupils of 8‚Äì11th grades were held.  More than one and a half thousand participants from all over Russia and the CIS fought for the opportunity to meet at the Moscow site.  The top 300 reached the final, which will be held on April 17 at the Moscow State Technical University.  N. E. Bauman and MIPT. <br><br><img src="https://habrastorage.org/files/c6e/86a/7b4/c6e86a7b44104815ad71ebcd82459ad9.jpg"><br><br>  In April, they will have the opportunity to once again prove themselves and compete for attractive prizes: iPad mini 2, iPod nano, iPod shuffle.  In addition to mundane material awards, as well as indispensable honor and respect, the winners of the first Tekhnokubka (diploma of I degree) will receive as many as eight additional points for admission to undergraduate and specialist programs at MIPT and MGTU.  N. E. Bauman, and the winners (diploma II and III degree) - six additional points.  The children will now be able to meet with leading IT-specialists, and in the future, they may decide to combine training in one of the best technical universities in Moscow with additional educational programs of Technopark and Tehnotrek. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  ‚ÄúTechnocup is an important social initiative: thanks to the Olympiad, talented young programmers will get an additional opportunity to enter the leading technical universities of the country.  We are systematically working to give students and schoolchildren as many opportunities as possible to gain the knowledge and practice necessary to work in a large company or to start developing their own project.  This is focused on our educational projects with universities (Technopark, Technosphere and Technotrek), our IT championships, and now this list will be added to Technoclub ‚Äù, - Dmitry <a href="https://habrahabr.ru/users/dmitry21/" class="user_link">Dmitry21</a> Voloshin, director of the department of research and education Mail.Ru Group. </blockquote><br>  For the participants of this year and those who would like to prepare for the future Tehnokubkam, we present a task analysis. <br><a name="habracut"></a><br><h1>  <a href="http://codeforces.com/contest/648/problem/A">A. The greatest lift</a> </h1><br>  The profile of a mountain range is schematically set as a rectangular table of the characters "." (Empty space) and "*" (part of a mountain).  Each column of the table contains at least one "asterisk".  It is guaranteed that either any of the ‚Äú*‚Äù symbols is in the bottom row of the matrix, or another symbol ‚Äú*‚Äù is directly below it. <br><br> <code>........... <br> .........*. <br> .*.......*. <br> **.......*. <br> **..*...**. <br> *********** <br></code> <br>  <sup><i>An example of the image of a mountain range</i></sup> <br><br>  The tourist route passes through the entire ridge from left to right.  Every day the tourist moves to the right - to the adjacent column in the schematic image.  Of course, every time he rises to the highest point of the mountain (or descends), which is located in the corresponding column. <br><br>  Considering that the tourist is initially located at the highest point in the first column, and ends his route at the highest point in the last column, find two values: <br><br><ul><li>  the greatest rise in a day (equal to 0, if there is not a single rise in the profile of the mountain range), </li><li>  the greatest descent per day (equal to 0 if there is not a single descent in the profile of the mountain range). </li></ul><br><img src="https://habrastorage.org/files/253/1a2/14c/2531a214c6a74f5d8e300590a3a04f1a.png"><br><br>  <b>The decision</b> .  To solve this problem, we calculate the height of each mountain and store it in the array <i>h []</i> , where <i>h [j]</i> is equal to the height of the <i>j-</i> th mountain.  To do this, we go around the given matrix, and if the element standing in row <i>i</i> and column <i>j</i> (rows and columns 0 are indexed) is equal to an asterisk, we update the height of the <i>jth</i> mountain: <i>h [j] = max (h [j], n - i)</i> .  It remains to simply iterate over the columns from 0 to <i>m - 2</i> inclusive and, if the current column is equal to <i>j</i> , update the maximum ascent or maximum descent value of <i>| h [j + 1] - h [j] |</i>  . <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> h[N]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n &gt;&gt; m; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; m; j++) { <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; c; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { h[j] = max(h[j], n - i); } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxU = <span class="hljs-number"><span class="hljs-number">0</span></span>, maxD = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff = h[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] - h[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (diff &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { maxU = max(maxU, diff); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { maxD = max(maxD, -diff); } } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; maxU &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; maxD &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/648/problem/B">B. Assemble the table</a> </h1><br>  Vasya bought a table with <i>n</i> legs.  Each leg consists of two parts, which are connected to each other.  Each part can be of arbitrary positive length, but it is guaranteed that out of all <i>2n</i> parts it is possible to make <i>n</i> legs of the same length.  When making up the legs, any two parts can be connected to each other.  Initially, all the legs of the table are disassembled, and you are given the length of <i>2n</i> parts in random order. <br><br>  Help Vasya to collect all the legs of the table so that they are all the same length, breaking the given <i>2n</i> parts into pairs in the correct way.  Each leg must be composed of exactly two parts; it is not allowed to use only one part as a leg. <br><br><img src="https://habrastorage.org/files/143/4ad/53b/1434ad53b1e64a3990afdf4ff9a31b22.png"><br><br>  <b>The decision</b> .  To solve this problem, we first calculate the length of one assembled table leg and store it in the variable len (len = sum / <i>n</i> , where sum is the total length of all parts, and <i>n</i> is the number of table legs).  Save the lengths of all parts of the legs in an array <i>a []</i> and sort it in ascending order.  Then we iterate over the parts of the legs of the variable <i>i</i> from 0 to <i>n</i> - 1 inclusively and we will output in response pairs of the form <i>(a [i], len - a [i])</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, len, sum; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n; i++) { <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; a[i]; sum += a[i]; } len = sum / n; sort(a, a + <span class="hljs-number"><span class="hljs-number">2</span></span> * n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a[i] &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; len - a[i] &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/648/problem/C">C. Path of the Robot</a> </h1><br>  You are given a rectangular checkered field consisting of <i>n</i> rows and <i>m</i> columns.  The field contains a cycle of the characters "*", such that: <br><br><ul><li>  the cycle can be bypassed by visiting each of its cells exactly once, moving each time up / down / left / right by one cell; </li><li>  the cycle does not contain self-intersections and self-casings, that is, two cells of the cycle are side by side if and only if they are adjacent when moving along the cycle (self-cornering along the corner is also prohibited). </li></ul><br>  Below are a few examples of valid cycles: <br><br><img src="https://habrastorage.org/files/48e/d4b/f6b/48ed4bf6b5204b4baded6f303948093f.png"><br><br>  All cells of the field, other than the cycle, contain the symbol ".".  Cycle on the field exactly one.  Attend cells that are different from the cycle, the robot can not. <br><br>  In one of the cells of the cycle is a robot.  This cell is marked with an "S".  Find the command sequence for the robot to bypass the loop.  Each of the four possible commands is encoded by a letter and denotes the movement of the Robot one cell: <br><br><ul><li>  "U" - move the cell up, </li><li>  "R" - move the cell to the right, </li><li>  "D" - move the cell down, </li><li>  "L" - move the cell to the left. </li></ul><br>  The robot must bypass the cycle, having been in each of its cells exactly once (except for the starting point - in it it starts and ends its way). <br><br>  Find the desired sequence of commands; any direction of loop traversal is allowed. <br><br><img src="https://habrastorage.org/files/62a/9dc/6df/62a9dc6df0d3436d9173ca63cbeb0b84.jpg"><br><br>  <b>Decision.</b>  First, find the starting position of the Robot, save it and assign the value of the starting position to the asterisk.  Since the condition is given a polyline without self-intersections and self-casings, the following algorithm is true: if there is a cell next to the current one in which there is an asterisk, we move to the next one whose value is equal to the asterisk, and assign its value to a point in which we moved).  In this case, the next cell must be different from the one from which we came into the current cell.  If there is no neighboring cell with an asterisk, it means that we have bypassed the entire polyline and need to finish the work of the program. <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, sx, sy; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> a[N][N]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx[] = {<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy[] = {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dir[] = {<span class="hljs-string"><span class="hljs-string">'U'</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'R'</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n &gt;&gt; m; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; m; j++) { <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; a[i][j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i][j] == <span class="hljs-string"><span class="hljs-string">'S'</span></span>) { sx = i, sy = j; } } } a[sx][sy] = <span class="hljs-string"><span class="hljs-string">'*'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> px = <span class="hljs-number"><span class="hljs-number">-1</span></span>, py = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> wasMove = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nx = sx + dx[i]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ny = sy + dy[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nx &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || nx &gt;= n || ny &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || ny &gt;= m) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[nx][ny] != <span class="hljs-string"><span class="hljs-string">'*'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nx == px &amp;&amp; ny == py) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } a[nx][ny] = <span class="hljs-string"><span class="hljs-string">'.'</span></span>; px = sx, py = sy; sx = nx, sy = ny; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; dir[i]; wasMove = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(wasMove) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">""</span></span>); }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/648/problem/D">D. Dogs and bowls</a> </h1><br>  There are <i>n</i> dogs on the coordinate line, the <i>i-</i> th dog is at point <i>x <sub>i</sub></i> .  In addition, there are <i>m</i> bowls of food on the straight line, each has its coordinate on the straight line <i>u <sub>j</sub></i> and the time <i>t <sub>j</sub></i> through which the food in the bowl cools and becomes tasteless.  This means that if the dog runs to the bowl at a time, strictly greater <i>t <sub>j</sub></i> , then the food will cool down and the dog will not eat it. <br><br>  Considering that each dog runs at a speed of 1, find the maximum number of dogs that can eat.  Consider that the dogs will run to the bowls to which you point them.  From one bowl can not eat two or more dogs. <br><br>  Dogs can overtake each other, that is, if one of them stops to eat, the other can pass by it to get to another bowl. <br><br><img src="https://habrastorage.org/files/798/f0a/2ba/798f0a2ba34449a0a736cb6c81a2e611.jpg"><br><br>  <b>The decision</b> .  If each bowl is presented as <i>[u <sub>j</sub> - t <sub>j</sub> , u <sub>j</sub> + t <sub>j</sub> ]</i> , then the <i>i-</i> th dog can eat from <i>j</i> bowls, if <i>u <sub>j</sub> - t <sub>j</sub> ‚â§ x <sub>i</sub> ‚â§ u <sub>j</sub> + t <sub>j</sub></i> . <br><br>  We will solve the problem eagerly.  Consider the leftmost dog and the bowls from which she can eat.  If there are no such bowls, the dog will not be able to eat.  Otherwise, from the bowls available to the left-most dog, we will choose for it a bowl with the left-most right end.  Further we will not consider this dog and this bowl and we will continue similarly our reasonings. <br><br>  It is easy to see that such greed leads to the optimal answer: <br><br><ul><li>  If the most left dog can eat, then there is no point for her not to eat, because with this we remove one bowl and worsen the answer to the unit. </li><li>  Consider the bowls of which the most left dog can eat.  All these bowls will be available for the rest of the dogs, except for those whose right border is too far to the left.  Thus, if we want to take any bowl (and we already understood from point 1 that it is worth doing), then it will be more profitable to take the bowl with the leftmost end, so we will not make it worse for the dogs on the right. </li></ul><br>  For this task, it was possible to try to write other greed, but many would be wrong. <br><br>  In order to realize this, we sort the dogs and bowls (on the left end) from left to right.  We will go from left to right, processing the events ‚Äúa bowl appeared‚Äù (in this case we add its right end to some data structure) and a ‚Äúlittle dog appeared‚Äù (it is necessary for the dog to find the left most suitable right end in the data structure). <br><br>  Complexity: <i>O</i> ( <i>n</i> log <i>n</i> ) or <i>O</i> ( <i>n</i> ) depending on the data structure (* set * or <i>queue</i> ). <br><br>  C ++ Solution <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">200200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x[N]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u[N], t[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(<span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n &gt;&gt; m)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; forn(i, n) assert(<span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, &amp;x[i]) == <span class="hljs-number"><span class="hljs-number">1</span></span>); forn(i, m) assert(<span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d%d"</span></span>, &amp;u[i], &amp;t[i]) == <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } pti segs[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ forn(i, m) segs[i] = mp(u[i] - t[i], u[i] + t[i]); sort(x, x + n); sort(segs, segs + m); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ans = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">multiset</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; z; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j &lt; m &amp;&amp; segs[j].x &lt;= x[i]) { z.insert(segs[j].y); j++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = z.lower_bound(x[i]); i++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != z.end()) { ans++; z.erase(it); } } } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/648/problem/E">E. Collect the number</a> </h1><br>  Given a non-negative integer <i>k</i> and <i>n</i> non-negative integers <i>a <sub>1</sub></i> , <i>a <sub>2</sub></i> , ..., <i>a <sub>n</sub></i> .  Writing some of these numbers one after another in an arbitrary order and, possibly, using some of them several times (and some without using them at all), you need to make the shortest (smallest number of digits) number divisible by <i>k</i> , or determine that is impossible. <br><br><img src="https://habrastorage.org/files/024/a43/af5/024a43af5ab049a18d7f97be808fbc67.jpg"><br><br>  <b>Decision.</b>  Note that when building a response, at any moment only the remainder of dividing its current prefix by <i>k is</i> important to us.  Indeed, if the current response prefix has the remainder of dividing by <i>k</i> , equal to <i>r</i> , then by assigning to the prefix of the number <i>a <sub>i</sub></i> this remainder will become equal to the remainder of d divided by <i>k of the</i> number <i>r ‚Ä¢ 10 <sup>l <sub>i</sub></sup> + a <sub>i</sub></i> ( <i>l <sub>i</sub></i> is the number of digits in the record the numbers <i>a <sub>i</sub></i> ). <br><br>  Then, obviously, we are interested in getting any remainder from dividing by such an operation using the minimum number of digits in the record.  Of course, we can get the remainder 0 immediately using an empty prefix, so for the remainder 0 we will be interested in the second largest answer. <br><br>  Everything described above allows us to construct a graph on <i>k</i> vertices (from 0 to <i>k</i> - 1, respectively, the residuals), the edges of which are determined by the numbers <i>a <sub>i</sub></i> : from the vertex <i>v</i> to the vertex <img src="https://habrastorage.org/files/85f/ffe/fc7/85fffefc76da4748ab55b8380ae3b117.png">  of length <i>l <sub>i</sub></i> , meaning that by adding <i>l <sub>i</sub></i> digits we can get a prefix with a remainder <i>u</i> from the prefix with the remainder <i>v</i> .  It is easy to notice that some <i>a <sub>i</sub></i> in this graph will correspond to the same edges (now their <i>nk</i> ) are numbers with the same length of the decimal notation and the remainder from dividing by <i>k</i> , therefore you should leave only the numbers unique for this criterion (they will not more than 10 <i>k</i> ), and then the number of edges will not exceed 10 <i>k</i> 2. <br><br>  Now all that is required of us is to find the length of the shortest non-empty path from the vertex 0 to itself in the constructed graph.  To avoid such an unpleasant cyclicity, let's just add an additional vertex <i>k</i> having the same outgoing edges as vertex 0, assuming that such a residue can only have an empty prefix.  Now the problem is reduced to finding the shortest path from the vertex <i>k</i> to the vertex 0, which can be solved by the Dijkstra algorithm in <i>O (k <sup>2</sup> )</i> .  However, due to the specificity of the problem, the solution by the Ford ‚Äì Bellman algorithm (with the correct cut-offs, of course) also passes all the tests, even if in theory it has such large <i>O (k <sup>3</sup> )</i> . <br><br>  Restoration of the answer in the problem is rather standard, with the exception of storing an additional number for each vertex that formed an edge, along which the transition needed in the shortest answer was performed. <br><br>  Dijkstra's solution <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; assert(<span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, &amp;x) == <span class="hljs-number"><span class="hljs-number">1</span></span>); any[x % k][length(x)] = x; } p10[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; P; ++i) p10[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = (p10[i] * <span class="hljs-number"><span class="hljs-number">10</span></span>) % k; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= k; ++i) { d[i] = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-number"><span class="hljs-number">1e9</span></span>); p[i] = <span class="hljs-number"><span class="hljs-number">-1</span></span>; used[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } d[k] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= k; ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!used[i] &amp;&amp; (v == <span class="hljs-number"><span class="hljs-number">-1</span></span> || d[v] &gt; d[i])) v = i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; used[v] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; r &lt; k; ++r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>; l &lt; P; ++l) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (any[r][l] != <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = (v * p10[l] + r) % k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d[to] &gt; d[v] + l) { d[to] = d[v] + l; p[to] = v; w[to] = any[r][l]; used[to] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"NO"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"YES"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; res; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { res.push_back(w[v]); v = p[v]; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (v != k); reverse(res.begin(), res.end()); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x: res) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, x); }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/649/problem/A">A. Polycarp's Favorite Numbers</a> </h1><br>  Polycarp dreams of becoming a programmer and is a fan of the powers of two.  Among the two numbers, he likes the one that is divided by the greater degree of the number 2. <br><br>  Given a sequence of positive integers <i>a <sub>1</sub></i> , <i>a <sub>2</sub></i> , ..., <i>a <sub>n,</sub></i> it is required to find <i>r</i> - the maximum power of 2, into which at least one of the numbers in the sequence is divided.  In addition, you want to display the number of numbers <i>a <sub>i</sub></i> , which are divided by <i>r</i> . <br><br><img src="https://habrastorage.org/files/bf4/b12/6e0/bf4b126e0bb1428d991f1e20c4d66138.jpg"><br><br>  <b>Decision.</b>  To solve this problem, you need to take advantage of the fact that the power of two grows quickly and the maximum power of two, into which the number not exceeding 10 <sup>9</sup> can be divided, is equal to 29. Therefore, you just need to iterate on the given numbers, find the maximum power of two that the current number divides into and update the answer with this maximum degree. <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ans = <span class="hljs-number"><span class="hljs-number">-1</span></span>, cnt = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cur = <span class="hljs-number"><span class="hljs-number">1</span></span>, power = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { cur *= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x % cur) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; power++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ans &lt; power) { ans = power; cnt = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ans == power) { cnt++; } } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ans &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/649/problem/B">B. Floors</a> </h1><br>  There is an <i>n-</i> access house, each floor has <i>m</i> floors, and there are exactly <i>k</i> apartments on each floor of each entrance.  Thus, there are only <i>n ‚Ä¢ m ‚Ä¢ k</i> apartments in the house.  They are numbered in a natural way from 1 to <i>n ‚Ä¢ m ‚Ä¢ k</i> , that is, the first apartment on the first floor in the first entrance has number 1, the first apartment on the second floor of the first entrance has number <i>k</i> + 1, and so on.  The peculiarity of this house is that it is round.  That is, if you bypass it clockwise, then after the entrance number 1 there is the entrance number 2, then the entrance number 3 and so on until the entrance number <i>n</i> .  After the entrance number <i>n</i> there is access number 1 again. <br><br>  Edward lives in apartment number a, and Natasha lives in apartment number <i>b</i> .  The transition to one floor up or down the stairs takes 5 seconds, the transition from the door of the entrance to the door of the neighboring entrance - 15 seconds, and the transition within one floor of one entrance occurs instantly.  There is also an elevator in each entrance.  It is arranged as follows: it always arrives exactly 10 seconds after the call, and to move a passenger one floor up or down, the elevator spends exactly one second.  Landing and disembarking occur instantly. <br><br>  Help Edward find the minimum time he can get to Natasha‚Äôs apartment.  Consider that Edward can exit the porch only from the first floor of the corresponding porch (this happens instantly).  If Edward is standing in front of the door of an entrance, he can enter it and immediately be on the first floor of this entrance (this also happens instantly).  Edward can choose which direction to go around the house. <br><br><img src="https://habrastorage.org/files/b5d/2fc/9e4/b5d2fc9e4e2f4491a8ca99ec64da3a56.jpg"><br><br>  <b>Decision.</b>  To solve this problem, it was necessary to accurately implement what is written in the condition.  The main difficulty was in identifying the porch number and the floor number according to the apartment number.  This could be done in the following way: if there are <i>n</i> entrances in the house, there are <i>m</i> floors on each porch, and <i>k</i> apartments on each floor, then apartment number <i>a</i> is at the entrance number ( <i>a</i> - 1) / ( <i>m ‚Ä¢ k</i> ) and floor number <i>((a - 1)% (m ‚Ä¢ k)) / k</i> , and these numbers are 0-indexed, which is convenient for further calculations.  After determining the numbers of entrances and floors, it was necessary to consider two cases: when the numbers of the entrances of Edward and Natasha were equal (then it was necessary to choose which is more optimal - take an elevator or go up / down the stairs) and when these numbers are different (it was necessary not to forget, that the house is round, and choose the right direction). <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, m, k, a, b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; a &gt;&gt; b; a--, b--; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p1 = a / (m * k), p2 = b / (m * k); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> f1 = (a % (m * k)) / k, f2 = (b % (m * k)) / k; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p1 == p2) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; min(<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f1 - f2) + <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(f1 - f2) * <span class="hljs-number"><span class="hljs-number">5</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p1 &gt; p2) swap(p1, p2); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; min((p2 - p1) * <span class="hljs-number"><span class="hljs-number">15</span></span>, (p1 + n - p2) * <span class="hljs-number"><span class="hljs-number">15</span></span>) + min(f1 * <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> + f1) + min(f2 * <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> + f2) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/649/problem/C">C. Printing conditions</a> </h1><br>  <i>N</i> teams came to the training for programming programming competitions.  The coach for each team picked up a training session, the set of tasks for the <i>i-</i> th team takes up <i>a <sub>i</sub></i> pages.  At the disposal of the coach there are <i>x</i> sheets of paper, in which both sides are clean, and <i>y</i> sheets, in which only one side is clean.  When printing conditions on a sheet of the first type, you can print two pages of the conditions of the tasks, and when printing on a sheet of the second type - only one.  Of course, conditions cannot be printed on the sheet from two different sets of tasks.  Please note that when using sheets that have both sides clean, it is not necessary to print a condition on both sides, one of them can remain clean. <br><br>  You have to determine the maximum number of teams that the coach can print complete sets of tasks. <br><br><img src="https://habrastorage.org/files/d17/d1c/768/d17d1c7683f2456eab111180ead427ae.jpg"><br><br>  <b>Decision.</b>  First, sort the specified sizes of task sets in a non-decreasing order.  Then you need to start sorting through sets of tasks, starting with the smallest.  If we cannot print the current set, then we are guaranteed that we will not be able to print any next set, so we need to print the answer and finish the algorithm.  Otherwise, you need to print the current set, increase the answer to the unit and go to the next set.  Each set is optimally printed as follows.  Let <i>x</i> be the remaining number of two-sided sheets, <i>y the</i> remaining number of one-sided sheets, and <i>a</i> is the number of pages in the current set of tasks.  If <i>x</i> = 0 and <i>y</i> = 0, then we definitely cannot print the current set.  If <i>a is</i> odd and <i>y</i> &gt; 0, print one page on a one-sided sheet and reduce <i>a</i> and <i>y</i> by one, otherwise, if <i>a is</i> odd and <i>x</i> &gt; 0, print one page on a two-sided sheet (which we will not use anymore) and decrease <i>a</i> and <i>x</i> per unit.  Now <i>a</i> is always an even number.  Therefore, it is advantageous to first use double-sided sheets for printing, and if they are not enough, one-sided sheets.  If one-sided sheets are not enough, then we will not be able to print the current set. <br><br><div class="spoiler">  <b class="spoiler_title">Solution example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, x, y; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[N]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">can</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a % <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) a--, y--; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) a--, x--; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * <span class="hljs-number"><span class="hljs-number">2</span></span> &gt;= a) { x -= a / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } a -= <span class="hljs-number"><span class="hljs-number">2</span></span> * x, x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y &gt;= a) { y -= a; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n &gt;&gt; x &gt;&gt; y; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; a[i]; sort(a, a + n); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ans = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(can(a[i])) ans++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><h1>  <a href="http://codeforces.com/contest/649/problem/D">D. Memory defragmentation</a> </h1><br>  Computer memory consists of <i>n</i> cells that are lined up.  Number the cells from 1 to <i>n</i> from left to right.  About each cell, it is known whether it is free or belongs to some process (in this case, the process to which it belongs is known). <br><br>  For each process, it is known that the cells belonging to it occupy a continuous area in memory.  With the help of operations like "rewrite data from a busy cell to a free one, and busy now to be considered free", all the cells belonging to the processes must be located at the beginning of the computer memory.  ,       (  )  . <br><br>             ,       . ,             ,         .  ,    ,   <i>i</i> ,        <i>j</i> ,        . <br><br> ,     ,       - . <br><br><img src="https://habrastorage.org/files/62d/267/a51/62d267a516f44e1da4233ae10aa3da6f.jpg"><br><br>  <b>Decision.</b>       ,       .  , ,      (   )  ,   .   :    ,        pos1  pos2   ,   pos1 ,   pos2  ,          pos1.  ,    ‚Äî      ,     -    ,        ,       (  ,      ). <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[N], need[N]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> szneed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; a[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[i] != <span class="hljs-number"><span class="hljs-number">0</span></span>) need[szneed++] = a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ans = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (need[i] != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; need[i] != a[i]) ans++; } <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><h1> <a href="http://codeforces.com/contest/649/problem/E">E. </a> </h1><br>    <i>n</i> .    ,    ,   . <br><br>   ,   ,      <i>x <sub>i</sub></i> ,    .  ,    <i>d <sub>i</sub></i> ,  <i>i</i> -     .  , <i>i</i> -        <i>x <sub>i</sub> + d <sub>i</sub></i> .    ,     ,      . <br><br>  ,      ,      a .      .     ,     . <br><br>         ,       a .            ,      .    ,     a     . <br><br> ,       (    )        .     -     ,   , ,        ,        . <br><br><img src="https://habrastorage.org/files/e65/767/cfa/e65767cfafd24bde869a09294d6db2bd.jpg"><br><br> <b></b> .           ,     ‚Äî   ,    ,    .          ,      a . <br><br>        .  mid ‚Äî    .   cnt ‚Äî   ,       .      set'a,        ,    ,   . <br>      (  ,     ).   set'  ,       ,    ,      set        ans.   ,        set' ,      ,   set'     . <br><br>       ,      set'   ans.    ans  <i>a</i> ,   mid    ,    mid    .                 ans. <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, a; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;pair&lt;pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt; v; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; s; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; ans; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ok</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ s.clear(); ans.clear(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = v[i].first.first, r = v[i].first.second; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!s.empty() &amp;&amp; s.begin()-&gt;first &lt;= l) { ans.push_back(s.begin()-&gt;second); s.erase(s.begin()); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)s.size() + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;= x) s.insert(mp(r, v[i].second)); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { s.insert(make_pair(r, v[i].second)); <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt; :: iterator it = s.end();--it; s.erase(it); } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!s.empty()) { ans.push_back(s.begin()-&gt;second); s.erase(s.begin()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ans.size(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; n &gt;&gt; a; v.resize(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; v[i].first.first &gt;&gt; v[i].first.second, v[i].first.second += v[i].first.first, v[i].second = i; sort(v.begin(), v.end()); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = <span class="hljs-number"><span class="hljs-number">0</span></span>, r = a; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r - l &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mid = (l + r) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ok(mid) &gt;= a) r = mid; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> l = mid; } ok(r); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; r &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a; i++) <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ans[i] + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">' '</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre></div></div><br><h1>   </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">929 people took part </font><font style="vertical-align: inherit;">in the </font></font><a href="http://codeforces.com/contests/648"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first qualifying round</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://codeforces.com/contest/648/standings"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The best result was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shown by Vladislav Makeev (Moscow, Russia). </font><font style="vertical-align: inherit;">The second and third place was taken by Rostislav Velichko (Stavropol, Russia) and Roman Gorbunov (Moscow, Russia). </font></font><br><br> <a href="http://codeforces.com/contest/649"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second qualifying round</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gathered 686 people. </font><font style="vertical-align: inherit;">With a large margin, the first place </font></font><a href="http://codeforces.com/contest/649/standings"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the rating table was</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> taken by Vlad Mosko (Gomel, Belarus). </font><font style="vertical-align: inherit;">Second and third place - Nazarbek Altybay (Aktobe, Kazakhstan) and Vladimir Romanov (Moscow, Russia). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once again we congratulate all the finalists and look forward to seeing new participants next year.</font></font></div><p>Source: <a href="https://habr.com/ru/post/280554/">https://habr.com/ru/post/280554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280544/index.html">Malefactors use Linux / Remaiten bot to compromise embedded devices, part 1</a></li>
<li><a href="../280546/index.html">NPM has forbidden to withdraw modules older than 24 hours without permission from open-source</a></li>
<li><a href="../280548/index.html">Report from Android Devs Meetup March 17</a></li>
<li><a href="../280550/index.html">To help DevOps: a firmware builder for network devices on Debian for 1008 hours</a></li>
<li><a href="../280552/index.html">Logeek Night meeting for Java specialists from Kazan</a></li>
<li><a href="../280556/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 33. "Exit Strategy"</a></li>
<li><a href="../280560/index.html">Ubuntu integrated into Windows 10</a></li>
<li><a href="../280562/index.html">16 cores and 30 GB under the hood of your Jupyter for $ 0.25 per hour</a></li>
<li><a href="../280564/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 35. "Verdict"</a></li>
<li><a href="../280574/index.html">Processing sms on a heap of identical gsm modems without violence against udev</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>