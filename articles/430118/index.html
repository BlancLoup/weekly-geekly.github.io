<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unity3D: Modifying the delegate of an iOS application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think many in the course of developing a game for iOS had to deal with the fact that there is a need to use one or another native functionality. Wit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unity3D: Modifying the delegate of an iOS application</h1><div class="post__text post__text-html js-mediator-article">  I think many in the course of developing a game for iOS had to deal with the fact that there is a need to use one or another native functionality.  With regards to Unity3D, there can be a lot of problems in this matter: in order to implement a feature, you have to look towards native plug-ins written in Objective-C.  Someone at this moment immediately despair and throws the idea.  Someone is looking for ready-made solutions in AssetStore or on forums, hoping that a ready-made solution already exists.  If there are no ready-made solutions, then the most resistant of us see no other way out than to dive into the depths of iOS programming and the interaction of Unity3D with Objective-C code. <br><br>  Those who choose the last path (although I think they themselves know) will face many problems on this difficult and thorny path: <br><br><ul><li>  iOS is a completely unfamiliar and detached ecosystem, developing in its own way.  At a minimum, you will have to spend quite a lot of time to figure out how to get close to the application, and where in the depths of the automatically generated XCode of the project there is the Unity3D interaction code of the engine with the native component of the application. </li><li>  Objective-C is rather detached and not very similar to a programming language.  And when it comes to interacting with the C ++ code of the Unity3D application, a ‚Äúdialect‚Äù of this language, called Objective-C ++, comes on the scene.  Information about him is very little, most of it is ancient and archival. </li><li>  The Unity3D interaction protocol with the iOS application is rather poorly described.  You should rely solely on tutorials of enthusiasts in the network who write how to develop the simplest native plugin.  At the same time, few people raise deeper questions and problems arising from the need to do something complicated. </li></ul><br>  Those who want to learn about the mechanisms of interaction with Unity3D iOS application, please under the cat. <br><a name="habracut"></a><br>  In order to bring more clarity to the gloom-covered bottleneck of Unity3D interaction with native code, this article describes aspects of how an iOS delegate interacts with Unity3D code, with which C ++ and Objective-C tools it is implemented, and how to modify the application delegate itself.  This information can be useful both for a better understanding of the mechanisms of operation of the Unity3D + iOS bundle, and for practical use. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Interaction between iOS and the application </h3><br>  As an introduction, let's consider how the interaction of an application with the system is implemented in iOS and vice versa.  Schematically, starting an iOS application looks like this: <br><br><img src="https://habrastorage.org/webt/jd/vm/oi/jdvmoimtygqdsc095abusfopdao.png" alt="image"><br><br>  To study this mechanism in terms of code, a new application created in XCode using the ‚ÄúSingle View App‚Äù template will be suitable. <br><br><img src="https://habrastorage.org/webt/du/_z/75/du_z75efp4bdgv_fvb02x-mjfis.png"><br><br>  By selecting this template, at the output we get the simplest iOS application that can run on a device or an emulator and show a white screen.  Xcode will helpfully create a project that contains only 5 files with source code (2 of them are header .h files) and several auxiliary files that are not interesting to us (layout, configs, icons). <br><br><img src="https://habrastorage.org/webt/jt/mz/ov/jtmzov95oshddmprhby9wkqigve.png"><br><br>  Let's see what the source code files are responsible for: <br><br><ul><li>  <i>ViewController.m</i> / <i>ViewController.h</i> - not very interesting source code.  Since your application has a View (which is represented not by the code, but by using the Storyboard), you need the Controller class, which will control this View.  In general, this is how Xcode itself pushes us to use the MVC pattern.  The project that generates Unity3D will not have these source files. </li><li>  <i>AppDelegate.m</i> / <i>AppDelegate.h</i> - delegate of your application.  The point of interest in the application where the custom application code begins. </li><li>  <i>main.m</i> - the starting point of the application.  In the manner of any C / C ++ application contains a function main, with which the program starts. </li></ul><br>  Now, let's see the code starting from the file <i>main.m</i> : <br><br><pre><code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * argv[]) { <span class="hljs-comment"><span class="hljs-comment">//1 @autoreleasepool { //2 return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); // 3 } }</span></span></code> </pre> <br>  With line 1, everything is clear and without explanation, let's move on to line 2. It indicates that the life cycle of the application will occur inside the Autorelease pool.  Using the autorelease pool, it tells us that we will entrust the memory management of the application to this particular pool, that is, it will deal with the issues of when to free up memory for a particular variable.  The story about the management of memory on iOS goes beyond the scope of this story, so it makes no sense to delve into this topic.  For those who are interested in this topic, you can read, for example, with <a href="http://macbug.ru/cocoa/mempool">this article</a> . <br><br>  Go to line 3. It calls the function <a href="https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain%3Flanguage%3Dobjc">UIApplicationMain</a> .  The program launch parameters (argc, argv) are passed to it.  Then, in this function it is indicated which class to use as the main class of the application, an instance is created.  And, finally, it is indicated which class to use as the application delegate, an instance is created, connections between the application class instance and its delegate are configured. <br><br>  In our example, as a class that will represent an instance of an application, nil is passed - roughly speaking, the local equivalent is null.  In addition to nil, you can pass there a specific class inherited from <a href="https://developer.apple.com/documentation/uikit/uiapplication%3Flanguage%3Dobjc">UIApplication</a> .  If nil is specified, UIApplication will be used.  This class is a centralized point of control and coordination of the application on iOS and is singleton (singleton).  With it, you can find out almost everything about the current state (state) of an application, notifications, windows, events that occurred in the system itself, which affect this application and many other things.  This class is almost never inherited.  We will dwell on the creation of the Application Delegate class. <br><br><h3>  Creating an application delegate </h3><br>  An indication of which class to use as an application delegate occurs in a function call <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSStringFromClass</span></span>([AppDelegate <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>])</code> </pre> <br>  Let's sort this call in parts. <br><br><pre> <code class="objectivec hljs">[AppDelegate <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]</code> </pre> <br>  <a href="https://developer.apple.com/documentation/foundation/1395143-nsstringfromclass%3Flanguage%3Dobjc">This construct</a> returns an object of the class AppDelegate (which is declared in AppDelegate.h / .m), and the function <a href="https://developer.apple.com/documentation/foundation/1395143-nsstringfromclass%3Flanguage%3Dobjc">NSStringFromClass</a> returns the name of the class as a string.  We simply pass to the UIApplicationMain function the string name of the class that needs to be created and used as a delegate.  For greater understanding, line 3 in <i>main.m</i> could be replaced by the following: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UIApplicationMain</span></span>(argc, argv, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-string"><span class="hljs-string">@"AppDelegate"</span></span>);</code> </pre> <br>  And the result of its implementation would be identical to the original version.  Apparently, the developers decided to come to exactly this approach so as not to use a string constant.  With the standard approach, if you rename the delegate class, the parser will immediately generate an error.  In the case of using the usual string, the code will be compiled successfully, and you will get an error only by running the application. <br><br>  A similar class creation mechanism, using only the string class name, can remind you of Reflection from C #.  Objective-C and its execution environment (runtime) have much greater capabilities than Reflection in C #.  This is quite an important point in the context of this article, but it would take a lot of time to describe all the possibilities.  However, we will still meet with ‚ÄúReflection‚Äù in Objective-C below.  It remains to understand the concept of the application delegate and its functions. <br><br><h3>  Application Delegate </h3><br>  All application interaction with iOS occurs in the UIApplication class.  This class takes on a lot of responsibility - notifies about the origin of events, about the state of the application and much more.  For the most part, his role is a notifying one.  But when something happens in the system, we should be able to somehow respond to this change, to perform some kind of custom functionality.  If an instance of the UIApplication class is also involved in this - this practice will begin to resemble an approach called the <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2%25D0%25B5%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">Divine Object</a> .  Therefore, it is worth thinking about how to free this class from a part of its duties. <br><br>  For these purposes, the iOS ecosystem uses such a thing as an application delegate.  From the name itself it can be concluded that we are dealing with such a design pattern as <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25B3%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">Delegation</a> .  In short, we simply transfer the responsibility for handling the reaction to certain application events to the application delegate.  For this purpose, in our example, the AppDelegate class has been created, in which we can write custom functionality, while leaving the UIApplication class to work in black box mode.  Such an approach may seem controversial to someone in terms of the beauty of architecture design, but the iOS authors themselves are pushing us towards this approach and the vast majority of developers (if not all) use it. <br><br>  To visually see how often an application delegate receives a message during an application, take a look at the diagram: <br><br><img src="https://habrastorage.org/webt/md/61/bc/md61bc9my4focy1suoy5qn9om2s.png" alt="image"><br><br>  In the yellow boxes, calls to certain delegate methods are indicated in response to certain application life events.  This diagram only illustrates events related to a change in application state and does not reflect many other aspects of delegate responsibility, such as accepting notifications or interacting with frameworks. <br><br>  Here are some examples of when we may need access to the application delegate from Unity3D: <br><br><ol><li>  handling push and local notifications </li><li>  logging to application analytics </li><li>  Determining how to launch the application - ‚Äúto clean‚Äù or exit from the background </li><li>  how exactly the application was launched - by tachu on notification, using <a href="https://developer.apple.com/design/human-interface-guidelines/ios/extensions/home-screen-actions/">Home Screen Quick Actions</a> or simply by tachu on Inconcus </li><li>  interaction with WatchKit or HealthKit </li><li>  opening and processing URLs from another application.  If this URL refers to your application, you can process it in your application instead of letting the system open this URL in a browser. </li></ol><br>  This is not the whole list of scenarios.  In addition, it is worth noting that the delegate modifies many analytics and advertising systems in their native plugins. <br><br><h3>  How Unity3D Implements Application Delegate </h3><br>  Let's now take a look at the XCode project generated by Unity3D and see how the application delegate is implemented in Unity3D.  When building for the iOS platform, Unity3D automatically generates the Xcode project for you, which uses quite a lot of generic code.  This template code also includes the Delegate code for the Application.  Inside any generated project, you can find the files <i>UnityAppController.h</i> and <i>UnityAppController.mm</i> .  These files contain the code of the UnityAppController class of interest. <br><br>  In fact, Unity3D uses a modified version of the ‚ÄúSingle View Application‚Äù template.  Only in this template Unity3D uses the application delegate not only to handle iOS events, but also to initialize the engine itself, prepare graphic components and much more.  It is very easy to understand if you look at the method <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)application:(<span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>*)application didFinishLaunchingWithOptions:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>*)launchOptions</code> </pre><br>  in the UnityAppController class code.  This method is called at the time of application initialization, when you can transfer control to your custom code.  Inside this method, for example, you can find the following lines: <br><br><pre> <code class="objectivec hljs">UnityInitApplicationNoGraphics([[[<span class="hljs-built_in"><span class="hljs-built_in">NSBundle</span></span> mainBundle] bundlePath] UTF8String]); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selectRenderingAPI]; [UnityRenderingView InitializeForAPI: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.renderingAPI]; _window = [[<span class="hljs-built_in"><span class="hljs-built_in">UIWindow</span></span> alloc] initWithFrame: [<span class="hljs-built_in"><span class="hljs-built_in">UIScreen</span></span> mainScreen].bounds]; _unityView = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> createUnityView]; [DisplayManager Initialize]; _mainDisplay = [DisplayManager Instance].mainDisplay; [_mainDisplay createWithWindow: _window andView: _unityView]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> createUI]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> preStartUnity];</code> </pre><br>  Even without going into the details of what these calls do, one can guess that they are related to preparing Unity3D for work.  It turns out the following script: <br><br><ol><li>  The main function from <i>main.mm is called.</i> </li><li>  An instance of the application class and its delegate is created. </li><li>  The application delegate prepares and launches the Unity3D engine. </li><li>  Your custom code starts working.  If you use il2cpp, then your code is translated from C # to IL and then to C ++ code that directly goes into the XCode project. </li></ol><br>  This script sounds quite simple and logical, but carries with it a potential problem: how can we modify the application delegate if we do not have access to the source code when working in Unity3D? <br><br><h3>  Unity3D target for modifying the application delegate </h3><br>  We can look at the files <i>AppDelegateListener.mm/.h</i> .  They contain macros that allow you to register any class as a listener for the application delegate events.  This is a good approach, we do not need to modify the existing code, but just add a new one.  But there is a significant drawback: not all the events of the application are supported and there is no possibility to get information about the launch of the application. <br><br>  The most obvious, however, unacceptable way out is to change the delegate source code with your hands after Unity3D builds the XCode project.  The problem with this approach is obvious - the option will work if you are doing the assembly with your hands and you are not bothered by the need to modify the code manually after each assembly.  In the case of using collectors (Unity Cloud Build or any other build machine) this option is absolutely unacceptable.  For these purposes, the developers of Unity3D left us a loophole. <br><br>  The <i>UnityAppController.h</i> file, <i>in</i> addition to declaring variables and methods, also contains the definition of a macro: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define IMPL_APP_CONTROLLER_SUBCLASS(ClassName) ...</span></span></code> </pre> <br>  This macro just gives the opportunity to override the application delegate.  To do this, you need to take a few simple steps: <br><br><ol><li>  Write your own application delegate in Objective-C </li><li>  Somewhere inside the source code add the following line <pre> <code class="objectivec hljs">IMPL_APP_CONTROLLER_SUBCLASS(___)</code> </pre> </li><li>  Put this source inside the folder of your Unity3D project's Plugins / iOS </li></ol><br>  Now you will receive a project in which the standard Unity3D delegate of the application will be replaced with your custom one. <br><br><h3>  How a delegate replacement macro works </h3><br>  Let's look at the full source code of the macro: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define IMPL_APP_CONTROLLER_SUBCLASS(ClassName) ... @interface ClassName(OverrideAppDelegate) \ { \ } \ +(void)load; \ @end \ @implementation ClassName(OverrideAppDelegate) \ +(void)load \ { \ extern const char* AppControllerClassName; \ AppControllerClassName = #ClassName; \ } \ @end</span></span></code> </pre> <br>  Using this macro in your source code will add the code described in the macro to the body of your source code at the compilation stage.  This macro does the following.  First, it adds a load method to your class interface.  An interface in the context of Objective-C can be viewed as a set of public fields and methods.  Speaking in C #, a static load method will appear in your class that returns nothing.  Next, the implementation of this load method will be added to the code of your class.  In this method, the variable AppControllerClassName, which is an array of type char, will be declared and then this variable will be assigned a value.  This value is the string name of your class.  Obviously, this information is not enough to understand the mechanism of this macro, so we need to figure out what this ‚Äúload‚Äù method is and why the variable is declared. <br><br>  The <a href="https://developer.apple.com/documentation/objectivec/nsobject/1418815-load%3Flanguage%3Dobjc">official documentation</a> states that load is a special method that is called once for each class (specifically a class, and not its instances) at the earliest stage of the application launch, before the main function is called.  The Objective-c (runtime) runtime at the start of the application will register all classes that will be used during the operation of the application and call their load method, if it is implemented.  It turns out that even before the start of any code of our application, the variable AppControllerClassName will be added to your class. <br><br>  Here you might think: ‚ÄúWhat is the point of having this variable, if it is declared inside a method and will be destroyed from memory, when exiting this method?‚Äù.  The answer to this question lies a bit beyond Objective-C. <br><br><h3>  And here With ++? </h3><br>  Let's take another look at the declaration of this variable. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* AppControllerClassName;</code> </pre> <br>  The only thing that can be incomprehensible in this declaration is the extern modifier.  If you try to use this modifier in pure Objective-C, then Xcode will generate an error.  The fact is that this modifier is not part of Objective-C, it is implemented in C ++.  Objective-C can be described quite succinctly, saying that it is a ‚ÄúC language with classes‚Äù.  It is an extension of the C language and allows unlimited use of C code in conjunction with Objective-C code. <br><br>  However, to use extern and other features of C ++, you need to go for some trick - use Objective-C ++.  There is practically no information about this language, for the reason that it is just Objective-C code that allows insertion of C ++ code.  In order for the compiler to consider that some source file should be compiled as Objective-C ++, and not Objective-C you just need to change the extension of this file from <i>.m</i> to <i>.mm</i> . <br><br>  The extern modifier itself is used to declare a global variable.  More precisely, to tell the compiler ‚ÄúBelieve me, such a variable exists, but the memory for it was allocated not here, but in another source.  And she has value too, I guarantee. ‚Äù  Thus, our line of code simply creates a global variable and stores in it the name of our custom class.  It remains only to understand where this variable can be used. <br><br><h3>  Back to main </h3><br>  We recall what was said earlier - the application delegate is created by specifying the name of the class.  If a delegate created a standard Xcode template using the constant value [myClass class], then apparently the guys from Unity decided that this value should be wrapped in a variable.  Using the scientific method, take the XCode project generated by Unity3D and go to the <i>main.mm</i> file. <br><br>  In it, we see a more complex code than before, part of this code is missed as unnecessary: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// WARNING: this MUST be c decl (NSString ctor will be called after +load, so we cant really change its value) const char* AppControllerClassName = "UnityAppController"; int main(int argc, char* argv[]) { ... UIApplicationMain(argc, argv, nil, [NSString stringWithUTF8String: AppControllerClassName]); } return 0; }</span></span></code> </pre> <br>  Here we see the declaration of this variable itself, and the creation of the application delegate with its help. <br>  If we created a custom delegate, then the desired variable exists and already matters - the name of our class.  And declaring and initializing a variable before the main function ensures that it has a default value, UnityAppController. <br><br>  Now with this decision should be all very clear. <br><br><h3>  Macro problem </h3><br>  Of course, for the vast majority of situations, using this macro is a great solution.  But it is worth noting that there is a large pitfall in it: you cannot have more than one custom delegate.  This is because if 2 or more classes use the IMPL_APP_CONTROLLER_SUBCLASS (ClassName) macro, then for the first one, the value of the variable we need will be assigned, and further assignments are ignored.  And this variable is a string, that is, it cannot be assigned more than one value. <br><br>  You might think that this problem is degenerate and in practice is unlikely.  But, this article would not have happened if such a problem had not really happened, and even under very strange circumstances.  The situation may be as follows.  You have a project in which you use a lot of analytics and advertising services.  Many of these services have Objective-C components.  They have long been in your project and you do not know the troubles with them.  Here you need to write a custom delegate.  You use a magic macro, designed to save you from problems, collect the project and get a report on the success of the assembly.  Run the project on the device, and your functionality does not work and at the same time you do not get a single error. <br><br>  But the point may be that one of the plug-ins of advertising or analytics uses the same macro.  For example, in the plugin from <a href="https://support.appsflyer.com/hc/ru/articles/213766183-%25D0%2598%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F-AppsFlyer-SDK-Unity">AppsFlyer</a> this macro is used. <br><br><h3>  What value will the extern variable take in case of multiple declarations? </h3><br>  It is interesting to understand, if the same extern variable is declared in several files, and they are initialized in the manner of our macro (in the load method), how can you understand what value the variable will take?  To understand the pattern, a simple test application was created, the code of which can be viewed <a href="https://github.com/vmchar/ExternVariablesTest">here</a> . <br><br>  The essence of the application is simple.  There are 2 classes A and B, in both classes the extern variable AexternVar is declared, it is assigned a specific value.  Variable values ‚Äã‚Äãin classes are set differently.  In the main function, the value of this variable is output to the log.  Experimentally, it turned out that the value of a variable depends on the order in which source codes are added to the project.  The order in which the Objective-C runtime environment will register classes during the course of an application depends on this.  If you want to repeat the experiment, open the project and select the Build Phases tab in the project settings.  Since the project is test and small - there are only 8 sources in it.  All of them are present on the Build Phases tab in the Compile Sources list. <br><br><img src="https://habrastorage.org/webt/oi/ly/ln/oilylnhxdyjg3cvgcrj5nzhjvwy.png"><br><br>  If in this list the source of class A is higher than the source of class B, then the variable will take a value from class B. Otherwise, the variable will take a value from class A. <br><br>  Just imagine how many problems this small nuance can theoretically cause.  Especially if the project is huge, automatically generated and you do not know in which classes such a variable is declared. <br><br><h3>  Solution to the problem </h3><br>  Earlier in the article it was already said that Objective-C will give odds to C # Reflection.  Specifically, to solve our problem, you can use a mechanism that is called <a href="https://nshipster.com/method-swizzling/">Method Swizzling</a> .  The essence of this mechanism is that we have the opportunity to replace the implementation of the method of any class with another in the course of the application.  Thus, we can replace the method we are interested in in UnityAppController with a custom one.  We take existing implementation and we supplement with the code necessary to us.  We write code that replaces the existing implementation of the method with the one we need.  In the course of the application, the delegate using the macro will work as before, calling the base implementation of the UnityAppController, and there our custom method will come into play and we will achieve the desired result.  This approach is well-written and illustrated in <a href="http://eppz.eu/blog/override-app-delegate-unity-ios-osx-3/">this article</a> .  With this trick, we can make an auxiliary class ‚Äî an analogue of a custom delegate.  In this class, we will write the entire custom code, making the custom class a kind of Wrapper to call the functionality of other classes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Such an approach will work, but it is extremely implicit due to the fact that it is difficult to track where the method is replaced and what consequences it will have. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Another solution </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main aspect of the problem that has happened is that there are many who want to have custom delegates, but only one, or partially replaced by the second. </font><font style="vertical-align: inherit;">At the same time, there is no possibility to make the code of custom delegates not crawl along different source files. </font><font style="vertical-align: inherit;">It turns out that the reference situation can be considered when there is only one delegate in the application, you need to be able to create custom classes as many as you want, and none of these classes use the macro to avoid problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Things are going well, it remains to determine how this can be done with Unity3D, while leaving the possibility of building the project using a build machine. </font><font style="vertical-align: inherit;">The solution algorithm is as follows:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We write custom delegates in the required quantity, dividing the logic of plug-ins into different classes, observing the principles of SOLID and not resorting to sophistication. </font></font></li><li>       UnityAppController   XCode      .         UnityAppController   . </li><li>    UnityAppController     Unity . </li><li>     XCode     UnityAppController  ,       </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most difficult item from this list is undoubtedly the last. However, this feature can be implemented in Unity3D by means of the post process build script. Such a script was written on one beautiful night; you can look </font></font><a href="https://gist.github.com/vmchar/7a565711b6d58fd5bd60869f62d5e3d2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at it on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This post process is quite simple to use, select it in the Unity project. Look in the Inspector window and see there a field called NewDelegateFile. Drag and drop into this field your modified version of UnityAppController'a and save.</font></font><br><br><img src="https://habrastorage.org/webt/zs/sb/l2/zssbl2ttito42xsbqwcpqzqfezs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When building an iOS project, the standard delegate will be replaced with a modified one, with no manual intervention required. </font><font style="vertical-align: inherit;">Now, when adding new custom delegates to the project, you will only need to modify the UnityAppController variant that you have in the Unity project.</font></font><br><br><h4>  PS </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to everyone who got to the end, the article really turned out to be extremely long. </font><font style="vertical-align: inherit;">Hopefully, the written information will be useful.</font></font></div><p>Source: <a href="https://habr.com/ru/post/430118/">https://habr.com/ru/post/430118/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430106/index.html">New XYZprinting at IMTS 2018: 3D Printers and Robots</a></li>
<li><a href="../430108/index.html">Why "Young Technician" will not be able to build a laser</a></li>
<li><a href="../430112/index.html">How we learned to talk to millions of people</a></li>
<li><a href="../430114/index.html">How to create a reliable game mechanics in Excel. Part 2</a></li>
<li><a href="../430116/index.html">Computers write prose, but still give way to people. Why?</a></li>
<li><a href="../430120/index.html">Tame the beast. What did we encounter when developing an application for keeping a personal journal on React Native?</a></li>
<li><a href="../430122/index.html">Workaholism is a painful condition that is not customary to talk about</a></li>
<li><a href="../430126/index.html">Another list of projects on what to practice</a></li>
<li><a href="../430128/index.html">Development through testing: improving skills</a></li>
<li><a href="../430132/index.html">What we learned about Intel ME security in recent years: 7 facts about the mysterious subsystem</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>