<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast multiplication of polynomials using Fourier transform is just</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good evening. 
 This post is dedicated to the fast Fourier transform. Direct and inverse transformations (in complex numbers) will be considered. In t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast multiplication of polynomials using Fourier transform is just</h1><div class="post__text post__text-html js-mediator-article">  Good evening. <br>  This post is dedicated to the fast Fourier transform.  Direct and inverse transformations (in complex numbers) will be considered.  In the next part, I plan to consider their applications in some problems of Olympiad programming (in particular, one task about the “similarity” of strings), and also to tell about the implementation of the conversion in integers. <br>  An FFT is an algorithm that calculates values ​​of a polynomial of degree <i>n</i> = <i>2</i> <sup><i>k</i></sup> at some <i>n</i> points in <i>O</i> ( <i>n</i> ⋅log <i>n</i> ) time (the “naive” method performs the same task in <i>O</i> ( <i>n</i> <sup><i>2</i></sup> ) time).  At the same time, you can perform the inverse transform.  Since adding, subtracting and multiplying arrays of numbers is much easier than polynomials (especially multiplying), FFT is often used to speed up calculations with polynomials and long numbers. <br><h2><a name="habracut"></a>  Definitions and applications </h2><br>  First, let's define what a polynomial is: <br>  <i>P</i> ( <i>x</i> ) = <i>a</i> <sub><i>0</i></sub> + <i>x</i> <i>a</i> <sub><i>1</i></sub> + <i>x</i> <sup><i>2</i></sup> <i>a</i> <sub><i>2</i></sub> + <i>x</i> <sup><i>3</i></sup> <i>a</i> <sub><i>3</i></sub> + <b>...</b> + <i>x</i> <sup><i>n</i> - <i>1</i></sup> <i>a</i> <sub><i>n</i> - <i>1</i></sub> <br><h4>  Complex numbers </h4><br>  If you are familiar with complex numbers, you can skip this clause, otherwise, here is a brief definition: <br>  <i>x</i> = <i>a</i> + <i>i</i> <i>b</i> , where <i>i</i> <sup><i>2</i></sup> = - <i>1</i> <br>  Here <i>a</i> is called the <em>real</em> ( <em>Real</em> ) part, and <i>b</i> - the imaginary ( <em>Imaginary</em> ).  In these numbers, as you can easily see, you can extract the root from negative (and indeed any) numbers - this is very convenient when working with polynomials - as follows from the main theorem of the algebra, each polynomial of degree <i>n</i> has exactly <i>n</i> complex roots (taking into account the multiplicity ). <br>  It is also very convenient to represent them as points on a plane: <br><img src="https://habrastorage.org/storage/3f9e9cb0/d756ca73/74d76c35/df48633e.png"><br>  Another remarkable property of complex numbers is that they can be represented as <i>x</i> = (cosα + <i>i</i> sinα) <i>r</i> , where α is the polar angle of the "number" (called the <em>argument</em> ), and <i>r</i> is the distance from zero to it ( <em>module</em> ).  And when multiplying two numbers: <br>  <i>a</i> = (cosα + <i>i</i> ⋅sinα) <i>r</i> <sub><i>a</i></sub> <br>  <i>b</i> = (cosβ + <i>i</i> ⋅sinβ) <i>r</i> <sub><i>b</i></sub> <br>  <i>a</i> <i>b</i> = (cosα + <i>i</i> ⋅sinα) (cosβ + <i>i</i> ⋅sinβ) <i>r</i> <sub><i>a</i></sub> <i>r</i> <sub><i>b</i></sub> <br>  <i>a</i> <i>b</i> = (cosα⋅cosβ-sinα⋅sinβ + <i>i</i> (sinα⋅cosβ + cosβ⋅sinα)) <i>r</i> <sub><i>a</i></sub> <i>r</i> <sub><i>b</i></sub> <br>  <i>a</i> <i>b</i> = (cos (α + β) + <i>i</i> ⋅ sin (α + β)) <i>r</i> <sub><i>a</i></sub> <i>r</i> <sub><i>b</i></sub> <br>  Their modules are multiplied, and the arguments are added. <br><h4>  Complex roots of 1 </h4><br>  Now let's understand how the complex roots of the nth degree of <i>1</i> look like.  Let <i>x</i> <sup><i>n</i></sup> = <i>1</i> , then its module is obviously equal to one, and <i>n</i> ⋅ arg <i>x</i> = <i>2</i> π <i>k</i> , where <i>k</i> is an integer.  This means that after <i>n</i> multiplications of a number by itself (that is, raising to the <i>nth</i> power), its argument will become “multiple” by <i>2</i> π (360 degrees). <br>  Recall the formula of a number, if the argument and the module are known, we get: <br>  α = <i>2</i> π⋅ <i>x</i> / <i>n</i> , where <i>0</i> <i>x</i> <br>  ω <sub><i>i</i></sub> = cosα + <i>i</i> ⋅sinα <br>  Those.  if we draw, we just get the points on the circle at regular intervals: <br><img src="https://habrastorage.org/storage/3d39713e/72bd1a32/af760dc7/a6937973.png" width="263" height="243"><br>  Please note three things that we will actively use (without them, nothing happens): <br>  ω <sub><i>a</i></sub> ⋅ ω <sub><i>b</i></sub> = ω <sub>( <i>a</i> + <i>b</i> ) mod <i>n</i></sub> <br>  ω <sub><i>0</i></sub> + ω <sub><i>1</i></sub> + ω <sub><i>2</i></sub> + <b>...</b> + ω <sub><i>n</i> - <i>1</i></sub> = <i>0</i> <br>  ω <sub><i>0</i></sub> <sup><i>n</i> / <i>2</i></sup> = ω <sub><i>2</i></sub> <sup><i>n</i> / <i>2</i></sup> = ω <sub><i>4</i></sub> <sup><i>n</i> / <i>2</i></sup> = <b>...</b> = <i>1</i> (for even <i>n</i> ) <br>  Because of these properties, it is at these points that we will consider the value of the polynomial.  Of course, the results will not necessarily be real, so the program will need to work with complex numbers. <br><h3>  Why the sum of the roots is zero </h3><br>  The proof is very simple: let φ = ω <sub><i>0</i></sub> + ω <sub><i>1</i></sub> + <b>....</b>  Multiply both sides by ω <sub><i>1</i></sub> (! = 1).  Because  ω <sub><i>i</i></sub> ⋅ω <sub><i>1</i></sub> = ω <sub><i>i</i> + <i>1</i></sub> , then φ⋅ω <sub><i>1</i></sub> = ω <sub><i>1</i></sub> + ω <sub><i>2</i></sub> + <b>...</b> + ω <sub><i>n</i> - <i>1</i></sub> + ω <sub><i>0</i></sub> .  The sum does not change from the permutation of the terms, therefore φ = φ⋅ω <sub><i>1</i></sub> , respectively φ (ω <sub><i>1</i></sub> - <i>1</i> ) = <i>0</i> .  Because  ω <sub><i>1</i></sub> ! = 1, then φ = <i>0</i> . <br><h2>  How does it work </h2><br>  We assume that our polynomial has degree <i>n</i> = <i>2</i> <sup><i>k</i></sup> .  If not, we add the highest coefficients with zeros to the nearest power of two. <br>  The basic idea of ​​FFT is very simple: <br>  Let be: <br>  <i>A</i> ( <i>x</i> ) = <i>a</i> <sub><i>0</i></sub> + <i>x</i> <i>a</i> <sub><i>2</i></sub> + <i>x</i> <sup><i>2</i></sup> <i>a</i> <sub><i>4</i></sub> + <b>...</b> + <i>x</i> <sup><i>n</i> / <i>2</i> - <i>1</i></sup> <i>a</i> <sub><i>n</i> - <i>2</i></sub> (even coefficients <i>P</i> ) <br>  <i>B</i> ( <i>x</i> ) = <i>a</i> <sub><i>1</i></sub> + <i>x</i> <i>a</i> <sub><i>3</i></sub> + <i>x</i> <sup><i>2</i></sup> <i>a</i> <sub><i>5</i></sub> + <b>...</b> + <i>x</i> <sup><i>n</i> / <i>2</i> - <i>1</i></sup> <i>a</i> <sub><i>n</i> - <i>1</i></sub> (odd coefficients <i>P</i> ). <br>  Then <i>P</i> ( <i>x</i> ) = <i>A</i> ( <i>x</i> <sup><i>2</i></sup> ) + <i>x</i> ⋅ <i>B</i> ( <i>x</i> <sup><i>2</i></sup> ). <br>  Now apply the principle of "divide and conquer": to calculate the values ​​of <i>P</i> at <i>n</i> points (ω <sub><i>0</i></sub> , ω <sub><i>1</i></sub> , <b>...</b> ), count the values ​​of <i>A</i> and <i>B</i> recursively at <i>n</i> / <i>2</i> points (ω <sub><i>0</i></sub> , ω <sub><i>2</i></sub> , <b>...</b> ) .  Now the value of <i>P</i> (ω <sub><i>i</i></sub> ) is quite simple to restore: <br>  <i>P</i> (ω <sub><i>i</i></sub> ) = <i>A</i> (ω <sub><i>2</i> <i>i</i></sub> ) + ω <sub><i>i</i></sub> ⋅ <i>B</i> (ω <sub><i>2</i> <i>i</i></sub> ) <br>  If we denote for ξ <sub><i>i</i></sub> = ω <sub><i>2</i> <i>i the</i></sub> points at which we consider the values ​​of a polynomial of degree <i>n</i> / <i>2</i> , the formula will change: <br>  <i>P</i> (ω <sub><i>i</i></sub> ) = <i>A</i> (ξ <sub><i>i</i></sub> ) + ω <sub><i>i</i></sub> ⋅ <i>B</i> (ξ <sub><i>i</i></sub> ) <br>  It can already be driven into the program, not forgetting that <i>i</i> takes values ​​from <i>0</i> to <i>n</i> - <i>1</i> , and ξ <sub><i>i is</i></sub> defined only from <i>0</i> to <i>n</i> / <i>2</i> - <i>1</i> .  Conclusion - it will be necessary to take <i>i</i> modulo <i>n</i> / <i>2</i> . <br>  The running time is expressed by the recurrent formula <i>T</i> ( <i>n</i> ) = <i>O</i> ( <i>n</i> ) + <i>2</i> <i>T</i> ( <i>n</i> / <i>2</i> ).  This is a fairly well-known relation and it is revealed in <i>O</i> ( <i>n</i> ⋅log <sub><i>2</i></sub> <i>n</i> ) (roughly speaking, the recursion depth is log <sub><i>2</i></sub> <i>n</i> levels, at each level, <i>O</i> ( <i>n</i> ) operations are performed in total for all calls). <br><h2>  Write something </h2><br>  Here is an example of an inefficient recursive FFT implementation: <br><h5>  Slow FFT </h5><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; #include &lt;complex&gt; using namespace std; typedef complex&lt;double&gt; cd; // STL-  .   double,     sin  cos typedef vector&lt;cd&gt; vcd; vcd fft(const vcd &amp;as) { //       1 int n = as.size(); // -    ? if (n == 1) return vcd(1, as[0]); vcd w(n); //   for (int i = 0; i &lt; n; i++) { double alpha = 2 * M_PI * i / n; w[i] = cd(cos(alpha), sin(alpha)); } //   A  B vcd A(n / 2), B(n / 2); for (int i = 0; i &lt; n / 2; i++) { A[i] = as[i * 2]; B[i] = as[i * 2 + 1]; } vcd Av = fft(A); vcd Bv = fft(B); vcd res(n); for (int i = 0; i &lt; n; i++) res[i] = Av[i % (n / 2)] + w[i] * Bv[i % (n / 2)]; return res; }</span></span></span></span></code> </pre> <br>  You can add I / O and verify that your implementation is correct.  For the polynomial <i>P</i> ( <i>x</i> ) = <i>4</i> + <i>3</i> <i>x</i> + <i>2</i> <i>x</i> <sup><i>2</i></sup> + <i>x</i> <sup><i>3</i></sup> + <i>0</i> <i>x</i> <sup><i>4</i></sup> + <i>0</i> <i>x</i> <sup><i>5</i></sup> + <i>0</i> <i>x</i> <sup><i>6</i></sup> + <i>0</i> <i>x</i> <sup><i>7, the</i></sup> values ​​should be as follows: <br>  <i>P</i> ( <i>w</i> <sub><i>0</i></sub> ) = ( <i>1</i> <i>0.</i> <i>0</i> <i>0</i> <i>0</i> , <i>0.</i> <i>0</i> <i>0</i> <i>0</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>1</i></sub> ) = ( <i>5.</i> <i>4</i> <i>1</i> <i>4</i> , <i>4.</i> <i>8</i> <i>2</i> <i>8</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>2</i></sub> ) = ( <i>2.</i> <i>0</i> <i>0</i> <i>0</i> , <i>2.</i> <i>0</i> <i>0</i> <i>0</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>3</i></sub> ) = ( <i>2.</i> <i>5</i> <i>8</i> <i>6</i> , <i>0.</i> <i>8</i> <i>2</i> <i>8</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>4</i></sub> ) = ( <i>2.</i> <i>0</i> <i>0</i> <i>0</i> , <i>0.</i> <i>0</i> <i>0</i> <i>0</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>5</i></sub> ) = ( <i>2.</i> <i>5</i> <i>8</i> <i>6</i> , - <i>0.</i> <i>8</i> <i>2</i> <i>8</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>6</i></sub> ) = ( <i>2.</i> <i>0</i> <i>0</i> <i>0</i> , - <i>2.</i> <i>0</i> <i>0</i> <i>0</i> ) <br>  <i>P</i> ( <i>w</i> <sub><i>7</i></sub> ) = ( <i>5.</i> <i>4</i> <i>1</i> <i>4</i> , - <i>4.</i> <i>8</i> <i>2</i> <i>8</i> ) <br>  If so, you can note the time of the recursive and naive method on large tests. <br>  I have a polynomial of degree <i>2</i> <sup><i>12,</i></sup> this implementation runs 62 ms, naive - 1800 ms.  The difference is obvious. <br><h3>  Getting rid of recursion </h3><br>  In order to make the procedure non-recursive, you have to think.  The easiest way, it seems to me, is to draw an analogy with MergeSort (merge sort) and draw a picture that shows all the recursive calls: <br><img src="http://habrastorage.org/storage/53ebde06/f16523c2/70da1628/c6f089c3.png"><br>  As we see, you can make one array, fill it initially with the values ​​fft ( <i>a</i> <sub><i>0</i></sub> ), fft ( <i>a</i> <sub><i>4</i></sub> ), fft ( <i>a</i> <sub><i>2</i></sub> ), <b>....</b>  As it is easy to understand, the numbers <i>a</i> <sub><i>i</i></sub> are the numbers “ <i>0</i> , <i>1</i> , <i>2</i> , <i>3</i> , <b>...</b> ” “expanded” in the binary representation.  For example, <i>1</i> <sub><i>1</i></sub> <i>0</i> = <i>0</i> <i>0</i> <i>1</i> <sub><i>2</i></sub> , <i>4</i> <sub><i>1</i></sub> <i>0</i> = <i>1</i> <i>0</i> <i>0</i> <sub><i>2</i></sub> or <i>6</i> = <i>1</i> <i>1</i> <i>0</i> <sub><i>2</i></sub> , <i>3</i> = <i>0</i> <i>1</i> <i>1</i> <sub><i>2</i></sub> .  This can be understood as follows: when descending to the lower level of recursion, we have one more low-order bit (from the end).  And with “normal” numbering, the bits are determined from the beginning.  Therefore, you need to "expand" the number.  This can be done “head on” for <i>O</i> ( <i>n</i> ⋅log <sub><i>2</i></sub> <i>n</i> ), or it can be dynamically programmed for <i>O</i> ( <i>n</i> ) using the following algorithm: <br><ol><li>  Run through the cycle from <i>0</i> to <i>n</i> - <i>1</i> </li><li>  We will store and dynamically recalculate the number of the highest single bit of the number.  It changes only when the current number is a power of two: it increases by 1. </li><li>  When we know the most significant bit of a number, it’s easy to invert the whole number: “cut off” the most significant bit (XOR), turn over the remainder (already calculated value) and add the “cut off” unit </li></ol><br>  Now we come up with an algorithm that allows us to get a step higher from the “step”.  Store all values ​​from the previous step, we will be in the same array.  As can be clearly seen in the figure, it is necessary to process the data in blocks of <i>k</i> , and at the beginning <i>k</i> = <i>1</i> , and then with each step it doubles.  We process two blocks of length <i>k</i> and get one block of length <i>2</i> <i>k</i> at the output.  Let's take an example to analyze how it was done recursively, recall the formula from the beginning of the article and repeat: <br><img src="http://habrastorage.org/storage/55691ba6/1fef06bd/3505bab9/6a938c7a.png"><br>  The arguments of the procedure for merging two blocks will be two vectors (naturally, by reference, the original and the result), the number of the starting element of the first block (the second comes right after) and the length of the blocks.  It could of course be done with iterators — for more STL, but we will still carry this procedure inside the core for brevity. <br><h5>  Block combination </h5><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fft_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vcd &amp;src, vcd &amp;dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p1 = start; <span class="hljs-comment"><span class="hljs-comment">//     int en1 = start + len; //    int p2 = start + len; //     int en2 = star + len * 2; //    int pdest = start; //      int nlen = len * 2; //    for (int i = 0; i &lt; nlen; i++) { double alpha = 2 * M_PI * i / nlen; cd w = cd(cos(alpha), sin(alpha)); //   dest[pdest] = src[p1] + w * src[p2]; if (++p1 &gt;= en1) p1 = start; if (++p2 &gt;= en2) p2 = start + len; } }</span></span></code> </pre><br>  And the basic conversion procedure: <br><pre> <code class="hljs pgsql">vcd fft(const vcd &amp;<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>.size(); <span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; //  n   <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; k) &lt; n) k++; vi rev(n); rev[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> high1 = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((i &amp; (i - <span class="hljs-number"><span class="hljs-number">1</span></span>)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) //    .  i  ,  i<span class="hljs-number"><span class="hljs-number">-1</span></span>     . high1++; rev[i] = rev[i ^ (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; high1)]; //   rev[i] |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (k - high1 - <span class="hljs-number"><span class="hljs-number">1</span></span>)); //    } vcd cur(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) cur[i] = <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>[rev[i]]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> len = <span class="hljs-number"><span class="hljs-number">1</span></span>; len &lt; n; len &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { vcd ncur(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i += len * <span class="hljs-number"><span class="hljs-number">2</span></span>) fft_merge(cur, ncur, i, len); cur.swap(ncur); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cur; }</code> </pre><br><h3>  Optimization </h3><br>  At the polynomial of degree <i>2</i> <sup><i>1</i> <i>6, the</i></sup> recursion works 640 ms, without recursion - 500. There is an improvement, but the program can be made even faster.  We use the property that ω <sub><i>i</i></sub> = -ω <sub><i>i</i> + <i>n</i> / <i>2</i></sub> .  This means that you can not count twice the root and <i>a</i> <sub><i>i</i></sub> ⋅ ω <sub><i>j</i></sub> - sine, cosine and multiplication of complex numbers are very costly operations. <br><h5>  fft_merge () </h5><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">2</span></span> * M_PI * i / nlen; cd w = cd(<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(alpha), <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(alpha)); <span class="hljs-comment"><span class="hljs-comment">//   cd val = w * src[p2]; dest[pdest] = src[p1] + val; dest[pdest + len] = src[p1] - val; pdest++; if (++p1 &gt;= en1) p1 = start; if (++p2 &gt;= en2) p2 = start + len; }</span></span></code> </pre><br>  The transition with this optimization is called “butterfly transformation”.  The program began to work 260 ms.  To consolidate success, let's assume all the roots of <i>1</i> and write them into an array: <br><h5>  fft_merge () </h5><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rstep = roots.size() / nlen; <span class="hljs-comment"><span class="hljs-comment">//      for (int i = 0; i &lt; len; i++) { cd w = roots[i * rstep]; cd val = w * src[p2];</span></span></code> </pre><br><h5>  fft () </h5><pre> <code class="cpp hljs">roots = vcd(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> alpha = <span class="hljs-number"><span class="hljs-number">2</span></span> * M_PI * i / n; roots[i] = cd(<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(alpha), <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(alpha)); }</code> </pre><br>  Now the speed is 78 ms.  Optimization of 8 times compared with the first implementation! <br><h3>  Code optimization </h3><br>  At the moment, the entire conversion code takes about 55 lines.  Not a hundred, but this is quite a lot - it can be shorter.  First, get rid of a heap of unnecessary variables and operations in <em>fft_merge</em> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fft_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vcd &amp;src, vcd &amp;dest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> start, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p1 = start; <span class="hljs-comment"><span class="hljs-comment">//int en1 = start + len; //  , .   int p2 = start + len; //int en2 = start + len * 2; //  int pdest = start; //int nlen = len * 2; //      //int rstep = roots.size() / nlen; int rstep = roots.size() / (len * 2); for (int i = 0; i &lt; len; i++) { //cd w = roots[i * rstep]; //       //cd val = w * src[p2]; cd val = roots[i * rstep] * src[p2]; dest[pdest] = src[p1] + val; dest[pdest + len] = src[p1] - val; pdest++, p1++, p2++; //if (++p1 &gt;= en1) p1 = start; //         2len,    len,     //if (++p2 &gt;= en2) p2 = start + len; //  } }</span></span></code> </pre><br>  Now you can move the cycle from <em>fft_merge</em> to the main procedure (you can also remove <em>p2</em> , since <em>p2 = p1 + len</em> - for me this also gave a small time gain. What is curious, if you remove <em>p1 = pdest</em> , then I personally have a time gain killed) : <br><h5>  fft () </h5><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = <span class="hljs-number"><span class="hljs-number">1</span></span>; len &lt; n; len &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-function"><span class="hljs-function">vcd </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ncur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rstep = roots.size() / (len * <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pdest = <span class="hljs-number"><span class="hljs-number">0</span></span>; pdest &lt; n;) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p1 = pdest; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { cd val = roots[i * rstep] * cur[p1 + len]; ncur[pdest] = cur[p1] + val; ncur[pdest + len] = cur[p1] - val; pdest++, p1++; } pdest += len; } cur.swap(ncur); }</code> </pre><br>  As you can see, the conversion itself takes not so much - 17 lines.  All the rest is the prerequisite of roots and reversal of numbers.  If you are ready to save the code in exchange for the running time ( <i>O</i> ( <i>n</i> ⋅log <sub><i>2</i></sub> <i>n</i> ) instead of <i>O</i> ( <i>n</i> )), you can replace the 13 reversal lines with the following six: <br><h5>  At the beginning of the fft () procedure </h5><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vcd </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cur</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ri = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; i2 &lt; k; i2++) <span class="hljs-comment"><span class="hljs-comment">//       ri = (ri &lt;&lt; 1) | !!(i &amp; (1 &lt;&lt; i2)); //      cur[i] = as[ri]; }</span></span></code> </pre><br>  As a result, the code now looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vcd </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fft</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vcd &amp;as)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = as.size(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  n   while ((1 &lt;&lt; k) &lt; n) k++; vector&lt;int&gt; rev(n); rev[0] = 0; int high1 = -1; for (int i = 1; i &lt; n; i++) { if ((i &amp; (i - 1)) == 0) //    .  i  ,  i-1     . high1++; rev[i] = rev[i ^ (1 &lt;&lt; high1)]; //   rev[i] |= (1 &lt;&lt; (k - high1 - 1)); //    } vcd roots(n); for (int i = 0; i &lt; n; i++) { double alpha = 2 * M_PI * i / n; roots[i] = cd(cos(alpha), sin(alpha)); } vcd cur(n); for (int i = 0; i &lt; n; i++) cur[i] = as[rev[i]]; for (int len = 1; len &lt; n; len &lt;&lt;= 1) { vcd ncur(n); int rstep = roots.size() / (len * 2); for (int pdest = 0; pdest &lt; n;) { int p1 = pdest; for (int i = 0; i &lt; len; i++) { cd val = roots[i * rstep] * cur[p1 + len]; ncur[pdest] = cur[p1] + val; ncur[pdest + len] = cur[p1] - val; pdest++, p1++; } pdest += len; } cur.swap(ncur); } return cur; }</span></span></code> </pre><br><h2>  Inverse transform </h2><br>  Obtaining the values ​​of a polynomial in points is, of course, good, but the Fourier transform can do more — construct a polynomial by these values, moreover, in the same time!  It turns out that if we apply the Fourier transform to an array of values ​​as to the coefficients of a polynomial, then divide the result by <i>n</i> and invert the segment from <i>1</i> to <i>n</i> - <i>1</i> (numbering from <i>0</i> ), then we obtain the coefficients of the original polynomial. <br>  The code here is extremely simple - everything is already written.  I think you can handle it. <br><h3>  Evidence </h3><br>  Suppose we apply the inverse transformation to the polynomial <i>P</i> ( <i>x</i> ) with coefficients <i>v</i> <sub><i>i</i></sub> (the original polynomial had coefficients <i>a</i> <sub><i>i</i></sub> ): <br>  <i>v</i> <sub><i>i</i></sub> = <i>a</i> <sub><i>0</i></sub> + ω <sub><i>i</i></sub> <i>a</i> <sub><i>1</i></sub> + ω <sub><i>2</i> <i>i</i></sub> <i>a</i> <sub><i>2</i></sub> + ω <sub><i>3</i> <i>i</i></sub> <i>a</i> + <b>...</b> <br>  Let's look at the result of the conversion: <br>  <i>b</i> <sub><i>i</i></sub> = <i>v</i> <sub><i>0</i></sub> + ω <sub><i>i</i></sub> <i>v</i> <sub><i>1</i></sub> + ω <sub><i>2</i> <i>i</i></sub> <i>v</i> <sub><i>2</i></sub> + ω <sub><i>3</i> <i>i</i></sub> <i>v</i> <sub><i>3</i></sub> + <b>...</b> <br>  Substitute the values ​​of <i>v</i> <sub><i>j</i></sub> (remember that ω <sub><i>a</i></sub> ω <sub><i>b</i></sub> = ω <sub><i>a</i> + <i>b</i> <i>m</i> <i>o</i> <i>d</i> <i>n</i></sub> : <br><img src="http://habrastorage.org/storage/6a57e381/d982e073/1ea91152/092bf7f1.png"><br>  Now let's prove one remarkable fact: for <i>x</i> ≠ <i>0</i> , ω <sub><i>0</i></sub> + ω <sub><i>x</i></sub> + ω <sub><i>2</i> <i>x</i></sub> + <b>...</b> + ω <sub>( <i>n</i> - <i>1</i> ) <i>x</i></sub> = <i>0</i> . <br>  It is proved analogously to the fact that the sum of the roots is zero: we denote by φ the sum, multiply both sides by ω <sub><i>x</i></sub> and see what happens. <br>  Now apply this fact to the calculation of the value of <i>b</i> <sub><i>i</i></sub> .  Note that all lines except one, which contains <i>a</i> <sub><i>n</i> - <i>i</i></sub> , will be reset. <br><br>  In this way: <br><br>  <i>b</i> <sub><i>i</i></sub> = <i>a</i> <sub><i>n</i> - <i>i</i></sub> ⋅ (ω <sub><i>0</i></sub> + ω <sub><i>0</i></sub> + ω <sub><i>0</i></sub> + ω <sub><i>0</i></sub> + <b>...</b> ) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>b</i> <sub><i>i</i></sub> = <i>a</i> <sub><i>n</i> - <i>i</i></sub> ⋅ <i>n</i> <br><br>  Q.E.D. <br><h2>  Application </h2><br>  Generally speaking, I already talked a little about the application at the beginning of the article.  In particular, now the multiplication of polynomials can be performed as follows: <br><h5>  Fast polynomial multiplication </h5><pre> <code class="hljs objectivec">vcd a, b; <span class="hljs-comment"><span class="hljs-comment">//  //   vcd a_vals = fft(a); vcd b_vals = fft(b); vcd c_vals(a_vals.size()); for (int i = 0; i &lt; a_vals.size(); i++) c_vals[i] = a_vals[i] * b_vals[i]; vcd c = fft_rev(c_vals); //  </span></span></code> </pre><br>  It is easy to see that the running time of this program is <i>O</i> ( <i>n</i> ⋅log <sub><i>2</i></sub> <i>n</i> ) and the most time consuming operations are Fourier transforms.  It can also be noted that if we need to calculate a more complex expression with two polynomials, then still we can perform only three transformations - addition and subtraction will also work in linear time.  Unfortunately, the division is not so simple, because the polynomial may accidentally take the value 0 at any of the points.  <b>UPD2:</b> do not forget that the degree of the product of two polynomials of degree <i>n</i> will be equal to <i>2n</i> , so when entering you should add “extra” zero leading coefficients. <br>  If you represent a number in decimal (or more) number system, as a polynomial with coefficients - numbers, the multiplication of long numbers can also be done very quickly. <br>  And finally, the task I will discuss in the following post: you have two lines of the same length of the order of <i>1</i> <i>0</i> <sup><i>5</i></sup> from the letters A, T, G, C. It is required to find such a cyclic shift of one of the lines so that the maximum number of characters matches.  Obviously a naive solution for <i>O</i> ( <i>n</i> <sup><i>2</i></sup> ), but there is a solution with the help of FFT. <br>  Good luck! <br><br>  <b>UPD:</b> Laid out the code entirely on <a href="http://pastebin.com/3Tnj5mRu">pastebin</a> </div><p>Source: <a href="https://habr.com/ru/post/113642/">https://habr.com/ru/post/113642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113634/index.html">Live prototyping of applications on Titanium using Livetanium</a></li>
<li><a href="../113635/index.html">RubyConf 2010: the present and the future of Ruby (I)</a></li>
<li><a href="../113636/index.html">We automate the layout of django-projects on the server</a></li>
<li><a href="../113638/index.html">Test the environment for testing: MS Visual Studio Test Professional 2010</a></li>
<li><a href="../113640/index.html">How to start developing business processes</a></li>
<li><a href="../113646/index.html">Sony has received permission to examine information on the hard disk from a PC hacker GeoHot</a></li>
<li><a href="../113648/index.html">Atheros Communications and Marvell Technologies released 802.11n-enabled mobile network chips</a></li>
<li><a href="../113650/index.html">Android tablets now in Indian buses</a></li>
<li><a href="../113652/index.html">Choosing a job, do not forget to choose a boss</a></li>
<li><a href="../113653/index.html">30% increase in Windows Phone 7 Marketplace</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>