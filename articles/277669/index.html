<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Java.util.concurrent. * Synchronizer reference</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The purpose of this publication is not a complete analysis of the synchronizers from the java.util.concurrent package. I am writing it, first of all, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Java.util.concurrent. * Synchronizer reference</h1><div class="post__text post__text-html js-mediator-article">  The purpose of this publication is not a complete analysis of the synchronizers from the java.util.concurrent package.  I am writing it, first of all, as a reference book, which will facilitate entry into the topic and show the possibilities of practical application of classes for synchronization of threads (hereinafter thread = thread). <br><br>  In java.util.concurrent there are many different classes that can be divided into groups according to their functionality: Concurrent Collections, Executors, Atomics, etc.  Synchronizers will be one of these groups. <br><br><img src="https://habrastorage.org/files/303/865/e0e/303865e0e58b4514863ca687a498d9cd.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Synchronizers</b> are auxiliary utilities for synchronizing threads, which enable the developer to regulate and / or restrict the work of streams and provide a higher level of abstraction than the main language primitives (monitors). <br><a name="habracut"></a><br><br><h4>  Semaphore </h4><br>  Semaphore Synchronizer implements the <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2584%25D0%25BE%25D1%2580_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">Semaphore</a> sync pattern.  Most often, semaphores are needed when you need to restrict access to a shared resource.  The constructor of this class ( <code>Semaphore(int permits)</code> or <code>Semaphore(int permits, boolean fair)</code> ) always passes the number of threads that the semaphore will allow to simultaneously use the specified resource. <br><br><img src="https://habrastorage.org/files/9da/48f/85b/9da48f85b5874362bc2279f181613c0e.gif"><br><br>  Access is controlled by a counter: initially, the counter value is <code>int permits</code> , when a thread enters a given block of code, the counter value decreases by one, when the stream leaves it, it increases.  If the counter value is zero, then the current flow is blocked until someone leaves the block (as an example of life with <code>permits = 1</code> , you can bring a queue to the office in the clinic: when the patient leaves the office, the lamp flashes, and the next patient enters ). <br><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html">Official documentation for Semaphore.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Semaphore usage example</b> <div class="spoiler_text">  Consider the following example.  There is parking, which at the same time can accommodate no more than 5 cars.  If the parking lot is full, the newly arrived car must wait until at least one place is vacated.  After that, he will be able to park. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Semaphore; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parking</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   - true,  - false private static final boolean[] PARKING_PLACES = new boolean[5]; //  "",     //aquire()       private static final Semaphore SEMAPHORE = new Semaphore(5, true); public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 7; i++) { new Thread(new Car(i)).start(); Thread.sleep(400); } } public static class Car implements Runnable { private int carNumber; public Car(int carNumber) { this.carNumber = carNumber; } @Override public void run() { System.out.printf(" ‚Ññ%d   .\n", carNumber); try { //acquire()          , //   ,        , //     SEMAPHORE.acquire(); int parkingNumber = -1; //     synchronized (PARKING_PLACES){ for (int i = 0; i &lt; 5; i++) if (!PARKING_PLACES[i]) { //   PARKING_PLACES[i] = true; //  parkingNumber = i; //  ,   System.out.printf(" ‚Ññ%d    %d.\n", carNumber, i); break; } } Thread.sleep(5000); //  ,   synchronized (PARKING_PLACES) { PARKING_PLACES[parkingNumber] = false;//  } //release(), ,   SEMAPHORE.release(); System.out.printf(" ‚Ññ%d  .\n", carNumber); } catch (InterruptedException e) { } } } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of the program</b> <div class="spoiler_text">  Car number 1 drove to the parking lot. <br>  Car number 1 parked at location 0. <br>  Car number 2 drove up to the parking lot. <br>  Car number 2 parked in place 1. <br>  Car number 3 drove up to the parking lot. <br>  Car number 3 parked on the spot 2. <br>  Car number 4 drove to the parking lot. <br>  Car number 4 parked on the spot 3. <br>  Car number 5 drove to the parking lot. <br>  Car number 5 parked on the spot 4. <br>  Car number 6 drove to the parking lot. <br>  Car number 7 drove to the parking lot. <br>  Car number 1 left the parking lot. <br>  Car number 6 parked at location 0. <br>  Car number 2 left the parking lot. <br>  Car number 7 parked in place 1. <br>  Car number 3 left the parking lot. <br>  Car number 4 left the parking lot. <br>  Car number 5 left the parking lot. <br>  Car number 6 left the parking lot. <br>  Car number 7 left the parking lot. <br></div></div><br>  A semaphore is great for solving this problem: it does not allow the car (stream) to park (go into a given code block and use a shared resource) if there are no parking spaces (the counter is 0) It is worth noting that the Semaphore class supports capturing and releasing more than one permissions at a time, but this is not necessary in this task. <br></div></div><br><br><h4>  CountDownLatch </h4><br>  CountDownLatch (countdown lock) provides the ability for any number of threads in a code block to wait until a certain number of operations are executed in other threads before they are ‚Äúreleased‚Äù to continue their operations.  The CountDownLatch ( <code>CountDownLatch(int count)</code> ) constructor must pass the number of operations that must be performed in order for the lock to ‚Äúrelease‚Äù the blocked threads. <br><br><img src="https://habrastorage.org/files/46b/3ae/b41/46b3aeb417cf4fb4ba271b4c66b52436.gif"><br><br>  The blocking of threads is removed with the help of a counter: any valid stream, when performing a certain operation, decreases the value of the counter.  When the counter reaches 0, all waiting threads are unlocked and continue to run (for example, a collection of an excursion group can serve as an example of the CountDownLatch: until a certain number of people are gathered, the excursion will not begin). <br><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html">Official documentation for CountDownLatch.</a> <br><br><div class="spoiler">  <b class="spoiler_title">CountDownLatch usage example</b> <div class="spoiler_text">  Consider the following example.  We want to hold a car race.  Five cars take part in the race.  To start the race you need to fulfill the following conditions: <br><ol><li>  Each of the five cars drove up to the starting straight; </li><li>  The command ‚ÄúTo the start!‚Äù Was given; </li><li>  The command "Attention!" Was given; </li><li>  The command "Marsh!" Was given. </li></ol>  It is important that all cars start at the same time. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CountDownLatch; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Race</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// CountDownLatch  8 "" private static final CountDownLatch START = new CountDownLatch(8); //    private static final int trackLength = 500000; public static void main(String[] args) throws InterruptedException { for (int i = 1; i &lt;= 5; i++) { new Thread(new Car(i, (int) (Math.random() * 100 + 50))).start(); Thread.sleep(1000); } while (START.getCount() &gt; 3) //,     Thread.sleep(100); //  .  ,  100ms Thread.sleep(1000); System.out.println(" !"); START.countDown();// ,    1 Thread.sleep(1000); System.out.println("!"); START.countDown();// ,    1 Thread.sleep(1000); System.out.println("!"); START.countDown();// ,    1 //   ,     //  } public static class Car implements Runnable { private int carNumber; private int carSpeed;//,     public Car(int carNumber, int carSpeed) { this.carNumber = carNumber; this.carSpeed = carSpeed; } @Override public void run() { try { System.out.printf(" ‚Ññ%d    .\n", carNumber); //     -   //   1 START.countDown(); // await()  ,  ,   ,  // CountDownLatch    0 START.await(); Thread.sleep(trackLength / carSpeed);//    System.out.printf(" ‚Ññ%d !\n", carNumber); } catch (InterruptedException e) { } } } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of the program</b> <div class="spoiler_text">  Car number 1 approached the starting line. <br>  Car number 2 approached the starting line. <br>  Car number 3 approached the starting line. <br>  Car number 4 approached the starting line. <br>  Car number 5 approached the starting line. <br>  On your marks! <br>  Attention! <br>  March! <br>  Car number 4 finished! <br>  Car number 1 finished! <br>  Car number 3 finished! <br>  Car number 5 finished! <br>  Car number 2 finished! <br></div></div><br>  CountDownLatch can be used in a variety of synchronization schemes: for example, so that while one thread does work, make other threads wait or, on the contrary, make the stream wait for others to do the work. <br></div></div><br><br><h4>  CyclicBarrier </h4><br>  CyclicBarrier implements the pattern of synchronization <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D1%2580%25D1%258C%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Barrier</a> .  A cyclic barrier is a synchronization point at which a specified number of parallel flows are encountered and blocked.  As soon as all profit streams are completed, an optional action is performed (or not performed if the barrier was initialized without it), and, after it has been completed, the barrier breaks and the waiting streams are ‚Äúreleased‚Äù.  The barrier constructor ( <code>CyclicBarrier(int parties)</code> and <code>CyclicBarrier(int parties, Runnable barrierAction)</code> ) must transmit the number of parties that must ‚Äúmeet‚Äù, and, optionally, the action that should occur when the parties meet, but before "Released." <br><br><img src="https://habrastorage.org/files/89a/f0c/b71/89af0cb71aad4465bb9c934b8be91a67.gif"><br><br>  The barrier is similar to CountDownLatch, but the main difference between them is that you cannot reuse the ‚Äúlock‚Äù after its counter reaches zero, and you can use the barrier again even after it breaks.  CyclicBarrier is an alternative to the <code>join()</code> method, which ‚Äúcollects‚Äù threads only after they have been executed. <br><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html">Official CyclicBarrier documentation.</a> <br><br><div class="spoiler">  <b class="spoiler_title">CyclicBarrier usage example</b> <div class="spoiler_text">  Consider the following example.  There is a ferry.  The ferry can ship three cars at a time.  In order not to drive the ferry once again, you need to send it when at least three cars are collected at the crossing. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.CyclicBarrier; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ferry</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CyclicBarrier BARRIER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CyclicBarrier(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FerryBoat()); <span class="hljs-comment"><span class="hljs-comment">//      ,   ,  //    .  ,   . public static void main(String[] args) throws InterruptedException { for (int i = 0; i &lt; 9; i++) { new Thread(new Car(i)).start(); Thread.sleep(400); } } //,        public static class FerryBoat implements Runnable { @Override public void run() { try { Thread.sleep(500); System.out.println("  !"); } catch (InterruptedException e) { } } } //,     public static class Car implements Runnable { private int carNumber; public Car(int carNumber) { this.carNumber = carNumber; } @Override public void run() { try { System.out.printf(" ‚Ññ%d    .\n", carNumber); //        ,    await() //    ,        BARRIER.await(); System.out.printf(" ‚Ññ%d  .\n", carNumber); } catch (Exception e) { } } } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of the program</b> <div class="spoiler_text">  Car number 0 approached the ferry. <br>  Car number 1 approached the ferry. <br>  Car number 2 approached the ferry. <br>  Car number 3 approached the ferry. <br>  Ferry ferried cars! <br>  Car number 2 continued to move. <br>  Car number 1 continued driving. <br>  Car number 0 continued to move. <br>  Car number 4 approached the ferry. <br>  Car number 5 approached the ferry. <br>  Car number 6 approached the ferry. <br>  Ferry ferried cars! <br>  Car number 5 continued to move. <br>  Car number 4 continued to move. <br>  Car number 3 continued to move. <br>  Car number 7 drove up to the ferry. <br>  Car number 8 approached the ferry. <br>  Ferry ferried cars! <br>  Car number 8 continued to move. <br>  Car number 6 continued to move. <br>  Car number 7 continued to move. <br></div></div><br>  When the three streams reach the <code>await()</code> method, the barrier action is triggered and the ferry forwards three cars from the accumulated ones.  After this, a new cycle begins. <br></div></div><br><br><h4>  Exchanger &lt;V&gt; </h4><br>  An exchanger may be needed in order to exchange data between two threads at a specific point in the operation of both streams.  The exchanger is a generic class, it is parameterized by the type of object to pass. <br><br><img src="https://habrastorage.org/files/947/ef3/f47/947ef3f47ff843a099059006b30ea54d.gif"><br><br>  The exchanger is the synchronization point of a pair of threads: the flow that calls the <code>exchange()</code> method on the <code>exchange()</code> blocked and another thread is waiting.  When another thread calls the same method, objects will be exchanged: each of them will receive the argument of the other in the <code>exchange()</code> method.  It is worth noting that the exchanger supports the transfer of <code>null</code> values.  This makes it possible to use it to transfer an object in one direction, or simply as a synchronization point for two streams. <br><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Exchanger.html">Official Exchanger documentation.</a> <br><br><div class="spoiler">  <b class="spoiler_title">Exchanger usage example</b> <div class="spoiler_text">  Consider the following example.  There are two trucks: one goes from point A to point D, the other from point B to point C. The roads AD and BC intersect at point E. From points A and B you need to deliver parcels to points C and D. For this, trucks at point E must meet and exchange the relevant parcels. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Exchanger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Delivery</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     String private static final Exchanger&lt;String&gt; EXCHANGER = new Exchanger&lt;&gt;(); public static void main(String[] args) throws InterruptedException { String[] p1 = new String[]{"{ A-&gt;D}", "{ A-&gt;C}"};//   1-  String[] p2 = new String[]{"{ B-&gt;C}", "{ B-&gt;D}"};//   2-  new Thread(new Truck(1, "A", "D", p1)).start();// 1-     D Thread.sleep(100); new Thread(new Truck(2, "B", "C", p2)).start();// 2-      } public static class Truck implements Runnable { private int number; private String dep; private String dest; private String[] parcels; public Truck(int number, String departure, String destination, String[] parcels) { this.number = number; this.dep = departure; this.dest = destination; this.parcels = parcels; } @Override public void run() { try { System.out.printf("  ‚Ññ%d : %s  %s.\n", number, parcels[0], parcels[1]); System.out.printf(" ‚Ññ%d    %s   %s.\n", number, dep, dest); Thread.sleep(1000 + (long) Math.random() * 5000); System.out.printf(" ‚Ññ%d    .\n", number); parcels[1] = EXCHANGER.exchange(parcels[1]);//  exchange()     //    exchange(),      System.out.printf("  ‚Ññ%d     %s.\n", number, dest); Thread.sleep(1000 + (long) Math.random() * 5000); System.out.printf(" ‚Ññ%d   %s  : %s  %s.\n", number, dest, parcels[0], parcels[1]); } catch (InterruptedException e) { } } } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of the program</b> <div class="spoiler_text">  In the truck number 1 loaded: {parcel A-&gt; D} and {parcel A-&gt; C}. <br>  Truck number 1 left from point A to point D. <br>  In the truck number 2 loaded: {parcel B-&gt; C} and {parcel B-&gt; D}. <br>  Truck number 2 drove from point B to point C. <br>  Truck number 1 arrived at point E. <br>  Truck number 2 arrived at point E. <br>  In the truck number 2 moved the parcel for point C. <br>  In the truck number 1 moved the parcel for point D. <br>  Truck number 2 arrived in C and delivered: {parcel B-&gt; C} and {parcel A-&gt; C}. <br>  Truck number 1 arrived in D and delivered: {parcel A-&gt; D} and {parcel B-&gt; D}. <br></div></div><br>  As we can see, when one truck (one stream) arrives at point E (reaches the synchronization point), it waits until another truck (another stream) arrives at point E (reaches the synchronization point).  After this, the parcel (String) is exchanged and both trucks (streams) continue their journey (work). <br></div></div><br><br><h4>  Phaser </h4><br>  Phaser (phaser), like CyclicBarrier, is an implementation of the <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D1%2580%25D1%258C%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2585%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">Barrier</a> synchronization pattern, but, unlike CyclicBarrier, provides more flexibility.  This class allows you to synchronize streams that represent a single phase or stage of performing a common action.  Like CyclicBarrier, the Phaser is the synchronization point at which the participating threads meet.  When all parties have arrived, Phaser moves to the next phase and waits for its completion again. <br><br>  If we compare Phaser and CyclicBarrier, we can highlight the following important features of the Phaser: <br><ul><li>  Each phase (synchronization cycle) has a number; </li><li>  The number of parties involved is not rigidly defined and can change: the flow can register as a participant and cancel its participation; </li><li>  The participant is not obliged to wait until all other participants gather at the barrier.  To continue your work it is enough to announce your arrival; </li><li>  Casual witnesses can monitor the activity in the barrier; </li><li>  The flow may not be a party to the barrier to expect to overcome it; </li><li>  Phaser has no optional action. </li></ul><br>  A Phaser object is created using one of the constructors: <br><br><pre> <code class="java hljs">Phaser() Phaser(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parties)</code> </pre><br>  The parties parameter indicates the number of parties that will perform the action phases.  The first constructor creates the Phaser object without any sides, and the barrier in this case is also ‚Äúclosed‚Äù.  The second constructor registers the number of parties transmitted to the constructor.  The barrier opens when all parties have arrived, or if the last participant is removed.  (The Phaser class still has constructors to which the Phaser parent object is passed, but we will not consider them.) <br><br>  Basic methods: <br><ul><li>  <b>int register ()</b> - registers a new member that performs the phases.  Returns the current phase number; </li><li>  <b>int getPhase ()</b> - returns the number of the current phase; </li><li>  <b>int arriveAndAwaitAdvance ()</b> - indicates that the thread has completed the execution of the phase.  The flow is suspended until all other parties have completed this phase.  The exact equivalent of <code>CyclicBarrier.await()</code> .  Returns the current phase number; </li><li>  <b>int arrive ()</b> - reports that the party has completed the phase, and returns the phase number.  When this method is called, the thread does not pause, but continues; </li><li>  <b>int arriveAndDeregister ()</b> - reports the completion of all phases by the party and removes it from registration.  Returns the current phase number; </li><li>  <b>int awaitAdvance (int phase)</b> - if phase is equal to the number of the current phase, suspends the flow that caused it until it ends.  Otherwise, it immediately returns an argument. </li></ul><img src="https://habrastorage.org/files/086/6a4/b7a/0866a4b7acdf416384d4e7372b49a34b.gif"><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Phaser.html">Official Phaser documentation.</a> <br><div class="spoiler">  <b class="spoiler_title">Phaser Case Study</b> <div class="spoiler_text">  Consider the following example.  There are five stops.  The first four of them can stand passengers and wait for the bus.  The bus leaves the park and stops at each stop for a while.  After the final stop the bus goes to the park.  We need to pick up passengers and disembark them at the right stops. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.ArrayList; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Phaser; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bus</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Phaser PHASER = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser(<span class="hljs-number"><span class="hljs-number">1</span></span>);<span class="hljs-comment"><span class="hljs-comment">//    // 0  6 -   , 1 - 5  public static void main(String[] args) throws InterruptedException { ArrayList&lt;Passenger&gt; passengers = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 5; i++) { //    if ((int) (Math.random() * 2) &gt; 0) passengers.add(new Passenger(i, i + 1));//     if ((int) (Math.random() * 2) &gt; 0) passengers.add(new Passenger(i, 5)); //     } for (int i = 0; i &lt; 7; i++) { switch (i) { case 0: System.out.println("   ."); PHASER.arrive();//  0  1  -  break; case 6: System.out.println("   ."); PHASER.arriveAndDeregister();//  ,   break; default: int currentBusStop = PHASER.getPhase(); System.out.println(" ‚Ññ " + currentBusStop); for (Passenger p : passengers) //,      if (p.departure == currentBusStop) { PHASER.register();// ,      p.start(); //   } PHASER.arriveAndAwaitAdvance();//    } } } public static class Passenger extends Thread { private int departure; private int destination; public Passenger(int departure, int destination) { this.departure = departure; this.destination = destination; System.out.println(this + "    ‚Ññ " + this.departure); } @Override public void run() { try { System.out.println(this + "   ."); while (PHASER.getPhase() &lt; destination) //      () PHASER.arriveAndAwaitAdvance(); //        Thread.sleep(1); System.out.println(this + "  ."); PHASER.arriveAndDeregister(); //     } catch (InterruptedException e) { } } @Override public String toString() { return "{" + departure + " -&gt; " + destination + '}'; } } }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of the program</b> <div class="spoiler_text">  The passenger {1 -&gt; 2} is waiting at the stop number 1 <br>  The passenger {1 -&gt; 5} is waiting at the stop number 1 <br>  The passenger {2 -&gt; 3} is waiting at the stop number 2 <br>  The passenger {2 -&gt; 5} is waiting at the stop number 2 <br>  Passenger {3 -&gt; 4} is waiting at stop number 3 <br>  The passenger {4 -&gt; 5} is waiting at the stop number 4 <br>  The passenger {4 -&gt; 5} is waiting at the stop number 4 <br>    . <br>  ‚Ññ 1 <br> {1 -&gt; 5}   . <br> {1 -&gt; 2}   . <br>  ‚Ññ 2 <br> {2 -&gt; 3}   . <br> {1 -&gt; 2}  . <br> {2 -&gt; 5}   . <br>  ‚Ññ 3 <br> {2 -&gt; 3}  . <br> {3 -&gt; 4}   . <br>  ‚Ññ 4 <br> {4 -&gt; 5}   . <br> {3 -&gt; 4}  . <br> {4 -&gt; 5}   . <br>  ‚Ññ 5 <br> {1 -&gt; 5}  . <br> {2 -&gt; 5}  . <br> {4 -&gt; 5}  . <br> {4 -&gt; 5}  . <br>    . <br></div></div><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By the way, the function of phaser can reproduce the work of CountDownLatch. </font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phaser example from CountDownLatch</font></font></b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.concurrent.Phaser; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewRace</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Phaser START = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trackLength = <span class="hljs-number"><span class="hljs-number">500000</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Car(i, (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) (Math.random() * <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">50</span></span>))).start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (START.getRegisteredParties() &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//,     Thread.sleep(100); //  .  ,  100ms Thread.sleep(100); System.out.println(" !"); START.arriveAndDeregister(); Thread.sleep(100); System.out.println("!"); START.arriveAndDeregister(); Thread.sleep(100); System.out.println("!"); START.arriveAndDeregister(); } public static class Car implements Runnable { private int carNumber; private int carSpeed; public Car(int carNumber, int carSpeed) { this.carNumber = carNumber; this.carSpeed = carSpeed; } @Override public void run() { try { System.out.printf(" ‚Ññ%d    .\n", carNumber); START.arriveAndDeregister(); START.awaitAdvance(0); Thread.sleep(trackLength / carSpeed); System.out.printf(" ‚Ññ%d !\n", carNumber); } catch (InterruptedException e) { } } } }</span></span></code> </pre> <br></div></div><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If someone came in handy, then I am very happy =) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For more information about the Phaser </font></font><a href="https://habrahabr.ru/post/117185/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can read more about synchronizers and see examples </font></font><a href="http://www.quizful.net/post/java-parallel-tools"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An excellent review of java.util.concurrent can be found </font></font><a href="https://habrahabr.ru/company/luxoft/blog/157273/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/277669/">https://habr.com/ru/post/277669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277653/index.html">Installing a Django project on a VPS (centOS 7) [For Beginners]</a></li>
<li><a href="../277655/index.html">Access MySQL data from a UWP application without using services</a></li>
<li><a href="../277657/index.html">Your cloud hosting in 5 minutes. Part 0: Virtualization</a></li>
<li><a href="../277663/index.html">What we should build LVM (principle of operation, performance, Thin Provision)</a></li>
<li><a href="../277665/index.html">Alternative to native support module in JIRA</a></li>
<li><a href="../277671/index.html">Math on the fingers: linear-quadratic controller</a></li>
<li><a href="../277673/index.html">Free Photoshop Script: Export Vector Layers from PSD to SVG</a></li>
<li><a href="../277675/index.html">Linux Mint distributions have been compromised</a></li>
<li><a href="../277677/index.html">We authenticate requests in the microservice application using nginx and JWT</a></li>
<li><a href="../277679/index.html">We write shell scripts in Python and is it possible to replace them with Bash</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>