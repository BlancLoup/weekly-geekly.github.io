<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nsynjs - JavaScript engine with synchronous streams and without callbacks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about the result of my second attempt at dealing with callbacks in JavaScript. The first attempt was described in a previo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nsynjs - JavaScript engine with synchronous streams and without callbacks</h1><div class="post__text post__text-html js-mediator-article">  In this article I will talk about the result of my second attempt at dealing with callbacks in JavaScript.  The first attempt was described in a <a href="https://habrahabr.ru/post/319094/">previous article</a> .  In the comments to it, I was prompted by some ideas that were implemented in the new project - nsynjs (next synjs). <br><br><img src="https://habrastorage.org/web/afc/796/4ca/afc7964caaaa4157b80d7d35fff1399e.jpg"><br><br>  TLDR: nsynjs is a JavaScript engine that can wait for the execution of callbacks and execute instructions sequentially. <br><a name="habracut"></a><br>  This is achieved by the fact that nsynjs breaks the code of the executable function into separate operators and expressions, wraps them into internal functions, and executes them one by one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Nsynjs allows you to write fully consistent code, like this: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(i&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) { wait(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;--      console.log(i, new Date()); i++; }</span></span></code> </pre> <br>  or such <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStats</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;-- ,      friends: dbQuery("select * from firends where user_id = "+userId).data, comments: dbQuery("select * from comments where user_id = "+userId).data, likes: dbQuery("select * from likes where user_id = "+userId).data, }; }</span></span></code> </pre> <br>  Nsynjs supports most ECMAScript 2015 constructs, including loops, conditional statements, exceptions, try-catch blocks, closures (it would be better to translate as "context variables"), and so on. <br><br>  Compared to Babel, he: <br><br><ul><li>  still easier (81kb without minimizing), </li><li>  has no dependencies </li><li>  does not require compilation </li><li>  performed much faster </li><li>  allows you to start and stop long-lived streams. </li></ul><br>  To illustrate, consider a small example of a web application that: <br><br><ol><li>  Receives a list of files via ajax request </li><li>  For each file in the list: </li><li>  Receives a file via ajax request </li><li>  Writes the contents of the file to the page. </li><li>  Wait 1 sec </li></ol><br>  A synchronous pseudo-code for this application would look like this (looking ahead, the real code is almost the same): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = ajaxGetJson(<span class="hljs-string"><span class="hljs-string">"data/index.json"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> el = ajaxGetJson(<span class="hljs-string"><span class="hljs-string">"data/"</span></span>+data[i]); progressDiv.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;"</span></span>+el+<span class="hljs-string"><span class="hljs-string">"&lt;/div&gt;"</span></span>); wait(<span class="hljs-number"><span class="hljs-number">1000</span></span>); };</code> </pre> <br>  The first thing to take care of is to identify all the asynchronous functions that we need and wrap them in a wrapper function to call them from the synchronous code in the future. <br><br>  The wrapper function should usually do the following: <br><br><ul><li>  accept a pointer to the state of the calling thread as a parameter (for example, ctx) </li><li>  call wrapped function with a callback </li><li>  return the object as a parameter of the operator return, assign the result of the callback to some property of this object </li><li>  call ctx.resume () in a callback (if there are several callbacks, then select the latest one) </li><li>  set the destructor function to be called in case of a thread interruption. </li></ul><br>  For all wrapper functions, the 'synjsHasCallback' property must be set to true. <br><br>  Create a simple wrapper for setTimeout.  Since we do not get any data from this function, the return operator is not needed here.  The result is the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wait = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, ms</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'firing timeout'</span></span>); ctx.resume(); <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;--     }, ms); }; wait.synjsHasCallback = true; // &lt;&lt;--   nsynjs,   -   </span></span></code> </pre><br>  She, in principle, will work.  But a problem may arise if the calling thread was stopped while the callback was in progress: the setTimeout function would still be called and the message printed.  To avoid this, you must also cancel the timeout when the stream is stopped.  This can be done by setting the destructor. <br><br>  The wrapper will then turn out like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wait = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, ms</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'firing timeout'</span></span>); ctx.resume(); }, ms); ctx.setDestructor(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'clear timeout'</span></span>); clearTimeout(timeoutId); }); }; wait.synjsHasCallback = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  We also need a wrapper over the jQuery library's getJSON function.  In the simplest case, it will look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ajaxGetJson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx,url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = {}; $.getJSON(url, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ res.data = data; ctx.resume(); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }; ajaxGetJson.synjsHasCallback = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  This code will only work if getJSON successfully received the data.  On error, ctx.resume () will not be called, and the calling thread will never resume.  To handle errors, the code must be modified code like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ajaxGetJson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx,url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ex; $.getJSON(url, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ res.data = data; <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;--   ,   }) .fail(function(e) { ex = e; // &lt;&lt;--   ,   }) .always(function() { ctx.resume(ex); // &lt;&lt;--      , //        }); return res; }; ajaxGetJson.synjsHasCallback = true;</span></span></code> </pre><br>  To getJSON to forcibly stop when the calling thread stops, you can add a destructor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ajaxGetJson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx,url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ex; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ajax = $.getJSON(url, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ res.data = data; <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;--   ,   }) .fail(function(e) { ex = e; // &lt;&lt;--   ,   }) .always(function() { ctx.resume(ex); // &lt;&lt;--      , //        }); ctx.setDestructor(function () { ajax.abort(); }); return res; };</span></span></code> </pre><br>  When the wrappers are ready, we can write the application logic itself: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> log = $(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>); log.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;Started...&lt;/div&gt;"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       synjsCtx,   //       var data = ajaxGetJson(synjsCtx, "data/index.json").data; log.append("&lt;div&gt;Length: "+data.length+"&lt;/div&gt;"); for(var i in data) { log.append("&lt;div&gt;"+i+", "+data[i]+"&lt;/div&gt;"); var el = ajaxGetJson(synjsCtx, "data/"+data[i]); log.append("&lt;div&gt;"+el.data.descr+","+"&lt;/div&gt;"); wait(synjsCtx,1000); } log.append('Done'); }</span></span></code> </pre><br>  Since the ajaxGetJson function may throw an exception in some cases, it makes sense to enclose it in a try-catch block: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> log = $(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>); log.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;Started...&lt;/div&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = ajaxGetJson(synjsCtx, <span class="hljs-string"><span class="hljs-string">"data/index.json"</span></span>).data; log.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;Length: "</span></span>+data.length+<span class="hljs-string"><span class="hljs-string">"&lt;/div&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data) { log.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;"</span></span>+i+<span class="hljs-string"><span class="hljs-string">", "</span></span>+data[i]+<span class="hljs-string"><span class="hljs-string">"&lt;/div&gt;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> el = ajaxGetJson(synjsCtx, <span class="hljs-string"><span class="hljs-string">"data/"</span></span>+data[i]); log.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;"</span></span>+el.data.descr+<span class="hljs-string"><span class="hljs-string">","</span></span>+<span class="hljs-string"><span class="hljs-string">"&lt;/div&gt;"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ex) { log.append(<span class="hljs-string"><span class="hljs-string">"&lt;div&gt;Error: "</span></span>+ex.statusText+<span class="hljs-string"><span class="hljs-string">"&lt;/div&gt;"</span></span>); } wait(synjsCtx,<span class="hljs-number"><span class="hljs-number">1000</span></span>); } log.append(<span class="hljs-string"><span class="hljs-string">'Done'</span></span>); }</code> </pre><br>  The last step is to call our synchronous function through the nsynjs engine: <br><br><pre> <code class="javascript hljs">nsynjs.run(process,{},<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'process() done.'</span></span>); });</code> </pre><br>  nsynjs.run accepts the following parameters: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ctx = nsynjs.run(myFunct,obj, param1, param2 [, param3 etc], callback)</code> </pre> <br><ul><li>  myFunct: a pointer to the function that you want to perform in synchronous mode </li><li>  obj: an object that will be accessible through this in the myFunct function </li><li>  param1, param2, etc - parameters for myFunct </li><li>  callback: a callback to be called when myFunct completes. </li></ul><br>  Return value: The context of the stream state. <br><br><h2>  Under the hood </h2><br>  When you call a function through nsynjs, the engine checks for the presence and, if necessary, creates the synjsBin property of this function.  This property stores a tree structure equivalent to the compiled function code.  Further, the engine creates a stream state context in which local variables, stacks, program counters, and other information necessary for stopping / resuming execution are stored.  After that, the main loop is started, in which the program counter sequentially iterates over the synjsBin elements, and executes them using the state context as a storage. <br><br>  When executing a synchronous code that contains calls to other functions, nsynjs recognizes three types of called functions: <br><br><ul><li>  synchronous </li><li>  wrappers over cabbies </li><li>  native. </li></ul><br>  The type of the function is determined in runtime by analyzing the following properties: <br><br><ul><li>  if the function pointer has the synjsBin property, then the function will be executed via nsynjs in synchronous mode </li><li>  if the function pointer has a synjsHasCallback property, then this is a wrapper function, so nsynjs will stop execution on it.  The wrapper function must itself take care of resuming the calling synchronous stream by calling ctx.resume () in the flask. </li><li>  All other functions are considered native, and return the result immediately. </li></ul><br><h2>  Performance </h2><br>  When parsing, the nsynjs engine tries to analyze and optimize the code elements of the original function.  For example, consider the cycle: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;arr.length; i++) { res += arr[i]; }</code> </pre><br>  This cycle will be optimized and compiled into one internal function that will be executed almost as fast as the native code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(state.localVars.i=<span class="hljs-number"><span class="hljs-number">0</span></span>; state.localVars.i&lt;arr.length; state.localVars.i++) { state.localVars.res += state.localVars.arr[state.localVars.i]; } }</code> </pre><br>  However, if there are function calls in the code element, as well as the continue, break, and return statements, the optimization for them, as well as for all parent elements, will not be executed. <br><br>  The impossibility of optimizing expressions with function calls is due to the fact that a pointer to a function, and therefore its type, can be calculated only during execution. <br><br>  For example operator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.E</code> </pre> <br>  will be optimized in one function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state,prev, v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.localVars.n = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.E }</code> </pre> <br>  If the operator has a function call, then nsynjs cannot know the type of the function being called in advance: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()</code> </pre> <br>  Therefore, the entire operator will be executed in steps: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span> } .. this.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state,prev</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.random } .. this.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state,prev</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev() } .. this.execute = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state,prev, v</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state.localVars.n = v }</code> </pre><br><h2>  Links </h2><br>  ‚Üí <a href="https://github.com/amaksr/nsynjs">GitHub repository</a> <br>  ‚Üí <a href="https://github.com/amaksr/nsynjs/tree/master/examples">Examples</a> <br>  ‚Üí <a href="https://github.com/amaksr/nsynjs/tree/master/test">Tests</a> <br>  ‚Üí <a href="https://www.npmjs.com/package/nsynjs">NPM</a> </div><p>Source: <a href="https://habr.com/ru/post/329310/">https://habr.com/ru/post/329310/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329300/index.html">A simple algorithm for checking victory in a cross on a non-standard field</a></li>
<li><a href="../329302/index.html">Incredible javascript - tricks, misunderstandings and unusual features</a></li>
<li><a href="../329304/index.html">Google I / O 2017: my impressions and comments of colleagues</a></li>
<li><a href="../329306/index.html">MongoDB Security Guide</a></li>
<li><a href="../329308/index.html">BGP route leaks</a></li>
<li><a href="../329312/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 24</a></li>
<li><a href="../329314/index.html">30,000 downloads of ReactOS v.0.4.5 in 5 days</a></li>
<li><a href="../329316/index.html">Do I need a support engineer to code it myself? (and other interesting questions and answers)</a></li>
<li><a href="../329318/index.html">Apache Ignite 2.0 - Machine Learning, a new data storage model, DDL</a></li>
<li><a href="../329320/index.html">We catch user input on the console in Google Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>