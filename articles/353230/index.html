<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>From JavaScript to Rust and back: the story about wasm-bindgen</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have already seen how quickly WebAssembly compiles , speeds up the js library and generates more compact binaries . We even have a general idea of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>From JavaScript to Rust and back: the story about wasm-bindgen</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/us/cp/kguscp_kr5s-y3wesrilgm2kl3q.png"></div><br><p>  We have already seen how <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">quickly</a> WebAssembly <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">compiles</a> , <a href="https://hacks.mozilla.org/2018/01/oxidizing-source-maps-with-rust-and-webassembly/">speeds up the js library</a> and generates <a href="https://hacks.mozilla.org/2018/01/shrinking-webassembly-and-javascript-code-sizes-in-emscripten/">more compact binaries</a> .  We even have a <a href="https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/">general idea of</a> how to establish interaction not only between the Rust and JavaScript communities, but also with communities of other languages.  In the <a href="https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/">last article</a> we mentioned the special tool wasm-bindgen and now I would like to dwell on it in more detail. </p><a name="habracut"></a><br><p>  Currently, <a href="https://webassembly.github.io/spec/">the WebAssembly specification</a> describes only four data types: two integer and two floating point.  However, most of the time JS and Rust developers use a much richer type system.  For example, JS developers interact with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document">document</a> object to add or modify HTML nodes, while Rust developers work with types such as <a href="https://doc.rust-lang.org/std/result/enum.Result.html">Result</a> for error handling, and almost all developers work with strings. </p><br><p>  To be limited only to the types that WebAssembly defines would be too inconvenient, and here wasm-bindgen comes to the rescue.  The main task of wasm-bindgen is to provide a bridge between systems of types Rust and JS.  It allows the JS functions to call the Rust API by passing ordinary strings or the Rust functions to catch the exception from the JS.  wasm-bindgen compensates for type mismatches and enables efficient and simple use of WebAssembly functions from JavaScript and back. </p><br><p>  You can find a more detailed description of the wasm-bindgen project on our <a href="">README</a> .  First, let's take a simple example of how to use wasm-bindgen, and then see how you can still use it. </p><br><h2 id="privet-mir">  Hello World! </h2><br><p>  Eternal classics.  One of the best ways to try a new tool is to study its variation of the message ‚ÄúHello world.‚Äù  In this case, we‚Äôll look at <a href="https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/hello_world">an example</a> that does exactly that ‚Äî it displays a dialog box that says "Hello World". </p><br><p> The goal here is simple, we want to create a Rust function that, when given a name, displays a dialog box that says <code>Hello, ${name}!</code>  .  In JavaScript, we would describe it like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">`Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">!`</span></span>); }</code> </pre> <br><p>  However, we want to write this function on Rust.  In order for this to work, we will need the following steps. </p><br><ul><li>  JavaScript should call the WebAssembly module, which exports the greet function. </li><li>  The Rust function takes a string that will contain the name as an argument. </li><li>  Inside the Rust function, we create a new line and interpolate the transferred name into it. </li><li>  And finally, Rust will invoke the JavaScript alert function using the generated string as an argument. </li></ul><br><p>  First, create a new Rust project: </p><br><pre> <code class="bash hljs">cargo new wasm-greet --lib</code> </pre> <br><p>  This command will create a folder wasm-greet, in which we will work with you.  The next step is to add the following information to our <code>Cargo.toml</code> (analog <code>package.json</code> for Rust): </p><br><pre> <code class="hljs scala">[lib] crate-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span></span>= [<span class="hljs-string"><span class="hljs-string">"cdylib"</span></span>] [dependencies] wasm-bindgen = <span class="hljs-string"><span class="hljs-string">"0.2"</span></span></code> </pre> <br><p>  We will skip the contents of the lib section for now, and in the <code>dependencies</code> section we indicate the dependence of our project on the <a href="https://crates.io/crates/wasm-bindgen">wasm-bindgen package</a> .  This package includes everything you need to use wasm-bindgen in our project. </p><br><p>  And now let's add some code!  Replace the contents of <code>src/lib.rs</code> following code: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![feature(proc_macro, wasm_custom_section, wasm_import_module)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> wasm_bindgen; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> wasm_bindgen::prelude::*; <span class="hljs-meta"><span class="hljs-meta">#[wasm_bindgen]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alert</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>); } <span class="hljs-meta"><span class="hljs-meta">#[wasm_bindgen]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { alert(&amp;<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {}!"</span></span>, name)); }</code> </pre> <br><p>  If you are not familiar with Rust, the example above may seem a bit verbose, but do not worry.  The project wasm-bindgen is constantly being improved and I am sure that the need for such a detailed description will be eliminated in the future.  The most important part here is the <code>#[wasm_bindgen]</code> attribute.  This is an abstract in Rust, which says that this function should be wrapped into another function if necessary.  Both of our functions (both importing the <code>alert</code> function and exporting the <code>greet</code> function) have this attribute.  A little later, we look under the hood and see what happens there. </p><br><p>  But first, let's compile our wasm code and open it in a browser: </p><br><pre> <code class="bash hljs">$ rustup target add wasm32-unknown-unknown --toolchain nightly <span class="hljs-comment"><span class="hljs-comment">#     $ cargo +nightly build --target wasm32-unknown-unknown</span></span></code> </pre> <br><p>  Upon completion, we will get a wasm file that will be located <code>target/wasm32-unknown-unknown/debug/wasm_greet.wasm</code> .  If we use something like <a href="https://github.com/WebAssembly/wabt">wasm2wat</a> and look inside this file, its contents may seem a bit intimidating.  It turns out that the wasm file is not yet ready for use from JS.  For this we need one more step: </p><br><pre> <code class="bash hljs">$ cargo install wasm-bindgen-cli <span class="hljs-comment"><span class="hljs-comment">#     $ wasm-bindgen target/wasm32-unknown-unknown/debug/wasm_greet.wasm --out-dir .</span></span></code> </pre> <br><p>  Just at this step all the magic happens.  The wasm-bindgen command processes the wasm file and makes it ready for use.  A little later, we will look at what it means to be ‚Äúready for use‚Äù, but for now it suffices to say that if we import the newly created <code>wasm_greet.js</code> module, then there will be a <code>greet</code> function, which is declared in Rust. </p><br><p>  Now we can use the packer and create an HTML page on which our code will be executed.  At the time of this writing, only <a href="https://medium.com/webpack/webpack-4-released-today-6cdb994702d4">Webpack 4.0</a> has enough WebAssembly support to work out of the box (however, at the moment there is a problem with the <a href="">Chrome</a> browser).  Of course, over time, more and more packers will add support for WebAssembly.  I will not go into details.  You can see a sample configuration for webpack in the <a href="https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/hello_world">repository</a> .  If we look at the contents of our JS file, we will see the following: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rust = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">"./wasm_greet"</span></span>); rust.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> m.greet(<span class="hljs-string"><span class="hljs-string">"World!"</span></span>));</code> </pre> <br><p>  ‚Ä¶ and that is all.  Having opened our page in the browser we will see a dialog box with the words <code>Hello, World!</code>  which is created in Rust. </p><br><h2 id="kak-rabotaet-wasm-bindgen">  How wasm-bindgen works </h2><br><p>  Whew, that was pretty big <code>Hello, World!</code>  .  Let's look a little at what is going on under the hood and how this tool works. </p><br><p>  One of the most important aspects of the wasm-bindgen is that the integration is based on the fundamental concept that the wasm module is just another type of ES module.  In the example above, we just wanted to create an ES module with the following signature (TypeScript): </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br><p>  WebAssembly does not have the ability to do this (remember that currently wasm only supports numbers), so we use wasm-bindgen to fill in the blanks.  In the last step of the last example, when we launched the <code>wasm-bindgen</code> it created not only the <code>wasm_greet.js</code> file, but also the <code>wasm_greet_bg.wasm</code> .  The first is our JS interface, which allows us to call the Rust code.  And the <code>*_bg.wasm</code> file contains the implementation and all the compiled code. </p><br><p>  When we import the <code>./wasm_greet</code> module, we get the Rust code that we would like to call from JS, but at this stage we are not able to do it natively.  Now that we have reviewed the integration process, let's look at the execution of this code. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rust = <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">"./wasm_greet"</span></span>); rust.then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> m.greet(<span class="hljs-string"><span class="hljs-string">"World!"</span></span>));</code> </pre> <br><p>  Here we asynchronously import our interface, wait until it is ready (download and compile the wasm module), and call the <code>greet</code> function. </p><br><blockquote>  Note that asynchronous loading is a <a href="https://github.com/webpack/webpack/issues/6615">Webpack</a> requirement, but this may not always be possible and can be implemented differently in other packers. </blockquote><p>  If we look at the contents of the <code>wasm_greet.js</code> file that was generated by <code>wasm-bindgen</code> , we will see something like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> wasm <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./wasm_greet_bg'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... export function greet(arg0) { const [ptr0, len0] = passStringToWasm(arg0); try { const ret = wasm.greet(ptr0, len0); return ret; } finally { wasm.__wbindgen_free(ptr0, len0); } } export function __wbg_f_alert_alert_n(ptr0, len0) { // ... }</span></span></code> </pre> <br><blockquote>  Note.  This code is not optimized and automatically generated and it is not always beautiful or small.  In the process of optimization during linking, the release assembly in Rust and after passing through the minicator, it will be much smaller. </blockquote><p>  Here we see how wasm-bindgen generated the <code>greet</code> function for us.  Under the hood, it still calls the function <code>greet</code> and wasm of the module, but now it is called not with a string, but with passing the pointer and the length as arguments.  More information about the <code>passStringToWasm</code> function can be found in the article from <a href="https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/">Lin Clark</a> .  If we had not used wasm-bindgen, we would have to write all this code on our own.  We‚Äôll go back to the <code>__wbg_f_alert_alert_n</code> function a little later. </p><br><p>  Having gone down on level below, we will find the following interesting point - the <code>greet</code> function in WebAssembly.  Let's take a look at the code that the Rust compiler sees.  Note that, like the JS code that is generated above, you did not write with your hands the exported <code>greet</code> symbol.  wasm-bindgen generated everything you need on your own, namely: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(name: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { alert(&amp;<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {}!"</span></span>, name)); } <span class="hljs-meta"><span class="hljs-meta">#[export_name = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"greet"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__wasm_bindgen_generated_greet</span></span></span></span>(arg0_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, arg0_len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arg0 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { ::std::slice::from_raw_parts(arg0_ptr <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, arg0_len) } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arg0 = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { ::std::<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>::from_utf8_unchecked(arg0) }; greet(arg0); }</code> </pre> <br><p>  Here we see our <code>greet</code> function, as well as the function <code>greet</code> , which is additionally generated using the <code>#[wasm_bingen]</code> <code>__wasm_bindgen_generated_greet</code> .  This is the exported function (this is indicated by the <code>#[export_name]</code> attribute and the <code>extern</code> keyword), which accepts a pointer and a string length.  It then converts this pair to <a href="https://doc.rust-lang.org/std/primitive.str.html">&amp; str</a> (string to Rust) and passes it to our <code>greet</code> function. </p><br><p>  In other words, wasm-bindgen generates two wrappers: one in JavaScript, which converts types from JS to wasm and one to Rust, which accepts types of wasm and converts to Rust. </p><br><p>  Well, let's look at the last set of wrappers for the <code>alert</code> function.  The <code>greet</code> function in Rust uses the standard <a href="https://doc.rust-lang.org/std/macro.format.html">format</a> macro <a href="https://doc.rust-lang.org/std/macro.format.html">!</a>  to create a new line and then passes it to the <code>alert</code> function.  Remember, when we declared the <code>alert</code> function, we used the <code>#[wasm_bindgen]</code> attribute, now let's see what the Rust compiler sees: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alert</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-meta"><span class="hljs-meta">#[wasm_import_module = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"__wbindgen_placeholder__"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__wbg_f_alert_alert_n</span></span></span></span>(s_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, s_len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s_ptr = s.as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s_len = s.len(); __wbg_f_alert_alert_n(s_ptr, s_len); } }</code> </pre> <br><p>  This is not exactly what we wrote, but we can clearly see what is happening here.  The <code>alert</code> function is actually a thin wrapper that takes the string <a href="https://doc.rust-lang.org/std/primitive.str.html">&amp; str</a> and then converts it into numbers that were understandable for wasm.  Then the function <code>__wbg_f_alert_alert_n</code> is <code>__wbg_f_alert_alert_n</code> and there is a curious part - this is the <code>#[wasm_import_module]</code> attribute <code>#[wasm_import_module]</code> . <br>  In order to import a function into WebAssembly, you need a module that contains it.  And since wasm-bindgen is built on ES modules, the import of such a function from wasm will be interpreted as import from the ES module.  The <code>__wbindgen_placeholder__</code> module actually does not exist, this term indicates that this import should be processed by wasm-bindgen and a wrapper for JS generated. </p><br><p>  And finally, we get our last piece of the puzzle - a generated JS file that contains: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__wbg_f_alert_alert_n</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ptr0, len0</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arg0 = getStringFromWasm(ptr0, len0); alert(arg0) }</code> </pre> <br><p>  As it turned out, a lot of things are happening under the hood and we have come a long way to call the JS function in the browser.  But don't worry, the key aspect of the wasm-bindgen is that it‚Äôs all hidden.  You can simply write Rust code with several attributes <code>#[wasm_bindgen]</code> here and there.  And then your JS code can use it as if it were another JavaScript module. </p><br><h2 id="na-chto-esche-sposoben-wasm-bindgen">  What else wasm-bindgen capable of? </h2><br><p>  The project wasm-bindgen is very ambitious, covers a large area and at the moment I do not have enough time to describe everything.  A good way to see it in action is to familiarize yourself with our <a href="https://github.com/alexcrichton/wasm-bindgen/tree/master/examples">examples</a> , from simple Hello World !, to <a href="https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/dom">manipulating the DOM nodes of a tree</a> from Rust. </p><br><p>  In general, the main features of the wasm-bindgen are: </p><br><ul><li>  Importing JS structures, functions, objects, etc.  for use in wasm.  You can quite naturally call JS methods on structures and access properties from Rust after all the <code>#[wasm_bindgen]</code> attributes are <code>#[wasm_bindgen]</code> </li><li>  Export structures and functions of Rust for use in JS.  Instead of working with numbers only, you can export a structure from Rust, which will turn into a JS class.  You can transfer not just numbers, but also structures there and back.  The following <a href="https://github.com/alexcrichton/wasm-bindgen/tree/master/examples/smorgasboard">example</a> will give you an idea of ‚Äã‚Äãthe possible interoperability. </li><li>  And other possibilities, like using global functions (such as <code>alert</code> ), to intercept exceptions from JS, using the Result data type in Rust and the generalized way of simulating the preservation of values ‚Äã‚Äãfrom JS in a Rust program. </li></ul><br><p>  If you are interested in learning about additional features, follow <a href="https://github.com/alexcrichton/wasm-bindgen/issues">our tracker</a> . </p><br><h2 id="chto-dalshe-dlya-wasm-bindgen">  What next for wasm-bindgen? </h2><br><p>  Before completion, I would like to tell you a little about the future of the wasm-bindgen project as this is one of the most exciting topics. </p><br><h3 id="podderzhka-drugih-yazykov-krome-rust">  Support for languages ‚Äã‚Äãother than Rust </h3><br><p>  From the very first day, the wasm-bindgen was designed with an eye to the fact that it can be used from many languages.  While Rust is the only supported language so far, the tool will allow you to add C / C ++ in the future as well.  The <code>#[wasm_bindgen]</code> creates an additional section in the <code>.wasm</code> file, which the parsit will then remove and <code>wasm-bindgen</code> .  This section describes which bindings need to be generated in JS and their interface.  There is nothing Rust-specific in this section, so a plug-in with C / C ++ compiler can also create it, so that it will be possible to use <code>wasm-bindgen</code> . </p><br><p>  For me, this is the most exciting moment because I believe that this is what will allow tools like <code>wasm-bindgen</code> to become the standard for interoperating WebAssembly and JS.  I hope that the ability to do without unnecessary configuration code will be an advantage for all languages ‚Äã‚Äãthat can be compiled into WebAssembly. </p><br><h3 id="avtomaticheskaya-generaciya-bindingov-k-js">  Automatic generation of bindings to JS </h3><br><p>  At the moment, one of the drawbacks when importing JS functions with <code>#[wasm_bindgen]</code> is that you need to describe all the functions yourself and make sure that no errors occur.  At times, this process can be quite tedious (and be a source of error) and it requires automation. </p><br><p>  All Web APIs are specified and described in <a href="https://heycam.github.io/webidl/">WebIDL</a> and it should be quite possible to generate all the bindings <a href="https://github.com/alexcrichton/wasm-bindgen/issues/42">automatically from WebIDL</a> .  This means that you will not need to define the <code>alert</code> function as we did in the example above, instead you could write something like this: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[wasm_bindgen]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { webapi::alert(&amp;<span class="hljs-built_in"><span class="hljs-built_in">format!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {}!"</span></span>, s)); }</code> </pre> <br><p>  In this case, the <code>webapi</code> package could be automatically generated from the descriptions of the WebIDL API and this would guarantee no errors. </p><br><p>  We can develop this idea even further and use the impressive work of the TypeScript community and <a href="https://github.com/alexcrichton/wasm-bindgen/issues/18">generate binders from TypeScript as well</a> .  This will automatically use any package with npm that has TypeScript support. </p><br><h3 id="bolee-bystrye-operacii-s-dom-chem-v-js">  Faster DOM operations than JS </h3><br><p>  And last but not least, on the horizon of wasm-bindgen, super fast manipulations with DOM are the holy grail of many JavaScript frameworks.  Today, all function calls for working with DOM go through costly transformations when moving from JavaScript to C ++ engines.  With WebAssembly, these conversions may become optional.  It is known that the WebAssembly type system ... is! </p><br><p>  From the very first day, the generation of the <code>wasm-bindgen</code> code has <code>wasm-bindgen</code> designed with the aim of supporting <a href="https://github.com/WebAssembly/host-bindings">hostings to the host</a> .  As soon as this function appears in WebAssembly, we will be able to directly use the imported functions without the wrappers that wasm-bindgen generates.  Moreover, it will allow JS engines to aggressively optimize manipulations with DOM from WebAssembly, since all interfaces will be strongly typed and there will no longer be any need to validate them.  And in this case, wasm-bindgen will not only make it easier to work with different types of data, but also provide the best of its kind performance when working with DOM. </p><br><h2 id="podvodya-itogi">  Summing up </h2><br><p>  I find working with WebAssembly incredibly interesting, not only because of the community, but also because of how fast it is evolving.  The project wasm-bindgen has a bright future.  It not only provides simple interoperability between JS and Rust, but also in the long term will open up new opportunities as WebAssembly develops. </p><br><p>  Try <a href="https://github.com/alexcrichton/wasm-bindgen">wasm-bindgen</a> , create a <a href="https://github.com/alexcrichton/wasm-bindgen/issues">request for a new function</a> , and <a href="http://fitzgeraldnick.com/2018/02/27/wasm-domain-working-group.html">stay in touch</a> with Rust and WebAssembly. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/353230/">https://habr.com/ru/post/353230/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353216/index.html">Improve performance review</a></li>
<li><a href="../353218/index.html">Online Hackathon: creating apps for SharePoint Online</a></li>
<li><a href="../353220/index.html">Ethical hacking: how to make money, not problems with the law</a></li>
<li><a href="../353226/index.html">Fourth: Redmadrobot developers winter internship</a></li>
<li><a href="../353228/index.html">Startup day (January-March 2018)</a></li>
<li><a href="../353232/index.html">Generation of site pages by means of service workers</a></li>
<li><a href="../353234/index.html">Flask Mega-Tutorial, Part XIX: Deploying Based on Docker Containers</a></li>
<li><a href="../353236/index.html">The history of gaming analytics platforms</a></li>
<li><a href="../353238/index.html">Docker. Start</a></li>
<li><a href="../353246/index.html">We invite you to a lecture evening on game design on April 18th at VSBI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>