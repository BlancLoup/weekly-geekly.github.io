<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Networks for the smallest. Part nine. Multicast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All issues  8.1. Networks for the smallest. Micro Issue number 3. iBGP 
 8. Networks for the smallest. Part Eight BGP and IP SLA 
 7. Networks for the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Networks for the smallest. Part nine. Multicast</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">All issues</b> <div class="spoiler_text">  <a href="http://linkmeup.ru/blog/65.html">8.1.</a>  <a href="http://linkmeup.ru/blog/65.html">Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/65.html">Micro Issue number 3.</a>  <a href="http://linkmeup.ru/blog/65.html">iBGP</a> <br>  <a href="http://linkmeup.ru/blog/65.html">8. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/65.html">Part Eight</a>  <a href="http://linkmeup.ru/blog/65.html">BGP and IP SLA</a> <br>  <a href="http://linkmeup.ru/blog/50.html">7. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/50.html">Part Seven.</a>  <a href="http://linkmeup.ru/blog/50.html">VPN</a> <br>  <a href="http://linkmeup.ru/blog/33.html">6. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/33.html">Part six.</a>  <a href="http://linkmeup.ru/blog/33.html">Dynamic routing</a> <br>  <a href="http://linkmeup.ru/blog/16.html">5. Networks for the smallest: Part Five.</a>  <a href="http://linkmeup.ru/blog/16.html">NAT and ACL</a> <br>  <a href="http://linkmeup.ru/blog/15.html">4. Networks for the smallest: Part Four.</a>  <a href="http://linkmeup.ru/blog/15.html">STP</a> <br>  <a href="http://linkmeup.ru/blog/14.html">3. Networks for the smallest: Part Three.</a>  <a href="http://linkmeup.ru/blog/14.html">Static routing</a> <br>  <a href="http://linkmeup.ru/blog/13.html">2. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/13.html">Part two.</a>  <a href="http://linkmeup.ru/blog/13.html">Switching</a> <br>  <a href="http://linkmeup.ru/blog/12.html">1. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/12.html">Part one.</a>  <a href="http://linkmeup.ru/blog/12.html">Connection to the equipment cisco</a> <br>  <a href="http://linkmeup.ru/blog/11.html">0. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/11.html">Part zero.</a>  <a href="http://linkmeup.ru/blog/11.html">Planning</a> <br></div></div><br>  Our speculative provider linkmeup matures and grows over quietly with all the services of ordinary telecom operators.  Now we have grown to IPTV. <br>  This implies the need to configure multicast routing and first of all an understanding of what multicast is all about. <br>  This is the first deviation from the familiar IP-network principles.  Still, the multicast paradigm is fundamentally different from the warm tube unicast. <br>  It may even be said that this somewhat challenges the flexibility of your mind in understanding new approaches. <br><br>  This article will focus on the following: <br><ul><li>  <a href="https://habr.com/ru/post/217585/">General understanding of Multicast</a> </li><li>  <a href="https://habr.com/ru/post/217585/">IGMP protocol</a> </li><li>  <a href="https://habr.com/ru/post/217585/">PIM protocol</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">PIM Dense Mode</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">Pim Sparse Mode</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">SPT Switchover - RPT-SPT Switching</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">DR, Assert, Forwarder</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">Automatic RP selection</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">SSM</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">BIDIR PIM</a> </li><li>  <a href="https://habr.com/ru/post/217585/">Multicast channel level</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">IGMP-Snooping</a> </li><li>  &gt;&gt;&gt; <a href="https://habr.com/ru/post/217585/">MVR</a> </li></ul><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/87e/3e6/372/87e3e6372d794e4676df8493addb0632.jpg" title="Multicast"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  Traditional video tutorial: <br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/uYnC6yU6Apo%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253&amp;usg=ALkJrhgwQ1ZqY0C-KVWVW5u4ZLkyHR0IDw" frameborder="0" allowfullscreen=""></iframe><br><br><blockquote>  At the dawn of my development as an engineer, the topic of multicast scared me incredibly, and I connect this with the psychotrauma of my first experience with him. <br>  ‚Äú <i>So, Marat, urgently, you need to forward the video stream to our new building in the city center before noon - the provider will give it to us here on the second floor</i> ‚Äù - I heard one wonderful morning.  All that I knew about multicaste then is that the sender is one, there are many recipients, and, it seems, the IGMP protocol is somehow involved there. <br><br>  As a result, before noon we tried to run the whole thing - I forwarding the most ordinary VLAN from the entry point to the exit point.  But the signal was unstable - the picture froze, collapsed, interrupted.  I was in a panic trying to figure out what could be done with IGMP at all, tinked, tacked, turned on multicast routing, IGMP-snooping, checked the delay and loss a thousand times - nothing helped.  And then suddenly it all worked.  Of course, stable, trouble-free. <br><br>  This gave me a vaccination against multicast, and for a long time I did not show any interest in it. <br><br>  Much later, I came to the following rule: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/5d4/42e/a63/5d442ea63e4f0f95c0db7d67c3a50acf.png" width="239" height="300" title="keep kalm and trust me"></a> <br>  And now I understand from the height of the crashed cases that there could not have been any problems with setting up the network part - the final equipment was buggy. </blockquote><br>  Keep calm and trust me.  After this article, such things will not frighten you. <br><br><a name="Multicast_Basics"></a><br><h1>  General understanding of Multicast </h1><br>  As you know, there are the following types of traffic: <br>  <b>Unicast</b> - unicast - one sender, one recipient.  ( <i>Example: HTTP page request from the WEB server</i> ). <br>  <b>Broadcast</b> ‚Äî broadcast ‚Äî one sender, recipients ‚Äî all devices in the broadcast segment.  ( <i>Example: ARP request</i> ). <br>  <b>Multicast</b> - multicast - one sender, many recipients.  ( <i>Example: IPTV</i> ). <br>  <b>Anycast</b> - unicast to the nearest host - one sender, there are many recipients in general, but in fact the data is sent only to one.  ( <i>Example: Anycast DNS</i> ). <br><hr><br><br>  Since we decided to talk about multicaste, then perhaps we will begin this paragraph with the question of where and how it is used. <br><br>  The first thing that comes to mind is television (IPTV) - one source server sends traffic that many clients want to receive at once.  This defines the term itself - <b>multicast</b> - multicast.  That is, if Broadcast already known to you means broadcasting to everyone, multicast means broadcasting to a specific group. <br><br>  The second application is, for example, replication of the operating system on many computers at once.  This means downloading large amounts of data from a single server. <br><br>  Possible scenarios: audio and video conferencing (one says - everyone is listening), e-commerce, auctions, exchanges.  But this is in theory, but in practice rarely there is still used multicast. <br><br>  Another use is for protocol service messages.  For example, OSPF in its broadcast domain sends its messages to the addresses 224.0.0.5 and 224.0.0.6.  And they will be processed only by those nodes on which OSPF is running. <br><br>  We formulate two basic principles of multicast distribution: <br><ol><li>  The sender sends only one copy of traffic, regardless of the number of recipients. </li><li>  Traffic is received only by those who are really interested in it. </li></ol><br><hr><br>  In this article for practice, we will take IPTV, as the most obvious example. <br><br><h2>  Example I </h2><br>  Let's start with the simplest case: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2b/eb2/f24/f2beb2f248cac323ba039dab9fe2f84c.png"><br><br>  The source server is configured to broadcast to the group 224.2.2.4 - this means that the server sends traffic to the IP address 224.2.2.4.  On the client, the video player is configured to accept a stream of group 224.2.2.4. <br><blockquote>  At the same time, note that the client and the server do not have to have addresses from the same subnet and ping each other - it is enough that they are in the same broadcast domain. </blockquote><br>  The multicast stream just flows from the server, and the client simply accepts it.  You can try it right in your workplace by connecting two computers with a patchcord and running, for example, VLC. <br><br>  It should be noted that in the multicast there is no alarm from the source, they say, <i>"Hello, I am the Source, do not need a little multicast?"</i> . <br>  The source server simply starts broadcasting multicast packets to its interface.  In our example, they go directly to the client and he, in fact, immediately takes them. <br>  If you catch packets on this link, you will see that multicast traffic is nothing but a sea of ‚Äã‚ÄãUDP packets. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c81/5f8/458/c815f845854c18869a5eb52af5968559.png" title="multicast dump"><br><br>  Multicast is not tied to any particular protocol.  In fact, everything that defines it is addresses.  However, if we talk about its application, then in the absolute majority of cases it is used exactly UDP.  This is easily explained by the fact that usually via multicast data is transmitted that is needed here and now.  For example, video.  If a piece of the frame is lost, and the sender will try to send it again, as it happens in TCP, then most likely this piece will be late, and where to show it then?  The train left.  Exactly the same with sound. <br>  Accordingly, it is not necessary to establish a connection, so TCP is useless here. <br><br>  What is so strikingly different from the unicast multicast?  I think you already have a guess.  And you are probably right. <br><br>  Normally, we have 1 recipient and 1 sender - each of them has one unique IP address.  The sender knows exactly where to send the packet and puts this address in the IP header.  Each intermediate node, due to its routing table, knows exactly where to forward the packet.  Unicast traffic between two nodes passes freely through the network.  But the problem is that in the normal package, only one IP address of the recipient is indicated. <br>  What if the same traffic has multiple recipients?  In principle, it is possible to extend the unicast approach and, in such a situation, send a copy of the packet to each client.  Customers will not notice the difference - even though it is one, even though there are a thousand of them, but the difference will be clearly visible on your data transmission channels. <br><img src="https://habrastorage.org/getpro/habr/post_images/14d/13b/475/14d13b475ace942ea85db5380968931d.png" title="Unicast Multicast relation graph of uniast and multicast traffic"><br>  Suppose we are transmitting one SD channel from a multicast server.  Let him use 2 MB / s.  There are 30 such channels in total, and each channel is watched by 20 people at a time.  Total is 2 MB / s * 30 channels * 20 people = 1200 MB / s or 1.2 Gb / s only on TV in the case of unicast.  But there are still HD channels, where you can safely multiply this figure by 2. And where is the place for torrents? <br><br>  That is why the block of <b>class D</b> addresses was embedded in IPv4 <b>: 224.0.0.0/4</b> (224.0.0.0394.255.255.255).  Addresses in this range define a multicast group.  One address is one group, usually it is denoted by the letter " <b>G</b> ". <br>  That is, saying that the client is connected to the group 224.2.2.4, we mean that it receives multicast traffic with the destination address 224.2.2.4. <br><br><h2>  Example II </h2><br>  Add a switch to the scheme and a few more clients: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/05a/365/12f/05a36512f3b4eeb9faefd06eec4f32e5.png"><br><br>  The multicast server still broadcasts to the group 224.2.2.4.  On the switch, all 4 ports must be in the same VLAN.  Traffic arrives at the switch and by default is sent to all ports of a single VLAN.  So all customers receive this traffic.  They have the same group address of 224.2.2.4 on everyone in the video player. <br>  Actually, all these devices become members of this multicast group.  Membership in it is dynamic: anyone, at any time, can enter and exit from it. <br><blockquote>  In this situation, traffic will be received even by those who, in general, did not want this, that is, neither the player nor anything else is running on it.  But only if it is in the same VLAN.  <a href="https://habr.com/ru/post/217585/">Later</a> we will figure out how to deal with it. </blockquote><br>  Note that in this case, only one copy of traffic per switch arrives from the source server, and not a separate copy per client.  And in our example with SD channels, the port loading between the source and the switch will not be 1.2 Gb / s, but only 60 Mb / s (2 Mb / s * 30 channels). <br><br>  As a matter of fact, this whole huge range (224.0.0.0-239.255.255.255) can be used. <br>  Well, almost all of them - the first addresses (range 224.0.0.0/23) are reserved for known protocols. <br><br><div class="spoiler">  <b class="spoiler_title">List of reserved IP addresses</b> <div class="spoiler_text"><table border="1"><tbody><tr><th>  Address </th><th>  Value </th></tr><tr><td>  224.0.0.0 </td><td>  Not used </td></tr><tr><td>  224.0.0.1 </td><td>  All nodes in this segment </td></tr><tr><td>  224.0.0.2 </td><td>  All multicast nodes of this segment </td></tr><tr><td>  224.0.0.4 </td><td>  This address was reserved for the late DVMRP protocol. </td></tr><tr><td>  224.0.0.5 </td><td>  All OSPF Segment Routers </td></tr><tr><td>  224.0.0.6 </td><td>  All DR Router Segments </td></tr><tr><td>  224.0.0.9 </td><td>  All RIPv2 Segment Routers </td></tr><tr><td>  224.0.0.10 </td><td>  All EIGRP Segment Routers </td></tr><tr><td>  224.0.0.13 </td><td>  All PIM Segment Routers </td></tr><tr><td>  224.0.0.18 </td><td>  All VRRP Segment Routers </td></tr><tr><td>  224.0.0.19-21 </td><td>  All IS-IS segment routers </td></tr><tr><td>  224.0.0.22 </td><td>  All IGMP Segment Routers (v2 and v3) </td></tr><tr><td>  224.0.0.102 </td><td>  All HSRPv2 / GLBP Segment Routers </td></tr><tr><td>  224.0.0.107 </td><td>  PTPv2 - Precision Time Protocol </td></tr><tr><td>  224.0.0.251 </td><td>  mDNS </td></tr><tr><td>  224.0.0.252 </td><td>  Llmnr </td></tr><tr><td>  224.0.0.253 </td><td>  Teredo </td></tr><tr><td>  224.0.1.1 </td><td>  NTP </td></tr><tr><td>  224.0.1.39 </td><td>  Cisco Auto-RP-Announce </td></tr><tr><td>  224.0.1.40 </td><td>  Cisco Auto-RP-Discovery </td></tr><tr><td>  224.0.1.41 </td><td>  H.323 Gatekeeper </td></tr><tr><td>  224.0.1.129-132 </td><td>  PTPv1 / PTPv2 </td></tr><tr><td>  239.255.255.250 </td><td>  SSDP </td></tr></tbody></table><br></div></div><br>  The range of 224.0.0.0/24 is reserved for <a href="http://lookmeup.linkmeup.ru/">link-local</a> communication.  Multicast packets with such destination addresses cannot exceed the limits of one broadcast segment. <br>  The range of 224.0.1.0/24 is reserved for protocols that need to transmit a multicast across the entire network, that is, pass through routers. <br><hr><br><br>  Here, in fact, the most basic things about multicast. <br>  We have considered a simple situation where the source and the receiver are in the same network segment.  The traffic received by the switch is simply sent to all ports by it - no magic. <br><br>  But for the time being it is not at all clear how the traffic from the server reaches the clients, when there is a huge provider network linkmyap between them?  Yes, and from where, in fact, will be known who the client?  We cannot manually register routes, simply because we do not know where customers may be.  Ordinary routing protocols will not answer this question.  So we come to the understanding that multicast delivery is something completely new to us. <br><br>  In general, in order to deliver a multicast from a source to a recipient, there are currently many protocols - IGMP / MLD, PIM, MSDP, MBGP, MOSPF, DVMRP. <br>  We will focus on two of them that are currently in use: PIM and IGMP. <br>  With the help of IGMP, the final recipient clients inform the closest routers that they want to receive traffic.  A PIM builds the path of movement of multicast traffic from the source to the recipients via routers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/149/c93/140/149c93140ceb8331d7ed2ca02fc2b138.png" title="PIM + IGMP"><br><br><hr><br><br><a name="IGMP"></a><br><h1>  Igmp </h1><br>  Let's go back to the dump.  Do you see this top package, after which the multicast stream flowed? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f28/a6f/157/f28a6f1579a0f66f38f5fbb20e12c8c4.png" title="Igmp dump"><br><br>  This is the IGMP message that the client sent when we clicked on Play.  That is how he reports that he wants to receive traffic for the group 224.2.2.4. <br>  <b>IGMP - Internet Group Management Protocol</b> is a network protocol for the interaction of clients of multicast traffic and the closest router to them. <br><blockquote>  IPv6 uses <a href="http://lookmeup.linkmeup.ru/">MLD</a> (Multicast Listener Discovery) instead of IGMP.  The principle of their work is absolutely the same, so you can easily change IGMP to MLD, and IP to IPv6 from here on. </blockquote><br>  How exactly does IGMP work? <br>  Perhaps you need to start with the fact that the protocol has three versions: IGMPv1, IGMPv2, IGMPv3.  The most used one is the second one, the first one is almost forgotten, therefore we will not talk about it, the third one is very similar to the second one. <br><br>  Focusing on the second, as the most revealing one, and consider all the events from the client‚Äôs connection to the group and its exit from it. <br>  The client will also request the group 224.2.2.4 through the VLC player. <br><br>  The role of IGMP is very simple: if there are no clients, you do not need to send multicast traffic to the segment.  If a client appears, it notifies the routers via IGMP that it wants to receive traffic. <br><br>  In order to understand how everything happens, take the following network: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c2/915/11d/1c291511db1c490b3e0cdd925e329561.png" title="Multicast"><br><br>  Suppose that the router is already configured to receive and process multicast traffic. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br>  <b>1.</b> As soon as we started the application on the client and set the group 224.2.2.4, the <b>IGMP Membership Report</b> packet will be sent to the network ‚Äî the node ‚Äúreports‚Äù that it wants to receive traffic from this group. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/806/187/1f4/8061871f4b19d71c7ae3b1f6b4b74f25.png" title="IGMP Report"><br><br>  In IGMPv2 Report, it is sent to the address of the desired group, and in parallel it is also indicated in the packet itself.  These messages should live only within their segment and not be sent anywhere by routers, so they have a TTL 1. <br><blockquote>  Often in the literature you can find mention of <b>IGMP Join</b> .  Do not worry - this is an alternative name for the IGMP Membership Report. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br>  <b>2. The</b> router receives IGMP-Report and, realizing that there are now clients behind this interface, it enters the information in its tables <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93c/9e7/bde/93c9e7bde5ddaabca4d673a5dead88f9.png" title="show ip igmp group"><br><br>  This is information output by IGMP.  The first group is requested by the client.  The third and fourth are the service groups of the <a href="http://lookmeup.linkmeup.ru/">SSDP</a> protocol built into Windows.  The second is a special group that is always present on Cisco routers ‚Äî it is used for the <a href="http://lookmeup.linkmeup.ru/">Auto-RP</a> protocol, which is activated by default on routers. <br>  The FE0 / 0 interface becomes downstream for group 224.2.2.4 traffic ‚Äî it will need to send the received traffic to it. <br><br>  Along with the usual unicast routing table, there is also a multicast: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c9/d43/73e/1c9d4373e09f5a43767f7d09f7cf6b2b.png" title="show ip mroute"><br><br>  The presence of clients is indicated by the first record <b>(*, 224.2.2.4)</b> .  And the entry <b>(172.16.0.5, 224.2.2.4)</b> means that the router knows about the source of the multicast stream for this group. <br>  It can be seen from the output that traffic for group 224.2.2.4 comes through FE0 / 1, and it must be transmitted to port FE0 / 0. <br>  The interfaces to which traffic is to be transferred are included in the list of downstream interfaces - <b>OIL - Outbound Interface List</b> . <br>  We will <b>analyze the show ip mroute</b> command in more detail later. <br><br>  Above on the dump you see that as soon as the client sent the IGMP-Report, immediately after it flew UDP - this is a video stream. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br>  <b>3.</b> The client began to receive traffic.  Now the router must sometimes check that it still has recipients so that it does not want to broadcast for nothing if suddenly there are no clients left.  To do this, it periodically sends an <b>IGMP Query</b> request to all its downstream interfaces. <br><br>  <i>* Dump filtered by IGMP *</i> . <br><img src="https://habrastorage.org/getpro/habr/post_images/f81/05a/a19/f8105aa1995baf21cfc7edebeff7bc8e.png" title="Igmp general query"><br><br>  By default, this happens every 60 seconds.  TTL of such packets is also 1. They are sent to the address 224.0.0.1 - all nodes in this segment - without specifying a specific group.  Such Query messages are called <b>General Query</b> - common.  Thus, the router asks: ‚ÄúGuys, and who else wants to receive what?‚Äù. <br><br>  Having received IGMP General Query, any host that listens to any group must send an IGMP Report, as it did when connecting.  In Report, of course, should be the address of the group of interest. <br><br>  <i>* Dump filtered by IGMP *</i> . <br><img src="https://habrastorage.org/getpro/habr/post_images/b42/ef0/fb9/b42ef0fb9ed713fd2f7aa565fc2ce962.png" title="IGMP Membership report"><br><br>  If, in response to Query, there is at least one Report for the group on the router, then there are more clients, it continues to broadcast to the interface from which this Report came, the traffic of this group itself. <br>  If for 3 consecutive Query there was no response for some group from the interface, the router deletes this interface from its multicast routing table for this group - it stops sending traffic there. <br><br>  On his own initiative, the client usually sends Report only when connected, then it simply responds to Query from the router. <br><blockquote>  An interesting detail in the client's behavior: having received the Query, he is not in a hurry to immediately reply to Report.  The node takes a timeout length from 0 to <b>Max Response Time</b> , which is specified in the incoming Query: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/813/69b/ee4/81369bee40dafa7cd6e9327744b12cd4.png" title="Max Response Time"><br><br>  When debugging or in the dump, by the way, you can see that it can take several seconds between receiving a different Report. <br>  This was done so that hundreds of clients all in a crowd did not flood the network with their Report packages, having received General Query.  Moreover, only one client usually sends Report. <br>  The fact is that Report is sent to the address of the group, and therefore comes to all customers.  Having received Report from another client for the same group, the node will not send its own.  The logic is simple: the router has already received this very Report and knows that there are customers, it does not need more. <br>  This mechanism is called <b>Report Suppression</b> . <br><br>  <b>Further in the article we will talk about why this mechanism actually very rarely works</b> . </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br>  <b>4.</b> This continues for centuries, until the client wants to leave the group (for example, turn off the player / TV).  In this case, it sends <b>IGMP Leave</b> to the group address. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/62b/bd3/8a462bbd344b0f866aafb9a4ac2dd72c.png" title="IGMP Leave"><br><br>  The router receives it and in theory should disconnect.  But after all, he cannot disable one specific client ‚Äî the router does not distinguish between them ‚Äî it simply has a downlink interface.  And behind the interface there can be several clients.  That is, if the router removes this interface from its OIL (Outgoing Interface List) list for this group, the video will turn off at all. <br>  But it is also impossible not to delete it completely - all of a sudden it was the last client - why then should it be wasted? <br><br>  If you look into the dump, you will see that after receiving the Leave, the router continues to send the stream for some time.  The fact is that the router, in response to Leave, sends IGMP Query to the address of the group for which this Leave came to the interface from which it came.  This package is called <b>Group Specific Query</b> .  <b>Only</b> those clients that are connected to this particular group respond <b>to</b> it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9da/4b9/9ee/9da4b99ee9d383b9bc2706f727f87f00.png" title="IGMP Group Specific Query"><br><br>  If the router received a response Report for the group, it continues to broadcast to the interface, if not received, it deletes after the timer expires. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In total, after receiving the Leave, two Group Specific Query are sent - one mandatory, the second control. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Dump filtered by IGMP *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/93e/a65/b05/93ea65b05c679ff99d44906255d6b157.png" title="disable multicast client"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, the router stops the flow.</font></font><br><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Querier </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider a slightly more complicated case: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d4/51d/e44/5d451de44a8d87cc4df354f500711de7.png" title="Igmper querier"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Two (or more) routers that can broadcast traffic are connected to the client segment. If nothing is done, multicast traffic will be duplicated - both routers will receive a Report from the clients. To avoid this, there is a mechanism for choosing </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Querier</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the poller. The one who wins will send Query, monitor the Report and respond to Leave, and, accordingly, it will send traffic to the segment. The loser will only listen to the Report and keep a finger on the pulse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elections are fairly simple and intuitive. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the situation since the inclusion of routers R1 and R2. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Activated IGMP on the interfaces. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first, by default, each of them considers itself Querier. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Everyone sends IGMP General Query to the network. The main goal is to find out if there are any clients, and in parallel - to announce to other routers in the segment, if any, about their desire to participate in the elections. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> General Query is received by all devices in the segment, including other IGMP routers. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Having received such a message from a neighbor, each router evaluates who is more worthy. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6) A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> router with a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smaller IP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wins </font><font style="vertical-align: inherit;">(indicated in the Source IP field of the IGMP Query package). He becomes Querier, all others - Non-Querier. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Non-Querier starts a timer that resets each time a Query with a lower IP address arrives. If, before the timer expires (more than 100 seconds: 105-107), the router does not receive a Query with a lower address, it declares itself to Querier and assumes all relevant functions. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If Querier gets Query with a smaller address, it disclaims these responsibilities. Querier becomes a different router with less IP. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That rare case, when measured, who has less.</font></font></i> <br><a name="NAG1"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Querier election is a very important multicast procedure, but some insidious non-RFC vendors can put a sturdy stick in their wheels. </font><font style="vertical-align: inherit;">I am now talking about IGMP Query with source address 0.0.0.0, which can be generated by the switch. </font><font style="vertical-align: inherit;">Such messages should not be involved in choosing Querier, but be prepared for anything. </font></font><a href="http://nag.ru/articles/article/25136/takie-raznyie-problemyi.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an example of a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> very complex long-playing problem.</font></font><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A couple more words about other versions of IGMP </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version 1 differs in essence only in that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">there is no Leave message in it</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the client does not want to receive more traffic from this group, he simply stops sending Report in response to Query. When there is not a single client, the router will time out to send traffic. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Querier selections are not supported</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To avoid duplication of traffic, a higher protocol is responsible, for example, PIM, which we will discuss </font></font><a href="https://habr.com/ru/post/217585/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">below</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Version 3 supports everything that IGMPv2 supports, but there are a number of changes. First, the Report is sent not to the group address, but to the multicast service address </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">224.0.0.22</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. And the address of the requested group is indicated only inside the package. This is done to simplify the work of IGMP Snooping, which we will discuss </font></font><a href="https://habr.com/ru/post/217585/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">later</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second, and more importantly, IGMPv3 began to support SSM in its pure form. This is the so-called </font></font><a href="http://lookmeup.linkmeup.ru/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Specific Multicast</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In this case, the client can not just request a group, but also indicate a list of sources from which he would like to receive traffic or, on the contrary, would not. In IGMPv2, the client simply requests and receives group traffic without worrying about the source. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/028/d32/083/028d32083c84704d1f9af242726b831e.png" title="Igmpv3"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, IGMP is intended for interaction between clients and a router. Therefore, returning to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example II</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where there is no router, we can authoritatively state - there IGMP is nothing more than a formality. </font><font style="vertical-align: inherit;">There is no router, and the client has no one to request a multicast stream. </font><font style="vertical-align: inherit;">And the video will work for the simple reason that the stream is already flowing from the switch - you just need to pick it up. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recall that IGMP does not work for IPv6. </font><font style="vertical-align: inherit;">There is an </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MLD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol </font><font style="vertical-align: inherit;">.</font></font><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Repeat again </font></font></h3><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Dump filtered by IGMP *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/49b/917/692/49b9176920cff1b46234fe0287043dd7.png" title="IGMP Capture"><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First of all, the router sent its IGMP General Query after IGMP was enabled on its interface to find out if there are recipients and state their desire to be Querier. At that time there was no one in this group. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then a client appeared who wanted to receive traffic of the group 224.2.2.4 and he sent his IGMP Report. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that the traffic went to him, but it was filtered from the dump. </font></font></i> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then, for some reason, the router decided to check whether there are any more clients and sent IGMP General Query again, to which the client is forced to respond ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">five.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Periodically (once a minute), the router checks that there are still recipients using IGMP General Query, and the node confirms this with the help of the IGMP Report. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then he changed his mind and abandoned the group, sending IGMP Leave. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. The</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> router received Leave and, wanting to make sure that there are no other recipients anymore, it sends the IGMP Group Specific Query ... twice. </font><font style="vertical-align: inherit;">And after the timer expires, it stops transmitting traffic here. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> However, it still continues to transmit IGMP Query to the network. </font><font style="vertical-align: inherit;">For example, in case you didn‚Äôt turn off the player, but just somewhere with a connection problem. </font><font style="vertical-align: inherit;">Then the connection is restored, but Report does not send the client by itself. </font><font style="vertical-align: inherit;">But on the query. </font><font style="vertical-align: inherit;">Thus, the flow can recover without human intervention.</font></font><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Once again </font></font></h3><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a protocol through which the router learns about the presence of multicast traffic recipients and their disconnection. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP Report</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sent by the client on connection and in response to IGMP Query. Indicates that the customer wants to receive traffic from a specific group. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP General Query</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sent by the router periodically to check which groups are currently needed. The recipient‚Äôs address is indicated as 224.0.0.1. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP Group Sepcific Query</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sent by the router in response to a Leave message to see if there are any other recipients in this group. The address of the multicast group is indicated as the recipient's address. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP Leave</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sent by the client when he wants to leave the group. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Querier</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- if there are several routers in one broadcast segment that can broadcast, one of them is selected as the main one - Querier. He will periodically send Query and transmit traffic. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detailed description of all </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terms </font><font style="vertical-align: inherit;">.</font></font><br><hr><br><br><a name="PIM"></a><br><h1>  Pim </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we figured out how clients are telling the nearest router about their intentions. Now it would be nice to transfer traffic from the source to the recipient via a large network. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you think about it, then we are facing a rather complicated problem - the source only broadcasts to the group, he does not know anything about where the recipients are and how many of them are. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The recipients and the routers closest to them know only that they need traffic from a specific group, but they have no idea where the source is and what its address is. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to deliver traffic in this situation? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are several multicast traffic routing protocols: </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DVMRP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSPF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - they all solve this problem differently. But the de facto standard has become</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM - Protocol Independent Multicast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Other approaches are so unviable that sometimes even their developers practically recognize this. </font><font style="vertical-align: inherit;">Here, for example, is an excerpt from the CBT RFC protocol: </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CBT version 2; </font><font style="vertical-align: inherit;">We wouldn‚Äôt be thinking about it. </font></font></i> <br><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM has two versions that can even be called two different protocols in principle, since they are very different:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PIM Dense Mode (DM) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PIM Sparse Mode (SM) </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Independent because it is not tied to any particular routing protocol for unicast traffic, and later you will see why. </font></font><br><br><a name="PIM-DM"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PIM Dense Mode </font></font></h2><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM DM is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trying to solve the problem of delivering multi-ata to the forehead. He obviously assumes that recipients are everywhere, in all corners of the network. Therefore, initially it floods the entire network with multicast traffic, that is, sends it to all ports, except where it came from. If it then turns out that somewhere it is not needed, then this branch is ‚Äúcut off‚Äù with the help of a special message PIM Prune - the traffic is no longer sent there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But after a while, the router tries again to send a multicast to the same branch - suddenly there were recipients. If they did not appear, the branch is again cut off for a certain period. If a client appears on the router between these two events, a Graft message is sent ‚Äî the router requests the branch to be cut back, so as not to wait until something passes to it.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you see, it‚Äôs not a question of determining the path to the recipients - the traffic will reach them simply because it is everywhere. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After ‚Äúcutting off‚Äù unnecessary branches, a tree remains, along which multicast traffic is transmitted. This tree is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPT - Shortest Path Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is devoid of loops and uses the shortest path from the receiver to the source. In fact, it is very similar to Spanning Tree in </font></font><a href="http://linkmeup.ru/blog/15.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where the source is the root. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPT is a specific kind of tree - the shortest path tree. In general, any multicast tree is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDT - Multicast Distribution Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is assumed that PIM DM should be used in networks with high density multicast clients, which explains its name (Dense). But the reality is that this situation is rather an exception, and often PIM DM is inappropriate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What really matters to us now is the loop avoidance mechanism. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine such a network: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/c5c/885/00fc5c8856724e811e1f23912f815307.png" title="RPF"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One source, one recipient and the simplest IP network between them. All routers run PIM DM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What would happen if there was no special loop avoidance mechanism? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source sends multicast traffic. R1 receives it and, in accordance with the principles, PIM DM sends to all interfaces, except where it came from - that is, to R2 and R3.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2 does exactly the same, that is, it sends traffic towards R3. R3 cannot determine that this is the same traffic that it has already received from R1, therefore it sends it to all its interfaces. R1 will receive a copy of the traffic from R3 and so on. Here it is - a loop. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does PIM offer in this situation? </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPF - Reverse Path Forwarding</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is the main principle of multicast traffic transmission in PIM (of any kind: both DM and SM) - the traffic from the source should come in the shortest way. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, for each received multicast packet, a check is made on the basis of the routing table whether it came from there. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) The router looks at the source address of the multicast packet. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) It checks the routing table through which interface the source address is available.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Checks the interface through which the multicast packet came. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4) If the interfaces are the same - everything is fine, the multicast packet is skipped, if the data comes from another interface - they will be discarded. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our example, R3 knows that the shortest path to the source is via R1 (static or dynamic route). Therefore, multicast packets that come from R1 are tested and accepted by R3, and those that come from R2 are discarded. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e51/9de/838/e519de8381a64c20936e7ecace437de6.png" title="RPF Check"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such a check is called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPF-Check</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and, thanks to it, even in more complex networks, loops in MDT will not occur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This mechanism is important to us, because it is relevant in PIM-SM and works there in the same way.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, PIM relies on the unicast routing table, but, first, it does not route traffic itself, and second, it doesn‚Äôt matter who filled the table and how. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will not stop here and examine the work of PIM DM in detail - this is an outdated protocol with a lot of flaws (well, like </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RIP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, PIM DM can be used in some cases. </font><font style="vertical-align: inherit;">For example, in very small networks, where the flow of multicast is small.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/401/b3c/657/401b3c657579343c778ba436a152ea36.gif" title="PIM DM"><br><hr><br><a name="PIM-SM"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PIM Sparse Mode </font></font></h2><br>  A completely different approach is using <b>PIM SM</b> .  Despite the name (rarefied mode), it can successfully be used on any network with an efficiency no less than that of PIM DM. <br>  Here they abandoned the idea of ‚Äã‚Äãunconditional flooding with a multicast network.  Interested nodes independently request a connection to the tree using <b>PIM Join</b> messages. <br>  If the router did not send Join, then the traffic will not be sent to it. <br><br>  In order to understand how PIM works, let's start with the already familiar simple network with one PIM router: <br><img src="https://habrastorage.org/getpro/habr/post_images/89e/577/857/89e57785751a8429793bac63f715a6d3.png"><br>  From the settings on R1, you must enable multicast routing, PIM SM on two interfaces (towards the source and towards the client) and IGMP towards the client.  <i>In addition to other basic settings, of course (IP, IGP).</i> <br><br>  From now on, you can uncover GNS and build a lab.  Enough detail about how to assemble a stand for multicast I told in this <a href="http://linkmeup.ru/blog/126.html">article</a> . <br><br><pre><code class="bash hljs">R1(config)<span class="hljs-comment"><span class="hljs-comment">#ip multicast-routing R1(config)#int fa0/0 R1(config-if)#ip pim sparse-mode R1(config-if)#int fa1/0 R1(config-if)#ip pim sparse-mode</span></span></code> </pre> <br><blockquote>  Cisco as usual here differs by its special approach: when PIM is activated on the interface, IGMP is automatically activated.  IGMP also works on all interfaces where PIM is activated. <br>  At the same time, for other manufacturers, two different protocols are included by two different commands: IGMP separately, PIM separately. <br>  Forgive Cisco this oddity?  Together with everyone else? <br><br>  Plus, you may need to configure the RP address ( <b>ip pim rp-address 172.16.0.1</b> , for example).  More on this later, for now take it for granted and accept it. </blockquote><br>  Check the current state of the multicast routing table for group 224.2.2.4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c8d/341/3b0/c8d3413b0602c5366298376d1619214d.png" title="show ip mroute"><br><br>  Once on the source you start the broadcast, you need to check the table again. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aba/f66/b59/abaf66b59f02594a7a2610f7ef2d1050.png" title="(*, G) (S, G)"><br><br>  Let's analyze this concise conclusion. <br><br>  The record of the form <b>(*, 225.0.1.1)</b> is called <b>(*, G)</b> , / is read by the <i>Starcomadge</i> / and informs us about the recipients.  And not necessarily talking about one client-computer, in general it may be, for example, another PIM-router.  What is important is which interfaces need to send traffic to. <br>  If the list of descending interfaces (OIL) is empty - <b>Null</b> , then there are no recipients - and we have not started them yet. <br><br>  The record <b>(172.16.0.5, 225.0.1.1)</b> is called <b>(S, G)</b> , / is read by the <i>eskomadzh</i> / and says that the source is known.  In our case, the source with the address 172.16.0.5 broadcasts traffic for the group 224.2.2.4.  Multicast traffic arrives at the FE0 / 1 interface - this is the <b>upstream</b> ( <b>Upstream</b> ) interface. <br><br>  So, no customers.  The traffic from the source reaches the router and this is where his life ends.  Let's add now the recipient - let's set up multicast reception on the PC. <br>  The PC sends the IGMP Report, the router understands that clients have appeared and updates the multicast routing table. <br>  Now it looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/a64/64f/8aaa6464f5c2b7dc2238725279034037.png" title="OIL Multicast"><br><br>  A downstream interface has also appeared: FE0 / 0, which is quite expected.  And it appeared both in (*, G), and in (S, G).  The list of downstream interfaces is called <b>OIL - Outgoing Interface List</b> . <br><br>  Add another client to the FE1 / 0 interface: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/0af/6ff/2ba0af6ffd67975332a4d8dd3b18ff16.png" title="OIL Multicast"><br><br>  If you read the output verbatim, we have: <br>  (*, G): There are multicast traffic recipients for group 224.2.2.4 behind the interfaces FE0 / 0, FE1 / 0.  And it doesn‚Äôt matter who the sender is, which is what the ‚Äú*‚Äù sign says. <br><br>  (S, G): When multicast traffic with destination address 224.2.2.4 from source 172.16.0.5 arrives at the FE0 / 1 interface, copies of it must be sent to FE0 / 0 and FE1 / 0. <br><br>  But it was a very simple example - one router immediately knows the source address and where the recipients are located.  In fact, there aren't even any trees here, except degenerate.  But it helped us understand how PIM and IGMP interact. <br><hr><br><br><h3>  To understand what PIM is, let's turn to the network is much more complex. </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/1b6/339/68c1b63395b1d2ebb595998303d04bf7.png" title="PIM SM RP"><br><br>  Suppose that all IP addresses are already configured according to the scheme.  IGP is running on the network for regular unicast routing. <br>  <i>Client1</i> , for example, can ping Server Source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/4cd/e19/9ad4cde198aa440814c7dfecfd06af53.png"><br><br>  But until PIM, IGMP is running, clients do not request channels. <br><br>  <a href="https://docs.google.com/document/d/1rtrifoyP4mwjnbVug8zW-nL0g5qm1405IaWpbasusog/pub">Initial configuration file</a> . <br><br><br>  So, time 0. <br><br>  We enable multicast routing on all five routers: <br><br><pre> <code class="bash hljs"> RX(config)<span class="hljs-comment"><span class="hljs-comment">#ip multicast-routing</span></span></code> </pre> <br>  PIM is enabled directly on all interfaces of all routers (including the interface in the direction of the source server and clients): <br><br><pre> <code class="bash hljs"> RX(config)<span class="hljs-comment"><span class="hljs-comment">#int FEX/X RX(config-if)#ip pim sparse-mode</span></span></code> </pre> <br><blockquote>  IGMP, in theory, should be enabled on the interfaces in the direction of the clients, but, as we noted above, on Cisco equipment, it turns on automatically with PIM. </blockquote><br><hr><br>  The first thing that PIM does is set up a neighborhood.  <b>Hello</b> messages are used for this.  When PIM is activated on the interface, it sends PIM Hello to the address <b>224.0.0.13</b> with a TTL of 1. This means that only routers in the same broadcast domain can be neighbors. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/e73/b77/fffe73b77fa6726cdbeab0bc437da3b2.png" title="Pim hello"><br><br>  As soon as the neighbors received greetings from each other: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa7/7da/c98/aa77dac98fc2ba98146ea64a6977b1e8.png" title="show ip pim neighbor"><br><br>  Now they are ready to accept applications for multicast groups. <br><br>  If we now launch clients into the open-air cage on one side and switch on the multicast stream from the server on the other, R1 will receive the traffic flow, and R4 will receive the IGMP Report when the client tries to connect.  As a result, R1 will not know anything about the recipients, and R4 about the source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f31/cd0/e10/f31cd0e1020410c5731c4e1a43be87d1.png" title="show ip mroute"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/455/e43/d22/455e43d2254ce08ffe99d3195bdddec9.png" title="show ip mroute"><br><br>  It would be nice if the information about the source and customers of the group were collected somewhere in one place.  But which one? <br><br>  This meeting point is called <b>Rendezvous Point - RP</b> .  This is the central concept of PIM SM.  Without it, nothing would work.  Here are the source and recipients. <br>  All PIM routers need to know who the RP is in the domain, that is, know its IP address. <br><br>  To build an MDT tree, a certain center point is selected as RP in the network, which, <br><ol><li>  responsible for exploring the source </li><li>  is the point of attraction Join messages from all concerned. </li></ol><br>  There are two ways to set RPs: static and dynamic.  We will look at both in this article, but let's start with a static one, since why are statics easier? <br><br>  Let it be R2 for the time being RP. <br>  To increase reliability, the address of the Loopback interface is usually selected.  Therefore, the command is executed <b>on all</b> routers: <br><pre> <code class="bash hljs"> RX(config)<span class="hljs-comment"><span class="hljs-comment">#ip pim rp-address 2.2.2.2</span></span></code> </pre> <br>  Naturally, this address should be accessible by the routing table from all points. <br>  Well, since the address 2.2.2.2 is RP, on the interface <i>Loopback 0</i> on R2 it is also desirable to activate PIM. <br><br><pre> <code class="bash hljs"> R2(config)<span class="hljs-comment"><span class="hljs-comment">#interface Loopback 0 RX(config-if)#ip pim sparse-mode</span></span></code> </pre> <br><br>  Immediately after this, R4 learns about the traffic source for the group 224.2.2.4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/177/958/e69/177958e6926517c6cd16f585e79d97be.png"><br><br>  and even transmits traffic: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/031/7a1/d870317a1d488525dbb995f67ad0aa36.png" title="show interface summary"><br><br>  The interface FE0 / 1 comes 362000 bps, and through the interface FE0 / 0 they are transmitted. <br><br>  Everything we did: <br>  Enabled the possibility of multicast traffic routing ( <b>ip multicast-routing</b> ) <br>  Activated PIM on interfaces ( <b>ip pim sparse-mode</b> ) <br>  Indicated the address of the RP ( <b>ip pim rp-adress <i>XXXX</i></b> ) <br><br>  Everything, this is already a working configuration and you can proceed to the analysis, because behind the scenes there is much more hidden than can be seen on the scene. <br>  <a href="https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub">Full configuration with PIM.</a> <br><hr><br><br><h3>  Debriefing </h3><br>  Well, so how does it all work?  How does the RP know where the source is, where are the customers and provide communication between them? <br><br>  Since everything is being done for the sake of our beloved clients, then, starting with them, we will examine in detail the whole process. <br><br>  <b>1)</b> Client 1 sends IGMP Report for group 224.2.2.4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0f/76c/be2/f0f76cbe266b970bac3548fb53a80401.png" title="Connecting multicast client"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>2)</b> R4 receives this request, realizes that there is a client behind the FE0 / 0 interface, adds this interface to the OIL and forms the entry (*, G). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c99/678/4bd/c996784bdbc7d2c04edb395190e2397e.png" title="(*, G)"><br><br><blockquote>  Here you can see the upstream interface FE0 / 1, but this does not mean that R4 receives traffic for group 224.2.2.4.  It only says that the only place he can get from now is FE0 / 1, because this is where RP is located.  By the way, the neighbor who passed <b>RPF-Check</b> - R2: 10.0.2.24 is also indicated here.  Expected. <br></blockquote><br><br>  R4 is called - LHR (Last Hop Router) - the last router in the path of multicast traffic, if you count from the source.  In other words, it is the router closest to the receiver.  For <i>Customer1</i> , this is R4, for <i>Customer2</i> , this is R5. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>3)</b> Since there is no multicast stream on R4 (he did not request it before), it forms the PIM Join message and sends it to RP (2.2.2.2). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2e/df5/bea/b2edf5bea38e8da760bf068ca4035cb6.png" title="(*, G)"><br><br>  PIM Join is sent by multicast to the address 224.0.0.13.  ‚ÄúTowards RP‚Äù means through the interface that is specified in the routing table, as outbound for the address that is specified inside the packet.  In our case, this is 2.2.2.2 - the RP address.  Such a Join is also referred to as <b>Join (*, G)</b> and says: ‚ÄúIt doesn‚Äôt matter who the source is, I need the traffic of the group 224.2.2.4‚Äù. <br>  That is, each router on the path must process such a Join and, if necessary, send a new Join to the RP.  (It is important to understand that if this group already exists on the router, it will not send above Join - it will simply add the interface from which Join came to OIL and start sending traffic). <br>  In our case, Join went to FE0 / 1: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c7/931/76b/1c793176b95feefe781642332d0a61b5.png" title="show ip route"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>4)</b> R2, after receiving Join, forms the entry (*, G) and adds the FE0 / 0 interface to the OIL.  But Join is nowhere to send - he is already RP, but nothing is yet known about the source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b61/8bf/71d/b618bf71d63489bc6127fd1d4f0654a5.png"><br><br>  This way, RP will know where the customers are located. <br><br>  If <i>Client 2</i> also wants to receive multicast traffic for the same group, R5 will send PIM Join to FE0 / 1, because RP is behind it, receiving it, forms a new PIM Join and sends it to FE1 / 1 - where RP is located . <br>  That is, Join travels node by node until it reaches RP or another router where there are already clients of this group. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ad6/39e/c6f/ad639ec6f591035ba3c59ac589905df5.png"><br><br>  So R2 - our RP - now knows that it has recipients for FE0 / 0 and FE1 / 0 for group 224.2.2.4. <br>  And no matter how many of them are there - one for each interface or one hundred - the traffic flow will still be one per interface. <br><br>  If we graphically depict what we received, it will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e7f/408/34f/e7f40834f8976c075fa7a11118128315.png" title="RP Tree"><br><br>  It resembles a tree remotely, doesn‚Äôt it?  Therefore, it is called so - <b>RPT - Rendezvous Point Tree</b> .  This is a tree with a root in RP, and whose branches extend to customers. <br>  A more general term, as we mentioned above, is <b>MDT ‚Äî Multicast Distribution Tree</b> ‚Äî a tree along which a multicast stream spreads.  Later you will see the difference between MDT and RPT. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>5)</b> Now we cut the server.  As we discussed above, he is not worried about PIM, RP, IGMP ‚Äî he just broadcasts.  And R1 gets this thread.  His task is to deliver a multicast to RP. <br>  PIM has a special type of message - <b>Register</b> .  It is needed in order to register the source of the multicast on the RP. <br>  So, R1 receives multicast group flow 224.2.2.4: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/a6a/6ea/546a6a6eab77dfd88d740fc1e06934b9.png" title="show interface summary"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4dd/190/543/4dd190543979f20c12df9f07ea711652.png" title="(S, G)"><br><br>  R1 is <b>FHR (First Hop Router)</b> - the first router in the path of multicast traffic or closest to the source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>6)</b> Next, it encapsulates each multicast packet received from the source into a unicast PIM Register and sends it straight to the RP. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2b/2a1/81a/a2b2a181a9b3def04b5f0f6f9fe57fd9.png" title="PIM Register"><br><br>  Pay attention to the protocol stack.  Above the unicast IP and PIM header is the original multicast IP, UDP and data. <br>  Now, unlike all other PIM messages known to us, 2.2.2.2 is indicated in the recipient's address, and not the multicast address. <br><br>  Such a package is delivered to the RP according to the standard rules of unicast routing and carries the original multicast packet, that is, this ... this is tunneling! <br><br><blockquote>  ===================== <br> <a href="http://linkmeup.ru/blog/130.html"><img src="https://habrastorage.org/getpro/habr/post_images/298/063/27d/29806327db155363023118ca212fbb1d.png" align="left" hspace="20"></a>  <a href="http://linkmeup.ru/blog/130.html"><b>Problem number 1</b></a> <br><br>  <a href="https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub">Scheme and initial configuration</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/1b6/339/68c1b63395b1d2ebb595998303d04bf7.png"><br><br>  On the server 172.16.0.5, an application is running that can only transmit packets to the broadcast address 255.255.255.255, with the UDP receiver port 10999. <br><br>  This traffic must be delivered to clients 1 and 2: <br>  Client 1 in the form of multicast traffic with a group address of 239.9.9.9. <br>  And in the client segment 2, in the form of broadcast packets to the address 255.255.255.255. <br><br>  Details of the problem <a href="http://linkmeup.ru/blog/130.html">here</a> . <br>  ===================== <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>7)</b> RP receives the PIM Register, unpacks it and detects the traffic for the group 224.2.2.4 under the wrapper. <br>  He immediately writes information about this into his multicast routing table: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b05/d05/9f3/b05d059f3801addb63f0edc2651f2867.png" title="(S, G)"><br><br>  There was a record (S, G) - (172.16.0.5, 224.2.2.4). <br>  Unpacked RP packets further sends to RPT on the FE0 / 0 and FE1 / 0 interfaces, through which traffic reaches the clients. <br><br>  In principle, this could be stopped.  Everything works - customers get traffic.  But there are two problems: <br><ol><li>  Encapsulation and decapsulation processes are very costly for routers.  In addition, additional headers increase the size of the packet, and it may simply not crawl into the MTU somewhere on the intermediate node (remember all the problems of <a href="http://www.opennet.ru/base/cisco/gre_fragment.txt.html">tunneling</a> ). </li><li>  If suddenly somewhere between the source and RP there are still recipients for the group, multicast traffic will have to go one way twice. </li></ol><br>  Take for example the following topology: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/927/958/eb7/927958eb7f664d889eb20013ac60b254.png" title="PIM Register Encapsulation"><br><br>  The traffic in the Register messages will first reach the RP via the R1-R42-R2 line, then the pure multicast will return via the R2-R42 line.  Thus, on the line R42-R2 two copies of one traffic will go, albeit in opposite directions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc8/330/be1/fc8330be1f817c8220028f27f29057b1.png" title="PIM Register Encapsulation"><br><br>  Therefore, it is better to transmit a pure multicast from the source to the RP, and for this you need to build a tree - <b>Source Tree</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>8)</b> Therefore, the RP sends a PIM Join message to R1.  But now it indicates for the group the address not of the RP, but of the source, learned from the Register message.  This message is called <b>Join (S, G) - Source Specific Join</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/479/8f8/7d44798f893db0634a0f7b9d8c284b8a.png" title="Source-Specific Join"><br>  His goal is exactly the same as that of PIM Join (*, G) - to build a tree, only this time from source to RP. <br>  Join (S, G) also extends node by node, just like regular Join (*, G).  Only Join (*, G) tends to RP, and Join (S, G) to S - source.  The recipient‚Äôs address is also a business address of 224.0.0.13 and TTL = 1. <br><br><blockquote>  If there are intermediate nodes, for example, R42, they also form an entry (S, G) and a list of downstream interfaces for this group and forward the Join further to the source. </blockquote><br>  The path that Join went from RP to the source turns into a <b>Source Tree</b> - a tree from the source.  But the more common name - <b>SPT - Shortest Path Tree</b> - because the traffic from the source to the RP will follow the shortest path. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>9)</b> R1 received Join (S, G), adds the interface FE1 / 0, from where the packet came, to the list of downstream interfaces OIL and begins to broadcast pure multicast traffic there, uncluttered by encapsulation.  The record (S, G) on R1 was already as soon as it received the first multicast packet from the Source Server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7d/12c/b1e/b7d12cb1e56ca77961dc996646e7ca64.png" title="(S, G)"><br><br>  According to the multicast constructed by the Source Tree, the RP is transmitted (and to all intermediate clients, if any, for example, R42). <br><br>  But it must be kept in mind that Register messages were transmitted all this time and are transmitted until now.  That is, in fact, R1 sends two copies of traffic now: one is a pure multicast on SPT, the other is encapsulated in a unicast Register. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd7/ad5/7ad/dd7ad57ad62b54b8ff7488cc0bd16cc3.png" title="PIM Register and UDP at the same time"><br><blockquote>  First, R1 sends a multicast register - <b>packet 231</b> .  Then R2 (RP) wants to connect to the tree, sends the Join <b>package 232</b> .  R1 still some time while processes request from R2, sends multicast in Register ( <b>packets with 233 on 238</b> ).  Further, when the downlink interface is added to OIL on R1, it starts transmitting a pure multicast - <b>packets 239 and 242</b> , but does not stop it yet and Register - <b>packets 241 and 243</b> .  And the <b>pack 240</b> is R2 could not resist and once again asked to build a tree. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/9e9/78f/bd8/9e978fbd8c665e7da99433a6e962e1c1.png"><br><br>  <b>10)</b> So, a clear multicast reaches RP.  She understands that this is the same traffic that comes to Register, because the same group address, the same source address and from the same interface.  In order not to receive two copies, he sends a uni-rim <b>PIM Register-Stop</b> to R1. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/c48/e90/604c48e90fd5c5b4ca0c570b30ead7d9.png" title="PIM Register-Stop"><br><br>  Register-Stop does not mean that R2 refuses traffic or does not recognize this source anymore, this only means that it is necessary to stop sending <b>encapsulated</b> traffic. <br><br>  Next comes a bitter struggle - R1 continues to transmit the traffic accumulated in the buffer while the Register-Stop processes, and with the usual multicast and within Register messages: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/011/b25/723/011b257234aed064fcafe58c624bf705.png" title="Multicast competition"><br><br>  But, sooner or later, R1 starts broadcasting only pure multicast traffic. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/396/74b/55b/39674b55b5ad9038a042fda45db301df.png" title="Multicast UDP"><br><a name="PIM_Register"></a><br><blockquote>  In preparation, I had, as it seemed to me, a logical question: well, why are all these tunneling, PIM Register?  Why not deal with multicast traffic, as with PIM Join - send hop after hop with TTL = 1 in the direction of RP - it will come sooner or later?  So would the tree be built at the same time without unnecessary gestures. <br>  Here there are several nuances. <br>  Firstly, the main principle of PIM SM is violated - to send traffic only to where it was requested from.  <b>No Join - No Tree</b> ! <br>  Secondly, if there are no clients for this group, FHR will not know about it and will continue to send traffic on ‚Äúits own tree‚Äù.  Why such mindless use of bandwidth?  In the world of communication, such a protocol simply would not have survived, just as PIM DM or DVMRP did not survive. </blockquote><br>  Thus, we have one large MDT tree for group 224.2.2.4 from the <i>Source Server</i> to <i>Client 1</i> and <i>Client 2</i> .  And this MDT is made up of two pieces that were built independently of each other: <b>Source Tree</b> from source to RP and <b>RPT</b> from RP to customers.  This is what distinguishes MDT from RPT and SPT.  MDT is a fairly generic term for the multicast transmission tree in general, while RPT / SPT is its very specific form. <br><br>  What to do if the server is already broadcasting, but there are still no clients?  Will the multicast still litter the area between the sender and the RP? <br>  No, in this case also help PIM Register-Stop.  If the Register started receiving messages for some group on the RP, but there are no recipients for it, the RP is not interested in receiving this traffic, therefore, <b>without sending</b> PIM Join (S, G), the RP immediately sends Register-Stop to R1. <br>  R1, having received Register-Stop and seeing that there is no tree for this group yet (no clients), begins to discard multicast traffic from the server. <br>  That is, the server itself is not worried about this at all and continues to send the stream, but when it reaches the interface of the router, the stream will be dropped. <br>  At the same time, the RP continues to store the record (S, G).  That is, he does not receive traffic, but he knows where the source for the group is located.  If recipients appear in the group, the RP finds out about them and sends to the source the Join (S, G) that builds the tree. <br><br>  In addition, every 3 minutes R1 will try to re-register the source on the RP, that is, send the Register packets.  This is necessary in order to notify the RP that this source is still alive. <br><br><blockquote>  Particularly inquisitive readers must ask a question - what about the RPF?  After all, this mechanism checks the sender address of the multicast packet and, if the traffic is not sent from the correct interface, it will be dropped.  In this case, the RP and the source may be behind different interfaces.  So in our example for R3 RP - for FE1 / 1, and the source - for FE1 / 0. <br>  The answer is predictable - in this case, not the source address, but RP is checked.  That is, the traffic should come from the interface towards the RP. <br>  But, as you will see later, this is also not an indestructible rule. </blockquote><br>  It is important to understand that RP is not a universal magnet - for each group there may be its own RP.  That is, there may be two, three, and one hundred in the network ‚Äî one RP is responsible for one set of groups, the other for another.  Moreover, there is such a thing as <a href="http://lookmeup.linkmeup.ru/"><b>Anycast RP</b></a> and then different RPs can serve the same group. <br><br><blockquote>  ===================== <br> <a href="http://linkmeup.ru/blog/131.html"><img src="https://habrastorage.org/getpro/habr/post_images/298/063/27d/29806327db155363023118ca212fbb1d.png" align="left" hspace="20"></a>  <a href="http://linkmeup.ru/blog/131.html"><b>Problem number 2</b></a> <br><br>  <a href="https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub">Scheme and initial configuration</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/1b6/339/68c1b63395b1d2ebb595998303d04bf7.png"><br><br>  <b>Note to the topology</b> : in this task, only the routers R1, R2, R3 are managed by the administrators of our network.  That is, the configuration can only be changed on them. <br><br>  Server 172.16.0.5 transmits multicast traffic to groups 239.1.1.1 and 239.2.2.2. <br><br>  Configure the network so that traffic from group 239.1.1.1 is not transmitted to the segment between R3 and R5, and to all segments below R5. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But at the same time, the traffic of the group 239.2.2.2 should be transmitted without problems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details of the problem </font></font><a href="http://linkmeup.ru/blog/131.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=====================</font></font><br></blockquote><br><hr><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Occam's razor or disabling unnecessary branches. </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the last client in the segment has unsubscribed, the PIM should cut off the extra RPT branch. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let, for example, the only client on R4 turned off the computer. The router by IGMP Leave message or after three unanswered IGMP Query realizes that there are no more clients for FE0 / 0, and sends a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM Prune</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> message to the RP </font><font style="vertical-align: inherit;">. The format is exactly the same as Join, but performs the opposite function. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The destination address is also 224.0.0.13, and the TTL is 1. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/03b/c78/244/03bc782449fc76a42e06d0dc3005c26c.png" title="PIM Prune"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the router that received the PIM Prune waits for a while before removing the subscription (usually 3 seconds - Join Delay Timer). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done for this situation:</font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b87/2e4/01d/b872e401d3d21fc600d69611e1ddc574.png" title="Prune override"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In one broadcast domain 3 routers. </font><font style="vertical-align: inherit;">One of them is higher and it is he who sends multicast traffic to the segment. </font><font style="vertical-align: inherit;">This is R1. </font><font style="vertical-align: inherit;">For both routers (R2 and R3), his OIL contains only one entry. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If R2 now decides to disconnect and sends PIM Prune, then it can substitute its colleague R3 - R1, after all, it will stop broadcasting to the interface altogether. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, so that this does not happen, R1 and gives a timeout of 3 seconds. </font><font style="vertical-align: inherit;">During this time, R3 must have time to react. </font><font style="vertical-align: inherit;">Taking into account the network broadcasting, he will also receive Prune from R2 and therefore, if he wants to continue receiving traffic, he instantly sends the normal PIM Join to the segment, notifying R1 that he should not delete the interface. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This process is called Prune Override. </font><font style="vertical-align: inherit;">R2 seemed to take over R1, seize the initiative.</font></font><br><hr><br><a name="SPT_Switchover"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SPT Switchover - RPT-SPT Switching </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Until now, we mainly considered only </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Now let's turn to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At first, everything for him is identical to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - he uses RPT from RP, which we considered earlier. By the way, since both </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> use the same tree, this tree is called the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äî this is quite a common name. Shared tree = RPT. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the multicast routing table on R5 at the very beginning, immediately after building the tree: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/54e/06a/4c5/54e06a4c5f3215f586aba8cf419f8d11.png" title="(*,G) SPT Switchover"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no record (S, G), but this does not mean that multicast traffic is not transmitted. Just the R5 doesn't care about who the sender is.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to what path should go in this case traffic - R1-R2-R3-R5. Although the path is shorter R1-R3-R5. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2be/49e/912/2be49e912f94cd820fbe4fb02930cd11.png" title="    RPT"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if the network is more complicated? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4af/2fc/54c/4af2fc54c22dc42422b40a8c79616880.png" title="   RPT  SPT"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Somehow inaccurate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that while we are tied to RP - it is the root of the RPT, only she first knows where everyone is. However, if you think about it, after the first multicast packet, all routers will know the source address along the traffic path, because it is indicated in the IP header. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7f/0be/fa8/b7f0befa8e176140fc7e536bae073fa1.png" title="   "><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why don't someone send the Join itself to the source and optimize the route? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See the root. Such a switch can trigger the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LHR (Last Hop Router)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- R5. After receiving the first multicast packet from R3, R5 sends the already familiar Source Specific Join (S, G) to the FE0 / 1 interface, which is indicated in its routing table, as outgoing for the network 172.16.0.0/24. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/24d/50b/7b6/24d50b7b6d7c01c0e1babc56fec7a377.png" title="  SPT"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having received such a Join, R3 sends it not to the RP, as it did with the usual Join (*, G), but to the source (via the interface according to the routing table). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, in this case, R3 sends a Join (172.16.0.5, 224.2.2.4) to the FE1 / 0 interface. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/1b1/437/1e01b1437007d0bb38ccc909304fed57.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, this Join falls on R1. And R1 by and large, no matter who sent it - RP or someone else - he just adds FE1 / 1 to his OIL for group 224.2.2.4. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d2/87a/b87/9d287ab87617a627093a65a032c60f08.png" title="SPT"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, there are two paths between the source and the receiver and R3 receives two streams.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b7/a21/773/3b7a21773b4c7379642ab20c1d92d6bd.png" title="  : SPT  RPT"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time to make a choice to trim too much. Moreover, it is R3 that does it, because R5 will not be able to distinguish between these two streams - they will both come through one interface. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as R3 recorded two identical flows from different interfaces, it selects the preferred one according to the routing table. In this case, direct, better than through RP. At this point, R3 sends Prune (S, G) to the RP side, chopping off this RPT branch. And from this moment there is only one stream directly from the source. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/452/f0e/63a/452f0e63a249f95a1516a73eb8972fac.png" title="   RPT"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, PIM built SPT - Shortest Path Tree. It is the Source Tree. This is the shortest path from the client to the source. By the way, the tree from the source to RP, which we have already considered above, is essentially the very same SPT.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is characterized by the record (S, G). </font><font style="vertical-align: inherit;">If the router has such an entry, then it knows that S is the source for the G group and the SPT tree has been built.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The root of the SPT tree is the source and really want to say "the shortest path from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source to the client</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font><font style="vertical-align: inherit;">But this is technically incorrect, since the paths from the source to the client and from the client to the source may be different. </font><font style="vertical-align: inherit;">Namely, a branch of the tree starts to be built from the client: the router sends PIM Join to the source / RP side and the RPF also checks the correctness of the interface when </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receiving</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traffic.</font></font></blockquote><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You remember that at the beginning of this paragraph on R5 there was only a record (*, G), now after all these events there will be two of them: (*, G) and (S, G)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><hr><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, even if you look at the multicast routing table of R3 in the same second as you clicked Play in VLC, you will see that it already receives traffic from R1 directly, as indicated by the presence of a record (S, G). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, SPT Switchover has already happened - this is the default action on the equipment of many manufacturers - to initiate the switch after receiving the first multicast package. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generally speaking, such a switch can occur in several cases:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never occur at all ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip pim spt-threshold infinity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a certain bandwidth utilization is reached ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip pim spt-threshold X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">).</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, immediately after receiving the first packet (default action or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no ip pim spt-threshold X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a rule, the decision that it is time to take the LHR. </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the RPF operation rule changes a second time ‚Äî it checks the location of the source again. </font><font style="vertical-align: inherit;">That is, of the two multicast streams - from RP and from the source - preference is given to traffic from the source.</font></font></blockquote><br><hr><br><a name="DR_Assert_Forwarder"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DR, Assert, Forwarder </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few more important points when considering PIM. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DR - Designated Router</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a dedicated router that is responsible for sending service packets to the RP. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - is responsible for accepting multicast packets directly from the source and registering it with the RP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an example of the topology: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/481/241/cff/481241cffa21c69861632d9f13f83a8f.png" title="Source DR"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no need for both routers to send traffic to the RP, let them reserve each other, but there should be only one responsible person. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since both routers are connected to the same broadcast network, they get PIM-Hello from each other. Based on it, they make their choice. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello PIM carries the priority value of this router on this interface.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f88/69a/718/f8869a718a94a5f25ec8cd7ea62c57eb.png" title="DR Priority"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The higher the value, the higher the priority. If they are the same, then the node with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highest IP address</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is selected </font><font style="vertical-align: inherit;">(also from the Hello message). </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/272/054/d57/272054d57298384ed2125c55179d8798.png" title="DR  "><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the other router (not DR) did not receive Hello from the neighbor during Holdtime (by default 105 s), it automatically assumes the role of DR. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In essence, Source DR is </font></font><a href="http://lookmeup.linkmeup.ru/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FHR - First Hop Router</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Receiver DR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the same as Source DR, only for recipients of multicast traffic - </font></font><a href="http://lookmeup.linkmeup.ru/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LHR (Last Hop Router)</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example topology:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/601/877/71e/60187771ed4a32f67af80db084cbe0b8.png" title="Receiver DR"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Receiver DR is responsible for sending to RP PIM Join. In the above topology, if both routers send Join, both will receive multicast traffic, but this is not necessary. Only DR sends Join. The second simply monitors the availability of DR. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the DR sends a Join, it will also broadcast traffic on the LAN. But then a natural question arises - what if the PIM DR was one and the IGMP Querier was different? And the situation is quite possible, because for Querier, the smaller the IP, the better, and for DR, on the contrary. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the DR is chosen for the router that is already Querier and this problem does not arise. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/169/bed/d5f/169bedd5f729c1af72cb4c47e45ff666.png" title="DR  "><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rules for selecting Receiver DR are exactly the same as Source DR. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assert and PIM Forwarder</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem of two simultaneously transmitting routers can arise in the middle of a network where there are neither end clients nor sources ‚Äî only routers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This issue was very acute in PIM DM, where it was a completely ordinary situation due to the Flood and Prune mechanism. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But in PIM SM it is not excluded. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider such a network: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0a/09a/809/b0a09a809c867f3c12d8844bb1d176c2.png" title="Assert   PIM Forwarder"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, the three routers are in the same network segment and, accordingly, are neighbors in the PIM. R1 acts as RP. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4 sends PIM Join towards RP. Since this packet is multicast, it falls on both R2 and R3, and both of them after processing it add a downstream interface to the OIL.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There should be a DR selection mechanism, but there are other clients of this group on R2 and R3, and both routers will have to send PIM Join anyway. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When multicast traffic comes from a source on R2 and R3, it is transmitted to the segment by both routers and backed up there. PIM does not try to prevent such a situation - here it acts on the fact of a crime - as soon as the router receives multicast traffic from this group to its downlink interface for a specific group (from the OIL list), it understands that something is wrong - there is another sender in this segment. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/590/65a/bc0/59065abc0513232308d690fd856d2c52.png" title="   "><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the router sends a special message to the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM Assert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This message helps you choose </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM Forwarder.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the router that is entitled to broadcast in this segment. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/796/425/980/796425980e4a6e3da15c0e6f5f8116f6.png" title="PIM Assert"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Don't confuse it with PIM DR. </font><font style="vertical-align: inherit;">First, PIM DR is responsible for sending </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIM Join and Prune messages</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and PIM Forwarder is </font><font style="vertical-align: inherit;">responsible </font><font style="vertical-align: inherit;">for sending </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traffic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The second difference is that PIM DR is always selected in any networks when establishing a neighborhood, and PIM Forwrder only when necessary - when multicast traffic is received from the interface from the OIL list.</font></font><br><hr><br><a name="Bootstrap"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RP selection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above, for simplicity, we set the RP manually </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using the ip pim rp-address </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XXXX</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is how the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show ip pim rp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command looked like </font><font style="vertical-align: inherit;">: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b5a/ed8/5a8/b5aed85a89546b7e8cecbeb1b12dceb0.png" title="show ip pim rp"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But </font><b><font style="vertical-align: inherit;">let's</font></b><font style="vertical-align: inherit;"> imagine a completely impossible situation in modern networks - R2 failed. This is all - finish. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Client 2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will still work, since SPT Switchover has occurred, but everything new and everything that went through the RP will break, even if there is an alternative way. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the load on the domain administrator. Imagine: manually killing at least one command on 50 routers (and for different groups there may be different RPs). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic RP selection allows you to avoid manual work and ensure reliability - if one RP becomes unavailable, the other will immediately enter into battle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the moment there is one generally accepted protocol that allows you to do this - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bootstrap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In previous times, Tsisk was promoted by a somewhat clumsy </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-RP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but now it is hardly used, although Tsisk does not recognize this, and in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">show ip mroute</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we have an annoying rudiment as a group of 224.0.1.40.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We must actually do justice to the Auto-RP protocol. </font><font style="vertical-align: inherit;">He was a salvation in the old days. </font><font style="vertical-align: inherit;">But with the advent of open and flexible Bootstrap, he naturally lost his position.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, suppose that in our network we want R3 to pick up RP functions in case of failure of R2. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2 and R3 are defined as candidates for the role of RP - so they are called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-RP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">On these routers we configure:</font></font><br><pre> <code class="bash hljs"> RX(config)interface Loopback 0 RX(config-if)ip pim sparse-mode RX(config-if)<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> RX(config)<span class="hljs-comment"><span class="hljs-comment">#ip pim rp-candidate loopback 0</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But while nothing is happening - the candidates do not yet know how to notify everyone about themselves. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To inform all multicast domain routers about existing RPs, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mechanism is introduced </font><b><font style="vertical-align: inherit;">- the BootStrap Router</font></b><font style="vertical-align: inherit;"> . Applicants may be several, as well as C-RP. They are called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-BSR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> respectively </font><font style="vertical-align: inherit;">. They are configured in a similar way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let BSR we have one and for the test (exclusively) it will be R1.</font></font><br><pre> <code class="bash hljs">R1(config)interface Loopback 0 R1(config-if)ip pim sparse-mode R1(config-if)<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> R1(config)<span class="hljs-comment"><span class="hljs-comment">#ip pim bsr-candidate loopback 0</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First of all, one main BSR is selected from all C-BSRs, which will fill everything. To do this, each C-BSR sends a multicast </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootStrap Message (BSM)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the </font><font style="vertical-align: inherit;">network </font><font style="vertical-align: inherit;">to the address 224.0.0.13 - this is also a PIM protocol packet. It must be accepted and processed by all multicast routers and then sent to all ports where PIM is activated. BSM is not transmitted in the direction of something (RP or source), as opposed to PIM Join, but in all directions. This fan mailing helps to reach BSM in all corners of the network, including all C-BSRs and all C-RPs. In order for the BSM not to wander around the network indefinitely, the same RPF mechanism is used - if the BSM came from the wrong interface where the sender's network of the message is located, the message is discarded.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/267/c20/2ed/267c202edb26341a39ef38661ffdf346.png" title="Bootstrap"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the help of these BSM, all multicast routers determine the most worthy candidate based on priorities. As soon as C-BSR receives BSM from another router with a higher priority, it stops sending its messages. As a result, all have the same information. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b2/efe/9df/7b2efe9df4370897312f3dd55e4051f6.png" title="show ip pim bsr-router"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage, when BSR is chosen, due to the fact that its BSM has already spread across the entire network, C-RPs know its address and unicast send </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candidte-RP-Advertisement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> messages to it </font><font style="vertical-align: inherit;">, in which they carry a list of the groups they serve - called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">group-to-RP mapping</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . BSR aggregates all these messages and creates an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RP-Set</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - information table: which RPs each group serves.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/abc/c72/204/abcc72204c345f6d34b68b906ec94ccb.png" title="Candidate-RP-Adverisement"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the BSR sends the same BootStrap Message in the old fan manner, which this time contains the RP-Set. These messages successfully reach all multicast routers, each of which </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">independently</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chooses which RP to use for each particular group. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/535/427/628/5354276284ebfe8a0ee235f5d3d64f51.png" title="BSR"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSR periodically makes such mailings so that, on the one hand, everyone knows that the information on the RP is still relevant, and on the other, C-BSR was aware that the main BSR itself is still alive. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RP, by the way, also periodically sends its announcements to Candidate-RP-Advertisement on BSR. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, all that needs to be done to configure the automatic selection of RPs is to specify a C-RP and specify a C-BSR ‚Äî not so much work, PIM will do the rest.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As always, in order to improve reliability, it is recommended to specify Loopback interfaces as candidates. </font></font><br><hr><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Concluding the chapter of PIM SM, let us once again mark the most important moments. </font></font></h4><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normal unicast connectivity should be provided using IGP or static routes. </font><font style="vertical-align: inherit;">This is the basis of the RPF algorithm.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The tree is built only after the appearance of the client. </font><font style="vertical-align: inherit;">It is the client that initiates the construction of the tree. </font><font style="vertical-align: inherit;">No customer - no tree.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RPF helps to avoid loops. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All routers should be aware of who is RP - only with its help you can build a tree. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The RP point can be specified statically, or it can be selected automatically using the BootStrap protocol. </font></font></li><li>     RPT ‚Äî     RP ‚Äî  Source Tree ‚Äî     RP.        RPT  SPT ‚Äî      . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also list all types of trees and messages that we now know. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDT - Multicast Distribution Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . General term describing any tree of multicast transmission. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPT - Shortest Path Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The tree with the shortest path from the client or RP to the source. In PIM DM there is only SPT. In PIM SM, SPT can be from source to RP or from source to destination after the SPT Switchover has occurred. It is denoted by the entry </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(S, G)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the source is known for the group. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the same as SPT. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPT - Rendezvous Point Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tree from RP to recipients. Used only in PIM SM. Denoted by the entry </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(*, G)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shared Tree</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the same as the RPT. It is so called because all clients are connected to the same common tree with a root in RP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Types of messages PIM Sparse Mode: </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - to establish a neighborhood and maintain this relationship. Also needed to select DR. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Join (*, G)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - request to connect to the tree of group G. It does not matter who is the source. Sent toward RP. With their help, the RPT tree is built. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Join (S, G)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Source Specify Join. This is a request to connect to a tree of group G with a specific source, S. It is sent to the source side, S. They are used to build an SPT tree. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prune (*, G)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - request to disconnect from a tree of group G, whatever sources for it were. Sent toward RP. This is how the RPT branch is trimmed. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prune (S, G)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- request to disconnect from the tree of the group G, whose root is the source S. It is sent to the source. This is how the SPT branch is trimmed. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a special message within which a multicast is transmitted to the RP until the SPT is built from the source to the RP. Transmitted by unicast from FHR to RP. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Register-Stop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sent by unicast from RP to FHR, ordering to stop sending multicast traffic encapsulated in Register. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bootstrap</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - BSR mechanism packages that allow you to select a router for the role of BSR, and also transmit information about existing RPs and groups. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a message for selecting PIM Forwarder so that two routers do not send traffic to one segment. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Candidate-RP-Advertisement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a message in which the RP sends to the BSR information about which groups it serves. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RP-Reachable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a message from the RP with which it notifies everyone of its availability. </font></font><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* There are other types of messages in PIM, but these are details *</font></font></i> <br><hr><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now let's try to abstract from the details of the protocol? </font><font style="vertical-align: inherit;">And then its complexity becomes apparent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Definition of RP, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Register the source to RP, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) Switch to SPT tree. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many protocol states, many entries in the multicast routing table.</font></font> Can I do something about this? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Today, there are two diametrically opposed approaches to simplifying PIM: SSM and BIDIR PIM. </font></font><br><br><a name="SSM"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SSM </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All that we have described so far is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM - Any Source Multicast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Clients do not care who is the source of traffic for the group - the main thing is that they receive it. </font><font style="vertical-align: inherit;">As you remember in the message IGMPv2 Report it is requested just to connect to the group. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSM - Source Specific Multicast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - an alternative approach. </font><font style="vertical-align: inherit;">In this case, the clients specify the group and source when connecting. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does this give? </font><font style="vertical-align: inherit;">Nothing more: the ability to completely get rid of RP. </font><font style="vertical-align: inherit;">LHR immediately knows the source address - there is no need to send Join to RP, the router can immediately send Join (S, G) in the direction of the source and build an SPT. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we get rid of</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RP search (Bootstrap and Auto-RP protocols), </font></font></li><li>     (   ,      ) </li><li>   SPT. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since there is no RP, then there is no RPT, respectively, there will no longer be any (*, G) entries on any router ‚Äî only (S, G). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another problem that is solved with the help of SSM is the presence of several sources. In ASM, it is recommended that the multicast group address be unique and only one source broadcast to it, since several streams in the RPT tree will merge, and the client, receiving two streams from different sources, probably will not be able to parse them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In SSM, traffic from various sources is distributed independently, each in its own SPT tree, and this is no longer a problem, but an advantage ‚Äî several servers can broadcast simultaneously. If suddenly the client began to record losses from the main source, he can switch to the backup one, without even re-requesting it - he already received two streams.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, a possible attack vector in a network with activated multicast routing is an attacker's connection of his source and generating a large amount of multicast traffic that will overload the network. </font><font style="vertical-align: inherit;">In SSM this is almost impossible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For SSM, a special range of IP addresses is allocated: 232.0.0.0/8. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On routers to support SSM, PIM SSM mode is enabled.</font></font><br><br><pre> <code class="bash hljs">Router(config)<span class="hljs-comment"><span class="hljs-comment"># ip pim ssm</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMPv3 and MLDv2 support pure SSM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When used, the client can</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Request a connection to a simple group, without specifying sources. </font><font style="vertical-align: inherit;">That is, it works like a typical ASM.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Request a connection to a group with a specific source. </font><font style="vertical-align: inherit;">You can specify several sources - a tree will be built before each of them.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Request a connection to the group and specify a list of sources from which the client </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">would not want</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to receive traffic</font></font></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/028/d32/083/028d32083c84704d1f9af242726b831e.png" title="IGMPv3"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMPv1 / v2, MLDv1 does not support SSM, but there is such a thing as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSM Mapping</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">At the nearest client router (LHR), each group is assigned a source address (or several). </font><font style="vertical-align: inherit;">Therefore, if there are clients on the network that do not support IGMPv3 / MLDv2, SPT will be built for them, not RPT, due to the fact that the source address is still known. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSM Mapping can be implemented as a static setting on the LHR, or by accessing the DNS server. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem with SSM is that customers must know the source addresses in advance ‚Äî they are not signaled by any signaling.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, SSM is good in those situations when there is a certain set of sources on the network, their addresses are obviously known and will not change. </font><font style="vertical-align: inherit;">And client terminals or applications are tightly tied to them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In other words, IPTV is a very suitable environment for SSM implementation. </font><font style="vertical-align: inherit;">This well describes the concept of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One-to-Many</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - one source, many recipients.</font></font><br><hr><br><a name="BIDIR_PIM"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> BIDIR PIM </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what if the network sources can appear spontaneously here and there, broadcast to the same groups, quickly stop transmitting and disappear? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, this situation is possible in online games or in the data center, where data is replicated between different servers. This is a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many-to-Many</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> concept </font><font style="vertical-align: inherit;">- many sources, many clients. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does a regular PIM SM look at it? </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is clear that inert PIM SSM is not suitable here?</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Just think what chaos will start: endless registration of sources, rebuilding of trees, a huge number of records (S, G) living for several minutes due to protocol timers. </font><b><font style="vertical-align: inherit;">Bidirectional PIM</font></b></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">Bidirectional PIM, BIDIR PIM)</font></b><font style="vertical-align: inherit;"> comes to the rescue</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Unlike SSM, on the contrary, they completely abandon SPT and (S, G) records - only the Shared Tree with the root in RP remains. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if in a normal PIM, a tree is one-way - the traffic is always sent from the source down the SPT and from the RP down the RPT - there is a clear division, where the source is where the clients are, then in bidirectional from the source the traffic to the RP is also sent up along the Shared Tree over the same one that traffic flows down to customers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This eliminates the registration of the source on the RP - the traffic is transmitted unconditionally, without any signaling or state changes. Since there are no SPT trees at all, SPT Switchover does not occur either.</font></font><br><br>  For example: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/30e/d47/31b/30ed4731b1796bcd31a57c175cb645b8.png" title="BIDIR PIM"><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Istochnik1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> began airing the network traffic simultaneously with the group 224.2.2.4 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Istochnikom2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Flows from them just poured towards RP. </font><font style="vertical-align: inherit;">Some of the clients that are nearby began to receive traffic immediately, because the routers have an entry (*, G) (there are clients). </font><font style="vertical-align: inherit;">The other part receives traffic on the Shared Tree from the RP. </font><font style="vertical-align: inherit;">And they receive traffic from both sources simultaneously. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, if you take a speculative network game for example, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the first player in the shooter who took the shot, and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source2</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is another player who took a step to the side. </font><font style="vertical-align: inherit;">Information about these two events spread throughout the network. </font><font style="vertical-align: inherit;">And </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">every</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> other player ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recipient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) should learn about both of these events. </font></font><br><blockquote>  ,  <a href="https://habr.com/ru/post/217585/"> </a>  ,       RP ‚Äî     ,   ,   RP    .        ?  : BIDIR PIM  ,   ,     ,  ,    .       RP    . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the image above between R5 and R7 has a straight line, much shorter than the path through the RP, but it was not used because Join goes to the RP side according to the routing table in which the path is not optimal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks pretty simple - you need to send multicast packets in the direction of RP and that's all, but there is one nuance that spoils everything - RPF. In the RPT tree, it requires that traffic come from RP and not otherwise. And here he can come from anywhere. Of course, we cannot take and abandon the RPF - this is the only mechanism that avoids the formation of loops. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the concept of </font><b><font style="vertical-align: inherit;">DF - Designated Forwarder</font></b><font style="vertical-align: inherit;"> is introduced in BIDIR PIM</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In each network segment, on each line, the router whose route to RP is better is chosen for this role. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is also done on those lines where customers are directly connected. </font><font style="vertical-align: inherit;">In BIDIR PIM, the DF is automatically DR. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/456/264/ea6/456264ea6a8b4ca3a68bdbdf81c061cd.png" title="Designated Forwarder"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The OIL list is generated only from those interfaces on which the router was selected for the DF role. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rules are pretty transparent:</font></font><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the PIM Join / Leave request arrives on the interface that is DF in this segment, it is passed to the RP side according to standard rules. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, for example, R3. </font><font style="vertical-align: inherit;">If requests come to DF interfaces that are marked with a red circle, it sends them to the RP (via R1 or R2, depending on the routing table).</font></font></li><li> <b>  PIM Join/Leave    DF ,   .</b> <br> ,  ,   R1  R3,     IGMP Report. R1    ,    DF (  ),      .  R3    ,    DF. R3 ,     ,   . </li><li> <b>     DF ,        OIL    RP.</b> <br> , <i>1</i>   . R4     DF        DF- ‚Äî       RP, ‚Äî  ,       RP     .    R3 ‚Äî       OIL ‚Äî    R5,     -  RPF,   ‚Äî   RP. </li><li> <b>      DF ,         OIL,  <b> </b>    RP.</b> <br>  , <i>2</i>  ,    RP      RPT. R3    R1,       R2 ‚Äî    R4   R5. </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, DF ensures that only one copy of the multicast packet will be sent to the RP as a result and the formation of loops is excluded. At the same time, the common tree in which the source is located, naturally, will receive this traffic before it reaches the RP. RP, according to the usual rules, will send traffic to all OIL ports, in addition, where the traffic came from. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, there is no need for more messages in Assert, because DF is selected in each segment. Unlike DR, he is responsible not only for sending Join to RP, but also for sending traffic to a segment, that is, a situation where two routers send traffic to the same subnet is excluded from BIDIR PIM.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the last thing to say about the bidirectional PIM is the features of RP. While in PIM, SM RP performed a very specific function - registration of the source, then in BIDIR PIM RP - this is some very conditional point towards which traffic on the one hand tends and Join from clients on the other. No one should perform decapsulation, request the construction of an SPT tree. Just on some router, suddenly the traffic from the sources starts to be transmitted to the Shared Tree. Why do I say "at some"? The fact is that in BIDIR PIM RP is an abstract point, not a specific router, a non-existent IP address can act as an RP address - the main thing is that it is routable (this RP is called </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phantom RP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All PIM terms can be found in the </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glossary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><hr><br><a name="L2_Multicast"></a><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multicast channel level </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, behind the long working week with lack of sleep, processing, tests - you have successfully implemented multicast and satisfied customers, director and sales department. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Friday is not the worst day to inspect the creation and allow yourself a pleasant stay. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But your afternoon nap suddenly disturbed the tech support call, then another one and more - nothing works, everything broke. </font><font style="vertical-align: inherit;">Check - there are losses, breaks. </font><font style="vertical-align: inherit;">Everything converges on one segment of several switches.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We uncovered SSH, checked the CPU, checked the utilization of the interfaces and the hair on end - loading under almost 100% on all interfaces of one VLAN. A loop! But where would she come from if no work was done? 10 minutes of checking and you noticed that on the upstream interface to the core you have a lot of incoming traffic, and on all downstream clients - outgoing traffic. For the loop, this is also characteristic, but somehow suspicious: they introduced a multicast, they did not do any work on switching, and the jump was only in one direction. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We checked the list of multicast groups on the router - and there is a subscription to all possible channels and all to one port - naturally, the one that leads to this segment. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The meticulous investigation revealed that the client‚Äôs computer is infected and sends IGMP Query to all multicast addresses in a row.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Packet losses began because the switches had to pass through a huge amount of traffic. </font><font style="vertical-align: inherit;">This caused an overflow of interface buffers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main question is why did the traffic of one client start being copied to all ports? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The reason for this lies in the nature of multicast MAC addresses. </font><font style="vertical-align: inherit;">The fact is, the multicast IP address space is mapped in a special way into the multicast MAC address space. </font><font style="vertical-align: inherit;">And the snag is that they will never be used as the source MAC address, and therefore will not be examined by the switch and listed in the MAC address table. </font><font style="vertical-align: inherit;">And what about a switch with frames whose destination address has not been studied? </font><font style="vertical-align: inherit;">He sends them to all ports.</font></font> What happened. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is the default action. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/831/cae/d55/831caed55259a02b08d3f71fbf2c1cc1.png" title="Multicast Flooding"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multicast MAC Addresses </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So what recipient MAC addresses are put in the Ethernet header of such packets? Broadcast?</font></font> Not.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a special range of MAC addresses to which multicast IP addresses are mapped. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These special addresses start like this: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x01005e and the next 25th bit should be 0</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try to answer why</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). The remaining 23 bits (remember, there are only them in the MAC address 48) are transferred from the IP address. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here lies some not very serious, but a problem. The range of multicast addresses is determined by the mask 224.0.0.0/4, this means that the first 4 bits are reserved: 1110, and the remaining 28 bits may vary. That is, we have 2 ^ 28 multicast IP addresses and only 2 ^ 23 MAC addresses ‚Äî 5 bits are not enough to display 1 in 1. Therefore, the last 23 bits of the IP address are taken and one-to-one are transferred to the MAC address, the remaining 5 bits are discarded.</font></font><br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/cf6/23c/4a5/cf623c4a5d9c97d76c2774bedfaa1583.gif" title="Multicast MAC Address"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, this means that 2 ^ 5 = 32 IP addresses will be displayed in one multicast MAC address. For example, groups 224.0.0.1, 224.128.0.1, 225.0.0.1 and so on until 239.128.0.1 will all be mapped to one MAC address 0100: 5e00: 0001. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you take a streaming video dump as an example, you can see: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/24c/188/9b4/24c1889b45906648c4cac2f4c4481c47.png" title=" "><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP address is 224.2.2.4, MAC address: 01: 00: 5E: 02: 02: 04. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are also other multicast MAC addresses that are not related to IPv4 multicast ( </font></font><a href="https://en.wikipedia.org/wiki/Multicast_address"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">click</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). All of them, by the way, are characterized by the fact that the last bit of the first octet is 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, such a MAC address cannot be configured on any network card, so it will never be in the Source MAC field of an Ethernet frame and never get into table of MAC addresses. So these frames should be sent as any</font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unknown Unicast</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to all ports VLAN'a. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All that we considered before is quite enough to fully transmit any multicast traffic from streaming video to stock quotes. </font><font style="vertical-align: inherit;">But will we really put up with such a disgrace in our almost perfect world, as the broadcast of what could be passed on to the elect?</font></font><br>  Not at all. <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Especially for perfectionists,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP-Snooping</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mechanism was invented </font><font style="vertical-align: inherit;">.</font></font><br><hr><br><a name="IGMP_Snooping"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Igmp-snooping </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea is very simple - the switch "listens" to IGMP packets passing through it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For each group separately, it maintains a table of ascending and descending ports. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the IGMP Report for the group came from the port, then the client is there, the switch adds it to the list of descending for this group. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If IGMP Query for the group came from the port, then the router is there, the switch adds it to the ascending list. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, a multicast traffic transmission table at the data link layer is formed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, when a multicast stream comes from above, it is copied only to downstream interfaces. If there are only two clients on the 16-port switch, only the traffic will be delivered to them.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7db/991/a3d/7db991a3d8d03246db6da9ab07175b82.png" title="IGMP Snooping"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The genius of this idea ends when we think about its nature. The mechanism assumes that the switch should listen on traffic at the 3rd level. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, IGMP-Snooping is in no comparison with NAT in the degree of ignoring the principles of network interaction. Moreover, besides saving resources, it carries a lot of less obvious possibilities. And in general, in the modern world, a switch that can peek inside IP is not an exceptional phenomenon.</font></font><br><br><blockquote> ===================== <br> <a href="http://linkmeup.ru/blog/132.html"><img src="https://habrastorage.org/getpro/habr/post_images/298/063/27d/29806327db155363023118ca212fbb1d.png" align="left" hspace="20"> <b> ‚Ññ 3</b></a> <br><br> <a href="https://docs.google.com/document/d/1Dwi4wO6B_VGhxapE4dqfBacT4_N3tNRU-Q9JFoiaEj0/pub">   </a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/68c/1b6/339/68c1b63395b1d2ebb595998303d04bf7.png"><br><br>  172.16.0.5      239.1.1.1, 239.2.2.2  239.0.0.x. <br>    , : <br> ‚Äî  1      239.2.2.2.        239.0.0.x. <br> ‚Äî  2      239.1.1.1.        239.0.0.x. <br><br>   <a href="http://linkmeup.ru/blog/132.html"></a> . <br> ===================== <br></blockquote><br><br><hr><br><br><h3> IGMP Snooping Proxy </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An inquisitive reader may have a question about how IGMP Snooping recognizes all client ports, given that only one fastest client is responding to IGMP Query, as we said above. It's very simple: IGMP-Snooping does not allow Report messages to go between clients. They are sent only to the upstream ports to the routers. Not seeing Report from other recipients of this group, the client is obliged to respond to the Query within Max Response Time specified in this Query. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, the network for 1000 nodes per IGMP Query within seconds 10 (the usual value of Max Response Time) will come to 1000 Reports for the router. Although it would be enough for him and one for each group. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And it happens every minute.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, you can configure proxying IGMP requests. Then the switch does not just "listen" to passing packets, it intercepts them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The rules of IGMP-Snooping may vary for different manufacturers. Therefore, we will consider them conceptually: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) If the very first Report request for a group arrives at the switch, it is sent up to the router, and the interface is added to the drop-down list. If such a group already exists, the interface is simply added to the list of descending ones, and the Report is destroyed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) If the latest Leave comes to the switch, that is, there are no other clients, this Leave will be sent to the router, and the interface will be removed from the list of descending. Otherwise, the interface is simply deleted, Leave is destroyed.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3) If IGMP Query arrives from the router, the switch intercepts it, sends in response IGMP Report for all groups that currently have recipients. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And further, depending on the settings and the manufacturer, either the same Query is sent to all client ports, or the switch blocks the request from the router and acts as Querier itself, periodically polling all recipients. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the share of unnecessary service traffic on the network and the load on the router are reduced.</font></font><br><br><a name="MVR"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Multicast VLAN Replication </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Short for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is the mechanism for those providers who practice </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLAN-per-user</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for example. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a typical example of a network where MVR is vital: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f92/ec8/7c8/f92ec87c85569a1b118da2cf528f49c3.png" title="MVR"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 clients in different VLANs, and everyone wants to receive multicast traffic from one group 224.2.2.4. At the same time, customers must remain isolated from each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IGMP-Snooping takes into account, of course, VLANs. If five clients in different VLANs request one group, this will be five different tables. Accordingly, 5 requests to connect to the group go to the router. And each of the five subinterfaces on the router will be added separately to the OIL. That is, having received 1 stream for the group 224.2.2.4, it will send 5 copies, despite the fact that they all go into one segment.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1e0/500/56b/1e050056b148d504bf45c703256d9ec9.png" title="Multicast VLAN Replication"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, Multicast VLAN Replication was developed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An additional VLAN is introduced - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multicast VLAN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - in it, accordingly, a multicast stream will be transmitted. It is ‚Äúforwarded‚Äù directly to the last switch, where traffic from it is copied to all client interfaces that want to receive this traffic ‚Äî this is replication. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the implementation, replication from Multicast VLAN can be done in a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">User-VLAN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or to certain physical interfaces.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/2ec/ecb/9952ececb3b2e8130112eb0c4784c818.png" title="Multicast VLAN Replication"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what about IGMP messages? </font><font style="vertical-align: inherit;">Query from the router, of course, comes via a multicast VLAN. </font><font style="vertical-align: inherit;">The switch sends them to the client ports. </font><font style="vertical-align: inherit;">When Report or Leave comes from a client, the switch checks from where it is (VLAN, interface) and, if necessary, redirects to a multicast VLAN. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the normal traffic is isolated and still goes to the router in the user VLAN. </font><font style="vertical-align: inherit;">And multicast traffic and IGMP packets are transmitted to the Multicast VLAN.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Cisco hardware, MVR and IGMP Snooping are configured independently. </font><font style="vertical-align: inherit;">That is, you can turn off one and the second will work. </font><font style="vertical-align: inherit;">In general, MVR is based on IGMP Snooping and on switches from other manufacturers for MVR operation it may be necessary to enable IGMP Snooping.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, IGMP-Snooping allows you to filter traffic on the switches, limit the number of groups available to the user, enable IGMP Querier, static configuration of the upstream ports, permanent connection to a group (this scenario is in the accompanying </font></font><a href="http://www.youtube.com/watch%3Ffeature%3Dplayer_embedded%26v%3D7MqBF0wKNR0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), quick response to the topology change by sending additional Query, SSM-Mapping for IGMPv2, etc.</font></font><br><a name="NAG2"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finishing the conversation about IGMP-Snooping, I want to repeat - this is an optional functionality - everything will work without it. But this will make the network more predictable, and the engineer‚Äôs life will be calmer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, all the advantages of IGMP Snooping can be wrapped against themselves. One such outstanding case can be read on the </font></font><a href="http://nag.ru/articles/article/25136/takie-raznyie-problemyi.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, the same Cisco has </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CGMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> protocol </font><font style="vertical-align: inherit;">- an analogue of IGMP, which does not violate the principles of the switch, but it is proprietary and not to say that it is widespread.</font></font><br><hr><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, my tireless reader, we are approaching the end of the issue and finally want to show how the client‚Äôs IPTV service can be implemented. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The easiest way to which we have already addressed this article more than once is to launch a player that can receive a multicast stream from the network. On it, you can manually set the IP address of the group and enjoy the video. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another software option that is often used by providers is a special application, usually a very custom one, in which a set of channels used in the provider‚Äôs network is sewn up. There is no need to set something manually - you just need to switch channels with buttons. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Both of these methods make it possible to watch streaming video only on a computer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The third option allows you to use the TV, and as a rule, any. To do this, in the client's house puts the so-called Set-Top-Box (STB) - a box installed on the TV. This is a trunk link that connects to the subscriber line and divides the traffic: it sends a normal unicast to Ethernet or WiFi so that customers have access to the Internet, and the multicast stream is transmitted to the TV via cable (DVI, RGB, antenna, etc.). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Often, by the way, you can see ads where the provider offers their set-top boxes for connecting to television - these are the very STB</font></font><br><br><blockquote> ===================== <br> <a href="http://linkmeup.ru/blog/133.html"><img src="https://habrastorage.org/getpro/habr/post_images/298/063/27d/29806327db155363023118ca212fbb1d.png" align="left" hspace="20"> <b> ‚Ññ 4</b></a> <br><br>      (  ,      ). <br><br>   : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/124/8a4/5e5/1248a45e57358fcd1262776620b46e0c.png"><br><br>    -,   ‚Äî ,    . <br><br>       . <br><br>  ,  : <br> <b>1.</b>   ,             ? <br> <b>2.</b> ,    ,        ,       ? <br><br>     ,     . <br><br>   <a href="http://linkmeup.ru/blog/133.html"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">=====================</font></font><br></blockquote><br><br><hr><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the article, inter-domain routing of multicast traffic ( </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSDP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MBGP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BGMP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), load balancing between RP ( </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anycast RP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><a href="http://habrahabr.ru/post/148444/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PGM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , proprietary protocols </font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;">remained intact</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">But, I think, having this article as a starting point, it‚Äôs easy to figure out the rest. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All terms related to multicast can be found in the </font></font><a href="http://lookmeup.linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lookmeup</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> glossary </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For assistance in preparing the article, thanks to </font></font><a href="http://habrahabr.ru/users/jdima/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JDima</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For technical support, thanks to </font></font><a href="http://xgu.ru/wiki/%25D0%259A%25D0%25B0%25D1%2582%25D0%25B5%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F:%25D0%2590%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580_%25D0%259D%25D0%25B0%25D1%2582%25D0%25B0%25D1%2588%25D0%25B0_%25D0%25A1%25D0%25B0%25D0%25BC%25D0%25BE%25D0%25B9%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25BA%25D0%25BE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Natasha Samoylenko</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="Niko"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KDPV was painted by </font></font><a href="http://www.nina-dolgopolova.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nina Dolgopolova</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a wonderful artist and friend of the project. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the pool of articles SDSM still a lot of interesting until the end, so you do not need to bury the cycle due to the long lack of release - with each new article the complexity increases significantly. </font><font style="vertical-align: inherit;">Ahead almost all MPLS, IPv6, QoS and network design. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you may have noticed, linkmeup has a new project - a glossary lookmeup (yes, we have a fantasy close by). </font><font style="vertical-align: inherit;">We hope that this glossary will be the most comprehensive reference for communications terms, so we will be glad to any help in filling it out. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Email</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> us at </font><a href=""><font style="vertical-align: inherit;">info@linkmeup.ru.</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stay </font></font><a href="http://linkmeup.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tuned</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/217585/">https://habr.com/ru/post/217585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../217573/index.html">Is it possible in theory to create a ship driven by an artificial black hole?</a></li>
<li><a href="../217575/index.html">Demonoid with us again</a></li>
<li><a href="../217579/index.html">Task management: some options for implementing repetitive tasks</a></li>
<li><a href="../217581/index.html">Tug wheel will save millions of dollars for passenger airlines</a></li>
<li><a href="../217583/index.html">Patch EDID TV from under Linux</a></li>
<li><a href="../217587/index.html">LZ Series Portable Batteries by iconBIT</a></li>
<li><a href="../217593/index.html">Following the publication in Google Play / App Store / Steam Greenlight</a></li>
<li><a href="../217595/index.html">Java Annotations, Part I</a></li>
<li><a href="../217599/index.html">Dismantling IBOX, another ARM mini PC</a></li>
<li><a href="../217603/index.html">Extending JavaScript native objects - is it evil? SugarJS Manifesto</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>