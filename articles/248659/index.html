<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to topological spaces. Java finite topology programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 For a long time I thought about choosing a mathematical object that is interesting not only from the point of view of discrete mathemat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to topological spaces. Java finite topology programming</h1><div class="post__text post__text-html js-mediator-article"><h1>  Introduction </h1><br>  For a long time I thought about choosing a mathematical object that is interesting not only from the point of view of discrete mathematics, but also functional analysis, and try to program it. <br><br>  This object became the so-called <b>topological spaces</b> .  Naturally, the finite volume of the representation of objects in the computer‚Äôs memory does not allow to model the topological spaces in mathematics with absolute precision, and therefore it remains to be content with finite topologies. <br><br>  Fortunately, this is one of those objects for which a finiteness not only allows one to operate with standard mathematical concepts, but also simplifies some of them.  Moreover, it is quite interesting to explore objects for which we <b>have no way</b> to measure the distance between points.  Yes, yes, you heard right.  We have no such possibility in the general topology. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But first things first. <br><a name="habracut"></a><br><h1>  Definition </h1><br>  First we give the classical definition of a topological space. <br><br>  <i>Let X be an arbitrary set.</i>  <i>A system œÑ of its subsets is called a topology if the following conditions are satisfied:</i> <i><br></i> <ol><li>  The empty set and the set X belong to the topology. </li><li>  The union of an arbitrary number of sets that belong to a topology belongs to a topology. </li><li>  The intersection of a finite number of sets belonging to a topology belongs to topology. </li></ol><br><br>  An arbitrary number of sets in this case means that we can also take associations of a countable or even an uncountable number of sets.  Naturally, this makes sense only in the case of infinite sets. <br><br>  As I said, everything in the computer is finite.  How our definition of topology will change if we assume that X is a finite set. <br><br>  It is easy to see that the definition will sound like this: <br>  <i>Let X be an arbitrary set of finite cardinality.</i>  <i>A system œÑ of its subsets is called a finite topology if the following conditions are satisfied:</i> <i><br></i> <ol><li>  The empty set and the set X belong to the topology. </li><li>  If two sets belong to topology, then their union belongs to topology </li><li>  If two sets belong to topology, then their intersection belongs to topology </li></ol><br><br>  For convenience, we will omit the word ‚Äúfinal‚Äù.  Note that topology is a set of sets.  Unfortunately, the standard classes for the set, represented in the Java language, did not suit me, mainly because the join and intersection operations in the Set interface change the set object, but I need to.  that the object is changed only when elements are added to it. <br><br>  Therefore, I created the following class to represent sets based on a linked list. <br><div class="spoiler">  <b class="spoiler_title">Class FSet &lt;T&gt;</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> generaltopology; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ T elem; Node next; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a)</span></span></span><span class="hljs-function"> </span></span>{ elem = a; next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } } Node first; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ first = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag= <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Node x = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !flag) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.elem.equals(a)) flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; x = x.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;T&gt; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; Node x = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; flag) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!b.contains(x.elem)) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; x = x.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a)</span></span></span><span class="hljs-function"> </span></span>{ Node x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Node(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contains(a)) { x.next = first; first = x; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FSet&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">union</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;T&gt; b)</span></span></span><span class="hljs-function"> </span></span>{ FSet&lt;T&gt; c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node a = first; a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; a = a.next) c.add(a.elem); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node a = b.first; a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; a = a.next) c.add(a.elem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FSet&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;T&gt; b)</span></span></span><span class="hljs-function"> </span></span>{ FSet&lt;T&gt; c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node a = first; a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; a = a.next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b.contains(a.elem)) c.add(a.elem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FSet&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;T&gt; b)</span></span></span><span class="hljs-function"> </span></span>{ FSet&lt;T&gt; c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node a = first; a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; a = a.next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!b.contains(a.elem)) c.add(a.elem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object b)</span></span></span><span class="hljs-function"> </span></span>{ FSet&lt;T&gt; bb = (FSet&lt;T&gt;)b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subset(bb) &amp;&amp; bb.subset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String s = <span class="hljs-string"><span class="hljs-string">"["</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node a = first; a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; a = a.next) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) s += a.elem + <span class="hljs-string"><span class="hljs-string">","</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s += a.elem; s += <span class="hljs-string"><span class="hljs-string">']'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; } }</code> </pre> <br></div></div><br>  This class is the main brick for building the final topology.  We now turn to the topology itself.  So far, I have only spoken about it, but have not said what a topological space is.  This is a pair (X, œÑ) of a set and its topology. <br><br>  Therefore, the advancement of the class looks like this (I want the set to consist of integers, but thanks to the use of generic classes, you can easily correct the code for an arbitrary type). <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topology</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FSet&lt;Integer&gt; EmptySet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); FSet&lt;Integer&gt; X; }</code> </pre><br><br>  Now the question is how the topology constructor should look.  Note that topology is always a system of subsets of the set X. <br><br>  So, here is the first independent task for you, dear reader.  Prove the following statement: <br><br>  <i>Let X be an arbitrary set.</i>  <i>Then the system œÑ consisting of the empty set and the set X forms a topology.</i> <br><br>  It was easy, right?  This topology is called trivial.  So let's always create a trivial topology at the beginning of use, adding the necessary sets later using the add method of the superclass. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Topology</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;Integer&gt; X)</span></span></span><span class="hljs-function"> </span></span>{ add(X); add(EmptySet); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.X = X; }</code> </pre><br><br>  But that is not all.  We added some element to the topology.  Does it remain a topology from the addition of an element or not?  Testing for the implementation of the second and third properties is easy to write, but the question is where to write it.  We cannot call it when adding an element, because then we will not be able to get a good topology due to the output of the error ‚ÄúAh, this is not a topology‚Äù.  So, at the creation stage, it is necessary to ‚Äúforgive‚Äù this error for a while, and only then make it a good kick: we will add a check box and a verification method <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> _isTopology; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isTopology</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; Node x = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; flag) { Node y = x.next; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (y != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; flag) { FSet&lt;Integer&gt; a = x.elem; FSet&lt;Integer&gt; b = y.elem; FSet&lt;Integer&gt; u = a.union(b); FSet&lt;Integer&gt; i = a.intersection(b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contains(u)) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!contains(i)) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; y = y.next; } x = x.next; } _isTopology = flag; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag;</code> </pre><br><br>  But it was just a warm-up.  Now we give a few more definitions. <br><br>  <i>The sets in the topology œÑ are called open.</i> <br>  <i>Sets that are complementary to open are called closed.</i> <br><br>  Most students are confused.  Here is the following task: <br><br>  <i>Let X = {1,2,3,4}, and œÑ = {‚àÖ, {1}, {2,4}, {1,2,4}, {1,2,3,4}}.</i>  <i>Determine if the following sets are open or closed?</i> <i><br></i>  <i>A = {1}</i> <i><br></i>  <i>B = {1,3}</i> <i><br></i>  <i>C = {1,2,3,4}</i> <i><br></i>  <i>D = {2,3}</i> <i><br></i> <br><br>  Naturally, the verification of these two properties is carried out by the following methods: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isOpen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;Integer&gt; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!a.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contains(a); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isClosed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;Integer&gt; a)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!a.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contains(X.complement(a)); }</code> </pre><br><br>  Exceptions are thrown if the system does not form a topology, or the transmitted set is not a subset of X of the topological space. <br>  If you slipped through the past task without trying to solve it, then you will be surprised why the second method is not called through the first one.  And if you decide, you will understand. <br><br><div class="spoiler">  <b class="spoiler_title">The answer to the previous problem</b> <div class="spoiler_text">  A is an open set.  It is included in the topology. <br>  B is a closed set.  It is the complement of the set {2,4} included in the topology. <br>  C - <b>open and closed set.</b>  It is open, because it is included in the topology.  But it is also closed, since it is the complement of the empty set that is included in the topology. <br>  D - <b>neither an open nor a closed set</b> , since neither it nor its complement are included in the topology. <br></div></div><br><br>  Next, you need to introduce the concept of neighborhood. <br><br>  <i>The neighborhood of the point x is any open set containing x</i> <br>  <i>The neighborhood of the set M is any open set G containing M</i> <br><br>  <i>Problem 3. Let a topological space from the previous problem be given.</i>  <i>Find all neighborhoods of points of the set X, as well as neighborhoods of the set {1,2}</i> <br><br>  Note that there can be several neighborhoods of both a point and a set.  Here I have already found a class that satisfies me: ArrayList.  Accordingly, I simply display a list of found neighborhoods. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList&lt;FSet&lt;Integer&gt;&gt; getNeighbourhoods(Integer x) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); ArrayList&lt;FSet&lt;Integer&gt;&gt; neighbourhoods = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Node a = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { FSet&lt;Integer&gt; open = a.elem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open.contains(x)) neighbourhoods.add(open); a = a.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbourhoods; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ArrayList&lt;FSet&lt;Integer&gt;&gt; getNeighbourhoods(FSet&lt;Integer&gt; M) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!M.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); ArrayList&lt;FSet&lt;Integer&gt;&gt; neighbourhoods = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Node a = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { FSet&lt;Integer&gt; open = a.elem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (M.subset(open)) neighbourhoods.add(open); a = a.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbourhoods; }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Answer to task 3</b> <div class="spoiler_text"><ol><li>  Neighborhood point 1: {1}, {1,2,4}, {1,2,3,4} </li><li>  Neighborhood point 2: {2,4}, {1,2,4}, {1,2,3,4} </li><li>  Neighborhoods point 3: {1,2,3,4} </li><li>  Neighborhood point 4: {2,4}.  {1,2,4}, {1,2,3,4} </li><li>  Neighborhood of the set {1,2}: {1,2,4}, {1,2,3,4} </li></ol><br><br></div></div><br><br>  In a topological space where such familiar terms as distance, metric or norm are absent, the neighborhood is the basic foundation for constructing geometry in such spaces. <br><br>  So some more definitions. <br><br>  <i>A point x from the set X is called a touch point of the set M lying in X if each neighborhood of the point x contains at least one point from M</i> <br>  <i>A point x from a set X is called a limit point of a set M lying in X if every neighborhood of x contains at least one point from M different from X</i> <br><br>  So, as always, as long as the knowledge is fresh, I offer you simple tasks after the definition, followed by code, and then a solution. <br><br>  <i>Problem 4. In the previous topological space, find the points of contact and limit points of the set M = {2,3}</i> . <br>  Note that the definition does not require belonging to a set of topology. <br><br>  The code for the corresponding points: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAdherencePoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer x, FSet&lt;Integer&gt; M)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!M.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (M.equals(EmptySet)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ArrayList&lt;FSet&lt;Integer&gt;&gt; neighbourhoods = getNeighbourhoods(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; neighbourhoods.size() &amp;&amp; flag) { FSet&lt;Integer&gt; a = neighbourhoods.get(i); FSet&lt;Integer&gt;.Node t = M.first; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsM = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !containsM) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.contains(t.elem)) containsM = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; t = t.next; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!containsM) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; i++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLimitPoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer x, FSet&lt;Integer&gt; M)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!M.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (M.equals(EmptySet)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ArrayList&lt;FSet&lt;Integer&gt;&gt; neighbourhoods = getNeighbourhoods(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; neighbourhoods.size() &amp;&amp; flag) { FSet&lt;Integer&gt; a = neighbourhoods.get(i); FSet&lt;Integer&gt;.Node t = M.first; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsM = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !containsM) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!t.elem.equals(x) &amp;&amp; a.contains(t.elem)) containsM = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; t = t.next; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!containsM) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; i++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  Touch Points: 2,3,4 <br>  Limit points: 3 <br></div></div><br><br>  Now we have everything to define an important concept in mathematics: the closure of a set. <br><br>  <i>The closure of the set M is the set of all its points of contact.</i>  It is usually denoted as [M]. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">FSet&lt;Integer&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getClosure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;Integer&gt; M)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!M.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); FSet&lt;Integer&gt; c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); FSet&lt;Integer&gt;.Node a = X.first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAdherencePoint(a.elem,M)) c.add(a.elem); a = a.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre><br><br>  Again, continuing to work with our topological space, we can see that [{2,3}] = {2,3,4}, while we got a closed set. <br><br>  Another important concept is the concept of an <i>isolated point.</i> <br><br>  <i>A point x is called an isolated point of the set M, if there exists a neighborhood of it that does not contain other points from M.</i> <br><br>  <i>Problem 5. Prove that x = 2 is an isolated point of the set M = {2,3}</i> <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIsolated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer x, FSet&lt;Integer&gt; M)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!M.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; ArrayList&lt;FSet&lt;Integer&gt;&gt; neighbourhoods = getNeighbourhoods(x); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; neighbourhoods.size() &amp;&amp; !flag) { FSet&lt;Integer&gt; a = neighbourhoods.get(i); FSet&lt;Integer&gt;.Node t = M.first; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> containsothers = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !containsothers) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!t.elem.equals(x) &amp;&amp; a.contains(t.elem)) containsothers = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; t = t.next; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!containsothers) flag =<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; i++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; }</code> </pre><br><br>  Further, it is necessary to understand that on the same set it is possible to introduce different topologies, thereby obtaining different spaces.  But between the topologies, you can establish a partial order. <br>  It is said that the topology of p1 is weaker than the topology of p2, if p1 is entirely contained in p2, and stronger otherwise. <br><br>  Obviously, the weakest topology is the trivial topology. <br>  <i>Problem 6. Let an arbitrary set X be given. Introduce the strongest topology on it.</i>  <i>List all open and closed sets.</i> <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Topology o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology || !o._isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (subset(o)) a = -<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (equals(o)) a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (o.subset(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  The strongest topology that can be introduced on the set X is the so-called discrete topology consisting of all the subsets of the set X. In it all the subsets of the set X are both open and closed at the same time. <br></div></div><br><br>  And the last concept I want to talk about in this article is a trace of topology. <br><br>  <i>The trace of the topology t on the set A, lying in X, is the topology t <sub>A</sub> , consisting of all sets of the form B ‚à© A, where B belongs to the topology.</i> <br><br>  <i>Problem 7. Prove that the trace of the topology of m on the set A forms a topology on the set A</i> <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Topology </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;Integer&gt; A)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_isTopology) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!A.subset(X)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"      "</span></span>); FSet&lt;Integer&gt; AX = A.intersection(X); Topology c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Topology(AX); Node f = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (f != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { c.add(f.elem.intersection(A)); f = f.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; }</code> </pre><br><br><h1>  Conclusion </h1><br>  This is the end of the first part of my series of articles on topological spaces and the programming of their subclass: finite topologies in the Java language.  In the next part, I plan to talk a little about the base topology, however, in the case of finite topologies, this concept is quite simplified, since finite topological spaces by default have a countable base, and we will see what happens next.  It is likely that we will talk about continuous mappings of one topological space to another.  It would be nice to try to program such an object, right? <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/248659/">https://habr.com/ru/post/248659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248645/index.html">Social networks in Russia, winter 2014-2015. Numbers, trends, forecasts</a></li>
<li><a href="../248647/index.html">Sample application using the library AQuery</a></li>
<li><a href="../248649/index.html">Access Control Approaches: RBAC vs. ABAC</a></li>
<li><a href="../248653/index.html">Video. Material Design Basic Principles</a></li>
<li><a href="../248657/index.html">Monitoring of servers from Infobox has become more convenient: notifications, monitoring of arbitrary ports, correct work with firewalls</a></li>
<li><a href="../248661/index.html">Interesting solutions for mobile ecommerce applications</a></li>
<li><a href="../248663/index.html">GNU Emacs. An article that I never found ...</a></li>
<li><a href="../248667/index.html">An example of using Fabric (Twitter Kit) in Android Studio</a></li>
<li><a href="../248669/index.html">Almost correct development on 1C, without revolutions</a></li>
<li><a href="../248671/index.html">"Bicycle" version checking site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>