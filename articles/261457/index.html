<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deploying the Postgres-xl Cluster for Dummies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. I want to share with habrovchanami my experience in deploying a cluster of Postgres-xl in the form of mini-instructions for dummies. There are ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deploying the Postgres-xl Cluster for Dummies</h1><div class="post__text post__text-html js-mediator-article">  Hello.  I want to share with habrovchanami my experience in deploying a cluster of Postgres-xl in the form of mini-instructions for dummies.  There are not many articles and manuals on deploying a postgres-xl cluster, but enough.  And they all have a couple of significant flaws in the eyes of a person like me, who has never worked on clustering and, moreover, has never worked in Linux-like axes before.  All articles of this kind are written for people already more or less familiar with Linux and deploying postgresql / postgres-xl in such an environment. <br><br>  Therefore, there was a desire to share with the rest of their achievements.  Next, I will step by step describe the entire deployment process, from downloading postgres-xl sources and compiling them, to configuring the cluster. <br><br>  Since there are a lot of ‚Äúfor experienced‚Äù articles already written, and in Habr√© too, I will omit the description of Postgres-xl itself, its components and their types (roles). <br><a name="habracut"></a><br><h2>  Part 1. Preparing the environment </h2><br>  For the test cluster, a configuration of 4 nodes was chosen: GTM, GTM-Standby and 2 nodes (GTM-proxy, Coordinator, Datanode): 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  GTM1 <br>  192.168.1.100 <br>  GTM-Active: 6666 <br><br></li><li>  GTM2 <br>  192.168.1.101 <br>  GTM-Stanby: 6666 <br><br></li><li>  NODE1 <br>  192.168.1.102 <br>  GTM-Proxy1: 6666 <br>  Coordinator1: 5432 <br>  Datanode1: 15432 <br><br></li><li>  NODE2 <br>  192.168.1.103 <br>  GTM-Proxy2: 6666 <br>  Coordinator2: 5432 <br>  Datanode2: 15432 <br></li></ul><br>  All nodes are virtualized machines with 1024 MB of RAM and a processor with a frequency of 2.1Ghz.  In choosing the OS distribution, I stopped at the latest version of CentOS 7.0, I will also omit its installation.  Installed the Minimal version. <br><br><h2>  Part 2. Installing dependencies </h2><br>  So, we have 4 clean machines with CentOS installed.  Before we start downloading sources from sourceforge, we first install the packages necessary for compiling the sources themselves. <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># yum install -y wget vim gcc make kernel-devel perl-ExtUtils-MakeMaker perl-ExtUtils-Embed readline-devel zlib-devel openssl-devel pam-devel libxml2-devel openldap-devel tcl-devel python-devel flex bison docbook-style-dsssl libxslt</span></span></code> </pre> <br>  Since  we have a clean installation of CentOS, then I added to this step the installation of wget - the download manager and vim - text editor.  Also, after installing the packages, it will not be superfluous to update the remaining packages with the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># yum update -y</span></span></code> </pre><br>  Waiting for the end of the update, proceed to the next part of the process. <br><br><h2>  Part 3. Download source code, compile it and install </h2><br>  To download the source code, execute the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># wget http://sourceforge.net/projects/postgres-xl/files/latest/download # mv download pgxl-9.2.src.tar.gz</span></span></code> </pre><br>  Or so: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># wget http://sourceforge.net/projects/postgres-xl/files/latest/download -O pgxl-9.2.src.tar.gz</span></span></code> </pre><br>  Copy the downloaded archive into the desired folder and unpack: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cp pgxl-9.2.src.tar.gz /usr/local/src/ # cd /usr/local/src/ # tar -xzvf pgxl-9.2.src.tar.gz</span></span></code> </pre><br>  The archive is unpacked into the postgres-xl folder, we check it with the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ls</span></span></code> </pre><br>  To compile the sources and install and run them later, we need a non-root user account, for example: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># useradd postgres # passwd postgres</span></span></code> </pre><br>  Next, enter and repeat the password, then grant the rights to this user on the entire source folder: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chown -R postgres.postgres postgres-xl # cd postgres-xl</span></span></code> </pre><br>  Now you need to configure source files with the help of ./configure before you start compiling them, I used this command with the following options: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ./configure --with-tcl --with-perl --with-python --with-pam --with-ldap --with-openssl --with-libxml</span></span></code> </pre><br>  More information about these options can be found on the official documentation page, <a href="http://files.postgres-xl.org/documentation/install-procedure.html">here</a> . <br><br>  If you do not need any module, you can not install it at the stage of installing dependencies, or use the standard configuration: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ./configure</span></span></code> </pre><br>  In order for compiled sources to be portable (in order not to perform all the previous steps on each of the cluster nodes), you need to add a couple more parameters --prefix and --disable-rpath.  As a result, the command for installation with default parameters will look like this: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ./configure --prefix=/usr/local/pgsql --disable-rpath</span></span></code> </pre><br>  The parameter <b>--prefix</b> is the installation path, it is '/ usr / local / pgsql' by default <br>  Parameter <b>--disable-rpath</b> - this parameter makes compiled source code portable. <br><br>  Now you can proceed directly to the compilation itself, you need to perform it on behalf of the user who was created earlier: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># su postgres $ gmake world</span></span></code> </pre><br>  or <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># su postgres -c 'gmake world'</span></span></code> </pre><br>  If the compilation was successful, the last line in the log should look like this: <br><br><pre> Postgres-XL, contrib and HTML documentation successfully made.  Ready to install.
</pre><br><br>  Everything!  Everything is compiled, you can copy the / usr / local / src / postgres-xl folder to the rest of the cluster nodes and install. <br><br>  Installation takes place on command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># gmake install-world</span></span></code> </pre><br>  Repeat this command on all nodes of the cluster and proceed to the configuration. <br><br><h2>  Part 4. Configuration </h2><br>  First you need to make some post-installation settings.  Declaring environment variables: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># echo 'export PGUSER=postgres' &gt;&gt; /etc/profile # echo 'export PGHOME=/usr/local/pgsql' &gt;&gt; /etc/profile # echo 'export PATH=$PATH:$PGHOME/bin' &gt;&gt; /etc/profile # echo 'export LD_LIBRARY_PATH=$PGHOME/lib' &gt;&gt; /etc/profile</span></span></code> </pre><br>  Then you need to re-log.  Logout do the team: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># exit</span></span></code> </pre><br>  Now we proceed to setting up the cluster nodes.  To begin, create a folder with data and initialize it in accordance with the role of the server. <br><br>  <b>GTM1 / GTM2</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># mkdir $PGHOME/gtm_data # chown -R postgres.postgres $PGHOME/gtm_data # su - postgres -c "initgtm -Z gtm -D $PGHOME/gtm_data"</span></span></code> </pre><br>  <b>NODE1</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># mkdir -p $PGHOME/data/data_gtm_proxy1 # mkdir -p $PGHOME/data/data_coord1 # mkdir -p $PGHOME/data/data_datanode1 # chown -R postgres.postgres $PGHOME/data/ # su - postgres -c "initdb -D $PGHOME/data/data_coord1/ --nodename coord1" # su - postgres -c "initdb -D $PGHOME/data/data_datanode1/ --nodename datanode1" # su - postgres -c "initgtm -D $PGHOME/data/data_gtm_proxy1/ -Z gtm_proxy"</span></span></code> </pre><br>  <b>NODE2</b> : <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># mkdir -p $PGHOME/data/data_gtm_proxy2 # mkdir -p $PGHOME/data/data_coord2 # mkdir -p $PGHOME/data/data_datanode2 # chown -R postgres.postgres $PGHOME/data/ # su - postgres -c "initdb -D $PGHOME/data/data_coord2/ --nodename coord2" # su - postgres -c "initdb -D $PGHOME/data/data_datanode2/ --nodename datanode2" # su - postgres -c "initgtm -D $PGHOME/data/data_gtm_proxy2/ -Z gtm_proxy"</span></span></code> </pre><br>  Next, edit the configuration files on the cluster nodes. <br><br>  <b>GTM1</b> : <br><br><div class="spoiler">  <b class="spoiler_title">gtm.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/gtm_data/gtm.conf nodename = 'gtm_master' listen_addresses = '*' port = 6666 startup = ACT log_file = 'gtm.log' log_min_messages = WARNING</span></span></code> </pre></div></div><br>  <b>GTM2</b> : <br><br><div class="spoiler">  <b class="spoiler_title">gtm.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/gtm_data/gtm.conf nodename = 'gtm_slave' listen_addresses = '*' port = 6666 startup = STANDBY active_host = 'GTM1' #   IP  GTM ,    '192.168.1.100' active_port = 6666 log_file = 'gtm.log' log_min_messages = WARNING</span></span></code> </pre></div></div><br>  <b>NODE1</b> : <br><br>  GTM_PROXY: <br><div class="spoiler">  <b class="spoiler_title">gtm_proxy.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_gtm_proxy1/gtm_proxy.conf nodename = 'gtm_proxy1' listen_addresses = '*' port = 6666 gtm_host = 'GTM1' gtm_port = 6666 log_file = 'gtm_proxy1.log' log_min_messages = WARNING</span></span></code> </pre><br></div></div><br><br>  COORDINATOR1 <br><div class="spoiler">  <b class="spoiler_title">postgresql.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_coord1/postgresql.conf listen_addresses = '*' port = 5432 pooler_port = 6667 gtm_host = 'localhost' #    /  gtm_proxy,    -  localhost gtm_port = 6666 pgxc_node_name = 'coord1'</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">pg_hba.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_coord1/pg_hba.conf host all all 192.168.1.0/24 trust</span></span></code> </pre></div></div><br><br>  DATANODE1 <br><div class="spoiler">  <b class="spoiler_title">postgresql.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_datanode1/postgresql.conf listen_addresses = '*' port = 15432 pooler_port = 6668 gtm_host = 'localhost' gtm_port = 6666 pgxc_node_name = 'datanode1'</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">pg_hba.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_datanode1/pg_hba.conf host all all 192.168.1.0/24 trust</span></span></code> </pre></div></div><br>  <b>NODE2</b> : <br><br>  GTM_PROXY: <br><div class="spoiler">  <b class="spoiler_title">gtm_proxy.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_gtm_proxy2/gtm_proxy.conf nodename = 'gtm_proxy2' listen_addresses = '*' port = 6666 gtm_host = 'GTM1' gtm_port = 6666 log_file = 'gtm_proxy2.log' log_min_messages = WARNING</span></span></code> </pre></div></div><br>  COORDINATOR2 <br><div class="spoiler">  <b class="spoiler_title">postgresql.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_coord2/postgresql.conf listen_addresses = '*' port = 5432 pooler_port = 6667 gtm_host = 'localhost' gtm_port = 6666 pgxc_node_name = 'coord2'</span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">pg_hba.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_coord2/pg_hba.conf host all all 192.168.1.0/24 trust</span></span></code> </pre></div></div><br><br>  DATANODE2 <br><div class="spoiler">  <b class="spoiler_title">postgresql.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_datanode2/postgresql.conf listen_addresses = '*' port = 15432 pooler_port = 6668 gtm_host = 'localhost' gtm_port = 6666 pgxc_node_name = 'datanode2'</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">pg_hba.conf</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi $PGHOME/data/data_datanode2/pg_hba.conf host all all 192.168.1.0/24 trust</span></span></code> </pre><br></div></div><br><br>  This is where the work with configs is completed.  The next step is to add exceptions to the CentOS firewall on all hosts: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># firewall-cmd --zone=public --add-port=5432/tcp --permanent # firewall-cmd --zone=public --add-port=15432/tcp --permanent # firewall-cmd --zone=public --add-port=6666/tcp --permanent # firewall-cmd --zone=public --add-port=6667/tcp --permanent # firewall-cmd --zone=public --add-port=6668/tcp --permanent # firewall-cmd --reload</span></span></code> </pre><br>  However, for GTM1 / GTM2 machines it will be enough to open only 6666 port. <br><br><h2>  Part 5. Running Cluster Nodes </h2><br>  Now we got directly to the launch of the cluster nodes.  To start the cluster nodes, you need to run the following commands on the appropriate nodes on behalf of the postgres user: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># su - postgres $ gtm_ctl start -Z gtm -D $PGHOME/{data_dir} $ gtm_ctl start -Z gtm_proxy -D $PGHOME/{data_dir} $ pg_ctl start -Z datanode -D $PGHOME/{data_dir} $ pg_ctl start -Z coordinator -D $PGHOME/{data_dir}</span></span></code> </pre><br>  Where ' <i>{data_dir}</i> ' is the name of the corresponding folder for GTM: ' <i>data / gtm_data</i> ', for datanode1 it is: ' <i>data / data_datanode1 /</i> ', etc. <br><br>  But I want to show you a different, more convenient way to control start / stop / startup. <br>  In the source folder there is a SysV script for PostgreSQL ‚Äúelegant control‚Äù.  Our task is to adapt it for each role of nodes in the cluster.  Let's see what the script itself is: <br><br><div class="spoiler">  <b class="spoiler_title">src / postgres-xl / contrib / start-scripts / linux</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cat /usr/local/src/postgres-xl/contrib/start-scripts/linux #! /bin/sh # chkconfig: 2345 98 02 # description: PostgreSQL RDBMS # This is an example of a start/stop script for SysV-style init, such # as is used on Linux systems. You should edit some of the variables # and maybe the 'echo' commands. # # Place this file at /etc/init.d/postgresql (or # /etc/rc.d/init.d/postgresql) and make symlinks to # /etc/rc.d/rc0.d/K02postgresql # /etc/rc.d/rc1.d/K02postgresql # /etc/rc.d/rc2.d/K02postgresql # /etc/rc.d/rc3.d/S98postgresql # /etc/rc.d/rc4.d/S98postgresql # /etc/rc.d/rc5.d/S98postgresql # Or, if you have chkconfig, simply: # chkconfig --add postgresql # # Proper init scripts on Linux systems normally require setting lock # and pid files under /var/run as well as reacting to network # settings, so you should treat this with care. # Original author: Ryan Kirkpatrick &lt;pgsql@rkirkpat.net&gt; # contrib/start-scripts/linux ## EDIT FROM HERE # Installation prefix prefix=/usr/local/pgsql # Data directory PGDATA="/usr/local/pgsql/data" # Who to run the postmaster as, usually "postgres". (NOT "root") PGUSER=postgres # Where to keep a log file PGLOG="$PGDATA/serverlog" # It's often a good idea to protect the postmaster from being killed by the # OOM killer (which will tend to preferentially kill the postmaster because # of the way it accounts for shared memory). Setting the OOM_SCORE_ADJ value # to -1000 will disable OOM kill altogether. If you enable this, you probably # want to compile PostgreSQL with "-DLINUX_OOM_SCORE_ADJ=0", so that # individual backends can still be killed by the OOM killer. #OOM_SCORE_ADJ=-1000 # Older Linux kernels may not have /proc/self/oom_score_adj, but instead # /proc/self/oom_adj, which works similarly except the disable value is -17. # For such a system, enable this and compile with "-DLINUX_OOM_ADJ=0". #OOM_ADJ=-17 ## STOP EDITING HERE # The path that is to be used for the script PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # What to use to start up the postmaster. (If you want the script to wait # until the server has started, you could use "pg_ctl start -w" here. # But without -w, pg_ctl adds no value.) DAEMON="$prefix/bin/postmaster" # What to use to shut down the postmaster PGCTL="$prefix/bin/pg_ctl" set -e # Only start if we can find the postmaster. test -x $DAEMON || { echo "$DAEMON not found" if [ "$1" = "stop" ] then exit 0 else exit 5 fi } # Parse command line parameters. case $1 in start) echo -n "Starting PostgreSQL: " test x"$OOM_SCORE_ADJ" != x &amp;&amp; echo "$OOM_SCORE_ADJ" &gt; /proc/self/oom_score_adj test x"$OOM_ADJ" != x &amp;&amp; echo "$OOM_ADJ" &gt; /proc/self/oom_adj su - $PGUSER -c "$DAEMON -D '$PGDATA' &amp;" &gt;&gt;$PGLOG 2&gt;&amp;1 echo "ok" ;; stop) echo -n "Stopping PostgreSQL: " su - $PGUSER -c "$PGCTL stop -D '$PGDATA' -s -m fast" echo "ok" ;; restart) echo -n "Restarting PostgreSQL: " su - $PGUSER -c "$PGCTL stop -D '$PGDATA' -s -m fast -w" test x"$OOM_SCORE_ADJ" != x &amp;&amp; echo "$OOM_SCORE_ADJ" &gt; /proc/self/oom_score_adj test x"$OOM_ADJ" != x &amp;&amp; echo "$OOM_ADJ" &gt; /proc/self/oom_adj su - $PGUSER -c "$DAEMON -D '$PGDATA' &amp;" &gt;&gt;$PGLOG 2&gt;&amp;1 echo "ok" ;; reload) echo -n "Reload PostgreSQL: " su - $PGUSER -c "$PGCTL reload -D '$PGDATA' -s" echo "ok" ;; status) su - $PGUSER -c "$PGCTL status -D '$PGDATA'" ;; *) # Print help echo "Usage: $0 {start|stop|restart|reload|status}" 1&gt;&amp;2 exit 1 ;; esac exit 0</span></span></code> </pre></div></div><br>  For all roles, copy this script into the directory ' <i>/etc/rc.d/init.d/</i> ' with some distinct name. <br>  I did something like this: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># cp /usr/local/src/postgres-xl/contrib/start-scripts/linux /etc/rc.d/init.d/pgxl_gtm # cp /usr/local/src/postgres-xl/contrib/start-scripts/linux /etc/rc.d/init.d/pgxl_gtm_prx # cp /usr/local/src/postgres-xl/contrib/start-scripts/linux /etc/rc.d/init.d/pgxl_dn # cp /usr/local/src/postgres-xl/contrib/start-scripts/linux /etc/rc.d/init.d/pgxl_crd</span></span></code> </pre><br>  Next, we begin to adapt the scripts for each specific instance on each node.  After some minor modifications, the GTM script looked like this (for convenience, I removed the comments and insignificant areas): <br><br><div class="spoiler">  <b class="spoiler_title">pgxl_gtm</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_gtm #! /bin/sh # chkconfig: 2345 98 02 # description: PostgreSQL RDBMS # Installation prefix prefix=/usr/local/pgsql # Data directory PGDATA="$prefix/gtm_data" # Who to run the postmaster as, usually "postgres". (NOT "root") PGUSER=postgres # Where to keep a log file PGLOG="$PGDATA/serverlog" # The path that is to be used for the script PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$prefix/bin # What to use to shut down the postmaster PGCTL="$prefix/bin/gtm_ctl" # Which cluster role PGROLE="gtm" set -e # Only start if we can find the postmaster. test -x $PGCTL || { echo "$PGCTL not found" if [ "$1" = "stop" ] then exit 0 else exit 5 fi } # Parse command line parameters. case $1 in start) echo -n "Starting PostgreSQL: " test x"$OOM_SCORE_ADJ" != x &amp;&amp; echo "$OOM_SCORE_ADJ" &gt; /proc/self/oom_score_adj test x"$OOM_ADJ" != x &amp;&amp; echo "$OOM_ADJ" &gt; /proc/self/oom_adj su - $PGUSER -c "$PGCTL start -Z $PGROLE -D '$PGDATA' &amp;" &gt;&gt;$PGLOG 2&gt;&amp;1 echo "ok" ;; stop) echo -n "Stopping PostgreSQL: " su - $PGUSER -c "$PGCTL stop -Z $PGROLE -D '$PGDATA' -m fast" echo "ok" ;; restart) echo -n "Restarting PostgreSQL: " su - $PGUSER -c "$PGCTL stop -Z $PGROLE -D '$PGDATA' -m fast -w" test x"$OOM_SCORE_ADJ" != x &amp;&amp; echo "$OOM_SCORE_ADJ" &gt; /proc/self/oom_score_adj test x"$OOM_ADJ" != x &amp;&amp; echo "$OOM_ADJ" &gt; /proc/self/oom_adj su - $PGUSER -c "$PGCTL start -Z $PGROLE -D '$PGDATA' &amp;" &gt;&gt;$PGLOG 2&gt;&amp;1 echo "ok" ;; reload) echo -n "Reload PostgreSQL: " su - $PGUSER -c "$PGCTL restart -Z $PGROLE -D '$PGDATA'" echo "ok" ;; status) su - $PGUSER -c "$PGCTL status -Z $PGROLE -D '$PGDATA'" ;; *) # Print help echo "Usage: $0 {start|stop|restart|reload|status}" 1&gt;&amp;2 exit 1 ;; esac exit 0</span></span></code> </pre></div></div><br>  As you can see, I added ' <i>$ PGHOME / bin</i> ' to the PATH variable, removed DAEMON, and in the PGCTL I registered the path to the gtm_ctl utility in the ' <i>$ PGHOME / bin</i> ' <i>directory</i> for managing GTM and GTM_PROXY roles, also added the PGROLE variable necessary for launching nodes cluster. <br><br>  In order to use such a script for the remaining roles in the cluster, you need to edit only 3 variables: PGDATA, PGROLE, PGCTL. <br><br>  <b>PGDATA</b> is the path to the data directory for this node role. <br>  <b>PGROLE</b> - the role of this instance in the cluster.  It happens gtm, gtm_proxy, coordinator, datanode. <br>  <b>PGCTL</b> is a server startup utility, for gtm and gtm_proxy it is ' <i>gtm_ctl</i> ', and for coordinator and datanode it is ' <i>pg_ctl</i> ' <br><br>  Here are the complete changes for the remaining nodes in our test cluster: <br><br>  <b>GTM_PROXY1</b> : <br><div class="spoiler">  <b class="spoiler_title">pgxl_gtm_prx</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_gtm_prx PGDATA="$prefix/data/data_gtm_proxy1" PGCTL="$prefix/bin/gtm_ctl" PGROLE="gtm_proxy"</span></span></code> </pre><br></div></div><br>  <b>GTM_PROXY2</b> : <br><div class="spoiler">  <b class="spoiler_title">pgxl_gtm_prx</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_gtm_prx PGDATA="$prefix/data/data_gtm_proxy2" PGCTL="$prefix/bin/gtm_ctl" PGROLE="gtm_proxy"</span></span></code> </pre><br></div></div><br>  <b>COORDINATOR1</b> : <br><div class="spoiler">  <b class="spoiler_title">pgxl_crd</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_crd PGDATA="$prefix/data/data_coord1" PGCTL="$prefix/bin/pg_ctl" PGROLE="coordinator"</span></span></code> </pre><br></div></div><br>  <b>COORDINATOR2</b> : <br><div class="spoiler">  <b class="spoiler_title">pgxl_crd</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_crd PGDATA="$prefix/data/data_coord2" PGCTL="$prefix/bin/pg_ctl" PGROLE="coordinator"</span></span></code> </pre><br></div></div><br>  <b>DATANODE1</b> : <br><div class="spoiler">  <b class="spoiler_title">pgxl_dn</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_dn PGDATA="$prefix/data/data_datanode1" PGCTL="$prefix/bin/pg_ctl" PGROLE="datanode"</span></span></code> </pre><br></div></div><br>  <b>DATANODE2</b> : <br><div class="spoiler">  <b class="spoiler_title">pgxl_dn</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># vi /etc/rc.d/init.d/pgxl_dn PGDATA="$prefix/data/data_datanode2" PGCTL="$prefix/bin/pg_ctl" PGROLE="datanode"</span></span></code> </pre><br></div></div><br>  Almost done!  Now we need to make these scripts executable by running the corresponding command on each node: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chmod a+x /etc/rc.d/init.d/pgxl_gtm # chmod a+x /etc/rc.d/init.d/pgxl_gtm_prx # chmod a+x /etc/rc.d/init.d/pgxl_crd # chmod a+x /etc/rc.d/init.d/pgxl_dn</span></span></code> </pre><br>  Now add scripts to load: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># chkconfig --add pgxl_gtm # chkconfig --add pgxl_gtm_prx # chkconfig --add pgxl_crd # chkconfig --add pgxl_dn</span></span></code> </pre><br>  And run: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># service pgxl_gtm start # service pgxl_gtm_prx start # service pgxl_crd start # service pgxl_dn start</span></span></code> </pre><br>  How the launch went you can see in the log file in the data directory, or you can run the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># service pgxl_gtm status # service pgxl_gtm_prx status # service pgxl_crd status # service pgxl_dn status</span></span></code> </pre><br>  If everything went successfully proceed to configure the nodes. <br><br><h2>  Part 6. Configuring Cluster Nodes </h2><br>  Perform the configuration of the cluster nodes in accordance with the manual: <br><br><div class="spoiler">  <b class="spoiler_title">NODE1</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># su - postgres $ psql -p 5432 -c "DELETE FROM pgxc_node" $ psql -p 5432 -c "CREATE NODE coord1 WITH (TYPE='coordinator',HOST='192.168.1.102',PORT=5432)" $ psql -p 5432 -c "CREATE NODE coord2 WITH (TYPE='coordinator',HOST='192.168.1.103',PORT=5432)" $ psql -p 5432 -c "CREATE NODE datanode1 WITH (TYPE='datanode',HOST='192.168.1.102',PORT=15432)" $ psql -p 5432 -c "CREATE NODE datanode2 WITH (TYPE='datanode',HOST='192.168.1.103',PORT=15432)"</span></span></code> </pre></div></div><br>  Check what happened with the command: <br><br><pre> <code class="bash hljs">$ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"select * from pgxc_node"</span></span></code> </pre><br>  If everything is fine, restart the pool: <br><br><pre> <code class="bash hljs">$ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"select pgxc_pool_reload()"</span></span></code> </pre><br>  If the configuration is successful, the command will return ' <i>t</i> ', that is, <i>true</i> . <br><br>  After this step, most manuals start creating test tables and performing test queries, but with a guarantee of 99.9%, I will tell you - when you try to perform INSERT, you will get these records in the logs: <br><pre> STATEMENT: insert into test select 112233445566, 0123456789;
 ERROR: Invalid Datanode number
</pre><br>  or here <br><pre> STATEMENT: SET global_session TO coord2_21495; SET datestyle TO iso; SET client_min_messages TO notice; SET client_encoding TO UNICODE; SET bytea_output TO escape;
 ERROR: Invalid Datanode number
 STATEMENT: Remote Subplan
 ERROR: node "coord2_21580" does not exist
 STATEMENT: SET global_session TO coord2_21580; SET datestyle TO iso; SET client_min_messages TO notice; SET client_encoding TO UNICODE; SET bytea_output TO escape;
 ERROR: Invalid Datanode number
 STATEMENT: Remote Subplan
 ERROR: Invalid Datanode number
 STATEMENT: Remote Subplan
 ERROR: Invalid Datanode number
 STATEMENT: Remote Subplan
 LOG: Will fall back to local snapshot for XID = 96184, source = 0, gxmin = 0, autovac launch = 0, autovac = 0, normProcMode = 0, postEnv = 1
 ERROR: node "coord2_22428" does not exist
 STATEMENT: SET global_session TO coord2_22428;
 ERROR: Invalid Datanode number
</pre><br>  And this is because in abstruse manuals ‚Äúfor experienced‚Äù, where everything is just like two fingers on the asphalt, an important step is missed - filling in the other nodes in DATANODEs themselves.  And this is done quite simply, on both data nodes in our configuration we do the following: <br><br><pre> <code class="bash hljs">$ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"EXECUTE DIRECT ON (datanode1) 'DELETE FROM pgxc_node'"</span></span> $ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"EXECUTE DIRECT ON (datanode1) 'create NODE coord1 WITH (TYPE=''coordinator'',HOST=''192.168.1.102'',PORT=5432)'"</span></span> $ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"EXECUTE DIRECT ON (datanode1) 'create NODE coord2 WITH (TYPE=''coordinator'',HOST=''192.168.1.103'',PORT=5432)'"</span></span> $ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"EXECUTE DIRECT ON (datanode1) 'create NODE datanode1 WITH (TYPE=''datanode'',HOST=''192.168.1.102'',PORT=15432)'"</span></span> $ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"EXECUTE DIRECT ON (datanode1) 'create NODE datanode2 WITH (TYPE=''datanode'',HOST=''192.168.1.103'',PORT=15432)'"</span></span> $ psql -p 5432 -c <span class="hljs-string"><span class="hljs-string">"EXECUTE DIRECT ON (datanode1) 'SELECT pgxc_pool_reload()'"</span></span></code> </pre><br>  Respectively line <br><pre> EXECUTE DIRECT ON (datanode1)
</pre><br>  change to <br><pre> EXECUTE DIRECT ON (datanode2)
</pre><br>  for node number 2. <br><br>  And voila!  Now you can safely create tables and test our cluster.  But that's another story ... <br><br><h2>  Conclusion </h2><br>  That's all, everything is set up and everything works, it would seem - there is nothing complicated, this article hides a whole week of searching and smoking manuals.  The download / compile and source installation stage seems to be the most innocuous now, but in fact there were also some problems there (of course, it was my inexperience in working on such an environment), for example, the code stubbornly did not want to compile and threw such an error: <br><br><pre> '/ usr / bin / perl' /bin/collateindex.pl -f -g -i 'bookindex' -o bookindex.sgml HTML.index
 Can't open perl script "/bin/collateindex.pl": No such file or directory
 make [4]: ‚Äã‚Äã*** [bookindex.sgml] Error 2
 make [4]: ‚Äã‚ÄãLeaving directory `/ usr / local / src / postgres-xl / doc-xc / src / sgml '
 make [3]: *** [sql_help.h] Error 2
 make [3]: Leaving directory `/ usr / local / src / postgres-xl / src / bin / psql '
 make [2]: *** [all-psql-recurse] Error 2
 make [2]: Leaving directory `/ usr / local / src / postgres-xl / src / bin '
 make [1]: *** [all-bin-recurse] Error 2
 make [1]: Leaving directory `/ usr / local / src / postgres-xl / src '
 make: *** [all-src-recurse] Error 2
</pre><br>  Later, in some Chinese forum I found the answer that I need to install the <b>docbook-style-dsssl library,</b> and so on, every new surprise brought me to a standstill due to lack of experience and complete manuals (for dummies like me) as such. <br><br>  But still, after a week of searching for information, hundreds of trial and error, everything worked out and the cluster started up. <br>  I hope someone this publication even a little bit will make life easier or will be useful. <br><br>  Next, I plan to do the Load-Balance setup, migrate the base from the usual PostgreSQL 9.4 running Windows to the assembled postgres-xl 9.2 cluster on CentOS 7.0, how to test the hardest queries in our project already in the cluster, compare with the results of Standalone PostgreSQL, do tuning cluster settings, play with PostGIS in a cluster, etc.  So, if this article or any of the things that I have listed is useful to the Habrovans, I will be happy to share it with you. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/261457/">https://habr.com/ru/post/261457/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261447/index.html">How to create a background HTML5 video in an email message</a></li>
<li><a href="../261449/index.html">The first Soviet transistors work</a></li>
<li><a href="../261451/index.html">Throwable exception and php7 errors</a></li>
<li><a href="../261453/index.html">Stash Contest: How to Get a License from JetBrains for Your Code</a></li>
<li><a href="../261455/index.html">Truly responsive letters. Part one</a></li>
<li><a href="../261459/index.html">Analysis of tasks of the Competitive Intelligence Competition on PHDays V</a></li>
<li><a href="../261461/index.html">Automate routine operations between Excel and AutoCAD using VBA</a></li>
<li><a href="../261463/index.html">Comparing the speed of .NET providers for working with Oracle DB</a></li>
<li><a href="../261467/index.html">Rapid development on 1C-Bitrix or how I met gulp</a></li>
<li><a href="../261469/index.html">Love and mathematics. Heart of hidden reality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>