<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We work with a USB stack nRF24LU1 +. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continued, the first part is here . 
 Simplified USB structure. It can be seen that there are only two interrupts USBIRQ and USBWU 


 USB initializat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We work with a USB stack nRF24LU1 +. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Continued, the first part is <a href="http://geektimes.ru/post/260142/">here</a> . <br>  Simplified USB structure.  It can be seen that there are only two interrupts USBIRQ and USBWU <br><img src="https://habrastorage.org/files/703/6b2/dd7/7036b2dd75044ad7b37b8c1901bec6e4.PNG"><br><a name="habracut"></a><br><h4>  USB initialization </h4><br>  Nothing complicated, register descriptions, see datashite.  Allow endpoint 0-2, enable interrupts, specify buffers for data storage.  (Endpoint 2 and 3 are allowed to work with double buffer when sending data to the host) <br><div class="spoiler">  <b class="spoiler_title">USB initialization</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usb_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Setup state information usb_state = DEFAULT; usb_bm_state = 0; // Setconfig configuration information usb_current_config = 0; usb_current_alt_interface = 0; // Disconnect from USB-bus since we are in this routine from a power on and not a soft reset: usbcs |= 0x08; delay_ms(50); usbcs &amp;= ~0x08; /*intterrupt enable uresie,suspie,sutokie,sudavie */ usbien = 0x1d; /*Endpoint 0 to 5 IN interrupt enables (in_ien)*/ in_ien = 0x01; /*Endpoints 0 to 5 IN interrupt request register (in_irq) - clear interrupt*/ in_irq = 0x1f; /*Endpoint 0 to 5 OUT interrupt enables (out_ien)*/ out_ien = 0x01; /*Endpoints 0 to 5 OUT interrupt request register (out_irq) - clear in interrupt*/ out_irq = 0x1f; // Setup the USB RAM with some OK default values: bout1addr = MAX_PACKET_SIZE_EP0/2; bout2addr = MAX_PACKET_SIZE_EP0/2 + USB_EP1_SIZE/2; bout3addr = MAX_PACKET_SIZE_EP0/2 + 2*USB_EP1_SIZE/2; bout4addr = MAX_PACKET_SIZE_EP0/2 + 3*USB_EP1_SIZE/2; bout5addr = MAX_PACKET_SIZE_EP0/2 + 4*USB_EP1_SIZE/2; binstaddr = 0xc0; bin1addr = MAX_PACKET_SIZE_EP0/2; bin2addr = MAX_PACKET_SIZE_EP0/2 + USB_EP1_SIZE/2; bin3addr = MAX_PACKET_SIZE_EP0/2 + 2*USB_EP1_SIZE/2; bin4addr = MAX_PACKET_SIZE_EP0/2 + 3*USB_EP1_SIZE/2; bin5addr = MAX_PACKET_SIZE_EP0/2 + 4*USB_EP1_SIZE/2; // Set all endpoints to not valid (except EP0IN and EP0OUT) /*Endpoints 0 to 5 IN valid bits (Inbulkval)*/ inbulkval = 0x01; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ outbulkval = 0x01; /*Isochronous IN endpoint valid bits (inisoval)*/ inisoval = 0x00; /*Isochronous OUT endpoint valid bits (outisoval)*/ outisoval = 0x00; /* Switch ON Endpoint 1 */ /*Endpoint 0 to 5 OUT interrupt enables (out_ien)* - out1ien */ in_ien |= 0x02; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ inbulkval |= 0x02; /*Endpoint 0 to 5 OUT interrupt enables (out_ien)*/ out_ien |= 0x02; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ outbulkval |= 0x02; /* Endpoint 0 to 5 OUT byte count registers (outxbc) ?Maybe 0xff is register clear*/ out1bc = 0xff; /* Switch ON Endpoint 2 */ /*Endpoint 0 to 5 OUT interrupt enables (out_ien)* - out1ien */ in_ien |= 0x04; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ inbulkval |= 0x04; /*Endpoint 0 to 5 OUT interrupt enables (out_ien)*/ out_ien |= 0x04; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ outbulkval |= 0x04; /* Endpoint 0 to 5 OUT byte count registers (outxbc) ?Maybe 0xff is register clear*/ out2bc = 0xff; /* Switch ON Endpoint 3 */ /*Endpoint 0 to 5 OUT interrupt enables (out_ien)* - out1ien */ in_ien |= 0x08; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ inbulkval |= 0x08; /*Endpoint 0 to 5 OUT interrupt enables (out_ien)*/ out_ien |= 0x08; /*Endpoints 0 to 5 OUT valid bits (outbulkval)*/ outbulkval |= 0x08; /* Endpoint 0 to 5 OUT byte count registers (outxbc) ?Maybe 0xff is register clear*/ out3bc = 0xff; }</span></span></code> </pre> <br></div></div><br>  Then we enable overlapping of USBIRQ (further we need to analyze the flags) and enable interrupts globally: <br><pre> <code class="cpp hljs">USB = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// USBIRQ is mapped to IEN1.4 EA = 1; // enable global interrupt</span></span></code> </pre><br>  Actually this is the whole initialization.  At each interruption, a handler will be called which looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USB interrupt request */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usb_irq_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> interrupt INTERRUPT_USB_INT </span></span>{ usb_irq(); }</code> </pre><br><br><h4>  USB interrupt handler </h4><br>  This is the basis of our system.  All the action will be spinning here.  What event occurred we will understand after analyzing the register IVEC. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usb_irq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> temp_irq; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ivec == INT_USBRESET) { <span class="hljs-comment"><span class="hljs-comment">/*The USB interrupt request register (usbirq) - clear USB reset interrupt request*/</span></span> usbirq = <span class="hljs-number"><span class="hljs-number">0x10</span></span>; usb_state = DEFAULT; usb_current_config = <span class="hljs-number"><span class="hljs-number">0</span></span>; usb_current_alt_interface = <span class="hljs-number"><span class="hljs-number">0</span></span>; usb_bm_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ivec) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_SUDAV: <span class="hljs-comment"><span class="hljs-comment">/*Setup data valid interrupt*/</span></span> usbirq = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; isr_sudav(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_SOF: <span class="hljs-comment"><span class="hljs-comment">/*Start of frame interrupt (sofir)*/</span></span> usbirq = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_SUTOK: <span class="hljs-comment"><span class="hljs-comment">/*Setup token interrupt*/</span></span> usbirq = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; packetizer_data_ptr = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; packetizer_data_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; packetizer_pkt_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_SUSPEND: <span class="hljs-comment"><span class="hljs-comment">/*Suspend interrupt (suspir)*/</span></span> usbirq = <span class="hljs-number"><span class="hljs-number">0x08</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_EP0IN: in_irq = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; packetizer_isr_ep0_in(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_EP0OUT: out_irq = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; packetizer_data_size = <span class="hljs-number"><span class="hljs-number">0</span></span>; USB_EP0_HSNAK(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_EP1IN: in_irq = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; int_ep1in_handler(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_EP1OUT: out_irq = <span class="hljs-number"><span class="hljs-number">0x02</span></span>; out1bc = <span class="hljs-number"><span class="hljs-number">0xff</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> INT_EP2IN: in_irq = <span class="hljs-number"><span class="hljs-number">0x04</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><br><h4>  Enumeration </h4><br>  Perhaps, use the quote from the wonderful guide <a href="http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part2.html">USB in a NutShell - guide to the standard USB</a> <br><blockquote>  Enumeration is the process of determining the fact that a device is actually connected to the USB bus and what parameters it requires - power consumption, <br>  the number and type of the end point (or points), the device class, etc. In the enumeration process, the host assigns an address to the device and allows configuration, <br>  allowing the device to transfer data over the bus.  [...] <br>  The general enumeration process under the Windows operating system includes the following steps: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. The host or hub detects the connection of a new device using pull-up resistors, which the device connects to a pair of data signal wires (D + and D-).  The host makes a delay of at least 100 ms, which allows you to insert the connector completely and stabilize the device power supply. <br>  2. The host issues a reset to the bus, which puts the device in the default state.  The device can now respond to the default zero address. <br>  3. The MS Windows host requests the first 64 bytes of the device descriptor (Device Descriptor). <br>  4. After receiving the first 8 bytes of the device descriptor, the host immediately issues a new bus reset. <br>  5. Now the host issues the Set Address command, which puts the device into addressable state. <br>  6. The host requests all 18 bytes of the device descriptor. <br>  7. It then requests 9 bytes of the Configuration Descriptor to determine its full size. <br>  8. The host requests 255 bytes of the configuration descriptor. <br>  9. The host requests all string descriptors (String Descriptors), if any. <br></blockquote><br>  To support WinUSB, an additional procedure is required: <br><ul><li>  In step 9, Windows will request a non-standard 0xEE string handle.  It is the correct answer that starts the further data exchange procedures for WinUSB. </li><li>  Next comes the Extended Compat ID OS Descriptor request. </li><li>  The last is Extended Properties OS Descriptor.  This is where the device reports its GUID. </li></ul><br>  I recommend this <a href="http://searchingforbit.blogspot.ru/2014/05/winusb-communication-with-stm32-round-2.html">manual</a> for understanding the process. <br><br>  For analysis and debugging, the minimum set is the UART on the controller side and the USB software analyzer on the host.  I recommend the free <a href="http://www.microsoft.com/en-us/download/details.aspx%3Fid%3D44226">Microsoft Message Analyzer</a> . <br><br>  So, all enumeration (and subsequent vendor requset and other requests, if needed) will be processed in the function isr_sudav () (Setup data valid interrupt). <br><div class="spoiler">  <b class="spoiler_title">isr_sudav ()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isr_sudav</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bmRequestType = setupbuf[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/* Host-to-device standart request */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((bmRequestType &amp; <span class="hljs-number"><span class="hljs-number">0x60</span></span> ) == <span class="hljs-number"><span class="hljs-number">0x00</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(setupbuf[<span class="hljs-number"><span class="hljs-number">1</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_GET_DESCRIPTOR: usb_process_get_descriptor(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_GET_STATUS: usb_process_get_status(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_SET_ADDRESS: usb_state = ADDRESSED; usb_current_config = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_GET_CONFIGURATION: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(usb_state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ADDRESSED: in0buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; in0bc = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CONFIGURED: in0buf[<span class="hljs-number"><span class="hljs-number">0</span></span>] = usb_current_config; in0bc = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ATTACHED: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> POWERED: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SUSPENDED: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DEFAULT: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: USB_EP0_STALL(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_SET_CONFIGURATION: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(setupbuf[<span class="hljs-number"><span class="hljs-number">2</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: usb_state = ADDRESSED; usb_current_config = <span class="hljs-number"><span class="hljs-number">0x00</span></span>; USB_EP0_HSNAK(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x01</span></span>: usb_state = CONFIGURED; usb_bm_state |= USB_BM_STATE_CONFIGURED; usb_current_config = <span class="hljs-number"><span class="hljs-number">0x01</span></span>; USB_EP0_HSNAK(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: USB_EP0_STALL(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> USB_REQ_GET_INTERFACE: <span class="hljs-comment"><span class="hljs-comment">// GET_INTERFACE in0buf[0] = usb_current_alt_interface; in0bc = 0x01; break; case USB_REQ_SET_DESCRIPTOR: case USB_REQ_SET_INTERFACE: // SET_INTERFACE case USB_REQ_SYNCH_FRAME: // SYNCH_FRAME default: USB_EP0_STALL(); break; } } // bmRequestType = 0 01 xxxxx : Data transfer direction: Host-to-device, Type: Class else if((bmRequestType &amp; 0x60 ) == 0x20) // Class request { if(setupbuf[6] != 0 &amp;&amp; ((bmRequestType &amp; 0x80) == 0x00)) { // If there is a OUT-transaction associated with the Control-Transfer-Write we call the callback // when the OUT-transaction is finished. Note that this function do not handle several out transactions. out0bc = 0xff; } else { USB_EP0_HSNAK(); } } /* Extended Compat ID OS Descriptor setupbuf[1] (bRequest) is equal to MS_VendorCode (0xAA is current program)*/ else if(bmRequestType == 0xC0 &amp;&amp; setupbuf[1] == MS_VENDORCODE) { packetizer_pkt_size = MAX_PACKET_SIZE_EP0; //xprintf("Extended Compat ID\r"); packetizer_data_ptr = g_usb_extended_compat_id; packetizer_data_size = MIN(setupbuf[6], packetizer_data_ptr[0]); packetizer_isr_ep0_in(); } /* Extended Properties OS Descriptor */ else if(bmRequestType == 0xC1 &amp;&amp; setupbuf[1] == MS_VENDORCODE) { packetizer_pkt_size = MAX_PACKET_SIZE_EP0; //xprintf("Extended Properties ID\r"); packetizer_data_ptr = g_usb_extended_proper_os; packetizer_data_size = MIN(setupbuf[6], packetizer_data_ptr[0]); packetizer_isr_ep0_in(); } else // Unknown request type { USB_EP0_STALL(); } }</span></span></code> </pre><br></div></div><br>  The penultimate two branches in this function are responsible for Extended Compat ID OS Descriptor and Extended Properties OS Descriptor requests. <br>  At this stage, the enumeration is completed, you can proceed to receive / transmit data. <br><br><h4>  Bulk tranfer </h4><br><h5>  In tranfer </h5><br><img src="https://habrastorage.org/files/606/5e2/8dc/6065e28dce21448a8dbf21969dd16a45.PNG"><br>  The host wants to accept data.  Sends In token.  If the inxbsy bit (x is the endpoint number) is set, the USB controller sends data to the host.  In order to set this bit itself, we must first load the data into the inxbuf [] buffer and tell how much we have written to the inxbc register, i.e.  data must be preloaded before interruption. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int_ep1in_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">64</span></span>;i++){ in1buf[i]=i; } in1bc = <span class="hljs-number"><span class="hljs-number">64</span></span>; }</code> </pre><br>  After successfully sending the data - received an ACK - the INT_EP1IN interrupt occurs (usb_irq function) and the next piece of data can be loaded into it. <br><br><h5>  Out tranfer </h5><br><img src="https://habrastorage.org/files/a84/bab/66b/a84bab66bcc540faa978062c17781ba7.PNG"><br>  The host wants to send data.  Sends out token.  Next to the token are data.  After the data is received, the INT_EP1OUT interrupt is triggered.  Data is read from the outxbuf [] buffer.  The size of the data is outxbc.  After the data have been processed, it is necessary to write any value to the outxbc register, thereby letting the USB controller know that we are ready to receive the next piece of data. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int_ep1out_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ do_anything(out1buf,in1bc); in1bc = <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">//dummy write }</span></span></code> </pre><br><br><h5>  Double buffering </h5><br>  If the task is to send or receive data with maximum speed, then you need to use double buffering.  While the controller is busy receiving or sending data, its buffers (inxbuf and outxbuf) are not available.  The idea is that an additional buffer appears, where we write when the controller is busy, and then just switch them. <br>  For this mode is responsible register usbpair.  For example, writing 0x01 there we combine 2 and 3 in endpoint.  The endpoint 3 buffer will be the second buffer. <br><img src="https://habrastorage.org/files/4ce/9fd/880/4ce9fd88028c43b3b12d742ac3896923.PNG"><br>  However, the documentation on this mode is extremely incomprehensible and sometimes mutually exclusive.  Through long experiments, I got this service code buffers for transmission to the host: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(in2cs != <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i%<span class="hljs-number"><span class="hljs-number">2</span></span>){ <span class="hljs-comment"><span class="hljs-comment">//first buffer for(i=0;i&lt;64;i++) in2buf[i]=0xAA; in2bc = 64; } else { //second buffer for(i=0;i&lt;64;i++) in3buf[i]=0xBB; in2bc = 64; } i++; }</span></span></code> </pre><br>  We wait until IN 2 is free and in turn we pour the data then in in2buf then in3buf, then all the while we update in2bc (!!!).  <i>The code is not specifically tested, use with caution.</i> <br><br><h4>  We program Host </h4><br>  All code was written in Visual Studio 2013. Immediately install a Windows Driver Kit (WDK).  It adds USB project templates.  I advise you to study a couple of manuals from Microsoft, everything is detailed there: <br><ul><li>  <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/dn376872(v%3Dvs.85).aspx">Write a Windows desktop app based on the WinUSB template</a> </li><li>  <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff540174(v%3Dvs.85).aspx">How to Access a USB Device by Using WinUSB Functions</a> </li></ul><br>  The program is simple to impossible: open the device, get a descriptor, read and write in the pipe.  Everything. <br><br><h4>  Speed ‚Äã‚Äãmeasurement </h4><br>  Here are the results achieved: <br><table><tbody><tr><td>  Data transfer to host in single buffer </td><td>  360 kb / s </td></tr><tr><td>  Data transfer to host in double buffer </td><td>  510 kb / s </td></tr><tr><td>  Receive data from single buffer host </td><td>  230 kb / s </td></tr><tr><td>  Receive data from host double buffer </td><td>  not tested </td></tr></tbody></table><br><h4>  Conclusion </h4><br>  I hope the article will benefit beginners and not only.  The source is not very combed, do not kick much, I post it on the githab, use it for health. <br>  <a href="https://github.com/covsh/workingtitle/tree/master/nRF24LU1P">github.com/covsh/workingtitle/tree/master/nRF24LU1P</a> </div><p>Source: <a href="https://habr.com/ru/post/367955/">https://habr.com/ru/post/367955/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../367941/index.html">Monoprice Sport Earbud Headphone Review</a></li>
<li><a href="../367943/index.html">The Japanese have created a hydrogel that works as an artificial muscle.</a></li>
<li><a href="../367949/index.html">The corporations are evil. Okay, Google: how to destroy humanity?</a></li>
<li><a href="../367951/index.html">A new technique allows you to create a conductive glass that lets even more light than normal</a></li>
<li><a href="../367953/index.html">Inside from Master Keith: how to assemble a 3D printer with your own hands for 12,330 rubles</a></li>
<li><a href="../367957/index.html">New Github Desktop</a></li>
<li><a href="../367959/index.html">The free MyShake app developed at the Berkeley University lab will turn a smartphone into a mini seismograph</a></li>
<li><a href="../367963/index.html">Apple promises to solve the ‚Äú1970 problem‚Äù with the next update.</a></li>
<li><a href="../367965/index.html">The myth of "cyberpsychosis" and intolerance to cyborg</a></li>
<li><a href="../367967/index.html">Sober look at the breathalyzer - review of semiconductor DrinkMate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>