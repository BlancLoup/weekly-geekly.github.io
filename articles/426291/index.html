<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Two Z80 on one machine: what was the difference between 8-bit arcade machines and home computers?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What I learned about the arcade machine Bomb Jack in the process of creating its emulator 


 Recently, I wrote a small Bomb Jack emulator, mainly to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Two Z80 on one machine: what was the difference between 8-bit arcade machines and home computers?</h1><div class="post__text post__text-html js-mediator-article"><h2>  What I learned about the arcade machine Bomb Jack in the process of creating its emulator </h2><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ea/be5/eae/7eabe5eaeb49a7c8a77b543628df89bf.png"></div><br>  Recently, I wrote a small Bomb Jack emulator, mainly to figure out how these first 8-bit arcade machines differed in design from 8-bit home computers. <br><br>  As I learned much later, a meeting at a summer fair in my hometown with arcade machines like Bomb Jack was one of those moments that changed my destiny.  On a typical summer day, having spent my entire stock of coins on arcade machines, I was returning home, and my head was filled with colors and sound effects.  I tried to understand how these games worked.  And then, until the end of the year, I spent all my time after school on creating pretty faded copies of these arcade games on a home computer.  I was like a cargo carriage fan from the Pacific Islands who wanted to create an American military radio station out of sticks. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At first, I was thinking about the idea of ‚Äã‚Äãcreating a <em>Pengo</em> emulator, because my teenage brain was impressed by this game much more than Bomb Jack (by the way, here is my <a href="https://floooh.github.io/tiny8bit/kc85.html%3Ftype%3Dkc85_3%26amp%3Bsnapshot%3Dkc85/pengo.kcc">cargo-iconic version of Pengo</a> ).  But the Pengo arcade equipment would have required the creation of emulators for sound and video chips, and for Bomb Jack, I had enough parts I already had (Z80 as CPU and AY-3-8910 for sound), so I was the first to take on Bomb Jack. <br><a name="habracut"></a><br>  In addition, Bomb Jack was a great opportunity to finally add support for NMI (non-maskable interrupt) to my Z80 emulator.  None of the Z80-based machines I emulated before have used NMI, so there wasn‚Äôt much point in recreating this function - I still couldn‚Äôt test its operation. <br><br>  If you do not know what Bomb Jack is, then this game looked like this (not sure what the correct aspect ratio was): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af7/79a/9ae/af779a9ae761839ee041300bc817c7f6.png" alt="Bomb Jack Screenshot"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_jJzasm63DE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The emulator version on WebAssembly can be explored here: <br><br>  <a href="https://floooh.github.io/tiny8bit/bombjack.html">https://floooh.github.io/tiny8bit/bombjack.html</a> <br><br>  After the loading procedure is complete and the high score table screen appears, press <strong>1</strong> to toss a coin, and then <strong>Enter</strong> (or any other key except arrows and space) to start the game. <br><br>  Inside the game, use the <strong>arrow keys</strong> to change direction and the <strong>spacebar</strong> to jump.  While in the air, press the <strong>spacebar</strong> to reduce the speed of the fall. <br><br>  The source code is here: <br><br>  <a href="">https://github.com/floooh/chips-test/blob/master/examples/sokol/bombjack.c</a> <br><br>  It uses <a href="https://github.com/floooh/chips">chip headers</a> to provide Z80 and AY-3-8910 emulation, as well as <a href="https://github.com/floooh/sokol">sokol headers</a> as a cross-platform wrapper (for entering the application, rendering, input and sound). <br><br><h2>  Step 1: research </h2><br>  "Research" is too loud a word: I just drove into Google "Bombjack arcade hardware specs". <br><br>  Compared to the popular home computers of the 80s (or even the mysterious East European computers, which often still have active communities), there is very little information on the Internet about Bomb Jack. <br><br>  I found two very important pieces of information: the <a href="https://github.com/floooh/emu-info/blob/master/misc/bombjack-schematics.pdf">circuit diagram of the</a> automaton and, of course, the <a href="">source code of the MAME emulator</a> . <br><br>  There is also a project that implements <a href="http://papilio.cc/index.php%3Fn%3DPlayground.BombJack">Bomb Jack on FGPA</a> , from the VHDL source code of which I was able to find out the details missing in the conceptual diagram. <br><br>  Understanding the source code for MAME would be complicated, because arcade-machine emulators are usually just a bunch of macros describing how different pieces of equipment interact, but the <em>source code</em> itself <em>is</em> not so much. <br><br>  Nevertheless, the macro descriptions of the equipment, and especially the comments, still proved to be very useful for understanding the work of the hardware, and where they became too mysterious (for example, the <a href="">video decoding part</a> ), the trial and error method was sufficient, and detailed study of the concept. <br><br><h2>  Equipment overview </h2><br>  The most interesting thing about Bomb Jack hardware is that there are actually <strong>two computers</strong> connected to each other with electrical tape: there is a <strong>main board</strong> with a Z80 CPU and equipment for video decoding and a separate <strong>sound card</strong> with its own Z80 CPU and three (yes, three!) sound chips AY-3-8910. <br><br>  Video decoding equipment is not implemented as an integrated circuit - it‚Äôs just a multitude of small general-purpose chips (their layout takes 6 out of 10 pages of a device‚Äôs schematic diagram).  When creating an emulator, I decided to go a short way: instead of emulating individual parts of video decoding equipment, I emulated only its behavior, creating corresponding output from the input data and not worrying too much about how the equipment itself works in the middle. <br><br>  Such a simplified solution is quite suitable for a separate arcade machine, which is designed to run only one program.  If the game starts and works correctly, then the emulation can be considered ‚Äúquite good‚Äù. <br><br>  In addition, this simplified approach is an important difference from the emulation of most home computers: some games require more accurate emulation than others, for example, machines like the C64 or Amstrad CPC need very accurate emulation up to clock cycles, some video games and graphics The demo worked correctly. <br><br>  It also means that my ready-made emulators of the CPU and sound chip are in fact unnecessary work for the Bomb Jack, for example, the work of the Z80 CPU with the implementation of a fraction of the computer cycle is a brute force, it would be simpler and simpler for the instruction level. <br><br><h2>  Main board </h2><br>  Usually the first thing I try to figure out when writing a new emulator is the memory allocation scheme (where the ROM and RAM, video memory and special addresses or I / O ports are located). <br><br>  On the Bomb Jack main board, there is only one ‚Äúinteresting‚Äù chip - the Z80 CPU operating at 4 MHz.  All the remaining space of the main board is occupied by the video decoding equipment (with the exception of a pair of RAM chips and ROM). <br><br>  The 16-bit address space looks like this: <br><br><ul><li>  <strong>0000..7FFF</strong> : 32 KB ROM </li><li>  <strong>8000..8FFF</strong> : 4 KB of general purpose RAM </li><li>  <strong>9000..93FF</strong> : 1 Kbytes of video memory </li><li>  <strong>9400..97FF</strong> : 1 Kbyte color RAM </li><li>  <strong>9820..987F</strong> : 96 bytes of sprite RAM </li><li>  <strong>9C00..9CFF</strong> : 256 bytes of RAM color palette </li><li>  <strong>9E00, B000..B005, B800</strong> : I / O Ports </li><li>  <strong>C000..DFFF</strong> : 8 KB ROM </li></ul><br>  The area of ‚Äã‚ÄãI / O ports is as follows.  Some ports are write-only, some are read-only, and some have different functions when reading and writing to them: <br><br><ul><li>  <strong>9E00</strong> : write: number of current background image, read: - </li><li>  <strong>B000</strong> : Read: Player 1 Joystick Status, Write: <strong>Enable</strong> / Disable NMI Mask </li><li>  <strong>B001</strong> : Read: Player 2 Joystick Status, Write: - </li><li>  <strong>B002</strong> : reading: coins and buttons Start, writing: - </li><li>  <strong>B003</strong> : Read: Watchdog CPU, Write: ??? </li><li>  <strong>B004</strong> : read: dip switches 1, write: switch screen </li><li>  <strong>B005</strong> : Read: Dip-switches 2, Write: - </li><li>  <strong>B800</strong> : write: command sound card, read: - </li></ul><br>  Here it is worth mentioning the following: <br><br><ul><li>  The device has MANY ROMs (40 Kbytes), and very little RAM (about 7 Kbytes, and only 4 Kbytes of which are ‚ÄúGeneral Purpose RAM‚Äù) </li><li>  For ‚ÄúDisplay RAM‚Äù, only 2 KB were allocated, divided into two fragments of 1 KB, which seems very small for a 256x256 full-color display, in which, it seems, colors are set pixel-by-pixel </li><li>  This is a system with I / O in the memory allocation scheme! </li></ul><br>  The I / O in the memory allocation scheme is a bit unusual for a machine with a Z80, because one of the distinguishing features of the Z80 is a separate 16-bit address space for device I / O.  This is done to save precious memory address space.  I / O in the memory allocation scheme is usually inherent in computers with a 6502 processor. <br><br>  A glance at the circuit diagram confirms this: the IORQ pin is not detected on the main board CPU, only the MREQ pin is connected (which is used to initialize reading or writing to the memory): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/99e/3d8/a5899e3d8384702517d0c7fe6c0de436.png" alt="Bomb jack iork"></div><br>  This means that we don‚Äôt have to worry about the I / O requests of the CPU timer function of the main board in the emulator, but only deal with memory requests. <br><br>  After studying the circuit diagram, I found another interesting detail about the mainboard CPU: <br><br>  Only the NMI contact is connected, while the INT contact is always maintained at a high level of the clock signal / it remains inactive (this means that the ‚Äúusual‚Äù masked interrupts are not executed, and only non-maskable occur): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/393/acf/cb8/393acfcb88d846cc868e2fa0e490fbbd.png" alt="Bomb jack iork"></div><br>  This is also quite unusual for a car with a Z80.  In all home computers based on the Z80, with which I had previously dealt, everything was the opposite - they used only masked interrupts, and never used nonmaskable ones.  The Z80's masked interrupt is a very flexible and serious improvement compared to the primitive interrupt system of its ‚Äúillegitimate father‚Äù - the Intel 8080, or its competitor - MOS 6502. But this increased flexibility is both more complex and difficult to implement in hardware (unless other Z80 chips are used, which already have a built-in complex interrupt protocol when connected by bus). <br><br>  Well, okay, enough details about the equipment, go to the emulator! <br><br><h2>  Download procedure </h2><br>  The next step after determining the memory configuration is to connect the emulated CPU to the emulated memory allocation scheme, record some visualization of the video memory contents and start the CPU cycles. <br><br>  Surprisingly, such a rough approach is often enough to go through the procedure of loading and displaying <em>something</em> on the screen.  When developing the Bomb Jack emulator, I simply took the contents of 1 Kbyte of video memory in the range from 0x9000 to 0x93FF as a 32x32 byte matrix.  When the byte was 0, I rendered a block of 8x8 black pixels, and otherwise a block of white pixels. <br><br>  Then I just ran the emulated CPU and hoped for the best.  Behold  There was some legible picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/17d/7c2/198/17d7c2198881dbfd40978e26d832aaca.png" alt="Bomb Jack Boot 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3b/e04/b97/d3be04b970ff2c8b5905ed3f7f757a51.png" alt="Bomb Jack Boot 2"></div><br>  The top image looks like the equipment test screen when loading, and the bottom one looks like the points record screen that appears after the loading procedure is completed: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f6/5ae/4b9/0f65ae4b9d00fa43e2da7582b9ceb5f3.png" alt="Bomb Jack Boot 3"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/649/5c8/db1/6495c8db1d035484ef03e32902f28cdf.png" alt="Bomb Jack Boot 4"></div><br>  ... but rotated 90 degrees (which is logical, because the screen of the arcade automata was often in a vertical ‚Äúportrait‚Äù orientation). <br><br>  Great, the start is promising! <br><br>  The next step is to figure out how to turn these white blocks into color pixels ... (and this is a huge step, details are described below in the section on video decoding). <br><br>  At first everything went pretty fast, pixels and colors were displayed on the test screen (later I noticed that the decoding of colors was completely wrong, and nevertheless ...): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c3/ecd/757/2c3ecd757e603194698f6f93b71e3127.png" alt="Bomb Jack Boot 5"></div><br>  But when the record screen was supposed to appear, I got a black screen.  Hacking the background color so that it was ‚Äúnot black,‚Äù I found that the pixels are rendered, but the whole color palette is black.  Hmm ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e81/dac/2e4/e81dac2e4796b7bf90d43a711a52f37e.png" alt="Bomb Jack Boot 5"></div><br>  Looking at this screen for a couple of minutes, I remembered that some of the colors on the screen of records are animated, and when there is animation, there must be some kind of timer.  The logical time source in this hardware configuration will be the display's VSYNC signal, and the VSYNC is connected to the NMI pin of the CPU (or, rather, not VSYNC, but VBLANK, which is a brief moment between the VSYNC signal and the ray of the cathode ray tube in the upper left corner). <br><br>  And all this I have not yet implemented ... <br><br>  The next evening, when I added the first version of NMI processing to the Z80 emulation and connected it to the first vsync / vblank counter in the mainboard CPU timer function, a lot of things suddenly started to happen! <br><br>  First of all, colors appeared on the screen of records, and some of them were animated: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/163/661/72d/16366172d4eb6b8e2342acbbd74a64ac.png" alt="Bomb Jack NMI 1"></div><br>  After a few seconds, something even more amazing began!  The screen of records disappeared, and a strange visualization of the first map was displayed.  It was clear that this is a demo mode of an arcade machine for attracting attention - I saw several bombs with color animation that disappeared when the imaginary Bomb Jack was jumping around the map, collecting these bombs: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d60/cd6/81d/d60cd681dedbdfbf4329410e0014f9f0.png" alt="Bomb Jack NMI 2"></div><br>  The colors were still completely wrong, and yet it is PROGRESS! <br><br>  The time has come to do the rest of the video decoding: <br><br><h2>  Iron Video </h2><br>  At first glance, the Bomb Jack video equipment looked very powerful for an 8-bit machine from 1984: despite the resolution of only 256x256 pixels, it could simultaneously display 128 (out of 4096) colors, and render up to 24 hardware sprites (16x16 in size) or 32x32) with pixel set color. <br><br>  The 8-bit home computers of that time had about the same display resolution, but they had many limitations regarding colors.  These limitations are very noticeable when comparing the versions of Bomb Jack for the ZX Spectrum and the Amstrad CPC with the version for the arcade machine: <br><br>  The <a href="https://floooh.github.io/tiny8bit/zx.html%2520file%3Dzx/bombjack_zx.z80%26amp%3Bjoystick%3Dkempston%26amp%3Btype%3Dzx48k">ZX Spectrum version</a> had a pretty good pixel resolution (256x192), but very few colors, and it suffered from the typical ‚ÄúSpectrum of colors‚Äù effect for the Spectrum (although the developers did their best to make it not noticeable): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46d/176/fff/46d176fffb8404ad696883849dd880d1.png" alt="Bomb jack zx"></div><br>  <a href="https://floooh.github.io/tiny8bit/cpc.html%3Ffile%3Dcpc/bomb_jack.sna%26amp%3Bjoystick%3Dtrue">The Amstrad CPC version is</a> more full-color, but to get more colors, the developers had to switch to the low-resolution display mode (160x200).  As a result of this, Jack and the monsters turned into an illegible pile of pixels: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bbd/f33/3d8/bbdf333d8e4d8d44735047f99e53b49c.png" alt="Bomb Jack CPC"></div><br>  Compare this with the version for the arcade machine, which had the same resolution in pixels as the ZX Spectrum, but with a much larger number of colors <em>and a</em> higher pixel resolution of colors: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/112/ac5/69f/112ac569f11f32d6c1ed4836bb8c2b51.png" alt="Bomb jack arcade"></div><br>  The interesting thing is that the arcade version has better graphics, not because it works on a more powerful hardware (it has more ROM for storing more graphics data, but the ‚Äúcomputational power‚Äù is about the same), but because the developers of the device could focus on the manufacture of specialized machines for one particular type of game and they did not need to create a universal general purpose home computer. <br><br>  Here's how the display hardware works (at least in my high-level interpretation): <br><br><h2>  Three layers of display </h2><br>  The finished Bomb Jack video signal is combined from three layers: the background layer, the front layer and the sprites layer. <br><br>  Such a system of layers has two main advantages: <br><br><ul><li>  It implements a rather tricky hardware image compression to generate a full-color ‚Äúhigh resolution‚Äù image over a very small amount of data. </li><li>  It significantly reduces the amount of CPU work needed to update the dynamic elements of the screen (even at 4 MHz, the 8-bit CPU does not have enough power to move such a number of objects across the display 256x256 at 60 Hz) </li></ul><br>  Video iron is quite different from what I saw in 8-bit home computers, but MAME implements generalized auxiliary classes for this type of equipment, so I can assume that it is quite often found in arcade machines. <br><br><h3>  Background layer </h3><br>  The background layer can render 1 of 5 background images embedded in ROM.  The background image is selected by writing a value from 1 to 5 at 0x9E00 (it looks like the value 0 is special and renders a completely black background). <br><br>  In fact, it seems that the equipment is capable of rendering 7 different images, but only 5 are used in the game. Secretly, I was hoping to find in the ROM previously undetected image data.  But alas, they are not there (yes, I probably am not the first to look for them there). <br><br>  Here is the background layer of the first map without the other two layers: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afe/75a/2c7/afe75a2c7386bb48fb3e90e2a24a655e.png" alt="Bomb Jack Background"></div><br>  The background layer is made up of <strong>16x16</strong> pixels. <br><br>  The advantage of building background images from tiles is that identical tiles can be used multiple times, so less data can be stored in the ROM.  Notice that the blue sky, parts of the pyramid and the sand under the pyramid use the same tiles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/613/0ee/4226130ee4b597ccbeccebbce664dbdf.png" alt="Bomb Jack Background Tiles"></div><br>  To save memory, the background layer equipment implements another trick - tiles can be turned horizontally.  I almost missed it in my implementation, because I assumed that the software does not use this hardware function, but noticed a small bug in the background of the third card: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22d/397/d5c/22d397d5c5b984b8a7b1e7c53e5abd34.png" alt="Bomb Jack Background 3"></div><br>  The same trick used on the fifth map, but here it is a little harder to notice if you don‚Äôt know what to look for: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4af/82d/430/4af82d430deab8804a795ac9fb142b87.png" alt="Bomb Jack Background 5"></div><br><br><h3>  Front layer: </h3><br>  Above the background layer is the ‚Äúfront layer‚Äù, which renders all the fixed parts of the screen, which nevertheless must be updated by the CPU (mostly text, platforms and bombs).  The layout is read from RAM (from fragments of 1-Kbyte RAM and 1-Kbyte color RAM). <br><br>  Here is the isolated front layer of the first map: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/5ac/fa8/8745acfa89c446ba9b5a9d9e719c8d31.png" alt="Bomb jack foreground"></div><br>  The front layer also consists of tiles (as well as background), but it uses smaller tiles of 8x8: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a9/e26/f94/5a9e26f94d1d9e0df0f50f4f1d1beb78.png" alt="Bomb Jack Background Tiles"></div><br>  The main advantage of separating the background and the front into separate layers is that the CPU does not need to worry about storing and recovering background pixels when creating or deleting the front elements. <br><br><h3>  Sprites layer </h3><br>  Finally, hardware sprites are rendered on top of the front layer.  Everything that moves around the screen is implemented in sprites.  Bomb Jack equipment can render up to 24 sprites, and each sprite can be 16x16 or 32x32 pixels.  At the same time, sprites can be positioned with pixel precision: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/276/66e/5a0/27666e5a0a266d28babf72dafe2e66bc.png" alt="Bomb jack sprites"></div><br><br><h2>  8x8 tile decoder </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the ‚Äúheart‚Äù of the video decoding equipment there is a color palette with 128 elements and a tile decoder 8x8 pixels in size. </font><font style="vertical-align: inherit;">The task of the tile decoder is to generate a 7-bit color palette index for each of the 64 pixels of the tile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These 8x8 tiles are the building blocks for everything on the screen ‚Äî 16x16 background tiles, 8x8 front-layer tiles, and 16x16 or 32x32 hardware sprites. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the block diagram of this 8x8 tile decoder for rendering the front layer (as I understood it):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e79/d6e/5d9/e79d6e5d9b5019923a37bc14658e8ec4.jpg" alt="Bomb Jack Tile Decoding"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Top-down flowchart explanation: </font></font><br><br><ul><li>          ¬´ ¬ª   (   32x32  )       (  32x32).            ,    ,      .    8x8        . </li><li>             .         (         ).         ,       ,    (       ). </li><li>       8   ,     8  (   ).            ,  ,       8x8  24    (3   ). </li><li>    64    7- .  3         ,   4  ‚Äî    .  ,  ,           16 ¬´¬ª,     8 .        8     . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This 7-bit index, assembled from bit layers and tile color values, is used to search for a 12-bit RGB color value from a color palette (4 bits per color channel). </font><font style="vertical-align: inherit;">The color palette is located in RAM and the CPU can work with it (as far as I have seen, the video RAM, colors and palettes are used only for writing; at least, the CPU never has read access to these areas).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is a general tile decoding scheme that is used by each of the three layers of the display, but the decoding of each layer is slightly different: </font></font><br><br><ul><li>        512   8x8.    9-  ,     8   .   ¬´¬ª      (         4   ,   4    ).   3      8x8  ,     ,    ¬´¬ª  . </li><li>      16x16,     16x16=256     256           (512   ).    ,     16x16      8x8,        .   ,      ;      ¬´¬ª   :   7   ,    . </li><li>       16x16   32x32 ,       4  16   8x8    .  ,    16x16  96 ,    32x32 ‚Äî    384    .       ,   3      ,    . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To better understand how the bit layers of tiles look like, I wrote a small </font></font><a href="https://gist.github.com/floooh/5f44cce30912142e726bb4ff783e24b8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C program</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that converts tile ROMs into PNG files (3 bits per pixel are converted to 8 levels of shades of gray). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is the front layer tile ROM. </font><font style="vertical-align: inherit;">We see numbers and text font data, platform tiles, bombs (split in half), parts of the logo from the Bomb Jack screensaver, and the number of points multipliers that appear at the top of the screen (by the way, everything is rotated 90 degrees because the whole screen is also rotated ):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/681/ca4/fec/681ca4fec37418dffeb4d601b9e787cf.png" alt="Bomb Jack Foreground Tile ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next, consider the background tile rom. </font><font style="vertical-align: inherit;">It doesn‚Äôt look very clear, because what we are seeing is actually decoding 16x16 tiles into 8x8 tiles. </font><font style="vertical-align: inherit;">Each 16x16 tile is made up of four adjacent 8x8 tiles. </font><font style="vertical-align: inherit;">But you can recognize parts of the Greek temple from card 2, castle from card 3 and skyscrapers from card 4.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ebc/fa9/86d/ebcfa986da9add0a45acc02b54bcb69e.png" alt="Bomb Jack Background Tile ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, the sprite tile rom. </font><font style="vertical-align: inherit;">Sprites 16x16 occupy the upper half, and sprites 32x32 - the bottom.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/444/974/01e/44497401e4d25c7915f1c15c9fb9f4ac.png" alt="Bomb Jack Sprite Tile ROM"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An interesting hack of the Bomb Jack screen saver is that the logo is assembled from front tiles and sprites. </font><font style="vertical-align: inherit;">I think the developers had the front tile ROM ending, but there was still a bit of space in the sprite ROM:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/939/bd5/b69/939bd5b6999622ee26e337f033087234.png" alt="Bomb Jack Splash 1"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d9/fef/f2a/6d9feff2acdd4ee2aaa63b8dc4226692.png" alt="Bomb Jack Splash 2"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/819/bb9/072/819bb90727322463b2c8a9196f6f74c2.png" alt="Bomb Jack Splash 3"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprite equipment </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bomb Jack sprite hardware is very powerful compared to that used in home computers of the time: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It could render up to 24 hardware sprites. </font><font style="vertical-align: inherit;">It seems that there were no restrictions on the number of sprites per scan line.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites could be 16x16 pixels or 32x32 pixels. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each sprite could choose from 16 slots of 8 colors in a common color palette. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sprites had per pixel color resolution. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each sprite could be turned vertically or horizontally. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each sprite could choose one of 128 sprite images stitched in ROM. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When decoding pixels and sprites of a sprite system, the same 8x8 base tile is used as in the background and front layers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attributes of sprites are located in the address range from 0x9820 to 0x987F - 96 bytes, 4 bytes per sprite. </font><font style="vertical-align: inherit;">As far as I saw, this area is write-only; </font><font style="vertical-align: inherit;">at least the CPU does not read access to this memory range. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each sprite is described by 4 bytes:</font></font><br><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : if specified, this is a 32x32 sprite, otherwise 16x16</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 6..0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 7 bits for setting the code of the sprite tile used to search for the bit layers of the sprite image in the ROM of the tiles.</font></font></li></ul></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><ul><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : if set, then the sprite is mirrored horizontally</font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bit 6</font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : if set, the sprite is mirrored vertically</font></font></font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 3..0</font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 4 bits to set the color for the tile decoder</font></font></font></font></li></ul><br></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 2</font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : sprite</font></font></font></font></li><li> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte 3</font></font></font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : sprite position on the Y axis.</font></font></font></font></li></ul><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'en', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><br>  It is not clear what bits 4 and 5 of byte 1 do, the comment in MAME says this: <br><br> <code>e ? (,    ) <br> f ? (,     (B)?)</code> <br> <br><h2>  Memory I / O ports </h2><br>  A few notes on the I / O ports of the main board.  As stated above, I / O ports look like this: <br><br><ul><li>  <strong>9E00</strong> : write: number of current background image, read: - </li><li>  <strong>B000</strong> : Read: Player 1 Joystick Status, Write: <strong>Enable</strong> / Disable NMI Mask </li><li>  <strong>B001</strong> : Read: Player 2 Joystick Status, Write: - </li><li>  <strong>B002</strong> : reading: coins and buttons Start, writing: - </li><li>  <strong>B003</strong> : Read: Watchdog CPU, Write: ??? </li><li>  <strong>B004</strong> : read: dip switches 1, write: switch screen </li><li>  <strong>B005</strong> : Read: Dip-switches 2, Write: - </li><li>  <strong>B800</strong> : write: command sound card, read: - </li></ul><br>  We already considered the address 0x9E00 (the choice of the background image) above, and the address 0xB800 (the sound card command) we will consider in the next section.  There are addresses from 0xB000 to 0xB005: <br><br>  Reading from addresses 0xB000 and 0xB001 returns the current state of two joysticks.  Specified bytes indicate closed joystick switches: <br><br><ul><li>  <strong>bit 0</strong> : direction "right" </li><li>  <strong>bit 1</strong> : direction "left" </li><li>  <strong>bit 2</strong> : direction "up" </li><li>  <strong>bit 3</strong> : direction "down" </li><li>  <strong>bit 4</strong> : jump button is pressed </li></ul><br>  The remaining 3 bits are ignored. <br><br>  Reading from 0xB002 returns the status of the coin acceptor and the Start buttons: <br><br><ul><li>  <strong>bit 0</strong> : player 1 coin inserted </li><li>  <strong>bit 1</strong> : player 2 coin in </li><li>  <strong>bit 2</strong> : player 1 start button </li><li>  <strong>bit 3</strong> : player 2 start button </li></ul><br>  Reading from addresses 0xB004 and 0xB005 returns the state of the dip switches, which are used to configure the behavior of the arcade machine: <br><br><ul><li>  <strong>B004</strong> : <br><ul><li>  <strong>bits 0,1</strong> : how many "games" are given for one coin (1, 2, 3 or 5) </li><li>  <strong>bits 2.3</strong> : same for player 2 </li><li>  <strong>bits 4,5</strong> : how many lives per game (3, 4, 5 or 2) </li><li>  <strong>bit 6</strong> : location of the arcade machine: ‚Äúcocktail table‚Äù or ‚Äúvertical‚Äù. </li><li>  <strong>bit 7</strong> : do i need to play sound in standby mode </li></ul></li><li>  <strong>B005</strong> : <br><ul><li>  <strong>bits 3,4</strong> : difficulty 1 (bird speed) </li><li>  <strong>bits 5.6</strong> : difficulty 2 (the number and speed of enemies) </li><li>  <strong>bit 7</strong> : frequency of occurrence of a special coin </li></ul></li></ul><br>  Finally, reading from address <strong>B003</strong> implements a software watchdog timer.  The CPU should often read from this address, otherwise the arcade machine will perform a hardware reset.  If for some reason the game crashes, the equipment will automatically reboot. <br><br>  You can write to some I / O port addresses: <br><br><ul><li>  <strong>B000</strong> : Do I need to generate NMI during vblank;  seems to be disabled only during the boot procedure </li><li>  <strong>B004</strong> : flip the entire screen;  I have never met the use of this function, but I have a theory about it (see below) </li></ul><br>  The screen flip function is a bit confusing, because when playing a game, I have never seen its use.  However, I have a hunch about what he is doing, but to confirm it, you need to write code.  When the arcade is in the "cocktail table" configuration, two players are seated opposite each other.  Therefore, I assumed that when a game switches from player 1 to player 2, this function reverses the screen.  However, I have not yet implemented the two-player mode in the emulator. <br><br><h2>  Sound card </h2><br>  The sound card itself is a full-featured computer with a Z80 CPU (running at 3 MHz), three sound chips (AY-38910 running at 1.5 MHz), as well as RAM and ROM.  The sound card memory distribution scheme looks quite simple: <br><br><ul><li>  <strong>0000..2000</strong> : 8 Kbyte ROM </li><li>  <strong>4000..4400</strong> : 1 Kbyte of RAM </li><li>  <strong>6000</strong> : sound command from the main board </li></ul><br>  Since there is nothing interesting about the address 0x8000 above in the memory allocation scheme, the top-most address contact of the CPU is not even connected: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b2f/4ea/35e/b2f4ea35ee4d2861ea1baa502da10837.png" alt="Bomb Jack Sound A15"></div><br>  The special address 0x6000 is the memory-mapped I / O port (8-bit latch) that does not correspond to the real RAM.  This is the same port that is located on the main board at 0xB800.  It is the communication channel between the main and sound cards. <br><br>  Three sound chips are controlled by these Z80 output instructions, and not through the ports in memory.  At AY-3-8910, only two I / O ports are open, the first is used to store the register number, and the second is for writing or reading the contents of the register specified by the first port. <br><br>  The I / O scheme is as follows: <br><br><ul><li>  <strong>0x00</strong> : first sound chip: register selection </li><li>  <strong>0x01</strong> : first sound chip: access to the selected register </li><li>  <strong>0x10</strong> : second sound chip: register selection </li><li>  <strong>0x11</strong> : second sound chip: access to the selected register </li><li>  <strong>0x80</strong> : third sound chip: register selection </li><li>  <strong>0x81</strong> : the third sound chip: access to the selected register </li></ul><br>  A few words about the sound chip AY-3-8910: <br><br>  This is a fairly standard device, very popular in home computers of the time (for example, in Amstrad CPC, ZX Spectrum 128, in MSX computers and many others).  AY-3-8910 spawned many variations and clones (for example, the Yamaha YM2149, which itself became the basis of a whole family of more powerful sound chips). <br><br>  AY-3-8910 has 3 channels of rectangular signals, one noise generator that can be mixed with three channels, and one envelope generator.  Since there was only one envelope generator for all three channels, it was not particularly useful, and most games used the CPU to modulate tone and volume. <br><br>  This means that the AY-3-8910 chip to create high-quality sound requires more CPU intervention (as opposed to more stand-alone SID chips, for example, in the C64 computer). <br><br>  It's amazing to see what can be done on three fairly simple sound chips and the CPU that controls them.  The music and sound effects of Bomb Jack are much richer than I had heard in most games for home computers. <br><br>  The only thing that is really interesting in this sound card is the way it receives its commands from the main board. <br><br><h2>  Sound command latch </h2><br>  ‚ÄúSound Latch‚Äù is a single-byte storage (8-bit latch), common to the main and sound cards.  The latch is tied to the address 0xB800 on the main board and to the address 0x6000 on the sound card. <br><br>  When enabled with the help of VSYNC NMI interrupts, the sound card performs a very simple interrupt service routine that reads the hardware latch, writes it to the usual memory address and sets a ‚Äúsignal bit‚Äù that tells the ‚Äúmain loop‚Äù that a new sound command is received: <br><br><pre> <code class="hljs 1c"> ex af,af' ;<span class="hljs-number"><span class="hljs-number">0066</span></span> exx ;<span class="hljs-number"><span class="hljs-number">0067</span></span> ld hl,<span class="hljs-number"><span class="hljs-number">0439</span></span>0h ;<span class="hljs-number"><span class="hljs-number">0068</span></span> set 0,(hl) ;006b ld a,(<span class="hljs-number"><span class="hljs-number">0600</span></span>0h) ;006d ld (<span class="hljs-number"><span class="hljs-number">0439</span></span>1h),a ;<span class="hljs-number"><span class="hljs-number">0070</span></span> exx ;<span class="hljs-number"><span class="hljs-number">0073</span></span> ex af,af' ;<span class="hljs-number"><span class="hljs-number">0074</span></span> retn ;<span class="hljs-number"><span class="hljs-number">0075</span></span></code> </pre> <br>  The way to activate the NMI contact is slightly different from the way for the main board: <br><br>  On the main board, the NMI contact becomes active while VBLANK is running. <br><br>  However, on the NMI sound card, it is activated when VSYNC is triggered, and remains active not during VBLANK, but until the interrupt service routine does not read the data from the latch at address 0x6000. <br><br>  When the equipment recognizes reading from the address 0x6000, it performs two hard-coded operations: <br><br><ul><li>  the sound of the latch is reset to 0 </li><li>  NMI contact becomes inactive </li></ul><br>  In essence, this is a simple debugging of contacts, which does not allow one sound command to be performed twice. <br><br>  The only question that remains is how often the main board records a new command (because the way to implement the emulation of two boards depends on this). <br><br>  After debugging with printf, I found that the main board records no more than one sound command per 60 Hz frame.  This greatly simplified the structure of the ‚Äúmain loop‚Äù of the emulator. <br><br>  The problem of the joint work of two separate emulated computers that need to exchange data with each other is that the emulation of one computer is effective only if it can perform many cycles at once without interference. <br><br>  For example, the worst case would be: <br><br><ul><li>  we execute in the computer 1 one instruction </li><li>  we execute in computer 2 one instruction </li><li>  repeat ... </li></ul><br>  My Z80 emulator is not optimized for going out and entering the emulation for each instruction, because in this case it should reset the state of the CPU at the beginning and end of each instruction into memory and load from memory.  If the CPU can process multiple instructions without interference, then you can store (most of) the state of the CPU in registers and reset the state to memory on the last instruction. <br><br>  That is, the ideal situation would be this: run the emulated system without hindrance during the entire frame of the host system (for a CPU with a frequency of 4 MHz and at 60 Hz, this means about 67 thousand cycles per frame, or anywhere from 3 thousand to 16 thousand instructions Z80). <br><br>  When working with Bomb Jack, I needed to make sure that the main board did not record the new command before the sound card could be able to read the last command.  Before I found out that the main board records no more than one command per frame, I considered the need to create a complex command queue that would intercept recordings into the sound latch of the main board and save the cycle number and command byte in the queue. <br><br>  Then, when the sound card was performing its frame, it would take a new command from the command queue when the command cycle number was reached. <br><br>  Such a system would work and would be ‚Äúcorrect‚Äù, but would greatly increase the complexity of the code. <br><br>  In the end, I decided to use a much simpler solution without any queues.  Since the main board records only one command per frame, I alternated the execution on two computers so that each of them performed two time slices per frame: <br><br><ul><li>  perform on the main board the first half of the frame </li><li>  perform the first half of the frame on the sound card </li><li>  perform the second half of the frame on the main board </li><li>  perform the second half of the frame on the sound card </li></ul><br>  This ensures that the sound card correctly sees each command recorded by the main board, and at the same time can perform each emulation for thousands of cycles. <br><br>  Of course, the fact that the host system works at approximately a frame rate of 60 Hz is a very bold assumption :) <br><br><h2>  And the last ... </h2><br>  The last interesting fact about the emulator version on WebAssembly: <br><br>  Compressed size of all downloaded files when running emulator on WebAssembly <br>  Approximately equal to 113 KB: <br><br><ul><li>  about 2.5 KB in HTML, CSS, and handwritten JS </li><li>  26.8 kb per emscripten runtime js file </li><li>  83.7 KB per file .wasm </li></ul><br>  The WASM file contains the built-in ROM of the arcade machine. <br><br>  In uncompressed form, these ROMs occupy 112 KB. <br><br>  That is, the <strong>entire</strong> compressed emulator with embedded ROM occupies almost the same volume as the uncompressed ROM :) <br><br>  112-kilobyte ROMs are compressed to about 57 KB, that is, the true size of the compressed code in WASM without ROM data takes less than 30 KB (84 - 57). <br><br>  It seems to me, not bad for a full emulator of an 8-bit system;) </div><p>Source: <a href="https://habr.com/ru/post/426291/">https://habr.com/ru/post/426291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426281/index.html">The founders of Amazon, Google, Microsoft and Facebook lost more than $ 30 billion during the collapse of the stock exchanges.</a></li>
<li><a href="../426283/index.html">WeChat in India: from a powerful launch to a complete loss of interest</a></li>
<li><a href="../426285/index.html">In one of the shops AvtoVAZ found a farm for mining</a></li>
<li><a href="../426287/index.html">Package to the moon</a></li>
<li><a href="../426289/index.html">Asp .net core authentication via IdentityServer4</a></li>
<li><a href="../426293/index.html">Which bike to choose for urban, country and extreme rides - a review of models Airwheel and Twitter</a></li>
<li><a href="../426295/index.html">How do i see the perfect browser</a></li>
<li><a href="../426297/index.html">What I do not like modern web</a></li>
<li><a href="../426299/index.html">[Design Psychology] - The Psychology of Design</a></li>
<li><a href="../426301/index.html">Is it in Europe, as they write about it?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>