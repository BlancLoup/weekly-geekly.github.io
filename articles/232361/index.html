<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributed computing: some theory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nine years ago, I started ‚Äúin my spare time‚Äù to teach computer science at a university in St. Petersburg. And only relatively recently, to my surprise...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distributed computing: some theory</h1><div class="post__text post__text-html js-mediator-article">  Nine years ago, I started ‚Äúin my spare time‚Äù to teach computer science at a university in St. Petersburg.  And only relatively recently, to my surprise, I found out that in our universities there are practically no courses with a focus on the problems of distributed computing.  And even on Habr√© this topic is not disclosed sufficiently!  It is necessary to correct the situation right now. <br><br>  I wanted to devote an article or even a series of articles to this topic.  But then I decided to post my tutorial on the basics of distributed computing, published this year (read, a small book of 155 pages).  The result was a hybrid - an article referring to the book.  The book is distributed free of charge and is available in electronic form. <br><br>  <b>Instead of the prologue.</b>  Starting the text of the article, I once again wondered why a programmer needs to know the theoretical foundations of distributed computing.  I have repeatedly heard this question (and continue to hear) from students and specialists already working in the field of IT.  Indeed, why, for example, to know that ‚Äúthe set of events of a distributed computation is partially ordered rather than linearly‚Äù?  What, so to speak, is the everyday practical use of this fundamental knowledge? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I have to admit that I do not have a ready-made, learned answer, which I can give out without thinking.  Therefore, each time you have to strain the convolutions, and each time the answers and arguments are different.  And now everything is like for the first time ... <br><a name="habracut"></a><br>  Let's try to start from afar.  And to make it clearer - with medicine.  Because, if it comes to medical errors, the brain begins to work actively and generate strong indignation: horror, horror, could kill a person.  What are they, just what?  Do not know what to do? <br><br>  We all quite naturally expect that before starting any manipulations with the human body, doctors still study its internal structure and working principles.  We absolutely disagree with the statement that it is much more important for surgeons to undergo practical courses on cutting and sewing instead of many years of cramming theoretical material about what we have inside and why it is there.  So why programmers involved in the development of a system with network interaction (i.e., by now almost any system) do not need to know "what is inside and why is it there"?  Why are mistakes in IT perceived with a maximum of light irony?  Well, yes, well, a bug.  <a href="http://www.youtube.com/watch%3Fv%3DgoFTawXby1E">And who <s>does not drink</s> does not make bugs?</a>  <a href="http://www.youtube.com/watch%3Fv%3DgoFTawXby1E">Call it!</a>  <a href="http://www.youtube.com/watch%3Fv%3DgoFTawXby1E">No, I'm waiting!</a>  Among the requirements for programmers, very often for some reason practical skills in one or another programming language come to the fore.  And much to the forefront, completely eclipsing the requirements for understanding the basic concepts, theoretical models, algorithms, in the end ... And the programmers themselves, which is no secret, with the beginning of the conversation "about no one needs a theory" fades like flowers in the desert ... Miracles , is not it‚Ä¶ <br><br>  Let me give you a small statement by L. Lamport on this topic (I tried to translate this statement into Russian just below, not far from the original): <br><br><blockquote>  For quite a while, I‚Äôve been disturbed by computer science.  What are you supposed to do?  It is a program that requires computer programming.  If you‚Äôre trying to find out where to go, you‚Äôll be able to find out what you‚Äôre trying to do. <br>  I think that programmers can learn more about how to think better.  Thinking is not the ability to manipulate language;  it's the ability to manipulate concepts.  Computer science should not be about concepts, not languages. </blockquote><br><blockquote>  For quite a long time, I‚Äôm worried about too much attention to computer language in IT.  As a result of an oversupply of such attention, programmers appear who are experts in C ++, but who are not able to write programs that do what is required of these programs.  A typical reaction of IT representatives to this problem is to offer programmers to use another more suitable language (programming, specifications, etc.) instead of / in addition to C ++.  In turn, a way out of the situation characteristic of the software development industry is seen in providing programmers with more advanced debugging tools, apparently based on the assumption that you can get good programs simply by <a href="http://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE_%25D0%25B1%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D1%2585_%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25B7%25D1%258C%25D1%258F%25D0%25BD%25D0%25B0%25D1%2585">setting the monkey at the keyboard</a> and then looking for and correcting errors in its code. <br>  My firm belief is that in order to get high-quality programs you need to teach programmers to think better.  The ability to think is not the ability to operate a computer language;  it is the ability to operate with concepts.  The study of information technology should focus on learning concepts, not languages. </blockquote><br>  To illustrate how important the ‚Äúconcepts‚Äù and ‚Äúelements of the theory‚Äù can be in the construction of distributed systems, let's consider a couple of simple examples.  To begin with, a group mailing of e-mail messages between users A, B, C and X. Suppose that user A sends an email to the whole group with the subject ‚ÄúGeneral meeting‚Äù.  Users B and C respond to the whole group with their messages with the subject ‚ÄúRe: General Meeting‚Äù. <br><br>  In fact, events occur in the following sequence: <br><ol><li>  The first message sent is from user A. </li><li>  User B receives it, reads it, and sends a response. </li><li>  User C receives both messages from A and B and then sends his answer, based on both messages from A and B. </li></ol><br>  However, due to arbitrary and independent delays in message delivery, some users may see a different sequence of events.  For example, according to the scenario shown in the figure below, in the mailbox of user X, messages will be placed in the following order: <br><ol><li>  Message from user C with the subject ‚ÄúRe: Re: General Meeting‚Äù. </li><li>  Message from User A with the subject ‚ÄúGeneral Meeting‚Äù. </li><li>  Message from User B with the subject ‚ÄúRe: General Meeting‚Äù. </li></ol><br><img src="https://habrastorage.org/files/196/aac/9bf/196aac9bf6b14269b5e262a3dd0dd4f6.png" height="232" width="542"><br><br>  Yeah, it turns out the order of receipt of messages, observed by different processes, can be different even for FIFO channels!  But what if we want the observed order to be the same everywhere (and at the same time we don‚Äôt want to use synchronous messaging)?  For example, if we write our transport with the appropriate guarantees.  Or do we want to build a fault-tolerant service (replicated state machine), where each replica must process incoming requests in the same order for all replicas so that the replica states do not differ?  Question‚Ä¶ <br><br>  Let us now consider another implementation of a distributed system in which processes interact only through the exchange of messages, and each process is involved in turning on / off the lamp with a certain light.  Let the first process control a lantern with a red light, the second with a yellow one, and the third with a green one.  Such is the traffic light system.  In the figure below, the switching on of the process of its lamp is indicated by a rectangle, and the switching off by a vertical line;  sending and receiving a message - an arrow.  Question: Can processes determine which lights are shining at the same time? <br><br><img src="https://habrastorage.org/files/d90/156/d2d/d90156d2d14e4648ba89925596011d15.png" height="158" width="552"><br><br>  So it turns out that in this implementation of the asynchronous system, the processes will not be able to determine whether the red light was on simultaneously with the yellow one.  Maybe yes.  Or maybe not ... These things will remain unknown.  But it will be known for sure that the red and green lights were at the same time switched on.  In other words, it turns out that there is not much point in saying that a particular global state is reached in the course of executing a distributed system!  As well as very often it is impossible to say whether any condition (predicate) defined on the set of its global states was fulfilled!  Again the question: why? <br><br>  <b>Our response to <s>Chamberlain</s> .</b>  In fact, the answers to these and many other questions related to the operation of asynchronous distributed systems are extremely difficult to put into the framework of a single article.  That's why I decided to publish several articles at once in one.  More precisely, as stated at the beginning of the article, present your small book on the basics of distributed computing, available in electronic form. <br><br>  <b><a href="http://goo.gl/LBblnW">Introduction to Distributed Computing &gt;&gt;</a></b> <br><br>  <b>From this book you will learn:</b> <br><br><ul><li>  about the causal sequence of distributed computing events </li><li>  what is justice, security and vitality </li><li>  what is the cone of the past and the cone of the future for the calculation event </li><li> how logical concurrency differs from physical concurrency </li><li>  why it does not make much sense to talk about a set of global computing states, but it makes sense to talk about a set of computing events </li><li>  how do we arrange distributed computing events into one or more sequences that ‚Äúcould‚Äù occur in the system </li><li>  what is a logical clock, and what is the logical time they count </li><li>  why logical time stops if nothing happens in the system </li><li>  how does scalar time differ from the vector one </li><li>  how and why you can use logical time in distributed algorithms </li><li>  what are the approaches to the effective implementation of vector clocks </li><li>  why can we need matrix time </li><li>  how does a distributed algorithm differ from centralized </li><li>  how to solve the problem of mutual exclusion without using shared variables </li><li>  What categories are all distributed mutual exclusion algorithms divided into? </li><li>  Why do we use logical time in permissions-based algorithms? </li><li>  why is it so difficult for philosophers to have dinner in a distributed system </li><li>  why do we need a conflict graph and a preceding graph </li><li>  why the precedence graph should change over time </li><li>  Why in the algorithms based on the transfer of a marker there is much more than the actual "transfer of the marker" </li><li>  and, I hope, something else ... </li></ul><br>  <b>What does the book consist of and how to read it?</b> <br><br>  In the beginning, I tried in two words to explain what goals were set when writing the book, and how it relates to other literature.  This is the introduction to the book.  It only takes a little over two pages, so it‚Äôs worth reading. <br><br>  The first section is mostly boltological and is devoted to the "quality" features of distributed systems.  If you do not know what a distributed system is and what requirements are imposed on it, then it makes sense to read the first section.  If you know that incoming messages to the receiving process may give an outdated idea of ‚Äã‚Äãthe sending process, just as the light emitted by a distant star gives an idea of ‚Äã‚Äãthe past state of the star, then the first four points can be skip :) Separately, it is worth noting p. 1.5 ‚ÄúInteraction in distributed systems‚Äù, in which I tried to present several simple tasks that demonstrate the difficulties that can be encountered in the development of distributed systems.  We will then solve these problems, armed with theoretical knowledge, so it‚Äôs worth getting to know them. <br><br>  The second section presents the model of distributed computing and the main theory used in the further presentation.  In a sense, this section is key.  However, one must be ready to work with such terms as ‚Äúset / subset‚Äù, ‚Äúbinary relation‚Äù, ‚Äúequivalence relation‚Äù, ‚Äúorder relation‚Äù, ‚Äúlinear / partial order‚Äù.  In this section, you will find evidence of some statements.  It seems to me that they should, at a minimum, be overlooked (and better studied) for a deeper understanding of the essential features of the functioning of distributed systems, distinguishing them from systems of other classes. <br><br>  On the basis of the theory presented above, the third section finally considers more practical things, namely, the various mechanisms of logical clocks.  With their help, we can arrange events in one or several sequences that could occur in the system, which allows us to significantly simplify the development of algorithms for distributed systems.  Examples of the use of logical clocks for solving the problems formulated in paragraph 1.5 ‚ÄúInteraction in distributed systems‚Äù are given. <br><br>  The fourth section is devoted to the study of the basic distributed mutual exclusion algorithms, built without the use of the usual shared variables.  The key ideas of these algorithms are also used to solve many other problems in distributed systems.  In addition, their study allows to reveal such important issues as ensuring the security properties and survivability of distributed algorithms.  Therefore, this section seems to me very useful for review. <br><br>  <b>Who is this book focused on?</b> <br><br>  The material of the book should be considered as an introduction to the issue of distributed computing.  She grew out of the academic high school environment, and would certainly be useful if you are just starting to work in this area.  If you already have some experience in the development of distributed systems and algorithms, perhaps you will find something new for yourself and share your opinion in the comments.  If you have many years of experience behind you and are an expert in this topic, I hope that you will be able to supplement me with your thoughts and thoughts. <br><br>  <b>What would I like?</b> <br><br>  I would be glad if the material of the book will be useful and informative for you - there will be time to come back here after reading it and write a ‚Äúthank you‚Äù, I will be grateful.  In addition, I would like to collect all the material on the topic, including comments, questions and answers in one place, in order to send everyone here, including new courses of new students.  If you can help and supplement the material with your thoughts, your experience, I will be doubly grateful.  Read, gain knowledge and use them in your work!  Download the book in PDF format right now at the link below: <br><br>  <b><a href="http://goo.gl/LBblnW">Introduction to Distributed Computing &gt;&gt;</a></b> <br><br>  Successes! <br>  Mikhail Kosyakov <br><br>  <b>Instead of an epilogue.</b>  "Information, unlike resources, is conceived to be shared."  Robert Kiyosaki </div><p>Source: <a href="https://habr.com/ru/post/232361/">https://habr.com/ru/post/232361/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232347/index.html">Parsing email addresses from a string in C #</a></li>
<li><a href="../232351/index.html">VKApp Treatment for iPhone</a></li>
<li><a href="../232353/index.html">Social engineering in practice: ‚Äúphysical access‚Äù to Kevin Mitnick‚Äôs private conference</a></li>
<li><a href="../232357/index.html">Android Tablet instead of Auto Radio</a></li>
<li><a href="../232359/index.html">Scan mail. Has Google gone too far?</a></li>
<li><a href="../232363/index.html">DNS failure with registrar R01 and some fatal accidents</a></li>
<li><a href="../232367/index.html">A selection of backend libraries</a></li>
<li><a href="../232369/index.html">Why there are no simple solutions that it is better to buy servers or optimize code</a></li>
<li><a href="../232381/index.html">In the wake of Spring Pet Clinic. Maven / Spring Context / Spring Test / Spring ORM / Spring Data JPA</a></li>
<li><a href="../232383/index.html">Meeting the comet today</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>