<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JBrainfuck - Writing a Brainfuck compiler for Java VM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long been interested in the question of writing my own compiler for a Java VM, but there was not enough experience to do this. Yes, and somehow...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JBrainfuck - Writing a Brainfuck compiler for Java VM</h1><div class="post__text post__text-html js-mediator-article">  I have long been interested in the question of writing my own compiler for a Java VM, but there was not enough experience to do this.  Yes, and somehow did not reach the hands, and recently still decided to understand this topic and at the same time to talk about his experience in creating a compiler for this VM. <br><br>  Take <a href="http://ru.wikipedia.org/wiki/Brainfuck">Brainfuck</a> as the implemented language.  It is easy to implement, which is great for studying this topic, but first I will give you my own implementation. <br><br>  <b>JBrainfuck</b> is an optimizing Brainfuck interpreter and compiler for Java VM.  Thanks to JIT has high performance. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  License: MIT </li><li>  Project address: <a href="https://github.com/SystemX-Files/jbrainfuck/">https://github.com/SystemX-Files/jbrainfuck/</a> </li><li>  Platforms: Linux, Windows, MacOS and wherever there is Java. </li></ul><br><a name="habracut"></a><br><h4>  Selection of development tools </h4><br>  An obvious solution would be to write a Java compiler. <br>  To generate the bytecode, take the <a href="http://asm.ow2.org/">ASM</a> library.  It is used by such popular languages ‚Äã‚Äãas Groovy, JRuby, and others. <br><a name="plugins"></a>  To conveniently view the JVM bytecode, install the plugins in our IDE. <br><br><ul><li>  <a href="http://asm.ow2.org/eclipse/index.html">Bytecode Outline</a> - for Eclipse </li><li>  <a href="http://plugins.jetbrains.com/plugin/5918">ASM Bytecode Outline</a> - for IDEA </li></ul><br><br><h4>  We start to create </h4><br>  I think many people know the Brainfuck language that we implement.  It consists of only 8 simple commands, but nevertheless it is full in turing, which allows you to implement anything in this language, even OS ( <s>God forbid</s> ). <br>  Its essence is simple.  We have a memory tape, on which you can move to the right or left, as well as change the value of the cell, adding or subtracting it. <br><br>  Here is a list of these commands: <br><table><tbody><tr><th>  Team brainfuck </th><th>  Analog in Java </th><th>  Description </th></tr><tr><td>  Start <br>  programs </td><td><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">30000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">15000</span></span>;</code> </pre> </td><td>  Allocate memory for tape <br>  and put the position in the middle </td></tr><tr><td> <code>&lt;</code> </td> <td><pre> <code class="java hljs">i--;</code> </pre> </td><td>  Jump left </td></tr><tr><td> <code>&gt;</code> </td> <td><pre> <code class="java hljs">i++;</code> </pre> </td><td>  Go right on tape </td></tr><tr><td>  + </td><td><pre> <code class="java hljs">arr[i]++;</code> </pre> </td><td>  Add 1 to current cell </td></tr><tr><td>  - </td><td><pre> <code class="java hljs">arr[i]--;</code> </pre> </td><td>  Subtract 1 from current cell </td></tr><tr><td>  . </td><td><pre> <code class="java hljs">System.out.print(arr[i]);</code> </pre> </td><td>  Display the value of the current cell </td></tr><tr><td>  , </td><td><pre> <code class="java hljs">arr[i] = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)System.in.read();</code> </pre> </td><td>  Enter the value of the current cell </td></tr><tr><td>  [ </td><td><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(arr[i] != <span class="hljs-number"><span class="hljs-number">0</span></span>) {</code> </pre> </td><td>  We work in a loop until the value is zero </td></tr><tr><td>  ] </td><td><pre> <code class="java hljs">}</code> </pre> </td><td>  Transition to the beginning of the cycle </td></tr></tbody></table>  Sample Brainfuck program printing ‚ÄúHello, Habr!‚Äù: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="hljs django"><span class="xml"><span class="xml">++++++++[&gt;+&gt;++&gt;+++&gt;++++&gt;+++++&gt;++++++&gt;+++++++&gt;++++++++&gt; +++++++++&gt;++++++++++&gt;+++++++++++&gt;++++++++++++&gt;++++++++ +++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++++++++++++++++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">]&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+ ++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;----.++++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+.-</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;++.--</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;++.--</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;</span></span></span><span class="xml">&gt;&gt;&gt;+.-</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span></span></span></code> </pre></div></div><br><h5>  Writing compiler </h5><br>  Since we are going to write the compiler according to all the rules, it will have three stages of compilation: lexical analysis, optimization and generation of bytecode. <br>  For a start, it is worth considering the possible optimization, it will allow you to find out how convenient it is to design a compiler. <br><br><h6>  Optimization </h6><br>  Probably the first thing that catches your eye is the same type of operation.  Of course, the idea immediately appears to compress this whole thing and reduce a lot of operations to the form <code>#~</code> , where <b>#</b> is the number of operations, and <b>~</b> is an operation. <br>  Also, a code of the form <code>[-]</code> or <code>[+]</code> is cell zeroing, so it makes sense to select a separate operation for this. <br><br>  If you further promote the idea of ‚Äã‚Äãreducing the number of operations, then you can understand that the operations of addition / subtraction are equivalent and differ only in the sign of the number.  So you can bring them to a single operation.  The same is also valid for left / right movement operation. <br><a name="opcodetable"></a><br>  After all the optimizations we will create a new table of operations.  Just under it and we will do our compiler. <br><table><tbody><tr><th>  Operation </th><th>  Java analogue </th><th>  Description </th></tr><tr><td>  SHIFT (arg) </td><td><pre> <code class="java hljs">i += arg;</code> </pre> </td><td>  Ribbon Shift </td></tr><tr><td>  ADD (arg) </td><td><pre> <code class="java hljs">arr[i] += arg;</code> </pre> </td><td>  Addition (subtract negative number) </td></tr><tr><td>  ZERO </td><td><pre> <code class="java hljs">arr[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> </td><td>  Zeroing </td></tr><tr><td>  OUT (arg) </td><td><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(arg --&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) System.out.print(arr[i]);</code> </pre> </td><td>  Print <i>arg</i> times </td></tr><tr><td>  IN (arg) </td><td><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(arg --&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) arr[i] = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)System.in.read();</code> </pre> </td><td>  Enter cell <i>arg</i> times </td></tr><tr><td>  WHILE </td><td><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(arr[i] != <span class="hljs-number"><span class="hljs-number">0</span></span>) {</code> </pre> </td><td></td></tr><tr><td>  END </td><td><pre> <code class="java hljs">}</code> </pre> </td><td></td></tr></tbody></table><br><a name="opcodeclass"></a>  We write a class that will store the operation and the number of repetitions. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Opcode</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type{ SHIFT, ADD, ZERO, OUT, IN, WHILE, END } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Type type = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  public int arg = 1; //-  public Opcode(Type type, int arg) { this.type = type; this.arg = arg; } public Opcode(Type type) { this.type = type; } public Opcode clone(){ return new Opcode(type, arg); } }</span></span></code> </pre></div></div><br><br><h6>  Lexical analyzer </h6><br>  Select the tokens that can appear in the Brainfuck code: <br><table><tbody><tr><th>  Lexeme </th><th>  Operation </th></tr><tr><td> <code>&lt;</code> </td> <td>  SHIFT with - </td></tr><tr><td> <code>&gt;</code> </td> <td>  SHIFT + </td></tr><tr><td> <code>+</code> </td> <td>  ADD with + </td></tr><tr><td> <code>-</code> </td> <td>  ADD with - </td></tr><tr><td> <code>.</code> </td> <td>  Out </td></tr><tr><td> <code>,</code> </td> <td>  IN </td></tr><tr><td> <code>[</code> </td> <td>  WHILE </td></tr><tr><td> <code>]</code> </td> <td>  END </td></tr><tr><td>  <code>[-]</code> or <code>[+]</code> </td><td>  ZERO </td></tr></tbody></table><br>  Now let's write an analyzer that highlights the sequence of these tokens: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tokenizer</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Opcode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   (       ) List&lt;Opcode&gt; retValue = new ArrayList&lt;Opcode&gt;(); int pos = 0; //    while (pos &lt; code.length()) { switch (code.charAt(pos++)) { //   ,    case '&gt;': retValue.add(new Opcode(Opcode.Type.SHIFT, +1)); break; case '&lt;': retValue.add(new Opcode(Opcode.Type.SHIFT, -1)); break; case '+': retValue.add(new Opcode(Opcode.Type.ADD, +1)); break; case '-': retValue.add(new Opcode(Opcode.Type.ADD, -1)); break; case '.': retValue.add(new Opcode(Opcode.Type.OUT)); break; case ',': retValue.add(new Opcode(Opcode.Type.IN)); break; case '[': char next = code.charAt(pos); //,      ([+]  [-]) if((next == '+' || next == '-') &amp;&amp; code.charAt(pos + 1) == ']') { retValue.add(new Opcode(Opcode.Type.ZERO)); pos += 2; } else retValue.add(new Opcode(Opcode.Type.WHILE)); break; case ']': retValue.add(new Opcode(Opcode.Type.END)); break; } } return retValue; } }</span></span></code> </pre></div></div><br><h6>  Optimizer </h6><br>  Now our task is to compress recurring operations and remove unnecessary (for example, several ZERO commands in a row). <br>  Everything is done relatively simply: <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Optimizer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Opcode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optimize(Tokenizer.tokenize(code)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Opcode&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Opcode&gt; tokens)</span></span></span><span class="hljs-function"> </span></span>{ Stack&lt;Opcode&gt; retValue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;Opcode&gt;(); <span class="hljs-comment"><span class="hljs-comment">//    for (Opcode token : tokens) { switch (token.type){ case SHIFT: case ADD: case OUT: case IN: case ZERO: //   ,       if(retValue.size() == 0) { retValue.push(token.clone()); continue; } //      ,     if(retValue.peek().type != token.type) { if(retValue.peek().arg == 0) //     "" retValue.pop(); //    if(retValue.peek().type == Opcode.Type.ZERO) //   ZERO retValue.peek().arg = 1; //   ,      retValue.push(token.clone()); //   continue; } //    ,     //        retValue.peek().arg += token.arg; break; case WHILE: case END: //    retValue.add(token.clone()); break; } } return retValue; } }</span></span></code> </pre></div></div><br><h6>  Bytecode generator </h6><br>  We proceed to the most difficult and interesting part, to the generation of bytecode under Java VM.  To understand how to generate baytkod, we will help <a href="https://habr.com/ru/post/229267/">previously</a> installed plugins for IDE.  Let's get started <br><br>  First we need to allocate memory for the tape and set the position.  Simply create a class with a method without parameters and declare an array and a variable for the position in it. <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  public void test() { char[] arr = new char[30000]; int i = 15000; // }</span></span></code> </pre><br>  Now we need to look at the bytecode that the Java compiler will create from this code.  To do this, call the Show Bytecode outline command from the context menu of the editor (for IDEA this way).  The environment will compile the class with our method and show bytecode.  We find our method and watch it. <br>  For a more confident understanding of the result, it is advisable to look at <a href="http://en.wikipedia.org/wiki/Java_bytecode_instruction_listings">the JVM instruction table</a> . <br><br><pre> <code class="hljs ruby"> public test()V /<span class="hljs-regexp"><span class="hljs-regexp">/  ,            ( ) L0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ VM,    5       L0 LINENUMBER 5 L0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     short   30000 SIPUSH 30000 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   T_CHAR       , -    ( ) NEWARRAY T_CHAR /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       1 (     JVM) ASTORE 1 L1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  LINENUMBER 6 L1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 5   L1 SIPUSH 15000 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ISTORE 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   integer    2 L2 LINENUMBER 7 L2 RETURN /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   L3 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     LOCALVARIABLE this LByteCodeTest; L0 L3 0 LOCALVARIABLE arr [C L1 L3 1 LOCALVARIABLE i I L2 L3 2 MAXSTACK = 1 MAXLOCALS = 3</span></span></code> </pre><br>  Now we have an idea how our code works at the bytecode level.  Remove labels, specify the line number and all after return.  This information is not needed for correct operation.  As a result, we get this: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  SIPUSH 30000 NEWARRAY T_CHAR ASTORE 1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  SIPUSH 15000 ISTORE 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ RETURN</span></span></code> </pre><br>  So far, everything is more or less simple.  In the JVM, most of the operations after execution remove their arguments from the stack.  It is very convenient and no need to clean up after.  Now we will add all operations to our method, so far without cycles, including in the input / output, which we have described in the <a href="https://habr.com/ru/post/229267/">table</a> . <br>  It turns out something like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  read() char[] arr = new char[30000]; int i = 15000; i += 1111; arr[i] += 2222; arr[i] = 0; System.out.print(arr[i]); arr[i] = (char) System.in.read(); }</span></span></code> </pre><br>  In this case, the meaning of the code is not important to us, it is important for us to see the bytecode of operations. <br>  Remove the extra instructions and see it: <br><br><pre> <code class="hljs ruby">public test()V throws java/io/IOException /<span class="hljs-regexp"><span class="hljs-regexp">/  SIPUSH 30000 NEWARRAY T_CHAR ASTORE 1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  SIPUSH 15000 ISTORE 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   1111 IINC 2 1111 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    2222 ALOAD 1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ILOAD 2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    DUP2 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      CALOAD /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    char  ,        (   CASTORE) SIPUSH 2222 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    2222 IADD /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      I2C /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     char (     integer) CASTORE /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ALOAD 1 ILOAD 2 ICONST_0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  JVM   0 (  ) CASTORE /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   GETSTATIC java/lang</span></span><span class="hljs-regexp"><span class="hljs-regexp">/System.out : Ljava/io</span></span><span class="hljs-regexp"><span class="hljs-regexp">/PrintStream; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  (  )    ALOAD 1 ILOAD 2 CALOAD /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  INVOKEVIRTUAL java/io</span></span><span class="hljs-regexp"><span class="hljs-regexp">/PrintStream.print (C)V /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ALOAD 1 ILOAD 2 GETSTATIC java/lang</span></span><span class="hljs-regexp"><span class="hljs-regexp">/System.in : Ljava/io</span></span><span class="hljs-regexp"><span class="hljs-regexp">/InputStream; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  INVOKEVIRTUAL java/io</span></span><span class="hljs-regexp"><span class="hljs-regexp">/InputStream.read ()I /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  I2C CASTORE /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ RETURN</span></span></code> </pre><br>  Now we have bytecode of all the operations we need to implement the generator without cycles. <br>  I want to note that the <code>I2C</code> instruction is not required (ascertained empirically).  I can assume that the dimension of the type is also controlled by the <code>CALOAD</code> instruction <code>CALOAD</code> and as a result, the presence of <code>I2C</code> loses its meaning.  We will also replace the <code>SIPUSH</code> instruction with <code>LDC</code> (add an integer constant to the stack), because our compiler stores repetitions in an integer (the field type arg is in the class <a href="https://habr.com/ru/post/229267/">Opcode</a> ). <br><br>  Let's start the code generator with the fact that in Java everything is stored in classes, so during the generation it will create the class.  The ASM library has great tools for generating them.  It all comes down to a simple construction of a class tree, with elements of the form fields, methods, and nested classes.  Methods in themselves store arrays of instructions JVM.  To make it easier to understand how to work with the result of compilation, let our class inherit from the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a> interface. <br><br>  Create an empty class inherited from this interface: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassTest</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } }</code> </pre><br>  And see the baytkod: <br><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> <span class="hljs-number"><span class="hljs-number">52.0</span></span> (<span class="hljs-number"><span class="hljs-number">52</span></span>) // <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> flags <span class="hljs-number"><span class="hljs-number">0x21</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ClassTest implements java/lang/Runnable { // <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> flags <span class="hljs-number"><span class="hljs-number">0x1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> &lt;init&gt;()V L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">3</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> INVOKESPECIAL java/lang/<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.&lt;init&gt; ()V <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> L1 LOCALVARIABLE this LClassTest; L0 L1 <span class="hljs-number"><span class="hljs-number">0</span></span> MAXSTACK = <span class="hljs-number"><span class="hljs-number">1</span></span> MAXLOCALS = <span class="hljs-number"><span class="hljs-number">1</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">access</span></span> flags <span class="hljs-number"><span class="hljs-number">0x1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> run()V L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">7</span></span> L0 <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> L1 LOCALVARIABLE this LClassTest; L0 L1 <span class="hljs-number"><span class="hljs-number">0</span></span> MAXSTACK = <span class="hljs-number"><span class="hljs-number">0</span></span> MAXLOCALS = <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br>  As you can see, when generating the bytecode, the <code>init</code> method is added, whose task is to call the parent constructor.  This moment should be taken into account and do not forget to add this method. <br><br>  For class generation there is a class <a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/tree/ClassNode.html">ClassNode</a> , and for <a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/tree/MethodNode.html">MethodNode</a> methods. <br>  You can generate our empty class as follows (without taking into account labels and line numbers): <br><br><pre> <code class="java hljs">ClassNode cn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ClassNode(); cn.version = V1_8; <span class="hljs-comment"><span class="hljs-comment">//  ASM cn.access = ACC_PUBLIC + ACC_SUPER; // ,   ACC_SUPER,    cn.name = "ClassTest"; //  cn.superName = "java/lang/Object"; //   cn.interfaces.add("java/lang/Runnable"); //  { //  public void &lt;init&gt;() MethodNode mn = new MethodNode(ACC_PUBLIC, "&lt;init&gt;", "()V", null, null); //   InsnList il = mn.instructions; //   //     JVM il.add(new VarInsnNode(ALOAD, 0)); il.add(new MethodInsnNode(INVOKESPECIAL, cn.superName, "&lt;init&gt;", "()V", false)); // il.add(new InsnNode(RETURN)); //    cn.methods.add(mn); } { //  public void run() MethodNode mn = new MethodNode(ACC_PUBLIC, "run", "()V", null, null); //   InsnList il = mn.instructions; // il.add(new InsnNode(RETURN)); //    cn.methods.add(mn); } //,     //  COMPUTE_FRAMES    // -        (    JVM) //        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES); // ClassNode  ClassWriter cn.accept(cw); cw.toByteArray(); // </span></span></code> </pre><br>  Now the task is to implement the addition of instructions to the <code>run</code> method from the array with Brainfuck operations.  Let's do this through the usual <code>switch</code> . <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        //     opcodes,     Brainfuck public byte[] toByteCode(String className, int memorySize){ // ...................... MethodNode mn = new MethodNode(ACC_PUBLIC, "run", "()V", null, null); InsnList il = mn.instructions; //   memorySize il.add(new LdcInsnNode(memorySize)); //     integer il.add(new IntInsnNode(NEWARRAY, T_CHAR)); //  il.add(new VarInsnNode(ASTORE, 1)); //     1 //  il.add(new LdcInsnNode(memorySize / 2)); il.add(new VarInsnNode(ISTORE, 2)); //     2 //    for (Opcode opcode : opcodes) { switch (opcode.type) { case SHIFT: //     opcode.arg il.add(new IincInsnNode(2, opcode.arg)); break; case ADD: //  opcode.arg   il.add(new VarInsnNode(ALOAD, 1)); il.add(new VarInsnNode(ILOAD, 2)); il.add(new InsnNode(DUP2)); il.add(new InsnNode(CALOAD)); il.add(new LdcInsnNode(opcode.arg)); il.add(new InsnNode(IADD)); il.add(new InsnNode(CASTORE)); break; case ZERO: //  il.add(new VarInsnNode(ALOAD, 1)); il.add(new VarInsnNode(ILOAD, 2)); il.add(new InsnNode(ICONST_0)); il.add(new InsnNode(CASTORE)); break; case OUT: //  opcode.arg  for (int i = 0; i &lt; opcode.arg;+i) { il.add(new VarInsnNode(ALOAD, 0)); il.add(new FieldInsnNode(GETFIELD, cn.name, "out", "Ljava/io/PrintStream;")); il.add(new VarInsnNode(ALOAD, 1)); il.add(new VarInsnNode(ILOAD, 2)); il.add(new InsnNode(CALOAD)); il.add(new MethodInsnNode(INVOKEVIRTUAL, "java/io/PrintStream", "print", "(C)V", false)); } break; case IN: //  opcode.arg  for (int i = 0; i &lt; opcode.arg;+i) { il.add(new VarInsnNode(ALOAD, 1)); il.add(new VarInsnNode(ILOAD, 2)); il.add(new VarInsnNode(ALOAD, 0)); il.add(new FieldInsnNode(GETSTATIC, cn.name, "in", "Ljava/io/InputStream;")); il.add(new MethodInsnNode(INVOKEVIRTUAL, "java/io/InputStream", "read", "()I", false)); il.add(new InsnNode(CASTORE)); } break; case WHILE: break; case END: break; } } // ...................... }</span></span></code> </pre><br>  It remains to solve the problem with cycles.  Again, we will resort to viewing the test method bytecode: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[<span class="hljs-number"><span class="hljs-number">30000</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">15000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// while(arr[i] != 0) { i += 10000000; } }</span></span></code> </pre><br>  Here is its byte code: <br><br><pre> <code class="sql hljs">public test()V L0 LINENUMBER 6 L0 SIPUSH 30000 NEWARRAY T_CHAR ASTORE 1 L1 LINENUMBER 7 L1 SIPUSH 15000 ISTORE 2 L2 LINENUMBER 9 L2 FRAME APPEND [[CI] //  //   ALOAD 1 ILOAD 2 CALOAD IFEQ L3 //   ,     L3 ( ) L4 LINENUMBER 10 L4 //  ILOAD 2 LDC 10000000 IADD ISTORE 2 //      L2 (  -  ) GOTO L2 L3 LINENUMBER 12 L3 //FRAME SAME //   RETURN</code> </pre><br>  As a result, for the cycles, we just need to correctly place the labels and transitions for them. <br>  For labels there is a class <a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/tree/LabelNode.html">LabelNode</a> , in fact the object itself is a label.  Where it is inserted among the instructions, there we go. <br>  To jump, use the <a href="http://asm.ow2.org/asm50/javadoc/user/org/objectweb/asm/tree/JumpInsnNode.html">JumpInsnNode</a> class.  The first argument indicates the type of transition (unconditional or any of the conditional) and the second argument is the label itself, where the transition will be made. <br>  For the distribution of labels with regard to nesting, we use the stack.  Those.  met the beginning of the cycle, saved the label to the stack, met the end, pulled out the label and registered transitions. <br>  Here is the result: <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">// Stack&lt;LabelNode&gt; lbls = new Stack&lt;LabelNode&gt;(); MethodNode mn = new MethodNode(ACC_PUBLIC, "run", "()V", null, null); // ...................... for (Opcode opcode : opcodes) { switch (opcode.type) { // ........................ case WHILE: //      LabelNode begin = new LabelNode(), end = new LabelNode(); //    lbls.push(end); lbls.push(begin); //  il.add(begin); //  il.add(new VarInsnNode(ALOAD, 1)); il.add(new VarInsnNode(ILOAD, 2)); il.add(new InsnNode(CALOAD)); il.add(new JumpInsnNode(IFEQ, end)); //    ,     break; case END: //   il.add(new JumpInsnNode(GOTO, lbls.pop())); //  il.add(lbls.pop()); break; } }</span></span></code> </pre><br><br><h6>  Performing bytecode </h6><br>  Now all this business needs to be started somehow, but first we will load this class.  Unfortunately, Java does not provide a regular API for this purpose, so we will resort to crutches like this ( <s>wherever without them</s> ): <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteCodeLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassLoader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ByteCodeLoader clazz = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteCodeLoader(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Class&lt;?&gt; loadClass(<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bytecode) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defineClass(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, bytecode, <span class="hljs-number"><span class="hljs-number">0</span></span>, bytecode.length); } }</code> </pre><br>  And the download and launch itself will look like this: <br><br><pre> <code class="java hljs">Class&lt;?&gt; aClass = ByteCodeLoader.clazz.loadClass( <span class="hljs-comment"><span class="hljs-comment">//     toByteCode( //  "BrainFuckJit", // 30000 //  ) ); ((Runnable)aClass.newInstance()).run(); //   </span></span></code> </pre><br><br><h4>  Performance tests </h4><br>  It will be interesting to find out how smart the option we have turned out.  For this there is a special program on Brainfuck, which has many nested loops and is good for performance testing. <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">&gt;+&gt;+&gt;+&gt;+&gt;++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">[</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+++</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">- &gt;&gt;&gt;&gt;&gt; &gt;+&gt;+&gt;+&gt;+&gt;++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">[</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+++</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">- &gt;&gt;&gt;&gt;&gt; &gt;+&gt;+&gt;+&gt;+&gt;++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">[</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+++</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">- &gt;&gt;&gt;&gt;&gt; &gt;+&gt;+&gt;+&gt;+&gt;++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">[</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">+++</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">- &gt;&gt;&gt;&gt;&gt; +++[-&gt;+++++</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">]</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">[-]</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; &lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;</span></span></span><span class="xml">[-] </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;</span></span></span><span class="xml">[-] </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;</span></span></span><span class="xml">[-] </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt;&lt;&lt;&lt; ]&lt;&lt;]&gt;</span></span></span><span class="xml">.</span></span></code> </pre><br>  This code is also suitable for the compiler performance test, at the end of the program a symbol with code 202 is output, if so, then everything is fine. <br>  We will conduct 6 tests.  Let's check the usual Brainfuck interpreter, JVM compiler and compilation in VC ++.  Each test will be tested with and without optimization (from Brainfuck). <br><br>  Test results (less is better): <br><img src="//habrastorage.org/files/7bb/596/bc3/7bb596bc34ff4a6b932eddb233fdf347.png"><br><br>  As you can see, our efforts were not in vain.  JIT compilation in Java VM did its job and brought the performance to the level of native execution. <br><br><h4>  Conclusion </h4><br>  Java VM is a very convenient platform for implementing your own languages.  VM with a thoughtful set of instructions and a convenient API allow you to write your language in a fairly short time. <br>  Although the lack of simple and understandable tutorials on ASM at first complicates understanding of how the library works and is able to guide you to various ancient rakes, while the library itself offers elegant solutions. <br>  And the purpose of this article was to fill this gap and give the opportunity to start creating as soon as possible. <br>  I hope I did it. <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/229267/">https://habr.com/ru/post/229267/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229253/index.html">Dnepropetrovsk Android Practice Leaders Community Meeting, dedicated to UX, July 10</a></li>
<li><a href="../229257/index.html">IT Distribution, a member of the group of companies MUK, received the status: "Oracle Platinum Partner"</a></li>
<li><a href="../229259/index.html">7 problems in the design of SaaS products, and how we solved them</a></li>
<li><a href="../229261/index.html">GUI in the game World of Tanks. Part Two: GUI Structure Overview and Future Plans</a></li>
<li><a href="../229263/index.html">Login to a web application using face recognition</a></li>
<li><a href="../229269/index.html">The evolution of extension language: the story of Lua</a></li>
<li><a href="../229273/index.html">Tarantool User Group Meetup in Moscow</a></li>
<li><a href="../229279/index.html">How the SMSDirect system works</a></li>
<li><a href="../229285/index.html">IBM Watson will help cooks to create new recipes using the new application</a></li>
<li><a href="../229287/index.html">Theme for night reading Habrahabr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>