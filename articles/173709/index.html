<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with the LCD indicator on the debug board STM32L-Discovery</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Theory 
 General information 
 A liquid crystal display (LCD, LCD. Liquid crystal display) is installed on the debug board STM32L-Discovery, which has...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with the LCD indicator on the debug board STM32L-Discovery</h1><div class="post__text post__text-html js-mediator-article"><h2>  Theory </h2><br><h4>  General information </h4><br>  A liquid crystal display (LCD, LCD. Liquid crystal display) is installed on the debug board STM32L-Discovery, which has six 14 segment signs, 4 colons (Colon), 4 points (DP), 4 bars (Bar).  All segments are grouped into COM0, COM1, COM2, COM3 groups of 24 segments.  Each group has its own separate "common wire". <br><img src="https://habrastorage.org/getpro/habr/post_images/1a6/a81/307/1a6a81307daf4147af68a7ffe38d2633.png" align="right"><br><img src="https://habrastorage.org/getpro/habr/post_images/d62/0cf/be0/d620cfbe073ef69a74c43899fc35bb9b.png" align="right"><br>  The STM32L152RBT6 microcontroller is installed on the debug board.  The microcontroller has a built-in LCD controller, which controls monochrome liquid-crystal indicators. <br>  LCD controller: <br><ol><li>  Allows you to customize the update rate (frame rate - the frequency with which the information on the LCD is updated) </li><li>  Supports static and multiplex control mode </li><li>  Supports software contrast setting </li><li>  Allows you to use several levels of control voltage (up to four) </li><li>  Uses double buffering, allowing you to update data in LCD_RAM ‚Äã‚Äãregisters at any time during program execution, without compromising the integrity of the displayed information </li></ol><br><h4>  LCD controller memory registers </h4><br>  In the STM32L152RB microcontroller, special LCD_RAM ‚Äã‚Äãregisters are allocated, the information stored in which corresponds to the COM0 - COM3 group of segments.  Each group corresponds to two 32-bit registers.  This number of registers allows the microcontroller to control the LCD with a large number of segments than that installed on the debug board. <br><br>  To control a LCD with 176 segments, 4 groups of COM0 - COM3 with 44 segments each are used; for managing LCDs with 320 segments, 8 groups of COM0 - COM7 with 40 segments each are used. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/c9b/f00/66a/c9bf0066a6cd5f4b988c7404abc7b0d7.png"><br><img src="https://habrastorage.org/getpro/habr/post_images/ac6/251/b70/ac6251b70528de96a2772397d6810c4e.png"><br>  On the STM32L-Discovery debug board, the LCD uses 96 segments, divided into 4 groups COM0 - COM3 with 24 segments each. <br><img src="https://habrastorage.org/getpro/habr/post_images/58e/b99/ed8/58eb99ed8208ba89e78bff8a6733efe2.png"><br>  The LCD on the STM32L-Discovery debug board is connected in such a way that the S40, S41 bits of the second LCD_RAM ‚Äã‚Äãregisters in each group and the S0-S27 bits of the first LCD_RAM ‚Äã‚Äãregisters are used.  To reduce the number of registers used, the information from the S40-S43 bits will be written to the free bits of S28-S31 using the remapping function. <br><br><h4>  Block frequency dividers </h4><br>  The block of frequency dividers (Frequency generator) allows to achieve different frame rates (frame rates) on the LCD in the range from 32 kHz to 1 MHz.  The source of the clock signal can be used: <br><ol><li>  External low-frequency generator with a frequency of 32 kHz (LSE. Low speed external) </li><li>  37 kHz internal low frequency generator (LSI. Low speed internal) </li><li>  External RF generator with frequency dividers at 2.4,8 and 16 and a maximum frequency of 1 MHz.  (HSE. High speed external) </li></ol><br>  To achieve accurate synchronization and reduce the offset of the DC voltage across the LCD segments, the clock source must be stable.  The clock signal LCDCLK enters the LCD controller.  The frequency of the clock signal is divided in accordance with the division factors, which are set by the PS [3: 0], DIV [3: 0] bits of the LCD_FCR (Frame Control Register) register.  The resulting frequency at the output of the frequency divider unit is calculated by the formula: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      f <sub>ck_div</sub> = F <sub>LCDCLK</sub> / (2 <sup>PS</sup> * (16 + DIV)) <br><br>  The frame rate is calculated by the formula: <br><br>  f <sub>Frame</sub> = f <sub>ck_div</sub> * duty <br><br>  where duty is the fill factor is the ratio of the pulse duration to its period.  During one frame, the LCD displays the information from the registers LCD_RAM ‚Äã‚Äã[x], LCD_RAM ‚Äã‚Äã[x + 1] and so on.  For the LCD installed on the debug board, for one frame the LCD controller should output information from 4 groups of COM0 - COM3 segments, therefore, the duration of the control pulse for one group will be 1/4 of the frame duration, i.e.  duty = 1/4. <br><br><h4>  LCD control </h4><br>  There are two ways to control the LCD - static control mode and multiplex control mode.  With a static display, each segment of the discharge indicator is connected to the output of the microcontroller.  With reference to the LCD, on the STM32LDiscovery debug board, 6 * 14 = 84 microcontroller pins will be required (excluding colons, points and stripes).  Due to the use of so many pins, the connection of other peripherals will become impossible.  The STM32L152RB microcontroller has 64 outputs.  In multiplex control mode (dynamic control mode), the same segments of the indicator bits are combined into groups.  Information is displayed due to the alternate ignition of the segments of the indicator discharges, with a frequency that is not perceived by the human eye. <br><br>  Multiplexed control allows you to manage a large number of segments.  Instead of managing each element separately, they can be addressed in rows and columns (COM and SEG), so the control circuit is simplified, since  each segment does not need its own control line.  To enable the selected segment, it is necessary to apply the potential difference COM and SEG to it.  Example of the first digit of the indicator (the indicator displays "1:"): <br><img src="https://habrastorage.org/getpro/habr/post_images/fb6/bf4/693/fb6bf46935187984af7529a526bb60fa.png"><br>  <i>The first digit of the indicator at time t <sub>0</sub></i> <br><img src="https://habrastorage.org/getpro/habr/post_images/669/31e/bc2/66931ebc24d32c287b21e6f624e028da.png"><br>  <i>The first digit of the indicator at time t <sub>1</sub></i> <br><img src="https://habrastorage.org/getpro/habr/post_images/2c0/ccd/fe9/2c0ccdfe92b58ca51e538644501512c3.png"><br>  <i>The first digit of the indicator at time t <sub>2</sub></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/04b/8d9/110/04b8d9110d84ac92b80c043806fbccab.png"><br>  <i>The general scheme of connecting segments to the conclusions of the LCD</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb8/998/825/cb8998825ca328a7eecd8a836458d3cd.png"><br>  <i>Wiring diagram of the conclusions of the LCD to the ports of the microcontroller</i> <br><br>  For SEG lines, a control voltage is used, the number of levels of which is determined by the bias coefficient.  The LCD on the debug board uses multiplex control mode with duty = 1/4 and bias = 1/3.  The duty and bias values ‚Äã‚Äãare set via the LCD_CR (Control Register) register in the DUTY [2: 0] and BIAS [1: 0] bits. <br><br><h2>  Practice </h2><br><h4>  Configuring Microcontroller Ports </h4><br>  To control the LCD, the ports of the microcontroller must be configured accordingly: <br><ol><li>  To the exit </li><li>  Using the alternative function AF 11 (Alternate function) </li><li>  Have a frequency output to the port of 400 kHz </li><li>  Use the push-pull mode </li><li>  Without pull-up resistors </li></ol><br>  When the port is in alternate function mode, the output data buffer of the port is controlled by signals coming from the periphery.  The header file stm32lxx.h of the CMSIS library contains a description of all the peripheral registers, as well as the structure of access to them. <br><br>  The pins of the LCD are connected to the GPIOA ports (PA1-PA3, PA8-PA10, PA15), GPIOB (PB3-PB5, PB8-PB15), GPIOC (PC0-PC3, PC6-PC11) of the microcontroller.  To operate the LCD, a clock signal must be sent to the selected ports.  Clocking the GPIO ports of the microcontroller comes from the AHB bus of the RCC (Reset and Clock Control) system bus - clocking and reset system.  The clock signal is supplied by setting the corresponding bits in the RCC_AHBENR register (AHB peripheral clock enable register). <br><img src="https://habrastorage.org/getpro/habr/post_images/d9d/235/3c2/d9d2353c27554a5829f0a12b8b4b5790.jpg"><br>  <i>Register RCC_AHBENR (the figure shows the first 15 bits)</i> <br><br>  For ports GPIOA, GPIOB, GPIOC, you must set 1 in 0, 1, 2 bits of the register. <br><blockquote>  <i>Next, I will give the code to write information to the register using bitmasks and using hexadecimal codes.</i>  <i>Using bitmasks is more convenient, but working with hexadecimal codes allows you to understand the essence of working with registers.</i> </blockquote><br><pre><code class="hljs php">RCC-&gt;AHBENR |=(RCC_AHBENR_GPIOAEN|RCC_AHBENR_GPIOBEN|RCC_AHBENR_GPIOCEN);  RCC-&gt;AHBENR = <span class="hljs-number"><span class="hljs-number">0x7</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0x7=111 */</span></span></code> </pre> <br><br>  To specify the port operation modes, the GPIOx_MODER (GPIO port mode register) register is used (x = A..H).  All register bits are grouped into MODERy groups [1: 0], where y is the pin number of the corresponding port.  Ports must be configured for alternate function mode, i.e.  in the group responsible for the pin, set the value to 10. For the GPIOA port, you need to configure pins 1-3.8-10.15, that is, set 1 to 3,5,7,17,19,21,31 discharges. <br><img src="https://habrastorage.org/getpro/habr/post_images/e7e/858/181/e7e858181f80e011a6de6e6f715654d7.jpg"><br>  <i>Register GPIOx_MODER (GPIO port mode register)</i> <br><br><pre> <code class="hljs ruby">GPIOA-&gt;MODER <span class="hljs-params"><span class="hljs-params">|= (GPIO_MODER_MODER1_1 |</span></span> GPIO_MODER_MODER2_1 <span class="hljs-params"><span class="hljs-params">| GPIO_MODER_MODER3_1 |</span></span> GPIO_MODER_MODER8_1 <span class="hljs-params"><span class="hljs-params">| GPIO_MODER_MODER9_1 |</span></span> GPIO_MODER_MODER10_1 <span class="hljs-params"><span class="hljs-params">| GPIO_MODER_MODER15_1);  GPIOA-&gt;MODER = 0x802A00A8; /* 0x802A00A8=1000 0000 0010 1010 0000 0000 1010 1000 */</span></span></code> </pre> <br>  The ports of the microcontroller must be put into push-pull mode.  To do this, in the GPIOx_OTYPER (GPIO port output type register) register, set 1 to the bits responsible for the pins. <br><img src="https://habrastorage.org/getpro/habr/post_images/d1e/a49/523/d1ea49523a40a11b4b8d9f341fa11799.jpg"><br>  <i>Register GPIOx_OTYPER (GPIO port output type register)</i> <br><br><pre> <code class="hljs ruby">GPIOA-&gt;OTYPER &amp;= ~(GPIO_OTYPER_OT_1 <span class="hljs-params"><span class="hljs-params">| GPIO_OTYPER_OT_2 |</span></span> GPIO_OTYPER_OT_3 <span class="hljs-params"><span class="hljs-params">| GPIO_OTYPER_OT_8 |</span></span> GPIO_OTYPER_OT_9 <span class="hljs-params"><span class="hljs-params">| GPIO_OTYPER_OT_10 |</span></span> GPIO_OTYPER_OT_15);  GPIOA-&gt;OTYPER &amp;= ~<span class="hljs-number"><span class="hljs-number">0x0000870E</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">/* 0x870E=1000 0111 0000 1110 */</span></span></code> </pre> <br>  Both options affect the selected pins.  (For GPIOA port, pins 1-3,8-10,15 are configured).  If you need to transfer all the pins of the port to the push-pull mode, you can write the value in the register: <br><pre> <code class="hljs erlang-repl">GPIOA-&gt;OTYPER = <span class="hljs-number"><span class="hljs-number">0</span></span>x0;</code> </pre> <br>  To specify the frequency of information output to the port, the GPIOx_OSPEEDR (GPIO port output speed register) register is used.  All register bits are grouped into OSPEEDRy [1: 0] groups, where y is the pin number of the corresponding port.  In this paper, the frequency should be set to 400 kHz i.  in the group responsible for the pin, set the value to 00. <br><img src="https://habrastorage.org/getpro/habr/post_images/3b1/190/e54/3b1190e549378c8db1905c154573dc46.jpg"><br>  <i>Register GPIOx_OSPEEDR (GPIO port output speed register)</i> <br><br><pre> <code class="hljs ruby">GPIOA-&gt;OSPEEDR &amp;= ~(GPIO_OSPEEDER_OSPEEDR1 <span class="hljs-params"><span class="hljs-params">| GPIO_OSPEEDER_OSPEEDR2 |</span></span> GPIO_OSPEEDER_OSPEEDR3 <span class="hljs-params"><span class="hljs-params">| GPIO_OSPEEDER_OSPEEDR8 |</span></span> GPIO_OSPEEDER_OSPEEDR9 <span class="hljs-params"><span class="hljs-params">| GPIO_OSPEEDER_OSPEEDR10 |</span></span> GPIO_OSPEEDER_OSPEEDR15);  GPIOA-&gt;OSPEEDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xC03F00FC</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">/*0xC03F00FC=1100 0000 0011 1111 0000 0000 1111 1100 */</span></span></code> </pre> <br>  If you need to set the output frequency to the 400 kHz port for all pins, you can write the value in the register: <br><pre> <code class="hljs erlang-repl">GPIOA-&gt;OSPEEDR = <span class="hljs-number"><span class="hljs-number">0</span></span>x0;</code> </pre> <br>  To disable pull-up pull-down pull-down resistors for selected pins, use the GPIOx_PUPDR register (GPIO port pullup / pull-down register).  All register bits are grouped into groups PUPDRy [1: 0], where y is the pin number of the corresponding port.  To disable the pull-up resistors in the group responsible for the pin, set to 00. <br><img src="https://habrastorage.org/getpro/habr/post_images/966/2ab/1c5/9662ab1c59b9e44a3f82526a51afab9d.jpg"><br>  <i>Register GPIOx_PUPDR (GPIO port pull-up / pull-down register)</i> <br><br><pre> <code class="hljs ruby">GPIOA-&gt;PUPDR &amp;= ~(GPIO_PUPDR_PUPDR1 <span class="hljs-params"><span class="hljs-params">| GPIO_PUPDR_PUPDR2 |</span></span> GPIO_PUPDR_PUPDR3 <span class="hljs-params"><span class="hljs-params">| GPIO_PUPDR_PUPDR8 |</span></span> GPIO_PUPDR_PUPDR9 <span class="hljs-params"><span class="hljs-params">| GPIO_PUPDR_PUPDR10 |</span></span> GPIO_PUPDR_PUPDR15);  GPIOA-&gt;PUPDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xC03F00FC</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">/*0xC03F00FC=1100 0000 0011 1111 0000 0000 1111 1100 */</span></span></code> </pre> <br>  If you need to disable pull-up resistors for all pins, you can write to the register value: <br><pre> <code class="hljs erlang-repl">GPIOA-&gt;PUPDR = <span class="hljs-number"><span class="hljs-number">0</span></span>x0;</code> </pre> <br>  To use the alternative function for the microcontroller ports, two registers are used: GPIOx_AFRL (GPIO alternate function low register), responsible for the lower pins (0 to 7) and GPIOx_AFRH (GPIO alternate function high register), which is responsible for the higher pins (8 to 15).  All register bits are grouped into AFRLy [3: 0] and AFRHy [3: 0] groups, where y is the pin number of the corresponding port.  Ports must be configured to use the alternative function AF11; for this, the value for the pin group must be set to 1011. <br><img src="https://habrastorage.org/getpro/habr/post_images/f1c/1a5/816/f1c1a58161a2b7b244bf17738ef9fa61.jpg"><br>  <i>Register GPIOx_AFRL (GPIO alternate function low register)</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a3c/01b/25f/a3c01b25fb50f5f21c18de90181715ce.jpg"><br>  <i>Register GPIOx_AFRH (GPIO alternate function high register)</i> <br><br>  To do this, write to the value registers: <br><pre> <code class="hljs php">GPIOA-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xBBB0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0xBBB0 = 1011 1011 1011 0000*/</span></span> GPIOA-&gt;AFR[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">0xB0000BBB</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0xB0000BBB=1011 0000 0000 0000 0000 1011 1011 1011*/</span></span></code> </pre> <br><blockquote>  <i>AFR [0] = 0xBBB0 - writes the value to the GPIOx_AFRL register.</i> <i><br></i>  <i>AFR [1] = 0xB0000BBB - writes the value to the GPIOx_AFRH register.</i> </blockquote><br>  Settings for the corresponding pins of the GPIOB and GPIOC ports are made in the same way. <br><br><h4>  LCD controller setup </h4><br>  When working with the LCD controller, as with other peripherals, it is necessary to send a clock signal to it.  A clock signal is also sent to the power management system.  The controller and power management system for clocking use the bus APB1.  To enable clocking in the RCC_APB1ENR register (APB1 peripheral clock enable register) it is necessary to set 1 in 9 and 28 bits. <br><img src="https://habrastorage.org/getpro/habr/post_images/020/49e/b40/02049eb409559e5be1a6dd11477d75c6.jpg"><br>  <i>Register RCC_APB1ENR (APB1 peripheral clock enable register)</i> <br><br><pre> <code class="hljs php">RCC-&gt;APB1ENR |= RCC_APB1ENR_PWREN|RCC_APB1ENR_LCDEN;  RCC-&gt;APB1ENR |= <span class="hljs-number"><span class="hljs-number">0x10000200</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0x10000200=1 0000 0000 0000 0000 0010 0000 0000 */</span></span></code> </pre> <br>  To operate the LCD controller, you must specify the source of the clock signals.  The source is specified in the RCC_CSR register.  By default, writing to this register is prohibited.  In the PWR power control register (PWR power control register), write protection to the RCC_CSR register is removed.  Register RCC_CSR controls the clocking sources of the RTC clock and the LCD controller <br>  Entry to the RCC_CSR register is permitted by setting 1 to 8 bits of the PWR_CR register. <br><img src="https://habrastorage.org/getpro/habr/post_images/815/7d0/af2/8157d0af284de13ab1a0b92677cd2581.jpg"><br>  <i>Register PWR_CR (PWR power control register)</i> <br><br><pre> <code class="hljs php">PWR-&gt;CR |= PWR_CR_DBP;  PWR-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0x100</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0x100 =1 0000 0000 */</span></span></code> </pre> <br>  To change the clock source of the LCD controller (and the RTC clock too), you must first reset the clock source by setting the RTCRST bit (setting 1 to 23 bits) in the RCC_CSR (Control / status register) register. <br><img src="https://habrastorage.org/getpro/habr/post_images/159/080/9b0/1590809b04b364ae8ddfb4ad54079382.jpg"><br>  <i>Register RCC_CSR (Control / status register)</i> <br><br><pre> <code class="hljs erlang-repl">RCC-&gt;CSR |= RCC_CSR_RTCRST;</code> </pre> <br>  Or by writing a value to the register using the operator "| =", since  value by <br>  The default register is different from 0x0: <br><pre> <code class="hljs php">RCC-&gt;CSR |= <span class="hljs-number"><span class="hljs-number">0x800000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0x800000 = 1000 0000 0000 0000 0000 0000 */</span></span></code> </pre> <br>  To select a new clock source, remove the RTCRST bit: <br><pre> <code class="hljs erlang-repl">RCC-&gt;CSR &amp;= ~RCC_CSR_RTCRST;  RCC-&gt;CSR &amp;= ~<span class="hljs-number"><span class="hljs-number">0</span></span>x800000;</code> </pre> <br>  An external low-frequency generator is selected as the clock source.  To enable the generator in the RCC_CSR register, you must set the LSEON bit (set 1 to 8 bits): <br><pre> <code class="hljs php">RCC-&gt;CSR |= RCC_CSR_LSEON;  RCC-&gt;CSR |= <span class="hljs-number"><span class="hljs-number">0x100</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0x100 = 1 0000 0000 */</span></span></code> </pre> <br>  After turning on the generator, it takes some time to stabilize it.  Generator readiness is checked by the hardware setting of the LSERDY bit in the RCC_CSR register: <br><pre> <code class="hljs lisp">while(!(<span class="hljs-name"><span class="hljs-name">RCC-&gt;CSR&amp;RCC_CSR_LSERDY</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  The selection of an external low-frequency generator as a clock source is made by setting the RCC_CSR register value 01 in the RTCSEL [1: 0] group: <br><pre> <code class="hljs php">RCC-&gt;CSR |= RCC_CSR_RTCSEL_LSE;  RCC-&gt;CSR |= <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* 0x10000 = 01 0000 0000 0000 0000 */</span></span></code> </pre> <br>  In the LCD controller, you must set the desired bias mode.  To do this, in the LCD control register LCD_CR it is necessary to set the value 10 to the BIAS group [1: 0].  Before setting the bits you need to clear the bits from the "garbage". <br><img src="https://habrastorage.org/getpro/habr/post_images/8e5/4a4/c32/8e54a4c32d8a76106ce50cddcc3a3322.jpg"><br>  <i>Register LCD_CR (LCD control register)</i> <br><br>  Reset bits: <br><pre> <code class="hljs erlang-repl"> LCD-&gt;CR &amp;= ~LCD_CR_BIAS;  LCD-&gt;CR &amp;= ~<span class="hljs-number"><span class="hljs-number">0</span></span>x60;</code> </pre> <br>  Selection of bias = 1/3 mode using bitmasks: <br><pre> <code class="hljs erlang-repl">LCD-&gt;CR |= LCD_CR_BIAS_1;  LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0</span></span>x40;</code> </pre> <br>  Set the duty mode = 1/4.  To do this, we also first reset all bits: <br><pre> <code class="hljs erlang-repl">LCD-&gt;CR &amp;=~LCD_CR_DUTY;  LCD-&gt;CR &amp;= ~<span class="hljs-number"><span class="hljs-number">0</span></span>x1C;</code> </pre> <br>  Set the value of 011 to the DUTY [1: 0] group of the LCD_CR register for <br>  duty mode = 1/4: <br><pre> <code class="hljs erlang-repl">LCD-&gt;CR |= LCD_CR_DUTY_0|LCD_CR_DUTY_1;  LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0</span></span>x;</code> </pre> <br>  Activate the function of reassigning the findings.  To do this, set 1 to 7 bits of the register LCD_CR: <br><pre> <code class="hljs xml">LCD-&gt;CR |= LCD_CR_MUX_SEG;  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">source</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">¬´C¬ª</span></span></span><span class="hljs-tag">&gt;</span></span>LCD-&gt;CR |= 0x80;</code> </pre> <br>  Set the values ‚Äã‚Äãof the clock frequency division factors LCDCLK.  The values ‚Äã‚Äãof the coefficients are set in the register LCD_FCR (LCD frame control register).  First, we also clear all bits, then set the necessary ones. <br><img src="http://habrastorage.org/storage2/755/a80/f04/755a80f04fdd67f25fd4075a0cae951c.jpg"><br>  <i>Register LCD_FCR (LCD frame control register)</i> <br><br><pre> <code class="hljs erlang-repl">LCD-&gt;FCR &amp;= ~LCD_FCR_PS; LCD-&gt;FCR &amp;= ~LCD_FCR_DIV;  LCD-&gt;FCR &amp;= ~<span class="hljs-number"><span class="hljs-number">0</span></span>x3C00000; LCD-&gt;FCR &amp;= ~<span class="hljs-number"><span class="hljs-number">0</span></span>x3C0000;</code> </pre> <br>  The values ‚Äã‚Äãof the clock frequency division factors are set to ck_ps = LCDCLK / 16, ck_div = ck_ps / 17.  To do this, set 1 in 24 and 18 bits: <br><pre> <code class="hljs php"> LCD-&gt;FCR |= <span class="hljs-number"><span class="hljs-number">0x1040000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*0x1040000 = 1 0000 0100 0000 0000 0000 0000*/</span></span></code> </pre> <br>  To set the desired level of contrast, it is necessary to set the value of 010 to the CC group [1: 0], also pre-clearing the bits from the old values: <br><pre> <code class="hljs php">LCD-&gt;FCR &amp;= ~LCD_FCR_CC; LCD-&gt;FCR |= LCD_FCR_CC_1;  LCD-&gt;FCR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x1C00</span></span>; LCD-&gt;FCR |= <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*0x800 = 1000 0000 0000*/</span></span></code> </pre> <br>  After setting all the values, it takes some time to synchronize the register LCD_FCR.  Register synchronization is checked by the hardware setting of the FCRSF bit in the LCD status register LCD_SR. <br><img src="http://habrastorage.org/storage2/047/393/84b/04739384b345ca12c0f99ce1962baeb2.jpg"><br>  <i>Register LCD_SR (LCD status register)</i> <br><br><pre> <code class="hljs lisp">while(!(<span class="hljs-name"><span class="hljs-name">LCD-&gt;SR&amp;LCD_SR_FCRSR</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  As the voltage source for the LCD, select the internal step-up converter to form the V <sub>lcd</sub> .  To do this, in the first digit of the register LCD_CR (LCD control register) is set to 0: <br><pre> <code class="hljs erlang-repl">LCD-&gt;CR &amp;= ~LCD_CR_VSEL;  LCD-&gt;CR &amp;= ~<span class="hljs-number"><span class="hljs-number">0</span></span>x2;</code> </pre> <br>  The resolution of the LCD controller operation is performed by setting the LCD control register to 1 in 0 digit: <br><pre> <code class="hljs erlang-repl">LCD-&gt;CR |= LCD_CR_LCDEN;  LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0</span></span>x1;</code> </pre> <br>  After installing the internal step-up converter as a voltage source, you must wait until it is ready.  Readiness is checked by hardware setting of the RDY bit in the LCD status register LCD_SR: <br><pre> <code class="hljs lisp">while(!(<span class="hljs-name"><span class="hljs-name">LCD-&gt;SR&amp;LCD_SR_RDY</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  After the resolution of the LCD controller is enabled, you must wait until it is ready.  Readiness is checked by the hardware setting of the ENS bit in the LCD status register LCD_SR: <br><pre> <code class="hljs lisp">while(!(<span class="hljs-name"><span class="hljs-name">LCD-&gt;SR&amp;LCD_SR_ENS</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><h4>  Image formation on the LCD </h4><br>  All indicator segments are grouped into COM0 - COM3 groups of 24 segments each (SEG0-SEG23).  Information about the segments is stored in the LCD_RAM ‚Äã‚Äãregisters of the LCD controller memory.  The layout of the printed circuit board is such that the segment numbers do not correspond to the digits of the LCD_RAM ‚Äã‚Äãregisters. <br><img src="http://habrastorage.org/storage2/1a1/e7d/b99/1a1e7db99159f68bb54478268998017e.png"><br>  In order to display 1 in the first digit of the LCD, it is necessary to light segments 1B, 1C.  Segment 1B belongs to the group COM0, segment 1C belongs to the group COM1.  Therefore, information about them should be recorded in the RAM [0] (LCD_RAM0), RAM [2] (LCD_RAM2) registers, respectively.  For segment 1B, the LCD output LCDSEG22 is responsible, information about which is stored in the SEG40 bit of the RAM [1] register (LCD_RAM1).  Using the reassign function, the SEG28 bit in the RAM [0] register (LCD_RAM0) will be responsible for the LCDSEG22 segment.  LCD segment LCDSEG1 is responsible for segment 1C, information about which is stored in the SEG1 bit of the RAM register [2] (LCD_RAM2). <br><img src="http://habrastorage.org/storage2/02a/6a0/c6d/02a6a0c6d24590ac18e55b8a14a05105.png"><br><pre> <code class="hljs php">LCD-&gt;RAM[<span class="hljs-number"><span class="hljs-number">0</span></span>]= <span class="hljs-number"><span class="hljs-number">0x10000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*0x10000000 = 1 0000 0000 0000 0000 0000 0000 0000 */</span></span> LCD-&gt;RAM[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0x2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*0x2= 10 */</span></span></code> </pre> <br>  Before writing values ‚Äã‚Äãto memory registers, it is necessary to check whether the previous data transfer to the LCD is completed.  To do this, check the UDR (Update display request) bit of the LCD_SR register (LCD status register).  The LCD controller has two output buffers, the information is entered into the first buffer, and is displayed on the LCD from the second buffer.  The UDR bit is set during transfer from the first buffer to the second, protecting the LCD_RAM ‚Äã‚Äãregisters from writing: <br><pre> <code class="hljs lisp">while(<span class="hljs-name"><span class="hljs-name">LCD-&gt;SR</span></span> &amp; LCD_SR_UDR)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  After writing information to the LCD_RAM ‚Äã‚Äãregisters, you need to set the UDR bit in the LCD status (LCD_SR) register (set 1 to 2 bits): <br><pre> <code class="hljs php"> LCD-&gt;SR |= LCD_SR_UDR;  LCD-&gt;SR |= <span class="hljs-number"><span class="hljs-number">0x4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*0x4 = 100 */</span></span></code> </pre> <br><img src="http://habrastorage.org/storage2/dd2/e26/40a/dd2e2640ad8bd3f62cfe34139139fae9.png"><br><div class="spoiler">  <b class="spoiler_title">Ready project code</b> <div class="spoiler_text"><pre> <code class="hljs rust">#include <span class="hljs-string"><span class="hljs-string">"stm32l1xx.h"</span></span> void gpio(void); void controller(void); int main() { gpio(); controller(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(LCD-&gt;SR &amp; LCD_SR_UDR); LCD-&gt;RAM[<span class="hljs-number"><span class="hljs-number">0</span></span>]= <span class="hljs-number"><span class="hljs-number">0x3E300FFF</span></span>; LCD-&gt;RAM[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0x2EB00382</span></span>; LCD-&gt;RAM[<span class="hljs-number"><span class="hljs-number">6</span></span>] = <span class="hljs-number"><span class="hljs-number">0x400</span></span>; LCD-&gt;SR |= LCD_SR_UDR; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } void gpio(void) { RCC-&gt;AHBENR |= <span class="hljs-number"><span class="hljs-number">0x7</span></span>; GPIOA-&gt;MODER |= <span class="hljs-number"><span class="hljs-number">0x802A00A8</span></span>; GPIOB-&gt;MODER |= <span class="hljs-number"><span class="hljs-number">0xAAAA0A80</span></span>; GPIOC-&gt;MODER |= <span class="hljs-number"><span class="hljs-number">0xAAA0AA</span></span>; GPIOA-&gt;OTYPER &amp;= ~<span class="hljs-number"><span class="hljs-number">0x870E</span></span>; GPIOB-&gt;OTYPER &amp;= ~<span class="hljs-number"><span class="hljs-number">0xFF38</span></span>; GPIOC-&gt;OTYPER &amp;= ~<span class="hljs-number"><span class="hljs-number">0xFCF</span></span>; GPIOA-&gt;PUPDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xC03F00FC</span></span>; GPIOB-&gt;PUPDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xFFFF0FC0</span></span>; GPIOC-&gt;PUPDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xFFF0FF</span></span>; GPIOA-&gt;OSPEEDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xC03F00FC</span></span>; GPIOB-&gt;OSPEEDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xFFFF0FC0</span></span>; GPIOC-&gt;OSPEEDR &amp;= ~<span class="hljs-number"><span class="hljs-number">0xFFFFF0FF</span></span>; GPIOA-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= <span class="hljs-number"><span class="hljs-number">0xBBB0</span></span>; GPIOA-&gt;AFR[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0xB0000BBB</span></span>; GPIOB-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= <span class="hljs-number"><span class="hljs-number">0xBBB000</span></span>; GPIOB-&gt;AFR[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0xBBBBBBBB</span></span>; GPIOC-&gt;AFR[<span class="hljs-number"><span class="hljs-number">0</span></span>] |= <span class="hljs-number"><span class="hljs-number">0xBB00BBBB</span></span>; GPIOC-&gt;AFR[<span class="hljs-number"><span class="hljs-number">1</span></span>] |= <span class="hljs-number"><span class="hljs-number">0xBBBB</span></span>; } void controller(void) { RCC-&gt;APB1ENR |= <span class="hljs-number"><span class="hljs-number">0x10000200</span></span>; PWR-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0x100</span></span>; RCC-&gt;CSR |= <span class="hljs-number"><span class="hljs-number">0x800000</span></span>; RCC-&gt;CSR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x800000</span></span>; RCC-&gt;CSR |= <span class="hljs-number"><span class="hljs-number">0x100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!(RCC-&gt;CSR&amp;RCC_CSR_LSERDY)); RCC-&gt;CSR |= <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; LCD-&gt;CR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x60</span></span>; LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0x40</span></span>; LCD-&gt;CR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x1C</span></span>; LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0xC</span></span>; LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0x80</span></span>; LCD-&gt;FCR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x3C00000</span></span>; LCD-&gt;FCR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x3C0000</span></span>; LCD-&gt;FCR |= <span class="hljs-number"><span class="hljs-number">0x1040000</span></span>; LCD-&gt;FCR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x1C00</span></span>; LCD-&gt;FCR |= <span class="hljs-number"><span class="hljs-number">0x800</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!(LCD-&gt;SR&amp;LCD_SR_FCRSR)); LCD-&gt;CR &amp;= ~<span class="hljs-number"><span class="hljs-number">0x2</span></span>; LCD-&gt;CR |= <span class="hljs-number"><span class="hljs-number">0x1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!(LCD-&gt;SR&amp;LCD_SR_RDY)); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!(LCD-&gt;SR&amp;LCD_SR_ENS)); }</code> </pre> <br></div></div><br><br>  <b>UPD:</b> User <a href="http://geektimes.ru/users/gariks/" class="user_link">Gariks has</a> <a href="">written a useful program for generating values ‚Äã‚Äãfor RAM registers.</a> <br><br>  References: <br><ol><li>  <a href="http://chipspace.ru/stm32l-discovery-lcd/">http://chipspace.ru/</a> STM32L-DISCOVERY.  We connect LCD </li><li>  <a href="http://easyelectronics.ru/category/arm-uchebnyj-kurs">http://easyelectronics.ru</a> ARM.  Training course </li><li>  <a href="http://radiokot.ru/start/mcu_fpga/avr/15/">http://radiokot.ru/</a> Dynamic Indication </li><li>  <a href="http://www.st.com/web/en/catalog/tools/PF250990">Discovery Kit for the STM32 L1 series - with STM32L152 MCU</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/173709/">https://habr.com/ru/post/173709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173699/index.html">High Availability FTP Server with AWS S3 Data Storage</a></li>
<li><a href="../173701/index.html">Checking PHP engine for durability</a></li>
<li><a href="../173703/index.html">Ultra-hard sapphire glass for smartphones</a></li>
<li><a href="../173705/index.html">Writing your bootloader</a></li>
<li><a href="../173707/index.html">Internet project managers</a></li>
<li><a href="../173711/index.html">6 practical tips for beginners in building a simple BI solution</a></li>
<li><a href="../173713/index.html">Balancing incoming connections on iptables</a></li>
<li><a href="../173715/index.html">Unity Technologies is now on Habr√©. Post about the present and the future</a></li>
<li><a href="../173717/index.html">Launched the first two domains of the dot.UkR level</a></li>
<li><a href="../173719/index.html">Announcement of the second wave of speakers and 25 reports of the DevCon 2013 conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>