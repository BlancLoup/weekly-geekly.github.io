<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Two-factor authentication in Meteor.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For some time I happened to work in a startup. We used Meteor.js as a back end (and front end). At some point, we are faced with the need to implement...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Two-factor authentication in Meteor.js</h1><div class="post__text post__text-html js-mediator-article">  For some time I happened to work in a startup.  We used Meteor.js as a back end (and front end).  At some point, we are faced with the need to implement two-factor authentication.  In this article I would like to tell you how to implement this feature in Meteor.js. <br><br>  Under the cut you will not find any screenshots / pictures, but you will see all the code necessary for implementation. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  In our case, the second factor was the code in the SMS message sent via Twilio.  Many of you will exclaim that the second factor in the form of SMS messages is wasteful and stupid.  This implementation of TFA can use any second factor.  In my opinion, it would be ideal to formulate them (second factors) as a strategy and connect as necessary, but I never got to that.  I‚Äôll focus on the implementation of functionality on the Meteor.js platform. <br><br>  I implemented a classic approach in which, with the successful input of the first factor, a time-limited session opens, which can be completed by entering the second factor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Meteor Accounts does not have a way to pause authentication, and we need this pause in order to generate the code, send it and give the user time to enter.  Therefore, we will have to abandon the standard <strong>Meteor.loginWithPassword</strong> method and use the <strong>Meteor.loginWithToken</strong> method, which is not in the documentation.  This method allows the user to authenticate to the system using the token already generated and stored in MongoDB. <br><br><h2>  Course of action </h2><br>  Steps: <br><br><ol><li>  We replace the entire authentication process with our Meteor method, which we call <strong>LoginProcedure</strong> ; </li><li>  Validation of the first factor and all sorts of checks; </li><li>  We generate the second factor - the code, and send it using Twilio - this step can be replaced with any method of generating the second factor and its delivery; </li><li>  We save the code and other data into a separate collection of MongoDB, which will store open authentication sessions; </li><li>  Let us return the intermediate result for which the client will require the user to enter the second factor; </li><li>  Receiving and checking the second factor; </li><li>  Generate a new token, return it to the client; </li><li>  The client automatically executes the <strong>loginWithToken</strong> with the received token; </li></ol><br><br><h2>  Steps 1-2 </h2><br>  Using your Meteor method for authentication is simple, but how to prevent users from using the standard <strong>loginWithPassword</strong> ? <br>  There is an <strong>Accounts.validateLoginAttempt</strong> method that must "approve" each authentication operation.  The argument gets the object <strong>attempt</strong> , in which we are interested in the <strong>methodName</strong> and <strong>type</strong> attributes.  For the <strong>loginWithToken</strong> method <strong>,</strong> these attributes will have the values <strong>login</strong> and <strong>resume,</strong> respectively.  And if we want to allow authentication after confirming the account by e-mail and after recovering the password, then we also need to ‚Äúapprove‚Äù the additional <strong>methodName</strong> values.  The result is the following method: <br><br><pre><code class="javascript hljs">Accounts.validateLoginAttempt(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">attempt</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> allowed = [ <span class="hljs-string"><span class="hljs-string">'login'</span></span>, <span class="hljs-string"><span class="hljs-string">'verifyEmail'</span></span>, <span class="hljs-string"><span class="hljs-string">'resetPassword'</span></span> ]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.contains(allowed, attempt.methodName) &amp;&amp; attempt.type == <span class="hljs-string"><span class="hljs-string">'resume'</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; });</code> </pre> <br>  Immediately write the function to generate a new token.  These functions will also use a couple of methods that are not included in the documentation.  And here is the code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generateLoginToken = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stampedToken = Accounts._generateStampedLoginToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ stampedToken, Accounts._hashStampedToken(stampedToken) ]; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> saveLoginToken = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userId</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Meteor.wrapAsync(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">userId, tokens, cb</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// In tokens array first is stamped, second is hashed // Save hashed to Mongo Meteor.users.update(userId, { $push: { 'services.resume.loginTokens': tokens[1] } }, function(error){ if (error){ cb(new Meteor.Error(500, 'Couldnt save login token into user profile')); }else{ // Return stamped to user cb &amp;&amp; cb(null, [200,tokens[0].token]); } }); })(userId, generateLoginToken()); };</span></span></code> </pre><br>  The <strong>Accounts._generateStampedLoginToken</strong> method returns a new token that must be returned to the client in order to later execute the <strong>loginWithToken</strong> method.  The <strong>Accounts._hashStampedToken</strong> method hashes the token, and it is in the hashed form that we must save it to MongoDB. <br><br>  It's time to go back to our Meteor method.  And here is the code, an explanation after: <br><br><pre> <code class="javascript hljs">Meteor.methods({ <span class="hljs-string"><span class="hljs-string">'LoginProcedure'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username, pswdDigest, code, hash</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Here perform some checks //I'll leave it up to you //Something to prevent NoSQL-Injections etc. ... //Now check if user already exists var user = Meteor.users.findOne({ '$or': [ { 'username': username }, { 'emails.address': username } ] }); if (!user) throw new Meteor.Error(404, 'fail'); //Now password checks //Explanations about this are right after the code var password = {digest: pswdDigest, algorithm: 'sha-256'}; var pswdCheck = Accounts._checkPassword(user, password); if (pswdCheck.error) throw new Meteor.Error(403,'fail'); //Next check if two-factor is enabled //If it's not, just generate token and return it //Else start the procedure... if (!user.twoFactorEnabled){ //Use function defined above return saveLoginToken(user._id); }else{ //Step 3-7 ... } } });</span></span></code> </pre><br>  As you can see, one more method not described in the documentation. <br><br>  Since we carry out all authentication manually, we also need to check the password manually.  And the problem lies in the fact that we do not know how Meteor hashes them.  For this purpose, the <strong>Accouts._checkPassword</strong> method is <strong>used</strong> .  As arguments, the user‚Äôs record received earlier from MongoDB and another object containing the user‚Äôs password hash and hashing method are passed to it.  It is always sha-256. <br>  The hashing itself will be performed on the client side before calling the Meteor method.  The standard method used is <strong>Package.sha.SHA256 ('PPAarRol')</strong> . <br><br>  It also describes the course of actions when TFA is disabled ‚Äî we simply generate a new token, return it to the client, and from there, the <strong>Meteor.loginWithToken</strong> call will be <strong>executed</strong> . <br><br>  I want to clarify the number of arguments to the Meteor method - I use the same method to open and end the authentication session. <br><br>  The <strong>hash</strong> argument is intended to track an already open session.  Suppose the user opens the authentication session and then closes the browser / tab, but the SMS with the code has already been sent.  And within a minute (the session lifetime), he will again open the authentication session, and then SMS will be sent again.  It would be a total loss of money.  Therefore, for an open session (after passing the first factor), a hash is created, which is tied to it and saved with it in MongoDB, and then returned to the client, and there it is stored in localstorage / cookie.  And, when the client boots up once again, it will check by its temporary calculations whether the last authentication session is alive.  If alive, he will attach this hash along with the first factor (username, password).  It will also allow you to open TFA sessions from different devices.  About this process in more detail in the following steps. <br><br><h2>  Steps 3-5 </h2><br>  These steps include the second factor itself. <br>  Let's create a special collection in MongoDB that will contain open authentication sessions.  Suppose it will be called <strong>TwoFactorSessions</strong> .  It should be defined only on the server side of Meteor. <br><br>  And here is the code: <br><br><pre> <code class="javascript hljs">Meteor.methods({ <span class="hljs-string"><span class="hljs-string">'LoginProcedure'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username, pswdDigest, code, hash</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Steps 1-2 ... if (!user.twoFactorEnabled){ //Steps 1-2 ... }else{ if (code &amp;&amp; hash){ //Step 6-7 ... }else(hash){ //That part is for continuing previous session //New code will not be sent, but client-side app //will receive special response code and open the pop-up var session = TwoFactorSessions.findOne({ hash: hash, username: username }); if (session){ //Lets use some imaginary validation function //that you will define by your own in your project validateSession(session, user); return [401, hash]; }else{ // Couldnt find, return error throw new Meteor.Error(404, 'No session'); } }else{ //Generated code, i'll leave it up to you var newCode = &lt;code here&gt;; //The now date can be used as hash, just timestamp var now = new Date(); var hash = +now; //Save it to special collection for suspended sign-in processes TwoFactorSessions.insert({ hash: hash, code: newCode, username: username, sent: now }); // Wrap async task return Meteor.wrapAsync(function(user, hash, code, startTime, cb){ // Send code using Twilio to the phone number of user Twilio.messages.create({ to: user.phone, from: '+000000000000', body: 'Hi! Code - '+code }, function(error, message){ if (error){ // Return error with Twilio cb &amp;&amp; cb(new Meteor.Error(500, 'Twilio error')); }else{ // Return 403, saying that SMS has been sent // hash, which user will send to us with code to identify his TF session cb &amp;&amp; cb(null, [403, hash]); } }); })(user, hash, newCode, now); } } } });</span></span></code> </pre><br>  In case a client receives a method call with the hash argument, we should try to find an already existing open authentication session.  Even if it exists, you still need to check its lifetime (the client is unpredictable, there will definitely be a character who will call a variety of methods with a variety of arguments through the console).  If everything is in order, let the client understand that you still need to pass the second factor. <br><br>  If the <strong>hash</strong> argument is not present, and the first factor is passed, then we generate a code (the second factor), a hash, save everything we need and deliver the code (the second factor).  As you can see, my hash is not a hash, but just a timestamp.  It seemed to me sufficient for demonstration purposes, but no one will forbid you to use a full-fledged hash, in which you can hide data to bind an open session to a device, for example. <br><br>  To work with Twilio, I used the official <a href="https://twilio.github.io/twilio-node/">twilio-node</a> module.  To connect modules from Node.js to Meteor you can use the convenient <a href="https://atmospherejs.com/meteorhacks/npm">meteorhacks</a> package <a href="https://atmospherejs.com/meteorhacks/npm">: npm</a> . <br><br>  Also pay attention to <strong>Meteor.wrapAsync</strong> .  If you are familiar with Meteor, you know that all asynchronous tasks on the server side need to be wrapped in this way. <br><br>  As a result, a hash is sent to the client to further identify the open session and the code by which it displays the form for entering the second factor. <br><br>  Everything is quite simple, but, I agree, messy. <br><br><h2>  Steps 6-7 </h2><br>  Now it's time to think about the client side. <br><br>  Suppose there is a template for authentication - <strong>signIn</strong> .  It has a form for the first factor and a modal pop-up for the second factor, which is identified by <strong>#modal</strong> , and all nested elements as <strong># modal- &lt;element name and role&gt;</strong> .  As you remember, the hash for identifying an open session should be stored in the localstorage / cookie, so in the following code we will use the <strong>Storage</strong> object.  It will be some abstract object that decides for itself where to put the value (localstorage or cookie, according to availability).  And here is the code: <br><br><pre> <code class="javascript hljs">Template.signIn.events({ ... <span class="hljs-string"><span class="hljs-string">'submit #signInForm'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ e.preventDefault(); <span class="hljs-comment"><span class="hljs-comment">//Here go your methods for retreiving //username/email and password var username = ...; var password = ...; var pswdDigest = Package.sha.SHA256(password); // Check if there is previous Two-Factor session var sessionHash = Storage.get('two-factor-auth-hash'); if (sessionHash){ //Validate it maybe? //We have additional value here, code expiration time var valid = validateItHereAsYouWant(); if (!valid) sessionHash = null; } //Now actual login procedure start Meteor.call('LoginProcedure', username, pswdDigest, null, sessionHash, function(error, response){ if (error){ if (error.error === 400){ // That code would mean that session is invalid Storage.remove('two-factor-auth-hash'); // Show some alerts here } }else if (response[0]===200){ // That response code would mean that // two-factor authentication is turned off // and client received new login token immediately // right after passing simple username/password check Meteor.loginWithToken(response[1], function(err){ if(err){ alert('Problem!'); }else{ Router.go('Account'); } }); }else if (response[0]===403){ // That response code would mean that second factor code is sent // Open modal window with code input field $('#modal').modal(); // Save hash into storage for continuation Storage.set('two-factor-auth-hash', response[1]); // Show alert saying the code was sent }else if (response[0]===401){ // Open modal window with code input field $('#modal').modal(); // Show alert that there is previous code that awaits input } } ... 'click #modal-code-submit': function(e){ e.preventDefault(); // Read the code, get the id hash var code = $('#modal-code-input').val(); var hash = Storage.get('two-factor-auth-hash'); // Again get the values inside fields // i mean username and password ... // Throught the net, only the digest should go var pswdDigest = Package.sha.SHA256(pswd); // Perform login again, but with code and id hash Meteor.call('LoginProcedure', username, pswdDigest, code, hash, function(error, response){ if (error){ if (error.error === 400){ // That error code would mean that session is invalid Storage.remove('two-factor-auth-hash'); Storage.remove('two-factor-auth-ttl'); $('#modal').modal('toggle'); // Show some error alerts } }else if (response[0]===200){ // Seems like ok, login token received Storage.remove('two-factor-auth-hash'); // Login Meteor.loginWithToken(response[1]); } }); } });</span></span></code> </pre><br>  The code is full of comments, carefully describing what is happening, but still explain. <br><br>  On the event <strong>#signInForm, we</strong> read the contents of the form, hash the password and call the Meteor method, also sending the <strong>hash</strong> , if it is found.  We expect to receive one of 4 answer options: <br><br><ol><li>  <strong>400</strong> - the session did not pass validation (ttl expired), the client must erase its hash; </li><li>  <strong>200</strong> - the first factor is passed, and the second is not included, then a token with which you can authenticate has arrived; </li><li>  <strong>403</strong> - a new code (the second factor) is generated and sent, we show a modal pop-up for input; </li><li>  <strong>401</strong> - the old code (the second factor) is still active, we show a pop-up, which displays the remaining lifetime of the session and the need to enter the same code. </li></ol><br>  From the modal window on the <strong>click # modal-code-submit</strong> event, we call the same Meteor method, but also pass the code (the second factor).  As a result, we expect to receive one of the following two answers: <br><ol><li>  <strong>400</strong> - the session has already expired, we show errors, we clean the <strong>hash</strong> in localstorage / cookie; </li><li>  <strong>200</strong> - the second factor has been successfully passed, we clean the <strong>hash</strong> in localstorage / cookie in order to avoid errors, and authenticate with the received token. </li></ol><br>  Now you need to implement a second factor check on the server side.  This event is characterized by the presence of all 4 arguments when calling the Meteor method.  And here is the code: <br><br><pre> <code class="javascript hljs">Meteor.methods({ <span class="hljs-string"><span class="hljs-string">'LoginProcedure'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">username, pswdDigest, code, hash</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//Steps 1-2 ... if (!user.twoFactorEnabled){ //Steps 1-2 ... }else{ if (code &amp;&amp; hash){ //All 4 arguments present here //First factor has already been passed since we're here //Process second factor var session = TwoFactorSessions.findOne({ hash: hash, username: username }); if (session){ //Lets use some imaginary validation function //that you will define by your own in your project validateSession(session, user, code); // Passed all checks // Update two-factor session with submitted date TwoFactorSessions.update({ hash: hash }, { $set: { submitted: new Date() } }); // Generate and save login token using // previously defined function (look for it in steps 1-2) return saveLoginToken(user._id); }else{ // Couldnt find, return error throw new Meteor.Error(404, 'twoFactor.invalidHash'); } }else(hash){ //Step 3-5 ... }else{ //Step 3-5 ... } } } });</span></span></code> </pre><br>  4 arguments when calling the Meteor method mean trying to end an open TFA session.  First check to see if there is such a session.  Simple request in MongoDB. <br><br>  Next, we validate the session.  At a minimum, you need to check: <br><br><ul><li>  Is this session already closed; </li><li>  Has ttl expired; </li><li>  Check the number of attempts to close the session; </li><li>  Does the code match (the second factor); </li><li>  Additional checks for session compliance with the user. </li></ul><br>  After validation is successful, the session should be considered closed.  Therefore, we will update the entry in MongoDB by adding the session closing time there. <br>  Then, we generate a new token for the user with previously defined functions and send it back to the client side. <br><br><h2>  Step 8 </h2><br>  The code for this step is contained in the last step.  On the client side, when we receive a token, we immediately call the <strong>Meteor.loginWithToken</strong> method and successfully authenticate <strong>ourselves</strong> . <br><br><h2>  Conclusion </h2><br>  For many, the API Meteor.js may seem closed, limited, without the ability to do something complex and intricate.  But, as has been demonstrated in this article, you can take a deeper look and implement functionality that does not seem to fit into standard packages. <br><br>  The most important thing, of course, is that I had to use hidden functions that are not described in the official documentation.  This will be alarming for many because these functions may change without warning.  But without them, it would be difficult to implement TFA in a less normal form.  At least at the time of this writing, I could not find a single implementation. </div><p>Source: <a href="https://habr.com/ru/post/252593/">https://habr.com/ru/post/252593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252583/index.html">$ 2,500 for a domain in the .SUCKS zone</a></li>
<li><a href="../252585/index.html">QIWI terminals. Dark side of the Moon</a></li>
<li><a href="../252587/index.html">Broadcast video with Raspberry Pi</a></li>
<li><a href="../252589/index.html">Big Data course: three months for basic knowledge, and why?</a></li>
<li><a href="../252591/index.html">Intel RealSense MeetUp. All about RealSense for Developers - Quickly and Businessly</a></li>
<li><a href="../252595/index.html">Reserving Windows client OS in Microsoft Azure</a></li>
<li><a href="../252597/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ38 (March 2 - 8, 2015)</a></li>
<li><a href="../252601/index.html">Features of working with files in applications on different mobile platforms</a></li>
<li><a href="../252603/index.html">Yandex - we will think for you</a></li>
<li><a href="../252605/index.html">Install and configure 3CX Webmeeting Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>