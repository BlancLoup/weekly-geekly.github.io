<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET events in detail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are a .NET programmer, then you must have announced and used events in your code. Despite this, not everyone knows how events work inside and w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET events in detail</h1><div class="post__text post__text-html js-mediator-article">  If you are a .NET programmer, then you must have announced and used events in your code.  Despite this, not everyone knows how events work inside and what features are associated with their application.  In this article I tried to describe the work of events in as much detail as possible, including some special cases that are rarely dealt with, but it is important and interesting to know about. <br><a name="habracut"></a><br><h4>  What is an event? </h4><br>  An event in C # is an entity that provides two possibilities: for a class, to report changes, and for its users to react to them. <br>  Example of declaring an event: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Changed;</code> </pre> <br>  Consider what the ad consists of.  First come the event modifiers, then the event keyword, after it the event type, which must be a delegate type, and the event identifier, that is, its name.  The event keyword informs the compiler that this is not a public field, but a special way a drop-down construct that hides from the programmer the details of the implementation of the event mechanism.  In order to understand how this mechanism works, it is necessary to study the principles of the work of delegates. <br><br><h4>  The core of the event is delegates. </h4><br>  We can say that the delegate in .NET is a kind of analogue of a function reference in C ++.  However, such a definition is inaccurate, since  Each delegate can refer not to one, but to an arbitrary number of methods that are stored in the delegate's call list (invocation list).  The delegate type describes the signature of the method to which it can refer; instances of this type have their own methods, properties, and operators.  When invoking the Invoke () method, a sequential call is made to each of the list methods.  The delegate can be called as a function; the compiler translates such a call into an Invoke () call. <br>  In C # for delegates, there are operators + and - that do not exist in the .NET environment and are syntactic sugar of the language, expanding into a call to the Delegate.Combine and Delegate.Remove methods, respectively.  These methods allow you to add and remove methods in the call list.  Of course, the form of assignment operators (+ = and - =) is also applicable to delegate operators, as well as to the + and - operators defined in the .NET environment for other types.  If, when subtracting from a delegate, its call list is empty, then null is assigned to it. <br>  Consider a simple example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs javascript">Action a = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> Console.Write(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//Action   public delegate void Action(); Action b = a; Action c = a + b; Action d = a - b; a(); // A b(); // A c(); // AA d(); //  NullReferenceException, .. d == null</span></span></code> </pre><br><h4>  Events - default implementation </h4><br>  Events in C # can be defined in two ways: <ol><li>  Implicit implementation of an event (field-like event). </li><li>  Explicit implementation of the event. </li></ol>  I‚Äôll clarify that the words ‚Äúexplicit‚Äù and ‚Äúimplicit‚Äù in this case are not terms defined in the specification, but simply describe the implementation method by meaning. <br><br>  Consider the most commonly used event implementation ‚Äî implicit.  Suppose there is the following source code in C # 4 (this is important; for earlier versions, a slightly different code is generated, as will be discussed later): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Changed; }</code> </pre><br>  These lines will be translated by the compiler into a code similar to the following: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { EventHandler hanged; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Changed { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changed; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changed, comparand + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(eventHandler != comparand); } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { EventHandler eventHandler = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changed; EventHandler comparand; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { comparand = eventHandler; eventHandler = Interlocked.CompareExchange&lt;EventHandler&gt;(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.changed, comparand - <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, comparand); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (eventHandler != comparand); } } }</code> </pre> <br>  The add block is called when the event is subscribed, the remove block is called when unsubscribing.  These blocks are compiled into separate methods with unique names.  Both of these methods take one parameter ‚Äî the delegate of the type that corresponds to the type of event and have no return value.  The parameter name is always ‚Äúvalue‚Äù; an attempt to declare a local variable with this name will result in a compilation error.  The scope indicated to the left of the event keyword defines the scope of these methods.  A delegate is also created with the name of the event, which is always private.  That is why we cannot trigger an event implemented implicitly from a class heir. <br><br>  Interlocked.CompareExchange compares the first argument with the third, and if they are equal, replaces the first argument with the second.  This action is thread safe.  The cycle is used for the case when, after assigning the variable delegate comparand to an event and before performing the comparison, another thread changes this delegate.  In this case, Interlocked.CompareExchange does not replace, the boundary condition of the cycle is not met and the next attempt is made. <br><br><h4>  Declaration with add and remove </h4><br>  When an event is explicitly implemented, the programmer declares a delegate field for the event and manually adds or removes subscribers via add / remove blocks, both of which must be present.  Such an announcement is often used to create your own event mechanism while maintaining the convenience of the C # language in working with them. <br>  For example, <a href="http://msdn.microsoft.com/en-us/library/8843a9ch.aspx">one of the typical implementations</a> consists in a separate storage of the delegates' event dictionary, in which there are only those delegates whose events have been subscribed to.  Access to the dictionary is carried out by keys, which are usually static fields of type object, used only to compare their links.  This is done in order to reduce the amount of memory occupied by the class instance (in case it contains a large number of non-static events).  This implementation is used in WinForms. <br><br><h4>  How do you subscribe to an event and call it? </h4><br>  All subscription and unsubscribe actions (denoted as + = and - = can be easily confused with delegate operators) are compiled into calls to the add and remove methods.  Calls within the class other than the above are compiled into a simple work with the delegate.  It should be noted that with the implicit (and with the right explicit) implementation of the event it is impossible to get access to the delegate from outside the class, you can only work with the event as with abstraction - by subscribing and unsubscribing.  Since there is no way to determine whether we have subscribed to any event (if not to use reflection), it seems logical that unsubscribing from it will never cause errors - you can safely unsubscribe, even if the event delegate is empty. <br><br><h4>  Event Modifiers </h4><br>  Event scope modifiers can be used (public, protected, private, internal), they can be overridden (virtual, override, sealed) or not implemented (abstract, extern).  An event can overlap an event with the same name from the base class (new) or be a member of the class (static).  If an event is declared with both the override modifier and the abstract modifier at the same time, then the heirs of the class will have to redefine it (as well as methods or properties with these two modifiers). <br><br><h4>  What types of events are there? </h4><br>  As already noted, the event type must always be a delegate type.  The standard event types are EventHandler and EventHandler &lt;TEventArgs&gt;, where TEventArgs is the heir to EventArgs.  The EventHandler type is used when event arguments are not provided, and the EventHandler &lt;TEventArgs&gt; type is used when event arguments are present, then a separate class is created for them - the heir from EventArgs.  You can also use any other types of delegates, but using the typed EventHandler &lt;TEventArgs&gt; looks more logical and beautiful. <br><br><h4>  What is the situation in C # 3? </h4><br>  The implementation of the field-like event, which is described above, corresponds to the C # 4 (.NET 4.0) language.  For earlier versions there are very significant differences. <br>  An implicit implementation uses lock (this) to provide thread safety instead of interlocked.CompareExchange with a loop.  For static events, lock (typeof (Class)) is used.  Here is a code similar to the compiler-opened implicit event definition in C # 3: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Class</span></span> { EventHandler changed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Changed { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { changed = changed + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { changed = changed - <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } } }</code> </pre><br>  In addition, work with an event inside the class is conducted as a delegate, i.e.  + = and - = call Delegate.Combine and Delegate.Remove directly, bypassing the add / remove methods.  This change may make it impossible to build a project in C # 4!  In C # 3, the result of the + = and - = was the delegate, since  the result of the variable assignment is always the assigned value.  In C # 4, the result is void, since  add / remove methods do not return values. <br><br>  In addition to changes in the work on different versions of the language there are a few more features. <br><br><h4>  Feature number 1 - the extension of the subscriber's lifetime </h4><br>  When you subscribe to an event, we add a reference to the method that will be called when the event is raised.  Thus, the memory occupied by the object subscribing to the event will not be released until it unsubscribes the event or until the object containing the event is destroyed.  This feature is one of the most common causes of memory leaks in applications. <br>  To correct this deficiency often used weak events, weak events.  This topic has already <a href="http://habrahabr.ru/post/89529/">been covered on Habr√©</a> . <br><br><h4>  Feature 2 is an explicit interface implementation. </h4><br>  An event that is part of an interface cannot be implemented as a field when the interface is explicitly implemented.  In such cases, you should either copy the standard implementation of the event for implementation as a property, or implement this part of the interface implicitly.  Also, if you do not need the thread safety of this event, you can use the simplest and most effective definition: <br><br><pre> <code class="cs hljs">EventHandler changed; <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler ISomeInterface.Changed { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { changed += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { changed -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } }</code> </pre><br><h4>  Feature # 3 - Secure Call </h4><br>  Events before calling should be checked for null, as follows from the work of delegates described above.  From this grows the code, to avoid what there are at least two ways.  The first method is described by Jon Skeet in his <a href="http://csharpindepth.com/">C # in depth</a> book: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler Changed = <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { };</code> </pre><br>  Short and concise.  We initialize the event delegate with an empty method, so it will never be null.  This method cannot be subtracted from the delegate, because  it is defined during the initialization of the delegate and it has neither a name nor a link to it from anywhere in the program. <br><br>  The second way is to write a method that contains the necessary null test.  This technique works especially well in .NET 3.5 and higher, where extension methods are available.  Since when calling the extension method, the object on which it is called is only a parameter of this method, this object can be an empty reference, which is used in this case. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EventHandlerExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SafeRaise</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> EventHandler handler, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) handler(sender, e); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SafeRaise&lt;TEventArgs&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> EventHandler&lt;TEventArgs&gt; handler, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, TEventArgs e) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TEventArgs : EventArgs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(handler != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) handler(sender, e); } }</code> </pre><br>  Thus, we can trigger events like Changed.SafeRaise (this, EventArgs.Empty), which saves us lines of code.  You can also define a third variant of the extension method for the case when we have EventArgs.Empty so as not to pass them explicitly.  Then the code will be reduced to Changed.SafeRaise (this), but I will not recommend this approach, since  for other members of your team, this may not be as obvious as passing an empty argument. <br><br><h4>  Subtlety # 4 - what's wrong with the standard implementation? </h4><br>  If you have a ReSharper, then you could watch the <a href="http://confluence.jetbrains.net/display/ReSharper/Delegate%2Bsubtraction%2Bhas%2Bunpredictable%2Bsemantics">following message</a> .  The resharper team correctly believes that not all your users are sufficiently knowledgeable in the work of events \ delegates in terms of unsubscribe \ subtraction, but nevertheless your events should work predictably not for your users, but from the point of view of events in .NET, but because .  there is such a feature, it should remain in your code. <br><br><h4>  Bonus: Microsoft's attempt to make contravariant events </h4><br>  In the first beta of C # 4, Microsoft tried to add contra-variant to the events.  This allowed you to subscribe to an EventHandler &lt;MyEventArgs&gt; event with methods that have an EventHandler &lt;EventArgs&gt; signature and everything worked until several methods with a different (but suitable) signature were added to the event delegate.  Such code was compiled, but fell with a runtime error.  Apparently, they could not get around this and in the release of C # 4 contravariant for EventHandler was disabled. <br>  This is not so noticeable if you omit the explicit creation of the delegate upon subscription, for example, the following code will compile perfectly: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tests</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;MyEventArgs&gt; Changed; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Changed += ChangedMyEventArgs; Changed += ChangedEventArgs; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangedMyEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, MyEventArgs e</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangedEventArgs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre><br>  This is because the compiler itself will substitute the new EventHandler &lt;MyEventArgs&gt; (...) to both subscriptions.  If at least in one of the places to use new EventHandler &lt;EventArgs&gt; (...), the compiler will report an error - it is not possible to convert the EventHandler &lt;System.EventArgs&gt; type into EventHandler &lt;Events.MyEventArgs&gt; (here Events is the namespace of my test project). <br><br><h4>  Sources </h4><br>  The following is a list of sources, part of the material from which was used in the preparation of the article.  I recommend reading the book by John Skit (Jon Skeet), in which not only delegates, but many other means of language are described in detail. <br><ul><li>  <a href="http://csharpindepth.com/">Jon Skeet.</a>  <a href="http://csharpindepth.com/">C # in Depth, Second Edition</a> </li><li>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/05/events-get-a-little-overhaul-in-c-4-part-i-locks.aspx">Chris Burrows.</a>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/05/events-get-a-little-overhaul-in-c-4-part-i-locks.aspx">Events get a little overhaul in C # 4, Part I: Locks</a> </li><li>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/08/events-get-a-little-overhaul-in-c-4-part-ii-semantic-changes-and.aspx">Chris Burrows.</a>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/08/events-get-a-little-overhaul-in-c-4-part-ii-semantic-changes-and.aspx">Events get a little overhaul in C # 4, Part II: Semantic Changes and + = / - =</a> </li><li>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/18/events-get-a-little-overhaul-in-c-4-part-iii-breaking-changes.aspx">Chris Burrows.</a>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/18/events-get-a-little-overhaul-in-c-4-part-iii-breaking-changes.aspx">Events get a little overhaul in C # 4, Part III: Breaking Changes</a> </li><li>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/30/events-get-a-little-overhaul-in-c-4-afterward-effective-events.aspx">Chris Burrows.</a>  <a href="http://blogs.msdn.com/b/cburrows/archive/2010/03/30/events-get-a-little-overhaul-in-c-4-afterward-effective-events.aspx">Events get a little overhaul in C # 4, Afterward: Effective Events</a> </li><li>  <a href="">Msdn</a>  <a href="">10.7 Events</a> - part of the C # language specification for .NET 1.1 </li><li>  <a href="http://msdn.microsoft.com/en-us/library/8843a9ch.aspx">Msdn</a>  <a href="http://msdn.microsoft.com/en-us/library/8843a9ch.aspx">How to: Handle Multiple Events Using Event Properties</a> </li><li>  <a href="http://confluence.jetbrains.net/display/ReSharper/Delegate%2Bsubtraction%2Bhas%2Bunpredictable%2Bsemantics">JetBrains ReSharper.</a>  <a href="http://confluence.jetbrains.net/display/ReSharper/Delegate%2Bsubtraction%2Bhas%2Bunpredictable%2Bsemantics">Delegate subtraction has unpredictable semantics</a> </li><li>  <a href="http://stackoverflow.com/questions/1120688/event-and-delegate-contravariance-in-net-4-0-and-c-sharp-4-0">StackOverflow Question.</a>  <a href="http://stackoverflow.com/questions/1120688/event-and-delegate-contravariance-in-net-4-0-and-c-sharp-4-0">Event and delegate contravariance in .NET 4.0 and C # 4.0</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/148562/">https://habr.com/ru/post/148562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148551/index.html">LG Optimus L5 Review</a></li>
<li><a href="../148555/index.html">Congratulations on the Day of the system administrator!</a></li>
<li><a href="../148556/index.html">Twitter is laid</a></li>
<li><a href="../148557/index.html">Ability</a></li>
<li><a href="../148560/index.html">Resharper 7 released</a></li>
<li><a href="../148564/index.html">Google Fiber launched in Kansas City - the cost and terms of the lightning internet</a></li>
<li><a href="../148565/index.html">Using JSON MVC Controller in Visual Studio on Empty Web Site Template and C # Language</a></li>
<li><a href="../148566/index.html">Simple RegionManager</a></li>
<li><a href="../148567/index.html">Paymentwall Kiev Office</a></li>
<li><a href="../148569/index.html">"The bullet hit the wires ..."</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>