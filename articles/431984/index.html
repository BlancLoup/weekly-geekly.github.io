<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generator client to database on Golang interface based</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Generator client to database on Golang based interface. 





 To work with databases, Golang offers the database/sql package, which is an abstraction...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generator client to database on Golang interface based</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://github.com/go-gad/sal">Generator client</a> to database on Golang based interface. </p><br><p><img src="https://habrastorage.org/webt/jn/y8/f1/jny8f1pghqry-6htgynybbcufbi.png"></p><br><p> To work with databases, Golang offers the <code>database/sql</code> package, which is an abstraction over the software interface of a relational database.  On the one hand, the package includes powerful functionality for managing a pool of connections, working with prepared statements, transactions, a database query interface.  On the other hand, you have to write a considerable amount of the same type of code in a web application to interact with the database.  The go-gad / sal library offers a solution in the form of generating the same type of code based on the described interface. </p><a name="habracut"></a><br><h2 id="motivation">  Motivation </h2><br><p>  Today there are a sufficient number of libraries that offer solutions in the form of ORMs, helpers for building queries, and generating helpers based on the database schema. </p><br><ul><li>  <a href="https://github.com/jmoiron/sqlx">https://github.com/jmoiron/sqlx</a> </li><li>  <a href="https://github.com/go-reform/reform">https://github.com/go-reform/reform</a> </li><li>  <a href="https://github.com/jinzhu/gorm">https://github.com/jinzhu/gorm</a> </li><li>  <a href="https://github.com/Masterminds/squirrel">https://github.com/Masterminds/squirrel</a> </li><li>  <a href="https://github.com/volatiletech/sqlboiler">https://github.com/volatiletech/sqlboiler</a> </li><li>  <a href="https://github.com/drone/sqlgen">https://github.com/drone/sqlgen</a> </li><li>  <a href="https://github.com/gocraft/dbr">https://github.com/gocraft/dbr</a> </li><li>  <a href="https://github.com/go-gorp/gorp">https://github.com/go-gorp/gorp</a> </li><li>  <a href="https://github.com/doug-martin/goqu">https://github.com/doug-martin/goqu</a> </li><li>  <a href="https://github.com/src-d/go-kallax">https://github.com/src-d/go-kallax</a> </li><li>  <a href="https://github.com/go-pg/pg">https://github.com/go-pg/pg</a> </li></ul><br><p>  When I switched to Golang several years ago, I already had experience working with databases in different languages.  Using ORM, for example, ActiveRecord, and without.  Having gone from love to hate, having no problems with writing a few extra lines of code, interaction with the database in Golang came to something like a repository pattern.  We describe the interface with the database, we implement using standard db.Query, row.Scan.  To use additional wrappers simply did not make sense, it was opaque, forced to be on the alert. </p><br><p>  The SQL language itself is already an abstraction between your program and the data in the repository.  It always seemed illogical to me to try to describe a data scheme, and then build complex queries.  The structure of the response in this case differs from the data scheme.  It turns out that the contract should not be described at the data schema level, but at the request and response level.  We use this approach in web development when we describe the data structures of requests and API responses.  When accessing the service via RESTful JSON or gRPC, we declare the contract at the request and response level using JSON Schema or Protobuf, and not the entity data schema within the services. </p><br><p>  That is, the interaction with the database has been reduced to a similar method: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { FindUser(id <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>) (*User, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Postgres <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DB *sql.DB } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pg *Postgres)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resp User err := pg.DB.QueryRow(<span class="hljs-string"><span class="hljs-string">"SELECT id, name FROM users WHERE id=$1"</span></span>, id).Scan(&amp;resp.ID, &amp;resp.Name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;resp, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HanlderFindUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s Store, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*User, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// logic of service object user, err := s.FindUser(id) //... }</span></span></code> </pre> <br><p>  This method makes your program predictable.  But let's be honest, this is not a poet's dream.  We want to reduce the number of template code to compose a query, fill data structures, use variable binding, and so on.  I tried to formulate a list of requirements that the desired set of utilities should satisfy. </p><br><h2 id="requirements">  Requirements </h2><br><ul><li>  Description of interaction in the form of an interface. </li><li>  The interface is described by methods and messages of requests and responses. </li><li>  Support for linking variables and prepared expressions (prepared statements). </li><li>  Named argument support. </li><li>  Associate a database response with message data structure fields. </li><li>  Support for atypical data structures (array, json). </li><li>  Transparent work with transactions. </li><li>  Built-in support for intermediate processors (middleware). </li></ul><br><p>  Implementation of interaction with the database, we want to abstract using the interface.  This will allow us to implement something similar to such a design pattern as a repository.  In the example above, we described the Store interface.  Now we can use it as an addiction.  At the testing stage, we can pass the stub object generated on the basis of this interface, and in production we will use our implementation based on the Postgres structure. </p><br><p>  Each interface method describes one database request.  Input and output parameters of the method should be part of the contract for the request.  The query string must be able to format depending on the input parameters.  This is especially true when compiling queries with a complex sample condition. </p><br><p>  When making a query, we want to use substitutions and variable bindings.  For example, in PostgreSQL, instead of a value, you write <code>$1</code> , and along with the query you pass an array of arguments.  The first argument will be used as the value in the converted query.  Support for prepared expressions will allow you not to worry about organizing the storage of these expressions.  The database / sql library provides a powerful tool for the support of prepared expressions, it takes care of the connection pool, closed connections.  But on the part of the user, it is necessary to take an additional action to reuse the prepared expression in the transaction. </p><br><p>  Databases, such as PostgreSQL and MySQL, use different syntax for using substitution and variable bindings.  PostgreSQL uses the format <code>$1</code> , <code>$2</code> , ... MySQL uses <code>?</code>  regardless of the location of the value.  The database / sql library offered a universal format of named arguments <a href="https://golang.org/pkg/database/sql/">https://golang.org/pkg/database/sql/#NamedArg</a> .  Usage example: </p><br><pre> <code class="go hljs">db.ExecContext(ctx, <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE created_at &lt; @end`</span></span>, sql.Named(<span class="hljs-string"><span class="hljs-string">"end"</span></span>, endTime))</code> </pre> <br><p>  Support for this format is preferable to use compared to PostgreSQL or MySQL solutions. </p><br><p>  The answer from the database that processes the software driver can be represented as follows: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title | url <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+-------+------------ 1 | 2012-03-13 11:17:23.609 | Tech | technology 2 | 2015-07-21 18:05:43.412 | Style | fashion (2 rows)</span></span></code> </pre> <br><p>  From the user's point of view, at the interface level, it is convenient to describe the output parameter as an array of structures of the form: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreatedAt time.Time Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> URL <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Next, project the <code>id</code> value to <code>resp.ID</code> and so on.  In general, this functionality covers most needs. </p><br><p>  When declaring messages through internal data structures, the question arises about how to support non-standard data types.  For example an array.  If you use the github.com/lib/pq driver when working with PostgreSQL, you can use auxiliary functions like <code>pq.Array(&amp;x)</code> when passing arguments to the query or scanning the response.  Example from documentation: </p><br><pre> <code class="go hljs">db.Query(<span class="hljs-string"><span class="hljs-string">`SELECT * FROM t WHERE id = ANY($1)`</span></span>, pq.Array([]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">235</span></span>, <span class="hljs-number"><span class="hljs-number">401</span></span>})) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x []sql.NullInt64 db.QueryRow(<span class="hljs-string"><span class="hljs-string">'SELECT ARRAY[235, 401]'</span></span>).Scan(pq.Array(&amp;x))</code> </pre> <br><p>  Accordingly, there should be ways to prepare data structures. </p><br><p>  When executing any of the interface methods, a connection to the database may be used as an object <code>*sql.DB</code>  If it is necessary to execute several methods within one transaction, I would like to use transparent functionality with a similar approach of working outside the transaction, not to pass additional arguments. </p><br><p>  When working with interface implementations, it is vital for us to be able to embed the toolkit.  For example, logging all requests.  The toolkit must access the request variables, response error, runtime, interface method name. </p><br><p>  For the most part, requirements were formulated as systematization of scenarios for working with a database. </p><br><h2 id="solution-go-gadsal">  Solution: go-gad / sal </h2><br><p>  One way to deal with template code is to generate it.  Fortunately, Golang has tools and examples for this <a href="https://blog.golang.org/generate">https://blog.golang.org/generate</a> .  The GoMock approach <a href="https://github.com/golang/mock">https://github.com/golang/mock</a> was taken as an architectural solution for generation, where the analysis of the interface is carried out using reflection.  Based on this approach, according to the requirements, the salgen utility and the sal library were written, which generate interface implementation code and provide a set of auxiliary functions. </p><br><p>  In order to start using this solution, it is necessary to describe the interface that describes the behavior of the interaction layer with the database.  Specify the <code>go:generate</code> directive with a set of arguments and start the generation.  A constructor and a bunch of sample code will be received, ready to use. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> repo <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./postgres_client.go -package=dev/taxi/repo dev/taxi/repo Postgres type Postgres interface { CreateDriver(ctx context.Context, r *CreateDriverReq) error } type CreateDriverReq struct { taxi.Driver } func (r *CreateDriverReq) Query() string { return `INSERT INTO drivers(id, name) VALUES(@id, @name)` }</span></span></code> </pre> <br><h4 id="interface">  Interface </h4><br><p>  It all starts with declaring the interface and a special command for the <code>go generate</code> utility: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:generate salgen -destination=./client.go -package=github.com/go-gad/sal/examples/profile/storage github.com/go-gad/sal/examples/profile/storage Store type Store interface { ...</span></span></code> </pre> <br><p>  Here it is described that for our interface <code>Store</code> from the package, the console utility <code>salgen</code> will be called, with two options and two arguments.  The first option <code>-destination</code> determines in which file the generated code will be written.  The second option <code>-package</code> defines the full path (import path) of the library for the generated implementation.  The following are two arguments.  The first one describes the complete package path ( <code>github.com/go-gad/sal/examples/profile/storage</code> ), where the interface is located, the second one indicates the interface name itself.  Note that the command for <code>go generate</code> can be located anywhere, not necessarily close to the target interface. </p><br><p>  After the <code>go generate</code> command is executed, we will get a constructor, whose name is constructed by adding the prefix <code>New</code> to the interface name.  The constructor takes a required parameter corresponding to the <code>sal.QueryHandler</code> interface: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryHandler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { QueryContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (*sql.Rows, error) ExecContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, args ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) (sql.Result, error) PrepareContext(ctx context.Context, query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (*sql.Stmt, error) }</code> </pre> <br><p>  This interface corresponds to the object <code>*sql.DB</code> </p><br><pre> <code class="go hljs">connStr := <span class="hljs-string"><span class="hljs-string">"user=pqgotest dbname=pqgotest sslmode=verify-full"</span></span> db, err := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connStr) client := storage.NewStore(db)</code> </pre> <br><h4 id="methods">  Methods </h4><br><p>  Interface methods define a set of available database queries. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { CreateAuthor(ctx context.Context, req CreateAuthorReq) (CreateAuthorResp, error) GetAuthors(ctx context.Context, req GetAuthorsReq) ([]*GetAuthorsResp, error) UpdateAuthor(ctx context.Context, req *UpdateAuthorReq) error }</code> </pre> <br><ul><li>  The number of arguments is always strictly two. </li><li>  The first argument is the context. </li><li>  The second argument contains the data to bind the variables and defines the query string. </li><li>  The first output parameter can be an object, an array of objects, or missing. </li><li>  The last output parameter is always an error. </li></ul><br><p>  The first argument always expects a <code>context.Context</code> object.  This context will be passed on to the database and toolkit calls.  The second argument expects a parameter with a base type of <code>struct</code> (or a pointer to a <code>struct</code> ).  The parameter must satisfy the following interface: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Queryer <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Query() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  The <code>Query()</code> method will be called before the database query.  The resulting string will be converted to a database specific format.  That is, for PostgreSQL, <code>@end</code> will be replaced with <code>$1</code> , and the value of <code>&amp;req.End</code> will be passed to the argument array </p><br><p>  Depending on the output parameters, it is determined which of the methods (Query / Exec) will be called: </p><br><ul><li>  If the first parameter is with a basic type of <code>struct</code> (or a pointer to a <code>struct</code> ), then the <code>QueryContext</code> method will be called.  If the response from the database does not contain any rows, then the error <code>sql.ErrNoRows</code> will be <code>sql.ErrNoRows</code> .  That is, the behavior is similar to <code>db.QueryRow</code> . </li><li>  If the first parameter is with the base type <code>slice</code> , then the <code>QueryContext</code> method will be called.  If the response from the database does not contain rows, then an empty list will be returned.  The base type of the list item must be <code>stuct</code> (or a pointer to a <code>struct</code> ). </li><li>  If the output parameter is one, with type <code>error</code> , the <code>ExecContext</code> method will be called. </li></ul><br><h4 id="prepared-statements">  Prepared statements </h4><br><p>  The generated code supports prepared expressions.  Prepared expressions are cached.  After the first preparation of the expression, it is placed in the cache.  The database / sql library itself ensures that prepared expressions are transparently applied to the desired connection to the database, including the processing of closed connections.  In turn, the <code>go-gad/sal</code> library takes care of reusing the prepared expression in the context of a transaction.  When the prepared expression is executed, the arguments are passed using variable binding, transparently to the developer. </p><br><p>  To support named arguments on the <code>go-gad/sal</code> side of the library, the query is converted to a form suitable for the database.  Now there is a conversion support for PostgreSQL.  The field names of the query object are used for substitutions in named arguments.  To specify a different name instead of the object field name, you must use the <code>sql</code> tag for the structure fields.  Consider an example: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteOrdersRequest <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { UserID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"user_id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r * DeleteOrdersRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM orders WHERE user_id=@user_id AND created_at&lt;@end`</span></span> }</code> </pre> <br><p>  The query string will be converted, and the list will be passed to the query execution arguments using the matching table and variable binding: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// generated code: db.Query("DELETE FROM orders WHERE user_id=$1 AND created_at&lt;$2", &amp;req.UserID, &amp;req.CreatedAt)</span></span></code> </pre> <br><h4 id="map-structs-to-requests-arguments-and-response-messages">  Map structs to request arguments and response messages </h4><br><p>  The <code>go-gad/sal</code> library takes care of linking database response lines with response structures, table columns with structure fields: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r GetRubricReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`SELECT * FROM rubrics`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> CreateAt time.Time <span class="hljs-string"><span class="hljs-string">`sql:"created_at"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetRubricsResp []*Rubric <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GetRubrics(ctx context.Context, req GetRubricsReq) (GetRubricsResp, error) }</code> </pre> <br><p>  And if the database response is: </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> rubrics; id | created_at | title <span class="hljs-comment"><span class="hljs-comment">----+-------------------------+------- 1 | 2012-03-13 11:17:23.609 | Tech 2 | 2015-07-21 18:05:43.412 | Style (2 rows)</span></span></code> </pre> <br><p>  Then the GetRubricsResp list will return to us, the elements of which will be pointers to Rubric, where the fields are filled with values ‚Äã‚Äãfrom the columns that correspond to the tag names. </p><br><p>  If the database response contains columns with the same name, the corresponding structure fields will be selected in the order of declaration. </p><br><pre> <code class="sql hljs">dev &gt; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rubrics, subrubrics; id | title | id | title <span class="hljs-comment"><span class="hljs-comment">----+-------+----+---------- 1 | Tech | 3 | Politics</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Rubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Subrubric <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { ID <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"id"`</span></span> Title <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"title"`</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GetCategoryResp <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Rubric Subrubric }</code> </pre> <br><h4 id="non-standard-data-types">  Non-standard data types </h4><br><p>  The <code>database/sql</code> package provides support for basic data types (strings, numbers).  In order to handle such data types as an array or json in a request or response, you must support the <code>driver.Valuer</code> and <code>sql.Scanner</code> .  In various implementations of drivers there are special auxiliary functions.  For example <code>lib/pq.Array</code> ( <a href="https://godoc.org/github.com/lib/pq">https://godoc.org/github.com/lib/pq#Array</a> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Array</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interface</span></span></span></span> { driver.Valuer sql.Scanner }</code> </pre> <br><p>  The default <code>go-gad/sql</code> library for view structure fields </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> DeleteAuthrosReq <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Tags []<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`sql:"tags"`</span></span> }</code> </pre> <br><p>  will use the value <code>&amp;req.Tags</code> .  If the structure satisfies the <code>sal.ProcessRower</code> interface, </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ProcessRower <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ProcessRow(rowMap RowMap) }</code> </pre> <br><p>  then the value used can be adjusted </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessRow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rowMap sal.RowMap)</span></span></span></span> { rowMap.Set(<span class="hljs-string"><span class="hljs-string">"tags"</span></span>, pq.Array(r.Tags)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *DeleteAuthorsReq)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Query</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">`DELETE FROM authors WHERE tags=ANY(@tags::UUID[])`</span></span> }</code> </pre> <br><p>  This handler can be used for request and response arguments.  In the case of a list in the response, the method must belong to the list item. </p><br><h4 id="transactions">  Transactions </h4><br><p>  To support transactions, the interface (Store) must be extended with the following methods: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { BeginTx(ctx context.Context, opts *sql.TxOptions) (Store, error) sal.Txer ...</code> </pre> <br><p>  The implementation of the methods will be generated.  The <code>BeginTx</code> method uses the connection from the current <code>sal.QueryHandler</code> object and opens the transaction <code>db.BeginTx(...)</code> ;  returns a new implementation object for the <code>Store</code> interface, but uses the resulting <code>*sql.Tx</code> object as a <code>*sql.Tx</code> </p><br><h4 id="middleware">  Middleware </h4><br><p>  Hooks are provided for embedding tools. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BeforeQueryFunc <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, FinalizerFunc)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalizerFunc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span></code> </pre> <br><p>  The <code>BeforeQueryFunc</code> hook will be called before <code>db.PrepareContext</code> or <code>db.Query</code> .  That is, at the start of the program, when the cache of prepared expressions is empty, when you call <code>store.GetAuthors</code> , the <code>BeforeQueryFunc</code> hook will be called twice.  The <code>BeforeQueryFunc</code> hook can return the <code>FinalizerFunc</code> hook, which will be called before leaving the custom method, in our case <code>store.GetAuthors</code> , using <code>defer</code> . </p><br><p>  When the hooks are executed, the context is filled with service keys with the following values: </p><br><ul><li>  <code>ctx.Value(sal.ContextKeyTxOpened)</code> boolean value determines whether the method is called in the context of a transaction or not. </li><li>  <code>ctx.Value(sal.ContextKeyOperationType)</code> , string value of the operation type, <code>"QueryRow"</code> , <code>"Query"</code> , <code>"Exec"</code> , <code>"Commit"</code> , etc. </li><li>  <code>ctx.Value(sal.ContextKeyMethodName)</code> string value of the interface method, for example, <code>"GetAuthors"</code> . </li></ul><br><p>  As arguments, the <code>BeforeQueryFunc</code> hook takes the sql string of the query and the argument <code>req</code> the user query method.  The <code>FinalizerFunc</code> hook accepts the <code>err</code> variable as an argument. </p><br><pre> <code class="go hljs">beforeHook := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, query </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, req </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context.Context, sal.FinalizerFunc)</span></span></span></span> { start := time.Now() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctx, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, err error)</span></span></span></span> { log.Printf( <span class="hljs-string"><span class="hljs-string">"%q &gt; Opeartion %q: %q with req %#v took [%v] inTx[%v] Error: %+v"</span></span>, ctx.Value(sal.ContextKeyMethodName), ctx.Value(sal.ContextKeyOperationType), query, req, time.Since(start), ctx.Value(sal.ContextKeyTxOpened), err, ) } } client := NewStore(db, sal.BeforeQuery(beforeHook))</code> </pre> <br><p>  Examples of output: </p><br><pre> <code class="plaintext hljs">"CreateAuthor" &gt; Opeartion "Prepare": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES($1, $2, now()) RETURNING ID, CreatedAt" with req &lt;nil&gt; took [50.819¬µs] inTx[false] Error: &lt;nil&gt; "CreateAuthor" &gt; Opeartion "QueryRow": "INSERT INTO authors (Name, Desc, CreatedAt) VALUES(@Name, @Desc, now()) RETURNING ID, CreatedAt" with req bookstore.CreateAuthorReq{BaseAuthor:bookstore.BaseAuthor{Name:"foo", Desc:"Bar"}} took [150.994¬µs] inTx[false] Error: &lt;nil&gt;</code> </pre> <br><h3 id="whats-next">  What's next </h3><br><ul><li>  Support for binding variables and prepared expressions for MySQL. </li><li>  Hook RowAppender to adjust the response. </li><li>  Return <code>Exec.Result</code> value. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/431984/">https://habr.com/ru/post/431984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431972/index.html">Leaked personal data of Quora users</a></li>
<li><a href="../431974/index.html">Tumblr rejects strawberry content completely</a></li>
<li><a href="../431976/index.html">Informatics Day in Russia: the history of the first project of an automatic computer</a></li>
<li><a href="../431978/index.html">Online Store Promotion: What Should Be Corrected</a></li>
<li><a href="../431982/index.html">Digjarati, hakerazzi and cholesterol in the data: about IT-jargon</a></li>
<li><a href="../431986/index.html">Fuck Up story: how I was disappointed in digital services for business and had done my job (well, almost)</a></li>
<li><a href="../431988/index.html">When the theorem became an axiom: a review of the ONYX BOOX Euclid</a></li>
<li><a href="../431990/index.html">Spaces have won. Translation of Kotlin Coding Conventions from JetBrains</a></li>
<li><a href="../431992/index.html">Biometrics: how is it with us, and with "them"</a></li>
<li><a href="../431994/index.html">Discussion of a free PVS-Studio license for projects hosted on GitHub</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>