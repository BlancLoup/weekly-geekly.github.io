<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ember - Best Practices: Avoid Leaking Condition into the Factory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In DockYard, we spend a lot of time on Ember, from building web applications, creating and maintaining add-ons, to contributing to the Ember ecosystem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ember - Best Practices: Avoid Leaking Condition into the Factory</h1><div class="post__text post__text-html js-mediator-article"><p> In DockYard, we spend a lot of time on Ember, from building web applications, creating and maintaining add-ons, to contributing to the Ember ecosystem.  We hope to share some of the experiences we have gained through a series of posts that will focus on Ember best practices, patterns, antipatterns and common mistakes.  This is the first post in this series, so let's start by <code>Ember.Object</code> back to the basics of <code>Ember.Object</code> . <a name="habracut"></a></p><br><p>  <code>Ember.Object</code> is one of the first things we learn as Ember developers, and no wonder.  Almost every object we work with in Ember, be it a route (Route), a component (Component), a model (Model), or a service (Service), is <a href="http://emberjs.jsbin.com/boqapo">inherited from Ember.Object</a> .  But from time to time, I see how it is misused: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Ember</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Component</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.extend</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">items</span></span>: [], actions: { <span class="hljs-built_in"><span class="hljs-built_in">addItem</span></span>(item) { this.<span class="hljs-built_in"><span class="hljs-built_in">get</span></span>(<span class="hljs-string"><span class="hljs-string">'items'</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">pushObject</span></span>(item); } } });</code> </pre> <br><p>  For those who have come across this before, the problem is obvious. </p><br><h2 id="emberobject">  Ember.Object </h2><br><p>  If you look at the <a href="http://emberjs.com/api/classes/Ember.Object.html">API</a> and deselect all <em>Inherited</em> , <em>Protected</em> , and <em>Private</em> options, you will see that <code>Ember.Object</code> does not have its own methods and properties.  <a href="">Source code</a> cannot be shorter.  This is a literal extension of Ember <code>CoreObject</code> , with an admixture of <code>Observable</code> : </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-type"><span class="hljs-type">EmberObject</span></span> = <span class="hljs-type"><span class="hljs-type">CoreObject</span></span>.extend(<span class="hljs-type"><span class="hljs-type">Observable</span></span>);</code> </pre> <br><p>  <code>CoreObject</code> provides a clean interface for defining factories or <em>classes</em> .  This is essentially an abstraction around how you usually create a constructor function, defining methods and properties on the prototype, and then creating new objects by calling <code>new SomeConstructor()</code> .  For the ability to call superclass methods using <code>this._super()</code> , or to combine a set of properties into a class through <a href="http://emberjs.com/api/classes/Ember.Mixin.html">impurities</a> , you should thank <code>CoreObject</code> .  All methods that you often have to use with Ember objects, such as <code>init</code> , <code>create</code> , <code>extend</code> , or <code>reopen</code> , are defined there as well. </p><br><p>  <code>Observable</code> is an admixture (Mixin), which allows you to monitor changes in the properties of an object, as well as at the time of <code>get</code> and <code>set</code> calls. </p><br><p>  When developing Ember applications, you never have to use <code>CoreObject</code> .  Instead, you inherit <code>Ember.Object</code> .  After all, in Ember, the most important <a href="https://medium.com/the-ember-way/ember-js-reactive-programming-computed-properties-and-observers-cf80c2fbcfc">reaction is to changes</a> , so you need methods with <code>Observable</code> to detect changes in property values. </p><br><h2 id="obyavlenie-novogo-klassa">  New Class Announcement </h2><br><p>  You can define a new type of observed object by extending the <code>Ember.Object</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Post = Ember.Object.extend({ title: <span class="hljs-string"><span class="hljs-string">'Untitled'</span></span>, author: <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span>, header: computed(<span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'author'</span></span>, function() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> title = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'title'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> author = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'author'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${title}</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ${author}`; }) });</code> </pre> <br><p>  New objects of type <code>Post</code> can now be created by calling <code>Post.create()</code> .  For each entry, properties and methods declared in the <code>Post</code> class will be inherited: </p><br><pre> <code class="hljs pgsql">const post = Post.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(); post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'title'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'Untitled'</span></span> post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'author'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'Untitled by Anonymous'</span></span> post instanceof Post; // =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><p>  You can change the property values ‚Äã‚Äãand give the post the name and the name of the author.  These values ‚Äã‚Äãwill be set on the instance, not on the class, so they will not affect the posts to be created. </p><br><pre> <code class="hljs pgsql">post.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'Heads? Or Tails?'</span></span>); post.<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(<span class="hljs-string"><span class="hljs-string">'author'</span></span>, <span class="hljs-string"><span class="hljs-string">'R &amp; R Lutece'</span></span>); post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'"Heads? Or Tails?" by R &amp; R Lutece'</span></span> const anotherPost = Post.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(); anotherPost.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'title'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'Untitled'</span></span> anotherPost.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'author'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'Anonymous'</span></span> anotherPost.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'header'</span></span>); // =&gt; <span class="hljs-string"><span class="hljs-string">'Untitled by Anonymous'</span></span></code> </pre> <br><p>  Since updating properties in this way does not affect other instances, it is easy to think that all operations performed in the example are safe.  But let's stop on this a bit more. </p><br><h2 id="utechka-sostoyaniya-vnutr-klassa">  State leaks inside a class </h2><br><p>  A post can have an additional list of tags, so we can create a property called <code>tags</code> and by default it is an empty array.  New tags can be added by calling the <code>addTag()</code> method. </p><br><pre> <code class="hljs pgsql">const Post = Ember.<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.extend({ tags: [], addTag(tag) { this.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>).pushObject(tag); } }); const post = Post.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(); post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>); // =&gt; [] post.addTag(<span class="hljs-string"><span class="hljs-string">'constants'</span></span>); post.addTag(<span class="hljs-string"><span class="hljs-string">'variables'</span></span>); post.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>); // =&gt; [<span class="hljs-string"><span class="hljs-string">'constants'</span></span>, <span class="hljs-string"><span class="hljs-string">'variables'</span></span>]</code> </pre> <br><p>  It looks like it works!  But check what happens after creating the second post: </p><br><pre> <code class="hljs pgsql">const anotherPost = Post.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(); anotherPost.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>); // =&gt; [<span class="hljs-string"><span class="hljs-string">'constants'</span></span>, <span class="hljs-string"><span class="hljs-string">'variables'</span></span>]</code> </pre> <br><p>  Even if the goal was to create a new post with empty tags (assumed by default), the post was created with tags from the previous post.  Because the new value for the <code>tags</code> property was not set, it just mutated the main array.  So we efficiently threw the state into the class <code>Post</code> , which is then used on all instances. </p><br><pre> <code class="hljs ruby">post.get(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'constants'</span></span>, <span class="hljs-string"><span class="hljs-string">'variables'</span></span>] anotherPost.get(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'constants'</span></span>, <span class="hljs-string"><span class="hljs-string">'variables'</span></span>] anotherPost.addTag(<span class="hljs-string"><span class="hljs-string">'infinity'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'constants'</span></span>, <span class="hljs-string"><span class="hljs-string">'variables'</span></span>, <span class="hljs-string"><span class="hljs-string">'infinity'</span></span>] post.get(<span class="hljs-string"><span class="hljs-string">'tags'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> =&gt; [<span class="hljs-string"><span class="hljs-string">'constants'</span></span>, <span class="hljs-string"><span class="hljs-string">'variables'</span></span>, <span class="hljs-string"><span class="hljs-string">'infinity'</span></span>]</code> </pre> <br><p>  This is not the only scenario in which you can confuse the state of an instance and the state of a class, but this, of course, is the one that occurs more often.  In the following example, you can set the default for <code>createdDate</code> for the current date and time by passing <code>new Date()</code> .  But <code>new Date()</code> evaluated once when a class is defined.  Therefore, regardless of when you create new instances of this class, they will all have the same value <code>createdDate</code> : </p><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Post = Ember.<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.extend({ createdDate: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date() }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> postA = Post.create(); postA.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'createdDate'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt; Fri Sep 18 2015 13:47:02 GMT-0400 (EDT) // Sometime in the future... const postB = Post.create(); postB.get('createdDate'); // =&gt; Fri Sep 18 2015 13:47:02 GMT-0400 (EDT)</span></span></code> </pre> <br><h2 id="kak-derzhat-situaciyu-pod-kontrolem">  How to keep the situation under control? </h2><br><p>  In order to avoid sharing tags between posts, the <code>tags</code> property will need to be set during object initialization: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Post = Ember.Object.extend({ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super(...arguments); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tags = []; } });</code> </pre> <br><p>  Since <code>init</code> is called whenever <code>Post.create()</code> called, each post instance will always get its own <code>tags</code> array.  In addition, you can make <code>tags</code> computed property (computed property): </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Post = Ember.Object.extend({ tags: computed({ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> []; }) });</code> </pre> <br><h2 id="vyvod">  Conclusion </h2><br><p>  Now it‚Äôs obvious why you shouldn‚Äôt write such components as in the example from the beginning of this post.  Even if a component appears only once on a page, when you exit a route, only the component instance is destroyed, not the factory.  So when you return, a new instance of the component will have traces of a previous visit to the page. </p><br><p>  This error may occur when using impurities.  Despite the fact that <code>Ember.Mixin</code> is not <code>Ember.Object</code> , the properties and methods declared in it, I <code>Ember.Object</code> to <code>Ember.Object</code> .  The result will be the same: you can end up sharing the state between all the objects that use the impurity. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318096/">https://habr.com/ru/post/318096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318078/index.html">The best free applications for customization and design of Windows 10</a></li>
<li><a href="../318080/index.html">How do I use Facebook groups to expand my own business</a></li>
<li><a href="../318084/index.html">Visualization of integration applications</a></li>
<li><a href="../318086/index.html">Build your open source AWS S3 server</a></li>
<li><a href="../318088/index.html">What does the operator monitor hide from the client?</a></li>
<li><a href="../318098/index.html">Yandex mobile experience in three video courses: design, development, interfaces</a></li>
<li><a href="../318100/index.html">Christmas Easter eggs</a></li>
<li><a href="../318102/index.html">Yii2-advanced: Making internationalization with a source in Redis</a></li>
<li><a href="../318104/index.html">Elixir in bioinformatics</a></li>
<li><a href="../318106/index.html">Intercepting Linux system calls using LSM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>