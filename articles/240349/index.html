<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive JavaScript: Functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive JavaScript: Functions</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>People believe that computer science is an art for geniuses.</i>  <i>In reality, the opposite is true - just a lot of people do things that stand on each other, as if making up a wall of small pebbles.</i> <i><br><br></i>  <i>Donald whip</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You have already seen calls to functions such as <code>alert</code> .  Functions are bread and butter programming on javascript.  The idea of ‚Äã‚Äãwrapping a piece of a program and calling it as a variable is very much in demand.  It is a tool for structuring large programs, reducing repetitions, assigning names to subprograms, and isolating subprograms from each other. <br><br>  The most obvious use of functions is to create a new dictionary.  Coming up with words for ordinary human prose is a bad form.  In a programming language, this is necessary. <br><br>  The average adult Russian-speaking person knows about 10,000 words.  A rare programming language contains 10,000 built-in commands.  And the vocabulary of a programming language is defined more clearly, so it is less flexible than a human one.  Therefore, we usually have to add our own words to it in order to avoid unnecessary repetitions. <br><a name="habracut"></a><br><h4>  Function definition </h4><br>  The definition of a function is the usual definition of a variable, where the value that the variable receives is a function.  For example, the following code defines the variable square, which refers to a function that counts the square of a given number: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> square = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x; }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(square(<span class="hljs-number"><span class="hljs-number">12</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 144</span></span></code> </pre><br><br>  A function is created by an expression starting with the <code>function</code> keyword.  Functions have a set of parameters (in this case, only x), and a body containing instructions that must be executed when calling a function.  The body of the function is always enclosed in braces, even if it consists of a single instruction. <br><br>  A function may have several parameters, or none at all.  In the following example, makeNoise does not have a list of parameters, and power has two of them: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> makeNoise = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); }; makeNoise(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ! var power = function(base, exponent) { var result = 1; for (var count = 0; count &lt; exponent; count++) result *= base; return result; }; console.log(power(2, 10)); // ‚Üí 1024</span></span></code> </pre><br><br>  Some functions return a value, like power and square, others do not return, like makeNoise, which produces only a side effect.  The <code>return</code> defines the value returned by the function.  When the program's processing reaches this instruction, it immediately exits the function, and returns this value to the place in the code from which the function was called.  return without an expression returns the value <code>undefined</code> . <br><br><h4>  Parameters and scope </h4><br>  The parameters of the function are the same variables, but their initial values ‚Äã‚Äãare specified when the function is called, and not in its code. <br><br>  An important property of functions is that the variables created inside the function (including parameters) are local to this function.  This means that in the example with power, the result variable will be created each time the function is called, and its separate incarnations are not related to each other. <br><br>  This locality of variables applies only to parameters and variables created inside functions.  Variables defined outside of any function are called global because they are visible throughout the program.  You can access these variables inside the function as well, unless you have declared a local variable with the same name. <br><br>  The following code illustrates this.  It defines and calls two functions that assign the value to the variable x.  The first declares it as local, thereby changing only the local variable.  The second one does not declare, so working with x inside the function refers to the global variable x, which was set at the beginning of the example. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"outside"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f1 = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-string"><span class="hljs-string">"inside f1"</span></span>; }; f1(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí outside var f2 = function() { x = "inside f2"; }; f2(); console.log(x); // ‚Üí inside f2</span></span></code> </pre><br><br>  This behavior helps prevent accidental interactions between functions.  If all variables were used anywhere in the program, it would be very difficult to make sure that one variable is not used for different purposes.  And if you reused a variable, you would face strange effects when third-party code corrupts the values ‚Äã‚Äãof your variable.  Referring to local variables for functions so that they exist only inside a function, the language makes it possible to work with functions as if with separate small universes, which allows not to worry about the whole code. <br><br><h4>  Nested scopes </h4><br>  JavaScript distinguishes between not only global and local variables.  Functions can be set inside functions, which leads to several levels of locality. <br><br>  For example, the following rather meaningless function contains two more inside: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> landscape = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flat = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; size; count++) result += <span class="hljs-string"><span class="hljs-string">"_"</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mountain = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">size</span></span></span><span class="hljs-function">) </span></span>{ result += <span class="hljs-string"><span class="hljs-string">"/"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; size; count++) result += <span class="hljs-string"><span class="hljs-string">"'"</span></span>; result += <span class="hljs-string"><span class="hljs-string">"\\"</span></span>; }; flat(<span class="hljs-number"><span class="hljs-number">3</span></span>); mountain(<span class="hljs-number"><span class="hljs-number">4</span></span>); flat(<span class="hljs-number"><span class="hljs-number">6</span></span>); mountain(<span class="hljs-number"><span class="hljs-number">1</span></span>); flat(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(landscape()); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ___/''''\______/'\_</span></span></code> </pre><br><br>  The flat and mountain functions see the result variable, because they are inside the function in which it is defined.  But they cannot see each other‚Äôs count variables, because the variables of one function are outside the scope of another.  And the environment outside the landscape function does not see any of the variables defined inside this function. <br><br>  In short, in every local scope you can see all the areas that contain it.  The set of variables available inside the function is determined by the place where this function is described in the program.  All variables from the blocks surrounding the function definition are visible ‚Äî including those defined at the top level in the main program.  This approach to scopes is called lexical. <br><br>  People who have studied other programming languages ‚Äã‚Äãmay think that any block enclosed in braces creates its own local environment.  But in JavaScript, only functions create scope.  You can use detached units: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> something = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> something = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  -   something... } //   ...</span></span></code> </pre><br><br>  But something inside a block is the same variable as the outside.  Although such blocks are allowed, it makes sense to use them only for if commands and loops. <br><br>  If this seems strange to you, it does not seem so only to you.  In the JavaScript version 1.7, the let keyword appeared, which works as var, but creates variables that are local to any given block, and not just to a function. <br><br><h4>  Functions as values </h4><br>  Function names are usually used as the name for a piece of a program.  Such a variable is set once and does not change.  So it's easy to confuse a function and its name. <br><br>  But these are two different things.  A function call can be used as a simple variable ‚Äî for example, to use them in any expressions.  It is possible to store a function call in a new variable, transfer it as a parameter to another function, and so on.  Also, the variable storing the function call remains an ordinary variable and its value can be changed: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> launchMissiles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ missileSystem.launch(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (safeMode) launchMissiles = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{<span class="hljs-comment"><span class="hljs-comment">/*  */</span></span>};</code> </pre><br><br>  In Chapter 5, we will discuss the wonderful things that can be done by passing function calls to other functions. <br><br><h4>  Function declaration </h4><br>  There is a shorter version of the expression ‚Äúvar square = function ...‚Äù.  The function keyword can be used at the beginning of the instruction: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x; }</code> </pre><br><br>  This is a function declaration.  The instruction defines the square variable and assigns it the specified function.  While everything is ok.  There is only one pitfall in this definition. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The future says:"</span></span>, future()); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">future</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"We STILL have no flying cars."</span></span>; }</code> </pre><br><br>  This code works, although the function is declared below the code that uses it.  This is because function declarations are not part of the normal execution of programs from top to bottom.  They "move" to the top of their scope and can be called in any code in this area.  Sometimes this is convenient, because you can write the code in the order that looks most meaningful, without worrying about the need to define all the functions above the place where they are used. <br><br>  And what will happen if we put a function declaration inside a conditional block or a loop?  Don't do that.  Historically, different platforms for running JavaScript handled such cases in different ways, and the current language standard prohibits doing so.  If you want your programs to work consistently, use function declarations only inside other functions or the main program. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//  if (something) { function b() {} // --! } }</span></span></code> </pre><br><br><h5>  Call stack </h5><br>  It will be useful to look at how the execution order works with functions.  Here is a simple program with several function calls: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">who</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">", "</span></span> + who); } greet(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br><br>  It is processed like this: calling greet makes the passage jump to the beginning of the function.  It calls the built-in function console.log, which intercepts the control, does its job and returns control.  Then he reaches the end of the greet, and returns to the place where he was called from.  The next line again calls console.log. <br><br>  Schematically, this can be shown as: <br><br><pre> <code class="javascript hljs">top greet <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log greet top <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log top</code> </pre><br><br>  Since the function must return to the place where it was called from, the computer must remember the context from which the function was called.  In one case, console.log should go back to greet.  In another, she returns to the end of the program. <br><br>  The place where the computer remembers the context is called the stack.  Each time a function is called, the current context is placed at the top of the stack.  When the function returns, it takes the top context from the stack and uses it to continue. <br><br>  Stacking storage requires memory space.  When the stack grows too large, the computer stops executing and produces something like ‚Äústack overflow‚Äù or ‚Äútoo much recursion‚Äù.  The following code demonstrates this - it asks the computer a very difficult question that leads to endless jumps between two functions.  More precisely, it would be endless jumps if the computer had an endless stack.  In reality, the stack is overflowing. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chicken</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> egg(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">egg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> chicken(); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chicken() + <span class="hljs-string"><span class="hljs-string">" came first."</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ??</span></span></code> </pre><br><br><h5>  Optional arguments </h5><br>  The following code is completely resolved and runs without problems: <br><br><pre> <code class="javascript hljs">alert(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">" !"</span></span>);</code> </pre><br><br>  Officially, the function takes one argument.  However, with such a call she does not complain.  She ignores the rest of the arguments and shows ‚ÄúHello.‚Äù <br><br>  JavaScript is very loyal about the number of arguments passed to a function.  If you pass too much, the extra will be ignored.  Too little - the value will be set to undefined. <br><br>  The disadvantage of this approach is that it is possible - and even likely - to pass the wrong number of arguments to the function, and no one will complain to you about it. <br><br>  The advantage is that you can create functions that take optional arguments.  For example, in the next version of the power function, it can be called with both two and one argument ‚Äî in the latter case, the exponent will be two, and the function works like a square. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">base, exponent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exponent == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) exponent = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; count &lt; exponent; count++) result *= base; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(power(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 16 console.log(power(4, 3)); // ‚Üí 64</span></span></code> </pre><br><br>  In the next chapter we will see how in the body of the function you can find out the exact number of arguments passed to it.  This is useful because  allows you to create a function that takes any number of arguments.  For example, console.log uses this property, and displays all the arguments passed to it: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"R"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí R 2 D 2</span></span></code> </pre><br><br><h4>  Closures </h4><br>  The ability to use function calls as variables, coupled with the fact that local variables are created anew each time a function is called, brings us to an interesting question.  What happens to local variables when the function stops working? <br><br>  The following example illustrates this question.  It declares the wrapValue function, which creates a local variable.  It then returns a function that reads this local variable and returns its value. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> localVariable = n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> localVariable; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrap1 = wrapValue(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wrap2 = wrapValue(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(wrap1()); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1 console.log(wrap2()); // ‚Üí 2</span></span></code> </pre><br><br>  This is valid and works as it should - access to the variable remains.  Moreover, several instances of the same variable can exist at the same time, which once again confirms the fact that local variables are recreated with each function call. <br><br>  This ability to work with reference to an instance of a local variable is called a closure.  The function closing local variables is called closing.  It not only frees you from the worries associated with the lifetime of variables, but also allows you to creatively use functions. <br><br>  With a slight change, we turn our example into a function that multiplies numbers by any given number. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">multiplier</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">factor</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number * factor; }; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> twice = multiplier(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(twice(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 10</span></span></code> </pre><br><br>  A separate variable like localVariable from the wrapValue example is no longer needed.  Since the parameter is in itself a local variable. <br><br>  It will take practice to start thinking in this way.  A good version of a mental model is to imagine that a function freezes the code in its body and wraps it in a package.  When you see the return function (...) {...}, imagine that this is a control panel with a piece of code, frozen for use later. <br><br>  In our example, multiplier returns a frozen piece of code, which we store in the variable twice.  The last line calls the function contained in the variable, and therefore the stored code is activated (return number * factor;).  It still has access to the variable factor, which was determined when the multiplier was called, and it also has access to the argument passed during defrost (5) as a numeric parameter. <br><br><h4>  Recursion </h4><br>  A function may well call itself if it takes care not to overflow the stack.  Such a function is called recursive.  Here is an example of an alternative implementation of the exponentiation: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">base, exponent</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exponent == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base * power(base, exponent - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(power(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 8</span></span></code> </pre><br><br>  Something like this, mathematics defines exponentiation, and perhaps it describes the concept more elegantly than a cycle.  The function calls itself many times with different arguments to achieve multiple multiplication. <br><br>  However, such an implementation has a problem - in the usual JavaScript environment it is 10 times slower than the version with the cycle.  Passing through the loop is cheaper than calling a function. <br><br>  The dilemma of ‚Äúspeed versus elegance‚Äù is quite interesting.  There is a certain gap between convenience for the person and convenience for the car.  Any program can be accelerated by making it bigger and more intricate.  The programmer is required to find a suitable balance. <br><br>  In the case of the first exponentiation, the inelegant cycle is fairly simple and straightforward.  It does not make sense to replace it with recursion.  Often, however, programs work with such complex concepts that I want to reduce efficiency by increasing readability. <br><br>  The basic rule, which has been repeated more than once, and with which I fully agree - do not worry about speed, until you are sure that the program is slow.  If so, find the parts that last the longest and change the elegance to efficiency. <br><br>  Of course, we should not immediately completely ignore speed.  In many cases, as with exponentiation, we do not receive any particular simplicity from elegant solutions.  Sometimes an experienced programmer will immediately see that a simple approach will never be fast enough. <br><br>  I draw attention to this because too many novice programmers cling to efficiency even in small things.  The result is more, more difficult and often not without errors.  Such programs take longer to write, and they often work not much faster. <br><br>  But recursion is not always just a less efficient alternative to cycles.  Some tasks are easier to solve with recursion.  Most often it is a bypass of several branches of a tree, each of which can branch. <br><br>  Here's a riddle for you: you can get an infinite number of numbers, starting with number 1, and then either adding 5 or multiplying by 3. How do we write a function that, having received a number, tries to find a sequence of such additions and multiplications that lead to a given number?  For example, the number 13 can be obtained by first multiplying 1 by 3, and then adding 5 two times.  And the number 15 is generally impossible to get. <br><br>  Recursive solution: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findSolution</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">start, history</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start == target) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> history; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start &gt; target) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(start + <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"("</span></span> + history + <span class="hljs-string"><span class="hljs-string">" + 5)"</span></span>) || find(start * <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"("</span></span> + history + <span class="hljs-string"><span class="hljs-string">" * 3)"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"1"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(findSolution(<span class="hljs-number"><span class="hljs-number">24</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí (((1 * 3) + 5) * 3)</span></span></code> </pre><br><br>  This example does not necessarily find the shortest solution ‚Äî it is satisfied by anyone.  I do not expect you to immediately understand how the program works.  But let's understand this great exercise in recursive thinking. <br><br>  The internal find function deals with recursion.  It takes two arguments - the current number and the string that contains the record of how we arrived at this number.  And returns either a line showing our sequence of steps, or null. <br><br>  For this function performs one of three actions.  If the given number is equal to the goal, then the current story is just the way to achieve it, so it returns.  If the given number is greater than the target, there is no sense to continue multiplying and adding, because this will only increase it.  And if we have not yet reached the goal, the function tries both possible paths, starting with a given number.  She calls herself twice, once with each of the ways.  If the first call returns non-null, it is returned.  In another case, the second is returned. <br><br>  To better understand how the function achieves the desired effect, let's review its calls that occur in the search for a solution for the number 13. <br><br><pre> <code class="javascript hljs">find(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"1"</span></span>) find(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">"(1 + 5)"</span></span>) find(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-string"><span class="hljs-string">"((1 + 5) + 5)"</span></span>) find(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-string"><span class="hljs-string">"(((1 + 5) + 5) + 5)"</span></span>) too big find(<span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-string"><span class="hljs-string">"(((1 + 5) + 5) * 3)"</span></span>) too big find(<span class="hljs-number"><span class="hljs-number">18</span></span>, <span class="hljs-string"><span class="hljs-string">"((1 + 5) * 3)"</span></span>) too big find(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"(1 * 3)"</span></span>) find(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-string"><span class="hljs-string">"((1 * 3) + 5)"</span></span>) find(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-string"><span class="hljs-string">"(((1 * 3) + 5) + 5)"</span></span>) found!</code> </pre><br><br>  Indent shows the depth of the call stack.  The first time, the find function calls itself twice to check solutions starting with (1 + 5) and (1 * 3).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first call looks for a solution starting with (1 + 5), and with the help of recursion checks all solutions that produce a number less than or equal to the required one. </font><font style="vertical-align: inherit;">Does not find, and returns null. </font><font style="vertical-align: inherit;">Then the operator || </font><font style="vertical-align: inherit;">and proceeds to the function call, which examines the variant (1 * 3). </font><font style="vertical-align: inherit;">Here we are lucky, because in the third recursive call we get 13. This call returns a string, and each of the || </font><font style="vertical-align: inherit;">on the way passes this line above, as a result returning the decision.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Grow functions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two more or less natural ways of entering functions into a program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is that you write similar code several times. This should be avoided - more code means more room for errors and more reading material for those trying to understand the program. So we take repetitive functionality, select a good name for it and put it into a function. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second way - you discover the need for some kind of functionality that is worthy of being placed in a separate function. You start with the name of the function, and then write its body. You can even start by writing code that uses the function, before the function itself is defined. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How difficult it is for you to choose a name for a function shows how well you imagine its functionality.</font></font> Take an example.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We need to write a program that displays two numbers, the number of cows and chickens on the farm, followed by the words "cows" and "chickens". </font><font style="vertical-align: inherit;">To the numbers you need to add zeros to the front so that each takes exactly three positions.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">007</span></span>  <span class="hljs-number"><span class="hljs-number">011</span></span> </code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, we need a function with two arguments. </font><font style="vertical-align: inherit;">Begin to code.</font></font><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  function printFarmInventory(cows, chickens) { var cowString = String(cows); while (cowString.length &lt; 3) cowString = "0" + cowString; console.log(cowString + " "); var chickenString = String(chickens); while (chickenString.length &lt; 3) chickenString = "0" + chickenString; console.log(chickenString + " "); } printFarmInventory(7, 11);</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we add to the string .length, we get its length. </font><font style="vertical-align: inherit;">It turns out that while loops add zeros to the numbers in front, until they get a line of 3 characters.</font></font><br><br>  Done!        (   , ),     ,       ,           ? <br><br> , .            ,  ,     .    .   : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  function printZeroPaddedWithLabel(number, label) { var numberString = String(number); while (numberString.length &lt; 3) numberString = "0" + numberString; console.log(numberString + " " + label); } //  function printFarmInventory(cows, chickens, pigs) { printZeroPaddedWithLabel(cows, ""); printZeroPaddedWithLabel(chickens, ""); printZeroPaddedWithLabel(pigs, ""); } printFarmInventory(7, 11, 3);</span></span></code> </pre><br><br>  Works!   printZeroPaddedWithLabel  .     ‚Äì ,     ‚Äì   .  ,       ,    : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  function zeroPad(number, width) { var string = String(number); while (string.length &lt; width) string = "0" + string; return string; } //  function printFarmInventory(cows, chickens, pigs) { console.log(zeroPad(cows, 3) + " "); console.log(zeroPad(chickens, 3) + " "); console.log(zeroPad(pigs, 3) + " "); } printFarmInventory(7, 16, 3);</span></span></code> </pre><br><br>   ,   zeroPad   .       ,     .  ,      . <br><br>       ?      ,       ,         ,  ,  ,   ,   ,  .. <br><br>   ‚Äì    ,    .           .  .     ,     ,     . <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Functions and side effects </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functions can be roughly divided into those that are called because of their side effects, and those that are called to get some value. </font><font style="vertical-align: inherit;">Of course, it is possible to combine these properties in a single function. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first helper function in the farm example, printZeroPaddedWithLabel, is called because of the side effect: it prints the string. </font><font style="vertical-align: inherit;">The second, zeroPad, because of the return value. </font><font style="vertical-align: inherit;">And it is no coincidence that the second function comes in more often than the first. </font><font style="vertical-align: inherit;">Functions that return values ‚Äã‚Äãare easier to combine with each other than functions that create side effects.</font></font><br><br>   ‚Äì   ,  ,       ,          ‚Äì  ,     ,      - .  ,        ,       (    ) ‚Äì   .    .         ,    .      ,     ,   ,       ,     .             ,    ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, do not hesitate to write not entirely clean functions, or to begin the sacred cleaning of the code from such functions. </font><font style="vertical-align: inherit;">Side effects are often helpful. </font><font style="vertical-align: inherit;">There is no way to write a clean version of the console.log function, and this feature is quite useful. </font><font style="vertical-align: inherit;">Some operations are easier to express using side effects.</font></font><br><br><h4>  Total </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This chapter showed you how to write your own functions. </font><font style="vertical-align: inherit;">When the function keyword is used as an expression, returns a pointer to the function call. </font><font style="vertical-align: inherit;">When it is used as an instruction, you can declare a variable by assigning it a function call.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  f     var f = function(a) { console.log(a + 2); }; //   g function g(a, b) { return a * b * 3.5; }</span></span></code> </pre><br><br>      ‚Äì   .   ,   ,   ,      ,    . ,    ,      . <br><br>     ,  ,  .    ,     ,     ,  ,          . <br><br><h4>  Exercises </h4><br><h5>  Minimum </h5><br>       Math.min,     .       .   min,   ,     . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(min(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 0 console.log(min(0, -10)); // ‚Üí -10</span></span></code> </pre><br><br><h5>  Recursion </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have seen that the operator% (remainder of division) can be used to determine whether an even number (% 2). </font><font style="vertical-align: inherit;">And here is another way to determine: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zero is even. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The unit is odd. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For any number N, the parity is the same as for N-2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write the recursive isEven function according to these rules. </font><font style="vertical-align: inherit;">It must take a number and return a boolean value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test it on 50 and 75. Try to ask it -1. </font><font style="vertical-align: inherit;">Why does she behave this way? </font><font style="vertical-align: inherit;">Can I somehow fix it? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Test it on 50 and 75. See how it behaves on -1. </font><font style="vertical-align: inherit;">Why? </font><font style="vertical-align: inherit;">Can you think of a fix to this?</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(isEven(<span class="hljs-number"><span class="hljs-number">50</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(isEven(75)); // ‚Üí false console.log(isEven(-1)); // ‚Üí ??</span></span></code> </pre><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We count the beans. </font></font></h5><br><br>   N   ,    .charAt(N) ( ‚Äú‚Äù.charAt(5) ) ‚Äì         .length.    ,     ( , ‚Äú‚Äù).      0,  ,       string.length ‚Äì 1.  ,       2,      0  1. <br><br>   countBs,      ,     ‚ÄúB‚Äù,   . <br><br>    countChar,     countBs,     ‚Äî ,       ( ,      ‚ÄúB‚Äù).     countBs. </div><p>Source: <a href="https://habr.com/ru/post/240349/">https://habr.com/ru/post/240349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240339/index.html">Documentation for the mod_xml_radius module from FreeSWITCH</a></li>
<li><a href="../240341/index.html">How to search for clients for a small regional web studio</a></li>
<li><a href="../240343/index.html">How Ebean made friends with Gradle and made peace with IntelliJ Idea</a></li>
<li><a href="../240345/index.html">New 0day vulnerability in Windows is exploited in-the-wild</a></li>
<li><a href="../240347/index.html">Why do business hackathons?</a></li>
<li><a href="../240351/index.html">Announcement of the first meeting of Java User Group Sevastopol</a></li>
<li><a href="../240357/index.html">5 popular javascript hacks</a></li>
<li><a href="../240361/index.html">Taming of the Shrew (in fact, no) FineReader</a></li>
<li><a href="../240367/index.html">Support for iOS 8 interactive notifications in the application</a></li>
<li><a href="../240369/index.html">An early version of ReSharper 9 is available for download.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>