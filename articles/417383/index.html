<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript ES6: weaknesses</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In June 2018, ECMAScript 2015 ( ES6 ) celebrated its three-year anniversary. In ES6, firstly, many new features of JavaScript appeared, and secondly, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript ES6: weaknesses</h1><div class="post__text post__text-html js-mediator-article">  In June 2018, ECMAScript 2015 ( <a href="https://benmccormick.org/2015/09/14/es5-es6-es2016-es-next-whats-going-on-with-javascript-versioning">ES6</a> ) celebrated its three-year anniversary.  In ES6, firstly, many new features of JavaScript appeared, and secondly, a new era of language development begins with this standard.  In addition, it was the last large-scale release of JS, as now the TC39 uses a scheme for issuing small annual releases of the standard, rather than introducing its new edition every few years. <br><br> <a href="https://habr.com/company/ruvds/blog/417383/"><img src="https://habrastorage.org/webt/ts/9f/9h/ts9f9hvjwknbldjzd40effqpdbs.jpeg"></a> <br><br>  The last 4 years of ES6, quite justifiably, has attracted widespread attention.  The author of the material, the translation of which we are publishing today, says that he, all this time, thanks to <a href="https://babeljs.io/learn-es2015/">Babel</a> , wrote all the code using the modern version of the JS specifications.  He believes that enough time has passed to critically analyze the new features of ES6.  In particular, he is interested in what he used for some time, and then he stopped using it because it worsened his code. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">About JS weaknesses</font> </h2><br>  Douglas Crockford, in his <a href="https://amzn.to/2LJBY9z">book</a> ‚ÄúJavaScript: Strengths,‚Äù wrote about what can be considered weaknesses of a language.  This is something which, in his opinion, is not worth using.  Fortunately, among the innovations of ES6, there is nothing as unsightly as some of the old problematic features of JS, such as the lax equality operator that performs implicit type conversion, the <code>eval()</code> function and the <code>with</code> instruction.  The new features of ES6 are much better designed.  However, there are some things in it that I avoid.  Those features that are on my list of JS "weaknesses" fell into this list for the following reasons: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  They are, in fact, "traps".  That is, it seems that they are intended to perform certain actions, and in most cases, work as expected.  However, sometimes they behave unexpectedly, which can easily lead to errors. </li><li>  They increase the volume of the language in exchange for a small benefit.  Such features give the developer some small advantages, but require that someone who tries to figure out his code, knowledge of certain mechanisms, usually hidden somewhere.  This is doubly true for API capabilities, when using such a feature means that other code that interacts with code written by some developer must be aware of the use of this API feature. </li></ul><br>  Now, guided by these considerations, let's talk about the weaknesses of ES6. <br><br><h2>  <font color="#3AC1EF">Keyword const</font> </h2><br>  Before the release of ES6, variables in JavaScript could be declared using the <code>var</code> keyword.  In addition, the variables could not be declared at all, then they, even if used in functions, fall into the global scope.  The role of variables can be played by the properties of objects, and functions are declared using the <code>function</code> keyword.  The <code>var</code> keyword has certain features. <br><br>  So, it allows you to create variables that are added to a global object, or those whose scope is limited to functions.  However, the <code>var</code> keyword pays no attention to blocks of code.  In addition, it is possible to refer to a variable declared using the <code>var</code> keyword in the code located before the declaration command.  This phenomenon is known as elevating variables.  These features, if not taken into account, can lead to errors.  In order to rectify the situation, two new keywords for declaring variables appeared in ES6: <code>let</code> and <code>const</code> .  They solved the basic problems of <code>var</code> .  Namely, we are talking about the fact that variables declared using these keywords have a block scope, as a result, for example, a variable declared in a loop is not visible outside of it.  In addition, the use of <code>let</code> and <code>const</code> does not allow access to variables before they are declared.  This will result in a <code>ReferenceError</code> error.  It was a big step forward.  However, the emergence of two new keywords, as well as their features, led to additional confusion. <br><br>  The value of a variable (constant) declared with the <code>const</code> keyword cannot be overwritten after the declaration.  This is the only difference between <code>const</code> and <code>let</code> .  This new feature looks useful, and it can really bring some benefits.  The problem lies in the very keyword <code>const</code> .  The way constants, declared with its help, behave does not correspond to what most developers associate with the notion of "constant". <br><br><pre> <code class="hljs pgsql">const <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>; //      "TypeError: invalid assignment to const `CONSTANT`" <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> = <span class="hljs-number"><span class="hljs-number">345</span></span>; const CONSTANT_ARR = [] CONSTANT_ARR.push(<span class="hljs-number"><span class="hljs-number">1</span></span>) //     [<span class="hljs-number"><span class="hljs-number">1</span></span>]  -    console.log(CONSTANT_ARR)</code> </pre> <br>  Using the <code>const</code> keyword prevents a new value from being written to a constant, but does not make the objects referenced by such constants immune.  This feature provides poor protection against changing values ‚Äã‚Äãwhen working with most data types.  As a result, due to the fact that the use of <code>const</code> can be confusing, and due to the fact that if the keyword <code>let</code> present, the presence of <code>const</code> looks redundant, I decided to always use <code>let</code> . <br><br><h2>  <font color="#3AC1EF">Tagged pattern strings</font> </h2><br>  The <code>const</code> keyword is an example of how a specification creates too many ways to solve too few tasks.  In the case of tagged patterned strings, we have the opposite situation.  The syntax of such strings was considered by the TC39 committee as a way to solve problems of string interpolation and working with multi-line strings.  Then they decided to expand this opportunity by using macros. <br><br>  If you have not previously encountered tagged patterned strings, note that they are a bit like string <a href="https://github.com/tc39/proposal-decorators">decorators</a> .  Here is an example of working with them with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">MDN</a> : <br><br><pre> <code class="hljs lua">var person = <span class="hljs-string"><span class="hljs-string">'Mike'</span></span>; var age = <span class="hljs-number"><span class="hljs-number">28</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(strings, personExp, ageExp)</span></span></span></span> { var str0 = strings[<span class="hljs-number"><span class="hljs-number">0</span></span>]; // <span class="hljs-string"><span class="hljs-string">"that "</span></span> var str1 = strings[<span class="hljs-number"><span class="hljs-number">1</span></span>]; // <span class="hljs-string"><span class="hljs-string">" is a "</span></span> //  (  ) //     , //  ,      . // var str2 = strings[<span class="hljs-number"><span class="hljs-number">2</span></span>]; var ageStr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ageExp &gt; <span class="hljs-number"><span class="hljs-number">99</span></span>){   ageStr = <span class="hljs-string"><span class="hljs-string">'centenarian'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   ageStr = <span class="hljs-string"><span class="hljs-string">'youngster'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str0 + personExp + str1 + ageStr; } var <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = myTag`that ${ person } is a ${ age }`; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>); // that Mike is a youngster</code> </pre> <br>  Tagged pattern strings cannot be called completely useless.  Here is an <a href="https://codeburst.io/javascript-es6-tagged-template-literals-a45c26e54761">overview of</a> some of their uses.  For example, they are useful when cleaning up HTML code.  And, at the moment, their use demonstrates the most accurate approach in situations where you need to perform the same operation on all the input data of an arbitrary string pattern.  However, you need this relatively rarely, you can do the same with the appropriate API (although this solution is longer).  And, for most tasks, using the API will be no worse than using tagged template strings.  This feature does not add new features to the language.  It adds to it new approaches to working with data, which should be familiar to those who have to read the code written using tagged template strings.  And I want my code to remain as clean and clear as possible. <br><br><h2>  <font color="#3AC1EF">Overcomplicated restructuring assignment expressions</font> </h2><br>  Some features of the language look great when used to solve simple tasks; however, when tasks become more complex, these features can get out of control.  For example, I like the ternary conditional operator: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? <span class="hljs-number"><span class="hljs-number">50</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span></code> </pre> <br>  However, the code written with its help becomes difficult to understand if, using such an operator, you start using nested constructs: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> conferenceCost = isStudent ? hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">25</span></span> : <span class="hljs-number"><span class="hljs-number">50</span></span> : hasDiscountCode ? <span class="hljs-number"><span class="hljs-number">100</span></span> : <span class="hljs-number"><span class="hljs-number">200</span></span>;</code> </pre> <br>  The same can be said about destructive assignment.  This mechanism allows you to pull out the values ‚Äã‚Äãof variables from objects or arrays: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = [<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b) <span class="hljs-comment"><span class="hljs-comment">// 2, 4</span></span></code> </pre> <br>  In addition, when using it, you can rename variables, get embedded values, set default values: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a: val1} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, b: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [{b}] = [{a:<span class="hljs-number"><span class="hljs-number">3</span></span>, b:<span class="hljs-number"><span class="hljs-number">4</span></span>} , {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, d: <span class="hljs-number"><span class="hljs-number">6</span></span>}]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {d=<span class="hljs-number"><span class="hljs-number">6</span></span>} = {a: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>}; console.log(val1, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d) <span class="hljs-comment"><span class="hljs-comment">// 2, 4, 5, 6</span></span></code> </pre> <br>  All this is wonderful - until the matter reaches the construction of complex expressions using all these possibilities.  For example, in the expression below, 4 variables are declared: <code>userName</code> , <code>eventType</code> , <code>eventDate</code> , and <code>eventId</code> .  Their values ‚Äã‚Äãare taken from different places in the <code>eventRecord</code> object <code>eventRecord</code> . <br><br><pre> <code class="hljs pgsql">let eventRecord = { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: "Ben M", email: "ben@m.com" }, event: "logged in", metadata: { <span class="hljs-type"><span class="hljs-type">date</span></span>: "10-10-2017" }, id: "123" }; let { <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: { <span class="hljs-type"><span class="hljs-type">name</span></span>: userName = "Unknown" }, event: eventType = "Unknown Event", metadata: [<span class="hljs-type"><span class="hljs-type">date</span></span>: eventDate], id: eventId } = obj;</code> </pre> <br>  To understand this code is almost impossible.  This problem can be solved with the help of a much more readable code, if we use several restructuring operations or refuse them altogether. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventRecord = { user: { name: <span class="hljs-string"><span class="hljs-string">"Ben M"</span></span>, email: <span class="hljs-string"><span class="hljs-string">"ben@m.com"</span></span> }, <span class="hljs-keyword"><span class="hljs-keyword">event</span></span>: <span class="hljs-string"><span class="hljs-string">"logged in"</span></span>, metadata: { date: <span class="hljs-string"><span class="hljs-string">"10-10-2017"</span></span> }, id: <span class="hljs-string"><span class="hljs-string">"123"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userName = eventRecord.user.userName || <span class="hljs-string"><span class="hljs-string">'Unknown'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> eventDate = eventRecord.metadata.date; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">event</span></span>:eventType=<span class="hljs-string"><span class="hljs-string">'UnknownEvent'</span></span>, id:eventId} = eventRecord;</code> </pre> <br>  I do not have a clear guideline indicating that the expression of destructuring assignment needs to be processed.  However, every time I look at a similar expression and cannot instantly understand what task it solves, what variables are used in it, I understand that it is time to simplify the code in order to improve its readability. <br><br><h2>  <font color="#3AC1EF">Default Export</font> </h2><br>  ES6 has one nice feature.  It lies in the way its developers approached the standardization of what was previously done with the help of various libraries, often competing with each other.  So in the specification appeared classes, promises, modules.  This is all that the JS developer community used before ES6, finding it in third-party libraries.  For example, the ES6 modules are a great substitute for what resulted in the AMD / CommonJS format war, and provide a convenient syntax for importing. <br><br>  ES6 modules support two basic ways to export values: named export (named export) and default export, or default export (default export): <br><br><pre> <code class="hljs vhdl">const mainValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> export export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mainValue export const secondaryValue = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a secondary value; export const secondaryValue2 = <span class="hljs-symbol"><span class="hljs-symbol">'This</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> another secondary value;</code> </pre> <br>  A module can use several named export commands, but only one default export command.  When importing what is exported using the default export command, you can give what was exported by default in the import file any name, since no name search is performed during the execution of this search operation.  When using named export, you need to use the variable names from the export file, although renaming is also possible. <br><br><pre> <code class="hljs pgsql">//   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renamedMainValue <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //   <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>; //     <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {secondaryValue <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> otherValue} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./the-above-example'</span></span>;</code> </pre> <br>  The default export enjoyed <a href="https://esdiscuss.org/topic/moduleimport">special attention from the developers of</a> the ES6 standard, and they intentionally created a simpler syntax for it.  However, in practice, I managed to find out that using the technology of named exports is preferable for the following reasons. <br><br><ol><li>  When using named export, the names of exported variables, by default, correspond to the names of imported variables, which simplifies their search for those who do not use intelligent development tools. </li><li>  When using named export, programmers using intelligent development tools get such convenient features as <a href="https://code.visualstudio.com/updates/v1_18">automatic import</a> . </li><li>  Named export makes it possible to consistently export anything from modules in the right quantities.  Default export restricts the developer to only exporting a single value.  As a workaround, you can apply the export of an object with several properties.  However, this approach loses the value of the tree-shaking algorithm used to reduce the size of JS applications collected by something like a webpack.  Using only modules with named exports simplifies the work. </li></ol><br>  In general, it can be noted that the naming of entities is a good practice, since it allows you to uniquely identify them both in code and in conversations about this code.  That is why I use named export. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  You have just learned about the possibilities of ES6, which, according to the author of this material, are unsuccessful.  Perhaps you will join this opinion, perhaps - no.  Any programming language is a complex system, the possibilities of which can be viewed from different points of view.  However, we hope that this article will be useful to all those who seek to write clear and high-quality code. <br><br>  <b>Dear readers!</b>  Is there something in modern JavaScript that you are trying to avoid? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/webt/ri/aw/tq/riawtqey48mow3zanijqzhgifjg.jpeg"></a> </div><p>Source: <a href="https://habr.com/ru/post/417383/">https://habr.com/ru/post/417383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417373/index.html">ZFS Storage, standby and test environments</a></li>
<li><a href="../417375/index.html">15 HTML methods of elements that you have probably never heard of</a></li>
<li><a href="../417377/index.html">Why not use Google Cloud</a></li>
<li><a href="../417379/index.html">New RDTT for Vega-C and Ariane 6</a></li>
<li><a href="../417381/index.html">Skype 8.0 came out: call recording and secret chats</a></li>
<li><a href="../417385/index.html">How I moved ... home, or my answer to the author of the article on "merciless flour"</a></li>
<li><a href="../417389/index.html">Tilt Shift Lens Effect</a></li>
<li><a href="../417391/index.html">Cross-browser web extension for custom scripts Part 4</a></li>
<li><a href="../417393/index.html">How we made a system that gives customers discounts based on individual characteristics</a></li>
<li><a href="../417395/index.html">End-to-end testing: what, why, why</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>