<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Turn off Intel ME 11 using undocumented mode</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During the study of the internal architecture of the Intel Management Engine (ME) version 11, a mechanism was discovered that disables this technology...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Turn off Intel ME 11 using undocumented mode</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/pt/blog/336242/"><img src="https://habrastorage.org/web/5d2/a85/fc0/5d2a85fc04ad45edaafac045c794f031.png"></a> <br><br>  During the study of the internal architecture of the Intel Management Engine (ME) version 11, a mechanism was discovered that disables this technology after the hardware is initialized and the main processor is started.  We will talk about how we found this undocumented regime and its connection with the state program for building the High Assurance Platform (HAP) trust platform. <br><br>  The authors warn that the use of this knowledge in practice can lead to damage to computers, and do not bear any responsibility for this, and also do not guarantee the performance or inoperability of something and do not recommend experimenting without an SPI programmer. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Introduction </h2><br>  The Intel Management Engine is a closed technology that is a microcontroller integrated into the Platform Controller Hub (PCH) chip with a set of embedded peripherals.  It is through PCH that almost all communication between the processor and external devices takes place, therefore Intel ME has access to almost all data on the computer and the ability to execute third-party code allows you to completely compromise the platform.  Such endless opportunities have attracted researchers for years and years, but now interest in Intel ME technology has grown significantly.  One of the reasons for this is the transition of this subsystem to a new hardware (x86) and software (modified MINIX as an operating system) architecture.  The use of the x86 platform makes it possible to use all the power of binary code analysis tools, which was previously difficult, since before the 11th version, the kernel with the rare command system, ARC, was used.  Unfortunately, the analysis of Intel ME 11th version was made difficult by the fact that executable modules are packed with a Huffman code with unknown tables.  But our research team (Dmitry Sklyarov, Mark Yermolov, Maxim Goryachiy) managed to restore them (the utility for unpacking images can be found <a href="https://github.com/ptresearch/unME11">on our page in GitHub</a> ). <br><br>  After unpacking the executable modules, we began to study the software and hardware "stuffing" of Intel ME.  Our team has been doing this for quite a long time, and we have accumulated a large amount of materials that it was decided to publish.  This is the first article in a series of articles on the internal design and features of the Intel ME, and we will describe how to disable the main functionality of the subsystem.  This question is plagued by specialists, since turning it off would reduce the risk of data leakage, for example, if a zero-day vulnerability was detected in this technology. <br><br><h2>  How to turn off ME </h2><br>  How to turn off ME - this question is often asked by some owners of x86-based computers.  The topic of deactivation <a href="https://hardenedlinux.github.io/firmware/2016/11/17/neutralize_ME_firmware_on_sandybridge_and_ivybridge.html">has been</a> <a href="https://habrahabr.ru/company/dsec/blog/282546">raised</a> <a href="https://hardenedlinux.github.io/firmware/2016/11/17/neutralize_ME_firmware_on_sandybridge_and_ivybridge.html">repeatedly</a> , including by <a href="https://github.com/ptresearch/me-disablement/blob/master/How%2520to%2520become%2520the%2520sole%2520owner%2520of%2520your%2520PC.pdf">researchers of our company</a> . <br><br>  The most recently discovered critical (9.8 out of 10) <a href="https://nvd.nist.gov/vuln/detail/CVE-2017-5689">vulnerability</a> in Intel Active Management Technology (AMT), a technology based on Intel ME, adds to this issue. <br><br>  Immediately distress the reader - it is impossible to completely turn off ME on modern computers.  This is primarily due to the fact that this technology is responsible for initialization, power management and launch of the main processor.  The fact that part of the code is ‚Äúhard-wired‚Äù inside the PCH chip, which performs the functions of a south bridge on modern motherboards, adds complexity.  The main means of enthusiasts who are ‚Äústruggling‚Äù with this technology is to remove all the ‚Äúexcess‚Äù from the flash-memory image while keeping the computer working.  But this is not so easy to do, because if the code embedded in the PCH does not find ME modules in the flash memory or determines that they are damaged, the system will not start.  For several years <a href="https://github.com/corna/me_cleaner">now</a> , the <a href="https://github.com/corna/me_cleaner">me_cleaner</a> project has been developing in the network, within which a special utility is available that allows you to remove most of the image and leave only the components vital for the main system.  But even if the system has started, it‚Äôs too early to rejoice - after about 30 minutes an automatic shutdown may occur, as with some failures the ME goes into the Recovery mode in which it does not function longer than a certain fixed time.  As a result, the cleaning process is complicated.  For example, up to the 11th version, it was possible to reduce the size of the image to 90 KB, but in the 11th version it was possible only to 650 KB. <br><br><img src="https://habrastorage.org/web/144/88a/548/14488a548cf64be0a24ca9db6b1e84e0.png"><br><br>  <i>Figure 1. Support for Skylake + architectures in me_cleaner</i> <br><br><h2>  Secrets in QResource </h2><br>  Intel gives motherboard manufacturers the ability to set a small number of ME parameters.  To do this, the company provides equipment manufacturers with a special set of software, which includes utilities such as Flash Image Tool (FIT) for setting the ME and Flash Programming Tool (FPT) parameters, which support flash memory programming directly through the built-in SPI controller.  These programs are not available to the end user, but they can easily be found on the Internet.  From these utilities you can extract a large number of XML files (detailed <a href="https://www.troopers.de/downloads/troopers17/TR17_ME11_Static.pdf">Intel ME: The Way of theStatic Analysis</a> ), the study of which allows you to learn a lot of interesting things: ME firmware structure and description of PCH strap - special configuration bits for various subsystems integrated into the PCH chip. <br><br><img src="https://habrastorage.org/web/68d/48d/ad5/68d48dad5b9347f497d3aaac9c7b707a.png"><br><br>  <i>Figure 2. Packed XML files</i> <br><br>  We were interested in one of these fields named ‚Äúreserve_hap‚Äù, since there was a comment opposite it - High Assurance Platform (HAP) enable. <br><br> <a href=""><img src="https://habrastorage.org/web/4a7/3ab/091/4a73ab091bf94f2b9dd15c06879758b7.png"></a> <br><br>  <i>Figure 3. PCH strap for High Assurance Platform</i> <br><br>  Google search was not long.  Literally the second link says that such a name is a program for creating trust platforms related to the US National Security Agency (NSA).  A presentation describing the program can be found <a href="http://fm.csl.sri.com/LAW/2009/dobry-law09-HAP-Challenges.pdf">here</a> .  Our first thought was to put this bit and see what would happen.  This can be done by anyone if he has a SPI programmer or access to Flash Descriptor (on many motherboards, access rights to regions of flash memory are incorrectly set). <br><br><img src="https://habrastorage.org/web/ef1/c19/318/ef1c193183594fae8182eb05c57fc4f3.png"><br><br>  <i>Figure 4. ME status after HAP bit activation</i> <br><br>  After loading the platform, the meinfo utility reports a strange status - Alt Disable Mode.  A quick check revealed that ME does not respond to commands and does not respond to exposure from the operating system.  We decided to figure out how the system goes into this mode and what it means.  By this time, we have already analyzed the main part of the BUP module, which is responsible for the initial initialization of the platform and, based on the output of meinfo, establishes this status.  To understand the algorithm of BUP, it is necessary to describe the Intel ME software environment in more detail. <br><br><h2>  Intel ME 11 software </h2><br>  Starting with the PCH 100 series, Intel has completely reworked this chip.  A transition was made to the new architecture of embedded microcontrollers - from ARCompact of ARC to x86.  The 32-bit Minute IA microcontroller (MIA), which is used in Intel Edison microcomputers and SoC Quark microcomputers, was chosen as the basis.  It is based on the design of the very old, scalar microprocessor Intel 486 with the addition of a command system (ISA) from the Pentium processor.  However, for PCH, the company manufactures this core using 22nm semiconductor technology, resulting in high energy efficiency of the microcontroller.  There are three such cores in the new PCH: Management Engine (ME), Integrated Sensors Hub (ISH) and Innovation Engine (IE).  The latter two can be activated and deactivated depending on the PCH model and target platform, and the ME core always works. <br><br><img src="https://habrastorage.org/web/cd4/dc1/03c/cd4dc103ccb9499ab2d3971a1a2c7c4d.png"><br><br>  <i>Figure 5. Three x86 processors in PCH</i> <br><br>  Such global changes required changes to the software component of ME.  In particular, MINIX (formerly ThreadX RTOS) was chosen as the basis for the operating system.  Now ME firmware includes a complete operating system with its own processes, threads, memory manager, hardware bus driver, file system, and much more.  ME integrates a hardware crypto processor that supports SHA256, AES, RSA, HMAC algorithms.  Access to equipment for user processes is done through a local descriptor table (LDT).  The address space of the process is also organized through LDT - it is just a part of the global kernel address space, the boundaries of which are specified in the local descriptor.  Thus, the kernel does not need to switch to the memory of different processes (changing page directories), as, for example, in Microsoft Windows or Linux. <br><br>  This concludes the review of the Intel ME software environment and will take a closer look at how the operating system and modules are loaded. <br><br><h2>  Boot stages of Intel ME </h2><br>  The launch starts with the ROM program, which is contained in the static memory built into the PCH.  Unfortunately, the general public doesn‚Äôt know how to read or rewrite this memory, but on the Internet you can find ‚Äúpre-sale‚Äù versions of ME firmware with a ROMB section (ROM BYPASS), which, we suppose, duplicates the ROM functions.  Thus, exploring such firmware, you can restore the basic functionality of the initialization program. <br><br>  Studying ROMB allows you to understand the purpose of the ROM ‚Äî performing initial initialization of equipment, such as an SPI controller, verifying the digital signature of the FTPR section header, loading the RBE module, which is already in flash memory.  RBE, in turn, checks the checksums of the modules KERNEL, SYSLIB, BUP and transfers control to the kernel entry point. <br><br>  It should be noted that these three entities - ROM, RBE and KERNEL - run at the zero privilege level (in ring-0) of the MIA core. <br><br><img src="https://habrastorage.org/web/d3d/7d1/01d/d3d7d101da7a49fcadce6cb8a7edf82b.png"><br><br>  <i>Figure 6. SYSLIB, KERNEL and BUP integrity checks in RBE</i> <br><br>  The first process that the kernel creates is BUP, which is already running in its address space, in ring-3.  The kernel does not start other processes on its own initiative, BUP itself, as well as a separate LOADMGR module, are engaged in this, we will return to it later.  The purpose of the BUP (platform BringUP) is to initialize the entire hardware environment of the platform (including the processor), perform the primary power management functions (for example, start the system by pressing the power button) and start all other ME processes.  Thus, it is safe to say that PCH in the 100th series and above simply does not physically have the ability to run without the correct ME firmware.  First, the BUP initializes the power management controller (PMC) and the ICC controller.  Secondly, it starts a whole string of processes;  Some of them are ‚Äúhard-wired‚Äù in the code (SYNCMAN, PM, VFS), and the other part is contained in InitScript (an autorun analog), which is stored in the header of the FTPR volume and is digitally protected. <br><br><img src="https://habrastorage.org/web/a0c/d03/131/a0cd03131ddd4017a9fce2788cca6ce6.png"><br><br>  <i>Figure 7. Starting SYNCMAN and PM</i> <br><br>  Thus, BUP reads InitScript and starts all processes that satisfy the ME startup type and are IBL processes. <br><br><img src="https://habrastorage.org/web/493/49a/7ff/49349a7ff43748a89755e5b44b82afcf.png"><br><br>  <i>Figure 8. InitScript handling</i> <br><br><img src="https://habrastorage.org/web/e3c/5ca/8da/e3c5ca8da75742c6abd0bc4cc8eef6be.png"><br><br>  <i>Figure 9. List of modules with IBL flag</i> <br><br>  In case the launch of the process failed, BUP will not start the system or <i>transfer it to the Recovery mode, in which automatic power loss will occur after several tens of minutes</i> .  As you can see in the illustration, the last in the list of IBL processes is LOADMGR.  It is the one that starts the remaining processes, but unlike BUP, if an error occurs during the module startup process, LOADMGR will simply proceed to the next one. <br><br>  Thus, the first option to limit the functioning of Intel ME is to remove all modules that do not have the IBL flag in InitScript, which will significantly reduce the size of the firmware.  But initially we wanted to find out what happens to ME in HAP mode.  To do this, consider the program model BUP in more detail. <br><br><img src="https://habrastorage.org/web/a3d/2a0/6ee/a3d2a06ee84b4b6a816e9b796613143c.png"><br><br>  <i>Figure 10. Module startup diagram in ME</i> <br><br><h2>  Bringup </h2><br>  If you look at the algorithm of the BUP module, you can say that the classic finite state machine is implemented inside it.  The execution is functionally divided into two components: the initialization stages (they represent the same state machine) and the execution of service requests of other processes after the system initialization.  The number of initialization stages is different, depending on the platform and SKU (TXE, CSME, SPS, consumer, corporate), but the main ones, common to all versions, can still be distinguished. <br><br><h3>  First stage </h3><br>  At the initial stage, the internal diagnostic file system sfs is created (SUSRAM FS is a file system located in volatile memory), reads the configuration, and, most importantly, receives information from the PMC about what led to this start ‚Äî powering up the platform, global restart the entire platform, restarting only ME or waking up from a state of sleep.  This stage is called boot flow determination.  It depends on the subsequent stages of the finite state machine initialization.  In addition, several operating modes are supported: normal and a set of service modes in which ME is not functioning regularly - HAP, HMRFPO, TEMP_DISABLE, RECOVERY, SAFE_MODE, FW_UPDATE and FD_OVERRIDE. <br><br><h3>  Second stage </h3><br>  At the next stage, initialization of the ICC controller and loading of the ICC profile (responsible for the clock frequencies of the main consumers), initialization of the Boot Guard and the beginning of the cyclic polling of the processor start confirmation occur. <br><br><h3>  Third stage </h3><br>  BUP expects a message from the PMC that the main processor has started.  After that, the BUP starts the PMC asynchronous polling cycle for power events (restarting or shutting down the platform) and proceeds to the next stage.  If such an event occurs, the BUP will perform the requested action at the time of the transition between the initialization stages. <br><br><h3>  Fourth stage </h3><br>  At this stage, the internal hardware is initialized.  BUP also launches the heci polling cycle (a special device designed to receive commands from the BIOS or the operating system) to receive a DID (DRAM Init Done message) from the BIOS.  This message allows ME to understand that the main BIOS initialized the RAM and reserved a special region for ME, UMA, and then proceed to the next stage. <br><br><h3>  Fifth stage </h3><br>  As soon as the DID is received, BUP, depending on the operation mode, which is determined by different components, either starts IBL processes from InitScript (during normal operation), or hangs in a loop, from which it can only exit when it receives a message from PMC, for example, as a result of a request to restart or shut down the system. <br><br>  It is at this stage that we find the HAP processing, and in this mode BUP does not execute InitScript, but hangs.  Thus, the rest of the sequence of actions during normal operation is not related to HAP and will not be considered by us.  The main thing that I want to note: in the HAP mode, the BUP performs all platform initialization (ICC, Boot Guard), but does not start the main ME processes. <br><br><img src="https://habrastorage.org/web/068/9e6/e7d/0689e6e7d432412894f4fdb9ff9e86ba.png"><br><br>  <i>Figure 11. Determining HAP mode</i> <br><br><img src="https://habrastorage.org/web/0c0/e1b/676/0c0e1b676a94481d956025ce8b5087f0.png"><br><br>  <i>Figure 12. Transfer ME to the fifth stage, which is equivalent to hanging</i> <br><br><img src="https://habrastorage.org/web/12a/275/12a/12a27512a6a04d8eb9872d2c34e7698f.png"><br><br>  <i>Figure 13. Fifth Stage</i> <br><br><h2>  HAP bit setting </h2><br>  Based on the foregoing, the second disconnect option is to install the HAP bit and remove or damage all modules except those that are needed by the BUP to start - RBE, KERNEL, SYSLIB, BUP.  You can do this simply by removing them from the FTPR CPD section and recalculating the checksum of the CPD header (the structure of the ME firmware is described <a href="https://www.troopers.de/downloads/troopers17/TR17_ME11_Static.pdf">here</a> ). <br><br>  One more question remains: how to set this bit?  You can use the FIT configuration files and determine where it is located in the image, but there is an easier way.  If you open FIT, then in the ME Kernel section you can find a certain parameter Reserved.  It is this bit that is responsible for enabling the HAP mode. <br><br><img src="https://habrastorage.org/web/9ea/8d0/da7/9ea8d0da768e4bf2a868399ba05e5e42.png"><br><br>  <i>Figure 14. HAP Mode Activation Bit</i> <br><br><h2>  HAP and Boot Guard </h2><br>  We also found the code in BUP, which, when HAP mode is activated, sets an extra bit in the Boot Guard policies.  Unfortunately, we have not yet managed to figure out what controls this bit. <br><br><img src="https://habrastorage.org/web/481/660/38d/48166038df0440389345df12beadb225.png"><br><br>  <i>Figure 15. Setting the extra bit for Boot Guard</i> <br><br><h2>  ME 11 support in me_cleaner </h2><br>  While this article was being prepared for printing, the developers updated me_cleaner, as a result of which it also began to remove from the images all modules except RBE, KERNEL, SYSLIB and BUP, but without setting the HAP bit, which introduces ME into ‚ÄúTemporaryDisable‚Äù mode.  We were curious about what happens with this approach. <br><br>  We found that deleting partitions with the ME file system results in an error when reading the cfg_rules file.  This file contains a number of different system settings.  Among them, we believe, is a flag, which we called ‚Äúbup_not_temporary_disable‚Äù.  If it is not set, the entire subsystem is transferred to the TemporaryDisable mode, and since this flag is a global variable initialized by default to zero, the read error is regarded as a configuration requiring shutdown. <br><br>  Note also that we also checked the firmware from the server and mobile versions of ME (SPS 4.x and TXE 3.x).  In the server version, this flag is always set to 1, and is not analyzed in the mobile.  It follows from the above that this method will not work on server and mobile versions (Apollo Lake) ME. <br><br><img src="https://habrastorage.org/web/3ac/ab6/77a/3acab677a6114efcbcde43beff77d988.png"><br><br>  <i>Figure 16. Reading the cfg_rules file</i> <br><br><h2>  Instead of conclusion </h2><br>  Thus, we have found an undocumented PCH strap, which allows Intel ME ME to go into shutdown mode at an early stage.  Although the physical removal of modules from the image while preserving their working capacity implicitly proves that this mode turns off ME, binary analysis leaves no doubt.  With a great deal of confidence, we can say that Intel ME is no longer able to get out of this mode, since no code has been found in the RBE, KERNEL and SYSLIB modules that would allow this.  We also believe that ROM integrated into PCH is almost the same as ROMB, in which nothing similar was found either.  Thus, HAP will protect against vulnerabilities present in all modules except RBE, KERNEL, SYSLIB, ROM and BUP, but, unfortunately, this mode will not protect against the exploitation of errors at earlier stages. <br><br>  We introduced Intel representatives to the study details.  Their response confirmed our conjecture about the relationship of the undocumented regime to the High Assurance Platform program.  With the permission of the company we give an excerpt from the answer: <br><br><blockquote>  Mark / Maxim, <br>  Requirements for customers or customers.  In the case of the United States government‚Äôs High Assurance Platform program, the modifications were made.  These modifications are under officially limited configuration. </blockquote><br>  We believe that this mechanism is the satisfaction of the usual request of any government service that wants to reduce the likelihood of leakage through side channels.  But the main question remains: how does HAP affect the functioning of Boot Guard?  Due to the closed nature of this technology, it is not yet possible to answer this question, but we hope that we will succeed in the near future. <br><br>  <b>Authors</b> : Hot Maxim, Ermolov Mark </div><p>Source: <a href="https://habr.com/ru/post/336242/">https://habr.com/ru/post/336242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336230/index.html">XBRL: just about the complex - Chapter 6. Immersion in XBRL - Part 4. How to make life easier</a></li>
<li><a href="../336232/index.html">Reverse engineering malicious fraud script</a></li>
<li><a href="../336234/index.html">With the wind! How we introduced contactless payment of trips to the subway</a></li>
<li><a href="../336236/index.html">Fill in "Agreements, taxes and banking information" in iTunes connect for Russian LLC</a></li>
<li><a href="../336240/index.html">Welcome to South DevFest 2017</a></li>
<li><a href="../336246/index.html">Championship #PGHACK. Platform</a></li>
<li><a href="../336248/index.html">Four types of programmers</a></li>
<li><a href="../336250/index.html">How to work with designers</a></li>
<li><a href="../336252/index.html">Comparative load testing of Lua-connectors for Tarantool from NGINX</a></li>
<li><a href="../336254/index.html">Features of the development of mobile MMO RTS. Part 6</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>