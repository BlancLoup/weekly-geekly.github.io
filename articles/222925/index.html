<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DIY: Universal Ambilight for home multimedia system - Atmosvet</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day. 

 For my first article I chose one of my most successful handicrafts: HDMI-passthrough analogue of Philips Ambilight, then I will call this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DIY: Universal Ambilight for home multimedia system - Atmosvet</h1><div class="post__text post__text-html js-mediator-article">  Good day. <br><br>  For my first article I chose one of my most successful handicrafts: HDMI-passthrough analogue of Philips Ambilight, then I will call this song ‚ÄúAtmosvet‚Äù. <br><br><h5>  Introduction </h5><br>  On the Internet, it is not very difficult to find ready / open solutions and articles on how to make Ambilight for a monitor / TV, if you display a picture from a PC.  But in my multimedia system, displaying pictures on a TV with a PC takes only 5% of the time of use, I play more games from game consoles, which means I had to invent something of my own. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h6>  Initial data: </h6><br><ul><li>  60 "Plasma TV </li><li>  HTPC based on Asrock Vision 3D 137B </li><li>  Xbox 360 </li><li>  PS3 </li><li>  PS4 </li><li>  WiiU </li></ul><br>  Most devices use <a href="">HDCP</a> to play content even while playing. <br><h6>  Demand: </h6><br>  It is necessary to provide centralized support for Atmosvet for all devices connected to the TV. <br><br><h5>  Implementation </h5><br>  I will not tell you how I attached a 4.5m LED strip to a TV and what needs to be done with the Arduino, you can use <a href="http://habrahabr.ru/post/200200/">this article</a> as a base. <br><br>  The only nuance: <br>  I noticed that strange blinks were going on at the bottom of the screen, at first I sinned on the signal, rewrote the deflicker, changed the resizing of the picture and dug up a whole lot, it became better, but it didn‚Äôt help with the blink.  Began to watch.  It turned out that the flicker was only at the end of the tape, and then with bright scenes.  Taking a multimeter, I measured the voltage at the beginning, middle and end of the tape and guessed the cause of the flicker: at the beginning of the tape was 4.9V (yes, the Chinese PD gives voltage with a deviation, this is not significant), in the middle of 4.5 at the end 4.22 - The voltage drop is too significant I just had to solve the problem - by the middle of the tape I had power from the power supply unit, the wire was let out behind the TV.  It helped instantly, any flicker stopped altogether. <br><br><h6>  Capture image webcam </h6><br>  The first test version for running in the idea and its visualization was selected through a webcam image capture) it looked something like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/529/dfb/6c0/529dfb6c016ba5cdd0813124c392c218.png" alt="image"><br><br>  Low color rendering and high latency showed that this implementation cannot be used in any way. <br><br><h6>  Capturing pictures via HDMI </h6><br><br>  In the process of exploring possible options, the following scheme was chosen as the most reliable and budgetary one: <br><ul><li>  The signal from all devices is fed to the <a href="http://www.dx.com/p/6-port-1080p-hdmi-switch-w-remote-controller-5-in-1-out-104846">5in-1out HDMI switch</a> that supports HDCP </li><li>  The output signal is sent to the <a href="http://www.dx.com/p/one-input-to-two-output-hdmi-1-4-splitter-65732">1in-2out HDMI splitter</a> , which not only supports HDCP, so also turn it off at the output (thank the Chinese). </li><li>  One of the output signals goes to the TV. </li><li>  Another output goes to <a href="http://www.dx.com/p/playvision-hdv-m610-mini-hdmi-to-av-video-audio-converter-white-152345">HDMI to AV Converter</a> </li><li>  S-Video signal goes to the <a href="http://www.iconbit.ru/products/106961/">capture box from ICONBIT</a> </li><li>  The capture box connects to the ever-running HTCP via USB, which is connected to the Arduino controller tape on the TV. </li></ul><br><br>  Initially it looks wild and like crutches, but: <br><ul><li>  It works. </li><li>  Sumno the whole thing, ordering from China, I cost thousands of 3-4 thousand rubles. </li></ul><br><br>  Why I did not use the board for HDMI capture?  It's simple: the cheapest option and affordable is the Blackmagic Intensity Shuttle, but it cannot work with a 1080p / 60fps signal, only with 1080p / 30fps - which is not acceptable, because  I did not want to lower the frame rate so that I could capture the picture.  + This case cost around 10 thousand.  rubles.  - which is not cheap with an unknown result. <br><br>  The HDMI to S-video conversion loss is insignificant for capturing color in the resolution of 46x26 LED backlighting. <br><br>  Initially, I tried to use <a href="http://www.dx.com/p/easycap-usb-video-capture-adapter-5707">EasyCap</a> for capturing S-video (it has a lot of Chinese variations), but the point is that the chip used there is extremely poor, and you cannot work with it using openCV. <br><br>  The only minus is that the S-Video output signal contained black bars at the edges that cut off the real content (about 2-5%), I cut the output image from the capture card to remove these bands, the very loss of the image in those areas did not affect the result in practice. <br><br><h5>  Soft </h5><br>  For me it was the most interesting part, because  with glands, I don‚Äôt really like poking around. <br><br>  To capture a picture, I used <a href="http://opencv.org/">openCV</a> and in particular its .NET wrapper <a href="http://www.emgu.com/wiki/index.php/Main_Page">emgu CV</a> . <br><br>  I also decided to apply several different post-processing techniques for the image and its preparation, before giving the list of colors to the controller. <br><br><h5>  Frame processing </h5><br><h6>  1. Getting captured frame </h6><br><h6>  2. Crop frame, to exclude black bars </h6><br>  Everything is simple: <br><pre><code class="cs hljs">frame.ROI = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, frame.Width - <span class="hljs-number"><span class="hljs-number">8</span></span>, frame.Height - <span class="hljs-number"><span class="hljs-number">18</span></span> - <span class="hljs-number"><span class="hljs-number">8</span></span>);</code> </pre> <br>  Crop 8 pixels on the top, 8 on the right and 18 on the bottom. (There is no band on the left) <br><br><h6>  3. Resize the frame in the backlight resolution, there‚Äôs no need for us to carry a healthy picture with us </h6><br>  Also nothing complicated, we do it with openCV: <br>  frame.Resize (LedWidth - 2 * LedSideOverEdge, <br>  LedHeight - LedBottomOverEdge - LedTopOverEdge, <br>  INTER.CV_INTER_LINEAR); <br>  The attentive reader will notice an abundance of variables.  The fact is that my TV frame is quite large, taking up 1 LED on the sides, 1 on top and 3 on the bottom, so the resize is placed on the LEDs that are directly opposite the display, and we already add corners later.  When resizing, we just get the average colors that the pixels of the LEDs should have. <br><br><h6>  4. We carry out mapping of light-emitting diodes from a rendered frame </h6><br>  Well, here, too, everything is simple, stupidly we pass on each side and successively fill an array of 136 values ‚Äã‚Äãwith the color of the LEDs.  So it turned out that at the moment all other operations are easier to perform with an array of LEDs than with a frame that is harder to process.  Also for the future, I added the ‚Äúdepth‚Äù parameter of capture (the number of pixels from the border of the screen, for averaging the color of the LED), but in the final setup, it turned out better without it. <br><br><h6>  5. Perform color correction (white balance / color balance) </h6><br>  The walls behind the TV in my bar, yellow timber, so you need to compensate for the yellowness. <br>  var blue = 255.0f / (255.0f + blueLevelFloat) * pixelBuffer [k]; <br>  var green = 255.0f / (255.0f + greenLevelFloat) * pixelBuffer [k + 1]; <br>  var red = 255.0f / (255.0f + redLevelFloat) * pixelBuffer [k + 2]; <br>  In general, I initially from the source of some open source editor took the color balance, but he did not change white (white remained white), I changed the formulas a little, sealed up, and got straight what I needed: if the level of the color component is negative (I will understand how this color is not enough), then we add its intensity and vice versa.  For my walls it turned out: RGB (-30,5,85). <br><br>  In color correction, I also align the black level (black comes somewhere around 13,13,13 in RGB), just subtracting 13 from each component. <br><br><h6>  6. Perform desaturation (reducing image saturation) </h6><br>  In the final setup, I do not use desaturation, but at some point I may need it, in fact it makes the colors more ‚Äúpastel‚Äù, like Phillips‚Äôs ambilight.  I will not give the code, we simply convert from RGB -&gt; HSL, reduce the Saturation component (saturation) and go back to RGB. <br><br><h6>  7. Deflicker </h6><br>  So it turns out that the input image is ‚Äútrembling‚Äù - this is a consequence of converting to an analog signal, as I suppose.  At first I tried to solve it in my own way, then I spied on the source of the Defliker filter used in VirtualDub, rewrote it in C # (it was in C ++), I realized that it does not work, because it is such that it fights with flicker between frames. in the end, I combined my decision and this deflicker received something strange, but it worked better than expected.  The initial deflicker worked only with the intensity of the entire frame, I need for each LED separately.  The initial deflicker compared the intensity change as a sum, I like the comparison of the length of the color vector more. The initial deflicker compared the delta intensity change compared with the previous frame, it does not fit, and I redid the average intensity value within the previous frame window.  And there are many other little things, as a result of which little was left of the initial deflicker. <br>  The basic idea: based on the average intensity of previous frames, to perform the modification of the current frame, if its intensity is not above a certain threshold (I have this threshold in the final setup 25), if the threshold is over, then the window is reset without modification. <br>  A slightly modified (for out-of-context readability) code of my deflicker: <br><pre> <code class="cs hljs">Array.Copy(_leds, _ledsOld, _leds.Length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _leds.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> lumSum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Calculate the luminance of the current led. lumSum += _leds[i].R*_leds[i].R; lumSum += _leds[i].G*_leds[i].G; lumSum += _leds[i].B*_leds[i].B; lumSum = Math.Sqrt(lumSum); // Do led processing var avgLum = 0.0; for (var j = 0; j &lt; LedLumWindow; j++) { avgLum += _lumData[j, i]; } var avg = avgLum/LedLumWindow; var ledChange = false; if (_strengthcutoff &lt; 256 &amp;&amp; _lumData[0, i] != 256 &amp;&amp; Math.Abs((int) lumSum - avg) &gt;= _strengthcutoff) { _lumData[0, i] = 256; ledChange = true; } // Calculate the adjustment factor for the current led. var scale = 1.0; int r, g, b; if (ledChange) { for (var j = 0; j &lt; LedLumWindow; j++) { _lumData[j, i] = (int) lumSum; } } else { for (var j = 0; j &lt; LedLumWindow - 1; j++) { _lumData[j, i] = _lumData[j + 1, i]; } _lumData[LedLumWindow - 1, i] = (int) lumSum; if (lumSum &gt; 0) { scale = 1.0f/((avg+lumSum)/2); var filt = 0.0f; for (var j = 0; j &lt; LedLumWindow; j++) { filt += (float) _lumData[j, i]/LedLumWindow; } scale *= filt; } // Adjust the current Led. r = _leds[i].R; g = _leds[i].G; b = _leds[i].B; // save source values var sr = r; var sg = g; var sb = b; var max = r; if (g &gt; max) max = g; if (b &gt; max) max = b; double s; if (scale*max &gt; 255) s = 255.0/max; else s = scale; r = (int) (s*r); g = (int) (s*g); b = (int) (s*b); // keep highlight double k; if (sr &gt; _lv) { k = (sr - _lv)/(double) (255 - _lv); r = (int) ((k*sr) + ((1.0 - k)*r)); } if (sg &gt; _lv) { k = (sg - _lv)/(double) (255 - _lv); g = (int) ((k*sg) + ((1.0 - k)*g)); } if (sb &gt; _lv) { k = (sb - _lv)/(double) (255 - _lv); b = (int) ((k*sb) + ((1.0 - k)*b)); } _leds[i] = Color.FromArgb(r, g, b); } /* Temporal softening phase. */ if (ledChange || _softening == 0) continue; var diffR = Math.Abs(_leds[i].R - _ledsOld[i].R); var diffG = Math.Abs(_leds[i].G - _ledsOld[i].G); var diffB = Math.Abs(_leds[i].B - _ledsOld[i].B); r = _leds[i].R; g = _leds[i].G; b = _leds[i].B; int sum; if (diffR &lt; _softening) { if (diffR &gt; (_softening &gt;&gt; 1)) { sum = _leds[i].R + _leds[i].R + _ledsOld[i].R; r = sum/3; } } if (diffG &lt; _softening) { if (diffG &gt; (_softening &gt;&gt; 1)) { sum = _leds[i].G + _leds[i].G + _ledsOld[i].G; g = sum/3; } } if (diffB &lt; _softening) { if (diffB &gt; (_softening &gt;&gt; 1)) { sum = _leds[i].B + _leds[i].B + _ledsOld[i].B; b = sum/3; } } _leds[i] = Color.FromArgb(r, g, b); }</span></span></code> </pre><br>  Let _leds be an array of Color LEDs, _ledsOld are frame values ‚Äã‚Äãbefore conversion, LedLumWindow is the window width of previous frames, to estimate the average intensity change, in the final setup window I had 100, which is about 30 seconds / s for 3 seconds.  _lumData is an array of intensity values ‚Äã‚Äãof previous frames. <br><br>  In the end, this mechanism gave more pleasant unexpected effects on the picture, it is difficult to describe how it is perceived visually, but it makes it darker where necessary and brighter where necessary, like a dynamic contrast.  The purpose of the deflicker was a broad result, not only eliminating flicker, but also a general balancing of the displayed color, both in terms of the components and the time within the window. <br><br><h6>  8. Smoothing LEDs on neighbors. </h6><br>  In general, in the final setup, I did not really like the smoothing, and I turned it off, but in some cases it may be useful.  Here we simply average the color of each LED over its neighbors. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> smothDiameter = <span class="hljs-number"><span class="hljs-number">2</span></span>*_smoothRadius + <span class="hljs-number"><span class="hljs-number">1</span></span>; Array.Copy(_leds, _ledsOld, _leds.Length); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _ledsOld.Length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rad = -_smoothRadius; rad &lt;= _smoothRadius; rad++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = i + rad; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { pos = _ledsOld.Length + pos; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &gt; _ledsOld.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>) { pos = pos - _ledsOld.Length; } r += _ledsOld[pos].R; g += _ledsOld[pos].G; b += _ledsOld[pos].B; } _leds[i] = Color.FromArgb(r/smothDiameter, g/smothDiameter, b/smothDiameter); }</code> </pre><br><br><h6>  9. Save the current state, so that the thread of sending the packages is grabbed and sent to the backlight controller. </h6><br>  I deliberately divided the process of processing frames and sending packets to the controller: the packets are sent once a certain interval (I have 40ms) so that Arduino sings to process the previous one, because more than 30ms she drowns, so it turns out that we are not directly dependent on the frame rate capture and do not interfere with that process (and after all sending a package also spends time). <br><br><h5>  A little about Arduino </h5><br>  You can‚Äôt just take and send a huge Arduino package on the TV series, because it will go beyond the HardwareSerial default buffer and you will lose its end. <br>  This is solved quite simply: setting the size of the HardwareSerial buffer of sufficient size to fit the entire packet with an array of colors, for me it is 410. <br><br><h5>  Ui </h5><br>  The software itself was implemented as a win service, in order to configure all the parameters + enable / disable I did a Web UI that communicated with the service through the WebService on the service.  The final interface on the mobile screen looks like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/524/b5b/e62/524b5be6232a224b261480bf7c2453b4.png" alt="image"><br><br>  Now I plan to screw the voice control through Kinect for Windows connected to the HTCP. <br><br><h5>  Result </h5><br>  As a result, the result met all expectations, and now playing games on consoles, I get even more immersion in the atmosphere of the game. <br><br>  As a general result of the work, I recorded a video with the work of the atmosphere according to my scheme: <br><br>  Test sample 1: Pacific Rim, a battle scene in Shanghai, this film is well suited for testing and demonstration, many vivid scenes and flashes, lightning strikes, etc .: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/eEkgB0TNFT4%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhjm8Z3CZ-Kzs1ffOA6VywYO4maoLQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Test sample 2: A clip from MLP, merged from YouTube, is very well suited to test scenes with bright colors (I liked the stripes), as well as quickly changing scenes (at the end of the video you can see the effects of the delay, visible only on video, while It‚Äôs not noticeable to the real view, I tried to measure the video delay - it turned out 10-20ms): <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/NB3n5923yZs%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhgS5gwAUkZDtko8WH22K6rYEk-uAg" frameborder="0" allowfullscreen=""></iframe><br><br>  And lastly, it is worth noting about the resource consumption from the HTPC: <br>  HTPC is ASRock Vision 3D on i3, the atmosphere service is 5-10% CPU and 32MB RAM. <br><br>  Thank you for your attention, I really hope that my article will help someone. </div><p>Source: <a href="https://habr.com/ru/post/222925/">https://habr.com/ru/post/222925/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222907/index.html">Tron fan created for himself a virtual reality with the help of 3 Kinect and Oculus Rift</a></li>
<li><a href="../222915/index.html">When will we take off? Overview of flying cars (and motorcycle)</a></li>
<li><a href="../222919/index.html">Notes on the results of university career day</a></li>
<li><a href="../222921/index.html">Newbie look. What is Google authorship today?</a></li>
<li><a href="../222923/index.html">Yandex Money: "It's not about you, it's about me, I'm sorry, we can not be together"</a></li>
<li><a href="../222931/index.html">How to poison a cat? Detective story with a happy ending</a></li>
<li><a href="../222933/index.html">Poll - Open data of the Ministry of Finance</a></li>
<li><a href="../222935/index.html">Create music from anything</a></li>
<li><a href="../222939/index.html">From Imagine Cup to a startup</a></li>
<li><a href="../222941/index.html">Ruby 2.1 in detail (Part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>