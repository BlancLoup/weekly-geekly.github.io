<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unix as IDE: Working with Text</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A text editor is a basic tool for any programmer, which is why the question of his choice becomes the cause of violent debate. Unix has traditionally ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unix as IDE: Working with Text</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/79f/53c/ac9/79f53cac976e1260bec33ad2f2545952.jpg">  A text editor is a basic tool for any programmer, which is why the question of his choice becomes the cause of violent debate.  Unix has traditionally been closely associated with its two perennial favorites, <b>Emacs</b> and <b>Vi</b> , and their current versions of <b>GNU Emacs</b> and <b>Vim</b> .  These editors have a very different approach to text editing, but they are comparable in strength. <br><br>  Since I belong to the <b>Vim</b> sect, we will further discuss the inexhaustible features of this editor, as well as the command line tools invoked directly from <b>Vim</b> to extend the built-in functionality.  Some of the principles discussed further may be applicable to <b>Emacs</b> , but not for simple editors like <b>Nano</b> . <br><a name="habracut"></a><br>  This will be a very superficial review, since <b>Vim</b> ‚Äôs programming possibilities are truly incalculable, and it‚Äôs still pretty long.  The <b>Vim</b> <i>: help</i> team is known among newbies as a quality and useful source of information, so do not neglect it. <br><br><h4>  File Type Definition </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Vim</b> has many settings that affect its behavior.  For example, it is easy to customize the code highlighting depending on the type of file being downloaded.  Thus, in particular, it is possible to establish an indent style that conforms to the norms of the programming language used.  This setting is better to put one of the first in your <i>.vimrc</i> file. <br><br><pre><code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has(<span class="hljs-string"><span class="hljs-string">"autocmd"</span></span>) filetype on filetype indent on filetype plugin on endif</code> </pre> <br><br><h4>  Syntax highlighting </h4><br><br>  Even if you are working with a 16-color terminal, feel free to turn on the backlight in your <i>.vimrc</i> file: <br><br><pre> <code class="bash hljs">syntax on</code> </pre><br><br>  The color schemes of a standard 16-color terminal are not very good in appearance, but they solve the tasks assigned to them if you pick up the correct syntax files.  There are a huge variety of color schemes, so it will not be difficult to customize them for yourself, and a 256-color terminal or <b>gVim</b> will provide even more opportunities.  Good syntax files will highlight errors with a bright red background color. <br><br><h4>  Line numbering </h4><br><br>  If you are used to numbering lines in traditional IDEs, you can enable it by typing: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> number</code> </pre><br><br>  You can try this trick if you have <b>Vim</b> not older than 7.3, and you want to number the lines not absolutely, but in relation to the current one: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> relativenumber</code> </pre><br><br><h4>  Tag files </h4><br><br>  <b>Vim</b> works very well with the data generated by the <b>ctags</b> utility.  This allows you to quickly find all occurrences of the desired identifier within the project, or go directly to declaring a variable from its place in the code, even if it is in another file.  For large C projects with many files, you can save a huge amount of wasted time, and this may be the closest thing that brings <b>Vim</b> closer to mainstream IDEs. <br><br>  You can run <i>:! Ctags -R</i> in the root directory of the project in one of their supported languages, and as a result you will receive a tag file with definitions and links to the location of identifiers in your project.  When the tag file is ready, you can search for the use of the tag in the project as follows: <br><br><pre> <code class="bash hljs">:tag someClass</code> </pre><br><br>  The <i>: tn</i> and <i>: tp</i> commands allow you to move between tag entries throughout the entire project.  The built-in tag mechanism covers most of the most used features, but if you want more clever chips, like a window with a list of tags, you can install the very popular <b>Taglist</b> plugin.  The <b>Unimpaired</b> plugin by Tim Pope also contains several important command reassignments. <br><br><h4>  Calling external programs </h4><br><br>  There are 2 main methods for invoking external commands from a <b>Vim</b> session: <br><ul><li>  <i>:! &lt;command&gt;!</i>  - used in cases when it is necessary to save the output of the program to the buffer </li><li>  <i>: shell</i> - Run the shell as a child process of <b>Vim</b> .  Suitable for interactive command execution. </li></ul><br><br>  The third method, which is not discussed in detail here, involves the use of plug-ins like <b>Conque</b> to emulate the shell directly in the <b>Vim</b> buffer.  I myself tried it in action, but the plugin seemed to me unfit for use.  Perhaps the matter is simply in the wrong author's intention (see <i>: help design-not</i> ). <br><br>  <b>Vim</b> is not a console or an operating system.  You can hardly run the console inside <b>Vim</b> or use it to control the debugger.  It has a different usage model: use it as a component of the command line or as part of an IDE. <br><br><h4>  Lint-like programs and syntax checking </h4><br><br>  Syntax check or compilation by calling an external program (for example, <code>perl -c</code> , <code>gcc</code> ) can be run from the editor using <i>!: Commands</i> .  If you are editing a Perl file, you can run the following command: <br><br><pre> <code class="bash hljs">:!perl -c % /home/tom/project/test.pl syntax OK Press Enter or <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> to <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span></code> </pre><br><br>  The character "%" is a wildcard for the file loaded into the current buffer.  The result is the text output of the command, if any, under the command line entered.  If you need to call an external program all the time, then it is better to wipe it as a command, or even as a key combination in the <i>.vimrc</i> file.  Below we define the command <i>: PerlLint</i> , called from normal mode using <i>\ l</i> : <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">command</span></span> PerlLint !perl -c % nnoremap &lt;leader&gt;l :PerlLint&lt;CR&gt;</code> </pre><br><br>  For many languages, there is another way to do the same thing by resorting to the quicklist window built into <b>Vim</b> .  Set the <i>makeprg</i> setting for the file type by including a call to the module that forms a readable output for <b>Vim</b> : <br><br><pre> <code class="bash hljs">:<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> makeprg=perl\ -c\ -MVi::QuickFix\ % :<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> errorformat+=%m\ at\ %f\ line\ %l\. :<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> errorformat+=%m\ at\ %f\ line\ %l</code> </pre><br><br>  You must first install the desired module via CPAN.  Upon completion, you can enter the command <i>: make</i> and check the syntax of the file.  If errors are found, you can open the quicklist window ( <i>: copen</i> ), check their description and move between them with <i>: cn</i> and <i>: cp</i> . <br><img src="https://habrastorage.org/storage2/aa6/e91/70f/aa6e9170f6345969f0ccc0aeafde497b.png"><br><br>  Similar tricks work similarly with gcc output, and indeed with any syntax-checking program that operates in the results of its work with file names, line numbers and error messages.  Similarly, you can work with web-based languages ‚Äã‚Äãlike PHP, and with JSLint for Javascript.  There is also a great <b>Syntastic</b> plugin designed for the same purpose. <br><br><h4>  Reading the output of other commands </h4><br>  To call a command and send its output directly to the current buffer, use <i>: r!</i>  .  For example, to get a quick list of the contents of a directory, you can type: <br><br><pre> <code class="bash hljs">:r!ls</code> </pre><br><br>  The teams, of course, is not limited to;  With the help of <i>: r</i> you can read out any files, for example, public keys or template texts: <br><br><pre> <code class="bash hljs">:r ~/.ssh/id_rsa.pub :r ~/dev/perl/boilerplate/copyright.pl</code> </pre><br><br><h4>  Filter output via other commands. </h4><br><br>  If you look at the hedge wider, then it will be all about filtering text in the buffer through external commands.  Since the visual mode of <b>Vim is</b> great for working with data that is divided into columns, it often makes sense to use the <b>column</b> , <b>cut</b> , <b>sort</b> or <b>awk</b> commands. <br><br>  For example, you can sort the entire file by the second column by the following command: <br><br><pre> <code class="bash hljs">:%!sort -k2 -r</code> </pre><br><br>  You can display only the third column of the selected text, where the line matches the pattern "/ vim /": <br><br><pre> <code class="bash hljs">:<span class="hljs-string"><span class="hljs-string">'&lt;,'</span></span>&gt;!awk <span class="hljs-string"><span class="hljs-string">'/vim/ {print $3}'</span></span></code> </pre><br><br>  You can arrange keywords in rows 1 through 10 by column: <br><br><pre> <code class="bash hljs">:1,10!column -t</code> </pre><br><br>  Any text filter or command can be applied this way in <b>Vim</b> , and this increases the range of capabilities of the text editor by an order of magnitude.  In this case, the <b>Vim</b> buffer is considered as a text stream, and all classical utilities communicate easily in this language. <br><br><h4>  Built-in alternatives </h4><br><br>  It should be noted that for the most common operations, such as sorting and searching, <b>Vim</b> has built-in methods <i>: sort</i> and <i>: grep</i> .  They are useful if <i>Vim is</i> used under Windows, but they are not even close to the adaptability of console calls. <br><br><h4>  File comparison </h4><br><br>  <b>Vim</b> has a <b>vimdiff</b> comparison <b>tool</b> that allows you not only to look at differences in different versions of a file, but also to resolve conflicts through a trilateral merge, to replace the difference between pieces of text with the commands <i>: diffput</i> and <i>: diffget</i> .  <b>Vimdiff</b> is called from the command line for at least two files like this: <br><br><pre> <code class="bash hljs">$ vimdiff file-v1.c file-v2.c</code> </pre><br><br><img src="https://habrastorage.org/storage2/000/7c0/1a3/0007c01a3f9374a14bde1cd2ce22526a.png"><br><br><h4>  Version control </h4><br><br>  You can run version control methods directly from <b>Vim</b> , and this is often enough.  It should be remembered that "%" is always the place to put the file from the current buffer: <br><br><pre> <code class="bash hljs">:!svn status :!svn add % :!git commit -a</code> </pre><br><br>  The current champion in Git functionality is the <b>Fugitive</b> plugin by Tim Pope, which I highly recommend to anyone using Git with <b>Vim</b> .  For more detailed coverage of the history and fundamentals of version control systems in Unix, see Part 7 of this series of articles. <br><br><h4>  A big difference </h4><br><br>  Programmers who are accustomed to graphic IDE, often consider <b>Vim a</b> toy or a relic.  Part of the reason is the fact that <b>Vim</b> are used to seeing as a means of editing configuration files on the server, and not at all as a convenient command-line text editor.  Its built-in tools fit so well with external Unix commands that they are often able to surprise even experienced users. <br><br>  <b><i>To be continued...</i></b> <br><br>  <a href="http://habrahabr.ru/post/150930/"><b>Unix as IDE: Introduction</b></a> <br>  <a href="http://habrahabr.ru/post/151064/"><b>Unix as IDE: Files</b></a> <br>  <a href="http://habrahabr.ru/post/151128/"><b>Unix as IDE: Working with Text</b></a> <br>  <a href="http://habrahabr.ru/post/151314/"><b>Unix as IDE: Compile</b></a> </div><p>Source: <a href="https://habr.com/ru/post/151128/">https://habr.com/ru/post/151128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151123/index.html">BigVideo.js: full screen background video</a></li>
<li><a href="../151124/index.html">Happy Tester's Day '12!</a></li>
<li><a href="../151125/index.html">Simulator for testing software APCS: Example</a></li>
<li><a href="../151126/index.html">802.11 Network Security - Top Threats</a></li>
<li><a href="../151127/index.html">Does the Internet dumb us?</a></li>
<li><a href="../151129/index.html">We make a textbook or documentation for an hour on the Sphinx</a></li>
<li><a href="../151130/index.html">Happy Testers Day!</a></li>
<li><a href="../151131/index.html">Kinect for Windows SDK. Part 2. Data Flows</a></li>
<li><a href="../151132/index.html">Leaked information about the unusual camera from Sony</a></li>
<li><a href="../151133/index.html">ReactOS hires and pays in Euro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>