<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating loadable Zabbix modules on the example of adding the Modbus protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the Zabbix 2.2 version, loadable modules were added, which allowed us to expand the capabilities of the system at a new level. ‚ÄúWhy is this needed?...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating loadable Zabbix modules on the example of adding the Modbus protocol</h1><div class="post__text post__text-html js-mediator-article">  In the Zabbix 2.2 version, loadable modules were added, which allowed us to expand the capabilities of the system at a new level.  ‚ÄúWhy is this needed?‚Äù, You ask, because it was always possible to run external scripts and programs from Zabbix.  Of course, first of all, this is speed - modules, like Zabbix itself, are written in C and, with the right approach, work as fast as possible, unlike external programs that need to be run on each poll.  Many may be frightened by the need to write code, but today I want to show you that everything is not so difficult. <br><br>  For example, we will write a module that will allow Zabbix to collect information from devices operating according to the industrial automation protocol, which is widely used in the world - Modbus, and we will take readings of temperature sensors using it, as well as receive electricity parameters from the Mercury 230 meter. portal <a href="https://share.zabbix.com/">share.zabbix.com</a> , where users can share their work on Zabbix. <br><br><img src="https://habrastorage.org/files/3d5/924/c83/3d5924c8386d4bb387d7e4e766eda0a1.jpg"><br><a name="habracut"></a><br><h1>  A few words about Modbus </h1><br>  Modbus is a very common protocol used in industrial automation networks (factories, workshops, other industrial facilities, various engineering systems ‚Äî everywhere you can stumble upon Modbus).  The protocol was developed back in 1979 by Modicon, and over the following decades, thanks to its advantages, Modbus was implemented on a huge number of different devices: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Simplicity</b> <br>  Modbus is very simple.  This allows you to run and implement it on the most simple and cheap pieces of iron.  Nor does it discourage developers from using them in their solutions. <br><br>  <b>Ethernet support</b> <br>  Modbus was on time prepared for the widespread penetration of Ethernet networks, including industrial facilities, and now it works not only via serial RS-232, RS-485 (Modbus RTU / ASCII) lines, but also via TCP / IP (Modbus TCP) . <br><br>  <b>Openness</b> <br>  All specifications of the protocol are open and accessible to all who wish to use it in their decisions, without any license fees to anyone. <br><br>  Now I‚Äôll say a few words about how Modbus works.  Data is accessed in the device‚Äôs memory through special logic tables: <b>Discrete Input, Coils, Input Registers, Holding Registers</b> .  In the first two data are presented in the form of single bits, in the last two - in the form of 16-bit words: <br><table><tbody><tr><th>  Table </th><th>  Data type </th><th>  Access </th></tr><tr><td>  Discrete input </td><td>  1 bit </td><td>  only reading </td></tr><tr><td>  Coils </td><td>  1 bit </td><td>  read and write </td></tr><tr><td>  Input Registers </td><td>  16 bits </td><td>  only reading </td></tr><tr><td>  Holding registers </td><td>  16 bits </td><td>  read and write </td></tr></tbody></table><br>  The first two tables can be used to work with simple discrete values: ‚Äúopen-closed‚Äù, ‚Äúaccident is not an accident‚Äù, etc.  And <b>Input and Holding Registers</b> can be used for everything else.  Moreover, the problem when the data does not fit in 16 bits is easily solved by using two adjacent registers.  So you can work with 32bit floats or long. <br>  Data elements in Modbus can be accessed through pass-through addressing from 0 to 65535 across all tables. <br><br>  Data access may not overlap, and each table leads to a separate memory block: <br><br><img src="https://habrastorage.org/files/7c9/2d5/ca1/7c92d5ca1c7f413d952b3e4eb40993db.png"><br><br>  Similarly, several tables can be used to access the same data: <br><br><img src="https://habrastorage.org/files/01a/568/580/01a5685803e44bc3b612ac6ab9eebc48.png"><br><br>  For example, if we have a controller with 16 dry contacts, and we want to know how it is now, closed or open?  Then we can take the values ‚Äã‚Äãof all 16 contacts at once through the <b>Input Registers</b> table, or read all the contacts in turn through the <b>Input Discrete</b> table. <br><br>  If Modbus devices are on a serial line (RS-485), then each device in Modbus has its own unique address (slave id, from 1 to 247), the polling device is always one and is called a master.  In the case of a Modbus TCP device, an IP address is sufficient. <br><br>  <i>Where do we place Zabbix here with our future module?</i> <br><br>  We will be able to place it as a Modbus master by connecting to the RS-485 network with controllers through a converter, or working with devices that support Modbus TCP directly: <br><br><img src="https://habrastorage.org/files/a05/6b7/505/a056b7505828423598ace81f63eb4435.PNG"><br><br><h2>  Setting up the environment </h2><br>  Let's prepare a small test stand that will help us test our Modbus module in Zabbix.  We will take the equipment from the domestic manufacturer <a href="http://www.owen.ru/">Aries</a> , whose input-output devices will allow us to control the temperature, various discrete sensors, and power supply parameters.  Also, as a bonus, we will take readings from the common three-phase electric meter Mercury 230R with the help of the DU-1M MAX-Logic converter, which can turn the embedded Mercury protocol into a Modbus.  All these devices are connected to the RS-485 bus, to which Zabbix will gain access as a master via an RS232 / RS485 converter. <br><br>  <b>Configuring Aries modules</b> for Modbus operation is described in the device documentation.  In general, here is what you need to do: <br>  Through the Aries configurator, connecting to all modules in turn through the RS232 / RS485 converter: <br><br><ul><li>  Change <b>slaveid</b> addresses to be unique. </li><li>  Set the <b>Modbus RTU</b> exchange protocol </li><li>  For MK110.224.2A: select the type of temperature sensors connected </li></ul><br>  <b>For DU-1M MAX-Logic (Mercury</b> 230 <b>)</b> everything is a bit more complicated: First, carefully follow the instructions on the DU-1M to connect to the Mercury 230 counter, then instead of using a cozy graphical configurator like in Aries we will use the console utility <a href="http://www.modbusdriver.com/modpoll.html">modpoll</a> , sending commands to the configuration registers to configure pairing with the counter (phew!). <br><br>  Here in the end what happens: <br><br><img src="https://habrastorage.org/files/26d/900/7b1/26d9007b1ecc42cbb5d487c0f6038bdb.PNG"><br><br>  And this is how it looks live: <br><br><img src="https://habrastorage.org/files/9a4/29c/18a/9a429c18a55541dcaddb67f5c04e615b.jpg"><br><br>  Having assembled a stand, we will test the performance with the help of <a href="http://www.modbusdriver.com/modpoll.html">modpoll</a> , for example, having connected a temperature sensor to the MB110-2A, we will poll it through register 10, as stated in the documentation for the device: <br><br><img src="https://habrastorage.org/files/9fc/737/b05/9fc737b059714aa29b2efa2422b74f45.png"><br><br>  Or remove the energy consumption of the meter Mercury at the rate of T1: <br><br><img src="https://habrastorage.org/files/b77/b5f/4e4/b77b5f4e433041169d42924f4ea1398a.png"><br><br>  As we can see, there is a connection, and data is collected.  It is time to deliver this data to Zabbix. <br><br><h1>  Writing module </h1><br>  <i>How to write a module for Zabbix?</i> <br><br>  As in the case of running scripts through a <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/items/userparameters">UserParameter,</a> you first need to think about how the <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/items">item</a> key will look like in Zabbix itself.  Let's start with this, in our case it will be such a key: <br><br><pre><code class="hljs xml">modbus_read_registers[ <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">connection</span></span></span><span class="hljs-tag">&gt;</span></span>, <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slave_id</span></span></span><span class="hljs-tag">&gt;</span></span>, <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">reg_to_read</span></span></span><span class="hljs-tag">&gt;</span></span>, <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">modbus_function</span></span></span><span class="hljs-tag">&gt;</span></span>, [<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">datatype</span></span></span><span class="hljs-tag">&gt;</span></span>],[<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">endiannes</span></span></span><span class="hljs-tag">&gt;</span></span>],[<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">first_reg</span></span></span><span class="hljs-tag">&gt;</span></span>] ]</code> </pre> <br>  Inside this key, we will pass four required and three optional parameters: <br><br><ul><li>  <b>connection</b> - IP address or serial port with connection parameters </li><li>  <b>slave_id</b> ‚Äî Modbus Device ID </li><li>  <b>reg_to_read</b> - treasured register with data </li><li>  <b>modbus_function</b> is one of the functions of reading Modbus tables, 1 for reading <b>COILS</b> </li><li>  2 for <b>DISCRETE INPUT</b> , 3 for <b>HOLDING REGISTERS</b> and 4 for <b>INPUT REGISTERS</b> </li><li>  <b>datatype</b> - the type of the returned data from the register.  bit, 16bit int, 32bit int or 32bit float. </li><li>  <b>endianness</b> , <b>first_reg</b> - needed to correctly set the order of bits for 32bit values, as well as to indicate which addressing is used - Modbus data model (table entries, where the first element has address 1 and last n) or PDU addressing (addressing from 0 to 65535 ). </li></ul><br>  So, come up with, great, now let's go directly to the module.  In fact, we need to write a function to collect data from the Modbus registers and add a special Zabbix interface to it from the following functions: <br>  two required functions: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zbx_module_api_version</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zbx_module_init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  And also three optional: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-function">ZBX_METRIC *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zbx_module_item_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zbx_module_item_timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zbx_module_uninit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br>  But we completely copy them from the <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/items/loadablemodules">dummy.c</a> example, which is kindly described in the documentation on Zabbix.  Great, saved time and effort, we go further. <br><br>  And then the question is how to write the collection function itself?  By the way, let's call it this way: <br><br><pre> <code class="hljs lisp">int zbx_modbus_read_registers(<span class="hljs-name"><span class="hljs-name">AGENT_REQUEST</span></span> *request, AGENT_RESULT *result)</code> </pre><br>  And here the work is reduced to a minimum, because in order not to screw up the implementation of the Modbus protocol and not reinvent the wheel, we will take the C library, which already does all this well: <a href="http://libmodbus.org/">libmodbus</a> . <br><br>  Using the libmodbus interface, we will only have to <b>validate the</b> incoming data from Zabbix, then run <b>the polling functions from libmodbus</b> , and then <b>convert the</b> resulting values ‚Äã‚Äãinto Zabbix data types and <b>return</b> them.  Well, or <b>return an</b> error. <br><br>  The rest of the details that I missed can be found <a href="https://www.zabbix.com/documentation/2.4/manual/config/items/loadablemodules">here</a> . <br><br>  And I once again emphasize a couple of key points: <br><br>  1) If the function is successfully executed, the result is put into <b>* result</b> via macros: <br><ul><li>  SET_UI64_RESULT - if the result is an integer </li><li>  SET_DBL_RESULT - if the result is a floating point number </li><li>  SET_STR_RESULT - if the result is Char </li><li>  SET_TEXT_RESULT - if the result is text </li><li>  SET_LOG_RESULT - if the result is a log </li></ul><br>  For example: <br><br><pre> <code class="hljs lisp">SET_DBL_RESULT(<span class="hljs-name"><span class="hljs-name">result</span></span>, modbus_get_float(<span class="hljs-name"><span class="hljs-name">temp_arr</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  And the function itself should return <b>SYSINFO_RET_OK.</b> <br><br>  2) If something went wrong, then you need to return <b>SYSINFO_RET_FAIL</b> , and in <b>* result</b> put an error message that we can see in the Zabbix web interface: <br><br><pre> <code class="hljs lisp">SET_MSG_RESULT(<span class="hljs-name"><span class="hljs-name">result</span></span>, strdup(<span class="hljs-string"><span class="hljs-string">"Check datatype provided."</span></span>))</code> </pre><br><img src="https://habrastorage.org/files/918/183/94a/91818394af314ceb96b041d9dc700b1a.png"><br><br>  3) It is very important to remember to <b>validate</b> all incoming input parameters.  Otherwise, the fall of the module will lead to the fall of the Zabbix server or agent itself. <br><br>  4) Remember that Zabbix launches many parallel polling processes.  So if you are going to work with resources that do not tolerate simultaneous access (file or serial port in our case), then you need to implement control of this access on your own.  I did this through semaphores, which made the task a bit more complicated, but fortunately this need not always be done. <br><br>  5) Since the external libmodbus library is used, it must be installed on the system where the Zabbix module will be used, for this: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">wget</span></span> http://libmodbus.org/releases/libmodbus-3.1.2.tar.gz tar zxvpf libmodbus-<span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span>.tar.gz cd libmodbus-<span class="hljs-number"><span class="hljs-number">3</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ./configure make make install ldconfig</code> </pre><br>  As a result, we got the following <a href="">code</a> for the module: <br><br>  Compile it and add the resulting .so file to Zabbix Server or Zabbix Agent.  Here it is only important to remember that the module depends on some headers of Zabbix itself.  Therefore, if you want to collect everything separately from Zabbix, then copy at least zbxtypes.h, module.h, sysinc.h from the Zabbix sources to yourself.  Well, that's done. <br><br><h1>  Stand testing </h1><br>  For example, the compiled file <i>libzbxmodbus.so will be uploaded</i> to Zabbix Server, for this we add in the Zabbiks config file: <br><br><pre> <code class="hljs pgsql">LoadModulePath = /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/lib LoadModule = libzbxmodbus.so</code> </pre><br>  Add the <i>zabbix</i> user to the <i>dialout</i> group to access the serial port: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">usermod</span></span> -a -G dialout zabbix</code> </pre><br>  ... and restart Zabbix: <br><br><pre> <code class="hljs pgsql">/etc/init.d/zabbix-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> <span class="hljs-keyword"><span class="hljs-keyword">restart</span></span></code> </pre><br>  If everything is successfully restarted, then go to Zabbix and create a <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/templates">template</a> for our Modbus devices. <br><br><h3>  Creating a template </h3><br>  To begin with, <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/items/item">we will create data elements</a> for the 110-224.2A to read the readings of the temperature sensor: <br><br><img src="https://habrastorage.org/files/c3e/966/3d3/c3e9663d3a2242169bf9d2192ea1f553.png"><br><br>  Where is the key ( <i>key</i> ): <br><br><pre> <code class="hljs perl">modbus_read_registers[{$MODBUS_PORT},{$MODBUS_SLAVE},<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,f,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><ul><li>  <i>{$ MODBUS_PORT}</i> - <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/macros/usermacros">Macro</a> that will be overwritten by the parameters of the connection to our device.  For example, at the host level, we define our {$ MODBUS_PORT} as <i>/ dev / ttyUSB0 9600 N 1</i> </li><li>  <i>{$ MODBUS_SLAVE}</i> - another user macro, which means slave_id and we will overwrite it as <i>32</i> </li><li>  <i>10</i> - the register in which lies the temperature value </li><li>  <i>3</i> - Modbus function used for reading, in this case 0x03 READ HOLDING REGISTER </li><li>  <i>f</i> - data type, float </li><li>  <i>1</i> - since Aries controllers use Big endian to encode values ‚Äã‚Äãthat do not fit in one register </li><li>  <i>0</i> - PDU addressing is used </li></ul><br>  More on how to choose the parameters <a href="https://github.com/v-zhuravlev/libzbxmodbus">here</a> .  In addition, you must specify: <br><br>  Type <br>  <i>Simple check</i> - if the module is loaded on Zabbix Server and Zabbix Proxy, <br>  <i>Zabbix agent</i> - if the module is loaded on Zabbix Agent <br><br>  Data <i>Type</i> ( <i>Type of information</i> ): <br>  in our case, this is <i>Numeric (float)</i> . <br><br><h3>  Creating a host </h3><br>  Create <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/hosts">a network node</a> , define macros, as agreed: <br><br><img src="https://habrastorage.org/files/c1d/95c/846/c1d95c8462954133a6d6ddef0afa9233.PNG"><br><br>  And attach the template that you just created: <br><br><img src="https://habrastorage.org/files/c56/7fd/6d3/c567fd6d33534b43aa8013046f2ed6cd.PNG"><br><br><h3>  Data </h3><br>  Go to the section Latest data and can begin to observe the data that we managed to collect from the sensor: <br><br><img src="https://habrastorage.org/files/786/2ca/972/7862ca972c8a410ea23e5cccd028da0b.PNG"><br><br>  And by creating patterns for the remaining device registers, we get the following picture: <br><br><img src="https://habrastorage.org/files/c86/ffb/ea4/c86ffbea4e004c91a69aff0699096df0.png"><br><br>  Well, then we can create <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/triggers">triggers</a> , <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/visualisation/graphs">graphics</a> , <a href="https://www.zabbix.com/documentation/2.2/ru/manual/config/visualisation/screens">complex screens</a> in the templates at will. <br><br><h1>  Conclusion </h1><br>  Using loadable modules, Zabbix developers have given us an interface for creating really fast and well-integrated extensions with Zabbix.  Yes, the possibilities are so far limited by the creation of new types of data elements, and, for example, it will not be possible to add a new trigger function ( <a href="https://support.zabbix.com/browse/ZBXNEXT-2650">ZBXNEXT-2650</a> ), but wait and see. <br><br>  So that the modules do not roll all over the Internet, a second important step was taken towards the organization of user solutions - <a href="https://share.zabbix.com/">share.zabbix.com</a> - a single repository created for the exchange of templates, modules and other extensions for Zabbix.  Looking for a pattern under the sly piece of iron?  Or have you written a template for a tricky piece of hardware and are ready to share it with the rest?  Looking for a solution on how to <a href="https://share.zabbix.com/databases/db_postgresql/postgresql-monitoring-for-zabbix">monitor PostgreSQL</a> ?  Or <a href="https://share.zabbix.com/virtualization/docker-containers-monitoring">Docker</a> ? <br><br>  Come and join us!  Well, our module is already there too. </div><p>Source: <a href="https://habr.com/ru/post/268119/">https://habr.com/ru/post/268119/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268109/index.html">jQuery plugin for organizing components on the page</a></li>
<li><a href="../268111/index.html">Selection of useful articles for iOS developers for the current week</a></li>
<li><a href="../268113/index.html">Secure crypto programming. Part 1</a></li>
<li><a href="../268115/index.html">A simple graphic editor using OpenCV</a></li>
<li><a href="../268117/index.html">IntelliJ IDEA 15 Preview available</a></li>
<li><a href="../268123/index.html">Fantasy on WebDAV. Regular Client</a></li>
<li><a href="../268125/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 15. "UBuyWeRush"</a></li>
<li><a href="../268127/index.html">How does the radio interface work in GSM networks</a></li>
<li><a href="../268129/index.html">File System and Hadoop: The Twitter Experience (Part 2)</a></li>
<li><a href="../268131/index.html">Mono and OS MSVS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>