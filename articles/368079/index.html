<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MRAA library for working with Intel Edison and Intel Galileo boards</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the MRAA library, which can greatly simplify working with various types of devices that use: 



- analog input; 
- digital inp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MRAA library for working with Intel Edison and Intel Galileo boards</h1><div class="post__text post__text-html js-mediator-article">  This article describes the MRAA library, which can greatly simplify working with various types of devices that use: <br><br><ul><li>  analog input; </li><li>  digital input and output; </li><li>  pulse width modulation (PWM); </li><li>  two-wire bus I2C; </li><li>  Universal Asynchronous Receiver-Transmitter (UART); </li><li>  interrupts when input level changes. </li></ul><br> <a href="http://geektimes.ru/company/intel/blog/260998/"><img src="https://habrastorage.org/files/bc6/8fd/16e/bc68fd16e5b74f259b8d369d3a24d343.jpg"></a> <br><a name="habracut"></a><br>  Instead of examples with complete programs, we will consider small fragments in the C language, which will show the basic principles of the MRAA API.  To get more information from this article, you should know the following things: <br><br><ul><li>  easy to master Linux and C; </li><li>  have basic knowledge of digital electronics and the use of GPIO (general-purpose input / output - general purpose inputs and outputs); </li><li>  have documentation on the devices you use. </li></ul><br>  This article does not explain how to compile, build a program, and install applications on this platform. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  <font color="#0071c5">1. Overview MRAA</font> </h1><br>  MRAA (pronounced "em-ra") is a low-level library written in C. It is designed to abstract from the details associated with accessing and controlling I / O on a platform such as Intel Galileo or Intel Edison, by introducing one small API . <br><br><ul><li>  MRAA works as a transition layer for basic input / output port (GPIO) capabilities in Linux.  Despite the fact that Linux offers a fairly rich infrastructure for managing GPIO, and typical commands for working with GPIO are standard, it can still be difficult to use them. <br><br></li><li>  All platforms are different.  Each has different features, pure pins and GPIO types.  For example, a pin may not support the same features for two different platforms.  Pin may not exist on this platform.  Also, the way it is configured may depend on many factors.  For example, using a pin in one mode may interfere with the work of another pin in another mode or prohibit its use altogether.  And since the MRAA library allows you to create platform-independent code, it makes development less complicated. <br><br></li><li>  It must be remembered that although MRAA can be used to write platform-independent code, the developer is still responsible for ensuring that the code is resilient to the limitations of all platforms on which it can be run. </li></ul><br><h2>  <font color="#0071c5">1.1 Downloading the MRAA Library and API Documentation</font> </h2><br>  The MRAA package is already installed on Intel Galileo and Intel Edison and can be connected to your code as shown below.  You can also download the latest source code from the Intel repository. <br>  API documentation is available at <a href="http://iotdk.intel.com/docs/master/mraa/">http://iotdk.intel.com/docs/master/mraa/</a> <br><br><h2>  <font color="#0071c5">1.2 GPIO pin names</font> </h2><br>  There are various ‚Äúpins‚Äù in this article.  The hardware pins are usually referred to by number.  The pin number can also begin with the letter ‚ÄúD‚Äù for the digital type and the letter ‚ÄúA‚Äù for the analog type.  For example, ‚ÄúD0‚Äù will point to digital pin # 0, and ‚ÄúA3‚Äù on analog input pin # 3.  Pin can also be specified as GPIO6, i.e.  This is GPIO-pin number 6, without specifying its type ‚ÄúD‚Äù or ‚ÄúA‚Äù, i.e.  It can be both digital and analog. <br><br><h2>  <font color="#0071c5">1.3 Library Linking</font> </h2><br>  When compiling, link the library with the command ‚Äìlmraa, for example: <br><br><pre><code class="bash hljs">gcc -g blink.c -o blink -lmraa</code> </pre> <br><h2>  <font color="#0071c5">1.4 Using MRAA</font> </h2><br>  Before writing code, remember the following. <br><br>  <b>1.</b> At the beginning of the program, the MRAA should be initialized as follows: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mraa_result_t</span></span> rv; <span class="hljs-attribute"><span class="hljs-attribute">rv</span></span> = mraa_init(); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (rv != MRAA_SUCCESS)    . . .</code> </pre> <br>  <b>2.</b> Many MRAA functions return a result of type mraa_result_t.  It is very important to make sure that the function call occurred without errors. <br><br>  <b>3. The</b> examples in this article do not perform error checking, but it is still highly recommended to do this. <br><br>  <b>4.</b> After initialization, you must specify the MRAA, which way you want to use the pin (input / output, digital / analog / PWM / AURT).  Below will be shown how to do it. <br><br>  <b>5.</b> When the work is completed (for example, at the end of the program), MRAA must be released to release the pins occupied so that it resets all internal states and settings.  Below will be shown how to do it. <br><br><h2>  <font color="#0071c5">1.5 Connecting MRAA Header Files</font> </h2><br>  The main MRAA include file is mraa.h.  It connects with other hardware-dependent header files.  For example: <br>  The code for an analog device should include: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa.h&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa/aio.h&gt;</span></span></span></span></code> </pre> <br>  The code for a digital device should include: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa.h&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa/gpio.h&gt;</span></span></span></span></code> </pre> <br><h1>  <font color="#0071c5">2. Using MRAA with analog devices</font> </h1><br>  An analog device is a device that receives data by measuring the pin voltage value, varying from 0 to the maximum supported.  This maximum voltage is called the reference voltage (AREF - Analog Reference Voltage).  For example, an analog pressure sensor can provide a voltage value starting at 0 (corresponding to no pressure), and increasing with increasing pressure.  This voltage on the sensor is converted into a number by a device called an ADC (Analog-to-digital converter, ADC - analog-to-digital converter).  The program that works with the sensor reads this number, issued from the ADC. <br><br><h2>  <font color="#0071c5">2.1 Reference Voltage</font> </h2><br>  The reference voltage is usually 3.3 V or 5.0 V DC.  However, the reference voltage may differ, as some platforms, such as Intel Edison, allow you to set a different reference value instead of using the built-in value.  Therefore, you need to know the exact value of the reference voltage before you receive data from the device. <br><br><h2>  <font color="#0071c5">2.2 bit ADC</font> </h2><br>  The ADC resolution is very important, as it determines the accuracy of your measurements.  All ADCs used on the Intel platform are 10 bits wide (1024 values).  And at least in the case of Intel Edison 12 bits (4096 values). <br><br>  You can determine the approximate step of voltage measurement accuracy by dividing the value of the reference voltage by the number of available values.  This value can then be used in the application.  For example, with a reference voltage of 5 V and a bit width of 10 bits, we find that the ADC step is approximately 5 mV.  Since  5.0 / 1024 = 0.00488 V <br><br><h2>  <font color="#0071c5">2.3 Interpretation of data</font> </h2><br>  Using the previously described information, you can determine the approximate voltage that is on the analog pin.  With a higher ADC resolution, it is possible to measure voltage with greater accuracy. <br><br><h2>  <font color="#0071c5">2.4 Analog Example</font> </h2><br>  <a href="http://www.seeedstudio.com/depot/Grove-Moisture-Sensor-p-955.html">Grove's humidity sensor</a> is an example of a simple analog device.  It is simply a resistor that changes the voltage level at the analog input according to which moisture level was determined.  The following example shows how the sensor works when it is connected to pin A0.  The program shows how to initialize MRAA and pin A0, read the value, print it and then release the pin. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA analog context */</span></span> mraa_aio_context m_aio; <span class="hljs-comment"><span class="hljs-comment">/* initialize A0 for use as an analog input */</span></span> m_aio = mraa_aio_init(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* read the value, an integer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = mraa_aio_read(m_aio); <span class="hljs-comment"><span class="hljs-comment">/* print the value */</span></span> printf(‚ÄúThe <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> returned was: %d\n‚Äù, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* now release (close) the pin and exit */</span></span> mraa_aio_close(m_aio); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) ; }</code> </pre> <br>  With an ADC of 10 bits, the return value will be from 0 to 1023. How to interpret the value depends on the sensor device.  For the Grove sensor and the ADC bit depth of 10 bits, the documentation gives the following ranges for the state of dry, wet and damp. <br><br><ul><li>  0-299 = dry </li><li>  300-699 = wet </li><li>  700-1023 = wet </li></ul><br>  It is important to remember that all sensors are different, and their values ‚Äã‚Äãcan be difficult to decode.  Consider the following: <br><br>  <b>1.</b> Some sensors have jitter (jitter).  In this case, you need to obtain several consecutive values ‚Äã‚Äãfrom the sensor and find the average value. <br><br>  <b>2.</b> If you are writing a MRAA driver for use on different platforms, it is important that you correctly specify the reference voltage and resolution of the ADC that will be used in the calculations.  Otherwise, the resulting data may be useless.  In the previous example, we did not need to know the reference voltage, but this does not apply to other more complex analog devices.  On some devices, the exact value of the reference voltage and the resolution of the ADC are required to determine the value received from the sensor. <br><br>  <b>3.</b> The value on the sensor is not always linearly related to the measured parameter.  In this case, you need to look in the documentation for the formulas for the translation of values ‚Äã‚Äãor use additional libraries, for example, UPM. <br><br><h1>  <font color="#0071c5">3. Using MRAA with digital devices</font> </h1><br>  Digital devices deal with high and low signal values.  Only these two values ‚Äã‚Äãare used.  For example, in a system operating at a voltage of 5 V, a low level may correspond to 0 V, and a high level of 5 V. Usually a high level is indicated by 1 and a low level by 0. <br>  Digital devices can be configured for input and output.  To be used as an input device, you need to use MRAA to read from a digital pin and return a value indicating whether the voltage was high or low. <br><br>  MRAA provides an API for reading and writing the status of a digital pin.  Additionally, you can connect an interrupt handler to a digital input.  To use the digital input and output capabilities in MRAA, you need to include a header file. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa/gpio.h&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#0071c5">3.1 Example of using a digital input</font> </h2><br>  For example, take a simple digital device, a button.  When the button is not pressed, it has a high voltage, when pressed it is low. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA digital context */</span></span> mraa_ai o_context m_aio; <span class="hljs-comment"><span class="hljs-comment">/* initialize D2 for use as a digital pin */</span></span> m_gpio = mraa_gpio_init(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* configure the digital pin as an input */</span></span> mraa_gpio_dir(m_gpio, MRAA_GPIO_IN); <span class="hljs-comment"><span class="hljs-comment">/* read the value into an integer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = mraa_gpio_read(m_gpio); <span class="hljs-comment"><span class="hljs-comment">/* print the value */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>) printf(‚ÄúThe button <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> being pushed\n‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> printf(‚ÄúThe button <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> not being pushed\n‚Äù); <span class="hljs-comment"><span class="hljs-comment">/* now release (close) the pin and exit */</span></span> mraa_gpio_close(m_gpio); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  As you can see, everything is quite simple.  Notice how we tell MRAA to set the pin to enter using the mraa_gpio_dir () function.  Digital pins can be used for both input and output, as opposed to analog pins, which can only work on input. <br><br><h2>  <font color="#0071c5">3.2.</font>  <font color="#0071c5">Interrupt handlers</font> </h2><br>  Sometimes you do not want to repeat reading the value on the pin to determine the change in its state.  Take for example the sensor that is connected to the motor to count the revolutions per minute.  In this case, it would be unwise to constantly keep reading the state of a pin to determine changes. <br><br>  MRAA offers the possibility to create an interrupt handler and connect it with a pin.  In this case, the MRAA guarantees that your function will be called whenever a specified state change occurs (from 0 to 1 or from 1 to 0). <br><br>  Using this feature, it is easy to write the counting function, and tell MRAA to call it when the state changes.  Below is a simple example of counting the number of transitions from a high signal state to a low one. <br><br><pre> <code class="hljs cpp"><span class="hljs-comment"><span class="hljs-comment">/* first, create our counting variable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Now our simple counting function. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* This will be our interrupt handler. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intrHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg)</span></span></span><span class="hljs-function"> </span></span>{ counter++; } <span class="hljs-comment"><span class="hljs-comment">/* now in our main() function */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA digital context */</span></span> mraa_aio_context m_aio; <span class="hljs-comment"><span class="hljs-comment">/* initialize D2 for use as digital pin */</span></span> m_gpio = mraa_gpio_init(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* configure the digital pin as an input */</span></span> mraa_gpio_dir(m_gpio, MRAA_GPIO_IN); <span class="hljs-comment"><span class="hljs-comment">/* now, setup an interrupt handler. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Our function (intrHandler()) above will */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* be called whenever the pin goes from */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* HIGH to LOW */</span></span> */ mraa_gpio_isr(m_gpio, MRAA_GPIO_EDGE_FALLING, intrHandler, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* sleep for 5 seconds, and then print out the current */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* value of counter */</span></span> sleep(<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚ÄúCounter = %d\n‚Äù, counter); <span class="hljs-comment"><span class="hljs-comment">/* now, stop the interrupt handler and cleanup */</span></span> mraa_gpio_isr_exit(m_gpio); <span class="hljs-comment"><span class="hljs-comment">/* now release (close) the pin and exit */</span></span> mraa_gpio_close(m_gpio); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Note the following in this example: <br><br><ul><li>  The counter variable is defined with the volatile keyword.  It is very important.  The volatile keyword tells the C compiler that the variable can be changed without his knowledge and prohibits it from doing any optimizations with it.  Without volatile, the compiler may decide that the variable does not change at all, and will always output "0".  Any variable that is handled inside the interrupt handler and simultaneously outside of it must be marked as volatile. <br><br></li><li>  In addition to MRAA_GPIO_EDGE_FALLING, the mraa_gpio_isr () function also supports MRAA_GPIO_EDGE_RISING (to define a transition from LOW to HIGH), and MRAA_GPIO_EDGE_BOTH (to define both transitions).  Please note that not all types of transitions are supported by all platforms.  The easiest way to determine what is supported is to check the error code returned by the mraa_gpio_isr () function. <br><br></li><li>  The last argument passed to mraa_gpio_isr () is a pointer.  This argument will be passed to the intrHandler () interrupt handler.  It is optional and can be used to pass additional parameters to the handler function.  In our example, we do not need such features, and we simply pass NULL. <br><br></li><li>  Calling mraa_gpio_isr_exit () disables the interrupt handler, and it is always recommended to call it in order to avoid any unexpected surprises. <br><br></li><li>  Only one interrupt handler can be connected to a specific pin.  The total number of pins that can control interrupts at one time depends on the platform, as well as the type of interrupts that can be used (MRAA_GPIO_EDGE_RISING, MRAA_GPIO_EDGE_FALLING or MRAA_GPIO_EDGE_BOTH).  This is another reason to check the error code when calling MRAA functions. </li></ul><br><h2>  <font color="#0071c5">3.3 Example of digital output</font> </h2><br>  Using digital output is easy.  The following example changes the signal from high (1) to low (0) on a digital output with a period of 1 second.  Something similar can be used to blink an LED connected to a pin. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA digital context */</span></span> mraa_aio_context m_aio; <span class="hljs-comment"><span class="hljs-comment">/* initialize D13 for use as a digital pin */</span></span> m_gpio = mraa_gpio_init(<span class="hljs-number"><span class="hljs-number">13</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* configure the digital pin as an output */</span></span> mraa_gpio_dir(m_gpio, MRAA_GPIO_OUT); <span class="hljs-comment"><span class="hljs-comment">/* now run in a loop 10 times, blinking the output each second */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">/* turn output on (HIGH) */</span></span> mraa_gpio_write(m_gpio, <span class="hljs-number"><span class="hljs-number">1</span></span>); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* turn output off (LOW) */</span></span> mraa_gpio_write(m_gpio, <span class="hljs-number"><span class="hljs-number">0</span></span>); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* now release (close) the pin and exit */</span></span> mraa_gpio_close(m_gpio); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  As you can see, with MRAA it is very simple to use digital I / O.  Interrupt handling is a bit more complicated, but the main thing here is to carefully use the volatile keyword for variables that you work with outside of the interrupt. <br><br><h1>  <font color="#0071c5">4. Using MRAA for Pulse Width Modulation (PWM)</font> </h1><br>  Pulse width modulation (PWM, PWM - Pulse-width modulation) is a type of digital output.  PWM is defined by two parameters, the period and the fill factor: <br><br><ul><li>  the period specifies how often the impulse must be generated; </li><li>  the fill factor indicates which part of the period should be in a high state. </li></ul><br>  For example, if you set the period to 2 ms, and the fill factor is 50%, then you will receive repeated changes: 1 ms the signal will be high and 1 ms low.  Changing the fill factor can be used for various functions, such as controlling the brightness of the LED or the speed of rotation of the motor. <br><br><h2>  <font color="#0071c5">4.1 Basic Terms of Use</font> </h2><br><ul><li>  MRAA offers the ability to configure a digital output for use in PWM mode.  It is important to check your platform to find out which pin can work in this mode.  This may differ on different platforms. <br><br></li><li>  Platforms may vary in the length of the period that is available.  Therefore, it is important to check for errors in calling MRAA functions. <br><br></li><li>  Some devices have requirements for the length of the period that can be used.  For example, a servomotor usually operates with a period of 20 ms. <br><br></li><li>  Header file that must be connected to work with PWM: </li></ul><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa/pwm.h&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#0071c5">4.2.</font>  <font color="#0071c5">An example of working with PWM</font> </h2><br>  In the following example, we will change the brightness of the LED.  We will do this by setting a period of 10 ms and will increase and decrease the fill factor every 100 ms. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA PWM context */</span></span> mraa_pwm_context m_pwm; <span class="hljs-comment"><span class="hljs-comment">/* initialize D3 for use as a digital pin */</span></span> m_pwm = mraa_gpio_init(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* set the period to 10ms */</span></span> mraa_pwm_period_ms(m_pwm, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* set the initial duty cycle to 0 */</span></span> mraa_pwm_write(m_pwm, <span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* enable PWM output */</span></span> mraa_pwm_enable(m_pwm, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* now run in a loop 10 times, dimming or brightening /* /* the LED every 100ms */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> duty = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-comment"><span class="hljs-comment">/* first, start at 0% duty cycle and increase to 100% */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (duty= <span class="hljs-number"><span class="hljs-number">0.0</span></span>; duty &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>; duty+=<span class="hljs-number"><span class="hljs-number">0.1</span></span>) { mraa_pwm_write(m_pwm, duty); usleep(<span class="hljs-number"><span class="hljs-number">100000</span></span>); } sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* now decrease it to 0% */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (duty= <span class="hljs-number"><span class="hljs-number">1.0</span></span>; duty &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span>; duty-=<span class="hljs-number"><span class="hljs-number">0.1</span></span>) { mraa_pwm_write(m_pwm, duty); usleep(<span class="hljs-number"><span class="hljs-number">100000</span></span>); } sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* disable PWM output and clean up */</span></span> mraa_pwm_enable(m_pwm, <span class="hljs-number"><span class="hljs-number">0</span></span>); mraa_pwm_close(m_pwm); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Note the following in this example: <br><br><ul><li>  We used the mraa_pwm_write () function which takes a floating-point value with a value of 0.0 (turned off, or a fill factor of 0%) and 1.0 (turned on, or a fill factor of 100%). <br><br></li><li>  MRAA also provides a set of functions that allow you to directly set the duration of the fill factor, and not as percentages.  This can be useful for devices that have specific requirements for the period and the amount of time that the signal is in the HIGH state, for example, a servomotor. <br><br></li><li>  In MRAA, there are functions for specifying a period in seconds, milliseconds (as in the example above), and microseconds.  MRAA also has a function that allows you to specify a period and a fill factor with one call. <br><br></li><li>  The main problem is to find out if your platform supports the required period.  MRAA will return the corresponding error if this period is not supported. </li></ul><br><h1>  <font color="#0071c5">5. Using MRAA with Inter-Integrated Circuits (I2C)</font> </h1><br>  Using I2C, remember the following: <br><br><ul><li>  I2C is a two-wire bidirectional bus.  It can operate at a frequency of 100 kHz, 400 kHz, 3.4 MHz. <br><br></li><li>  I2C consists of two signal lines - SCL (clocking) and SDA (data). <br><br></li><li>  I2C devices have an address that must be unique on the I2C bus.  Multiple devices can be connected to one bus, but each must have a unique address, and only one of them can be connected at a time. <br><br></li><li>  In addition to the address, I2C devices can have a set of registers (sometimes called commands) into which you can write or read.  Writing and reading these registers enables communication and control. <br><br></li><li>  Header file for working with I2C </li></ul><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa/i2c.h&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#0071c5">5.1 Example of working with I2C</font> </h2><br>  In the following example, we will work with I2C real time clock (DS1307) and read the value from the register of seconds.  We set the I2C MRAA context on the I2C-bus 0, using the address 0x68, and read the second register.  The resulting value will be printed every 10 seconds. <br><br>  It is important to remember that many I2C devices have different requirements, for example, how data should be written or read.  Therefore, the details of the work check in the documentation <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA I2C context */</span></span> mraa_i2c_context m_i2c; <span class="hljs-comment"><span class="hljs-comment">/* initialize I2C on bus 0 */</span></span> m_i2c = mraa_i2c_init(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* now run in a loop 10 times, reading the seconds */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* register and printing it.*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf; <span class="hljs-comment"><span class="hljs-comment">/* always specify the address */</span></span> mraa_i2c_address(m_i2c, <span class="hljs-number"><span class="hljs-number">0x68</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* read in 1 byte. mraa_i2c_read() always reads */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* starting at register 0x00 */</span></span> mraa_i2c_read(m_i2c, &amp;buf, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚ÄúThe seconds returned was: %d\n‚Äù, buf); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } mraa_i2c_stop(m_pwm); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  See the example above: <br><br><ul><li>  We used the mraa_i2c_read () function, which starts reading from register 0x00.  For more flexible use, MRAA offers several more functions for reading and writing to registers.  It is also possible to write and read data width of 16 bits.  The method to use depends on your device and software requirements. <br><br></li><li>  When you read a 16-bit word, you may have to change the byte order if the device has such a requirement. <br><br></li><li>  Some access methods work better on some devices.  For example, the function mraa_i2c_read () functioned incorrectly on one of our proven devices, and it was necessary to use mraa_i2c_read_byte_data ().  Therefore, in the design may require additional experiments. </li></ul><br><h1>  <font color="#0071c5">6. Using MRAA with Universal Asynchronous Receivers / Transmitters (UART)</font> </h1><br><ul><li>  A UART based device is essentially a regular serial device.  Like the devices we connected to the COM port in the past.  This is usually a full duplex connection that operates at a certain speed, measured in baud.  Standard speed for many sensors is 9600 baud (or 9600 bps). <br><br></li><li>  In fact, you have two wires.  TX for transmission and RX for reception.  It should be borne in mind that in the case of most sensors, you will use different voltage levels than those used on a traditional COM port that is compatible with the RS232 standard.  Usually these voltages are 5 V or 3.3 V, while the RS232 COM port uses -15V ... 15V.  Do not connect such a low voltage device directly to the COM port unless it is specifically supported by the manufacturer of the sensor.  So how can you mess up your device. <br><br></li><li>  MRAA offers a mechanism when two pins D0 and D1 (Intel Galileo and Intel Edison) can implement a hardware UART, allowing the program to simply read and write data on a device with UART access.  When MRAA is configured with the correct pins, you can communicate with the device via / dev / ttyX using standard Linux read () and write () functions.  Consider that MRAA only configures the correct routing of the pins for connecting the UART, and your program should open and properly configure the TTY device and start working with it. <br><br></li><li>  Header file for using UART: </li></ul><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mraa/uart.h&gt;</span></span></span></span></code> </pre> <br><h2>  <font color="#0071c5">6.1 UART example</font> </h2><br>  In the following example, we use a fictional UART-based sensor connected to D0 and D1.  It will be denoted by UART 0. <br><br>  It is important that after opening the device the settings that were made automatically by the Linux kernel are correctly changed.  We added a setupTTY () function that performs these actions after opening a TTY device. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> setupTTY(<span class="hljs-type"><span class="hljs-type">int</span></span> fd, speed_t baud) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; struct termios termio; <span class="hljs-comment"><span class="hljs-comment">/* get current modes */</span></span> tcgetattr(fd, &amp;termio); <span class="hljs-comment"><span class="hljs-comment">/* setup for a 'raw' mode. 8bit, 1 stop bit, no parity, */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* no echo or special character handling, */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* no flow control or line editing semantics. */</span></span> cfmakeraw(&amp;termio); // <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> our baud rates cfsetispeed(&amp;termio, baud); cfsetospeed(&amp;termio, baud); // make it so <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tcsetattr(fd, TCSAFLUSH, &amp;termio) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { fprintf(stderr, ‚Äú%s\n‚Äù, ‚Äútcsetattr failed‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* now our main function */</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> main() { <span class="hljs-comment"><span class="hljs-comment">/* initialize MRAA */</span></span> mraa_init(); <span class="hljs-comment"><span class="hljs-comment">/* create an MRAA UART context */</span></span> mraa_uart_context m_uart; <span class="hljs-comment"><span class="hljs-comment">/* initialize UART 0 (pins D0 and D1 used for TX and RX) */</span></span> m_uart = mraa_uart_init(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* now that we have our context, query MRAA */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* to get the file name of the TTY device we need to open. */</span></span> <span class="hljs-type"><span class="hljs-type">char</span></span> *devPath = mraa_uart_get_dev_path(m_uart); <span class="hljs-comment"><span class="hljs-comment">/* if this fails, we can go no further */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!devPath) { fprintf(stderr, ‚Äú%s\n‚Äù, ‚ÄúCould <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> device <span class="hljs-type"><span class="hljs-type">path</span></span>‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* now that we have a device path, open it and set it up */</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> fd; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((fd = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(devPath, O_RDWR)) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { fprintf(stderr, ‚Äú%s\n‚Äù, ‚ÄúCould <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> device <span class="hljs-type"><span class="hljs-type">path</span></span>‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* now we are almost ready, call setupTTY() and from then on */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* we can read/write to the device normally. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* We assume a baud rate of 9600/ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!setupTTY(fd, B9600)) { fprintf(stderr, ‚Äú%s\n‚Äù, ‚ÄúCould <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> setup TTY port‚Äù); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* now we can use standard read and write calls */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* read(fd, ...) or write(fd, ‚Ä¶) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* when we are done, close the device and exit */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>   : <br><br><ul><li>  UART-,    ,   MRAA   ,         Unix ,   read()  write(). <br><br></li><li>  read()  write() ,   .  ,    ,      ,        .        select().   UPM wt5001  .      dataAvailable(). <br><br></li><li>     ,   9600 .  B9600     Linux'.     .         ,   . <br><br></li><li>  setupTTY(),   ,   .        ,      . </li></ul><br><h1> <font color="#0071c5">7. </font> </h1><br>  MRAA        -   Intel Galileo  Intel Edison.  , MRAA      , , , I2C  UART      .          . </div><p>Source: <a href="https://habr.com/ru/post/368079/">https://habr.com/ru/post/368079/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../368069/index.html">Spaceship in the desert: how was the Orion capsule landing?</a></li>
<li><a href="../368071/index.html">DJI Matrice 100 Drone: a friendly quadcopter that can bypass obstacles</a></li>
<li><a href="../368073/index.html">Dell and the United Nations Foundation make the world a better place</a></li>
<li><a href="../368075/index.html">Unofficial expansion of the memory of the iPhone or the Chinese victory over American marketing</a></li>
<li><a href="../368077/index.html">Folk Brand: ZTE New at MWC 2016</a></li>
<li><a href="../368081/index.html">Down with laziness, it's time to train! HLS with mobile applications</a></li>
<li><a href="../368083/index.html">NASA is planning an expedition to Uranus and Neptune</a></li>
<li><a href="../368085/index.html">Friday task for testers</a></li>
<li><a href="../368089/index.html">Service "Yandex.Taxi" earned in Minsk</a></li>
<li><a href="../368091/index.html">Russian cosmonauts do not drink water obtained from the urine of the crew</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>