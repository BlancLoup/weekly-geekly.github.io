<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Best HTTP / 2 prioritization to speed up the web</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="HTTP / 2 promised to speed up the web significantly, and Cloudflare had long since deployed HTTP / 2 access for all clients. But one HTTP / 2 feature,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Best HTTP / 2 prioritization to speed up the web</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57d/5cf/dbe/57d5cfdbe917c7b464a249fb187b3ffd.png"></div><br>  HTTP / 2 promised to speed up the web significantly, and Cloudflare had long since deployed HTTP / 2 access for all clients.  But one HTTP / 2 feature, prioritization, did not meet expectations.  Not because it is fundamentally broken, but because of the implementation in browsers. <br><br>  Today, Cloudflare proposes to change the HTTP / 2 prioritization, which gives our servers control over prioritization decisions that really speed up the Internet. <br><br>  Historically, it is the browser that controls how and when to load web content.  Today, for all paid plans we make radical changes to this model.  They transfer control directly to the site owner.  On the Speed ‚Äã‚Äãtab in the Cloudflare dashboard, clients can turn on Extended HTTP / 2 Prioritization: it overrides the default browser settings for an improved scheduling scheme, which significantly speeds up access for visitors (in some cases we have seen 50% acceleration).  With Cloudflare workers, site owners can go even further and fully customize their settings for their specific needs. <br><a name="habracut"></a><br><h1>  Current situation </h1><br>  Web pages consist of <a href="httparchive.org/t/whats-the-distribution-of-requests-per-page/21/10%3Fu%3Dpatmeenan">dozens (sometimes hundreds) of</a> individual resources that are loaded and collected by the browser into the final displayed content.  This includes visible content with which the user interacts (HTML, CSS, images), as well as application logic (JavaScript) for the site itself, advertising, analytics, and marketing tracking lights.  From the user's point of view, the sequence in which these resources are loaded is very important: it affects the time when he sees the content and can interact with the page. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The browser is, in essence, an HTML processing engine that runs through an HTML document and follows the instructions in order: from beginning to end HTML, building the page as you go.  Links to style sheets (CSS) tell the browser how to style the content of the page, and the browser will delay displaying the content until it loads the style sheet.  Scripts on the page may have different behaviors.  If the script is marked as ‚Äúasynchronous‚Äù or ‚Äúdeferred‚Äù, the browser can continue processing the document and simply run the script when it becomes available.  If the script is not marked as asynchronous or deferred, the browser <a href="https://html.spec.whatwg.org/">MUST</a> stop processing the document until the script loads and runs.  Such scripts are called ‚Äúblocking‚Äù because they block the browser's ability to continue processing the document. <br><br>  HTML document is divided into two parts.  The &lt;head&gt; document header is at the beginning and contains style sheets, scripts, and other browser instructions needed to display the content.  After the title comes the body of the &lt;body&gt; document, it contains the actual content displayed in the browser window (although scripts and style sheets can also be in the body).  Until the browser gets to the body of the document, the user has nothing to show, and the page will remain blank.  Therefore, it is important to process the header as quickly as possible.  If you are interested in the details, on the <i>HTML5 Rocks</i> website there is <a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">an excellent tutorial</a> on how browsers work. <br><br>  The browser is usually responsible for the order of loading the various resources needed to build the page and further processing the document.  In HTTP / 1.x, there are restrictions on how many objects a browser can request from any server at a time (usually 6 connections and only one resource at a time per connection), so the order of requests is strictly controlled by the browser.  In HTTP / 2, the situation is completely different.  The browser can request all resources at once (at least as soon as it becomes aware of them), and provides the server with detailed instructions on how to deliver these resources. <br><br><h1>  Optimum resource loading order </h1><br>  For most parts of the page loading cycle, there is an optimal order that speeds up the accessibility of the page for the user to the maximum (and the difference between the optimal and non-optimal loading order can reach 50% or more). <br><br>  As described above, before the browser can display any content, CSS and JavaScript block it in the <code>&lt;head&gt;</code> section.  At this stage, it is more profitable to use 100% of the channel to download blocking resources, rather than loading them in order, as they are written in the HTML code.  This allows the browser to analyze and launch each element while loading the next blocking resource, which creates an optimal pipeline. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db9/e18/fbe/db9e18fbe00d27755a152a8deabbcaa4.png"><br><br>  Script loading time for parallel or sequential loading is not different, but with sequential loading, the first script can be processed and executed during the loading of the second one. <br><br>  After loading the blocking resources, the situation becomes a bit more interesting.  Here, the optimal load may depend on a particular site or even business priorities (the choice of user content or advertising, or analytics, etc.).  A separate problem with fonts, because the browser detects the necessary fonts after applying the style sheet to the displayed content.  Therefore, by the time the browser learns about the font, it is necessary to display text that is already ready to be displayed on the screen.  Any delays in loading the font lead to a lack of text on the screen (or the text is displayed in the wrong font). <br><br>  As a rule, some compromises need to be taken into account: <br><br><ul><li>  Custom fonts and images in the visible part of the page (viewport) should be loaded as quickly as possible.  They directly affect the user's visual experience when loading the page. <br></li><li>  Non-blocking JavaScript should be loaded sequentially with respect to other JavaScript resources so that the execution of each of them can be put into the pipeline.  JavaScript can include custom application logic, as well as tracking beacons for analytics and marketing, and their delay can lead to a decrease in performance tracked by the business. <br></li><li>  Images can be downloaded in parallel.  The first few bytes of the image file contain its dimensions, which may be necessary for the browser layout, and parallel loading of progressive images can provide visual completeness after transferring approximately only 50% of the total volume. </li></ul><br>  Given the tradeoffs, in most cases, this strategy works well: <br><br><ul><li>  Custom fonts are loaded sequentially and share available bandwidth with images in scope. <br></li><li>  Visible images are loaded in parallel, sharing the part of the bandwidth allocated to them. <br></li><li>  When there are no more fonts or visible images: <br><ul><li>  Non-blocking scripts are loaded sequentially and share the available bandwidth with invisible images (which are out of scope). <br></li><li>  Invisible images are loaded in parallel, dividing the part of the bandwidth allocated to them. </li></ul></li></ul><br>  Thus, the user-visible content is loaded as quickly as possible, the application logic is delayed to a minimum, and invisible images are loaded in such a way as to complete the layout as quickly as possible. <br><br><h1>  Example </h1><br>  To illustrate, we use a simplified product category page from a typical e-commerce site: <br><br><ul><li>  <b>Blue</b> is the HTML file for the page itself. <br></li><li>  <b>Green</b> - One external style sheet (CSS file). <br></li><li>  <b>Orange</b> - Four external scripts (javascript).  Two blocking scripts at the beginning of the page and two asynchronous.  Blocking scripts are shown in a darker shade of orange. <br></li><li>  <b>Red</b> is one custom web font. <br></li><li>  <b>Purple</b> - 13 images.  The preview window displays the page logo and four product images, and another 8 product images require scrolling.  The five visible images are indicated by a darker shade of purple. </li></ul><br>  For simplicity, we assume that all resources are the same size and each is loaded in 1 second.  Downloading all resources takes a total of 20 seconds, but the order and method of loading is extremely important. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fbd/07b/58a/fbd07b58a4c8aeff2a758ad1946d8523.png"><br><br>  Here's what the optimal resource load will look like in a browser: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b2/6a8/2cd/8b26a82cdb5c546e9005200e5528b988.gif"><br><br><ul><li>  The page is empty for the first 4 seconds while loading HTML, CSS and blocking scripts: they all use 100% of the connection. <br></li><li>  At the 4-second mark, the background and page structure are displayed without text or images. <br></li><li>  After a second, at 5 seconds, the page text is displayed. <br></li><li>  In the interval of 5‚àí10 seconds, images are loaded, at first blurry, but very quickly they become clear.  At about 7 seconds, the result is almost indistinguishable from the final version. <br></li><li>  At 10 seconds, the loading of all visual content in the visible part of the page is completed. <br></li><li>  Over the next two seconds, asynchronous JavaScript is loaded and executed, executing any non-critical logic (analytics, marketing tags, etc.). <br></li><li>  In the last 8 seconds, the remaining images are loaded in case the user scrolls the page. </li></ul><br><h1>  Current browser prioritization </h1><br>  All current browser engines implement <a href="http2-prioritization/">different prioritization strategies</a> , none of which is optimal. <br><br>  <b>Microsoft Edge and Internet Explorer</b> <a href="http2-prioritization/">do not support prioritization</a> , so they work with the default HTTP / 2 settings, which loads everything in parallel, evenly distributing bandwidth between all resources.  Microsoft Edge in future versions will switch to the use of the Chromium engine, which can improve the situation.  But for now, in our example, the browser will be stuck in the page header most of the time, as the images slow down the transmission of blocking scripts and style sheets. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e9c/844/a65/e9c844a65472a56d92cb37cd27f2f035.png"><br><br>  Visually, this leads to a rather painful experience: the user looks at the blank screen for 19 seconds, and then there is a delay of 1 second to display the text.  When you are watching the animation below, be patient, because for 19 seconds it may seem that nothing is happening on the empty screen (although it is): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/fae/539/6c9fae539ae1d3c99570cf53af415be4.gif"><br><br>  <b>Safari</b> <a href="http2-prioritization/">loads all resources in parallel</a> , sharing bandwidth based on their importance, according to Safari (blocking resources such as scripts and style sheets are more important than images).  Images are loaded in parallel, but also simultaneously with blocking content. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c75/a7d/f05/c75a7df05716f5706aa4b037774733d2.png"><br><br>  Although Safari is similar to Edge in the sense that everything is loading at the same time, allocating a larger band for blocking resources allows you to display content much earlier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0c/840/5a1/f0c8405a1b6ddc40645ab7985e28a5eb.gif"><br><br><ul><li>  After about 8 seconds, the loading of the stylesheet and scripts is completed, so you can start rendering the page.  Since the images were loaded in parallel, they can also be partially displayed (blurry for progressive images).  This is still two times slower than the optimal scenario, but much better than in the Edge. <br></li><li>  After about 11 seconds, the font is loaded.  You can display the text.  At this point, more data is loaded for the images, and they become a little sharper.  This compares with the situation around the 7-second mark for an optimal loading scenario. <br></li><li>  During the remaining 9 seconds, the images become clearer as more data is loaded, until finally the process is completed in 20 seconds. </li></ul><br>  <b>Firefox</b> creates a dependency tree that groups resources and then plans to either load groups one by one or share bandwidth between groups together.  Within this group, resources share bandwidth and load simultaneously.  Images are planned to be loaded after the style sheets that block rendering, and load in parallel, but scripts and style sheets that block rendering are also loaded in parallel and do not receive the advantages of pipeline processing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/870/e6d/83c/870e6d83c673b9c706dac49c78d3848d.png"><br><br>  In our example, this is a bit faster than in Safari, since the images are waiting for the loading of style sheets: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd2/806/b55/bd2806b55e830bd4c2a7e08bb1b18ce4.gif"><br><br><ul><li>  At 6 seconds, the original content of the page is displayed with the background and blurred versions of the product images (compared to 8 seconds for Safari and 4 seconds in the best case). <br></li><li>  At 8 seconds, the font was loaded, and you can display the text along with a slightly clearer product images (compared to 11 seconds for Safari and 7 seconds in the best case). <br></li><li>  During the remaining 12 seconds, the images become clearer as the remaining content is loaded. </li></ul><br>  <b>Chrome</b> (and all Chromium-based browsers) prioritizes resources by <a href="http2-prioritization/">list</a> .  This works very well for blocking resources that are optimally loaded in order, but not so good for images.  Each image is loaded up to 100% before starting the next one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e22/14d/4e0/e2214d4e04fab810f0a4398fe02434c1.png"><br><br>  In practice, this is almost the optimal loading scenario, with the only difference that images are loaded one at a time, and not in parallel: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/91e/76c/d1d/91e76cd1d814aef138b35345eda46d82.gif"><br><br><ul><li>  Up to 5 seconds, Chrome download is identical to the optimal scenario, displaying the background at 4th second and text content at 5th. <br></li><li>  Over the next 5 seconds, the scopes are loaded one by one until the process finishes at 10 seconds (compared to the optimal scenario, when they are displayed in a slightly blurred form at 7 seconds and become clearer during the remaining three seconds). <br></li><li>  After completion of the visual part of the page in 10 seconds (identical to the optimal script), the remaining 10 seconds are spent on launching asynchronous scripts and loading hidden images (as in the optimal script). </li></ul><br><h1>  Visual comparison </h1><br>  The visual difference is quite different, although technically downloading the entire content takes the same time: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62e/2a1/d5f/62e2a1d5f10b801af61992517d7f5a5a.gif"><br><br><h1>  Server side prioritization </h1><br>  HTTP / 2 prioritization is requested by the client (browser), and the server must decide what to do based on the request.  <a href="http2-prioritization-issues">A large number of servers do not support this feature at all</a> , and the rest fulfill the client's request.  Another option is to decide on the best server-side prioritization based on the client‚Äôs request. <br><br>  According to the <a href="http2-spec/">specification</a> , HTTP / 2 prioritization is a dependency tree that requires full knowledge of all current requests in order to be able to prioritize resources relative to each other.  This allows you to implement incredibly complex strategies, but this is difficult to implement well on the browser or server side (as evidenced by various browser strategies and different levels of server support).  To simplify prioritization management, we have developed a simpler scheme that still has all the flexibility necessary for optimal planning. <br><br>  The Cloudflare prioritization scheme consists of 64 priority ‚Äúlevels‚Äù, and within each level there are groups of resources that determine how to divide the connection between them: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ba5/7e5/efa/ba57e5efa56119a58bbd39596da3f9ce.png"><br><br>  First, all resources are downloaded at a higher priority level, then a transition to a lower level occurs. <br><br>  Within a given priority level, there are three different concurrency groups: <br><br><ul><li>  <b>0</b> : all resources in the ‚Äú0‚Äù group are sent sequentially in the order in which they were requested, using 100% bandwidth.  Only after loading all the resources of the ‚Äú0‚Äù group are other groups considered at the same level. <br></li><li>  <b>1</b> : all resources in concurrency group ‚Äú1‚Äù are sent sequentially in the order in which they were requested.  The available bandwidth is evenly distributed between parallelism group ‚Äú1‚Äù and parallelism group ‚Äún‚Äù. <br></li><li>  <b>n</b> : resources in parallel group ‚Äún‚Äù are transferred in parallel, sharing the available bandwidth. </li></ul><br>  In practice, the concurrency group ‚Äú0‚Äù is useful for critical content that needs to be processed sequentially (scripts, CSS, etc.).  Group ‚Äú1‚Äù is useful for less important content that can share bandwidth with other resources, but where the resources themselves still benefit from sequential processing (asynchronous scripts, non-progressive images, etc.).  The concurrency group ‚Äún‚Äù is useful for resources that benefit from parallel processing (progressive images, video, audio, etc.). <br><br><h1>  Default Cloudflare Prioritization </h1><br>  The extended prioritization option implements the ‚Äúoptimal‚Äù resource loading order described above.  The specific priorities used are as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b89/e96/e4f/b89e96e4f4534f5df00d732e97b5db62.png"><br><br>  This scheme allows you to sequentially send resources that block rendering, then send visible images in parallel, and then the rest of the page content with some level of strip sharing to balance the load between the application and the content.  The <i>caution * If Detectable</i> is that not all browsers distinguish between different types of style sheets and scripts, but it will still be much faster in all cases.  Acceleration by 50%, especially for visitors of Edge and Safari, will not be something unusual: <br><br> <a href=""><img src="https://habrastorage.org/webt/u_/1n/px/u_1npxrzhg0svmgdyzelnamxj84.png"></a> <br><br><h1>  Setting up prioritization with workers </h1><br>  Faster defaults are great, but things get really interesting thanks to the ability to customize prioritization with Cloudflare Workers support, so sites can redefine the default priority for resources or implement their own prioritization schemes. <br><br>  If the worker adds a <code>cf-priority</code> header to the response, the Cloudflare edge servers will apply the specified priority and concurrency.  The header format is &lt;priority&gt; / &lt;concurrency&gt;, so the header is <code>response.headers.set('cf-priority', ‚Äú30/0‚Äù);</code>  sets the answer to priority 30 and parallelism 0. Similarly, ‚Äú30/1‚Äù sets parallelism to ‚Äú1‚Äù, and ‚Äú30 / n‚Äù sets parallelism to n. <br><br>  With such flexibility, the site can customize arbitrary priority resources for their needs.  For example, to increase the priority of some important asynchronous scripts or main images: they are downloaded before the browser has determined that they are in sight. <br><br>  To inform about ranitization prioritization decisions, the workers also indicate the browser-requested prioritization information in the request object that is passed to the worker‚Äôs event receiver (request.cf.requestPriority).  Incoming priorities are a list of attributes separated by semicolons.  It looks like this: <code>weight=192;exclusive=0;group=3;group-weight=127</code> . <br><br><ul><li>  <b>weight</b> : weight to prioritize HTTP / 2. <br></li><li>  <b>exclusive</b> : exclusive HTTP / 2 flag (1 for Chromium based browsers, 0 for others). <br></li><li>  <b>group</b> : HTTP / 2 stream identifier for the request group (non-zero for Firefox). <br></li><li>  <b>group-weight</b> : HTTP / 2 weight for the request group (non-zero for Firefox). </li></ul><br><h1>  This is just the beginning. </h1><br>  The ability to customize and control the priority of responses is a basic building block for a lot of future work.  We intend to implement our own advanced optimization on top of this, but with the support of workers, all sites and researchers can experiment with different prioritization strategies.  Through the Apps Marketplace, companies can also create new optimization services on top of the working platform and share them with other sites. <br><br>  If you are on a Pro plan or higher, go to the Speed ‚Äã‚Äãtab in the Cloudflare dashboard and turn on HTTP / 2 Extended Prioritization to speed up your site. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/386/d53/276/386d532767b6396ee628a7e0eb837282.png"></div><p>Source: <a href="https://habr.com/ru/post/452020/">https://habr.com/ru/post/452020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../452006/index.html">Epic's metauniverse: why Fortnite authors should have it all</a></li>
<li><a href="../452008/index.html">Engineering approaches and checklists: how not to go crazy in the chaos of tasks</a></li>
<li><a href="../45201/index.html">Pro geek and automation - continued</a></li>
<li><a href="../452010/index.html">Osmo Action: the first action camera from DJI</a></li>
<li><a href="../452016/index.html">12 years in the cloud</a></li>
<li><a href="../452026/index.html">20 years ago, Microsoft forever changed the way we use the mouse.</a></li>
<li><a href="../452028/index.html">A ray of light in a dark kingdom: how technology returns lost sight</a></li>
<li><a href="../45203/index.html">Work with SVN branches</a></li>
<li><a href="../452030/index.html">Computer history: discovering interactivity</a></li>
<li><a href="../452034/index.html">Self-control of time for self-education and time for reading books</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>