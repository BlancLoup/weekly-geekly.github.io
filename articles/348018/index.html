<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Even in Java 9, ArrayList can still (and should) be improved.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think most javistes would agree that java.util.ArrayList is the most used collection in the Java world. It appeared in version 1.2 and quickly becam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Even in Java 9, ArrayList can still (and should) be improved.</h1><div class="post__text post__text-html js-mediator-article"><p> I think most javistes would agree that <code>java.util.ArrayList</code> is the most used collection in the Java world.  It appeared in version 1.2 and quickly became the ‚Äúdefault collection‚Äù, because in most cases its capabilities are enough for everyday work.  Many changes have been made to this class (see, for example, the <a href="">change history in the JDK 8 repository</a> ) to make it as productive as possible.  In this note, I will show that even such a pumped-up component as <code>ArrayList</code> still holds room for improvement. </p><a name="habracut"></a><br><p>  Suppose we need to convert part of a list into an array.  To do this, we describe the method: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T[] toSubArray(ArrayList&lt;T&gt; list, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list .subList(from, to) .toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br><p>  Let's estimate its performance in comparison with conversion to an array of the source list: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@Fork</span></span>(jvmArgsAppend = {<span class="hljs-string"><span class="hljs-string">"-XX:+UseParallelGC"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xms1g"</span></span>, <span class="hljs-string"><span class="hljs-string">"-Xmx1g"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubListToArrayBenchmark</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * baseline */</span></span> <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer[] list(Data data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.list.toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Integer[] subList(Data data) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data.list.subList(<span class="hljs-number"><span class="hljs-number">0</span></span>, data.size).toArray(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ ArrayList&lt;Integer&gt; list; <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({<span class="hljs-string"><span class="hljs-string">"0"</span></span>, <span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-string"><span class="hljs-string">"100"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ list = IntStream .range(<span class="hljs-number"><span class="hljs-number">0</span></span>, size) .boxed() .collect(toCollection(ArrayList::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>)); } } }</code> </pre> <br><p>  After completing the measurements, we find that the performance of the <code>subList()</code> method is significantly inferior to that of the baseline: </p><br><table><thead><tr><th>  Benchmark </th><th>  size </th><th>  Score </th><th>  Error </th><th>  Unit </th></tr></thead><tbody><tr><td>  list </td><td>  0 </td><td>  <strong>7.2</strong> </td><td>  0.1 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  0 </td><td>  <strong>12.8</strong> </td><td>  0.2 </td><td>  ns / op </td></tr><tr><td>  list </td><td>  ten </td><td>  <strong>34.6</strong> </td><td>  3.9 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  ten </td><td>  <strong>44.7</strong> </td><td>  1.0 </td><td>  ns / op </td></tr><tr><td>  list </td><td>  100 </td><td>  <strong>141.9</strong> </td><td>  2.2 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  100 </td><td>  <strong>252.1</strong> </td><td>  4.9 </td><td>  ns / op </td></tr><tr><td>  list </td><td>  1000 </td><td>  <strong>1201.6</strong> </td><td>  21.0 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  1000 </td><td>  <strong>2310.4</strong> </td><td>  53.0 </td><td>  ns / op </td></tr></tbody></table><br><p>  Given the fact that in both cases an equal amount of data moves, the significant difference looks surprising. </p><br><p>  The answer lies in the class of <code>ArrayList</code> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cloneable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">io</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... public Object[] toArray() { return Arrays.copyOf(elementData, size); } public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; } //... }</span></span></code> </pre> <br><p>  Both methods directly access the array using <code>Arrays.copyOf()</code> and <code>System.arraycopy()</code> to move the data.  Let's look inside: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arrays</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @HotSpotIntrinsicCandidate // since Java 9 public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) { @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } //... }</span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">System</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @HotSpotIntrinsicCandidate // since Java 9 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); //... }</span></span></code> </pre> <br><p>  These methods are marked as <code>@HotSpotIntrinsicCandidate</code> , which allows <code>@HotSpotIntrinsicCandidate</code> <del>  create high-performance machine code for them </del>  to substitute their implementation with high-performance machine code to achieve the best performance. </p><br><p>  Now let's turn to the <code>subList()</code> method: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;E&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fromIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> toIndex)</span></span></span><span class="hljs-function"> </span></span>{ subListRangeCheck(fromIndex, toIndex, size); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubList&lt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, fromIndex, toIndex); }</code> </pre> <br><p>  As you can see, <code>ArrayList</code> has its own implementation of this method, and (more importantly) its own implementation of the list part view: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ArrayList&lt;E&gt; root; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SubList&lt;E&gt; parent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Now the main thing: although <code>SubList</code> marked as <code>RandomAccess</code> and has a direct access to the array through the <code>root</code> field, <strong>it does not have its own implementation</strong> of the <code>toArray()</code> and <code>toArray(T[])</code> methods.  And if so, then the <strong>inherited methods</strong> of the <code>AbstractCollection</code> class <strong>are used</strong> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] toArray() { <span class="hljs-comment"><span class="hljs-comment">// Estimate size of array; be prepared to see more or fewer elements Object[] r = new Object[size()]; Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) { if (! it.hasNext()) // fewer elements than expected return Arrays.copyOf(r, i); r[i] = it.next(); } return it.hasNext() ? finishToArray(r, it) : r; } public &lt;T&gt; T[] toArray(T[] a) { // Estimate size of array; be prepared to see more or fewer elements int size = size(); T[] r = a.length &gt;= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator&lt;E&gt; it = iterator(); for (int i = 0; i &lt; r.length; i++) { if (! it.hasNext()) { // fewer elements than expected if (a == r) { r[i] = null; // null-terminate } else if (a.length &lt; i) { return Arrays.copyOf(r, i); } else { System.arraycopy(r, 0, a, 0, i); if (a.length &gt; i) { a[i] = null; } } return a; } r[i] = (T)it.next(); } // more elements than expected return it.hasNext() ? finishToArray(r, it) : r; }</span></span></code> </pre> <br><p>  Here, the array is filled in a loop using an iterator, and this works slower than transferring data with <code>Arrays.copyOf()</code> and <code>System.arraycopy()</code> .  It follows that to improve performance, we need to override <code>toArray()</code> and <code>toArray(T[])</code> and use the same approach as <code>ArrayList</code> .  Let's add: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ArrayList&lt;E&gt; root; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> SubList&lt;E&gt; parent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-comment"><span class="hljs-comment">//... @Override public Object[] toArray() { return Arrays.copyOfRange(root.elementData, offset, offset + size); } @Override public &lt;T&gt; T[] toArray(T[] a) { if (a.length &lt; size) return (T[]) Arrays.copyOfRange(root.elementData, offset, offset + size, a.getClass()); System.arraycopy(root.elementData, offset, a, 0, size); if (a.length &gt; size) a[size] = null; return a; } //... }</span></span></code> </pre> <br><p>  Have we done everything right?  Not!  The methods we override do not take into account the likelihood that the source list can be changed after the call to the <code>subList()</code> method.  We must take this opportunity into account.  Therefore, we add a check to the beginning of each of the overridden methods: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Object[] toArray() { checkForComodification(); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- return Arrays.copyOfRange(root.elementData, offset, offset + size); } @Override public &lt;T&gt; T[] toArray(T[] a) { checkForComodification(); // &lt;-- if (a.length &lt; size) return (T[]) Arrays.copyOfRange(root.elementData, offset, offset + size, a.getClass()); System.arraycopy(root.elementData, offset, a, 0, size); if (a.length &gt; size) a[size] = null; return a; }</span></span></code> </pre> <br><p>  <code>subList()</code> benchmark with a modified <code>ArrayList</code> , we find out that now the performance of the <code>subList()</code> method is only slightly lower than that of the baseline.  A slight lag is due to the creation of a sublist and calling <code>checkForComodification()</code> at the beginning of the <code>toArray(T[])</code> method. </p><br><table><thead><tr><th>  Benchmark </th><th>  size </th><th>  Score </th><th>  Error </th><th>  Unit </th></tr></thead><tbody><tr><td>  list </td><td>  0 </td><td>  <strong>7.2</strong> </td><td>  0.1 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  0 </td><td>  <strong>7.5</strong> </td><td>  0.2 </td><td>  ns / op </td></tr><tr><td>  list </td><td>  ten </td><td>  <strong>24.5</strong> </td><td>  0.5 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  ten </td><td>  <strong>25.4</strong> </td><td>  0.6 </td><td>  ns / op </td></tr><tr><td>  list </td><td>  100 </td><td>  <strong>142.8</strong> </td><td>  4.5 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  100 </td><td>  <strong>141.6</strong> </td><td>  2.5 </td><td>  ns / op </td></tr><tr><td>  list </td><td>  1000 </td><td>  <strong>1243.6</strong> </td><td>  28.5 </td><td>  ns / op </td></tr><tr><td>  subList </td><td>  1000 </td><td>  <strong>1247.8</strong> </td><td>  23.7 </td><td>  ns / op </td></tr></tbody></table><br><p>  <strong>The bottom line:</strong> <br>  <a href="https://bugs.openjdk.java.net/browse/JDK-8196207">Ticket and link to patch</a> (most likely to close in Java 11) </p><br><p>  <strong>What to read:</strong> <br>  <a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/">A long, complex and extremely useful article about black witchcraft in the pool of VM</a> </p><br><p>  <strong>The original correspondence on the topic notes:</strong> <a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2018-January/051102.html">is here</a> </p><br><h4 id="vyvody">  findings </h4><br><ul><li>  even painfully familiar classes can hide flaws </li><li>  abstract collections are written to cover as many cases as possible and offer generalized algorithms, therefore, when creating a specific implementation, it is often possible to write more efficient code, tailored to the peculiarities of your data structure </li><li>  to make changes it is not necessary to be an employee of Orakla;  if you have a patch that fixes a proven mistake or introduces a tangible improvement, it will be accepted for consideration </li><li>  look more often at the platform code: javist can never know too much about the JDK </li></ul><br><p>  <strong>PS</strong> Ticket closed, changes poured. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348018/">https://habr.com/ru/post/348018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348008/index.html">We are friends of gRPC with a long-lived project, PHP and front-end</a></li>
<li><a href="../348010/index.html">False alarms. New technique of catching two birds with one stone. Part 2</a></li>
<li><a href="../348012/index.html">As I measured the quality of technical support work</a></li>
<li><a href="../348014/index.html">Blockchain: features, structure, EDS and task for a student, part 1</a></li>
<li><a href="../348016/index.html">And so it will come down ... or the Hole as a means of protection</a></li>
<li><a href="../348020/index.html">Blockchain: Networking, Signature Verification and Student Assignment, Part 2</a></li>
<li><a href="../348022/index.html">Game development under NES in C. Chapters 1-3. From introduction to Hello World</a></li>
<li><a href="../348024/index.html">SecurityWeek 2: army of clones, Google hunts for ghosts, Blizzard patches</a></li>
<li><a href="../348026/index.html">Installing Linux without .ISO and virtualization</a></li>
<li><a href="../348028/index.html">Convolutional neural network, part 2: training in the error back-propagation algorithm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>