<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monolith for hundreds of client versions: how we write and support tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 I am a backend developer on the Badoo server team. At last year's HighLoad conference, I gave a presentation , the text version of which I w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monolith for hundreds of client versions: how we write and support tests</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/tz/sv/jv/tzsvjvswjax_rsrd3fjcriulb-8.jpeg"><br><br>  Hello! <br><br>  I am a backend developer on the Badoo server team.  At last year's HighLoad conference, I <a href="https://www.youtube.com/watch%3Fv%3DANWOHxaXj9g">gave a presentation</a> , the text version of which I want to share with you.  This post will be most useful to those who independently write tests for the backend and have problems with testing legacy-code, as well as those who want to test complex business logic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What are we talking about?  First, I will briefly talk about our development process and how it affects our need for tests and the desire to write these tests.  Then we will go up through the pyramid of test automation, discuss the types of tests we use, talk about the tools inside each of them and what problems we solve with their help.  In the end we will look at how to support and run all this stuff. <br><a name="habracut"></a><br><h2>  Our development process </h2><br>  We illustrated our development process: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/er/hv/jr/erhvjrnkf7zncdxhlgjusogzmyk.png" width="600"></div><br>  A golfer is a backend developer.  At some point, a development task arrives, usually in the form of two documents: requirements from the business side and a technical document describing changes in our protocol for interaction between the backend and clients (mobile applications and the site). <br><br>  The developer writes the code and launches it into operation, and before all client applications.  All functionality is protected by some feature flags or A / B tests, this is written in the technical document.  After that, in accordance with current priorities and product roadmap, client applications are released.  For us, backend developers, it is completely unpredictable when this or that feature will be implemented on clients.  The release cycle of client applications is somewhat more complicated and longer than ours, so our product managers literally juggle with priorities. <br><br>  The development culture adopted by the company is of great importance: the backend developer is responsible for the feature from the moment it is implemented on the backend to the last integration on the last platform on which it was originally planned to implement this feature. <br><br>  The situation is quite possible: six months ago you rolled out some feature, the client teams didn‚Äôt implement it for a long time, because the company‚Äôs priorities have changed, you are already busy working on other tasks, you have new deadlines, priorities - and here you are resorted to by colleagues and they say: ‚ÄúDo you remember this thing that you wrote down six months ago?  It does not work".  And instead of engaging in new tasks, you extinguish fires. <br><br><img src="https://habrastorage.org/files/e22/ebe/15c/e22ebe15c2174a4d99ebf0da46fbe950.gif" width="600"><br><br>  Therefore, our developers have a motivation unusual for PHP programmers to make it so that the problems at the integration stage arise as little as possible. <br><br>  What do you want to do first of all to make sure that the feature works? <br><br>  Of course, the first thing that comes to mind is to conduct manual testing.  You take the application in your hands, but it does not know how - after all, the feature is new, customers will take care of it in six months.  Well, manual testing does not give any guarantee that during the time that passes from the moment the backend is released before the integration begins, no one will break anything on the clients. <br><br>  And here automatic tests come to our aid. <br><br><h2>  Unit tests </h2><br>  The simplest tests we write are unit tests.  We use PHP as the main language for the backend and PHPUnit as the unit testing framework.  Looking ahead, I will say that all our backend tests are written on the basis of this framework. <br><br>  Unit tests we most often cover some small isolated pieces of code, check the performance of methods or functions, that is, we are talking about tiny units of business logic.  Our unit tests should not interact with anything, turn to databases or services. <br><br><h3>  Softmocks </h3><br>  The main difficulty faced by developers when writing unit tests is untestable code, and usually this is legacy code. <br><br>  A simple example.  Badoo was 12 years old; once it was a very small startup that was developed by several people.  The startup quite successfully existed without any tests at all.  Then we became big enough and realized that it was impossible to live without tests.  But by this time a lot of code was written that worked.  Do not rewrite it just for the sake of test coverage!  It would not be very reasonable from a business point of view. <br><br>  Therefore, we have developed a small <a href="https://github.com/badoo/soft-mocks">open source library SoftMocks</a> , which makes our test writing process cheaper and faster.  It intercepts all include / require PHP files and on the fly replaces the original file with modified content, that is, with rewritten code.  This allows us to create stubs for any code.  <a href="https://habr.com/company/badoo/blog/279617/">Here is a</a> detailed description of how the library functions. <br><br>  Something like this for the developer: <br><br><pre><code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//mock  \Badoo\SoftMocks::redefineConstant($constantName, $newValue); //mock  : , ,  \Badoo\SoftMocks::redefineMethod( $class, $method, $method_args, $fake_code ); //mock  \Badoo\SoftMocks::redefineFunction( $function, $function_args, $fake_code );</span></span></code> </pre> <br>  With the help of such simple constructions we can globally redefine everything we want.  Including they allow us to bypass the limitations of the standard PHPUnit mocker.  That is, we can mock static and private methods, override constants and do much more, which is not possible in regular PHPUnit. <br><br>  However, we ran into a problem: it seems to developers that with SoftMocks, there is no need to write test code - you can always ‚Äúbrush‚Äù the code with our global mocks, and everything will work fine.  But this approach leads to more complex code and the accumulation of "crutches".  Therefore, we have adopted several rules that allow us to keep the situation under control: <br><br><ol><li>  All new code should be easily tested with standard PHPUnit mocks.  If this condition is met, then the code is tested and you can easily select a small piece and test only it. <br></li><li>  SoftMocks can be used with old code that is not written in an appropriate way for unit-testing, as well as in cases when it is too expensive / long / difficult to do otherwise (underline). <br></li></ol><br>  Compliance with these rules is carefully monitored during the code review phase. <br><br><h3>  Mutation Testing </h3><br>  Separately, I want to say about the quality of unit tests.  I think that many of you use such metrics as the percentage of coverage (code coverage).  But she, unfortunately, does not answer one question: ‚ÄúHave I written a good unit test?‚Äù.  It is possible that you wrote such a test, which actually does not check anything, does not contain a single assert, but it generates an excellent code coverage.  Of course, the example is exaggerated, but the situation is not so far from reality. <br><br>  Recently, we began to introduce mutational testing.  This is a rather old, but not very well-known concept.  The algorithm for such testing is quite simple: <br><br><ul><li>  we take the code and code coverage; <br></li><li>  Parsing and starting to change the code: true to false,&gt; to&gt; =, + to - (in general, harm in every way); <br></li><li>  for each such change-mutation we run test suites that cover the modified string; <br></li><li>  if the tests have dropped, then they are good and really do not allow us to break the code; <br></li><li>  if the tests have passed, most likely, they are not sufficiently effective, despite the coverage, and it may be worth looking at them more carefully, throwing some assertions (or there is an area not covered with dough). <br></li></ul><br>  For PHP, there are several ready-made frameworks, such as Humbug and Infection.  Unfortunately, they did not suit us, because they are incompatible with SoftMocks.  Therefore, we wrote our small console utility that does the same thing, but uses our internal code coverage format and is friends with SoftMocks.  Now the developer runs it manually and analyzes the tests written by him, but we are working on the implementation of the tool in our development process. <br><br><h2>  Integration testing </h2><br>  With the help of integration tests, we check the interaction with various services and databases. <br><br>  To further story was more understandable, let's develop a fictional promo and cover it with tests.  Imagine that our product managers decided to distribute conference tickets to our most loyal users: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/72/us/3f/72us3fyuuclhm8c1erh3qk42yra.png" width="300"></div><br>  A promo should be shown if: <br><br><ul><li>  the user in the field "Work" indicated "programmer", <br></li><li>  the user participates in the HL18_promo A / V test, <br></li><li>  user is registered more than two years ago. <br></li></ul><br>  By clicking on the button "Get a ticket" we must save the data of this user to some list in order to transfer to our managers who distribute tickets. <br><br>  Even in this rather simple example, there is a thing that cannot be verified using unit tests, interaction with a database.  To do this, we need to use integration tests. <br><br>  Consider the standard way to test database interaction offered by PHPUnit: <br><br><ol><li>  Raise the test database. <br></li><li>  Prepare DataTables and DataSets. <br></li><li>  Run the test. <br></li><li>  Clearing the test database. <br></li></ol><br>  What difficulties await us with this approach? <br><br><ul><li>  You need to support the structures DataTables and DataSets.  If we change the scheme of the table, then it is necessary to reflect these changes in the test, which is not always convenient and requires additional time. <br></li><li>  It takes time to prepare the database.  Every time we set up a test, we need to fill something in there, create some kind of tables, which is long and troublesome if there are a lot of tests. <br></li><li>  And the most important drawback: the parallel launch of such tests makes them unstable.  We started the test A, he began to write in the test table, which he created himself.  At the same time, we launched test B, which wants to work with the same test table.  As a result, interlocks and other unforeseen situations arise. <br></li></ul><br>  To avoid these problems, we developed our own small DBMocks library. <br><br><h3>  DBMocks </h3><br>  The principle of operation is as follows: <br><br><ol><li>  With the help of SoftMocks, we intercept all the wrappers through which we work with databases. <br></li><li>  When <br>  the query passes through the mock, parses the SQL query, and pulls out the DB + TableName from it, and from the connection we get the host. <br></li><li>  On the same host in tmpfs, we create a temporary table with the same structure as the original (copy the structure with SHOW CREATE TABLE). <br></li><li>  After that, all requests that will be received via mocks to this table will be redirected to the newly created temporary one. <br></li></ol><br>  What gives us this: <br><br><ul><li>  no need to constantly take care of the structures; <br></li><li>  tests can no longer damage the data in the source tables, because we will redirect them to temporary tables on the fly; <br></li><li>  we are still testing compatibility with the version of MySQL we work with, and if the request suddenly ceases to be compatible with the new version, then our test will see it and fall. <br></li><li>  and most importantly, the tests are now isolated, and even if we run them in parallel, the threads will diverge according to different temporary tables, since we add a unique key for each test to the names of the test tables. <br></li></ul><br><h2>  API testing </h2><br>  The difference between unit and API tests is well illustrated by this gif: <br><br><img src="https://habrastorage.org/webt/ho/zb/me/hozbmexeumir1wdsjsgnlobh5xs.gif"><br>  <i>The lock works fine, but here it is attached to the wrong door.</i> <br><br>  Our tests imitate the client session, are able to send requests to the backend, following our protocol, and the backend answers them as a real client. <br><br><h3>  Test user pool </h3><br>  What do we need to successfully write such tests?  Let's return to the conditions of our promo: <br><br><ul><li>  the user in the field "Work" indicated "programmer", <br></li><li>  the user participates in the HL18_promo A / V test, <br></li><li>  user is registered more than two years ago. <br></li></ul><br>  As you can see, everything is about the user.  And in reality, 99% of API tests require an authorized registered user, which is present in all services and databases. <br><br>  Where to get it?  You can try to register it at the time of testing, but: <br><br><ul><li>  it is long and resource intensive; <br></li><li>  after the completion of the test, this user needs to somehow be removed, which is quite a non-trivial task if we are talking about large projects; <br></li><li>  Finally, as in many other high-load projects, we perform many operations in the background (adding a user to various services, replicating to other data centers, etc.);  tests do not know anything about such processes, but if they implicitly rely on the results of their implementation, there is a risk of instability. <br></li></ul><br><br>  We have developed a tool called the Test Users Pool.  It is based on two ideas: <br><br><ol><li>  We do not register users every time, but use them repeatedly. <br></li><li>  After the test, reset the user data to the original state (at the time of registration).  If this is not done, the tests will eventually become unstable, because users will be ‚Äúcontaminated‚Äù with information from other tests. <br></li></ol><br><br>  It works like this: <br><br><img src="https://habrastorage.org/webt/yg/db/p5/ygdbp5rwmfrbd2ssyiejb3bp8fs.png"><br><br>  At some point, we wanted to run our API tests in a production environment.  Why do we even want this?  Because the devel infrastructure is not the same as production. <br><br>  Although we are trying to constantly repeat the production-infrastructure in a reduced size, devel will never be its full copy.  To be absolutely sure that the new build meets expectations and there are no problems, we post the new code on the preproduction cluster, which works with production-data and services, and we run our API tests there. <br><br>  In this case, it is very important to think about how to isolate test users from real ones. <br><br><div class="spoiler">  <b class="spoiler_title">What happens if test users start to appear real in our application.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/io/wg/gkiowghhl3b4hzazgj9u5e_wf4s.gif" width="300"></div><br></div></div><br>  How to make insulation?  Each of our users has an <code>is_test_user</code> flag.  At the registration stage, it becomes <code>yes</code> or <code>no</code> , and no longer changes.  By this flag, we isolate users in all services.  It is also important that we exclude test users from business intelligence and A / V testing results in order not to distort the statistics. <br><br>  It is possible to go in a simpler way: we started by saying that all test users were ‚Äúresettled‚Äù to Antarctica.  If you have a geoservice, this is quite a working method. <br><br><h3>  QA API </h3><br>  We do not just need a user - we need him with certain parameters: to work as a programmer, participate in a particular A / V test, and was registered more than two years ago.  We can easily assign a profession to test users using our backend API, but getting into A / B tests is probabilistic.  And the registration condition more than two years ago is generally difficult to fulfill, because we do not know when the user appeared in the pool. <br><br>  To solve these problems, we have a QA API.  This is, in essence, a backdoor for testing, which is a well-documented API-methods that allow you to quickly and easily manage user data and change their state, bypassing the main protocol of our communication with customers.  Methods write backend developers for QA engineers and for use in UI and API tests. <br><br>  QA API can be used only in the case of test users: if there is no corresponding flag, the test will immediately fall.  Here is one of our QA API methods that allows you to change the date of user registration to an arbitrary one: <br><br><img src="https://habrastorage.org/webt/gw/mf/ws/gwmfwsbej3rtmytvaxdoxbzrvaa.png"><br><br>  And there will be three calls that will allow you to quickly change the data of the test user so that they satisfy the conditions for displaying promo: <br><br><ul><li>  In the field "Work" is indicated "programmer": <br> <code>addUserWorkEducation?user_id=ID&amp;works[]=Badoo, <br> </code> <br> </li><li>  The user participates in the A / B test HL18_promo: <br> <code>forceSplitTest?user_id=ID&amp;test=HL18_promo</code> <br> </li><li>  Registered more than two years ago: <br> <code>userCreatedChange?user_id=ID&amp;created=2016-09-01</code> <br> </li></ul><br><br>  Since this is a backdoor, it is extremely important to think about security.  We protected our service in several ways: <br><br><ul><li>  isolated at the network level: services can only be accessed from the office network; <br></li><li>  with each request, we pass the secret, without which it is impossible to access the QA API even from the office network; <br></li><li>  methods work only with test users. <br></li></ul><br><br><h3>  Remotemocks </h3><br>  To work with a remote API test backend, we may need mocks.  For what?  For example, if the API test in a production environment starts to access the database, we need to make sure that the data in it is cleared from the test data.  In addition, mock'i ‚Äã‚Äãhelp make the answer of the test more suitable for testing. <br><br>  We have three texts: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jo/66/dc/jo66dczs4sbrfuzaohyqy7izy6e.png" width="300"></div><br><br>  Badoo is a multilingual application, we have a complex localization component that allows you to quickly translate and receive translations for the current location of the user.  Our localizers are constantly working to improve translations, conduct A / B tests with tokens, looking for more successful formulations.  And, conducting the test, we can not know what text will be returned by the server - it can change at any time.  But we can use RemoteMocks to check whether the localization component is correctly addressed. <br><br>  How do RemoteMocks work?  The test asks the backend to initialize them for their session, and when all subsequent requests are received, the backend checks for the presence of mocks for the current session.  If they are, it simply initializes them using SoftMocks. <br><br>  If we want to create a remote mock, then we indicate which class or method should be replaced and by what.  All subsequent requests to the backend will be executed with this mock in mind: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;remoteInterceptMethod( \Promo\HighLoadConference::class, <span class="hljs-string"><span class="hljs-string">'saveUserEmailToDb'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> );</code> </pre><br>  Well, now let's build our API test: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//       $app_startup = [ 'supported_promo_blocks' =&gt; [\Mobile\Proto\Enum\PromoBlockType::GENERIC_PROMO] ]; $Client = $this-&gt;getLoginedConnection(BmaFunctionalConfig::USER_TYPE_NEW, $app_startup); //  $Client-&gt;getQaApiClient()-&gt;addUserWorkEducation(['Badoo, ']); $Client-&gt;getQaApiClient()-&gt;forceSplitTest('HL18_promo'); $Client-&gt;getQaApiClient()-&gt;userCreatedChange('2016-09-01'); //     $this-&gt;remoteInterceptMethod(\Promo\HighLoadConference::class, 'saveUserEmail', true); //,   ,   $Resp = $Client-&gt;ServerGetPromoBlocks([]); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_NEXT_PROMO_BLOCKS')); $PromoBlock = $Resp-&gt;CLIENT_NEXT_PROMO_BLOCKS; ‚Ä¶ //   CTA, ,   ,   $Resp = $Client-&gt;ServerPromoAccepted($PromoBlock-&gt;getPromoId()); $this-&gt;assertTrue($Resp-&gt;hasMessageType('CLIENT_ACKNOWLEDGE_COMMAND'));</span></span></code> </pre><br><br>  In this simple way we can test any functionality that comes to the development in the backend and requires changes in the mobile protocol. <br><br><h3>  API test usage rules </h3><br>  It seems to be all right, but we again encountered a problem: API tests turned out to be too convenient for development and there was a temptation to use them everywhere.  As a result, once we realized that we were starting to solve with the help of API tests, tasks for which they were not designed. <br><br>  Why is that bad?  Because API tests are very slow.  They go around the network, refer to the backend, which raises the session, goes to the database and a bunch of services.  Therefore, we have developed a set of rules for the use of API tests: <br><ul><li>  the purpose of the API tests is to check the protocol of interaction between the client and the server, as well as the correctness of the integration of the new code; <br><br></li><li>  it is permissible to cover complex processes with them, for example, chains of actions; <br></li><li>  it is impossible to test with them using small variability of the server response - this is the task of the unit tests; <br></li><li>  during the code review we check including the tests. <br></li></ul><br><h2>  UI tests </h2><br>  Since we are considering the automation pyramid, I‚Äôll tell you a little about UI tests. <br><br>  Back-end developers in Badoo do not write UI tests - for this we have a special team in the QA department.  We cover the feature with UI-tests when it has already been brought to mind and stabilized, because we believe that it is unwise to spend resources on a fairly expensive feature automation, which, perhaps, will not go further than the A / B test. <br><br>  For mobile autotests, we use Calabash, and for the web, Selenium.  <a href="https://youtu.be/N0hYSHmRJTQ">It</a> tells about our platform for automation and testing. <br><br><h2>  Test run </h2><br>  We now have 100,000 unit tests, 6,000 integration tests and 14,000 API tests.  If you try to run them into one stream, then even on the most powerful of our machines, a full run takes all: modular - 40 minutes, integration - 90 minutes, API tests - ten hours.  This is too long. <br><br><h3>  Parallelization </h3><br>  <i>We described our experience in parallelizing unit tests <a href="https://habr.com/ru/company/badoo/blog/181488/">in this article</a> .</i> <br><br>  The first solution, which seems obvious, is to run tests in several threads.  But we went further and made a cloud for parallel launch in order to be able to scale hardware resources.  Simplified his work looks like this: <br><br><img src="https://habrastorage.org/webt/2q/s8/v7/2qs8v7eoyhw_-e3iv-igmt_xui0.png"><br><br>  The most interesting task here is the distribution of tests between threads, that is, their breakdown into chunks. <br><br>  You can share them equally, but all the tests are different, so there may be a strong bias in the execution time of a thread: all threads have already reached, and one hangs for half an hour, as he is ‚Äúlucky‚Äù with very slow tests. <br><br>  You can run multiple threads and "feed" them tests one by one.  In this case, the disadvantage is less obvious: the initialization of the environment has overhead costs, which, with a large number of tests and this approach, begin to play an important role. <br><br>  What did we do?  We began to collect statistics on the run time of each test, and then began to assemble chunks so that one stream according to the statistics was executed for no longer than 30 seconds.  At the same time, we rather tightly pack tests into chunks to make them smaller. <br><br>  However, our approach also has a flaw.  It is associated with API tests: they are very slow and take up a lot of resources, preventing fast tests from running. <br><br>  Therefore, we have divided the cloud into two parts: in the first, only fast tests are run, and in the second, both fast and slow tests can be launched.  With this approach, we always have a piece of cloud that is able to handle quick tests. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6z/py/0n/6zpy0n5tqvqmqjsf7huyqiu5ogo.png" width="600"></div><br><br>  As a result, unit tests were run in a minute, integration tests - in five minutes, and API tests - in 15 minutes.  That is, a full run instead of 12 hours takes no more than 22 minutes. <br><br><h3>  Test run based on code coverage </h3><br>  We have a large complex monolith, and, in an amicable way, we need to constantly chase all the tests, because a change in one place may break something in another.  This is one of the main drawbacks of monolithic architecture. <br><br>  At some point we came to the conclusion that you do not need to run all the tests every time - you can do runs based on code coverage: <br><br><ol><li>  We take our branch diff. <br></li><li>  We form the list of changed files. <br></li><li>  For each file we get a list of tests, <br>  which cover it. <br></li><li>  From these tests we create a set and run it in a test cloud. <br></li></ol><br>  Where to get coverage?  We collect data once a day when the development environment infrastructure is idle.  The number of tests to be run has noticeably decreased, the speed of receiving feedback from them, on the contrary, has increased significantly.  Profit! <br><br>  An added bonus was the ability to run tests for patches.  Despite the fact that Badoo has not been a start-up for a long time, we can still quickly implement changes to production, quickly pour out a hot fix, roll out features, change the configuration.  As a rule, the speed of rolling out patches is very important to us.  The new approach gave a big increase in the speed of feedback from the tests, because now we don‚Äôt have to wait long for the complete run. <br><br>  But without flaws anywhere.       ,       ,   ,       .        .     ,  code coverage        . ,   , ‚Äî  ,  -        ,     .     . <br><br>         API-,      code coverage.         ,   ,    .       - ,  API-         . <br><br><h2>  Conclusion </h2><br><ul><li>       ,       .    - , , -    . <br></li><li>   ‚â† .    code review    ,   . <br></li><li>       , ,     .         . <br></li><li>   .              . <br></li><li> ,    !     ,         . <br></li></ul><br><br><blockquote> <b> ,    <a href="https://habr.com/ru/company/badoo/blog/441052/">Badoo PHP Meetup 16 </a> .         PHP-.    ,   .   ! <a href="https://www.youtube.com/badootech">  12:00,  ‚Äî   YouTube-</a></b> . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/443768/">https://habr.com/ru/post/443768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443754/index.html">About the feasibility of Selenium WebDriverWait</a></li>
<li><a href="../443756/index.html">Design classes: what is good?</a></li>
<li><a href="../443762/index.html">Using inheritance when generating web pages in pure javascript</a></li>
<li><a href="../443764/index.html">What the designer smoked: an unusual firearm</a></li>
<li><a href="../443766/index.html">We try contract programming With ++ 20 already now</a></li>
<li><a href="../443770/index.html">Domain Driven Design: Value Objects and Entity Framework Core in practice</a></li>
<li><a href="../443772/index.html">Antiquities: IBM ThinkPad T40, the first wireless</a></li>
<li><a href="../443776/index.html">China introduces experimental face recognition system when paying for subway fares</a></li>
<li><a href="../443782/index.html">Developers can now use Valve's Network API for their games on Steam</a></li>
<li><a href="../443790/index.html">Survivor error</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>