<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Robot Loader Project: Determine Your Own Location</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="My long-time British partner (it was for him two years ago that ‚ÄúRecognition of postal addresses‚Äù was written) had a new idea to optimize business pro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Robot Loader Project: Determine Your Own Location</h1><div class="post__text post__text-html js-mediator-article">  My long-time British partner (it was for him two years ago that <a href="http://habrahabr.ru/post/106207/">‚ÄúRecognition of postal addresses‚Äù</a> was written) had a new idea to optimize business processes: robots had to carry boxes around the warehouse, and the loaders only to shift goods from the robot to the shelf and back.  The point, naturally, is not to have a loader on each heel, and take up loading and unloading as soon as the robot stops - but that there are much more robots than movers and that robots most of the time were at the end point of their route, waiting for loading.  Then the loader will only move from one robot to the next, loading each one, and will not spend working time carrying the goods. <br><br><h2>  Prehistory </h2><br><img src="https://habrastorage.org/storage2/a7a/b02/dd0/a7ab02dd047de152724798f11f2668e9.jpg" align="right">  Last year, we experimented with the Roomba self-propelled vacuum cleaner platform.  A new vacuum cleaner cost us around ¬£ 300 (a used one can be found for ¬£ 100 and even cheaper), and it consists of two electric drives for wheels, two touch sensors in front, an infrared sensor at the bottom (for detecting steps) and at the top (for searching for the station) .  The exact list of sensors depends on the model: the protocol provides for up to four infrared sensors from the bottom, each of which returns one bit (‚Äúthe floor is visible / not visible‚Äù).  In any case, no range finders: all available sensors are one-bit.  In addition, there are no ‚Äúprogrammable arduins‚Äù in Roomba, and in order to control it, you need to install a laptop (or arduin) on top and communicate with the robot via RS-232.  Having played enough with a vacuum cleaner, we left it gathering dust on one of the shelves of the warehouse. <br><br><img src="https://habrastorage.org/storage2/11b/af2/279/11baf2279338db7d717784ac71c46d84.jpg" align="right">  This year we decided to try <a href="http://www.microsoft.com/robotics/">Microsoft Robotics Development Studio (MRDS)</a> , to promote which Microsoft formulated the <a href="http://msdn.microsoft.com/en-us/library/hh418576.aspx">‚ÄúMRDS Reference Platform‚Äù</a> specification - a set of equipment and a control protocol for a ‚Äústandard‚Äù robot.  This specification would allow robots to create compatible robots and transfer programs between them.  Compared with the hardware of the vacuum cleaner, the Reference Platform is much more complicated and powerful: Kinect is included in the specification, three IR rangefinders and two ultrasonic, and also wheel rotation sensors (encoders).  The implementation of the MRDS RP is currently offered only by the company Parallax called <a href="http://www.parallax.com/eddie">Eddie</a> (about ¬£ 1000, not including Kinect).  The extraordinary similarity of Eddie with the photos of the prototype robot in the MRDS RP specification suggests that the specification was created in close cooperation with Parallax, in other words, Parallax managed to achieve that Microsoft took their platform as a reference. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In addition to the variety of sensors, the Eddie has a mechanically impressive platform (declared load capacity of 20kg, and the power of the motors is enough to push the warehouse loader ahead of itself) and the programmable Parallax Propeller controller, i.e.  Critical pieces of code can be sewn directly into the robot, and not just command it from a computer. <br><a name="habracut"></a><br><img src="https://habrastorage.org/storage2/a0b/c9a/40c/a0bc9a40ca1bf3a0dc44b00c1873eea9.jpg" align="right">  The British Channel 4 included a two-minute piece with the Eddie demo integrated into a shopping cart in <a href="http://www.channel4.com/programmes/stephen-fry-gadget-man/4od">one of the releases of</a> the Gadget Man program.  Unfortunately, only the owners of British IP addresses can view the program on Channel 4, and I did not manage to grab it and reload it (maybe someone of the readers will succeed?) - therefore I bring only freeze-frames from there. <br><br><img src="https://habrastorage.org/storage2/fb0/cc6/7de/fb0cc67def140f83f0f4f181dc2a9d16.jpg"><br><br><h2>  Task </h2><br>  Just control the robot "forward-back-left-right" - nothing tricky, and the program of such "remote control" is included directly in the delivery of Eddie.  But there is no one to steer the loader robots: each of them must himself be aware of where he is at the warehouse, and make his way to the next point.  It is with this definition of the position that the main problem arose.  GPS-like technologies are swept away: the signal from the satellites does not pass through the roof of the warehouse.  Kinect is good at gesture recognition, but how do they recognize storage shelves?  On the shelves themselves, unique barcodes every meter are already glued, but first, they are not read reliably ‚Äúon the move‚Äù of the robot and at a distance of 20 cm from the shelves (you cannot get closer - there is a risk of crashing into the support or into a box projecting from the shelf).  Secondly, in order to drive up to the shelf at a distance of 20 cm and read the barcode, one already needs to understand the current position - otherwise the robot, which has moved aside from the shelves, loses its orientation completely and irreparably. <br><br><img src="https://habrastorage.org/storage2/f4c/fbf/baa/f4cfbfbaa389235af319b388190a2f0b.jpg" align="right">  The first navigation attempt was based on rangefinders: the robot ‚Äúgropes‚Äù the shelf and travels along it, maintaining a predetermined distance, just as the tottering drinker walks, leaning against the wall through the step.  The similarity was really huge: the delay in receiving the signal from the range finders, processing them in the MRDS, forming a command for the motors, and overcoming their inertia - amounted to tenths of a second.  During this time, the robot ‚Äúled away‚Äù to the side, so that the ‚Äúcourse correction‚Äù each time was tens of degrees, and the trajectory was obtained in a wide zigzag.  In addition to this, the Eddie rangefinders were not too accurate - the error was up to ¬± 5 cm - and rather narrowly focused, i.e.  the shelves were recognized only on one, in advance of a given height from the floor. <br><br>  Navigation through wheel sensors turned out to be more promising, giving each wheel mileage with an accuracy of about ¬± 7 mm.  Eddie's firmware has already included the calculation of the ‚Äúrobot run‚Äù (half the sum of the runs of both wheels) and the ‚Äúrobot directions‚Äù (difference between the runs of the wheels, with the normalizing factor), but the current coordinates (x, y) cannot be calculated from only the values ‚Äã‚Äãof the two counters.  It is necessary to break the trajectory of the robot into small simple sections, and summarize the movement in each section.  At first glance, I want to bring the path of the robot broken line;  but in reality, ‚Äúat rest‚Äù - at a constant speed of the motors - the robot will move along an arc of a circle: the larger the radius, the smaller the difference between the speeds of the motors.  On the contrary, the breakpoint, when the robot changes direction, not moving from the place, in reality there is not and can not be.  Therefore, we will approximate the trajectory of the robot with a sequence of arcs. <br><br><h2>  Calculations </h2><br>  It all started with a drawing on a napkin deep at night, when it suddenly dawned on me: <br><br><img src="https://habrastorage.org/storage2/b5d/086/45c/b5d08645c49225119f272c4a0b422680.jpg"><br><br>  At the beginning of the arc, the robot was at point <i>A</i> (known), at the end it turned out to be at point <i>B</i> (unknown), while the left wheel traveled a known path <i>S</i> <sub>1</sub> = <i>œÜr</i> <sub>1</sub> , and the right wheel traveled a known path <i>S</i> <sub>2</sub> = <i>œÜr</i> <sub>2</sub> .  The distance <i>w</i> between the tracks is constant, and is determined by the construction of the robot.  We get: <br>  <i>r</i> <sub>2</sub> / <i>r</i> <sub>1</sub> = <i>S</i> <sub>2</sub> / <i>S</i> <sub>1</sub> and <i>r</i> <sub>2</sub> = <i>r</i> <sub>1</sub> + <i>w</i> , whence <br>  ( <i>r</i> <sub>1</sub> + <i>w</i> ) / <i>r</i> <sub>1</sub> = <i>S</i> <sub>2</sub> / <i>S</i> <sub>1</sub> <br>  <i>r</i> <sub>1</sub> <i>S</i> <sub>1</sub> + <i>wS</i> <sub>1</sub> = <i>r</i> <sub>1</sub> <i>S</i> <sub>2</sub> <br>  <i>r</i> <sub>1</sub> = <i>wS</i> <sub>1</sub> / ( <i>S</i> <sub>2</sub> - <i>S</i> <sub>1</sub> ) <br><br>  Hence, the angle at which the robot turned, <i>œÜ</i> = <i>S</i> <sub>1</sub> / <i>r</i> <sub>1</sub> = ( <i>S</i> <sub>2</sub> - <i>S</i> <sub>1</sub> ) / <i>w</i> , and the distance |  <i>AB</i> |  = 2 |  <i>AM</i> |  = 2 ( <i>r</i> <sub>1</sub> + <i>w</i> / 2) sin ( <i>œÜ</i> / 2) = (2 <i>wS</i> <sub>1</sub> / ( <i>S</i> <sub>2</sub> - <i>S</i> <sub>1</sub> ) + <i>w</i> ) sin ( <i>œÜ</i> / 2) = <i>w</i> ¬∑ sin ( <i>œÜ</i> / 2) ( <i>S</i> <sub>2</sub> + <i>S</i> <sub>1</sub> ) / ( <i>S</i> <sub>2</sub> - <i>S</i> <sub>1</sub> ) <br><br>  Here, by and large, and all the mathematics to determine the position: each time we add the calculated <i>œÜ</i> to the angle of the direction of the robot, and we shift the current coordinates by distance |  <i>AB</i> |.  The question remains practical: how often to perform such updates of the position?  If too often, we will be confronted with the inaccuracy of the wheel sensors measuring the mileage with discrete ‚Äúticks‚Äù.  If it is too rare, then the approximation of a path segment by a circular arc will not be accurate enough. <br><br>  I decided that the wheel sensor reading is most accurate at the moment of ‚Äútick‚Äù, so I recalculate the position of the robot for each tick of any wheel - but not more often than the poll time of the robot, recorded somewhere around 80ms;  and at least once a second, so that the stopped wheel (for example, when turning) is also recorded.  All registered ‚Äúticks‚Äù are saved to the list, since to recalculate a position I need the mileage of both wheels for the same period of time.  We take the gap from <i>the earlier</i> of the previous ‚Äúticks‚Äù with both wheels, and linearly interpolate the run of the second wheel at the same moment using the ‚Äútick list‚Äù.  For the end of the gap - in the same way, we take the mileage read by the sensor for the ‚Äúticked‚Äù wheel, and linearly extrapolate the mileage of the second one.  Thus, the accuracy should be the maximum achievable. <br><br>  Every time the position of the robot is recalculated, you need to re-set the wheel speeds in order to direct the robot to its intended target.  It is unrealistic to direct the robot exactly to the desired ‚Äúazimuth‚Äù, rotating in place: the said wheel mileage error of ¬± 7mm turns into an error of several degrees when turning the robot, i.e.  the robot will still go "obliquely", and it will have to turn again on the road.  Therefore, if the direction to the target is not very different from the current one, I decided to send the robot to the target along an arc, without prior ‚Äúazimuth guidance‚Äù.  (If the current direction differs from the desired one by more than <i>œÄ</i> / 2, then such an arc will be greater than the semicircle, which is clearly impractical. In this case, the robot can do nothing but rotate in the right direction.) <br><br>  To calculate the arc, go back to the drawing above.  Now we know the points <i>A</i> and <i>B</i> , and therefore, the angle <i>œÜ</i> ;  you need to find the ratio <i>S</i> <sub>2</sub> / <i>S</i> <sub>1</sub> = <i>r</i> <sub>2</sub> / <i>r</i> <sub>1</sub> : it will set the ratio of wheel speeds, necessary for our arc.  Repeat the above calculation in the opposite direction: <br>  |  <i>AB</i> |  = 2 |  <i>AM</i> |  = 2 ( <i>r</i> <sub>1</sub> + <i>w</i> / 2) sin ( <i>œÜ</i> / 2) <br>  <i>r</i> <sub>1</sub> = |  <i>AB</i> |  / (2sin ( <i>œÜ</i> / 2)) - <i>w</i> / 2 <br>  <i>r</i> <sub>2</sub> = |  <i>AB</i> |  / (2sin ( <i>œÜ</i> / 2)) + <i>w</i> / 2 <br>  <i>r</i> <sub>2</sub> / <i>r</i> <sub>1</sub> = 1 + <i>w</i> / (| <i>AB</i> | / (2sin ( <i>œÜ</i> / 2)) - <i>w</i> / 2) = 1 + 2 / (| <i>AB</i> | / ( <i>w</i> ¬∑ sin ( <i>œÜ</i> / 2)) - 1 ) <br><br>  How far will such an arc lead us away from the straight line <i>AB</i> ?  If a robot needs two meters of free space on its sides to complete the arc, then in our warehouse there is simply no such possibility: the width of the aisles between the shelves is only one and a half meters. <br><br><img src="https://habrastorage.org/storage2/604/a3e/902/604a3e90270e241bd2fd9185409093a3.jpg"><br><br>  Calculate the distance |  <i>MH</i> |  between arc and straight: |  <i>OH</i> | - |  <i>OM</i> |  = <i>r</i> - <i>r</i> ¬∑ cos ( <i>œÜ</i> / 2) = ( <i>r</i> <sub>1</sub> + <i>w</i> / 2) (1 - cos ( <i>œÜ</i> / 2)) <br><br>  If the magnitude of this "hump" exceeds the specified limit, then we refuse to move in an arc, and, rotating in place, will try to turn closer towards the target. <br><br>  As it turned out, in reality, the ratio of the voltages on the motors does not yet determine the ratio of the wheel speeds.  It would be possible to select the correct transformation between them, but I solved the problem by ‚Äúbrute force‚Äù: I restored the ratio to the 9th degree, i.e.  the slightest deviation to one of the sides immediately pushes the robot in the opposite direction.  In fact, it was with this exponent that the movement of the robot became truly smooth: with smaller degrees, it deviated very strongly to the side, and returned to the correct route only at the target itself;  with large - the correction turned out to be too strong, and the robot was ‚Äúwound‚Äù from side to side by a narrow zigzag. <br><br><h2>  Implementation </h2><br>  I conceived to add new functionality to the MarkRobot service from the ReferencePlatform2011 delivery: implement a new portset in the spirit of <code>PositionOperations : PortSet&lt;GetPosition, SetPosition, SetDestination&gt;</code> , and so that the service itself, transparently for the user, polls the wheel sensors and exposes the voltage on the motors.  In fact, it did not come to this realization - only a muddy prototype was ready without sharing the responsibilities between the services.  I will try, nevertheless, to show that I did it. <br><br>  First you need something to work with coordinates: it‚Äôs not to be stored in <code>System.Drawing.PointF</code> . <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x, y, heading; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Position</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heading</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y = y; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.heading = heading; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sqr</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d * d; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DistanceTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Sqrt(Sqr(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.y - y) + Sqr(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x - x)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NormalizeHeading</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> heading</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (heading &lt; -Math.PI) heading += <span class="hljs-number"><span class="hljs-number">2</span></span> * Math.PI; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (heading &gt; Math.PI) heading -= <span class="hljs-number"><span class="hljs-number">2</span></span> * Math.PI; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> heading; } <span class="hljs-comment"><span class="hljs-comment">// turn angle/2, go ahead distance, turn angle/2 again public Position advance(double distance, double angle) { double newHeading = heading + angle / 2, newX = x + distance * Math.Cos(newHeading), newY = y + distance * Math.Sin(newHeading); return new Position(newX, newY, NormalizeHeading(heading + angle)); } }</span></span></code> </pre><br>  The <code>advance</code> method implements the recalculation of coordinates by a given angle of rotation <i>œÜ</i> and the distance covered |  <i>AB</i> |, as in the drawing in the middle of the article. <br><br>  (Only now, by copying the code here, I noticed that I had exactly the ‚Äúdouble angle formula‚Äù, and that instead of shifting to | <i>AB</i> | at an angle of <i>œÜ</i> / 2, I could move to <i>r</i> <sub>1</sub> + <i>w</i> / 2 at an angle of <i>œÜ</i> . Well come on.) <br><br>  Further, the service contains within itself a copy of <code>PositionKeeping</code> , within which there are two instances of <code>EncoderLog</code> - the ‚Äú <code>EncoderLog</code> list‚Äù, a separate copy for each wheel.  The list is <code>SortedList</code> in <code>SortedList</code> , because (theoretically) sensor data may not arrive in chronological order.  The only non-trivial method in <code>EncoderLog</code> is linear approximation of the run to get its value at any time between ‚Äúticks‚Äù or after the last ‚Äútick‚Äù. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PositionKeeping</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> readonly DateTime initialized = DateTime.Now; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EncoderLog</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SortedList&lt;DateTime, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SortedList&lt;DateTime, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; { { initialized, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DateTime at, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reading)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>[at] = reading; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DateTime at, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> reading)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Clear(); <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Add(at, reading); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime LastTick { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Last().Key; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> LastReading { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Last().Value; }} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadingAt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DateTime at)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(index&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Keys[index] &gt; at) index--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(index&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>.NaN; <span class="hljs-comment"><span class="hljs-comment">// before first reading; impossible // now, log.Keys[index] &lt;= at, and log.Keys[index+1] &gt; at DateTime preceding = log.Keys[index], following = index&lt;log.Count-1 ? log.Keys[index+1] : DateTime.MaxValue; if(following == DateTime.MaxValue) { // last reading precedes at; extrapolate if(index==0) // there's only one reading return log[preceding]; else { DateTime nextPreceding = log.Keys[index-1]; return log[nextPreceding] + (at-nextPreceding).TotalSeconds * (log[preceding]-log[nextPreceding]) / (preceding-nextPreceding).TotalSeconds; } } else // both readings are available; interpolate return log[preceding] + (at-preceding).TotalSeconds * (log[following]-log[preceding]) / (following - preceding).TotalSeconds; } } public EncoderLog leftEnc = new EncoderLog(), rightEnc = new EncoderLog();</span></span></code> </pre><br>  In addition to ‚Äútick lists‚Äù, <i>a position list</i> should be stored in <code>PositionKeeping</code> at the time of each ‚Äútick‚Äù - we will measure the distance traveled from this saved position in order to get a new position. <br><pre> <code class="hljs pgsql"> private SortedList&lt;DateTime, Position&gt; position = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SortedList&lt;DateTime, Position&gt; { { initialized, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Position(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span>) } }; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Register(DateTime at, Position pos) { position.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(at, pos); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(DateTime at, Position pos) { // the position has changed =&gt; <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> ticks logs become obsolete leftEnc.<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(at, leftEnc.ReadingAt(at)); rightEnc.<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(at, rightEnc.ReadingAt(at)); position.Clear(); position.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(at, pos); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Position <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> position.Last().<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>; } }</code> </pre><br>  It remains to supplement the <code>PositionKeeping</code> class by calculating the new position using the data of both wheel sensors - in accordance with the formulas derived.  <code>Update</code> can be called from the sensor check cycle ( <code>ServiceHandlerBehavior.Concurrent</code> ), and takes the service port argument, where it sends new coordinates if a tick is registered.  This message changes the state of the service, so it should be treated as <code>ServiceHandlerBehavior.Exclusive</code> . <br><pre> <code class="hljs pgsql"> private static readonly TimeSpan RegisterDelay = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>); // register <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>-tick <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> actual ticks <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> this long <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Update</span></span>(DateTime at, <span class="hljs-type"><span class="hljs-type">double</span></span> left, <span class="hljs-type"><span class="hljs-type">double</span></span> right, PositionOperations mainPort) { DateTime prevRef = Min(leftEnc.LastTick, rightEnc.LastTick); SetPosition <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> SetPosition { <span class="hljs-type"><span class="hljs-type">Timestamp</span></span> = at, LeftEncUpdated = left != leftEnc.LastReading || at &gt; leftEnc.LastTick + RegisterDelay, LeftEncReading = left, RightEncUpdated = right != rightEnc.LastReading || at &gt; rightEnc.LastTick + RegisterDelay, RightEncReading = right }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.LeftEncUpdated || <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.RightEncUpdated) { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Position = Recalculate(prevRef, left, right); mainPort.Post(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>); } } private Position Recalculate(DateTime prevRef, <span class="hljs-type"><span class="hljs-type">double</span></span> left, <span class="hljs-type"><span class="hljs-type">double</span></span> right) { <span class="hljs-type"><span class="hljs-type">double</span></span> sLeft = left - leftEnc.ReadingAt(prevRef), sRight = right - rightEnc.ReadingAt(prevRef); Position refPos = position[prevRef]; // has <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> exist <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> the encoder reference <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(sRight - sLeft) &lt; <span class="hljs-number"><span class="hljs-number">.5</span></span>) // less <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> half-tick difference: go straight <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> refPos.advance(Constants.CmPerTick * (sRight + sLeft) / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">double</span></span> angle = Constants.CmPerTick * (sRight - sLeft) / Constants.WheelsDist, distance = Constants.WheelsDist * Math.Sin(angle / <span class="hljs-number"><span class="hljs-number">2</span></span>) * (sRight + sLeft) / (sRight - sLeft); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> refPos.advance(distance, angle); } } }</code> </pre><br>  All that remains in the code of interest is the <code>SetPosition</code> handler, which sets the voltage on the motors so that the robot moves toward the target. <br><pre> <code class="hljs pgsql">[ServiceHandler(ServiceHandlerBehavior.<span class="hljs-keyword"><span class="hljs-keyword">Exclusive</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> SetPositionHandler(SetPosition <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.LeftEncUpdated &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.RightEncUpdated) { // position updated <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> an absolute reference. positionKeeping.<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Timestamp, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Position); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.LeftEncUpdated) positionKeeping.leftEnc.Register(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Timestamp, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.LeftEncReading); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.RightEncUpdated) positionKeeping.rightEnc.Register(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Timestamp, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.RightEncReading); positionKeeping.Register(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Timestamp, <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Position); } // the navigator Destination dest = state.dest; <span class="hljs-type"><span class="hljs-type">double</span></span> distance = <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Position.DistanceTo(dest.x, dest.y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) // reached { drivePort.SetDrivePower(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); SendNotification(submgrPort, <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> DriveDistance()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-type"><span class="hljs-type">double</span></span> heading = Position.NormalizeHeading(Math.Atan2(dest.y - <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Position.y, dest.x - <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>.Position.x)), power = (distance &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>) ? <span class="hljs-number"><span class="hljs-number">.2</span></span> : <span class="hljs-number"><span class="hljs-number">.4</span></span>; // a few magic numbers <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(heading) &lt; <span class="hljs-number"><span class="hljs-number">.05</span></span>) { // straight ahead drivePort.SetDrivePower(power, power); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-type"><span class="hljs-type">double</span></span> r = distance / (<span class="hljs-number"><span class="hljs-number">2</span></span> * Math.Sin(heading / <span class="hljs-number"><span class="hljs-number">2</span></span>)), hump = r * (<span class="hljs-number"><span class="hljs-number">1</span></span> - Math.Cos(heading / <span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(heading) &gt; Math.PI / <span class="hljs-number"><span class="hljs-number">2</span></span> || Math.Abs(hump) &gt; Constants.MaxHump) { // <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> an arc; rotate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heading &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) // rotate left drivePort.SetDrivePower(<span class="hljs-number"><span class="hljs-number">-.3</span></span>, <span class="hljs-number"><span class="hljs-number">.3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> // rotate right drivePort.SetDrivePower(<span class="hljs-number"><span class="hljs-number">.3</span></span>, <span class="hljs-number"><span class="hljs-number">-.3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // go <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> arc <span class="hljs-type"><span class="hljs-type">double</span></span> rLeft = Math.Abs(r - Constants.WheelsDist / <span class="hljs-number"><span class="hljs-number">2</span></span>), rRight = Math.Abs(r + Constants.WheelsDist / <span class="hljs-number"><span class="hljs-number">2</span></span>), rMax = Math.Max(rLeft, rRight); // &lt;Patrician|Away&gt; what does your robot <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>, sam // &lt;bovril&gt; it collects data about the surrounding environment, <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> discards it <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> drives <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> walls drivePort.SetDrivePower(power * Math.Pow(rLeft / rMax, <span class="hljs-number"><span class="hljs-number">9</span></span>), power * Math.Pow(rRight / rMax, <span class="hljs-number"><span class="hljs-number">9</span></span>)); } }</code> </pre><br><br><h2>  What's next? </h2><br>  This robot drove pretty well, but the problem arose due to accumulating errors.  To correct the coordinates, it was enough to read successfully at least 20% of the <code>SetPosition</code> , and ‚Äúrestart‚Äù <code>PositionKeeping</code> calling <code>SetPosition</code> with <code>LeftEncUpdated = RightEncUpdated = false</code> .  For a few meters between the readable barcodes, the error in determining the coordinates did not exceed 20 cm - just as much we left in reserve between the robot and the shelves. <br><br>  Much worse was the case with the error of direction (heading), because we could not correct the direction: the barcode can be read from any angle (and thank God).  The accumulated direction error of several degrees is already enough for the robot to go astray and drive in from the full swing into the regiment.  A frontal solution would be to install a gyroscope;  but there is no ready-made gyro for Eddie, and I would like to avoid the mysteries with a soldering iron and writing firmware. <br><br>  Correction of direction without a gyroscope and other exotic sensors, I am going to devote the following article. </div><p>Source: <a href="https://habr.com/ru/post/161803/">https://habr.com/ru/post/161803/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../161783/index.html">Free distance education</a></li>
<li><a href="../161785/index.html">Dart + WebGL do cookies on the dark side taste good?</a></li>
<li><a href="../161787/index.html">Amazon SQS vs RabbitMQ</a></li>
<li><a href="../161793/index.html">‚ÄúIT Infrastructure Under Control‚Äù: Web Conferencing Records Out</a></li>
<li><a href="../161801/index.html">Pre-holiday discount on IM + Pro</a></li>
<li><a href="../161805/index.html">Drawing a snowman in PowerShell</a></li>
<li><a href="../161813/index.html">XAircraft x650 and aerial photography</a></li>
<li><a href="../161815/index.html">And one more release: Qt 5.0 RC</a></li>
<li><a href="../161819/index.html">Crimson Marketing</a></li>
<li><a href="../161823/index.html">The digest of interesting news and materials from the world of ayti for the last week ‚Ññ34 (December 1 - 7, 2012)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>