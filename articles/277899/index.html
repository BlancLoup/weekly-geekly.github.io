<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Article about microcontroller EFM32ZG110F32</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It just so happened that we had quite a lot of EFM32ZG110F32 microcontrollers in stock, this is a Zero Gecko series from SiLabs. The controllers are c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Article about microcontroller EFM32ZG110F32</h1><div class="post__text post__text-html js-mediator-article">  It just so happened that we had quite a lot of EFM32ZG110F32 microcontrollers in stock, this is a Zero Gecko series from SiLabs.  The controllers are cool, but not very popular yet, that's why I'm writing this article. <br><br><img src="https://habrastorage.org/files/a3c/9db/ede/a3c9dbede8774fb295db6d20671c3c33.png" align="right"><br>  As an advertisement, we offer the following set: ARM Cortex-M0 +, 32 Kbytes of Flash, 4 Kbytes of RAM, DMA, I2C, UART, USART, 12-bit ADC, current DAC, comparator, hardware pulse counter, real time clock and various pieces to reduce power consumption in the QFN-24 package <b>for $ 0.96</b> . <br>  <font color="gray"><i>upd: yes, it is possible by the piece</i></font> <br><br>  Under the cut a long post with a detailed overview of the crystal and the debug board, a description of the available programming and debugging tools.  Examples of working with various peripheral crystal blocks are given, proprietary development tools and the mbed platform from ARM are used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Hardware overview </h4><hr><br>  EFM32 is a 32-bit microcontroller based on ARM Cortex-M processor cores.  Their main feature is the support of a variety of software and hardware technologies to optimize power consumption, but at the same time a standard set of peripheral devices is also provided. <br><br>  The hero of this article - the EFM32ZG110F32 microcontroller - belongs to the youngest series of the EFM32 family, it is called the EFM32 Zero Gecko.  These are the simplest and cheapest controllers under the EFM32 brand, they are built on the basis of the Cortex-M0 + core and differ in the set of supported peripherals and enclosures.  The fact that represents the EFM32ZG110F32, the easiest way to judge by this scheme. <br><br><img src="https://habrastorage.org/files/54b/ecf/798/54becf798e0b44778ddc37309a5d6d1f.png"><br><br>  The color for each block indicates the power consumption mode, up to which the block can be used: <br><ul><li>  EM0 - active mode, the manufacturer claimed power consumption - 114 ŒºA / MHz </li><li>  EM1 - mode with disabled processor core, the declared power consumption is 48 ŒºA / MHz <br>  <i>Modern low-power microcontrollers generally support autonomous peripheral technologies.</i>  <i>Each manufacturer calls them differently; for EFM32, the technology of peripheral interaction without the participation of the processor core is called Peripheral Reflex System (PRS).</i>  <i>With the use of PRS and DMA, you can organize quite complex crystal scenarios.</i>  <i>For example, such: on the overflow of the timer, conversion is performed on the ADC, the conversion results via DMA are recorded in RAM;</i>  <i>these actions are repeated twenty times and only after saving twenty results an interrupt is generated, through which the processor core wakes up and the processing of the received data begins.</i> </li><li>  EM2 is a mode in which high-frequency clock is turned off and only low-frequency and asynchronous peripheral modules remain available.  Power consumption declared by the manufacturer - 0.9 ¬µA <br>  <i>Most often, it is the EM2 that is used as a sleep mode.</i>  <i>In contrast to the EM1, this mode allows you to provide long-term power from the battery, but with the support of DMA, serial interface, I2C, pulse counter, comparator and other units, allowing to detect events and exchange data with third-party devices.</i> <br></li><li>  EM3 is a mode in which not only high-frequency, but also low-frequency clock generators are turned off.  Accordingly, LEUART, real time clock and DMA become unavailable.  The EM3 power consumption declared by the manufacturer is 0.5 ¬µA. <br></li><li>  In EM4 mode, the microcontroller is actually turned off and consumes about 20 nA.  Exit from such a ‚Äúdeep hibernation‚Äù is possible only by reset, which, however, can be generated not only from the reset line, but also from another I / O line that has been pre-configured accordingly. <br></li></ul><br><br>  In order to evaluate the described microcontroller, it is most convenient to use a debug board and in this article the possibilities of the crystal will be demonstrated precisely with its help.  The EFM32 Zero Gecko microcontroller kit is called EFM32ZG-STK3200 and is purchased for $ 42, please contact.  The kit consists of a USB cable, a battery and one such board. <br><br><img src="https://habrastorage.org/files/159/005/65e/15900565e6a84df2a6d149f09c84d2ab.png"><br><br>  Here it is important to note this: the article is devoted to the EFM32ZG110F32 microcircuit, and on the debug board there is a more ‚Äúolder‚Äù microcontroller of the same series - EFM32ZG222F32.  The first controller is made in the QFN-24 package, the second - in the QPF-48.  As a result, only 17 I / O lines are available on the EFM32ZG110F32, up to five of which can be used as ADC channels, and on the EFM32ZG222F32 there are already 37 lines, of which only two are potential channels for the ADC.  The rest of the crystals are completely identical, so the examples discussed below can be safely attributed to both EFM32ZG222F32 and EFM32ZG110F32. <br><br>  Now back to the debug board and consider the modules available on it: <br><ul><li>  J-Link is a full-fledged debugging interface for programming and debugging an on-board microcontroller.  The EFM32ZG-STK3200 board can also be used as a programmer for a third-party board; to do this, you need to configure the EFM32ZG-STK3200 as a debugger and connect to the third-party board in a certain way.  I will tell about it below. </li><li>  The power switch allows you to select either a debugging USB interface or a three-volt battery as the source, respectively, the switch has two positions - DBG and BAT.  In the first case, not only the controller power supply and debug interface are provided.  When connected to a computer via a USB cable, it is possible to work with the Advanced Energy Monitor unit.  This is a measuring module that is installed on the board for measuring the energy consumption of the crystal.  The data that can be obtained with the Advanced Energy Monitor is used by the energy profiling utility, which will also be discussed later. </li><li> The main output device installed on the board is the so-called memory LCD connected to the controller via the SPI interface.  Memory LCD is a monochrome display with its own memory in which the displayed image is stored.  When updating the image, only the changed pixels are redrawn, thus ensuring low power consumption and relatively high display performance.  The Memory LCD display mounted on the EFM32ZG-STK3200 is so good that we bought one board only for the sake of the display.  It was strange. </li><li>  I do not need any explanations for the LEDs and mechanical buttons.  But they are, two pieces each. </li><li>  Touch buttons are capacitive sensors and are built on a popular circuit that uses an RC-chain and an analog comparator and timer integrated into the microcontroller.  If it is short, then on the RC-chain and comparator a frequency generator is built, the frequency of which depends on the capacitance, which in turn increases when the finger touches the pad.  A touch is detected when through a frequency measurement, performed, as a rule, on timers. </li><li>  The pads, on which all I / O lines are available, are arranged in two rows along the top and bottom edges of the board and on the 20-pin connector on the right edge. </li></ul><br><br>  If your application is designed for a task in which power consumption is important, then the EFM32ZG-STK3200 is absolutely useful for you (primarily due to the Advanced Energy Monitor measurement module mentioned above).  If the EFM32 is not used in a battery-powered device, and for some reason you don‚Äôt want to use this board at all, you still have to <a href="https://www.silabs.com/Support%2520Documents/TechnicalDocs/BRD2010A_B01.pdf">link</a> to Zero Gecko Starter Kit Schematics.  It may well come in handy when designing. <br><br>  From the review of the microcontroller and the debug board, we turn to the review of the available software development tools. <br><br><h4>  Software Review </h4><hr><br>  For development, you can use both software from Silicon Labs, and commonly used gcc or Keil, IAR, etc. <br><br>  Silicon Labs platform is called Simplicity Studio.  It includes an eclipse-based IDE, several utilities for developing and debugging a project, sample programs, all documentation and other components.  It makes sense to use either Simplicity Studio only, or your familiar development environment (Keil, IAR, Atollic, Rowley or Sourcery) or gcc along with utilities from Simplicity Studio. <br><br>  Why is it worth downloading Simplicity Studio regardless of your preferred compiler and IDE? <br>  First, it does not cost anything.  Like any other software from manufacturers of microcontrollers, Simplicity Studio is a free environment.  Secondly, distributions are available for Mac and Ubuntu.  Thirdly, when installing Simplicity Studio for the selected family of microcontrollers (in our case for 32-bit EFM32), you will immediately receive a complete set of development tools, documentation and useful links that will be automatically updated.  It's comfortable. <br><br>  So, after installing Simplicity Studio and connecting the debug board (on which USB power should be selected), the main menu of the program will appear. <br><br><img src="https://habrastorage.org/files/937/3b5/499/9373b549924344618ee5664ac6030111.png"><br><br>  All displayed tools are active for the connected microcontroller.  If, for example, a Zigbee module were chosen, then a completely different set of icons would result.  The following options are available for debugging the program on EFM32ZGxxx: <br><ul><li>  Development environment.  The default is Simplicity IDE, but another medium can be selected as the preferred IDE, in which case the Simplicity IDE icon will be replaced. </li><li>  Energy profiling is a utility that works with the Advanced Energy Monitor measurement module installed on the debug board and builds a beautiful Current / Time graph that is updated as the program runs. </li><li>  The configurator is a graphical interface for configuring I / O lines and peripheral devices, allowing you to generate a program design with the appropriate initialization functions. </li><li>  With demo examples and a utility for programming a crystal, I think everything is clear. </li><li>  In the settings of the debug board, you can select the debug mode.  Three modes are available: <br>  1. Debugging of the MC, located on the board, via J-Link, located on the board <br>  2. Debugging the MC, located on the board, through an external debugger <br>  3. Using the board as a debugger for the connected board. <br>  In the same section, you can update the firmware of the board, for more details, see example # 5. </li><li>  I don‚Äôt know how the SWO terminal got into the menu for the EFM32 Zero Gecko controller - the SWO line is not provided on Cortex-M0 + based microcontrollers.  We will consider it an accident. </li><li>  Battery emulation of the device is a utility that is used to input a series of microcontrollers, its state (power consumption modes and active peripheral units), the number and type of batteries.  For the described configuration of the crystal and the power supply, the autonomy of the controller is calculated. </li><li>  In the Software Examples section, ready-made programs for the selected series of microcontrollers are available ‚Äî connected the board, selected the program, launched it.  For useful examples, you should also look at the Application Notes menu.  Each document describing the peculiarities of working with peripherals is accompanied by illustrating projects. </li><li>  All documentation for a connected card or a selected microcontroller is available in one click - when you install Simplicity Studio, all available materials for the selected chip family are downloaded, and when you update Simplicity Studio, the latest documentation is updated. </li><li>  Documentation for microcontroller software ‚Äî libraries, drivers, all registers and data structures ‚Äî is available in the Software Documentation section or via the <a href="http://devtools.silabs.com/studio/doc/EFM32/software/cmsis_docs/efm32zg/html/index.html">link</a> . </li><li>  Configuring interaction with third-party software is a menu for selecting the preferred IDE, checking and installing the required drivers, etc. </li></ul><br>  In the upper right corner there is an update center, where you can check and download all available software updates and documentation for the selected series of microcontrollers. <br><br>  <i>Speaking of updates.</i>  <i>The first Simplicity Studio, developed by the company energy micro, was great in its simplicity.</i>  <i>The next version was released in Silicon Labs.</i>  <i>Simplicity Studio 2.0 had a much wider range of functions, contained an IDE and supported C8051Fxxx microcontrollers, but it turned out to be very slow.</i>  <i>By the current version (3.2), the situation is completely leveled and working in Simplicity Studio is again very nice.</i> <br><br>  To acquaint the reader with the capabilities of the EFM32ZG110F32 microcontroller, consider several examples of working with various development and debugging tools. <br><br><h4>  Example # 1 Readiness Check </h4><hr><br>  If the debugging board was in your hands for the first time and you just launched Simplicity Studio, then it makes sense to run a demo example and make sure that all this software and hardware complex is working properly. <br>  After switching on the board in DBG mode, make sure that the board has been determined (see the lower left corner of the main menu of Simplicity Studio).  For the EFM32ZG-STK3200 card in the first row, the Demo item will be available, containing ready-made firmware for the microcontroller. <br><br><img src="https://habrastorage.org/files/7a0/0af/3ed/7a00af3ede5a4e27a9ac8ac961839e3f.png"><br><br>  You just need to select one of the projects and click Finish.  The controller will be programmed with a ready-made binary file, the selected program will start on the board, and a graph of the current consumption level will appear on the computer screen. <br>  If everything went well, then you can start developing your own programs. <br><br>  All demo programs are available in the form of projects for each of the supported development environments.  The corresponding files after installing Simplicity Studio are in the directory ... \ SiliconLabs \ SimplicityStudio \ v3 \ developer \ sdks \ efm32 \ v2 \ kits \ EFM32ZG_STK3200 \ examples <br><br>  For each example available: <br><ul><li>  project for Keil - MDK-ARM (arm folder), </li><li>  makefile for gcc (armgcc folder), </li><li>  project for Atollic TrueSTUDIO (atollic folder), </li><li>  project for IAR Embedded Workbench for ARM (iar folder), </li><li>  project for Rowley Associates - CrossWorks for ARM (rowley folder), </li><li>  project for Simplicity IDE - CrossWorks for ARM (SimplicityStudio folder), </li><li>  ready files .bin, .hex and .out (folder bin). </li></ul><br><br><h4>  Example # 2 Working with the Low Energy UART interface and the energy profiler utility </h4><hr><br>  Let's start to deal with individual units of the microcontroller.  Returning to the peripheral block diagram of the EFM32ZG110F32 microcontroller, you can notice the LEUART module among the communication interfaces. <br>  LEUART or Low Energy UART is a serial interface that maintains functionality in sleep modes up to and including EM2.  Since in EM2 mode, only low-frequency 32.768 kHz generators are available for clocking, the LEUART interface supports only the lowest operating speed of the standard UART speeds - 9600 baud. <br><br>  In addition to working with minimal power consumption, this interface provides two unusual functions for the UART.  For LEUART, this can either be assigned to a start frame, before which parcels are not received, or signal frame, only for the arrival of which an interrupt is generated.  In both cases, the ‚Äúanalysis‚Äù of input signals is performed by the controller automatically and without the participation of the core. <br><br>  Since LEUART is a unit designed to reduce the energy consumption of a crystal, it is logical to demonstrate its capabilities together with the energy profiling software tool, the energy profiler utility. <br><br>  <b>The essence of the experiment</b> <br><br>  Parcels come from an external source to the serial interface - character arrays.  Each character must be accepted and saved, and at the end of the reception of the string, the controller must perform some calculations.  Our program is a test one, which means it is fairly simple and practically useless. <br>  A string that comes in from a third-party device is transmitted twice per second and has the same view: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hello[] = { <span class="hljs-string"><span class="hljs-string">'H'</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'L'</span></span>, <span class="hljs-string"><span class="hljs-string">'O'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'H'</span></span>, <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'R'</span></span>, <span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">'\r'</span></span> };</code> </pre> <br>  The carriage end <b>'\ r'</b> character will be considered as the line end character, and the received characters are written to the <b>rxbuf []</b> array.  The calculations necessary for ‚Äúprocessing‚Äù the resulting string will be reduced to the execution of an empty <b>for (j = 0; j &lt;1000; j ++)</b> loop, for the execution time of which LED1 is turned on. <br>  The purpose of the experiment will be to control and optimize the energy consumption of the crystal when performing the task of receiving and processing data. <br><br>  <b>Project setup, connection fees</b> <br><br>  In the project for the operation of low energy UART, functions from the EFM32 API are used - libraries provided by SilLabs and working ‚Äúon top‚Äù of ARM CMSIS.  To use them, you need to add the appropriate files to the project, you can find them in the directory ... \ SimplicityStudio \ v3 \ developer \ sdks \ efm32 \ v2 \ emlib after installing Simplicity Studio. <br><br><img src="https://habrastorage.org/files/4cd/34d/4ae/4cd34d4ae1af4683bd996c827c423a62.png"><br><br>  The example also uses the BSP (Board Support Package) package, which includes ready-made functions that simplify working with debugging boards for EFM32.  These functions make it possible not to think about the topology of the board when working with modules installed on it (for example, BSP_LedInit () and BSP_LedToggle (1)).  The BSP libraries are not designed to work with other cards, nor even to work with a branded card, powered by a battery, and not a debug USB.  However, in a pilot project it is quite possible to afford this. <br><br>  Both the EFM32 API and BSP are available for all IDEs that support EFM32 microcontrollers. <br><br>  As for the LEUART connection to the transmitting device, in accordance with the LEUART software configuration (see the function initLeuart () from the listing below), it is required <br>  a) power the board from the debug USB interface, <br>  b) connect the D5 line and ground to the transmitter device. <br><br><img src="https://habrastorage.org/files/c91/594/b6e/c91594b6ef964a47b62ffca3d145854e.png"><br><br>  <b>The first version of the software implementation</b> <br><br>  For the clarity of the experiment, at the first iteration of writing a program, pretend to be a schoolboy and forget about the existence of interrupts.  We write a program that performs an infinite loop polling serial interface: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//.... while (1) { rx_char = LEUART_Rx(LEUART0); if(rx_char == '\r') { rxbuf[i] = rx_char; i = 0; BSP_LedToggle(1); for (j = 0; j &lt; 1000; j++); BSP_LedToggle(1); } else { rxbuf[i] = rx_char; i++; } } }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Full text of the program</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_chip.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_cmu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_emu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_leuart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_gpio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bsp.h"</span></span></span><span class="hljs-meta"> char rx_char; int i, j; char rxbuf[13]; LEUART_Init_TypeDef LEUART0Init = { .enable = leuartEnableRx, .refFreq = 0, .baudrate = 9600, .databits = leuartDatabits8, .parity = leuartNoParity, .stopbits = leuartStopbits2, }; void initLeuart(void) { LEUART_Reset(LEUART0); LEUART_Init(LEUART0, &amp;LEUART0Init); LEUART0-&gt;ROUTE = LEUART_ROUTE_RXPEN | LEUART_ROUTE_LOCATION_LOC0; GPIO_PinModeSet(gpioPortD, 5, gpioModeInputPull, 1); } int main(void) { CHIP_Init(); CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO); CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO); CMU_ClockEnable(cmuClock_CORELE, true); CMU_ClockEnable(cmuClock_GPIO, true); CMU_ClockEnable(cmuClock_LEUART0, true); initLeuart(); BSP_LedsInit(); while (1) { rx_char = LEUART_Rx(LEUART0); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(rx_char == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">) { rxbuf[i] = rx_char; i = 0; BSP_LedToggle(1); for (j = 0; j &lt; 1000; j++); BSP_LedToggle(1); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { rxbuf[i] = rx_char; i++; } } }</span></span></code> </pre><br></div></div><br>  With the permission of the public, I will not give a step-by-step instruction on the creation of the project, nor explain the given code line by line.  For the masses I cite a <a href="http://community.silabs.com/t5/Official-Blog-of-Silicon-Labs/Building-an-Empty-Project-and-Simplicity-Studio-IDE/ba-p/142596">link</a> to the instruction for creating an empty project in Simplicity IDE, from there you can use the NEXT button to blink the LED and take the next few dozen lessons. <br><br>  So, to measure the power consumption of the program with an endless polling of the data reception flag, you should use the energy profiler utility, which is part of Simplicity Studio.  If the project is created in Simplicity IDE, then to start profiling it is enough to find just such an icon in the top menu.  If you are programming in a different environment or want to delve into the configuration settings of profiling, then you will have a direct path to the Profile Configurations settings window, available in the drop-down menu. <br><br><img src="https://habrastorage.org/files/070/3b9/3ed/0703b93edbde4cc58695a34d153debb2.png"><br><br>  When configuring the configuration, the executable file and bild-a settings corresponding to the IDE used should be specified. <br>  Many settings in Profile Configurations are also related to Code Correlation features.  Code Correlation is the binding of the energy measurement results to the executable code (each point on the graph corresponds to a line in the listing).  It is through this option that we are talking about profiling, and not just about measuring energy consumption.  It sounds great, of course, but the Code Correlation feature is not available for the Zero Gecko series microcontrollers.  In order to correlate measurements and program text, the value of the program counter must be additionally removed from the board.  Such data is transmitted via the SWO line, which is not provided for on Cortex-M0 based microcontrollers.  Therefore, we will be content with only the schedule of current changes being built during the execution of the program, which is also quite good. <br><br>  We begin the profiling of the first version of the program. <br><br><img src="https://habrastorage.org/files/797/51d/998/79751d99850c4fb4bc4843045761b774.png"><br><br>  Indeed, every 500 ms the microcontroller receives the parcel and processes it.  Confirming the data from the chart, the LED on the board winks twice per second. <br>  On average, with a constant polling of the flag, approximately 1.6 mA is consumed.  This is a lot, so the program must be optimized. <br><br>  <b>The second version of the software implementation</b> <br><br>  The obvious optimization option is to use interrupts from the serial interface and put the controller to sleep while interrupting.  We will execute an empty cycle and turn on LED1 in the interrupt handler. <br><br>  Main () function fragment <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CHIP_Init(); i = <span class="hljs-number"><span class="hljs-number">0</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { EMU_EnterEM2(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br>  Interrupt Setup <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupLeuart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ LEUART_IntEnable(LEUART0, LEUART_IEN_RXDATAV); NVIC_EnableIRQ(LEUART0_IRQn); LEUART0-&gt;CTRL = LEUART_CTRL_RXDMAWU; }</code> </pre><br>  Interrupt handling <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LEUART0_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ leuartif = LEUART_IntGet(LEUART0); LEUART_IntClear(LEUART0, leuartif); rx_char = LEUART0-&gt;RXDATA; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rx_char == <span class="hljs-string"><span class="hljs-string">'\r'</span></span>) { rxbuf[i] = rx_char; i = <span class="hljs-number"><span class="hljs-number">0</span></span>; BSP_LedToggle(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;<span class="hljs-number"><span class="hljs-number">1000</span></span>; j++); BSP_LedToggle(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rxbuf[i] = rx_char; i++; } }</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Full text of the program</b> <div class="spoiler_text">  The program almost completely repeats the example of working with LEUART, available in Simplicity Studio <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_chip.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_cmu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_emu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_leuart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_dma.h"</span></span></span><span class="hljs-meta"> char rx_char; int i, j; char rxbuf[12]; uint32_t leuartif; uint32_t len; LEUART_Init_TypeDef LEUART0Init = { .enable = leuartEnableRx, .refFreq = 0, .baudrate = 9600, .databits = leuartDatabits8, .parity = leuartNoParity, .stopbits = leuartStopbits2, }; void LEUART0_IRQHandler(void) { leuartif = LEUART_IntGet(LEUART0); LEUART_IntClear(LEUART0, leuartif); rx_char = LEUART0-&gt;RXDATA; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (rx_char == </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">) { rxbuf[i] = rx_char; i = 0; BSP_LedToggle(1); for (j=0; j</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;1000; j++); BSP_LedToggle(1); } else { rxbuf[i] = rx_char; i++; } } void initLeuart(void) { LEUART_Reset(LEUART0); LEUART_Init(LEUART0, &amp;LEUART0Init); LEUART0-&gt;ROUTE = LEUART_ROUTE_RXPEN | LEUART_ROUTE_LOCATION_LOC0; GPIO_PinModeSet(gpioPortD, 5, gpioModeInputPull, 1); } void setupLeuart(void) { LEUART_IntEnable(LEUART0, LEUART_IEN_RXDATAV); NVIC_EnableIRQ(LEUART0_IRQn); } int main(void) { CHIP_Init(); i = 0; CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO); CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO); CMU_ClockEnable(cmuClock_CORELE, true); /* Enable CORELE clock */ CMU_ClockEnable(cmuClock_GPIO, true); /* Enable GPIO clock */ CMU_ClockEnable(cmuClock_LEUART0, true); /* Enable LEUART0 clock */ initLeuart(); setupLeuartDma(); BSP_LedsInit(); while (1) { EMU_EnterEM2(true); } }</span></span></span></span></code> </pre><br></div></div><br>  After changing the code, just click once on the profiler icon, the program will be compiled, the controller will be programmed, and the measurement results will be displayed on the screen.  The results show that the consumption has declined many times - an average of 224 ŒºA instead of 1.6 mA. <br><br><img src="https://habrastorage.org/files/f0c/f43/688/f0cf436887bf46708d67da9fd5726dea.png"><br><br>  The microcontroller spends waiting for a parcel in the EM2 mode, this is the deepest sleep that we can afford to preserve the functionality of LEUART.  Processing the results in general has nowhere to change, which means further optimization of the program is possible only for the process of receiving the parcel.  Let's look at the corresponding section of the graph closer. <br><br><img src="https://habrastorage.org/files/db5/2ab/4ea/db52ab4eaf764f939e2819fc9f788270.png"><br><br>  Upon the arrival of each character of the string {'H', 'E', 'L', 'L', 'O', '', 'H', 'A', 'B', 'R', '!', 0 , '\ r'} calls the interrupt handler, in which the newly arrived character is compared with '\ r'.  Remembering that in front of us is not a normal serial interface, but LEUART, you can use not an interrupt upon the arrival of a character, but an interruption upon the arrival of SIGFRAME.  Let's try. <br><br>  <b>The third version of the software implementation</b> <br><br>  Under the terms of the problem, each character of the string that has arrived should be entered into the memory of the controller.  If you just change the type of interrupt, then save it would be impossible.  The solution of the problem will be the use of DMA, on the zero channel of which the data will be ‚Äúforwarded‚Äù to LEUART without leaving the power saving mode EM2. <br><br>  Interrupt Setup <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setupLeuartDma</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ DMA_Init(&amp;dmaInit); DMA_CfgChannel(DMA_CHANNEL, &amp;chnlCfg); DMA_CfgDescr(DMA_CHANNEL, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, &amp;descrCfg); DMA_ActivateBasic(DMA_CHANNEL, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) &amp;rxbuf, (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) &amp;LEUART0-&gt;RXDATA, BUF_MAX<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//-------------------------------      '\r' --------------------------------// LEUART0-&gt;SIGFRAME = '\r'; LEUART_IntEnable(LEUART0, LEUART_IEN_SIGF); //-----------------------------------------------------------------------------------------------------------// NVIC_EnableIRQ(LEUART0_IRQn); LEUART0-&gt;CTRL = LEUART_CTRL_RXDMAWU; }</span></span></code> </pre><br>  Interrupt handling <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LEUART0_IRQHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ leuartif = LEUART_IntGet(LEUART0); LEUART_IntClear(LEUART0, leuartif); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (leuartif &amp; LEUART_IF_SIGF) { DMA_ActivateBasic(DMA_CHANNEL, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, BUF_MAX<span class="hljs-number"><span class="hljs-number">-1</span></span>); BSP_LedToggle(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; j++); BSP_LedToggle(<span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre> <br><br><div class="spoiler">  <b class="spoiler_title">Full text of the program</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_chip.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_cmu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_emu.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_leuart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_dma.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_gpio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DMA_CHANNEL 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BUF_MAX 1023 char rx_char; int i, j; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* DMA control block, must be aligned to 256. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined (__ICCARM__) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> data_alignment=256 DMA_DESCRIPTOR_TypeDef dmaControlBlock[DMA_CHAN_COUNT * 2]; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined (__CC_ARM) DMA_DESCRIPTOR_TypeDef dmaControlBlock[DMA_CHAN_COUNT * 2] __attribute__ ((aligned(256))); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined (__GNUC__) DMA_DESCRIPTOR_TypeDef dmaControlBlock[DMA_CHAN_COUNT * 2] __attribute__ ((aligned(256))); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Undefined toolkit, need to </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> alignment #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> uint32_t leuartif; uint32_t len; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Defining the LEUART0 initialization data */</span></span></span><span class="hljs-meta"> LEUART_Init_TypeDef LEUART0Init = { .enable = leuartEnableRx, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Activate data reception on LEUn_RX pin. */</span></span></span><span class="hljs-meta"> .refFreq = 0, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Inherit the clock frequenzy from the LEUART clock source */</span></span></span><span class="hljs-meta"> .baudrate = 9600, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Baudrate = 9600 bps */</span></span></span><span class="hljs-meta"> .databits = leuartDatabits8, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Each LEUART frame containes 8 databits */</span></span></span><span class="hljs-meta"> .parity = leuartNoParity, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No parity bits in use */</span></span></span><span class="hljs-meta"> .stopbits = leuartStopbits2, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Setting the number of stop bits in a frame to 2 bitperiods */</span></span></span><span class="hljs-meta"> }; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* DMA init structure */</span></span></span><span class="hljs-meta"> DMA_Init_TypeDef dmaInit = { .hprot = 0, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No descriptor protection */</span></span></span><span class="hljs-meta"> .controlBlock = dmaControlBlock, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* DMA control block alligned to 256 */</span></span></span><span class="hljs-meta"> }; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Setting up channel */</span></span></span><span class="hljs-meta"> DMA_CfgChannel_TypeDef chnlCfg = { .highPri = false, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Normal priority */</span></span></span><span class="hljs-meta"> .enableInt = false, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No interupt enabled for callback functions */</span></span></span><span class="hljs-meta"> .select = DMAREQ_LEUART0_RXDATAV, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Set LEUART0 RX data avalible as source of DMA signals */</span></span></span><span class="hljs-meta"> .cb = NULL, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No callback funtion */</span></span></span><span class="hljs-meta"> }; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Setting up channel descriptor */</span></span></span><span class="hljs-meta"> DMA_CfgDescr_TypeDef descrCfg = { .dstInc = dmaDataInc1, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Increment destination address by one byte */</span></span></span><span class="hljs-meta"> .srcInc = dmaDataIncNone, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Do no increment source address */</span></span></span><span class="hljs-meta"> .size = dmaDataSize1, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Data size is one byte */</span></span></span><span class="hljs-meta"> .arbRate = dmaArbitrate1, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Rearbitrate for each byte recieved*/</span></span></span><span class="hljs-meta"> .hprot = 0, </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No read/write source protection */</span></span></span><span class="hljs-meta"> }; void LEUART0_IRQHandler(void) { leuartif = LEUART_IntGet(LEUART0); LEUART_IntClear(LEUART0, leuartif); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (leuartif &amp; LEUART_IF_SIGF) { DMA_ActivateBasic(DMA_CHANNEL, true, false, NULL, NULL, BUF_MAX-1); BSP_LedToggle(1); for (j = 0; j </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 1000; j++); BSP_LedToggle(1); } } void initLeuart(void) { LEUART_Reset(LEUART0); LEUART_Init(LEUART0, &amp;LEUART0Init); LEUART0-&gt;ROUTE = LEUART_ROUTE_RXPEN | LEUART_ROUTE_LOCATION_LOC0; GPIO_PinModeSet(gpioPortD, 5, gpioModeInputPull, 1); } void setupLeuartDma(void) { DMA_Init(&amp;dmaInit); DMA_CfgChannel(DMA_CHANNEL, &amp;chnlCfg); DMA_CfgDescr(DMA_CHANNEL, true, &amp;descrCfg); DMA_ActivateBasic(DMA_CHANNEL, true, false, (void *) &amp;rxbuf, (void *) &amp;LEUART0-&gt;RXDATA, BUF_MAX-1); LEUART0-&gt;SIGFRAME = '\r'; LEUART_IntEnable(LEUART0, LEUART_IEN_SIGF); NVIC_EnableIRQ(LEUART0_IRQn); LEUART0-&gt;CTRL = LEUART_CTRL_RXDMAWU; } int main(void) { CHIP_Init(); i = 0; CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO); CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO); CMU_ClockEnable(cmuClock_CORELE, true); CMU_ClockEnable(cmuClock_DMA, true); CMU_ClockEnable(cmuClock_GPIO, true); CMU_ClockEnable(cmuClock_LEUART0, true); initLeuart(); setupLeuartDma(); BSP_LedsInit(); while (1) { EMU_EnterEM2(true); } }</span></span></span></span></code> </pre><br></div></div><br><br>  We run the profiling for the third time and we get evidence that the optimization made makes sense - the consumption has decreased from 224 to 139 ŒºA. <br><br><img src="https://habrastorage.org/files/0df/4a7/730/0df4a773004f42d6921e85290f6335cd.png"><br><br>  The ‚Äúteeth‚Äù disappeared, corresponding to the interrupt handling for each incoming character.  Due to this, the power consumption for data reception / processing, and the average value have decreased significantly. <br><br>  I would not like to go into the comparison of specific numbers (the line could, for example, be longer, and the parcels more often), but I think that the principle of reducing consumption using low energy UART and the energy profiler is described quite clearly. <br><br><h4>  Example # 3 Work with PCNT hardware pulse counter and crystal configurator </h4><hr><br>  Consider another interesting development tool, configurator for peripherals and I / O lines.  Selecting the corresponding item of the main menu of Simplicity Studio and specifying the part number to use, you can start creating a new project in the graphic environment of the controller settings. <br><br>  For the EFM32ZG110F32 microcontroller (yes, still $ 0.96 apiece), this interface is available to the user: <br><br>  <b>I / O line settings window</b> <br><br><img src="https://habrastorage.org/files/d53/088/f2f/d53088f2f430471ba46838bfca338198.png"><br><br>  <b>Peripherals Settings Window</b> <br><br><img src="https://habrastorage.org/files/415/30d/155/41530d155c41420d8eba41588355b5ae.png"><br><br>  The general principle of operation in the Configurator is as follows: the required peripherals are selected, the operation mode is configured for each block, then the I / O lines necessary for the blocks are assigned, the configuration is set for each line.  After configuration, the project generation for the development environment is started. <br>  The configurator allows you to simplify the initial stage of programming - instead of squeezing the peripheral settings from the documentation, a graphical interface is used.  In addition, this utility allows you to quickly assess the capabilities of the selected crystal and make a simple trial project.  Such a configurator is the majority of manufacturers of microcontrollers. <br><br>  With the use of the configurator, we will get acquainted with a 16-bit pulse counter.  Like LEUART, this module is rarely found on microcontrollers, and, like LEUART, a pulse counter reduces the power consumption of a device. <br><br>  So, in the configuration menu of the EFM32ZG110F32 microcontroller, we tick the PCNT0 and look at the available settings. <br><br><img src="https://habrastorage.org/files/d4e/3b2/285/d4e3b22859e0409ea6924dc0d7ec955c.png"><br><br>  The module can be configured to count the number of pulses arriving at one of the crystal ports; in this case, an interrupt is generated when a specified number of pulses are reached.  Another variant of the module operation is the quadrature encoder mode with an interruption by changing the count direction (clockwise / counterclockwise). <br>  The PCNT counter can use one or two input signals.  In the ‚ÄúSingle input, LFACLK oversampling‚Äù and ‚ÄúSingle input, externally clocked‚Äù pulse counting modes, only the S0 line is used, and the signal to S1 is ignored.  In the ‚ÄúQuadrature decoder mode, externally clocked‚Äù mode both input signals are used. <br><br>  The PCNT counter is available in sleep modes up to EM3, however, in the ‚ÄúSingle input, LFACLK oversampling‚Äù pulse counting mode, an internal rather than an external clock source is used, so it is possible to use power consumption modes no lower than EM2.  Operation of the unit in EM3 mode is also not possible if the Peripheral Reflex System channels are not used as PCNT input inputs, not the microcontroller I / O lines.  On the other hand, EM2 is the power consumption in microamps units, which is quite acceptable for an encoder. <br><br>  Let's set up through the configurator the settings of the simplest PCNT mode.  Let the fifth pulse be detected on one of the GPIO lines. <br>  We set the operation mode to ‚ÄúSingle input, LFACLK oversampling‚Äù, the Initial top value is set to ‚Äú5‚Äù, leave the account settings (Count the edges of the positive edges) and the count direction Count up) by default, enable the filter out filter out pulses shorter then 5 clockcycles ‚Äùto protect against chatter.  Input channel settings remain the default because  The second channel in the Single input mode is ignored, and the first uses the controller's foot, and not the PRS channel.  The remaining properties of the Pulse Counter menu refer to the quadrature encoder mode, so we don‚Äôt look at them at all. <br><br><img src="https://habrastorage.org/files/542/fcd/ea0/542fcdea024049479aec84577669b982.png"><br><br>  Having seen our settings, the configurator rightly notes that once the pulses arriving on one of the I / O lines are counted, this line must be selected and configured. <br><br><img src="https://habrastorage.org/files/79c/9bf/4c9/79c9bf4c964041f0b3075b8a0cea47f8.png"><br><br>  By clicking on the error message, go to the I / O line settings window, where two locations are available for the S0IN line: <br><br><img src="https://habrastorage.org/files/4b6/7ad/f57/4b67adf57fb242adacfbf0b8cbbd7c6b.png"><br><br>  Suppose that the second location, i.e.  line PC0, suits us better.  Again we look into the error window. <br><br><img src="https://habrastorage.org/files/a6e/d12/73c/a6ed1273c1f94fb5958d72933dd16669.png"><br><br>  And, again agreeing with the configurator, we change the mode of operation of the controller leg from Disabled to Input. <br><br><img src="https://habrastorage.org/files/a55/ac7/822/a55ac78225b244eaa0d4f27f6aa3b996.png"><br><br>  Now you can generate the source code for a given configuration of the microcontroller EFM32ZG110F32.  In the right-click menu of the mouse, we find the Generate Source command and get the finished project.  The project contains the initialization of the crystal - setting the clocking, pulse counter and GPIO, as well as an empty while (1) loop in the function main (). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enter_DefaultMode_from_RESET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CMU_enter_DefaultMode_from_RESET(); PCNT0_enter_DefaultMode_from_RESET(); PORTIO_enter_DefaultMode_from_RESET(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CMU_enter_DefaultMode_from_RESET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ CMU_OscillatorEnable(cmuOsc_LFRCO, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFRCO); CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFRCO); CMU_ClockEnable(cmuClock_CORELE, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFRCO); CMU_ClockEnable(cmuClock_PCNT0, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); CMU_ClockEnable(cmuClock_GPIO, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PCNT0_enter_DefaultMode_from_RESET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ PCNT_Init_TypeDef init = PCNT_INIT_DEFAULT; init.counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; init.top = <span class="hljs-number"><span class="hljs-number">5</span></span>; init.negEdge = <span class="hljs-number"><span class="hljs-number">0</span></span>; init.countDown = <span class="hljs-number"><span class="hljs-number">0</span></span>; init.filter = <span class="hljs-number"><span class="hljs-number">1</span></span>; init.hyst = <span class="hljs-number"><span class="hljs-number">0</span></span>; init.s1CntDir = <span class="hljs-number"><span class="hljs-number">0</span></span>; init.cntEvent = pcntCntEventUp; init.auxCntEvent = pcntCntEventNone; init.s0PRS = pcntPRSCh0; init.s1PRS = pcntPRSCh0; PCNT_Init(PCNT0, &amp;init); PCNT_Enable(PCNT0, pcntModeOvsSingle); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PORTIO_enter_DefaultMode_from_RESET</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Pin PC0 is configured to Input enabled */</span></span> GPIO-&gt;P[<span class="hljs-number"><span class="hljs-number">2</span></span>].MODEL = (GPIO-&gt;P[<span class="hljs-number"><span class="hljs-number">2</span></span>].MODEL &amp; ~_GPIO_P_MODEL_MODE0_MASK) | GPIO_P_MODEL_MODE0_INPUT; <span class="hljs-comment"><span class="hljs-comment">/* Module PCNT0 is configured to location 2 */</span></span> PCNT0-&gt;ROUTE = (PCNT0-&gt;ROUTE &amp; ~_PCNT_ROUTE_LOCATION_MASK) | PCNT_ROUTE_LOCATION_LOC2; }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Full text of the program</b> <div class="spoiler_text">  Main.c file <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/**************************************************************************/</span></span><span class="hljs-comment"><span class="hljs-comment">/** * @file * @brief Empty Project * @author Energy Micro AS * @version 3.20.2 ****************************************************************************** * @section License * &lt;b&gt;(C) Copyright 2014 Silicon Labs, http://www.silabs.com&lt;/b&gt; ******************************************************************************* * * This file is licensed under the Silicon Labs Software License Agreement. See * "http://developer.silabs.com/legal/version/v11/Silicon_Labs_Software_License_Agreement.txt" * for details. Before using this software for any purpose, you must agree to the * terms of that agreement. * ******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_device.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"em_chip.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/**************************************************************************/</span></span></span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @brief Main function *****************************************************************************/</span></span></span><span class="hljs-meta"> int main(void) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Chip errata */</span></span></span><span class="hljs-meta"> CHIP_Init(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Infinite loop */</span></span></span><span class="hljs-meta"> while (1) { } }</span></span></code> </pre><br><br>  InitDevice.c file <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//========================================================= // src/InitDevice.c: generated by Hardware Configurator // // This file will be regenerated when saving a document. // leave the sections inside the "$[...]" comment tags alone // or they will be overwritten! //========================================================= // USER INCLUDES #include "InitDevice.h" // USER PROTOTYPES // USER FUNCTIONS // $[Library includes] #include "em_system.h" #include "em_emu.h" #include "em_cmu.h" #include "em_device.h" #include "em_chip.h" #include "em_pcnt.h" // [Library includes]$ //============================================================================== // enter_DefaultMode_from_RESET //============================================================================== extern void enter_DefaultMode_from_RESET(void) { // $[Config Calls] CMU_enter_DefaultMode_from_RESET(); PCNT0_enter_DefaultMode_from_RESET(); PORTIO_enter_DefaultMode_from_RESET(); // [Config Calls]$ } //================================================================================ // HFXO_enter_DefaultMode_from_RESET //================================================================================ extern void HFXO_enter_DefaultMode_from_RESET(void) { // $[HFXO] // [HFXO]$ } //================================================================================ // LFXO_enter_DefaultMode_from_RESET //================================================================================ extern void LFXO_enter_DefaultMode_from_RESET(void) { // $[Use oscillator source] // [Use oscillator source]$ // $[LFXO Boost Percent] // [LFXO Boost Percent]$ // $[REDLFXO Boost] // [REDLFXO Boost]$ } //================================================================================ // CMU_enter_DefaultMode_from_RESET //================================================================================ extern void CMU_enter_DefaultMode_from_RESET(void) { // $[LFXO enable] // [LFXO enable]$ // $[HFXO enable] // [HFXO enable]$ // $[LFACLK Setup] /* Enable LFRCO oscillator */ CMU_OscillatorEnable(cmuOsc_LFRCO, true, true); /* Select LFRCO as clock source for LFACLK */ CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFRCO); // [LFACLK Setup]$ // $[High Frequency Clock select] /* Using HFRCO at 14MHz as high frequency clock, HFCLK */ CMU_ClockSelectSet(cmuClock_HF, cmuSelect_HFRCO); // [High Frequency Clock select]$ // $[LF clock tree setup] /* Enable LF clocks */ CMU_ClockEnable(cmuClock_CORELE, true); CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFRCO); // [LF clock tree setup]$ // $[Peripheral Clock enables] /* Enable clock for PCNT0 */ CMU_ClockEnable(cmuClock_PCNT0, true); /* Enable clock for GPIO by default */ CMU_ClockEnable(cmuClock_GPIO, true); // [Peripheral Clock enables]$ } //================================================================================ // ADC0_enter_DefaultMode_from_RESET //================================================================================ extern void ADC0_enter_DefaultMode_from_RESET(void) { // $[ADC_Init] // [ADC_Init]$ // $[ADC_InitSingle] // [ADC_InitSingle]$ // $[ADC_InitScan] // [ADC_InitScan]$ } //================================================================================ // ACMP0_enter_DefaultMode_from_RESET //================================================================================ extern void ACMP0_enter_DefaultMode_from_RESET(void) { // $[ACMP Initialization] // [ACMP Initialization]$ // $[ACMP Channel config] // [ACMP Channel config]$ } //================================================================================ // IDAC0_enter_DefaultMode_from_RESET //================================================================================ extern void IDAC0_enter_DefaultMode_from_RESET(void) { // $[IDAC Initialization] // [IDAC Initialization]$ // $[IDAC optional configurations] // [IDAC optional configurations]$ // $[IDAC enable] // [IDAC enable]$ } //================================================================================ // RTC_enter_DefaultMode_from_RESET //================================================================================ extern void RTC_enter_DefaultMode_from_RESET(void) { // $[RTC_Init] // [RTC_Init]$ } //================================================================================ // USART1_enter_DefaultMode_from_RESET //================================================================================ extern void USART1_enter_DefaultMode_from_RESET(void) { // $[USART_InitAsync] // [USART_InitAsync]$ // $[USART_InitSync] // [USART_InitSync]$ // $[USART_InitPrsTrigger] // [USART_InitPrsTrigger]$ } //================================================================================ // LEUART0_enter_DefaultMode_from_RESET //================================================================================ extern void LEUART0_enter_DefaultMode_from_RESET(void) { // $[LEUART0 initialization] // [LEUART0 initialization]$ } //================================================================================ // VCMP_enter_DefaultMode_from_RESET //================================================================================ extern void VCMP_enter_DefaultMode_from_RESET(void) { // $[VCMP_Init] // [VCMP_Init]$ } //================================================================================ // WDOG_enter_DefaultMode_from_RESET //================================================================================ extern void WDOG_enter_DefaultMode_from_RESET(void) { // $[CMU_ClockEnable] // [CMU_ClockEnable]$ // $[CMU_OscillatorEnable] // [CMU_OscillatorEnable]$ // $[WDOG_Init] // [WDOG_Init]$ } //================================================================================ // I2C0_enter_DefaultMode_from_RESET //================================================================================ extern void I2C0_enter_DefaultMode_from_RESET(void) { // $[I2C0 initialization] // [I2C0 initialization]$ } //================================================================================ // TIMER0_enter_DefaultMode_from_RESET //================================================================================ extern void TIMER0_enter_DefaultMode_from_RESET(void) { // $[TIMER0 initialization] // [TIMER0 initialization]$ // $[TIMER0 CC0 init] // [TIMER0 CC0 init]$ // $[TIMER0 CC1 init] // [TIMER0 CC1 init]$ // $[TIMER0 CC2 init] // [TIMER0 CC2 init]$ } //================================================================================ // TIMER1_enter_DefaultMode_from_RESET //================================================================================ extern void TIMER1_enter_DefaultMode_from_RESET(void) { // $[TIMER1 initialization] // [TIMER1 initialization]$ // $[TIMER1 CC0 init] // [TIMER1 CC0 init]$ // $[TIMER1 CC1 init] // [TIMER1 CC1 init]$ // $[TIMER1 CC2 init] // [TIMER1 CC2 init]$ } //================================================================================ // PCNT0_enter_DefaultMode_from_RESET //================================================================================ extern void PCNT0_enter_DefaultMode_from_RESET(void) { // $[PCNT0 initialization] PCNT_Init_TypeDef init = PCNT_INIT_DEFAULT; init.counter = 0; init.top = 5; init.negEdge = 0; init.countDown = 0; init.filter = 1; init.hyst = 0; init.s1CntDir = 0; init.cntEvent = pcntCntEventUp; init.auxCntEvent = pcntCntEventNone; init.s0PRS = pcntPRSCh0; init.s1PRS = pcntPRSCh0; PCNT_Init(PCNT0, &amp;init); /* Activating PCNT0 */ PCNT_Enable(PCNT0, pcntModeOvsSingle); // [PCNT0 initialization]$ } //================================================================================ // PRS_enter_DefaultMode_from_RESET //================================================================================ extern void PRS_enter_DefaultMode_from_RESET(void) { // $[PRS initialization] // [PRS initialization]$ } extern void PORTIO_enter_DefaultMode_from_RESET(void) { // $[Port A Configuration] // [Port A Configuration]$ // $[Port B Configuration] // [Port B Configuration]$ // $[Port C Configuration] /* Pin PC0 is configured to Input enabled */ GPIO-&gt;P[2].MODEL = (GPIO-&gt;P[2].MODEL &amp; ~_GPIO_P_MODEL_MODE0_MASK) | GPIO_P_MODEL_MODE0_INPUT; // [Port C Configuration]$ // $[Port D Configuration] // [Port D Configuration]$ // $[Port E Configuration] // [Port E Configuration]$ // $[Port F Configuration] // [Port F Configuration]$ // $[Route Configuration] /* Module PCNT0 is configured to location 2 */ PCNT0-&gt;ROUTE = (PCNT0-&gt;ROUTE &amp; ~_PCNT_ROUTE_LOCATION_MASK) | PCNT_ROUTE_LOCATION_LOC2; // [Route Configuration]$ }</span></span></code> </pre><br></div></div><br>            . ,      ,         . <br><br>            EFM32ZG-STK3200. <br><br><h4>  #4      - </h4><hr><br>    ,  J-Link,   EFM32ZG-STK3200          ,       ¬´¬ª  EFM32. ,             EFM32ZG-STK3200     energy profiler. <br>   EFM32ZG-STK3200      . <br><br> <b>1.  </b> <br><br>  EFM32ZG-STK3200  USB ,     Simplicity Studio   Kit Manager.       Debug Mode  MCU  Out. <br><br><img src="https://habrastorage.org/files/fcc/b8b/c0f/fccb8bc0f37a445d8f81a11411c1f9f0.png"><br><br> <b>2.  </b> <br><br>      EFM32ZG-STK3200    Cortex- 20-   SWD (Serial Wire Debug).        ,   20   . <br><br><img src="https://habrastorage.org/files/cc9/e04/1ea/cc9e041ea3244a589f8809c47325b04a.png"><br><br>  SWO       .   EFM32 Zero Gecko,       Cortex-M0/-M0+,  SWO  ,       EFM32ZG-STK3200 J-Link      Cortex-M3  ,  SWO      . <br><br>  Reset     , ,  , highly recommended.            ,   ,         . <br><br>   ,        VMCU.   VMCU    ,    energy profiler    ,    . <br><br> <b>3.  IDE</b> <br><br>  Simplicity IDE      EFM32ZG-STK3200   Debug Out    .   Keil  IAR     J-Link,    <a href="https://www.silabs.com/Support%2520Documents/TechnicalDocs/AN0043.pdf">AN0043 ‚Äî EFM32 Debug and Trace</a> . <br><a name="EFM32-mbed"></a><br><h4>  #5   EFM32   mbed </h4><hr><br>            EFM32 Zero Gecko    mbed   ARM. <br> mbed ‚Äî   ,       IoT-.     mbed OS      Cortex-M,  -IDE,         (, , ,   ..),       .          . <br>    mbed               mbed    EFM32 Zero Gecko. <br><br> SiLabs ‚Äî    <a href="https://developer.mbed.org/platforms/"></a>  ,     mbed.  <a href="https://developer.mbed.org/platforms/EFM32-Zero-Gecko/"></a> ,  EFM32ZG     ,       ,          -.  And this will do. <br><br>         (. Debug Mode: MCU   #4)      USB-.           (    DBG),       .         ,       ‚Äî      :    mbed     mbed.     mbed   ,    --     .      Kit Manager    Simplicity Studio.   ,  Kit Manager    .       . <br><br>    mbed   .     <b>developer.mbed.org</b>  ,       Platforms    EFM32ZG-STK3200. <br><img src="https://habrastorage.org/files/fca/403/750/fca403750356403e816ef5dac73b7a79.png"><br><img src="https://habrastorage.org/files/eef/98f/ceb/eef98fceb1ba4b72811f0e66bce35df3.png"><br><br>    mbed      -      .  EFM32ZG-STK3200,     IDE. <br><img src="https://habrastorage.org/files/07f/fff/692/07ffff69251d436d942909bbc87a3261.png"><br><img src="https://habrastorage.org/files/c35/fcc/7a2/c35fcc7a24404d0ea2c82291027ba3e8.png"><br><br>      .            : :  . <br><img src="https://habrastorage.org/files/c77/39d/443/c7739d4439184f39bc1fa6d60187b4a6.png"><br><br>    ,     .        . <br><img src="https://habrastorage.org/files/680/33c/f30/68033cf302a646c49a1d359991e97d4f.png"><br><br>   .      EFM32,   mbed,    Mass Storage Device. <br><br><img src="https://habrastorage.org/files/2e4/ec0/d1c/2e4ec0d1c26945329f310ac1371e3586.png"><br><br>   developer.mbed.org       STK3200,                 . <br><br><img src="https://habrastorage.org/files/b0b/609/0cd/b0b6090cd32b4f66957476b6e0b3c9b0.png"><br><br> ,    mbed  .        ,     mbed       .  . <br><br>      mbed   .    sleep(),             mbed.    EFM32   ,  mbed  <a href="https://developer.mbed.org/teams/SiliconLabs/wiki/Using-the-improved-mbed-sleep-API">sleep API</a> ,         ARM mbed. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span><span class="hljs-meta"> DigitalOut myled(LED1); LowPowerTicker toggleTicker; void ledToggler(void) { myled = !myled; } int main() { toggleTicker.attach(&amp;ledToggler, 0.2f); while(1) { sleep(); } }</span></span></code> </pre><br><br><h4>  Conclusion </h4><hr><br>  Thanks for attention.  ,   EFM32ZG110F32    EFM32   .          ,         email,   <a href="https://habrahabr.ru/users/uuuulala/"></a> . </div><p>Source: <a href="https://habr.com/ru/post/277899/">https://habr.com/ru/post/277899/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277889/index.html">Zabbix 3.0: Interface</a></li>
<li><a href="../277891/index.html">How we transported the data center of a western company to the Russian Federation due to the law on personal data</a></li>
<li><a href="../277893/index.html">Sessions and memory management in the assembly Vivaldi 1.0.403.15</a></li>
<li><a href="../277895/index.html">How to create email-auto-answers: Analysis of 100 applications to support services of IT companies</a></li>
<li><a href="../277897/index.html">Project Performance Test</a></li>
<li><a href="../277901/index.html">A bit about 2FA: Two-factor authentication</a></li>
<li><a href="../277903/index.html">Joseph "Lick" Liclider: "Intergalactic Computer Network" and "Symbiosis of Man and Computer"</a></li>
<li><a href="../277905/index.html">The book "Computer Design for Architects"</a></li>
<li><a href="../277911/index.html">How to graduate from the Theater Institute and become a leader in Yandex - a lecture by Grigory Bakunov at Innopolis University</a></li>
<li><a href="../277913/index.html">2nd of March. "Call Jake." NIC and RFC history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>