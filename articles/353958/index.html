<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compare Draft, Gitkube, Helm, Ksonnet, Metaparticle and Skaffold</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, Kubernetes is very popular, and developers are looking for additional ways and methods for deploying applications in a cluster of this syste...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compare Draft, Gitkube, Helm, Ksonnet, Metaparticle and Skaffold</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jl/hp/nw/jlhpnw-td9ywefnjh42tjazdezi.png" alt="image"></div><br>  Recently, Kubernetes is very popular, and developers are looking for additional ways and methods for deploying applications in a cluster of this system.  Even the <code>kubectl</code> command line <code>kubectl</code> become perceived as a low-level tool, while users continue to look for even simpler ways to interact with the cluster.  Draft, Gitkube, Helm, Ksonnet, Metaparticle and Skaffold are just a few of the tools that help developers create and deploy applications in Kubernetes. <br><br>  Draft, Gitkube and Skaffold simplify application development by letting developers launch them as quickly as possible in a Kubernetes cluster.  Helm and Ksonnet help in the deployment process, because  they can determine whether the application is ready to be sent, as well as manage the release of new versions, the processing of various clusters, etc. Metaparticle is an unusual tool that allows you to work with any formats (YAML, dockerfile) as part of your own code. <br><br>  So, what to use in a particular situation? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's get a look. <a name="habracut"></a><br><br><h2>  Draft </h2><br>  <i>Simple application development and deployment in any Kubernetes cluster.</i> <br><br>  As the name implies, Draft simplifies the development of applications running within Kubernetes clusters.  The official statement says that Draft is a tool for developing applications running in Kubernetes, and not for deploying them.  In the project documentation of the Draft tool for the deployment of applications it is recommended to use Helm. <br><br>  The main task of Draft is to transfer the code, on which the developer is still working, from his computer to the Kubernetes cluster before the changes are fixed in the version control system.  Their fixation will occur only after the developer is satisfied with the edits added and launched with the help of Draft in the Kubernetes cluster. <br><br>  Draft is not designed for production deployment, as it is intended solely for rapid application development for Kubernetes.  However, this tool integrates well with Helm, as it uses it for laying out changes. <br><br><h3>  Architecture </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-m/fq/2q/-mfq2qv-d6jwewn-acs9dlvufck.png" alt="image"></div><br>  <i>Draft: architecture diagram</i> <br><br>  As you can see in the diagram, CLI <code>draft</code> is a key component.  It determines the application language used in the source code and applies the appropriate <i>package from the repository.</i>  <i>A package</i> is a combination of the dockerfile and the Helm chart that defines the environment for the application.  <i>Packages</i> can be defined and added to <i>repositories.</i>  Users can define their own <i>packages and repositories</i> , as they are presented as files on local systems or in a Git repository. <br><br>  Any source directory can be expanded if there is a corresponding <i>package</i> for this stack.  After the directory is configured using the <code>draft create</code> command (adds the dockerfile, the Helm chart and the draft.toml file), you can use the <code>draft up</code> command to create a docker image, transfer it to the registry and launch the application using the Helm chart (provided that Helm installed).  Execution of this command after each change will lead to the deployment of a new assembly. <br><br>  In addition, there is a <code>draft connect</code> command that can redirect connections to the local system, as well as transfer logs from the container.  It can be used in conjunction with the <code>nginx-Ingress</code> command to provide domain names for each deployable application. <br><br><h3>  From scratch to k8s </h3><br>  Below are the steps that will allow you to run an application written in Python in the k8s cluster using Draft (a more detailed guide is in <a href="">this document</a> ). <br><br>  Requirements: <br><br><ul><li>  cluster k8s (hence the kubectl interface); </li><li>  Helm CLI; </li><li>  Draft CLI; </li><li>  Docker; </li><li>  Docker repository for storing images. </li></ul><br><pre> <code class="bash hljs">$ helm init $ draft init $ draft config <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> registry docker.io/myusername $ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Azure/draft $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> draft/examples/example-python $ draft create $ draft up <span class="hljs-comment"><span class="hljs-comment">## edit code $ draft up</span></span></code> </pre><br><h3>  Using </h3><br><ul><li>  Application development within the Kubernetes cluster. </li><li>  Used in the ‚Äúinternal development cycle‚Äù before changes in the code are recorded in the version control system. </li><li>  Pre-CI: as soon as development using Draft has been completed, the concept of continuous integration and delivery (CI / CD) is applied. </li><li>  Not suitable for development in production. </li></ul><br>  More detail <a href="http://draft.sh/">here</a> . <br><br><h2>  Gitkube </h2><br>  <i>Creating and deploying docker images in Kubernetes using git push</i> <br><br>  Gitkube is a tool with which you can create and deploy docker images in Kubernetes using the <code>git push</code> command.  Unlike Draft, Gitkube does not have a command line interface, and it runs exclusively in a cluster. <br><br>  Any source repository with dockerfile can be deployed using Gitkube.  After Gitkube is installed and opened in a cluster, the developer can create a <i>remote</i> user resource that provides the remote Git URL.  Now you can send changes to this address, after which the kubectl assembly of Docker will be deployed in the cluster.  Application manifests can be created using any tool (kubectl, helm, etc.) <br><br>  Everything is focused on plug-and-play installation and the use of popular tools (Git and kubectl).  Flexibility with respect to the deployed repository is not allowed.  The context of the Docker assembly, the dockerfile path, as well as the updated deployments can be customized. <br><br>  Authentication for the git remote command is based on the SSH public key.  Every time changes made to the code are captured and applied using Git, the build and deployment processes are started. <br><br><h3>  Architecture </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/b7/b7/ep/b7b7epi_p4mojbt46tw2smxbiia.png" alt="image"></div><br>  <i>Gitkube: architecture diagram</i> <br><br>  There are 3 components in the cluster: <i>remote</i> CRD, which defines what should happen when sending to a remote URL;  <i>gitkubed</i> , which creates Docker images and updates the deployment process;  as well as a <i>gitkube controller</i> that tracks CRD to configure <i>gitkubed</i> . <br><br>  After these objects appear in the cluster, the developer can create his own applications using kubectl.  The next step is to create a <i>remote</i> object that tells Gitkube what should happen when the git push command is executed against a specific remote address.  Gitkube writes the remote URL back to the <i>remote</i> object field. <br><br><h3>  From scratch to k8s </h3><br>  Requirements: <br><br><ul><li>  cluster k8s (kubectl); </li><li>  Git; </li><li>  Gitkube installed in a cluster ( <code>kubectl create</code> command). </li></ul><br>  Below are the steps required to deploy applications to Kubernetes, including installing Gitkube: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/hasura/gitkube-example $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> gitkube-example $ kubectl create -f k8s.yaml $ cat ~/.ssh/id_rsa.pub | awk <span class="hljs-string"><span class="hljs-string">'$0=" - "$0'</span></span> &gt;&gt; <span class="hljs-string"><span class="hljs-string">"remote.yaml"</span></span> $ kubectl create -f remote.yaml $ kubectl get remote example -o json | jq -r <span class="hljs-string"><span class="hljs-string">'.status.remoteUrl'</span></span> $ git remote add example [remoteUrl] $ git push example master <span class="hljs-comment"><span class="hljs-comment">## edit code ## commit and push</span></span></code> </pre><br><h3>  Using </h3><br><ul><li>  Simple deployment using Git (without building Docker). </li><li>  Application Development at Kubernetes. </li><li>  During development, the current branch (WIP, work in progress) can be ‚Äúpushed‚Äù many times to quickly get results. </li></ul><br>  ‚Üí More details <a href="http://gitkube.sh/">here.</a> <br><br><h2>  Helm </h2><br>  <i>Package Manager for Kubernetes</i> <br><br>  The Helm tool, as stated in the description, allows you to manage applications on Kubernetes using <i>charts</i> .  Helm creates Kubernetes manifests and manages their versions, providing the ability to roll back to any object (and not just for deployments).  Charts can include deploy, services, ConfigMap interfaces, etc. They also support the use of templates so that variables can be easily changed.  Charts can be used for complex applications with many dependencies. <br><br>  Helm is primarily intended for the deployment of manifests and their management in the production environment.  Unlike Draft or Gitkube, which help in application development, Helm focuses solely on production and deployment.  There is a wide range of embedded <i>charts</i> that can be used with Helm. <br><br><h3>  Architecture </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/kn/6p/bhkn6pxuaprlb-ekkvimutmz4ya.png" alt="image"></div><br>  <i>Helm: architecture diagram</i> <br><br>  First, consider the charts themselves.  As mentioned earlier, a chart is a collection of information necessary to create an instance of the Kubernetes application.  It can contain deployments, services, ConfigMap interfaces, Secret plugins, ingress controller, etc. All of them are defined as YAML files, which, in turn, are templates.  Developers can also determine the dependence of some charts on others, or include some charts in the others.  Charts can be published or merged into a charts repository. <br><br>  Helm has two main components: the Helm command line interface and the Tiller server.  The command line assists in managing charts and repositories, and also interacts with Tiller to deploy these charts. <br><br>  Tiller is a component running in a cluster that communicates with the k8s server API to create and manage real objects.  He also plays the charts for the release assembly.  When the developer executes the <code>helm install &lt;chart-name&gt;</code> command, the client contacts the server and reports the name of the chart.  After that, Tiller finds a chart, creates a template and expands it in a cluster. <br><br>  Helm does not process the source code.  To create an image, you will need any CI / CD system, after which you can use Helm for deployment. <br><br><h3>  From scratch to k8s </h3><br>  Requirements: <br><br><ul><li>  cluster k8s; </li><li>  Helm CLI; </li></ul><br>  Example of deploying Wordpress in a k8s cluster using Helm: <br><br><pre> <code class="bash hljs">$ helm init $ helm repo update $ helm install stable/wordpress <span class="hljs-comment"><span class="hljs-comment">## make new version $ helm upgrade [release-name] [chart-name]</span></span></code> </pre> <br><h3>  Using </h3><br><ul><li>  Layout of complex applications (with many k8s objects). </li><li>  Reusable charts repository. </li><li>  Easy to deploy in multiple environments. </li><li>  Embedding Charts: Addictions. </li><li>  Patterns: easy parameter changes. </li><li>  Distribution and reusability. </li><li>  Deployment at the last stage: continuous delivery. </li><li>  Deploy an already created image. </li><li>  Joint update and rollback of multiple k8s objects - lifecycle management. </li></ul><br>  More detail <a href="http://helm.sh/">here</a> . <br><br><h2>  Ksonnet </h2><br>  <i>CLI-enabled infrastructure for creating flexible Kubernetes cluster configurations</i> <br><br>  The Ksonnet tool provides an alternative way to define application configuration for Kubernetes.  It uses jsonnet (JSON template creation language) instead of standard YAML files to define the k8s manifests.  The Ksonnet command line generates the final YAML file and then applies it to the cluster. <br><br>  Ksonnet is designed to identify components that can be reused when building applications. <br><br><h3>  Architecture </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zw/wo/q5/zwwoq5hhgowvrlqpayhk9qijdky.png" alt="image"></div><br>  <i>Ksonnet: Review</i> <br><br>  The main elements are called parts.  Combining parts, we create <i>prototypes</i> .  After adding parameters to the <i>prototype</i> , it becomes a component, and the components are grouped together to form an <i>application</i> .  <i>Applications</i> can be deployed in multiple <i>environments</i> . <br><br>  There are three main stages of Ksonnet: creating an application directory ( <code>ks init</code> command), automatic manifest generation (or writing your own) for a component ( <code>ks generate</code> command), deploying an application in a cluster / environment ( <code>ks apply &lt;env&gt;</code> command).  Various environments are managed using the <code>ks env</code> command. <br><br>  In short, Ksonnet helps manage applications as a group of components using Jsonnet, and then deploy them in various Kubernetes clusters. <br><br>  Like Helm, Ksonnet does not process source code.  This is a tool for defining applications for Kubernetes using Jsonnet. <br><br><h3>  From scratch to k8s </h3><br>  Requirements: <br><br><ul><li>  cluster k8s; </li><li>  Ksonnet CLI. </li></ul><br>  Guestbook example: <br><br><pre> <code class="bash hljs">$ ks init $ ks generate deployed-service guestbook-ui \ --image gcr.io/heptio-images/ks-guestbook-demo:0.1 \ --<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> ClusterIP $ ks apply default <span class="hljs-comment"><span class="hljs-comment">## make changes $ ks apply default</span></span></code> </pre><br><h3>  Using </h3><br><ul><li>  Flexibility in writing configurations through the use of Jsonnet. </li><li>  Layout: Complex applications can be assembled by combining and matching components. </li><li>  The prototype library and the ability to reuse components (eliminate duplication). </li><li>  Easy to deploy in multiple environments. </li><li>  Deployment at the last stage: the stage of continuous delivery. </li></ul><br>  More detail <a href="http://ksonnet.io/">here</a> . <br><br><h2>  Metaparticle </h2><br>  <i>Standard Library for Cloud Applications Running in Containers and Kubernetes</i> <br><br>  Metaparticle is a standard library for cloud applications.  It helps to apply standard patterns for the implementation of proven models of development of distributed systems using programming language interfaces. <br><br>  Metaparticle provides interfaces for idiomatic languages ‚Äã‚Äãthat help create systems that can containerize and deploy applications in Kubernetes, develop replicable load-balanced services, and much more.  There is no need to define a dockerfile or Kubernetes manifest.  Everything is processed using idioms characteristic of the programming language used. <br><br>  For example, to create a web application in Python, you need to add the <code>containerize</code> decorator (imported from the Metaparticle package) to the main function.  After execution of the Python code in the Kubernetes cluster, the docker image is assembled and deployed in accordance with the parameters specified in the decorator.  To connect to the cluster uses the standard context kubectl.  Thus, a change of environment will mean a change in the current context. <br><br>  Similar primitives are available for NodeJS, Java and .NET.  Work is underway to add support for more languages. <br><br><h3>  Architecture </h3><br>  The <code>Metaparticle</code> library for the corresponding language requires patterns and dependencies to create code in the form of docker images, send it to the registry, create k8s YAML files, and deploy to the cluster. <br><br>  <a href="http://github.com/metaparticle-io/package">The Metaparticle package</a> contains language idiomatic bindings for creating containers.  <a href="http://github.com/metaparticle-io/sync">Metaparticle Sync</a> is a library inside Metaparticle for synchronizing several containers running on different platforms. <br><br>  JavaScript / NodeJS, Python, Java and .NET are currently supported. <br><br><h3>  From scratch to k8s </h3><br><ul><li>  Requirements: </li><li>  cluster k8s; </li><li>  Metaparticle library for a supported language; </li><li>  Docker; </li><li>  Docker repository for storing images. </li></ul><br>  An example for Python (only the relevant part) is the creation of docker images and deployment in a k8s cluster: <br><br><pre> <code class="bash hljs">@containerize( <span class="hljs-string"><span class="hljs-string">'docker.io/your-docker-user-goes-here'</span></span>, options={ <span class="hljs-string"><span class="hljs-string">'ports'</span></span>: [8080], <span class="hljs-string"><span class="hljs-string">'replicas'</span></span>: 4, <span class="hljs-string"><span class="hljs-string">'runner'</span></span>: <span class="hljs-string"><span class="hljs-string">'metaparticle'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>: <span class="hljs-string"><span class="hljs-string">'my-image'</span></span>, <span class="hljs-string"><span class="hljs-string">'publish'</span></span>: True }) def main(): Handler = MyHandler httpd = SocketServer.TCPServer((<span class="hljs-string"><span class="hljs-string">""</span></span>, port), Handler) httpd.serve_forever()</code> </pre><br><h3>  Using </h3><br><ul><li>  Developing applications without the need for YAML or dockerfile files. </li><li>  You no longer need to learn many tools and file formats to take full advantage of containers and Kubernetes. </li><li>  The rapid development of replicable, load-balanced services. </li><li>  Synchronization management, for example, blocking and selection of master copies in distributed networks. </li><li>  Simple development of cloud patterns, such as segmented systems. </li></ul><br>  More detail <a href="http://metaparticle.io/">here</a> . <br><br><h2>  Skaffold </h2><br>  <i>Simple and repeatable development in Kubernetes</i> <br><br>  Skaffold manages the process of creating, storing and deploying applications in Kubernetes.  Skaffold, like Gitkube, allows you to deploy any directory with dockerfile in a k8s cluster. <br><br>  Skaffold creates a local docker image, sends it to the registry and deploys it using the <code>skaffold</code> command line <code>skaffold</code> .  It also monitors the status of the directory and, when the code inside it changes, builds and redeploys it.  In addition, it sends logs from containers. <br><br>  The process of creating, transmitting and deploying is configured using a YAML file, so the developer can use the most convenient combination of tools at these stages.  For example, you can choose docker build or Google Container Builder to create, kubectl or Helm to deploy, etc. <br><br><h3>  Architecture </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iw/5l/x1/iw5lx1nhaahchmgbf6izmsfpozm.png" alt="image"></div><br>  <i>Skaffold Review</i> <br><br>  Skaffold CLI does all the work.  We refer to the file <code>skaffold.yaml</code> , which defines the necessary actions.  A typical example is creating a docker image with a dockerfile in the directory where <code>skaffold dev</code> is <code>skaffold dev</code> , tagging with the sha256 hash, transferring the image, installing it into the k8s manifest pointing to the YAML file, and applying the manifest to the cluster.  This process runs continuously, responding to every change in the directory.  Logs from the running container are transferred to the same viewing window. <br><br>  Skaffold is very similar to Draft and Gitkube, but it is a more flexible tool, as it allows you to manage different chains of build-push-deploy processes, as shown in the example above. <br><br><h3>  From scratch to k8s </h3><br>  Requirements: <br><br><ul><li>  cluster k8s; </li><li>  Skaffold CLI; </li><li>  Docker; </li><li>  Docker repository for storing images. </li></ul><br>  Steps that must be performed to deploy an application that displays the string hello-world: <br><br><pre> <code class="bash hljs">$ git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/GoogleCloudPlatform/skaffold $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> examples/getting-started <span class="hljs-comment"><span class="hljs-comment">## edit skaffold.yaml to add docker repo $ skaffold dev ## open new terminal: edit code</span></span></code> </pre><br><h3>  Using </h3><br><ul><li>  Rapid deployment. </li><li>  Cyclic build is a continuous build / deploy cycle. </li><li>  Application Development at Kubernetes. </li><li>  Defining build-push-deploy chains in a CI / CD stream </li></ul><br>  More detail <a href="http://github.com/GoogleContainerTools/skaffold">here</a> . <br><br>  *** <br><br>  You can write to the author if he missed something or was mistaken somewhere.  The article does not mention tools like <a href="http://vapor-ware.github.io/ksync/">Ksync</a> and <a href="http://telepresence.io/">Telepresence</a> , since another article about them is planned in the near future.  But if you know about other useful tools belonging to the same category that are mentioned here, write about it in the comments. <br><br>  A discussion of the article on Hacker News can be found <a href="http://news.ycombinator.com/item%3Fid%3D16714984">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/353958/">https://habr.com/ru/post/353958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353948/index.html">Hijacking Telegram on Panic Waves</a></li>
<li><a href="../353950/index.html">Experiments on cats: how to increase the number of purchases in the application</a></li>
<li><a href="../353952/index.html">Issue # 19: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../353954/index.html">Experience using Megaplan API</a></li>
<li><a href="../353956/index.html">Learn OpenGL. Lesson 5.3 - Shadow Maps</a></li>
<li><a href="../353960/index.html">Money & Design. How to earn more than 200.000 ‚ÇΩ if you work alone</a></li>
<li><a href="../353962/index.html">Automate UI testing on PhoneGap. Payment application case</a></li>
<li><a href="../353966/index.html">New standards for passwordless authentication: how they work</a></li>
<li><a href="../353968/index.html">Why doesn‚Äôt the extension of a security staff result in increased security, and what to do</a></li>
<li><a href="../353970/index.html">May help</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>