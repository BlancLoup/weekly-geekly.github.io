<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Plasma Cash blockchain status data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear users! This article is about web 3.0 - the Internet with decentralization. Web 3.0 introduces the concept of decentralization as the basis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Plasma Cash blockchain status data structures</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear users!  This article is about web 3.0 - the Internet with decentralization.  Web 3.0 introduces the concept of decentralization as the basis for the modern Internet, many computer systems and networks need security features and decentralization for their needs.  The decentralization solution is called distributed registry or blockchain technology. <br><br><img src="https://habrastorage.org/webt/qd/nd/dv/qdnddvdk76wf5sy2ajwn38jp9w0.jpeg"><br><a name="habracut"></a><br>  Blockchain is a distributed registry.  It can be considered as a huge database that lives forever and does not change in history, the blockchain is used as a basis for decentralized web applications or services. <br><br>  In fact, the blockchain is not only a database, it is an opportunity to increase trust between network members with the ability to execute business logic on the network. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Byzantine consensus increases network reliability solves the problem of consistency <br>  The scalability that DLT introduces is changing existing business networks. <br><br>  Blockchain offers new very important benefits: <br><br><ol><li>  Prevent costly mistakes. </li><li>  Transparent transactions. </li><li>  Digitization for real goods. </li><li>  Smart contracts. </li><li>  Speed ‚Äã‚Äãand security of payments. </li></ol><br>  Opporty PoE is a project whose goal is to research cryptographic protocols and improve existing DLT and blockchain solutions. <br><br>  Most public distributed registry systems do not have scalability properties ‚Äî their throughput is rather low.  For example, ethereum processes only ~ 20 tx / s. <br>  Many solutions were created to increase the scalability property and not to lose decentralization (as you know, only 2 out of 3 can be: scalability, security, decentralization). <br><br>  One of the most effective is a sidechain solution. <br><br><h2>  Plasma concept </h2><br>  The concept is that the root chain handles a small number of commits from child chains, so that the root chain acts as the most secure and final layer for storing all intermediate states.  Each subsidiary chain functions as its blockchain with its own consensus algorithm, but there are several important caveats. <br><br><ul><li>  Smart contracts are created in the root chain and act as a checkpoint of the child chain in the root chain. </li><li>  A subsidiary chain is created, which functions as its own blockchain with its own consensus.  All states in the chain of child processes are protected by fraud proofs, which ensure that all state transitions are valid and apply a withdrawal protocol. </li><li>  Smart contracts specific to the dapp or child chain (application logic) can then be deployed in the child chain. </li><li>  The necessary funds can be transferred from the root chain to the child chain. </li></ul><br>  Validators have economic incentives to act honestly, and send commitments to the root chain - the final settlement transaction layer. <br><br>  As a result, dapp users working in the child chain should not interact with the root chain at all.  In addition, they can put their money in the root chain whenever they want, even if the child chain is hacked.  These exits from the child chain allow users to securely store their funds with Merkle proofs confirming ownership of a certain amount of funds. <br><br>  The main advantages of a plasma are related to its ability to significantly ease the calculations that currently overload the main chain.  In addition, the Ethereum blockchain can handle more extensive and more parallel data sets.  The time that is removed from the root chain is also transferred to Ethereum nodes, which receive lower processing and storage requirements. <br><br>  Plasma Cash is a design that gives online tokens unique serial numbers that turn them into unique tokens.  The advantages of this include no need for confirmations, simpler support for all types of tokens (including Non-fungible tokens), and mitigation against mass exits from the child chain. <br><br>  The plasma problem is related to the concept of ‚Äúmass exits‚Äù from the child chain.  In this scenario, coordinated withdrawal from a child chain at the same time could potentially lead to a lack of computing power to withdraw all funds.  As a result, users may lose funds. <br><br><h2>  Plasma Implementation Options </h2><br><img src="https://habrastorage.org/webt/vq/qg/hr/vqqghr_ucnoum3q8o1b215zgcic.png"><br><br>  Basic plasma has a lot of options for implementation. <br><br>  The main differences are: <br><br><ul><li>  storing information about the method of storage and presentation of the state, </li><li>  types of tokens (divisible indivisible), </li><li>  transaction security </li><li>  type of consensus algorithm, etc. </li></ul><br>  The main variations of plasma: <br><br><ul><li>  UTXO based - each transaction consists of inputs and outputs: a transaction can be performed and spent, the list of transactions not spent is the state of the child chain itself. </li><li>  Account based - simply contains a reflection of each account-account and its balance, this type is used in ethereum, since each account can be of two types - a user account and a smart contract account.  The advantage of this type of state storage is its simplicity, and the minus is that this option is not scalable (the special nonce property is used so that the transaction is not performed twice). </li></ul><br>  The purpose of this article is to explain the data structures used in the Plasma Cash blockchain. <br><br>  In order to understand exactly how commitments work, it is necessary to clarify the concept of the Merkle tree. <br><br><h2>  Merkle Trees their use in Plasma </h2><br>  Merkle trees are an extremely important data structure in the blockchain world.  In essence, Merkle trees give us the ability to capture a certain set of data in a way that hides the data, but allows users to prove that some of the information was in the set.  For example, if I have ten numbers, I can create proof for these numbers, and then prove that one particular number was in this set of numbers.  This proof has a small constant size, which makes it cheap to publish in Ethereum. <br><br>  You can use this for a set of transactions.  You can also prove that a particular transaction is in this transaction set.  This is exactly what the operator is doing.  Each block consists of a set of transactions that turn into a Merkle tree.  The root of this tree is proof, which is published in Ethereum along with each plasma block. <br><br>  Users should be able to withdraw their funds from the plasma chain. When users want to exit the plasma chain, they send an ‚Äúexit‚Äù transaction to Ethereum. <br><br>  Plasma Cash use special Merkle Tree which makes it possible not to validate the whole block, but to validate only those branches that correspond to the user's token. <br><br>  That is, to transfer a token, you need to go through the history and scan only those tokens that are needed by a certain user, when transferring a token, the user simply transfers the entire history to another user and he can already authenticate the entire history - and most importantly do it very quickly. <br><br><img src="https://habrastorage.org/webt/wx/is/3z/wxis3zgyhtyh-ruopuffedzcwsk.png"><br><br><h2>  Plasma Cash data structures for state and history storage </h2><br>  Nevertheless, it is necessary to use only some merkla trees, because it is necessary to obtain proof of inclusion as well as evidence of non-inclusion of the transaction in the block, for example - <br><br><ul><li>  Sparse merkle tree </li><li>  Patricia trie </li></ul><br>  Opporty has implemented its Sparse Merkle Tree and Patricia Trie implementations. <br><br>  A sparse Merkle tree is similar to a standard Merkle tree, except that the data it contains is indexed and each data point is placed on a sheet that corresponds to the index of this data point. <br><br>  Suppose we have a four-leaf merkle tree.  We will fill this tree with several letters (A, D) for demonstration.  The letter A is the first letter of the alphabet, so we must put it on the first sheet.  Similarly, we can put D on the fourth sheet. <br><br>  So what happens in the second and third leaves?  We just leave them empty.  More precisely, a special value is placed (for example, zero) instead of placing a letter. <br><br>  The tree eventually looks like this: <br><br><img src="https://habrastorage.org/webt/5g/9g/18/5g9g18uvkq5oizxi81z8pbeij48.png"><br><br>  The proof of inclusion works in the same way as in a normal merkle tree. What happens if we want to prove that C is not part of this Merkle tree?  It's simple!  We know that if C were part of a tree, it would be on the third sheet.  If C is not part of the tree, then the third sheet must be zero. <br><br>  All that is needed is the standard proof of Merkle's inclusion, showing that the third sheet is zero. <br><br>  The best part of the sparse Merkle tree is that they really represent the keysto-value repositories inside the Merkle tree! <br><br>  Here is part of the PoE protocol code that implements the construction of the Sparse Merkle Tree <br><br><pre><code class="plaintext hljs">class SparseTree { //... buildTree() { if (Object.keys(this.leaves).length &gt; 0) { this.levels = [] this.levels.unshift(this.leaves) for (let level = 0; level &lt; this.depth; level++) { let currentLevel = this.levels[0] let nextLevel = {} Object.keys(currentLevel).forEach((leafKey) =&gt; { let leafHash = currentLevel[leafKey] let isEvenLeaf = this.isEvenLeaf(leafKey) let parentLeafKey = leafKey.slice(0, -1) let neighborLeafKey = parentLeafKey + (isEvenLeaf ? '1' : '0') let neighborLeafHash = currentLevel[neighborLeafKey] if (!neighborLeafHash) { neighborLeafHash = this.defaultHashes[level] } if (!nextLevel[parentLeafKey]) { let parentLeafHash = isEvenLeaf ? ethUtil.sha3(Buffer.concat([leafHash, neighborLeafHash])) : ethUtil.sha3(Buffer.concat([neighborLeafHash, leafHash])) if (level == this.depth - 1) { nextLevel['merkleRoot'] = parentLeafHash } else { nextLevel[parentLeafKey] = parentLeafHash } } }) this.levels.unshift(nextLevel) } } } }</code> </pre> <br>  This code is quite trivial.  We have a key-value repository with proof of inclusion / non-inclusion. <br><br>  In each iteration, a specific level of the final tree is filled, starting with the most recent one.  Depending on which key of the current sheet is even or odd, we take two adjacent sheets and count the hash of the current level.  If we reach the end, we write a single merkleRoot - a common hash. <br><br>  You must understand that this tree is already filled with initially empty values!  And if we store a huge amount of IDS token.  we have a huge tree size and it is generated for a very long time! <br><br>  There are many solutions to this non-optimization, but Opporty decided to change this tree to Patricia Trie. <br><br>  Patricia Trie is a connection from Radix Trie and Merkle Trie. <br><br>  Radix Trie data key will store the data path itself!  This allows you to create an optimized data structure for the memory! <br><br><img src="https://habrastorage.org/webt/af/zc/ly/afzclyhgeydkylbnn5hrjj0gs-g.png"><br><br><h3>  Opporty implementation </h3><br><pre> <code class="plaintext hljs">buildNode(childNodes, key = '', level = 0) { let node = {key} this.iterations++ if (childNodes.length == 1) { let nodeKey = level == 0 ? childNodes[0].key : childNodes[0].key.slice(level - 1) node.key = nodeKey let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(nodeKey)), childNodes[0].hash]) node.hash = ethUtil.sha3(nodeHashes) return node } let leftChilds = [] let rightChilds = [] childNodes.forEach((node) =&gt; { if (node.key[level] == '1') { rightChilds.push(node) } else { leftChilds.push(node) } }) if (leftChilds.length &amp;&amp; rightChilds.length) { node.leftChild = this.buildNode(leftChilds, '0', level + 1) node.rightChild = this.buildNode(rightChilds, '1', level + 1) let nodeHashes = Buffer.concat([Buffer.from(ethUtil.sha3(node.key)), node.leftChild.hash, node.rightChild.hash]) node.hash = ethUtil.sha3(nodeHashes) } else if (leftChilds.length &amp;&amp; !rightChilds.length) { node = this.buildNode(leftChilds, key + '0', level + 1) } else if (!leftChilds.length &amp;&amp; rightChilds.length) { node = this.buildNode(rightChilds, key + '1', level + 1) } else if (!leftChilds.length &amp;&amp; !rightChilds.length) { throw new Error('invalid tree') } return node }</code> </pre><br>  That is, we go through recursively and build separate left and right subtrees.  At the same time building the key as the path in this tree! <br><br>  This solution is even more trivial and works faster while being quite optimized!  In fact, the Patricia tree should still be more optimized by introducing new node types ‚Äî extension node, branch node, and so on, as done in the ethereum protocol, but this implementation satisfies all of our conditions ‚Äî we got a fast and memory-optimized data structure. <br><br>  By implementing these data structures, Opporty made Plasma Cash scaling possible as it allows you to check the history of the token and enable the non-inclusion of the token in the tree!  That allows you to greatly accelerate the validation of the blocks and the Plasma Child Chain itself. <br><br><h3>  Useful links: </h3><br><ol><li>  <a href="https://plasma.io/plasma.pdf">White paper plasma</a> </li><li>  <a href="https://github.com/opporty-com/Plasma-Cash">Git hub</a> </li><li>  <a href="https://clever-solution.com/case-studies/scalability-opporty-plasma-cash">Use cases and architecture description</a> </li><li>  <a href="https://lightning.network/lightning-network-paper.pdf">Lightning network paper</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/456374/">https://habr.com/ru/post/456374/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456362/index.html">Level 6 designer: how we motivate and develop designers</a></li>
<li><a href="../456366/index.html">How I was creating the LED HEART box</a></li>
<li><a href="../456368/index.html">Perform public and private transactions on the JPMorgan Quorum blockchain using Web3</a></li>
<li><a href="../456370/index.html">QoS implementation in Qsan storage</a></li>
<li><a href="../456372/index.html">SimbirSoft invites IT-specialists to the Summer Intensive-2019</a></li>
<li><a href="../456376/index.html">Not a single spring boot: review alternatives</a></li>
<li><a href="../456380/index.html">Open Day at the Faculty of Programming in Netology</a></li>
<li><a href="../456382/index.html">Collaboration and automation in the frontend. What we have learned for 13 schools</a></li>
<li><a href="../456386/index.html">Open libraries for visualizing audio content</a></li>
<li><a href="../456388/index.html">Diagram of the development of diagnostic capabilities in PVS-Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>