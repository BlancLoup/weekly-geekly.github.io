<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Breathalyzer from facebook</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone knows the social network facebook . Many have heard of some programmer tasks published by the administration of this network in order to sear...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Breathalyzer from facebook</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/579/6e0/d39/5796e0d397deb38f4f9a3ed794362418.jpg" alt="Picture to attract attention"><br>  Everyone knows the social network <a href="http://facebook.com/">facebook</a> .  Many have heard of some <a href="http://www.facebook.com/careers/puzzles.php">programmer tasks</a> published by the administration of this network in order to search for programmers in their office (although, judging by the comments on the forum, this practice has long been suspended).  Some tried to solve these puzzles.  Some have even succeeded.  But only a few shared their experience in this.  And the experience, I must say, is very, very useful.  Gathering my thoughts, I decided to slightly correct this omission. <br><br>  <i>A small disclaimer:</i> This article will not be a beautiful code, following the principles of the PLO, compliance with adopted conventions and other things that are popular nowadays.  It is always possible to have time to nicely refactor a working code, and the task solved during the article is to write the actual working code. <br><br>  So, breathalyzer.  He is a <a href="http://www.facebook.com/careers/puzzles.php%3Fpuzzle_id%3D17">breathalyzer</a> .  This is a snack-complexity task according to facebook classification, i.e.  by their standards, it is not complicated at all.  That did not stop me from spending a good couple of weeks on its decision (partly because of the fundamental desire to solve it in Ruby).  I did the second task in turn, and it was she who prompted me to the main idea, which prompted me to put a lot of effort into finding a solution.  And the idea was as follows - I do not know how to program ... <br><a name="habracut"></a><br>  Yes.  I graduated from a completely not bad technical university in an IT specialty. I have been earning Delphi programming for several years, I am writing web applications on RoR at my leisure for my own development and improvement of CSR, but I have not learned to program it.  What prompted me to this thought?  Let's see together. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Conditions of the problem </h4><br>  So you are a facebook programmer, which in itself is not bad.  The administration of the social network began to be disturbed by the problem of a large number of messages on the walls written by drunk people (which they themselves sometimes regret), and therefore you are given the task of organizing an online breathalyzer to determine the degree of intoxication of a person according to his written text.  The number of messages sent to the walls of the social network is too large to moderate all of them manually.  However, a good programmer is not a hindrance - the process can be automated. <br>  The terms are simple.  If we omit the details regarding the formatting of source texts and results, as well as the target area of ‚Äã‚Äãapplication of the code, then the program will be given some text with errors and a dictionary of correct words.  The task is to calculate the number of errors in each word and display the total amount of errors for the text.  The number of errors is calculated by the number of corrections that need to be made to a word in order to bring it into full compliance with one of the words in the dictionary.  The corrections are: inserting one letter, deleting one letter, replacing one letter with any other.  Hmm ... it's not immediately clear how to count this, but okay, the eyes are afraid, and the hands are hooks.  Go.  Oh yeah, an important addition to the conditions of the assignment states that the program must be effective in time. <br><br><h4>  Decision.  Iteration 1 </h4><br>  The first problem to be solved is the actual counting of errors in the word.  A quick search on Google shows that everything has already been invented before us, and the quantitative indicator of the difference in words for given conditions is called the ‚ÄúLevenshtein distance‚Äù.  The description of the algorithm for finding this distance has already been <a href="http://habrahabr.ru/blogs/algorithm/114997/">encountered</a> on Habr√©, so I will not dwell on it in detail; I will give its implementation in Ruby.  So, the heart of our decision is as follows: <br><pre><code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_levenshtein_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s,t)</span></span></span></span> n = s.length m = t.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span> d = Array.new(n+<span class="hljs-number"><span class="hljs-number">1</span></span>).map!{Array.new(m+<span class="hljs-number"><span class="hljs-number">1</span></span>)} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..n d[i][<span class="hljs-number"><span class="hljs-number">0</span></span>]=i <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..m d[<span class="hljs-number"><span class="hljs-number">0</span></span>][j]=j <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s[i-<span class="hljs-number"><span class="hljs-number">1</span></span>]==t[j-<span class="hljs-number"><span class="hljs-number">1</span></span>] cost=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> cost=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> d[i][j] = [d[i-<span class="hljs-number"><span class="hljs-number">1</span></span>][j]+<span class="hljs-number"><span class="hljs-number">1</span></span>, d[i][j-<span class="hljs-number"><span class="hljs-number">1</span></span>]+<span class="hljs-number"><span class="hljs-number">1</span></span>, d[i-<span class="hljs-number"><span class="hljs-number">1</span></span>][j-<span class="hljs-number"><span class="hljs-number">1</span></span>] + cost].min <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d[n][m] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><br>  The link to the dictionary is given in the conditions of the problem (just in case I <a href="http://static.terribles.ru/twl06.txt">duplicate</a> ), several examples of source texts for testing are posted by the participating enthusiasts on the forum ( <a href="">187.in</a> , <a href="">david_22719.in</a> , <a href="">4.in</a> , <a href="">12.in</a> ), you can proceed.  Things are easy.  We read the entire dictionary (since it is conveniently formatted by the word on each line and sorted alphabetically), we read the source text, we start a cycle: for each word from the source text we are looking for the closest word in the dictionary.  How are we looking?  We run around the dictionary, swinging the Levenshtein distance search function: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word, dic)</span></span></span></span> result_word = <span class="hljs-string"><span class="hljs-string">''</span></span> result_cost = <span class="hljs-number"><span class="hljs-number">999</span></span> dic.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|dic_word|</span></span> ld = calc_levenshtein_distance(word, dic_word) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ld&lt;result_cost result_word = dic_word result_cost = ld <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; result_word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; result_cost} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  The main body of the program minus the reading of dictionaries: <br><pre> <code class="ruby hljs">total_cost = <span class="hljs-number"><span class="hljs-number">0</span></span> words.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|word|</span></span> total_cost += find_word(word, dic_words)[<span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  The full text of the first option can be found <a href="">here</a> .  This is where the first doubts have already visited me, but okay, the first launch with my favorite test file in the future (almost all iterations I checked first on the <i>187.in</i> file) ... Hmm.  After a ten-minute wait, it became clear that this program would hardly be considered effective in time. <br><br>  Well, it is necessary to look for where the brake was dug.  So, the main part of the program is the Levenshtein distance search function, wrapped in two cycles - according to the words of the incoming text and the dictionary.  A dictionary contains nearly 180 thousand words.  There is something to work hard ... <br><br><h4>  Decision.  Iteration 2 </h4><br>  To begin with we will make the simplest optimization.  First, if the considered word is present in the dictionary without changes, then without further ado, we will assume the number of errors in it to be zero. <br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(word)</code> </pre><br>  Secondly, in some examples there are repeated words, therefore for each considered word we will save search results: <br><pre> <code class="ruby hljs">res = already_found.<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(word) ? already_found[word] : find_word(word, dic_words) already_found[word] <span class="hljs-params"><span class="hljs-params">||</span></span>= res</code> </pre><br>  Third, add a debug output.  According to the condition of the task, the program should print a single number in the console, but for work it will be nice to see a little more information (the full text of the second version is <a href="">here</a> ).  This iteration allowed us to achieve a relatively sane runtime of the program on the <i>4.in</i> and <i>12.in</i> input files (about three minutes on my home computer) and, equally important, to get the correct results.  Wait for execution <i>187.in</i> is still not easy, even despite the output to the console of each word being processed.  Well, at least we can be sure that our program is working properly.  For now. <br><br><h4>  Decision.  Iteration 3 </h4><br>  The conditions of the problem state that you can correct errors in words only in three ways: add a letter, remove a letter, replace a letter with any other.  From this follows the fact that words differing in length by 1 have a Levenshtein distance of at least 1 between themselves. What does this give?  We can break the dictionary into groups according to the length of words.  Analyzing the next word from the incoming text, we can begin to search the dictionary with those words that are identical to the one being considered in length, continue with those that are at 1, and so on.  As soon as the difference in length exceeds the current minimum distance found, we will know that there is no need to continue. <br><br>  First, we construct a dictionary of the required structure: <br><pre> <code class="ruby hljs">dictionary = {} dic_words.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|w|</span></span> dictionary[w.length] <span class="hljs-params"><span class="hljs-params">||</span></span>= [] dictionary[w.length] &lt;&lt; w <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Then we will modify the dictionary search function with a file so that it goes through the words in the necessary order: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word, dic)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic[word.length] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic[word.length].<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(word) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> result_word = <span class="hljs-string"><span class="hljs-string">''</span></span> result_cost = <span class="hljs-number"><span class="hljs-number">999</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> offset <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; result_word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; result_cost} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> result_cost&lt;=offset indexes = [word.length-offset,word.length+offset].uniq indexes.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|index|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unless</span></span> dic[index] dictionary_part = dic[index] dictionary_part.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|dic_word|</span></span> ld = calc_levenshtein_distance(word, dic_word) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ld&lt;result_cost result_word = dic_word result_cost = ld <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; result_word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; result_cost} <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Hooray!  Program execution on files <i>12.in</i> and <i>4.in was</i> reduced to 70 seconds (the full text is searched <a href="">here</a> ).  And even it turned out to wait for the execution results on the file <i>187.in</i> - about 17 minutes.  As my math teacher said, it's better already, but for now two.  The <i>david_22719.in</i> file is still inaccessible. <br><br><h4>  Decision.  Iteration 4 </h4><br>  Forgive me Ruby-ists and lovers of other interpreted languages, but somewhere at this stage I realized that in tasks that are critical to the time of execution, such s <s>..</s> cope poorly.  Somewhere in this stage, I implemented the task in C and realized.  The bruteforce of each word throughout the dictionary for the file <i>187.in was</i> executed in seconds.  In a few minutes the program mastered even the file <i>david_22719.in</i> .  Posted by facebook bot decision returned with the note: <br><blockquote>  After running your solution to a breathalyzer (received on January 18, 2011, 10:40 am), I have determined.  Your solution ran for 1585.775 ms on its longest test case. </blockquote><br><br>  The solution in Ruby returned time after time with a note <br><blockquote>  Thank you for your puzzle!  After running your solution to a breathalyzer (received on January 18, 2011, 12:20 pm), I‚Äôve been able to find out. </blockquote><br><br>  Well, that means it's time to look for other ways to improve.  The heart of the program is the Levenshtein distance calculation function, for which there is more than one algorithm, but all of them except the simplest ... how to say it ... are somewhat nontrivial.  Having rummaged some hours, I decided to look for other solution.  And found.  Unfortunately, I can‚Äôt find a link right now, it was painful for a long time, but the idea was to make a list of all possible first-order errors for a given word and check if there is at least one of them in the dictionary.  The function of compiling a list of typos: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_possible_edits</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word)</span></span></span></span> letters = <span class="hljs-string"><span class="hljs-string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span>.split(<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>) res = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(word.length-<span class="hljs-number"><span class="hljs-number">1</span></span>) str = String.new(word) str[i] = <span class="hljs-string"><span class="hljs-string">''</span></span> res &lt;&lt; str <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> letters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(word.length-<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> word[i]==c str = String.new(word) str[i]=c res &lt;&lt; str <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> letters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(word.length) str = String.new(word).insert(i,c) res &lt;&lt; str <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  And add the lines to the dictionary search function: <br><pre> <code class="ruby hljs"> minimum_errors = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#     ,        edits = get_possible_edits(word) edits.each do |edit| return {:word =&gt; edit, :cost =&gt; 1} if dic[edit.length] ? dic[edit.length].include?(edit) : false end minimum_errors = 2 #          ,       </span></span></code> </pre><br><br>  Well, the further search for the solution will be truncated taking into account the fact that in this word there is exactly at least one error (since we have already considered all the options with one error): <br><pre> <code class="ruby hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> offset <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; result_word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; result_cost} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((result_cost&lt;=offset) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (result_cost&lt;=minimum_errors)) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Such changes made it possible to improve the result of running <i>187.in</i> to 14 minutes, <i>12.in</i> to 64 seconds, and <i>4.in</i> is executed in a fraction of a second (which is not surprising, there are no words with more than one error in it).  Little win  Now you can go even further and calculate the error to the second order using the same method.  However, it should be understood that the number of possible first-level errors increases geometrically with increasing length of the word in question, and the number of second-level errors increases quadratically with the number of first-level errors.  So, if we just add a piece of code: <br><pre> <code class="ruby hljs"> edits.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|edit|</span></span> edits2 = get_possible_edits(edit) edits2.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|edit2|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; edit2, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic[edit2.length] ? dic[edit2.length].<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(edit2) : <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> minimum_errors = <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  then with extraordinary ease we will increase the program execution time on the <i>input</i> file <i>12.in</i> ten times.  This algorithm is advisable to use in short words.  Experimentally, I found that the greatest gains from it can be obtained by considering them words no longer than six characters: <br><pre> <code class="ruby hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> word.length&lt;=<span class="hljs-number"><span class="hljs-number">6</span></span> edits.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|edit|</span></span> edits2 = get_possible_edits(edit) edits2.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|edit2|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; edit2, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic[edit2.length] ? dic[edit2.length].<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(edit2) : <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> minimum_errors = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  On the 187.in file, this element allows you to play even about 10% of the execution time.  At this point, all the trivial optimizations end, which means it's time to plunge into math. <br><br><h4>  Decision.  Iteration 5 </h4><br>  Lowenstein's distance is not a new thing in mathematics, and many algorithms have been invented to find it, however, to understand their work, you need good mathematical preparation, endless time and unshakable confidence that somewhere in your family were Olympian gods.  I spent more than one evening, sorting out mathematical-algorithmic calculations, eventually settled on <a href="http://algolist.manual.ru/search/lcs/ukkonen.php">the Ukkonen algorithm</a> . <br><br>  Here, before writing code, you will have to speculate a little with the use of mathematics.  I'm not sure that I understand its essence correctly, especially since the literal implementation of the algorithm described there did not work for me.  But I can tell you what I understood, and what works. <br><br>  Imagine the Levenshtein distance calculation table.  For simplicity, we consider the case when it is horizontally longer than vertically (we do not lose generality, because we can always just change the word order).  We are interested in the value in the lower right cell of the table.  According to the algorithm, it is calculated last.  But it turns out that it is not at all necessary to count the entire table to get this value!  The essence of the Ukkonen method is that several diagonals are calculated.  Which diagonals to calculate and how to choose them correctly?  This is the main question. <br><br>  Let's call the main diagonal the one that comes out of the upper left corner.  If the number of letters in the compared words coincides, then it also rests on our desired lower right corner.  This diagonal is always calculated, regardless of anything.  How many diagonals are needed?  I am not ready to give a mathematical justification, but empirically I found out that there should be at least three diagonals. <br><br>  If the difference in the length of words is at least two characters, then all the diagonals to the right of the main one are calculated, up to the one that displays the solution in the lower right corner (remember, we assume that with different lengths of words, the longer one is written horizontally). <br><br><img src="http://habrastorage.org/getpro/habr/post_images/3c1/d15/c0d/3c1d15c0de6c476c5ad2cc1041b67244.png" alt="Calculation with different lengths of words"><br><br>  If the words differ in length by one letter, then an additional one diagonal is added to the left of the main one, if the words are the same in length, then one diagonal is added to the left and right of the main one: <br><br><img src="http://habrastorage.org/getpro/habr/post_images/c8b/6a7/467/c8b6a7467c2d37d6be958d389835e609.png" alt="Calculation with the same length of words"><br>  In the illustrations, the main diagonal is highlighted in green, calculated in yellow, the solution in red. <br><br>  Each step of the calculation function of the table calculates the value of the new cell as the minimum of the three surrounding it (plus the transition cost coefficients), so that the missing cells of the table do not affect the course of the calculation, you need to initialize them with some obviously large number, for example 50. The left upper cell, as before, is initialized by zero.  In code, it looks like this: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a,b,c)</span></span></span></span> m = a &lt; b ? a : b <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &lt; c ? m : c <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_levenshtein_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s,t)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> calc_levenshtein_distance(t,s) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s.length&lt;t.length n = s.length m = t.length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span> d = Array.new(m+<span class="hljs-number"><span class="hljs-number">1</span></span>).map!{Array.new(n+<span class="hljs-number"><span class="hljs-number">1</span></span>).map!{<span class="hljs-number"><span class="hljs-number">50</span></span>}} d[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]=<span class="hljs-number"><span class="hljs-number">0</span></span> p = (n==m) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">#   q = (nm&lt;=1)? 1 : 0 #   for j in 1..[(n-m+p),n].min d[0][j]=d[0][j-1]+1 end for i in 1..m do for j in (i - q)..[(i + n - m + p),n].min do if j==0 d[i][j] = d[i-1][j]+1 else cost = 1 cost = 0 if t[i-1] == s[j-1] d[i][j] = min3(d[i-1][j] + 1 , d[i][j-1] + 1 , d[i-1][j-1] + cost) end end end return d[m][n] end</span></span></code> </pre><br><br>  Improvements are evident, <i>187.in</i> is executed in just 6 minutes, and <i>12.in</i> - in 25 seconds.  But still, it would be good to come up with something else.  The full text of the fifth iteration is <a href="">here</a> . <br><br><h4>  Decision.  Iteration 6 </h4><br>  How else can you accelerate a function that is already accelerated as much as possible?  Well, for example, you can simply not call it.  It is not necessary to consider the Levenshtein distance for those words that obviously do not coincide by an amount not less than that already found.  That's just how to calculate this value, and even faster than the Levenshtein distance to get some speed gain?  I do not pretend to be ideal, but I managed to come up with something.  I decided to store for each word an array of 26 values, each of which showed how many times the corresponding letter of the English alphabet occurs in a given word.  The difference between two words using these arrays can be calculated as the sum of the differences of the corresponding values ‚Äã‚Äãof the arrays: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arr_diff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a1,a2)</span></span></span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> res += (a1[i]-a2[i]).abs <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Such a difference, of course, is even more abstract than the Levenshtein distance, but it can be calculated more quickly.  How can she help?  How can the Levenshtein distance be related to the difference of such hashes?  The most important connection is that adding and removing a single letter in a word adds one to both of these values.  If in the word to swap two letters, then the Levenshtein distance of the new word from the original one will be 2, although the difference of the corresponding arrays will be zero, since  the composition of the letters is preserved.  And if we change a letter in a word to any other, then the difference of the arrays will increase by 2, while the Levenshtein distance is only 1. Thus, the limitation on the difference of arrays <i>from below is</i> rather weak: minus the length difference in the word, there can be as many permutations letters that lead to an increase in the Levenshtein distance, but not to an increase in the difference of arrays (the only lower constraint that we can impose is one, in case the minimum number of errors in a word is odd, because an odd number of errors by Leven  matte cannot be achieved by permutations of letters), and <i>from above</i> - the difference of the arrays cannot exceed the Levenshtein double distance. <br><br>  Based on the foregoing, we can say that for two words with the Levenshtein distance <b>diff</b> and the difference in length by <b>offset the</b> difference of the arrays will lie in the interval <b>[offset, 2 * diff - offset]</b> .  In fact, to limit the bottom, you can also use an estimate of the minimum number of errors in a word (for example, if we did not find the word by searching all first-order typos, then we can say that there are at least two errors in it).  If the difference in the minimum number of errors and the difference in the length of words is odd (that is, in addition to the difference in length in the word, the minimum of N errors and N are odd), then the minimum possible difference in the arrays of words can be increased by one - <b>[offset + (min_errors - offset )% 2, 2 * diff - offset]</b> (in the case of even N, no additional constraints can be imposed, because an even number of Levenshtein errors can be achieved by permutations of letters that do not affect the difference of arrays). <br><br>  Let us try to use this knowledge to filter the words given to the Levenshtein distance calculation function.  We will consider arrays for vocabulary words not immediately when reading a dictionary, but as necessary, in order not to make unnecessary calculations for short input files, during reading we will only initialize the corresponding arrays: <br><pre> <code class="ruby hljs">dictionary = {} dic_words.each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|w|</span></span> dictionary[w.length] <span class="hljs-params"><span class="hljs-params">||</span></span>= {} dictionary[w.length][w] = Array.new(<span class="hljs-number"><span class="hljs-number">26</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  At each comparison of the current word with the dictionary we know the result of the previous comparison.  If we have already found a word with a distance from the desired one in 3, then we are no longer interested in words with a greater distance, so we can impose restrictions on the difference of the corresponding word arrays.  The dictionary search function in this case will look like this: <br><pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_word</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(word, dic)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic[word.length] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:word</span></span> =&gt; word, <span class="hljs-symbol"><span class="hljs-symbol">:cost</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dic[word.length].<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>?(word) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> minimum_errors = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#     ,        edits = get_possible_edits(word) edits.each do |edit| return {:word =&gt; edit, :cost =&gt; 1} if dic[edit.length] ? dic[edit.length].include?(edit) : false end minimum_errors = 2 #          ,        if word.length&lt;=6 edits.each do |edit| edits2 = get_possible_edits(edit) edits2.each do |edit2| return {:word =&gt; edit2, :cost =&gt; 2} if dic[edit2.length] ? dic[edit2.length].include?(edit2) : false end end minimum_errors = 3 end result_word = '' result_cost = 999 wordhash = Array.new(26,0) word.each_byte{|b| wordhash[b-65]+=1} for offset in 0..15 do return {:word =&gt; result_word, :cost =&gt; result_cost} if ((result_cost&lt;=offset) or (result_cost&lt;=minimum_errors)) indexes = [word.length-offset,word.length+offset].uniq indexes.each do |index| next unless dic[index] dictionary_part = dic[index] if dictionary_part[dictionary_part.keys.first].max==0 #       ,    dictionary_part.each do |key, val| key.each_byte{|b| val[b-65]+=1} end end lower_bound = (minimum_errors-offset&gt;0 ? minimum_errors-offset : 0).abs%2 + offset higher_bound = 2*result_cost - offset dictionary_part.each do |dic_word, dic_wordhash| a = arr_diff(dic_wordhash,wordhash) next if a&lt;lower_bound or a&gt;higher_bound ld = calc_levenshtein_distance(word, dic_word) if ld&lt;result_cost result_word = dic_word result_cost = ld higher_bound = 2*result_cost - offset end end end end return {:word =&gt; result_word, :cost =&gt; result_cost} end</span></span></code> </pre><br><br>  Thus it turns out to achieve the execution of the file <i>187.in</i> in 66 seconds ( <i>12.in</i> - 5.5 seconds).  This is quite good compared to the time shown (or rather, not shown) by the first version of the program and even allows, after waiting a couple of hours, to see the solution for the file <i>david_22719.in</i> , but as it turned out, not enough to go through the facebook bot. <br><br><h4>  Decision.  Iteration 7 </h4><br>  But then I blunted.  I didn‚Äôt master any accelerated execution algorithmically, so I had to resort to purely technical tools based on the features of Ruby in general and version 1.8.6 in particular.  For example, experimentally, I found that the ternary operator (a? B: c) runs faster than the traditional if-else.  I learned that ugly calculations in one line can win a fraction of a second from the option of creating temporary variables.  Disproved the myth that short variable names speed up the process.  I found out that parsing a whole file with a regular expression works faster than line-by-line reading ... Many hours of licking code trying to remove some extra object initialization or unnecessary memory allocation allowed me to knock a couple more seconds off of time, but it still wasn't enough to go through the bot.  And then I gave up. <br><br><h4>  Decision.  White flag </h4><br>  I decided to give up not quite in the sense that they usually invest in it.  I have abandoned the idea of ‚Äã‚Äãsolving a Ruby problem.  At least, in pure Ruby ... Yes, you understood correctly, I decided to cheat a little and turn to power C. Having smoked the corresponding manuals for a couple of hours, I wrote a Ruby extension that counts the Levenshtein distance for two lines: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ruby.h&gt; #ifndef max #define max( a, b ) ( ((a) &gt; (b)) ? (a) : (b) ) #endif #ifndef min #define min( a, b ) ( ((a) &lt; (b)) ? (a) : (b) ) #endif void Init_levenshtein(); VALUE distance(VALUE self, VALUE rwm, VALUE rwn); void Init_levenshtein() { VALUE cLevenshtein = rb_define_class("Levenshtein",rb_cObject); rb_define_singleton_method(cLevenshtein, "distance", distance, 2); } VALUE distance(VALUE self, VALUE rwm, VALUE rwn) { char *wm, *wn; int res; wm = StringValuePtr(rwm); wn = StringValuePtr(rwn); res = LeveDist(wm,wn); return INT2NUM(res); } int min3(int a, int b, int c) { int Min = a; if (b &lt; Min) Min = b; if (c &lt; Min) Min = c; return Min; } int LeveDist(char *s, char *t) { char* wm; char* wn; int m, n, q, p, cost, i, j; int loop1, loop2; char* d; int res = -1; if (strlen(s) &gt; strlen(t)) { wm = t; wn = s; } else { wm = s; wn = t; } m = strlen(wm); n = strlen(wn); d = calloc((m + 1)*(n + 1),sizeof(char)); memset(d, 50, (m + 1)*(n + 1)); p = (n==m) ? 1 : 0; q = (nm&lt;=1)? 1 : 0; *d = 0; loop1 = min(n, n - m + p); for (j = 1; j &lt;= loop1; j++) *(d + j) = *(d + j - 1) + 1; for (i = 1; i &lt;= m; i++) { loop2 = min(n, i + n - m + p); for (j = (iq); j &lt;= loop2; j++) { if (j == 0) { *(d + i * (n + 1) + j) = *(d + (i - 1)*(n + 1) + j) + 1; } else { cost = 1; if (*(wm + i - 1) == *(wn + j - 1)) cost = 0; *(d + i * (n + 1) + j) = min3(*(d + (i - 1)*(n + 1) + j) + 1, *(d + i * (n + 1) + j - 1) + 1, *(d + (i - 1)*(n + 1) + j - 1) + cost); } } } res = *(d + m * (n + 1) + n); free(d); return res; }</span></span></span></span></code> </pre><br><br>      : <br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'levenshtein'</span></span> ... Levenshtein.distance(word,dic_word)</code> </pre><br>   ,    ,    ,   ,        (       ). <br><br><h4>  Decision.  Victory! </h4><br>  ,     Windows       .      Linux   ,           : <br><blockquote> Thank you for your submission of a puzzle solution to Facebook! After running your solution to breathalyzer (received on January 25, 2011, 3:04 am), I have determined it to be correct. Your solution ran for 5097.469 ms on its longest test case. </blockquote><br> , ,    ,     ,         <br><br><h4>  Conclusion </h4><br>  ,  ,   .   wall of text     .  ,           ‚Äî       -.       Ruby.    ,    .           -  .         ,     , ,     ,     ‚Äî   ,   ,      .  ,     ,         .  ‚Äî    ,    ,         . <br><br><h4>    </h4><br><ul><li>        (Core-i7 2.66 GHz) </li><li>      ,         </li><li> ,    ,    -       ,         Ruby     -     </li><li>        ,  facebook-    </li><li> facebook-      </li><li>      snack- ( thrift-),        ,     </li><li>  C   ,     187.in    ,      </li><li>           </li></ul></div><p>Source: <a href="https://habr.com/ru/post/128893/">https://habr.com/ru/post/128893/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../128886/index.html">BUILD conference speakers will speak at Tech ‚àô Ed Russia 2011 in Moscow</a></li>
<li><a href="../128887/index.html">Why your company has no friends</a></li>
<li><a href="../128889/index.html">Manufacturing ATM skimmers using 3D printing</a></li>
<li><a href="../128891/index.html">Electronic necklace. Part 1</a></li>
<li><a href="../128892/index.html">iPhone 5. Tim Cook. The 4th of October</a></li>
<li><a href="../128894/index.html">Habrarebrecha this Thursday</a></li>
<li><a href="../128895/index.html">‚ÄúDill‚Äù - your credit optimizer</a></li>
<li><a href="../128896/index.html">Watching movies on android devices from a home server</a></li>
<li><a href="../128898/index.html">Asterisk + UniMRCP + VoiceNavigator. Synthesis and speech recognition in Asterisk. Part 4</a></li>
<li><a href="../128899/index.html">Habra-Wishlist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>