<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating and testing a firewall in Linux, Part 1.2. Simple interception of traffic with Netfilter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content of the first part: 

 1.1 - Creating a virtual lab (so that we have where to work, I'll show you how to create a virtual network on your compu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating and testing a firewall in Linux, Part 1.2. Simple interception of traffic with Netfilter</h1><div class="post__text post__text-html js-mediator-article">  <b>Content of the first part:</b> <br><br>  <a href="https://habrahabr.ru/post/315340/"><b>1.1</b> - Creating a virtual lab (so that we have where to work, I'll show you how to create a virtual network on your computer. The network will consist of 3 Linux ubuntu machines).</a> <br>  <b><b>1.2</b> - Writing a simple module in Linux.</b>  <b>Introducing Netfilter and intercepting traffic with it.</b>  <b>We combine everything together, we test.</b> <br>  <b>1.3</b> - <a href="https://habrahabr.ru/post/315454/">Writing a simple char device.</a>  <a href="https://habrahabr.ru/post/315454/">Adding a virtual file system - sysfs.</a>  <a href="https://habrahabr.ru/post/315454/">Writing user interface.</a>  <a href="https://habrahabr.ru/post/315454/">We combine everything together, we test.</a> <br><br>  <b>The content of the second part:</b> <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  <a href="https://habrahabr.ru/post/316086/"><b>2.1</b> - Introduction to the second part.</a>  <a href="https://habrahabr.ru/post/316086/">We look at the network and protocols.</a>  <a href="https://habrahabr.ru/post/316086/">Wireshark.</a> <br>  <a href="https://habrahabr.ru/post/316756/"><b>2.2</b> - Firewall Tables.</a>  <a href="https://habrahabr.ru/post/316756/">Transport Layer.</a>  <a href="https://habrahabr.ru/post/316756/">TCP structures, UDP.</a>  <a href="https://habrahabr.ru/post/316756/">Extend the firewall.</a> <br>  <b>2.3</b> - Expanding functionality.  We process the data in user space.  libnetfilter_queue. <br>  <b>2.4</b> - (* Optionally) We study the real Buffer Overflow attack and prevent it with the help of our Firewall. <br></div></div><br><a name="habracut"></a><br>  <b>A very brief introduction to operating systems.</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For those who are not familiar with the basics of operating systems in general and linux-systems in particular, VERY briefly needed basic concepts so that we can move on.  In Linux, like many other operating systems, there are two address spaces - <i>kernel space</i> and <i>user space</i> .  <i>Kernel space</i> - the operating system works here, it mainly deals with the distribution of computer resources between programs (for example, which program is currently running on the processor (scheduling), which program to send output from the keyboard, what to do with packets from the network card, IO operation and many other things).  The OS is in very intimate connections with the hardware (mouse, monitor, printer ...).  Since its work is very important, a separate part of it is allocated for it, which is not related to the <i>user space</i> - the place where most user programs work, such as: editors, calculators, browsers, etc.  In Linux, to change or add new functions in the OS - there are several ways.  One of them is to change the source code of the kernel and compile it again.  But this method is long and difficult, especially when you need to extend the functionality of a minimal or dynamic.  Therefore, there is another way - modules.  Modules - roughly speaking - this is a program that can be dynamically and quickly added to the kernel space, after which, the module will become part of the operating system and get more functionality and access to resources than regular programs. <br><br>  There are many articles on this topic, for example, <a href="http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html">this one is</a> very good.  I hope that I was able to bring intuition. <br><br><h3>  Writing a simple module in Linux.  Practice </h3><br>  To begin with, very briefly we will consider an example of a simple module <a href="http://www.thegeekstuff.com/2013/07/write-linux-kernel-module/">from here</a> - then we will consider what Netfilter is and combine it all together in one source code.  Below, there will be pictures, at the end of the article, links to all source texts.  So: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/987/920/127/98792012783144f4a50727c336ee7dee.png" alt="image" width="90%"></div><br>  This is the source code of a very simple module.  A few things: <br><br>  <b>1</b> - I work in the Geany editor, as Eclpise-like ones in this case will not work.  I compile through the terminal, but it seems possible through Geany. <br><br>  <b>2</b> - there is no printf in the kernel, but there is its printk counterpart, which works in the same way.  By the way, in the kernel there are analogues of all the necessary libraries and functions (and there are no standard libraries like stdlib). <br><br>  <b>3</b> - printk, does not write to the console, but writes to a special file, the contents of which can be read using the dmesg command.  With us, this will be the main way to debug the program (there are other ways to see how printk works, for example, if you switch to the console without the X interface Ctrl + Shift + F1).  It will also be useful <i>dmesg ‚Äìc</i> , for cleaning everything that has accumulated in this file. <br><br>  <b>4</b> - <i>MODULE_LICENSE, MODULE_AUTHOR, MODULE_DESCRIPTION</i> are macros that "give" linux information about the module, which can then be obtained using special commands (search for more on the link). <br><br>  <b>5</b> - The kernel uses the C89 syntax for writing when in C. For example (and most importantly) - unlike the usual C99, all variables must be declared at the very beginning of functions and cannot be declared in another part of it.  If you do NOT comply with this rule, the code will be compiled, but with warnings (which is bad and not for us). <br><br><h3>  Compile module </h3><br>  Pay attention (below on the picture) to the Makefile.  It differs from ordinary programs in user space.  So the whole process looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d19/4e8/5db/d194e85db93348ef984bfc04ed069c76.png" alt="image" width="90%"></div><br>  The module is loaded with the special command <i>‚Äúinsmod ./module_name.ko‚Äù</i> and the macro <i>module_init is launched</i> .  The module is deleted from the computer memory by the command <i>‚Äúrmmod module_name‚Äù</i> . <br><br>  We are checking.  Just load the module, and then unload and look at the <i>dmesg</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/91f/7dc/a26/91f7dca2616a416fa686d11afffc1e83.png" alt="image" width="90%"></div><br>  Is done.  On this introduction to the modules is completed. <br><br><h3>  Introduction to Netfilter.  Theory </h3><br>  <i>Netfilter</i> is a framework built into the linux kernel that allows you to perform various network operations.  We will be interested in intercepting incoming and outgoing traffic. <br><br>  By the way, the most frequently associated program with this framework is <i>iptables</i> , which allows you to dynamically set traffic filtering rules (that is, this is nothing but a simple firewall) built into Linux.  In the Russian version of Wikipedia, there was almost no distinction between the two terms, which I consider to be incorrect, therefore I give the link to the English version.  <a href="https://en.wikipedia.org/wiki/Netfilter">Wikipedia - Netfilter</a> <br>  and on the official website.  It has all the necessary information.  <a href="http://www.netfilter.org/">www.netfilter.org</a> <br><br><h3>  The architecture of intercepting (hooking) traffic.  Theory </h3><br>  The netfilter traffic hooking architecture is as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ff5/453/5bd/ff54535bd7834a679f7f214af5b31cbf.png" alt="image" width="90%"></div><br>  <a href="https://debian-handbook.info/browse/stable/sect.firewall-packet-filtering.html">A photo</a> <br><br>  The diagram shows the stages that pass packets after hitting the phy network card.  Let's take a closer look: <br><br><blockquote>  <i>Prerouting</i> - all the packets that came to the device‚Äôs network card from outside (here, for example, someone from the network, tries to send us mail, or we are on the way of the packet and must transfer it further). <br>  <i>Forward</i> - if the received packet is not intended for this IP address, then the operating system will forward it (remember forward enable from the previous part?) Or throw it out if it considers it unnecessary. <br>  <i>Input</i> - all packages that are intended for any application will get here.  For example, it may be packages for the browser, after the request of a page. <br>  <i>Output</i> - here all the packets that the computer applications send to the network (that is, not the ones we do forwarding) appear.  For example, the same browser request to get a page from the Internet.  Or ping. <br>  <i>Postrouting</i> - combines all outgoing packets. </blockquote><br>  Mathematically: <br><br>  <i>Input data = Prerouting = Forward + Input</i> <br>  <i>Output data = Postrouting = Output + Forward</i> <br><br>  Of course, usually <i>input! = Output</i> (if you don‚Äôt understand for some reason it‚Äôs worth rereading the topic again or look additionally on the Internet). <br><br>  For example, after we type in the browser line <i><a href="http://www.site.com/">www.site.com,</a></i> the package will go through two ‚Äústops‚Äù before it hits the network ‚Äî <i>Output</i> and <i>Postrouting</i> . <br><br>  When site.com will respond to us, the packet will go through two ‚Äústations‚Äù before it <i>reaches the</i> browser ‚Äî <i>Input data</i> and <i>Prerouting</i> . <br><br>  Other packets, for example, with host1 -&gt; host2, will go through <i>Input, Forward, Output.</i> <br>  At each ‚Äústop‚Äù we will be able to make a decision about the ‚Äúcaught packet‚Äù - whether we want to skip it further or not (or something else). <br><br><h3>  The architecture of intercepting (hooking) traffic.  Practice </h3><br>  For interest, we will come up with a rule - all packages that are intended for the FW_dev computer (the one where we set up the firewall), or which FW_dev sends on its behalf to other computers - we will allow it to pass (accept).  All other traffic, we will close (deny).  The ultimate goal is to calculate how many packets have passed, how many we have banned, and transfer data to the user (in the user space). <br><br>  To do this, at the beginning of the module, we define several global variables. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> accepted_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dropped_num = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Now we will install hook functions, in the necessary traffic interception points.  To begin, we write the functions themselves.  All functions must have a predefined type: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hooknum, struct sk_buff *skb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*okfn)(struct sk_buff *))</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre><br>  Feature Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// hook out packets, accept packet unsigned int hook_func_out(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)) { accepted_num++; return NF_ACCEPT; } // hook in packets, accept packet unsigned int hook_func_in(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)) { accepted_num ++; return NF_ACCEPT; } // hook forward packets, drop packet unsigned int hook_func_forward(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)) { dropped_num++; return NF_DROP; }</span></span></code> </pre><br>  The next step is to register them in the system, so it is logical to do this when the module is loaded.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// hook functions structs for registration usage static struct nf_hook_ops nfho_forward; static struct nf_hook_ops nfho_out; static struct nf_hook_ops nfho_in; static int __init fw_module_init(void) { ..... // netfilter functions printk("initialize kernel module\n"); nfho_in.hook = hook_func_in; nfho_in.hooknum = NF_INET_LOCAL_IN; nfho_in.pf = PF_INET; nfho_in.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho_in); // Register the hook nfho_out.hook = hook_func_out; nfho_out.hooknum = NF_INET_LOCAL_OUT; nfho_out.pf = PF_INET; nfho_out.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho_out); // Register the hook nfho_forward.hook = hook_func_forward; nfho_forward.hooknum = NF_INET_FORWARD; nfho_forward.pf = PF_INET; nfho_forward.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho_forward); // Register the hook ‚Ä¶ }</span></span></code> </pre><br>  Here you should pay attention to the <i>hooknum</i> field, to which we assign a value that determines the location of packet interception and corresponds to the diagram above.  The last step is to remove them (deregister) before removing the module from the OS. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">exit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fw_module_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// net filter functions nf_unregister_hook(&amp;nfho_in); nf_unregister_hook(&amp;nfho_out); nf_unregister_hook(&amp;nfho_forward); // end netfilter functions ‚Ä¶ }</span></span></code> </pre><br>  It remains to check the work, and also add a user interface so that any user can read data from our module.  Check first. <br><br><h3>  Prefinal code </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/netfilter_ipv4.h&gt; #include "fw.h" MODULE_AUTHOR( AUTHOR); MODULE_DESCRIPTION( DESCRIPTION); MODULE_VERSION( VERSION); MODULE_LICENSE("GPL"); static unsigned int accepted_num; static unsigned int dropped_num; // hook functions static struct nf_hook_ops nfho_forward; static struct nf_hook_ops nfho_out; static struct nf_hook_ops nfho_in; // hook out packets unsigned int hook_func_out(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)) { printk("Get output packet, accept\n"); accepted_num++; return NF_ACCEPT; } // hook in packets unsigned int hook_func_in(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)) { printk("Get input packet, accept\n"); accepted_num++; return NF_ACCEPT; } // hook forward packets unsigned int hook_func_forward(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *)) { printk("Get forward packet, drop\n"); dropped_num++; return NF_DROP; } static int __init fw_module_init(void) { printk("Starting FW module loading\n"); accepted_num = 0; dropped_num = 0; nfho_in.hook = hook_func_in; nfho_in.hooknum = NF_INET_LOCAL_IN; nfho_in.pf = PF_INET; nfho_in.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho_in); // Register the hook nfho_out.hook = hook_func_out; nfho_out.hooknum = NF_INET_LOCAL_OUT; nfho_out.pf = PF_INET; nfho_out.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho_out); // Register the hook nfho_forward.hook = hook_func_forward; nfho_forward.hooknum = NF_INET_FORWARD; nfho_forward.pf = PF_INET; nfho_forward.priority = NF_IP_PRI_FIRST; nf_register_hook(&amp;nfho_forward); // Register the hook return 0; } static void __exit fw_module_exit(void) { printk("Removing FW module\n"); nf_unregister_hook(&amp;nfho_in); nf_unregister_hook(&amp;nfho_out); nf_unregister_hook(&amp;nfho_forward); } module_init( fw_module_init); module_exit( fw_module_exit);</span></span></span></span></code> </pre><br><h3>  Compile, load the module </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9d5/860/1d5/9d58601d52b04e79b79423df06331dcd.png" alt="image" width="90%"></div><br>  Helmet with <b>host2</b> ping one message to <b>10.0.2.3</b> (we expect the module to skip it, because <b>10.0.2.3</b> is the internal interface. If the message was for <b>host1</b> - <b>10.0.1.1</b> , then we would not have missed it) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/529/3e8/ede/5293e8ede76d4341a119a5adbf26e6c8.png" alt="image" width="90%"></div><br>  we look at "logs", we unload the module <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8f5/071/cf7/8f5071cf7ccd41afb6af23d8089356ce.png" alt="image" width="90%"></div><br><h3>  What happened? </h3><br><blockquote>  In 8354 - I loaded the module. <br>  In 8356 - we found some outgoing packet.  At this stage, we can not know what it is, but most likely one of the packets of the <i>DHCP</i> interface that we have configured. <br>  In 8359 - we found the incoming packet - it was our ping.  After we received it, we immediately sent the answer which we see further. <br>  In 8359 - the answer to ping. <br>  In 8394 - unloaded module. </blockquote><br>  At this stage, you can play with the system and make sure that traffic from <b>host1</b> -&gt; <b>host2</b> does not pass. <br><br>  That's all for now, a list of links: <br><br>  <a href="http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html">The Linux Kernel Module Programming Guide</a> <br>  ¬ª <a href="http://www.thegeekstuff.com/2013/07/write-linux-kernel-module">How To Write Your Own Linux Kernel Module With A Simple Example</a> <br>  ¬ª <a href="https://en.wikipedia.org/wiki/Netfilter">Https://en.wikipedia.org/wiki/Netfilter</a> <br>  <a href="http://www.netfilter.org/">www.netfilter.org</a> <br>  " <a href="https://debian-handbook.info/browse/stable/sect.firewall-packet-filtering.html">Firewall or Packet Filtering</a> - here I took the picture :) </div><p>Source: <a href="https://habr.com/ru/post/315350/">https://habr.com/ru/post/315350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315340/index.html">Creating and testing a firewall in Linux, Part 1.1 Virtual Lab</a></li>
<li><a href="../315342/index.html">How we tested interface usability</a></li>
<li><a href="../315344/index.html">The first winners of the Telegram BotPrize will receive $ 200,000</a></li>
<li><a href="../315346/index.html">Due to skinny fonts the internet becomes unreadable.</a></li>
<li><a href="../315348/index.html">We catch someone else's WiFi at a distance of 1 km</a></li>
<li><a href="../315352/index.html">Type Value Conversion in .NET</a></li>
<li><a href="../315354/index.html">Inter-VNET, VNET-to-VNET VPN and VNET Peering Speed ‚Äã‚ÄãComparison in Microsoft Azure</a></li>
<li><a href="../315356/index.html">Creating PostProcess Material for a Cure Effect in the Unreal Engine 4</a></li>
<li><a href="../315358/index.html">What will the Russian recruitment market without LinkedIn - expert opinion</a></li>
<li><a href="../315360/index.html">With a small or large</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>