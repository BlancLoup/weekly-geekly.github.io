<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modern approach to garbage collection</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I have met quite a few articles in which the latest garbage collector in Go is not advancing in the best way for me. Some of the articles we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modern approach to garbage collection</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a1d/d6b/f42/a1dd6bf42c2f491caf1fa02bc574fbf3.jpg"><br><br>  Recently, I have met quite a few articles in which the latest garbage collector in Go is not advancing in the best way for me.  Some of the articles were written by the developers of the language itself, and their statements hinted at a radical breakthrough in garbage collection technology. <br><br>  Here is the <a href="https://blog.golang.org/go15gc">initial announcement</a> of the introduction of the new collector, dated August 2015: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  In Go, a garbage collector (GC) is created <b>not only for 2015, but also for 2025, and even further ... The collector in Go 1.5 heralds the coming of the future, in which assembly pauses are no longer a barrier to switching to a secure language.</b>  This is the future in which applications can easily scale with the equipment, and as the power of the equipment grows, the garbage collector is no longer a deterrent to creating better, scalable software.  Go is a good language to use for at least the next ten years. </blockquote><br>  The creators claim that they did not just solve the problem of pauses for garbage collection, but went much further: <br><br><blockquote>  One of the high-level ways to solve performance problems is to add GC settings (knobs), one for each problem.  The programmer can change them by selecting the best combination for your application.  The disadvantage of this approach is that with the introduction of one or two new settings every year, after ten years it will be necessary to legally regulate the work of people who will change these settings.  Go did not go this way.  Instead of a bunch of settings, we left one and called it GOGC. <br><br>  Moreover, freed from the burden of supporting dozens of settings, developers can focus on improving the runtime of the application. </blockquote><br>  I have no doubt that many Go users were just happy to get a new approach to runtime in Go.  But I have complaints about these statements: they look like an unreliable marketing bulshit.  And since they are replayed over and over again on the Web, the time has come to understand them in detail. <br><a name="habracut"></a><br>  The reality is that Go hasn't implemented any new ideas or research results in the garbage collector.  As the authors themselves admit, it‚Äôs just a parallel-tagged and cleaned collector based on the ideas of the 1970s.  This is remarkable only because the collector was designed to optimize the length of the pauses at the expense of all the other important characteristics of the collector.  In <a href="https://talks.golang.org/2015/go-gc.pdf">technical</a> and marketing materials, Go does not mention all these side effects, so many programmers are unaware of their existence.  As a result, it seems that competitive languages ‚Äã‚Äãare poorly designed slag.  And the authors of Go only fuel these thoughts: <br><br><blockquote>  To create a collector for the next decade, we turned to algorithms from decades past.  Our collector implements the tri-color (parallel-tagging and cleaning) algorithm proposed by <a href="http://dl.acm.org/citation.cfm%3Fid%3D359655">Dijkstra in 1978</a> .  <b>This is a deliberate difference from the majority of modern assemblers of the "corporate" class</b> , which, we believe, best meets the characteristics of modern equipment and the requirements for the level of delay in modern software. </blockquote><br>  You read all this, and the thought arises that over the past 40 years nothing better has been proposed in the field of "corporate" garbage collectors. <br><br><h1>  Introduction to Garbage Collection Theory </h1><br>  When developing a garbage collection algorithm, a number of factors must be considered: <br><br><ul><li>  <b>Program bandwidth:</b> how much will the algorithm slow down the speed of the program?  Sometimes this is expressed as a percentage: the ratio of processor time spent on assembly to the time spent on useful work. </li><li>  <b>Collector Throughput:</b> How much garbage can a collector clean up after a certain amount of CPU time? </li><li>  <b>Heap Redundancy:</b> How much memory is above the theoretical minimum required by the collector?  If during the assembly it places temporary structures in memory, will this not lead to a sharp increase in memory consumption by the program? </li><li>  <b>Pause duration:</b> for how long the collector stops the program? </li><li>  <b>Pause frequency:</b> how often does the collector stop the program? </li><li>  <b>Distribution of pauses:</b> most pauses are very short and only a few very long?  Or do you prefer to make the pause duration more uniform? </li><li>  <b>Memory placement performance:</b> Is the placement in a new memory fast, slow, or unpredictable? </li><li>  <b>Compaction:</b> Does the collector give a message about the absence of memory (out-of-memory, OOM), even if there is enough space to satisfy his request, but it is scattered around the heap in the form of small chunks?  If it does not, the program may start to slow down and eventually just get up, even if there is enough memory to continue. </li><li>  <b>Multithreading:</b> How efficiently does a collector use multi-core machines? </li><li>  <b>Scaling:</b> how efficiently does the collector work as heaps grow? </li><li>  <b>Tuning:</b> How difficult is it to set up a picker right out of the box, and also for optimal performance? </li><li>  <b>Warm-up time:</b> is the algorithm self-adjusting based on measurements of its own behavior?  If so, how long does it go into optimal operation? </li><li>  <b>Freeing the page:</b> does the algorithm return unused memory to the operating system?  If yes, then when? </li><li>  <b>Portability:</b> Does the collector work on processor architectures that provide weaker memory consistency guarantees compared to x86? </li><li>  <b>Compatibility:</b> with which languages ‚Äã‚Äãand compilers does the builder work?  Is it possible to run it with a language that was created without taking into account the use of collectors, for example C ++?  Do I need to modify the compiler?  If so, do you need to recompile the whole program and dependencies when changing the algorithm of the collector? </li></ul><br>  As you can see, <b>there are many</b> different factors to consider when designing a collector, and some of them affect the architecture of the wider ecosystem associated with your platform.  And I'm not sure that I listed all the factors. <br><br>  Due to the complexity of the design parameters space, garbage collection is a sub-area of ‚Äã‚Äãcomputer science, richly covered in research papers.  New algorithms are proposed and implemented regularly, in both academic and commercial environments.  But, unfortunately, no one has yet created an algorithm suitable for all occasions. <br><br><h1>  Around solid tradeoffs </h1><br>  Let's deal with this in more detail. <br><br>  The first garbage collection algorithms developed for single-processor computers and programs with small heaps.  CPU and memory resources were expensive, and users were undemanding, so they were loyal to the pauses in the programs.  The algorithms created at that time tried to use a smaller processor and minimize excess memory consumption on the heap.  This meant that the collector did nothing as long as the program could store data in memory.  Then she paused to complete the tagging and cleaning of the heap, in order to free some of the memory as soon as possible. <br><br>  Old collectors have advantages: they are simple;  do not slow down the program if they do not do their work;  Do not lead to excessive memory consumption.  Conservative collectors, such as <a href="http://www.hboehm.info/gc/">Boehm GC</a> , do not even need to make changes to the compiler or programming language!  This makes them suitable for desktop applications (usually their heaps are small), including for <a href="https://wiki.unrealengine.com/Garbage_Collection_Overview">AAA video games</a> ;  most of the memory in them is occupied by data files that do not need to be scanned. <br><br>  Algorithms that are characterized by pauses of a full stop (Stop-the-world, STW) for tagging and cleaning are most often studied on computer science courses.  Sometimes at the interviews I ask the candidates to talk a little about garbage collection.  And most often they represent the collector as a black box, inside of which it is not known what is happening, or they believe that it uses very old technology. <br><br>  The problem is that such simple pauses for tagging and cleaning are extremely poorly scaled.  If you add cores and increase the ratios of heap volumes and memory locations, the algorithm stops working well.  But sometimes, when small heaps are applied, even simple algorithms quite tolerably perform their task!  In such situations, you can take advantage of such a collector and minimize the redundancy of memory consumption. <br><br>  The other extreme is the use of heaps of hundreds of gigabytes in size on machines with dozens of cores.  For example, on servers serving exchange transactions or search queries.  In such situations, you need to make the pause as short as possible.  And then algorithms may be preferable, generally slowing down the work of programs due to background garbage collection, but with very short pauses. <br><br>  On powerful systems, you can also perform large batch jobs.  For them, it is not the pauses that are important, but only the total execution time.  In such cases, it is better to use an algorithm that maximizes <b>throughput</b> , that is, the ratio of useful work performed to the time spent on garbage collection. <br><br>  Alas, there is not a single algorithm, completely perfect.  Also, no language's runtime can determine if your program is a batch job or an interactive program that is sensitive to delays.  It is this, and not the stupidity of the developers of runtime, that led to the appearance of ‚Äúgarbage collector settings‚Äù.  This is a consequence of the fundamental limitations of computer science. <br><br><h1>  Generational hypothesis </h1><br>  <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.122.4295%26rep%3Drep1%26type%3Dpdf">In 1984, it was noticed</a> that most of the placements in memory "die young", that is, become rubbish a very short time after placement.  This observation, called the generational hypothesis, is one of the strongest empirical observations in the development of programming languages.  The hypothesis for several decades has been confirmed for many different languages: functional, imperative, not having and having data types. <br><br>  The generational hypothesis has benefited in the sense that garbage collection algorithms have begun to use its advantages.  So there appeared generational collectors (generational collectors), which had a number of advantages in comparison with the old ‚Äústop-mark-clean‚Äù algorithms: <br><br><ul><li>  <b>Collector throughput:</b> they can collect much more garbage and much faster. </li><li>  <b>Memory placement performance:</b> when placing a new memory, you no longer need to look for free slots in the heap.  So accommodation, in fact, was free. </li><li>  <b>The bandwidth of the program: the</b> memory fragments began to be placed neatly next to each other, which <a href="http://dl.acm.org/citation.cfm%3Fid%3D1005693">greatly improved the efficiency of using the cache</a> .  Generation-based collectors require the program to do a certain amount of work as it is done, but in practice this is outweighed by the benefits of changes in cache performance. </li><li>  <b>Pause duration:</b> most pauses (but not all) become shorter. </li></ul><br>  But such collectors have drawbacks: <br><br><ul><li>  <b>Compatibility:</b> algorithms move data in memory and make additional manipulations when the program in some cases writes to the pointer.  This means that the builder must be tightly integrated with the compiler.  For C ++, there are no generation based collectors. </li><li>  <b>Heap redundancy:</b> such collectors copy fragments of memory back and forth between different "spaces".  Since there should be enough space for copying, there is some heap size redundancy.  In addition, such collectors require the support of various pointer maps ( <b>memorized sets</b> are remembered sets), which further enhances redundancy. </li><li>  <b>Distribution of pauses:</b> although many pauses are very short, sometimes full stops are required for tagging and cleaning throughout the entire heap. </li><li>  <b>Customization:</b> generation-based collectors have introduced the concept of ‚Äúyoung generation‚Äù, or ‚Äúheavenly space‚Äù (eden space), and the program's performance depends on its size. </li><li>  <b>Warm-up time:</b> In response to a tuning problem, some collectors dynamically adapt the size of the younger generation based on the behavior of the program being run.  But now the pauses have become dependent on the duration of the program.  This is usually only important for benchmark results. </li></ul><br>  Nevertheless, the benefit from the use of collectors on the basis of generations is so great that today this type absolutely dominates.  If you are ready to accept shortcomings, then you will surely like such collectors.  These algorithms can be extended with all sorts of functions, typical modern assemblers can be in one person multi-threaded, parallel, compacting and using generations. <br><br><h1>  Parallel Go Gatherer </h1><br>  Go is a rather ordinary imperative language with value types.  Perhaps his memory access patterns can be compared with C #, which uses the hypothesis of generations, therefore, the .NET collector is used. <br><br>  In fact, Go programs usually require request / response handlers like HTTP servers.  That is, they demonstrate behavior that is strongly tied up over generations.  The creators of Go think about how this can be used in the future through such things as the ‚Äú <a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit">request oriented collector</a> ‚Äù.  As already <a href="https://news.ycombinator.com/item%3Fid%3D11969740">noted, this is simply a renamed generation-based collector</a> with a customized tenure policy. <br>  You can emulate such a collector in other runtime for request / response handlers.  To do this, you need to make sure that the younger generation is large enough to fit all the garbage generated during the processing of the request. <br><br>  But despite this, the collector used in Go today is <b>not</b> a generation-based collector.  It simply performs in the background the good old procedure of tagging with cleaning. <br><br>  This approach has one advantage: you can get very, very short pauses.  But all other parameters will worsen.  For example: <br><br><ul><li>  <b>Collector Throughput: The</b> time it takes to clear a heap of garbage increases with heap size.  The more memory your program uses, the slower this memory is released and the more time the computer spends on assembling compared to useful work.  You will avoid all this only if the program does not parallelize its execution at all, but you can continue to use the kernel for garbage collection without restrictions. </li><li>  <b>Summarization:</b> since it is not executed, the program may result in fragmenting the entire heap.  We'll talk more about this below.  Also, you do not get the benefits of careful use of the cache. </li><li>  <b>Program bandwidth:</b> the builder must do a lot of work in each cycle.  It takes more CPU time, which could have been given to the program itself, and because of that it is slower. </li><li>  <b>Distribution of pauses: a</b> collector running simultaneously with a program can lead to what in the Java world is called a failure of the joint execution mode (concurrent mode failure): the program generates garbage faster than the threads of the collector have time to clean it.  In this case, the runtime has to completely stop the program and wait for the cleaning cycle to complete.  So when the Go authors claim that the pauses are very short, this applies only to cases where the collector has enough processor time to keep up with the program.  In addition, the <a href="https://github.com/golang/go/issues/10958">Go compiler lacks the ability to pause threads reliably and quickly</a> .  That is, the duration of the pauses depends strongly on the code you are executing (for example, base64-decoding of a large blob in a single gorutin can lead to an increase in pauses). </li><li>  <b>Heap redundancy:</b> Considering the slowness of garbage collection on the heap with the help of tagging and cleaning, you need a <b>lot of</b> space in order not to face the failure of the joint execution mode.  By default, Go provides 100% redundancy ... that is, it doubles the amount of memory needed by your program. </li></ul><br>  Here is an excerpt from <a href="https://groups.google.com/forum/">one post</a> , which describes the above disadvantages: <br><br><blockquote>  Service 1 allocates more memory than Service 2, so the pauses for a full stop are longer.  However, in both services, the absolute length of the pauses of the stop is reduced by an order of magnitude.  After switching on on both services, we observed ~ 20% growth in consumption by the processor time collector. </blockquote><br>  In this case, the duration of pauses in Go has decreased by an order of magnitude, but at the expense of slowing down the work of the collector.  Can this be considered a justified compromise or has the duration of pauses been already quite low?  The author did not say. <br><br>  However, there comes a time when it no longer makes sense to increase the capacity of iron to reduce pauses.  If pauses on the server are reduced from 10 to 1 ms, will users notice this?  And if for such a reduction you need to double the hardware resources? <br><br>  Go optimizes the duration of pauses at the expense of bandwidth, and so much so that it seems as if he wants to slow down your program by an order of magnitude, just to make the pauses a bit smaller. <br><br><h1>  Java comparison </h1><br>  The Java HotSpot virtual machine has several garbage collection algorithms.  You can select them from the command line.  None of them try to reduce the pauses as much as Go, because they are trying to maintain a balance.  To feel the impact of compromise, you can compare the algorithms with each other, switching between different collectors.  How?  Using a simple restart of the program, because compilation is performed as it is executed, so that the different barriers needed for different algorithms can be compiled and optimized in code as needed. <br><br>  On modern computers, the default <b>generation-based collector is</b> used.  It is created for batch tasks and initially does not pay attention to the length of the pause (it can be set on the command line).  Because of the ability to choose the default collector, many people believe that the lousy garbage collector in Java: out of the box, Java tries to make your application run as quickly as possible, with the least memory redundancy, and does not give a damn about pauses. <br><br>  If you need to reduce the duration of pauses, then you can switch to the collector with parallel marking and cleaning (concurrent mark / sweep collector, CMS).  This is closest to what is used in Go.  But this is an algorithm based on generations, so it has a longer pause than Go: the younger generation is compacted during pauses, because objects are moving.  There are two types of pauses in CMS: shorter, about 2-5 ms, and longer, about 20 ms.  CMS works adaptively: since it is executed simultaneously (concurrent), it must assume when it will start (as in Go).  While Go asks you to configure heap redundancy, the CMS adapts itself during runtime, trying to avoid simultaneous execution failures.  Since most of the heaps are handled using regular tagging and cleaning, you may encounter problems and brakes due to heap fragmentation. <br><br>  The most recent generation collector in Java is called G1 (from garbage first).  By default it works since Java 9. The authors tried to make it as universal as possible.  For the most part, it runs at the same time, based on generational generation, and compacts the entire heap.  Much self-configuring.  But since he does not know what you want (like all garbage collectors), it allows you to adjust the trade-offs: just specify the maximum amount of memory you allocate to it and the size of pauses in milliseconds, and the rest will adjust the algorithm yourself to meet your requirements. .  By default, the duration of pauses is about 100 ms, so if you do not reduce them yourself, do not expect the algorithm to do this: G1 will prefer the speed of the application. <br><br>  The pauses are not quite consistent: most are very short (less than 1 ms), but there are also a few long ones (more than 50 ms) related to the compaction of the heap.  G1 scales well.  There are reviews of people who used it on heaps of terabyte size.  Also, G1 has a number of nice features like deduplication of rows in a heap. <br><br>  Finally, another new algorithm was developed under the name Shenandoah.  It is included in OpenJDK, but will not appear in Java 9 until you start using special Java builds from Red Hat (project sponsor).  The algorithm is designed to minimize the length of pauses, regardless of the size of the heap, which at the same time is compacted.  The disadvantages include high heap redundancy and a number of barriers: to move objects during the execution of the application, you must simultaneously read the pointer and interact with the garbage collector.  In this sense, the algorithm is similar to the ‚Äúnon-stop‚Äù picker from Azul. <br><br><h1>  Conclusion </h1><br>  The purpose of this article is not to convince you to use other languages ‚Äã‚Äãor tools.  Garbage collection is a difficult, <b>really</b> difficult problem that has been studied for decades by the army of scientists and programmers.  Therefore, be suspicious of breakthrough solutions that no one noticed.  Most likely, these are merely strange or unusual disguised compromises avoided by others for reasons that will become clear later. <br><br>  And if you want to minimize the duration of pauses at the expense of all other parameters at any cost, then contact the garbage collector from Go. </div><p>Source: <a href="https://habr.com/ru/post/318504/">https://habr.com/ru/post/318504/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318494/index.html">Uninitialized variables: look for errors</a></li>
<li><a href="../318496/index.html">Simple framework UI ERP with Vaadin</a></li>
<li><a href="../318498/index.html">Liveedu.tv - streaming service for programmers and designers</a></li>
<li><a href="../318500/index.html">A fistful of relays. Part 3 - command decoder and control machine</a></li>
<li><a href="../318502/index.html">Intuitive programming</a></li>
<li><a href="../318508/index.html">Little known Git commands</a></li>
<li><a href="../318510/index.html">Code review in distributed team</a></li>
<li><a href="../318512/index.html">Do sites fall on holidays more often than usual? Myths, reality and how to protect yourself</a></li>
<li><a href="../318514/index.html">Radiant Chinese machine and painting machine to them. Frankenstein</a></li>
<li><a href="../318518/index.html">Kaggle: Allstate Claims Severity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>