<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>List of DOM rendering optimizations implemented at the Javascript framework level</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since October 2009, I have been developing an application for searching and listening to music. I strive to organize the ability of the user to quickl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>List of DOM rendering optimizations implemented at the Javascript framework level</h1><div class="post__text post__text-html js-mediator-article">  Since October 2009, I have been developing an application for searching and listening to music.  I strive to organize the ability of the user to quickly interact with the interface, and as a means of speeding up the interaction, I use various methods for quickly rendering pages. <br><br>  I suggest to get acquainted with the methods implemented by me in the application at the system level: <br><br><ul><li>  Using CSS and switching classes instead of rebuilding the DOM tree </li><li>  Pervasive caching of element selections ( <em>$ ('div.active_part span.highlighter')</em> ), atomic change operations (instead of a total redraw, instead of redoing large portions of the DOM tree) </li><li>  Minimize DOM reads while writing state changes </li><li>  Caching the size and location of elements (this saves from unnecessary computation when reading these values ‚Äã‚Äãin the presence of other changes: reading while changing many parts of the tree has a very negative effect on performance) </li><li>  Accurate, not delayed accumulation of changes needed in the DOM </li><li>  Attaching parts of changing collections at a time (for example, when 3 new items are inserted in the middle of the list; <em>createDocumentFragment</em> ) at a specific place ( <em>after</em> , <em>before</em> ) instead of unpinning the entire collection from the DOM and re-attaching it (and instead of redrawing the entire list) </li><li>  Progressive asynchronous rendering: the picture is drawn immediately with a small amount of detail, then more details appear </li><li>  Clone nodes (as part of templating) </li><li>  Caching and using the cache of the results of parsing DOM templates </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/5b3/e7b/643/5b3e7b643e5be6ac358cf2a83904fe61.png" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/f19/e0b/173/f19e0b173db13a54093b0722b572d2c8.png" alt="image"><br>  <em>images from the part with the title "Attaching parts of changing collections at the same time ..."</em> <br><a name="habracut"></a><br><br><h3>  Using CSS and switching classes instead of rebuilding the DOM tree </h3><br><br>  The principle that the maximum of the visual part is transferred to CSS, and the change in the displayed one occurs by switching classes (for example, switching the class <em>.hidden {display: none}</em> instead of deleting / creating a node if you just need to hide the element).  At the same time, the use of this principle allows us not to overload the browser with an excessive number of DOM nodes in the document. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/979/d39/1f0/979d391f02a39213649d846c17cd2da1.gif"><br>  <em>in this example, to display the complete list of one of the nodes, the class wants_more_songs is simply switched</em> <br><br><br><br><h3>  Ubiquitous caching of node samples, atomic changes </h3><br><br>  By atomic changes, I mean the principle that instead of completely reworking, re-parsing and building new large parts of the DOM structure, we change some specific part of an already existing DOM.  Moreover, structure changes are tied to state changes as specifically as possible.  If the class should change, change it through <em>$ ('. Target_node'). AddClass ('active')</em> , if the text is changed, then through <em>$ ('. Target_node'). Text ('place an order')</em> .  The same goes for attributes and other parts of the DOM. <br><br>  This is the first optimization, one of the first principles that I used (in connection with which I refused from template engines, especially in the underscorejs.template style).  They will stop to not redraw the entire view when the state of the model changes, but to change only a part.  According to them, I should not use <em>.innerHTML</em> (or <em>jquery (...). Html ()</em> ), and should also cache samples of nodes (selectors), i.e.  if I need to change any part, then I do not do a sample every time, but just take the necessary node from the cache. <br>  I have these two things organized like this: the code is divided according to MVC, when changes of model states, information about changes is sent to the view, the function associated with the changeable state is triggered in the view.  The function uses caching for samples. <br>  For example, the model had the following states: <br><pre><code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">artist</span></span>: <span class="hljs-string"><span class="hljs-string">"The Killers"</span></span>, <span class="hljs-attr"><span class="hljs-attr">track</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span> }</code> </pre> <br>  we changed them with this code: <br><pre> <code class="javascript hljs">track_model.updateState(<span class="hljs-string"><span class="hljs-string">'track'</span></span>, <span class="hljs-string"><span class="hljs-string">"When You Were Young"</span></span>);</code> </pre> <br>  states have become such: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">artist</span></span>: <span class="hljs-string"><span class="hljs-string">"The Killers"</span></span>, <span class="hljs-attr"><span class="hljs-attr">track</span></span>: <span class="hljs-string"><span class="hljs-string">"When You Were Young"</span></span> }</code> </pre> <br>  <em>The state of the track field has changed</em> , and we sent these changes from the model to the view. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/257/d2c/7c9/257d2c7c9b45fa7fbdf6412f15c79660.gif"><br>  <em>Animation, 3 frames.</em>  <em>We change track state in model, 2 views instantly react to change</em> <br><br>  in View, a function that responds to a change in a particular state and makes a DOM change is triggered, in this case the following code will work: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'stch-track'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new_state, old_state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container .find(<span class="hljs-string"><span class="hljs-string">'.song-track-name'</span></span>) .text(new_state) .toggleClass(<span class="hljs-string"><span class="hljs-string">'hidden'</span></span>, !new_state); }</code> </pre> <br>  (note the name of the method of the form <em>'stch-' + state_name</em> , in this case <em>'stch-track'</em> ); <br>  so specific changes are tied to specific parts of the DOM <br><br>  Now let's pay attention to caching.  If you make a selection with each change ( <em>this.container.find ('. Song-track-name')</em> ), this will negatively affect the performance, therefore, in order not to make a selection every time, for example, we immediately change this code: <br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'stch-track'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new_state, old_state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.track_name_node){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.track_name_node = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.find(<span class="hljs-string"><span class="hljs-string">'.song-track-name'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//            } this.track_name_node.text(new_state).toggleClass('hidden', !new_state); }</span></span></code> </pre> <br>  ( <em>so I cached samples when I first started writing code, in accordance with the principles of atomic changes</em> ) <br><br>  Later, when I started to make and use my template, for cases when it is necessary to make changes in the DOM in manual mode, I created a directive <em>(&lt;span pv-anchor = "track_name_con" class = "song-track-name"&gt; &lt;/ span &gt;)</em> , which indicates that the node must be cached in the repository, because I will contact it manually (instead of writing the imperative code <em>this.container.find ('. song-track-name')</em> each time).  Thus, I can rewrite the reaction to changes like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'stch-track'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new_state, old_state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tpl.ancs[<span class="hljs-string"><span class="hljs-string">'track_name_con'</span></span>].text(new_state).toggleClass(<span class="hljs-string"><span class="hljs-string">'hidden'</span></span>, !new_state); }</code> </pre> <br>  Such simple changes (when text or a class or some other attribute depends on the state) are usually described by other directives, and the <em>pv-anchor</em> directive is used for more complex changes (for example, affecting the location or size of other nodes) for hanging events in complex interactions. and for other cases where the DOM is changed manually. <br><br><h3>  Minimize DOM reads while writing state changes </h3><br><br>  The browser tries to render after all changes to the DOM have been made.  However, he will have to calculate everything much earlier, and then again, if you try to count some properties.  Therefore, I strive to read the DOM as rarely as possible, and if it does not work out, then cache (if possible) the read results. <br><br><br>  Now there are fast-acting and relatively convenient template engines, for example, the template engine in <em>angularjs</em> and <em>Facebook React</em> .  When I was at the very beginning of the journey, I did not know about the existence of convenient template engines that make these simple things (were they then?), So I did not use them. <br>  When the code in the application evolved, divided according to the MVC principle, I still did not have a template engine, so I described all reactions to changes manually (as described in the example above). <br><br>  Later I paid attention to the template engine in <em>angularjs</em> , which is rapidly gaining popularity, and also adhered to the principle of atomic changes (and had data binding).  But I was more interested in the principle that state changes are tied to the properties of elements.  This is done by declaring additional attributes in the html document. <br><br>  I took from <em>angularjs the</em> code responsible for parsing the expressions, and the declarative way of date-binding through the attributes itself.  This way of describing the connection leaves the HTML code working and allows the browser to perform the most difficult part of the work (HTML parsing), and then reuse the result (using the cloning method <em>.cloneNode ()</em> . <br><br>  Example: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user_tag_page usual_page"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">pv-class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lula_page usual_page {{!vmp_show &amp;&amp; 'hidden'}}"</span></span></span><span class="hljs-tag"> &gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  This example uses the pv-class directive.  According to its value, the element will always have the <em>lula_page usual_page</em> classes, and also, if the model does not have the state vmp_show, then the element must have one more class - ‚Äúhidden‚Äù.  The template engine will overwrite .className automatically when the state of <em>vmp_show changes</em> , however, if template is not used, the <em>className</em> will not be overwritten and its value will be the same as we originally recorded it - <em>class = "user_tag_page usual_page"</em> . <br><br>  This method is not only convenient and allows for optimization of parsing, but also gives the potential for performance optimizations associated with making changes to the DOM.  For example, performance optimization is implemented when the classes of elements change.  Perhaps you know that the <em>jQuery (node) .addClass ('sample-class')</em> method, before adding a class, checks if the element has such a class, i.e.  makes additional reading before writing (at least until classList api appears).  But since  in the template we know the full set of classes and the set of classes that should be at the current state of the model (for example, " <em>lula_page usual_page hidden</em> "), we can immediately do this: <br><br><pre> <code class="javascript hljs">node.className = <span class="hljs-string"><span class="hljs-string">"lula_page usual_page hidden"</span></span>;</code> </pre> <br>  those.  we didn‚Äôt have to read the previous value of the className at all, because we only change it if the state has changed, and we know the entire list of the states on which it depends, and what exactly the class value should be. <br><br>  Knowing the state of the models and the structure of the DOM structure, they don‚Äôt need to read this DOM at all (unless it depends on the size of any other parts). <br><br>  However, specifically with reading classes, the described principle may not give a performance boost at all (at least, a modern browser should understand that it does not need to calculate any dimensions or arrangements in order to provide the full value of <em>className</em> ), but this is a small bonus that I get from the template. <br><br>  <em>However, in the record related to the release of the latest, currently released version of jquery (1.11, 2.1, January 24, 2014), the developers <a href="http://blog.jquery.com/2014/01/24/jquery-1-11-and-2-1-released/">reported</a> (see under the heading Fewer forced layouts) that they corrected the extra <em>layout change</em> changes as the class changed.</em>  <em>Those.</em>  <em>it matters, and quite seriously.</em>  <em>Chrome developers are <a href="https://code.google.com/p/chromium/issues/detail%3Fid%3D278045">also working</a> on this issue.</em> <br><br><h3>  Cache size and location of elements </h3><br><br>  Reading the size or position of the elements causes a premature calculation of all other changes made - this is a good place for optimizations.  For cases where this is possible, I use caching. <br><br>  For example, to set the width of the nodes that display the current progress of playback and loading, I use not pixel width, but pixel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59e/c96/19f/59ec9619fa5771f2c709cf6c98f806bb.png" height="400"><br>  <em>normal width file bar progress</em> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c2/38b/6b5/5c238b6b556441dac35fb425243b52e1.png" height="400"><br>  <em>width of the progress bar when the list of files is expanded</em> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/835/2db/435/8352db435d011a07693aa62665f374b1.png" height="400"><br>  <em>width progress bar with a different width of the window</em> <br><br><br><br>  To calculate it is necessary to know the width of the parent element.  The width of the parent element can vary from the width of the screen and the full or single display of the list of found files. <br><br>  In this case, the width does not depend on any other parameters.  With the same width and list display mode, the node width will always be the same.  I use states that can affect the width as part of the key when accessing the repository. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getBoxDemension(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getProgressWidth, <span class="hljs-string"><span class="hljs-string">'progress_c-width'</span></span>, window_width, !!p_wmss);</code> </pre> <br><br>  The first parameter of the method ( <em>getProgressWidth</em> ) is simply a function that the <em>getBoxDemension</em> method itself will call if there is no value for the given key in the repository. <br>  All other parameters are simply added to the string.  In this case, the <em>p_wmss</em> in the line becomes <em>'false'</em> or <em>'true'</em> (only one file or the entire list is displayed).  As a result, the key may look like for example <em>progress_c-width-1372-false</em> . <br><br>  When the window width or display mode is changed, the new width for the new key will be calculated (if it is not already in the repository), and parts depending on this width will be automatically redrawn. <br><br>  In fact, two more lines are added to the key each time - this is the name of the position of the slot-slot of this view inside the parent view (in the terminology of my framework, which automatically assigns this name to the position of the view), and the same is true for the parent view parent view.  This is used for cases when the same view is used in different places, and therefore the calculated dimensions depend not only on, for example, the width of the screen and the display mode of the file list, but also on where the view is used. <br><br>  <em>Additionally, you can see the <a href="http://youtu.be/9xjpmpX4NJE">videotape</a> , where Google‚Äôs employee Paul Lewis tells about this in part of his report.</em>  <em>See also the <a href="http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">joint article by</a> Paul Lewis and Paul Irish on the same topic.</em>  <em><a href="https://docs.google.com/spreadsheet/pub%3Fkey%3D0ArK1Uipy0SbDdHVLc1ozTFlja1dhb25QNGhJMXN5MXc%26single%3Dtrue%26gid%3D0%26output%3Dhtml">The list of properties</a> that somehow affect the rendering of that article.</em> <br><br><h3>  Accurate, not delayed accumulation of changes necessary to make in the DOM </h3><br><br>  The framework implements the collection of all states in the packet before being sent to the views for model states that depend on a different state and change when the state is updated.  But only with this model, and not with the entire application. <br><br>  When the model state is updated, all other model states that depend on it will also be automatically updated, and the changes will be collected in one large package and sent to the view so that rendering takes place in one iteration.  Calculations of changes will occur until new changes in this model cease to appear, i.e.  sending will be delayed only by calculating the states of this model (and nothing more).  Changes in states that depend on other models (for example, on our updated one) will be calculated in these models only after the updated model sends changes to its views. <br><br>  Thus, the accumulation of state changes is realized, which is not delayed for too long. <br><br>  To render in one iteration when manually updating several states, I use the following method: <br><pre> <code class="javascript hljs">.updateManyStates({ <span class="hljs-attr"><span class="hljs-attr">artist</span></span>: <span class="hljs-string"><span class="hljs-string">'artist_224'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'radnomd title 014'</span></span> })</code> </pre><br><br>  instead of doing two such steps: <br><pre> <code class="javascript hljs">updateState(<span class="hljs-string"><span class="hljs-string">'artist'</span></span>, <span class="hljs-string"><span class="hljs-string">'artist_224'</span></span>)</code> </pre> <br><pre> <code class="javascript hljs">updateState(<span class="hljs-string"><span class="hljs-string">'title'</span></span>, <span class="hljs-string"><span class="hljs-string">'radnomd title 014'</span></span>)</code> </pre> <br><br>  <em>In the future, in addition to this principle, I am using the requestAnimationFrame to accumulate changes directly on the template side.</em> <br><br><h3>  Attaching portions of a changing collection at a time ( <em>createDocumentFragment</em> ) to a specific location ( <em>after</em> , <em>before</em> ) instead of detaching the entire collection from the DOM and reattaching </h3><br><br>  When changing lists, the list is not redrawn again. <br>  When you change lists, DOM parts associated with list items are not recreated. <br>  When the lists change, the new order of DOM elements of the list is set not by unpinning completely from the document, but by unpinning, if necessary, and by attaching changes in their position (or new) elements to a strictly defined place for them. <br>  The DOM corresponding to the elements of the list to be attached is not attached individually, but with the help of <em>createDocumentFragment</em> , if the elements follow each other.  The elements are attached to the <em>documentDrafment</em> in the desired order, then the <em>documentDrafment is</em> attached to the document in the right place using the methods <em>after</em> , <em>before</em> or <em>append</em> . <br><br>  Thus, when changing the list in the DOM, only the most necessary and minimal changes occur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/914/f5c/727914f5c74aa9488326cfeb29dba7d9.png" height="400"><br>  <em>a list with the last element highlighted in this list (the global variable $ 0 in the console is the selected and highlighted element, $ 1, $ 2, $ 3 - the elements selected before)</em> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a58/ec0/a9e/a58ec0a9e148b369e30b9bd633f0dd0c.png" height="400"><br>  <em>A large number of new compositions have been added to the list, while the element responsible for the presentation of the composition (the list has changed) that was chosen before has remained absolutely the same node.</em> <br><br><br><br>  <em>Additionally, you can read the <a href="http://webo.in/articles/habrahabr/55-fast-documentfragment/">translation of the recording</a> from the blog of John Resig.</em> <br><br><h3>  Progressive asynchronous rendering: the picture is drawn immediately with a small amount of detail, then more details appear </h3><br>  If necessary, draw a large structure with elements nested into each other (even simple things are most often implemented as nested parts), including if necessary to draw a list, the framework in the first iteration will draw views for models at the very top of the structure.  Inside this iteration, there will be two more: the very base that defines the visual dimensions will be drawn, then the details will be drawn (relating directly to this model, reactions to changes in its states).  In the next iteration, the framework will draw nested models, and this will continue until the nesting ends.  All iterations are separated and can be discharged using <em>setTimeout</em> , if drawing takes for example more than 200 ms (in the future I plan to replace requestAnimationFrame), in order not to block the interface and allow the browser to render what is already there.  For the user, the interface will change gradually, i.e.  it will see that some changes occur, in contrast to a simpler way, when after a long pause (during which the browser does not respond to clicks and displays the same thing), the browser drastically changes the picture. <br><br>  It looks like a progressive jpeg or can remind you of game engines.  In moments when the engine does not have enough resources, and the image appears first in poor quality (unfiltered textures, low poly models, etc.), and then the picture is improved. <br><img src="https://habrastorage.org/getpro/habr/post_images/42d/220/948/42d22094861f6afc20cf93008d71b205.gif">  <em>Animation, 2 frames.</em>  <em>Progressive rendering: first garabits, then details.</em>  <em>It was possible to catch the moment and capture the first part only in the debugging mode, which is why the darkening is visible.</em> <br><br><h3>  Node cloning </h3><br><br>  Getting the DOM structure for the View is approximately as follows: the HTML parser of the browser itself once parses the HTML (performs the hardest work, it happens beforehand, while loading the entire page), then, if necessary, the result is cloned through the DOM API ( <em>.cloneNode ()</em> ).  The copies from the template are created by cloning the DOM of the template tree, after which the directives associated with this node are read and understood. <br><br><h3>  Caching and using the cache of the results of parsing DOM templates </h3><br><br>  So that after cloning the nodes, you do not have to re-read the attributes to search for directives (such service data is not copied when the node is cloned), as well as to reuse objects that are created by directives (for subsequent use by the template engine) in order to use memory more efficiently and rarer garbadge collector, a solution was found that allows you to quickly copy the service data from the original node to the clone node. <br><br>  This happens as follows: the template DOM structure is parsed, analyzed.  All the nodes of elements with directives are set to the <em>pvprsd</em> property with a unique value corresponding to a unique set of directives that is stored in the repository and can be used in the future.  After all necessary elements are set to a property, starting from the root, the structure is expanded into an array.  The template structure is cloned from the root, and this instance is also cloned.  Exemplar further in a similar way from the root is decomposed into an array.  Such cloning and unfolding ensures that there will be absolutely similar nodes in the arrays under the same indices.  After this, the usual pass through the array copies <em>pvprsd</em> from the element of the first array to the element of the instance array: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getAll = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iteration_list = [ node ]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( iteration_list.length ){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cur_node = iteration_list.shift(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( cur_node.nodeType != <span class="hljs-number"><span class="hljs-number">1</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cur_node.childNodes.length; i++ ) { iteration_list.push( cur_node.childNodes[i] ); } result.push( cur_node ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; };</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cloned = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onode.cloneNode(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all_onodes = getAll(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onode); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> all_cnodes = getAll(cloned);</code> </pre><br><br><h3>  Conclusion </h3><br><br>  I talked about the optimization methods that I implemented in the application at the system level.  This allows me not to program the same optimization every time, but, following some rules, to write code resulting from high-performance.  Of course, I use other methods, I use profiling, but this happens in some specific cases and additional time is spent. <br><br>  I would be interested to know what other optimizations can be implemented at the system level.  For example, automatically creating visually isolated areas based on iframe / object elements ‚Äî as done manually in this example: <a href="http://fb.html5isready.com/">http://fb.html5isready.com</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a4/963/da0/3a4963da016dccd5671b5a3a235c44f0.png"><br>  <em>part of the visual representation of the application is inside the object element</em> <br><br><br><br>  I have not implemented such a method, but I imagine it realistic to implement it automatically - when a template, its instances, styles, operational state changes themselves fall into an automatically generated, based on some criteria, an iframe. <br><br>  Please tell us about other implementations of optimization techniques at the system level that you know about (like <a href="http://wilsonpage.co.uk/preventing-layout-thrashing/">such</a> or <a href="https://github.com/paullewis/Boundarizr">such</a> ).  Or about somewhere expressed ideas of such optimizations ( <a href="http://aerotwist.com/blog/the-web-needs-containment/">example</a> ), or about their ideas, if they are ready to share. </div><p>Source: <a href="https://habr.com/ru/post/210558/">https://habr.com/ru/post/210558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210542/index.html">Our checklist for filters on sites</a></li>
<li><a href="../210544/index.html">Remote service advertisers</a></li>
<li><a href="../210546/index.html">Processing incoming requests, the experience of a small web studio</a></li>
<li><a href="../210548/index.html">TorrentMonitor and hello again</a></li>
<li><a href="../210554/index.html">Video about how the collider works and how it works</a></li>
<li><a href="../210562/index.html">Designer review Android 4.4 KitKat. Part 2</a></li>
<li><a href="../210564/index.html">User Timing API</a></li>
<li><a href="../210570/index.html">Stock market: How are exchanges organized and why are they needed?</a></li>
<li><a href="../210572/index.html">Why did I change jobs?</a></li>
<li><a href="../210574/index.html">Gaming community in terms of independent game developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>