<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of one Russian RTOS, part 7. Means of data exchange between tasks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In addition to interaction at the level of interlocking, tasks must interact with each other and at the data level. At the same time, the distinctive ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of one Russian RTOS, part 7. Means of data exchange between tasks</h1><div class="post__text post__text-html js-mediator-article">  In addition to interaction at the level of interlocking, tasks must interact with each other and at the data level.  At the same time, the distinctive feature of the MAX RTOS is the possibility of data exchange not only within one controller, <br><br><img src="https://habrastorage.org/webt/59/df/62/59df62609c178548336498.jpeg"><br>  <b>Fig.</b>  <b>1. An example of the interaction of tasks within one controller</b> <br><br>  but also between the controllers, completely hiding the transport level. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/59/df/62/59df6260bfa0d036809595.jpeg"><br>  <b>Fig.</b>  <b>2. An example of the interaction of tasks between controllers</b> <br><br>  In this case, different controllers are equivalent to different processes, since their memory is completely isolated.  In the OS version <a href="https://www.astrosoft.ru/products/development/rtos-macs/">published on our website</a> , the physical channel between the controllers can be wired SPI or UART interfaces, as well as a wireless interface through RF24 radio modules. <a name="habracut"></a><br><br>  The use of SPI and UART options is not recommended, since in the current implementation no more than two controllers can be connected through them. <br><br>  Further I will tell about it in more detail, and other chapters of the "Book of Knowledge" can be found here: <br><br>  <a href="https://habrahabr.ru/post/336308/">Part 1. General information</a> <br>  <a href="https://habrahabr.ru/post/336696/">Part 2. Core MAX MAX</a> <br>  <a href="https://habrahabr.ru/post/336944/">Part 3. The structure of the simplest program</a> <br>  <a href="https://habrahabr.ru/post/337476/">Part 4. Useful theory</a> <br>  <a href="https://habrahabr.ru/post/337974/">Part 5. The first application</a> <br>  <a href="https://habrahabr.ru/post/338682/">Part 6. Thread synchronization tools</a> <br>  Part 7. Means of data exchange between tasks (this article) <br>  <a href="https://habrahabr.ru/post/340032/">Part 8. Work with interruptions</a> <br><br><h2>  Means for data exchange within one controller (message queue) </h2><br>  The classic approach to the work of the RTOS is as follows: tasks exchange data with each other using message queues.  At least all academic textbooks require it.  I belong to practicing programmers, so I admit that it is sometimes easier to get by with any direct means of exchange made for a specific case.  For example, banal ring buffers that are not tied to the system.  But nevertheless, there are cases where message queues are the most optimal objects (if only because, unlike non-system things, they can block tasks when the buffer overflows or the polled buffer is empty). <br><br>  Consider a textbook example.  There is a serial port.  Of course, by the circuit engineers, to simplify the system, it is made without flow control lines.  Data on the wire can go one after the other.  At the same time, the equipment of many (though not all) typical controllers does not imply a large hardware queue.  If the data do not have time to pick up - they will be overwritten by all new portions coming from the receiving shift register. <br><br>  On the other hand, suppose a task processing data takes some time (for example, to move a working tool).  This is quite normal - the G-code comes to CNC machines with some pre-emption.  The tool moves, and the next line at the same time runs along the wires. <br><br>  So that the buffer register of the controller does not overflow, and the bytes in the program would have time to be received during the main work, it is necessary and sufficient to do them in the interrupt handler.  The simplest variant is possible when ‚Äúraw‚Äù bytes are transferred to the main task: <br><br><img src="https://habrastorage.org/webt/59/df/62/59df6260c3c26943825507.jpeg"><br>  <b>Pic.3</b> <br><br>  But in this case, it turns out too many operations of staging and taking from the queue.  Overhead costs are too high.  It is advisable to queue not the ‚Äúraw‚Äù bytes, but already the results of their preprocessing (starting from lines, ending with the results of string interpretation for our G-code example).  But it is <b>unacceptable to</b> perform preprocessing in the interrupt handler, because at that time part and all other interrupts are blocked (depending on the priority setting), and data for other subsystems will be processed with a delay, which sometimes disrupts the product. <br><br>  This postulate is worth repeating it several times.  I remember that on one forum I saw the following question: ‚ÄúI took a typical microphone sound unpacker from the PDM format, but it does not work properly.‚Äù  And an example was attached to the question in which PDM filtering was performed in the context of an interrupt.  It goes without saying that when the author of the question began to convert from PDM to PCM without interruption (as he was immediately advised), all the problems went away by themselves.  Therefore, <b>in the interruption of preprocessing to produce unacceptable!</b>  <font color="ff0044"><b>You can not</b></font> cook eggs in the microwave and <font color="ff0044"><b>perform unnecessary actions in the interrupt handler!</b></font> <br><br>  The scheme recommended in all textbooks, if there is a preprocessing, is as follows. <br><br><img src="https://habrastorage.org/webt/kx/hl/wo/kxhlwodepsc-ouj5ptqi2wanixs.png"><br>  <b>Pic.4</b> <br>  The high-priority preprocessing task is blocked almost all the time.  The interrupt handler received a byte from the hardware, the preprocessor woke it up, passing it that byte, and then went out.  From now on, all interrupts are re-enabled. <br><br>  The high-priority preprocessor wakes up, accumulates data in the internal buffer, and then falls asleep, again giving the opportunity to work with normal priority tasks.  When a line is accumulated (a newline character has arrived), it interprets it and places the result in the message queue.  This is the option that all academic publications recommend, so I simply had to bring a classic idea to the readers here.  Although I immediately add that I myself, not as a theorist, but as a practitioner, I see the weak point of this method.  We win on a rare reference to the queue, but we lose on context switches for entering a high-priority task.  In general, the recommendations were communicated, about the shortcomings of this approach - it‚Äôs told, and how to work in real life - everyone should find his own method, selecting the optimal ratio of performance and simplicity.  Some recommendations with real estimations will be in the next article on interrupts. <br><br>  To implement the message queue, the MessageQueue class is used.  Since the message queue should work effectively with arbitrary types of data, it is implemented as a template (the data type is substituted for it as an argument). <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageQueue</span></span></span><span class="hljs-class"> {</span></span> ...</code> </pre> <br>  The constructor has the form: <br><br>  <b>MessageQueue (size_t max_size);</b> <br><br>  The max_size parameter specifies the maximum queue size.  If you try to queue an item when it is filled to capacity, the assigning task will be blocked until a free space appears (some task will not pick up one of the already queued items). <br><br>  Since it has already been said too much, one cannot do without an example of queue initialization.  Take a fragment of the test, in which you can see that the queue element is of type short, and the dimension of the queue will not exceed 5 elements: <br><br><pre> <code class="cpp hljs">voidMessageQueueTestApp::Initialize() { mQueue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageQueue&lt;<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">5</span></span>); Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageSenderTask(<span class="hljs-string"><span class="hljs-string">"send"</span></span>), Task::PriorityNormal, <span class="hljs-number"><span class="hljs-number">0x50</span></span>); Task::Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MessageReceiverTask(<span class="hljs-string"><span class="hljs-string">"receive"</span></span>), Task::PriorityNormal, <span class="hljs-number"><span class="hljs-number">0x50</span></span>); }</code> </pre> <br>  You can put a message in the queue using the function: <br><br>  <b>Result Push (const T &amp; message, uint32_t timeout_ms = INFINITE_TIMEOUT);</b> <br><br>  The timeout_ms parameter is required for cases when the queue is full.  In this case, the system will try to wait for the moment when free space appears in it.  And this parameter - just tells how long it is allowed to wait. <br><br>  If necessary, the message can be put not at the end of the queue, but at its beginning.  To do this, use the function: <br><br>  <b>Result PushFront (const T &amp; message, uint32_t timeout_ms = INFINITE_TIMEOUT);</b> <br><br>  To remove another item from the head of the queue, use the function: <br><br>  <b>Result Pop (T &amp; message, uint32_t timeout_ms = INFINITE_TIMEOUT);</b> <br><br>  Here, respectively, the timeout parameter sets the wait time in case the queue is empty.  During the specified time, the system will try to wait for messages in the queue to appear in other tasks. <br><br>  You can also get the value of the element from the queue head, without removing it: <br><br>  <b>Result Peek (T &amp; message, uint32_t timeout_ms = INFINITE_TIMEOUT);</b> <br><br>  Finally, there are functions to find out the number of messages in the queue: <br><br>  <b>size_t Count ()</b> <br><br>  and the maximum possible queue size: <br><br>  <b>size_t GetMaxSize ()</b> <br><br><h2>  Means of data exchange between different controllers </h2><br>  Generally, purely formally, the means of communication between controllers are drivers.  But ideologically, they belong to the usual means of data exchange, which is one of the main features of the MAKS RTOS; therefore, we will consider them in the part of the manual relating to the core. <br><br>  I recall that in the published version of the OS, physical exchange can be carried out through wired interfaces UART or SPI, or through the radio module RF24 (also connected to the SPI interface).  We also recall that in order to activate the data exchange between controllers, a line should be entered in the MaksConfig.h file: <br><br>  #define MAKS_USE_SHARED_MEM 1 <br><br>  and determine the type of physical channel by setting one of the constants in the unit: <br><br>  <b>MAKS_SHARED_MEM_SPI, MAKS_SHARED_MEM_UART or MAKS_SHARED_MEM_RADIO</b> . <br><br>  <font color="ff0044"><b>The SPI and UART mechanisms in the current implementation provide communication between only two devices, so the radio variant is recommended</b></font> <br><br>  Now, after such a prolonged preamble, let's start studying the SharedMemory class. <br>  The class object can be initialized using the Initialize () function.  The word "can" is not applied accidentally.  <font color="ff0044"><b>In general, for a radio variant, initialization is not required.</b></font> <br><br>  The data structure is passed to this function.  Consider briefly her field. <br><br><img src="https://habrastorage.org/webt/59/df/65/59df65c73bcb5969567679.png"><br><br>  Consider the examples of filling this structure and calling the initialization function. <br><br><pre> <code class="cpp hljs"> SmInitInfo info; info.TransferCore = &amp;SpiTransferCore::GetInstance(); info.NotifyMessageReceived = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; info.AutoSendContextsActivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; info.SendActivityDelayMs = <span class="hljs-number"><span class="hljs-number">100</span></span>; info.CheckActivityDelayMs = <span class="hljs-number"><span class="hljs-number">200</span></span>; SpiTransferCore::GetInstance().Initialize(); SharedMemory::GetInstance().Initialize(info);</code> </pre> <br>  Another option: <br><br><pre> <code class="cpp hljs"> SmInitInfo info; info.TransferCore = &amp;SpiTransferCore::GetInstance(); info.AutoSendContextsActivity = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; info.SendActivityDelayMs = <span class="hljs-number"><span class="hljs-number">100</span></span>; info.CheckActivityDelayMs = <span class="hljs-number"><span class="hljs-number">200</span></span>; SpiTransferCore::GetInstance().Initialize(); SharedMemory::GetInstance().Initialize(info);</code> </pre> <br>  This class provides two mechanisms for interacting tasks - messages and shared memory (with the possibility of locks). <br><br>  Since the ‚Äúshared memory‚Äù object is always one, the developers of the operating system created the MaksSharedMemoryExtensions.cpp file, which converts complex function names to global ones. <br><br>  Here is a fragment of this file: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SharedMemory::GetInstance().GetContext(context_id, data); } <span class="hljs-function"><span class="hljs-function">Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data_length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SharedMemory::GetInstance().GetContext(context_id, data, data_length); } <span class="hljs-function"><span class="hljs-function">Result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> context_id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* data, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data_length)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SharedMemory::GetInstance().SetContext(context_id, data, data_length); }</code> </pre><br>  Since all the applications in the package use global function names, I will also use this naming convention in the examples for this document. <br><br><h3>  Messages </h3><br>  Let's start with the messages.  To send them, use the SendMessage () function.  The function is quite complex, so consider it in detail: <br><br>  <b>Result SendMessage (uint32_t message_id, const void * data, size_t data_length)</b> <br><br>  Arguments: <br><br>  <b>message_id</b> - message identifier; <br>  <b>data</b> - a pointer to the message data; <br>  <b>data_length</b> - the length of the message data. <br><br>  Usage example: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> APP5_EXPOSE_MESSAGE_ID = <span class="hljs-number"><span class="hljs-number">503</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (broadcast) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> t = <span class="hljs-number"><span class="hljs-number">0</span></span>; SendMessage(APP5_EXPOSE_MESSAGE_ID, &amp;t, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(t)); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> APP5_AIRPLANE_MESSAGE_ID = <span class="hljs-number"><span class="hljs-number">504</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> AirplaneTask::SendAirplane() { <span class="hljs-function"><span class="hljs-function">Message </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_x, _y, _deg, _visibility)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SendMessage(APP5_AIRPLANE_MESSAGE_ID, &amp;msg, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(msg)) == ResultOk; }</code> </pre> <br>  The result of the function reflects the status of the message being sent.  It was received by any of the recipients or not - the function is silent.  It is only known whether it is gone or not.  To confirm, the recipient must independently send a return message. <br><br>  Accordingly, the function is used to wait for a message on the recipient‚Äôs side: <br><br>  <b>Result WaitUntilMessageReceived (SmMessageReceiveArgs &amp; args, uint32_t timeout_ms = INFINITE_TIMEOUT)</b> <br><br>  Arguments: <br><br>  <b>args</b> - object reference with message parameters; <br><br>  <b>timeout_ms</b> - wait timeout in milliseconds.  If the time-out value is INFINITE_TIMEOUT, then the task will be blocked without the possibility of unlocking by time-out (endless waiting). <br><br>  Message parameters are a whole class.  Consider briefly its open members: <br><br>  <b>uint32_t GetMessageId ()</b> <br>  Returns the received message ID: <br><br>  <b>size_t GetDataLength ()</b> <br>  Returns the data size of the received message in bytes. <br><br>  <b>void CopyDataTo (void * target)</b> <br>  Copies the message data to the specified buffer.  Memory for the buffer must be allocated in advance.  The buffer size must be at least the size of the message data (the result of calling the GetDataLength method) <br><br>  Thus, an example serving the receipt of a message sent in the past example looks like this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MessageReceiveTask::Execute() { Message msg; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { SmMessageReceiveArgs args; Result res = WaitUntilMessageReceived(args); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == ResultOk) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mid = args.GetMessageId(); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mid) { .... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> APP5_EXPOSE_MESSAGE_ID: <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> BOARD_LEFT _gfx-&gt;ExposeAirplaneRed(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> _gfx-&gt;ExposeAirplaneBlue(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> break; case APP5_AIRPLANE_MESSAGE_ID: { args.CopyDataTo(&amp;msg); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> BOARD_LEFT _gfx-&gt;UpdateAirplaneRed(msg.X, msg.Y, msg.Deg); _gfx-&gt;SetAirplaneRedVisibility(msg.Visibility); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> _gfx-&gt;UpdateAirplaneBlue(msg.X, msg.Y, msg.Deg); _gfx-&gt;SetAirplaneBlueVisibility(msg.Visibility); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } break; ...</span></span></code> </pre> <br><h3>  Synchronized context </h3><br>  Context is the area of ‚Äã‚Äãmemory that should be synchronized between all controllers.  The goal of synchronization can be any.  The simplest case is that one device informs the other about completed work steps for hot sparing.  If it fails, other devices will have information about how to pick up the work.  For devices that achieve the goal together, the exchange mechanism through the context may be more convenient than through messages.  Messages should be formed, transmitted, received, decoded.  And it is possible to work with context memory as with ordinary memory; it is only important not to forget to synchronize it so that the memory of one device is duplicated with the others. <br><br>  The number of synchronized contexts in the system can be arbitrary.  Therefore, it is not necessary to fit everything into one.  For different needs, you can create different synchronized contexts.  The size of the memory, the data structure in it and other parameters of the synchronized context is the concern of the application programmer (of course, the larger the amount of synchronized memory, the slower the synchronization occurs, which is why it is better to use different contexts of small size for different needs). <br><br>  In addition, even moments for synchronization sessions - and those are selected by the application programmer.  The RTOS MAX provides an API to provide, but an application programmer should call its functions.  This is due to the fact that the data exchange process is relatively slow.  If everything is left at the mercy of the operating system, then there may be delays at a time when the processor core should serve other tasks as much as possible.  If you automatically synchronize contexts too often, resources will be wasted, if too rarely, data may become outdated before the controllers are synchronized.  Add to this the question, whose data is more important (for example, if there are four different subscribers), after which it becomes absolutely clear - only an application programmer can initiate synchronization.  It is he who knows when it is better to do this, as well as which of the subscribers should distribute their data to the rest.  The OS also provides transparency of the operation for the application program. <br><br>  The context has its own numeric identifier (set by the application programmer).  All applications can have one synchronized context or several.  It is only important that their identifiers be consistent within the interacting controllers. <br>  The simplest examples of synchronized data are the cleaning robots periodically mark the territory they have cleaned on the map in order to know about the still uncleared areas, and also tell who is going where to go now, so as not to interfere with each other.  Wrenches working on one product, mark each screwed nut after the end of screwing, so that if one fails, the other would have finished its part.  A touch-screen board fixed the pressure and noted this fact for the rest of the boards.  Well, a lot of other cases where you need to share memory, but it is allowed to do this several times per second (maximum - several dozen times per second). <br><br>  Thus, the context can be represented in the form shown in the figure: <br><br><img src="https://habrastorage.org/webt/59/df/62/59df6260ecdd5701248535.jpeg"><br>  <b>Fig.</b>  <b>5. Context</b> <br><br>  And its purpose - can be represented in the following image: <br><br><img src="https://habrastorage.org/webt/59/df/62/59df6260a22f2294729837.jpeg"><br>  <b>Fig.</b>  <b>6. The essence of context synchronization</b> <br><br>  Now consider the functions that are used to synchronize the context: <br><br>  <b>Result GetContext (uint32_t context_id, void * data);</b> <br><br>  It copies the context data to the specified memory area, the memory must be allocated in advance.  Suitable for the case when the data length is known in advance (for example, a structure with simple fields). <br><br>  Arguments: <br><br>  context_id - context identifier; <br><br>  data - pointer to the memory area for storing the context; <br><br>  As a result, the context data with the specified identifier that was received during the last synchronization will be returned.  Thus, this function will work quickly, since the data is taken from a local copy of the context.  There is a second version of this function: <br><br>  <b>Result GetContext (uint32_tcontext_id, void * &amp; data, size_t &amp; data_length);</b> <br><br>  allocates memory and copies data and context length.  Suitable for the case when the length of the data is not known in advance (for example, an array of arbitrary length). <br><br>  Arguments: <br><br>  context_id - context identifier; <br><br>  data - pointer to the memory area for storing the context; <br><br>  data_length - the size in bytes of the memory area for storing the context. <br><br>  In principle, you can create a task that will wait for the context update, and then copy its new data into the application's memory.  The following function is suitable for this: <br><br>  <b>Result WaitUntilContextUpdated (uint32_t &amp; context_id, uint32_t timeout_ms = INFINITE_TIMEOUT)</b> <br><br>  Arguments: <br><br>  context_id - context identifier; <br><br>  timeout_ms - wait timeout in milliseconds.  If the time-out value is INFINITE_TIMEOUT, then the task will be blocked without the possibility of unlocking by time-out (endless waiting). <br><br>  Finally, consider the case when a task wants to update its context throughout the system (consisting of several controllers). <br><br>  First you need to capture the context.  To do this, use the following function: <br><br>  <b>Result LockContext (uint32_t context_id)</b> <br><br>  Argument: <br><br>  context_id - context identifier. <br><br>  <font color="ff0044"><b>The function requires the exchange between controllers, so it can take a long time.</b></font> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the context was able to be captured (if you try to capture at the same time, only one will win, the others will get an error code), then the context can be written using the following function: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result SetContext (uint32_t context_id, const void * data, size_t data_length)</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arguments: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">context_id - context identifier; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data - a pointer to the memory area for storing the context; </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_length - the size in bytes of the memory area for storing the context. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, to synchronize the context, call the function: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Result UnlockContext (uint32_t context_id)</font></font><br></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Argument: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">context_id - context identifier. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is after her call that the synchronization of contexts in the entire system will occur.</font></font><br><br> <font color="ff0044"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function requires the exchange between controllers, so it can take a long time.</font></font></b></font> <br><br><h3>  Work example </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider a real example of working with synchronized contexts that comes bundled with the OS. </font><font style="vertical-align: inherit;">The code is contained in the file ... \ maksRTOS \ Source \ Applications \ CounterApp.cpp </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this example, several devices increase a certain counter once a second (if you run this application on boards with a screen, the value of the counter will be displayed visually). </font><font style="vertical-align: inherit;">If one of the controllers is disabled and then enabled, it will receive the current contents of the counter and will work along with all. </font><font style="vertical-align: inherit;">Thus, the system will keep counting as long as at least one of the controllers is ‚Äúalive‚Äù in it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The application programmer who did this example chose the context identifier on the principle: ‚ÄúWhy not?‚Äù</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m_context_id = <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The memory to be synchronized looks easy: </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> m_counter;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main actions that interest us occur in the function: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void CounterTask :: Execute ()</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, the controller tries to figure out: is it the first one in the system? </font><font style="vertical-align: inherit;">For this, it tries to get the context:</font></font><br><br><pre> <code class="cpp hljs"> Result result = GetContext(m_context_id, &amp; m_counter);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the controller is not the first, then the context will be received, but the value of the counter, which exists in the system, will also be received in passing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the controller is first, the context will not be received. </font><font style="vertical-align: inherit;">In this case, it should be created, which is done as follows (in the same place, the counter is zero);</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( result != ResultOk ) { m_counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; result = LockContext(m_context_id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( result == ResultOk ) { SetContext(m_context_id, &amp; m_counter, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(m_counter)); UnlockContext(m_context_id); } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything, now the context exactly exists, it was found in the system to which we just connected, or created by us. </font><font style="vertical-align: inherit;">Enter an infinite loop:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) {</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There we wait one second: </font></font><br><br><pre> <code class="cpp hljs"> Delay(MAKS_TICK_RATE_HZ);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we are trying to win a contest for the right to distribute our counter to the whole system: </font></font><br><br><pre> <code class="cpp hljs"> result = LockContext(m_context_id);</code> </pre> <br>     ‚Äî  <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( result == ResultOk ) { GetContext(m_context_id, &amp; m_counter); ++ m_counter; SetContext(m_context_id, &amp; m_counter, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(m_counter)); UnlockContext(m_context_id); }</code> </pre><br>  ,   ,   .   ,          .   ,     .  ,    ,        ,     ,         ,              .     , ,   - . </div><p>Source: <a href="https://habr.com/ru/post/339498/">https://habr.com/ru/post/339498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339484/index.html">Traffic Sign Recognition Using CNN: Spatial Transformer Networks</a></li>
<li><a href="../339488/index.html">How to involve users in the gaming world: contests and interactivity in social networks. Cases of the Krasnodar studio Plarium</a></li>
<li><a href="../339490/index.html">Step-by-step instructions for creating an SMS web application using the SMS API from Infobip</a></li>
<li><a href="../339492/index.html">C / C ++ code optimization</a></li>
<li><a href="../339496/index.html">Fuel for AI: a selection of open datasets for machine learning</a></li>
<li><a href="../339500/index.html">What the Android DevOps-engineer head hurts</a></li>
<li><a href="../339502/index.html">Fintech track GenerationS - another chance for your fintech startup</a></li>
<li><a href="../339504/index.html">Generalized search for paths for AI in platformers</a></li>
<li><a href="../339506/index.html">OpenCV. Search for road signs using contour analysis in Android</a></li>
<li><a href="../339508/index.html">How to run docker-voting on Swarm, Kubernetes and Nomad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>