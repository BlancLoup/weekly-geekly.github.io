<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Solve RAII problems with std :: thread: cancellation_token as an alternative to pthread_cancel and boost :: thread :: interrupt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article deals with problems in std :: thread, simultaneously resolving an ancient dispute on the topic "what to use: pthread_cancel, a boolean fla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Solve RAII problems with std :: thread: cancellation_token as an alternative to pthread_cancel and boost :: thread :: interrupt</h1><div class="post__text post__text-html js-mediator-article"><p>  The article deals with problems in std :: thread, simultaneously resolving an ancient dispute on the topic "what to use: pthread_cancel, a boolean flag or boost :: thread :: interrupt?" </p><br><h2>  Problem </h2><br><p>  The class std :: thread, which was added to C ++ 11, has one unpleasant feature - it does not correspond to the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">RAII</a> idiom <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">(Resource Acquisition Is Initialization)</a> .  Excerpt from <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">standard</a> : </p><br><blockquote>  30.3.1.3 thread destructor <br>  ~ thread (); <br>  If joinable () then <strong>terminate ()</strong> , otherwise no effects. </blockquote><br><p> What we face such a destructor?  The programmer must be very careful when it comes to the destruction of the object <code>std::thread</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dangerous_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">thread </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([] { do_something(); })</span></span></span></span>; do_another_thing(); <span class="hljs-comment"><span class="hljs-comment">// may throw - can cause termination! t.join(); }</span></span></code> </pre> <br><p><a name="habracut"></a>  If an exception is thrown from the <code>do_another_thing</code> function, the <code>std::thread</code> destructor will terminate the entire program by calling <code>std::terminate</code> .  What can be done with this?  Let's try to write a RAII wrapper around <code>std::thread</code> and see where this attempt takes us. </p><br><h3>  Add RAII to std :: thread </h3><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_wrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Constructors ~thread_wrapper() { reset(); } void reset() { if (joinable()) { // ??? } } // Other methods private: std::thread _impl; };</span></span></code> </pre> <br><p>  <code>thread_wrapper</code> copies the <code>std::thread</code> interface and implements another additional function - <code>reset</code> .  This function should translate the stream into a non-joinable state.  The destructor calls this function, so after that <code>_impl</code> will <code>_impl</code> without calling <code>std::terminate</code> . </p><br><p>  In order to translate the <code>_impl</code> into a non-joinable state, <code>reset</code> has two options: <code>detach</code> or <code>join</code> .  The problem with <code>detach</code> is that the thread will continue to run, wreaking havoc and disrupting the RAII idiom.  So our choice is <code>join</code> : </p><br><pre> <code class="cpp hljs">thread_wrapper::reset() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (joinable()) join(); }</code> </pre> <br><h3>  Serious problem </h3><br><p>  Unfortunately, such a <code>thread_wrapper</code> implementation is no better than the usual <code>std::thread</code> .  Why?  Let's consider the following usage example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; alive{<span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-function"><span class="hljs-function">thread_wrapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;alive] { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params">(alive) do_something(); })</span></span></span></span>; do_another_thing(); alive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  If an exception is <code>do_another_thing</code> from <code>do_another_thing</code> , then crash will not occur.  However, calling <code>join</code> from the <code>thread_wrapper</code> destructor will <code>thread_wrapper</code> <em>forever</em> , because <code>alive</code> will never <code>thread_wrapper</code> <code>false</code> and the thread will never end. </p><br><p>  The thing is that the <code>thread_wrapper</code> object <code>thread_wrapper</code> no way to influence the function being executed in order to ‚Äúask‚Äù it to complete.  The situation is further complicated by the fact that in the <code>do_something</code> function, the execution thread may well ‚Äúfall asleep‚Äù on the condition variable or in the blocking call of the operating system. </p><br><p>  Thus, to solve the problem with the <code>std::thread</code> destructor, a more serious problem needs to be solved: </p><br><p>  <strong>How to interrupt the execution of a long-term function, especially if in this function the thread of execution can "fall asleep" on a conditional variable or in the blocking call of the OS?</strong> </p><br><p>  A special case of this problem is the interruption of the entire execution flow.  Let's look at three existing ways to interrupt the thread: <code>pthread_cancel</code> , <code>boost::thread::interrupt</code> and a boolean flag. </p><br><h2>  Existing solutions </h2><br><h3>  <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_cancel.html">pthread_cancel</a> </h3><br><p>  Sends an interrupt request to the selected thread.  The POSIX specification contains a <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_09.html">special list of</a> interrupted functions ( <code>read</code> , <code>write</code> , etc.).  After calling <code>pthread_cancel</code> for any thread, these functions in this thread begin to throw an exception of a special type.  This exception cannot be ignored - a catch-block that caught such an exception <em>must</em> throw it further, so this exception completely unwinds the thread stack and ends it.  A thread can temporarily prohibit the interruption of its calls using the <code>pthread_setcancelstate</code> function (one possible use: to avoid exceptions from destructors, logging functions, etc.). </p><br><p>  Pros: </p><br><ul><li>  You can interrupt waiting on conditional variables. </li><li>  You can interrupt OS blocking calls. </li><li>  Difficult to ignore interrupt request </li></ul><br><p>  Minuses: </p><br><ul><li>  Major portability issues: in addition to the obvious lack of <code>pthread_cancel</code> on <strong>Windows</strong> , it is also missing in some libc implementations (for example, <strong>bionic</strong> , which is used in <strong>Android</strong> ) </li><li>  Issues with <code>std::condition_variable::wait</code> in C ++ 14 and later standards </li><li>  May cause problems in C code that uses interrupted functions (probable list of special effects: resource leaks, unlocked mutexes, etc.) </li><li>  Interrupted functions in a destructor require special precautions (for example, <code>close</code> is an interrupted function) </li><li>  Cannot be used in the environment without exceptions </li><li>  Cannot be used to interrupt individual functions or tasks. </li></ul><br><p>  Problems with <code>std::condition_variable::wait</code> occur because in C ++ 14 <code>std::condition_variable::wait</code> received the <code>noexcept</code> specification.  If you enable interrupts with <code>pthread_setcancelstate</code> , then we lose the ability to interrupt waiting on conditional variables, and if interrupts are enabled, then we are not able to meet the <code>noexcept</code> specification, because we cannot "swallow" this <em>special</em> exception. </p><br><h3>  <a href="http://www.boost.org/doc/libs/1_61_0/doc/html/thread/thread_management.html">boost :: thread :: interrupt</a> </h3><br><p>  The <strong>Boost.Thread</strong> library provides an optional thread termination mechanism, somewhat similar to <code>pthread_cancel</code> .  In order to interrupt the thread of execution, just call the corresponding object <code>boost::thread</code> method <code>interrupt</code> .  You can check the status of the current thread using the function <code>boost::this_thread::interruption_point</code> : in the interrupted thread, this function throws an exception of type <code>boost::thread_interrupted</code> .  If the use of exceptions is prohibited by using BOOST_NO_EXCEPTIONS, then you can use <code>boost::this_thread::interruption_requested</code> to check the status.  <strong>Boost.Thread</strong> also allows you to interrupt wait in <code>boost::condition_variable::wait</code> .  To do this, use thread-local storage and an extra mutex inside the condition variable. </p><br><p>  Pros: </p><br><ul><li>  Portability </li><li>  You can abort <code>boost::condition_variable::wait</code> </li><li>  Can be used in the environment without exceptions. </li></ul><br><p>  Minuses: </p><br><ul><li>  Binding to <strong>Boost.Thread</strong> - this interrupt mechanism cannot be used with standard conditional variables or threads </li><li>  Requires additional mutex inside <code>condition_variable</code> </li><li>  Overhead: adds two extra locks / unlocks of mutexes to each <code>condition_variable::wait</code> </li><li>  You can not interrupt the blocking calls OS </li><li>  It is problematic to use to interrupt individual functions or tasks (judging by the code, this can be done only with the use of exceptions) </li><li>  Minor violation of the philosophy of exceptions - interruption of the flow is not an exceptional situation in the program life cycle </li></ul><br><h3>  Boolean flag </h3><br><p>  If you read questions about <code>pthread_cancel</code> ( <a href="http://stackoverflow.com/questions/4760687/cancelling-a-thread-using-pthread-cancel-good-practice-or-bad">1</a> , <a href="http://stackoverflow.com/questions/2084830/kill-thread-in-pthread-library">2</a> , <a href="http://stackoverflow.com/questions/7961029/how-can-i-kill-a-pthread-that-is-in-an-infinite-loop-from-outside-that-loop">3</a> , <a href="http://stackoverflow.com/questions/3822674/for-pthread-how-to-kill-child-thread-from-the-main-thread">4</a> ) on StackOverflow, then one of the most popular answers is: "Use the boolean flag instead of <code>pthread_cancel</code> ". </p><br><p>  The atomic variable <code>alive</code> in our example with exceptions is the boolean flag: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; alive{<span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-function"><span class="hljs-function">thread_wrapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;alive] { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params">(alive) do_something(); })</span></span></span></span>; do_another_thing(); <span class="hljs-comment"><span class="hljs-comment">// may throw alive = false; }</span></span></code> </pre> <br><p>  Pros: </p><br><ul><li>  Platform independent </li><li>  There are obvious breakpoint execution points </li></ul><br><p>  Minuses: </p><br><ul><li>  Code duplication </li><li>  It prevents the decomposition - there is no simple and effective way to write a blocking function </li><li>  You cannot interrupt waiting on conditional variables (especially if they are outside the class with a boolean flag) </li><li>  You can not interrupt the blocking calls OS </li></ul><br><h2>  Cancellation token </h2><br><p>  What to do?  Let's take the boolean flag as the basis and start solving the problems associated with it.  Code duplication?  Great - let's wrap the boolean flag in a separate class.  Let's call it <code>cancellation_token</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellation_token</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !_cancelled; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ _cancelled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; _cancelled; };</code> </pre> <br><p>  Now you can put the <code>cancellation_token</code> in our <code>thread_wrapper</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_wrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Constructors ~thread_wrapper() { reset(); } void reset() { if (joinable()) { _token.cancel(); _impl.join(); } } // Other methods private: std::thread _impl; cancellation_token _token; };</span></span></code> </pre> <br><p>  Great, now it only remains to pass the reference to the token to the function that is executed in a separate thread: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_wrapper</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> _impl = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread(f, args..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(_token)); }</code> </pre> <br><p>  Since we write <code>thread_wrapper</code> for illustrative purposes, we can still not use <code>std::forward</code> and, at the same time, ignore the problems that will arise in the move-constructor and the <code>swap</code> function. </p><br><p>  It is time to recall the example with <code>use_thread</code> and exceptions: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; alive{<span class="hljs-literal"><span class="hljs-literal">true</span></span>}; <span class="hljs-function"><span class="hljs-function">thread_wrapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([&amp;alive] { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params">(alive) do_something(); })</span></span></span></span>; do_another_thing(); alive = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><p>  In order to add support for the <code>cancellation_token</code> , we just need to add the correct argument to the lambda and remove <code>alive</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use_thread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">thread_wrapper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">t</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([] (cancellation_token&amp; token) { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params">(token) do_something(); })</span></span></span></span>; do_another_thing(); }</code> </pre> <br><p>  Wonderful!  Even if an exception is <code>do_another_thing</code> from <code>do_another_thing</code> destructor <code>thread_wrapper</code> still call <code>cancellation_token::cancel</code> and the thread will complete its execution.  In addition, by removing the code of the boolean flag in the <code>cancellation_token</code> , we significantly reduced the amount of code in our example. </p><br><h3>  Interrupt waiting </h3><br><p>  It is time to teach our tokens to interrupt blocking calls, for example, waiting on conditional variables.  To abstract from specific interrupt mechanisms, we need the <code>cancellation_handler</code> interface: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellation_handler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  A handler for interrupting waiting on a condition variable looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cv_handler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cancellation_handler { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: cv_handler(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable&amp; condition, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;mutex&gt;&amp; lock) : _condition(condition), _lock(lock) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">unique_lock </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_lock.get_mutex())</span></span></span></span>; _condition.notify_all(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::condition_variable&amp; _condition; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;mutex&gt;&amp; _lock; };</code> </pre> <br><p>  Now it‚Äôs enough to put a pointer to <code>cancellation_handler</code> in our <code>cancellation_token</code> and call <code>cancellation_handler::cancel</code> from <code>cancellation_token::cancel</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cancellation_token</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex _mutex; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::atomic&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; _cancelled; cancellation_handler* _handler; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !_cancelled; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;mutex&gt; l(_mutex); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_handler) _handler-&gt;cancel(); _cancelled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cancellation_handler* handler)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;mutex&gt; l(_mutex); _handler = handler; } };</code> </pre> <br><p>  An interrupted version of waiting on a condition variable looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancellable_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::condition_variable&amp; cv, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::unique_lock&lt;mutex&gt;&amp; l, cancellation_token&amp; t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">cv_handler </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cv, l)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// implements cancel() t.set_handler(&amp;handler); cv.wait(l); t.set_handler(nullptr); }</span></span></code> </pre> <br><p>  <strong>Attention!</strong>  <strong>The implementation is unsafe, both in terms of exceptions and thread safety.</strong>  <strong>She is here only to illustrate how the <code>cancellation_handler</code> works.</strong>  <strong>Links to the correct implementation can be found at the end of the article.</strong> </p><br><p>  By implementing the corresponding <code>cancellation_handler</code> , you can teach the token to interrupt the blocking calls of the OS and the blocking functions from other libraries (if these functions have at least some mechanism to interrupt the wait). </p><br><h3>  Rethread library </h3><br><p>  The described tokens, handlers and threads are implemented as an open-source library: <a href="https://github.com/bo-on-software/rethread">https://github.com/bo-on-software/rethread</a> , with <a href="">documentation</a> (in English), <a href="https://github.com/bo-on-software/rethread_testing">tests and benchmarks</a> . </p><br><p>  Here is a list of the main differences between the above code and the one implemented in the library: </p><br><ul><li>  <code>cancellation_token</code> is an interface with several implementations.  Interrupted functions get <code>cancellation_token</code> via <strong>constant</strong> link. </li><li>  Token uses atomics instead of mutexes for frequently used operations. </li><li>  The wrapper over the thread is called <code>rethread::thread</code> </li></ul><br><p>  What is in the library: </p><br><ul><li>  Tokens </li><li>  RAII compliant streams </li><li>  Interrupted wait on any conditional variables that are interface compatible with <code>std::condition_variable</code> </li><li>  Interrupted wait in <code>poll</code> - this allows you to implement interrupt versions of many POSIX blocking calls ( <code>read</code> , <code>write</code> , etc.) </li></ul><br><h4>  Performance </h4><br><p>  The measurements were carried out on a laptop with an Intel Core i7-3630QM @ 2.4GHz processor. </p><br><p>  Below are the results of benchmarks tokens from <code>rethread</code> . <br>  The performance of the following operations was measured: </p><br><ul><li>  Status checking is the price of calling the <code>cancellation_token::is_cancelled()</code> function (or its equivalent contextual conversion to a boolean type) </li><li>  Calling an interrupted function is the overhead of one interrupted blocking function: registering the handler in the token before the call and "unregistering" after the end of the call </li><li>  Creating one <code>standalone_cancellation_token</code> </li></ul><br><h5>  Ubuntu 16.04 </h5><br><table><thead><tr><th></th><th>  CPU time, ns </th></tr></thead><tbody><tr><td>  Check token status </td><td>  1.7 </td></tr><tr><td>  Call interrupted function </td><td>  15.0 </td></tr><tr><td>  Creating a token </td><td>  21.3 </td></tr></tbody></table><br><h5>  Windows 10 </h5><br><table><thead><tr><th></th><th>  CPU time, ns </th></tr></thead><tbody><tr><td>  Check token status </td><td>  2.8 </td></tr><tr><td>  Call interrupted function </td><td>  17.0 </td></tr><tr><td>  Creating a token </td><td>  33.0 </td></tr></tbody></table><br><h4>  Negative Overhead </h4><br><p>  Such low overhead costs for interruptibility create an interesting effect: <br>  <strong>In some situations, the interrupted function is <em>faster</em> than the ‚Äúnormal‚Äù approach.</strong> <br>  In the code without using tokens, blocking functions cannot be blocked forever - then it will not be possible to achieve "normal" application termination (perversions like <code>exit(1);</code> it cannot be considered the norm).  In order to avoid perpetual blocking and regularly check the status, we need a timeout.  For example, such: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (alive) { _condition.wait_for(lock, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  First, such a code will wake up every 100 milliseconds only to check the flag (the timeout value can be increased, but it is limited from above by the "reasonable" application completion time). </p><br><p>  Secondly, this code is not optimal even without such meaningless awakenings.  The fact is that the call <code>condition_variable::wait_for(...)</code> less effective than <code>condition_variable::wait(...)</code> : at a minimum, it needs to get the current time, count the wake-up time, etc. </p><br><p>  To prove this statement, two synthetic benchmarks were written in rethread_testing, in which two primitive implementations of a multi-threaded queue were compared: ‚Äúregular‚Äù (with timeout) and interrupted (with tokens).  Measured processor time spent waiting for a single object to appear in the queue. </p><br><table><thead><tr><th></th><th>  CPU time, ns </th></tr></thead><tbody><tr><td>  Ubuntu 16.04 &amp; g ++ 5.3.1 ("normal" queue) </td><td>  5913 </td></tr><tr><td>  Ubuntu 16.04 &amp; g ++ 5.3.1 (interrupted queue) </td><td>  5824 </td></tr><tr><td>  Windows 10 &amp; MSVS 2015 ("normal" queue) </td><td>  2467 </td></tr><tr><td>  Windows 10 &amp; MSVS 2015 (interrupted queue) </td><td>  1729 </td></tr></tbody></table><br><p>  So, on MSVS 2015, the interrupted version runs 1.4 faster than the "regular" version with timeouts.  On Ubuntu 16.04, the difference is not so noticeable, but even there the interrupted version clearly outperforms the ‚Äúnormal‚Äù one. </p><br><h3>  Conclusion </h3><br><p>  This is not the only possible solution to this problem.  The most tempting alternative is to put a token in the thread-local storage and throw an exception when it is interrupted.  The behavior will be similar to <code>boost::thread::interrupt</code> , but without an additional mutex in each conditional variable and with significantly less overhead.  The main disadvantage of this approach is the already mentioned violation of the philosophy of exceptions and the non-obviousness of breakpoints. </p><br><p>  An important advantage of the approach with tokens is that it is possible not to interrupt entire streams, but to separate tasks, and if you use the <code>cancellation_token_source</code> implemented in the library, then you can have several tasks at the same time. </p><br><p>  Almost all of my Wishlist in the library I implemented.  In my opinion, there is not enough integration with blocking calls to the system, such as working with files or sockets.  Write interruptible versions for <code>read</code> , <code>write</code> , <code>connect</code> , <code>accept</code> , etc.  it will not be difficult, the main problems are the unwillingness to put tokens in standard iostreams and the lack of a generally accepted alternative. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306332/">https://habr.com/ru/post/306332/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306318/index.html">Infectious distribution of advertising in social networks</a></li>
<li><a href="../306322/index.html">10 techniques used by manipulators (and how to deal with them)</a></li>
<li><a href="../306324/index.html">Implementation of the Bailey ‚Äî Borwein ‚Äî Plaff algorithm on Golang</a></li>
<li><a href="../306326/index.html">Help Desk and Service Desk - when is Excel and CRM insufficient? Really important functions of accounting systems</a></li>
<li><a href="../306328/index.html">10 errors leading to software overgraining</a></li>
<li><a href="../306334/index.html">Elixir: Getting Started with Plug</a></li>
<li><a href="../306336/index.html">Skills and requirements for information security professionals</a></li>
<li><a href="../306338/index.html">Stripe: your dream service to automate money transfers</a></li>
<li><a href="../306340/index.html">Summer update on Habr√©: ‚ÄúAdministration‚Äù, voice weight and much more</a></li>
<li><a href="../306342/index.html">Prospects for the commercial use of IPv6 in Russia (year 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>