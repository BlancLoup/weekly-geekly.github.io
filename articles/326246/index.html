<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Green light to developers - from startup to the stars. Valentin Gogichashvili</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The PG Day conference is held for the fourth time. During this time we have accumulated a large base of useful materials from our speakers. The level ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Green light to developers - from startup to the stars. Valentin Gogichashvili</h1><div class="post__text post__text-html js-mediator-article"> <i>The PG Day conference is held for the fourth time.</i>  <i>During this time we have accumulated a large base of useful materials from our speakers.</i>  <i>The level of reports in the industry every year is becoming higher and higher, but there are topics that, like good wine, do not lose their relevance.</i> <i><br><br></i>  <i>At one of the past PG Day, <b>Valentin Gogichashvili</b> , who heads Data Engineering in Zalando, told how PostgreSQL is used in a company with a large staff of developers, highly dynamic processes, and how they came to this choice.</i> <i><br><br></i>  <i>It's no secret that Zalando is a regular guest at PG Day.</i>  <i>At PG Day'17 Russia we will present you three wonderful reports from German colleagues.</i>  <i><a href="http://pgday.ru/ru/2017/speakers/23%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">Murat Kabilov</a> and <a href="http://pgday.ru/ru/2017/speakers/50%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">Alexey Klyukin</a> will talk about the internal development of Zalando for the <a href="http://pgday.ru/ru/2017/papers/195%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">deployment of highly accessible PostgreSQL clusters</a> .</i>  <i><a href="http://pgday.ru/ru/2017/speakers/82%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">Alexander Kukushkin</a> will tell about the <a href="http://pgday.ru/ru/2017/papers/136%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">practice of operating PostgreSQL in AWS</a> .</i>  <i><a href="http://pgday.ru/ru/2017/speakers/64%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">Dmitry Dolgov</a> will help to understand the <a href="http://pgday.ru/ru/2017/papers/127%3Futm_source%3Dhabr%26utm_medium%3Dpost%26utm_campaign%3Dzalando">internals and performance of the JSONB data type</a> in the context of using PostgreSQL as a document-oriented storage.</i> <br><a name="habracut"></a><br><img src="https://habrastorage.org/web/a82/3b4/b70/a823b4b70097456ba4fb1f9f88771da7.jpg"><br>  For the first time in my entire life I will present it in Russian.  Do not judge if any translations and terms will be very funny for you.  I'll start with myself.  I am Valentine, head of Data Engineering in Zalando. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/ad1/24b/cc2/ad124bcc2304468596c78f0b14a4c57b.jpg"><br><br><img src="https://habrastorage.org/web/bae/c1e/6a0/baec1e6a02c241739790f6f27359a040.jpg"><br><img src="https://habrastorage.org/web/47b/380/a15/47b380a1556f4e8da56e96b36896c933.jpg"><br>  <b>Zalando</b> is a very famous in Europe online store selling shoes and everything related to clothing.  That's how it looks about.  Brand awareness of about 98% in Germany, our marketers did a very good job.  Unfortunately, when marketers work well, it becomes very bad technology departments.  At the time when I came to Zalando 4 years ago, our department consisted of 50 people, and we grew by 100% per month.  And so it went on for a very long time.  Now we are one of the biggest online stores.  We have three warehouse centers, millions of users and 8 thousand employees. <br><br><img src="https://habrastorage.org/web/ea1/837/203/ea1837203bf94a4ea4903032780b7258.jpg"><br><img src="https://habrastorage.org/web/a3c/57c/99b/a3c57c99bdbe48ce918998adb4dc77dc.jpg"><br>  Behind the interface screen, you have a great idea; terrible things are happening, including such warehouses: we have three such things.  And this is only one small room, which is sorted.  From a technological point of view, everything is much more beautiful, it is very good to draw diagrams.  We have a wonderful person who can draw. <br><br><img src="https://habrastorage.org/web/0a1/8c8/a43/0a18c8a432fa40a4babd5c0e53e549a5.jpg"><br><br>  Postgres occupies one of the most important niches in our structure, because Postgres records everything related to user data.  In fact, Postgres records everything except search data.  We are looking at Solar's.  Our technology office currently employs 700 people.  We grow very fast and are constantly looking for people.  Berlin has a large office.  Smaller offices in Dortmund, Dublin and Helsinki.  In Helsinki, opened literally last month, there is now going hiring. <br><br><img src="https://habrastorage.org/web/76c/a24/4c6/76ca244c659944c0a667c89307f99c09.jpg"><br><img src="https://habrastorage.org/web/973/aaa/d81/973aaad8146a47cd926b616691e13a85.jpg"><br><br>  <b>What are we doing as a technology company?</b> <br><br>  We used to be <b>Java</b> and <b>Postgres</b> company: everything was written in Java and recorded in Postgres.  In March 2015, we announced the concept of <b>radical agility</b> , which gives our teams endless autonomy with the choice of technology.  Therefore, it is very important for us that Postgres is still the technology for our developers that they will choose themselves, and not I will come and say, ‚ÄúWell, let's write to Postgres‚Äù.  Six terabytes occupies the base for ‚Äútransactional‚Äù data.  The largest database that is not included there is the event log, which we use to record our timeseries, business events (about 7 terabytes).  It is interesting to work with this data.  Many new things you learn about everything. <br><br><img src="https://habrastorage.org/web/c6d/e68/fe8/c6de68fe8ac840b195308bb394129a0b.jpg"><br><br>  <b>What problems do we have?</b> <br><br>  Constant growth, fast weekly development cycles: new features roll out every week.  And downtime is not encouraged.  Recently, we have a problem - autonomous development teams are dragging databases into their Amazon AWS accounts, and DBA-shniki do not have access to these databases. <br><br><img src="https://habrastorage.org/web/ed9/a49/12f/ed9a4912f47e4f35a6c381c24fa5ecf6.jpg"><br><br>  I will tell about how we change the data scheme so that the production does not stand idle.  How we work with data (access to databases in Zalando is carried out through a layer of stored procedures).  I will explain very briefly why I think this is important.  And as we shardim, as we break the database, also tell. <br><br><img src="https://habrastorage.org/web/3a9/c35/a5b/3a9c35a5b5ff44f98d51eccc8829b34c.jpg"><br><br>  So, in Postgres, one of the most important abilities is the <b>ability to change data schemes with virtually no locks</b> .  The problems that exist in Oracle, in MySQL and in many other systems, and which essentially led to the fact that NoSQL databases have risen as full members of our friendly family of databases, lies in the fact that other databases cannot so quickly and well change data schemas.  In PostgreSQL no locks are needed to add a column or rename it, drop it or add default values, expand directories. <br><br>  All that is needed is a barrier lock, which must ensure that no one else touches this table, and change the directory.  Almost all operations do not require rewriting gigabytes of data.  It's the most important.  In particular, it is possible to create and delete indexes CONCURRENTLY (an index will be created without locking your table). <br><br>  Problems after all exist with.  Until now, it is not possible to add constraint <b>NOT NULL</b> to a large giant table without having to check that there are really no zero values ‚Äã‚Äãin the table in the columns.  This is correct because we trust constraints.  But, unfortunately, there are a couple of exceptions that need to be applied in order for all this to work well, there are no scary locks that will stop the entire system. <br><br><img src="https://habrastorage.org/web/a52/d0f/a59/a52d0fa59a7942e0b907ca81518f4b07.jpg"><br><br>  How did we organize it?  When I started in Zalando, I was the only DBA.  I wrote all the scripts that change the database structure.  Then we realized that it was terrible, because we need to do this on every staging environment.  I started dumping directories in different environments and comparing them with diffs.  There was an idea to automate the creation of dbdiffs.  I realized that it‚Äôs not possible to waste time on such a tool, and it‚Äôs still easier to write with my hands the transition scripts from one version to another.  But the name dbdiff remains. <br><br>  With the growth that we had, it became impossible to write dbdiff by ourselves.  So we had to teach developers to write SQL, train them and certify the basics of PostgreSQL, so that they understand how the database works, why there are locks, where regressions occur, etc.  Therefore, we have introduced certification for "releasers".  Only a person with such a certificate of our team receives administrative rights to the base and can stop the system.  We, of course, come to the rescue and help, advise, do everything to ensure that the guys do not have problems. <br><br><img src="https://habrastorage.org/web/35c/d40/6ba/35cd406bac0d4025b05045abae537c56.jpg"><br><img src="https://habrastorage.org/web/6ab/699/d97/6ab699d973db4a6bbd562275a9067022.jpg"><br><br>  Here is an example of what a very simple dbdiff looks like: the order_address and foreign key table is added.  The problem is that if the table is changed during development, the source of this table must be changed each time.  Since each object, each table lies in a separate file in git, you need to go in and change dbdiff every time, you can use the excellent opportunity pl / pgsql to load files from a directory. <br><br><img src="https://habrastorage.org/web/2ac/506/e27/2ac506e27f1941d09ab0fb968f1e8152.jpg"><br><br>  Interestingly, the operation of adding a foreign key constraint is problematic because it requires locking the entire table, which can take a lot of time.  In order to protect yourself, we recommend that you set statement_timeout to all - the number of seconds during which it is permissible for your system to keep locks.  If the table fits in memory, 3 seconds is usually enough.  If it does not fit, you will not scan it in 3 seconds. <br><br><img src="https://habrastorage.org/web/e8d/d81/c7a/e8dd81c7a3f446dbb4352ea331166176.jpg"><br><img src="https://habrastorage.org/web/28d/b60/6c7/28db606c7c4e4433aa3145b59109ad2c.jpg"><br><br>  What else helps us?  We are helped by the tools we wrote.  <b>pg_view</b> collects all the database information we need, including locks, the partition occupancy with xlog.  It looks something like top.  This tool collects information about how much disk space is left so that you can stop the migration in time if something goes wrong and shows locks that occur in the database. <br><br>  <b>nice_updater</b> is a program that controls the database, looks at its load, the workload of the xlog-partitions, slowly, 10-100 thousand records, executes update statements, periodically starts a vacuum.  So we are doing big migrations.  If you need to add some table or write new values ‚Äã‚Äãto additional columns, this is very easy to do with nice_updater.  We rolled out some operation, due to which a few gigabytes of incorrect data was formed, they need to be rewritten - nice_updater helps us very well.  In my opinion, it is already in open source.  We try all of our tools ‚Äúopen source‚Äù: the quality of the code is very high, documentation appears. <br><br>  The biggest advice I can give is to force programmers to write code that is equal to everything, is there a database or not.  Our biggest mistake was that Postgres worked too well, the developers thought that the database is always like gravity.  Therefore, any disconnection of the database for 2 seconds is regarded by our developers as a horror and a complete disaster.  They do not write ROLLBACK, do not handle errors of this type, they do not have tests. <br><br>  Having the ability to disable the base for 30 seconds in order to conduct an upgrade or do something else with the base is, in fact, the first thing to be.  Today, Andres and I [ca.  Ed .: <a href="https://pgday.ru/ru/2015/speakers/37">Andres Freund</a> ] said that in general you need to make a mode that will randomly disable connections, so that developers learn to write normal code.  We have a script that kills everything that takes more than five minutes.  Statement timeout is set to 30 seconds by default.  If someone writes a procedure that takes more than 30 seconds, he needs to give good reasons. <br><br><img src="https://habrastorage.org/web/eca/0b2/a29/eca0b2a298464d24924bd901810038f8.jpg"><br><img src="https://habrastorage.org/web/9f6/015/4d2/9f60154d2f7548bfad7afc176757f6db.jpg"><br><img src="https://habrastorage.org/web/c48/f1c/bfd/c48f1cbfd7ba4bffb4a66429160e73c1.jpg"><br><br>  <b>What do stored procedures give us?</b> <br><br>  The biggest advantage is the ability to replace data on the fly: add a new empty column, reading data from the old column.  Then turn on the record in both columns and do readings from the new one, implementing a fallback to the old one using coalesce.  Then migrate the data to a new column.  And then you can already throw out the old one.  A couple of times we did normalization of the tables so that the application code did not know about it at all.  This feature is important for keeping the system in working condition. <br><br>  With good training and with good tools, we managed in principle to avoid downtime caused by migrations or changes in the data structure.  In order to understand the scale of the number of changes: we have about 100 dbdiffs rolling out per database.  And they basically change the tables.  They regularly say that relational databases lack flexibility in changing data structures.  It is not true. <br><br>  We try to do dbdiff transactions, but, unfortunately, there are commands that are not transactional, for example, changing enum. <br><br><img src="https://habrastorage.org/web/04b/1cd/d59/04b1cdd59dd34308ab7e2236790d70cc.jpg"><br><img src="https://habrastorage.org/web/43d/56a/4c8/43d56a4c806c44d397cfff4567fafcf2.jpg"><br><img src="https://habrastorage.org/web/932/02a/615/93202a6158164cccb3cdfe603a34145a.jpg"><br><br>  <b>How do they usually refer to the data?</b> <br><br>  Here we have a classical structure - a hierarchy of objects: customer, it has a bank account.  There are many different orders, orders are listed positions.  What is good about this hierarchy?  Objects that are tied to a customer are associated only with it.  In most cases, we do not need to go beyond this hierarchy.  We are not interested at all when placing an order with Customer A, which orders are available with Customer B, and vice versa.  Everyone knows that there are a lot of advantages: you stay in your comfort zone, use the same language in which you write business logic. <br><br>  But we had big problems with hibernate, to teach developers to write code that will work well with transactions.  Developers are trying to load the entire table into memory, then do something with it and commit some parts in a couple of minutes.  A long transaction remains, and the longer it is, the more difficult it is to make migrations in schemas.  Tables must be constantly displayed in the code.  We have no such thing as a database separate from the application.  We call this data logic.  In essence, these are constraints that are superimposed on the data, and it is convenient to keep them in stored procedures.  This is not possible with migrations.  In fact, this is a separate data layer. <br><br>  If there are no stored procedures, it is better to have an abstract layer inside the application.  Netflix, for example, also does this.  They have a special library, with which they completely abstract data access through the data layer.  Thus, they migrated from Oracle to Cassandra: they divide logic into business and data, and then replace business logic with another database.  But changing the scheme in such a situation can be a nightmare. <br><br><img src="https://habrastorage.org/web/eac/b5a/9f3/eacb5a9f32704d92988e00c7da512b91.jpg"><br><br>  <b>NoSQL</b> is a great thing, you can take this whole hierarchy along with all the orders and create one document.  Nothing needs to be initialized, everything is written directly in JSON.  Transactions are not needed: what is recorded, then recorded.  There are implicit schemes.  How to work with this when the structure of the document begins to change and where to push all this logic?  This is scary.  At the moment, unfortunately, there is not a single NoSQL database, except PostgreSQL, which is in ACID and does not lose data. <br><br>  And, accordingly, in NoSQL there is no SQL.  SQL is a very powerful language for analytic operations, converts data very quickly.  To do all this, for example, in Java is also somehow scary. <br><br><img src="https://habrastorage.org/web/620/078/a13/620078a1380645fbbbf5d8bd99b9c576.jpg"><br><br>  <b>What are the alternatives to ORM?</b> <br><br>  Direct SQL queries.  You can pull aggregates from the database without using stored procedures.  There are clear transaction boundaries - one SQL is started, no time is spent on processing data between transactions.  A very good example: YeSQL on Clojure works, almost like a stored procedure.  And Scala Slick - if you are involved in Scala and have not yet seen Slick, then you should definitely watch the source code, this is one of the most impressive pieces of code I've ever seen. <br><br><img src="https://habrastorage.org/web/979/002/d2a/979002d2a49c4745b4bc850962fa8515.jpg"><br><img src="https://habrastorage.org/web/811/0b0/9be/8110b09be2014bdd9a0b5f1c7ecdc8e7.jpg"><br><br>  Stored procedures.  Clear transaction boundaries.  Abstraction from the data layer.  This is a recipe for a classic application written in Java. <br><br>  We have business logic, JDBC Driver and data tables.  What have we done?  We first implemented the stored procedure layer.  Suppose we return a row, for example, <i>getFullCustomerInformation</i> , in which there is an array, its orders are serialized by Postgres, inside there is also an array with positions, inside which there is an array with bank data.  It turns out very well typed hierarchical structure.  If this is all written in Java, at some point we have 50 pages of members in the classes.  This led to such terrible consequences that we decided to write our own library.  They called it Sproc Wrapper, which works like an APC Layer in a database.  It essentially makes the database an application server. <br><br><img src="https://habrastorage.org/web/44a/706/b1f/44a706b1f43a40a5b7c20e9a08edce64.jpg"><br><img src="https://habrastorage.org/web/a11/e11/a57/a11e11a57a94445e93994ba6bb3e36c2.jpg"><br><img src="https://habrastorage.org/web/71f/0e6/7f8/71f0e67f818546f8a43a6e26589e8d2c.jpg"><br><img src="https://habrastorage.org/web/f2b/036/d4b/f2b036d4bd7f4cb2b0ab5101483ae324.jpg"><br><br>  <b>What does this look like?</b> <br><br>  The stored procedure is written, then such a small interface with annotations is written.  The register_customer call is completely transparent to the application, the stored procedure in the database is called, as is the serialization / deserialization of all the terrible nested arrays, hash maps, etc.  Including order address structures, which are maps as list of orders. <br><br><img src="https://habrastorage.org/web/98d/647/725/98d6477253f049fdb111360e5c2f3728.jpg"><br><br>  <b>What problems?</b> <br><br>  Problems with stored procedures are that you need to write too much code.  If you need to do a lot of CRUD operations (you write new Excel), I would not advise using stored procedures.  If you have tables with 100 columns, you have to enter the change for each column as a separate stored procedure, then you can go crazy.  We had people who wrote bootstrapper, generating these stored procedures.  But then we said that it is better to use hibernate in this situation and edit these tables.  We have, for example, in the procurement team, which drive in product information, there is a tool, it is written in hibernate.  These tools are used by 500 people, and 15 million use our main site. <br><br>  What is positive?  Need to learn SQL.  This is very helpful for developers.  Developers who started to teach Closure and Scala now periodically come to me and say ‚ÄúScala is almost like SQL, wow !!!‚Äù.  I guess, yes.  Data pipelines that flow upwards through functional filters are exactly what SQL has always done.  Unfortunately, there is still no execution planner in Scala. <br><br><img src="https://habrastorage.org/web/7b7/8f8/d95/7b78f8d9505d434c9b640551ad2da41b.jpg"><br><br>  <b>Automate everything.</b> <br><br>  Everything that is done by hand is likely to be done poorly.  It is very important to know how PostgreSQL works, how systems work so that nothing breaks. <br><br><img src="https://habrastorage.org/web/1fd/3ad/585/1fd3ad5851e54b2fb6fb2c3d28272c14.jpg"><br><img src="https://habrastorage.org/web/cac/356/230/cac35623064c4666be6e1013971d94d8.jpg"><br><br>  <b>How do we version?</b> <br><br>  At first, when we first started using stored procedures, when we changed the procedure, the type of data that it returns was changed.  You need to drop the old procedure, roll out a new one.  All this in one transaction.  If there are any dependencies between stored procedures, I had to look for them with pens.  Drop completely and roll out again.  When I was the only DBA in the company, all I did was to write these scary dbdiff updates to stored procedures.  Then we somehow sat down and came up with the idea that you can use the amazing PostgreSQL search_path feature that controls the paths to search for objects in a session.  If your application with version 15.01 opens and exposes search_path, then the objects it will find will be located in this scheme. <br><br>  Our deployment tool while rolling out the application with this set of stored procedures creates a schema of the required version and loads everything there.  Application then uses them.  What happens when we roll out a new version?  The Deployment tool rolls out a new scheme with the entire set of stored procedures that we have, and at the moment a new version rolls out, we actually have both versions, each with its own set of stored procedures.  There is nothing related to the data.  These are the so-called API schemes that provide the data access layer and nothing else.  And all the migrations that happen, they happen here.  Therefore, when migration occurs, it must be compatible with the previous version, which is still working. <br><br>  <b>Question from the audience</b> : <i>How long did you teach the developers to work on such a flow?</i>  <i>How to ensure that everyone does exactly that and did not migrate, which are not compatible with previous versions?</i>  <i>Do you somehow test additionally that the migration is indeed correct, that the new API correctly reads old data and does not fall at the same time?</i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valentin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : This is, of course, a question of how well test coverage works, and how well everything is tested. We have developers working on local databases, then we have integration staging, test staging, release staging and production. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question from the audience</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Who writes API, DBA or developers? How is the separation of access rights? </font></font></i> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valentine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: They write the developers. The option when DBA does this is not scalable. I know a few small companies in which DBA write all APIs in general. When they called me, they also thought that I would write an API. But this is impossible. We first hired five people a month, now we hire 40 people a month. Therefore, it is easier to spend time for developers to learn how to work with the database. It is very simple in fact, if you explain how everything is physically stored and arranged. </font></font><br><br><img src="https://habrastorage.org/web/fd0/bf8/3a0/fd0bf83a04ea4a22838eda349dc28cb2.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing is very convenient, because the entire API layer is being tested, and no migration is required. Everything can be automated. </font></font><br><br><img src="https://habrastorage.org/web/b48/a4a/8d8/b48a4a8d8d1f438eaca3987a393d0d34.jpg"><br><img src="https://habrastorage.org/web/554/139/c54/554139c5460c42d8a5e67b945310c0e4.jpg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the positive points that we have one big base?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If I were asked if you can do everything in one big base, I would answer: stay in one big base as long as you can afford it. If you have all your business data in the database memory, do not do anything, stay in the same database, it is very beautiful. You can do analytics quickly, link data between objects, and strategies for accessing various data are trivial. It is enough to support one machine, and not a whole bunch of different nodes. </font></font><br><br><img src="https://habrastorage.org/web/5a7/ecd/43e/5a7ecd43eabd410c94c96eb0a76dfd78.jpg"><br><img src="https://habrastorage.org/web/295/e8e/9b5/295e8e9b5282428fb8f240785b1c5393.jpg"><br><img src="https://habrastorage.org/web/cba/c90/38b/cbac9038b8114cb7b3d50e2e066cbbb7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the problem occurs when you have more data than RAM. Everything becomes slower: migrations, backups, maintenance, upgrades. The larger the base, the greater the headache. We share data: we take one large logical base and put it on many PostgreSQL instances. </font></font><br><br><img src="https://habrastorage.org/web/a6b/b6b/e6d/a6bb6be6debb486a92569b1cf81a142f.jpg"><br><img src="https://habrastorage.org/web/f19/138/062/f191380623274ed697390d7cfa56d90b.jpg"><br><img src="https://habrastorage.org/web/906/ecd/bd8/906ecdbd8d78450e805a66efd5bea9e8.jpg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is so good about it?</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, our bases are getting small. You can work with them quickly, but the problem, of course, is that it is already impossible to make joines. More tools are needed for analysts. To work with the data requires more tools. If you think that you can work with large amounts of data without investing in the development of an infrastructure that automates your processes, then you are mistaken. It is impossible to do. Need to write a lot of tools. </font></font><br><br><img src="https://habrastorage.org/web/2cb/2c8/946/2cb2c8946cce4443a1929c4b5b1238f7.jpg"><br><img src="https://habrastorage.org/web/44b/568/12d/44b56812d59b44cbab967bdbf6a354ab.jpg"><br><img src="https://habrastorage.org/web/0d6/7e3/b51/0d67e3b51fca4481809ed899b3090552.jpg"><br><img src="https://habrastorage.org/web/37c/784/2dc/37c7842dc5224b66a2999ea5c8735573.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We had an advantage. We already had a Sproc Wrapper, which provides us with a data layer. We just taught him to access different databases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What does this look like? We have a call to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findOrders</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">with the </font><i><font style="vertical-align: inherit;">runOnAllShards</font></i><font style="vertical-align: inherit;"> parameter</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= true. He calls the stored procedure on all shards that he had registered. Or we have a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CustomerNumber</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we say it is a shard key. In the configuration, you can specify which search strategy (Lookup Strategy) can be used: parallel search by shards, shard aware ID, and hashing is also, in my opinion, supported. The most widely used strategy for finding objects on shards is the so-called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtual Shard ID</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/web/ac3/a0f/7a9/ac3a0f7a9fcd479b99828f89b7c4c8bb.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The idea is very simple indeed. We have a partitioning key - in the hierarchy that I showed, it will be CustomerNumber. A partitioning key is a key that defines for each object the boundaries of the connections between your objects. </font></font><br><br><img src="https://habrastorage.org/web/eb0/c4d/1fb/eb0c4d1fb2424bf2bf046053e848c63f.jpg"><br><img src="https://habrastorage.org/web/ce1/0b6/541/ce10b654134141848585aea0a39783ba.jpg"><br><img src="https://habrastorage.org/web/214/62f/0f3/21462f0f369a4140b0f797195cc229fa.jpg"><br><img src="https://habrastorage.org/web/1a3/06f/8be/1a306f8be93d44049279836a4e10f1e1.jpg"><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Key formation.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main thing is to understand what partitioning key is. For example, we have users. The user has his orders, and many orders are attached to these orders. Partitioning key is a common key that selects a group of objects that belong to the same user. We will have a customer number, a unique user number. It must be dragged along with all objects of type Order, the underlying objects in the hierarchy, in order to understand where my Customer is located. I should always be able to find out where the parent lies for the objects in the hierarchy. I'm afraid to say Customer ID, because ID is a technical key. We are not talking about technical keys. We are talking about logical keys. Because technical keys will not be unique within a logical base.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is quite normal to use the UUID for the Customer ID. We distinguish between Customer Number and Customer ID. One Customer ID exists eight times in our system, in eight databases. And the Customer Number is always one. We are hashing with MD5, but you can do better. The main thing is that the hashes are distributed evenly. This is done at the level of sharding strategy. In fact, the hash needs to be implemented wherever the application needs to quickly find the location of the hierarchy of objects. In our Sproc Wrapper situation, this will be just the Sharding Strategy for the Customer object.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the size of the hash of this key, we determine the number of virtual shards. What happens when we want to split the base? We just say that we share the base and start using the first bit in our hash. Thus, when the base is divided, we can indicate that it was a master, it became a slave, and at such a moment we will have a very short system shutdown. At the moment this is so. It could be fully automated to be transparent. We turn off the system, change the sharding strategy, and say that from now on we have access here and here, but we write data that has the first bit, one, to another database that already has data. The only thing we need to do after this is to erase all the objects that belong to one from this database, and on the other, to erase all the data that belong to zero.</font></font> And so on.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even can be asymmetrically divided. Sharding strategy may know that if you start a hash from scratch, then there are still a couple of shards. So it is better not to do it, because you can go crazy. In principle, we have already shared it twice. </font></font><br><br><img src="https://habrastorage.org/web/781/ff0/bc6/781ff0bc6da546309046ea97fd35d75d.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are now experimenting with the amazing PostgreSQL feature - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logical replication</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is a multi-master - the possibility of upgrades to the major version without having to stop the system, do everything slowly and painfully. Partial replication - you can pull out of the database only one table or part of the table. Make updates to caches.</font></font><br><br><img src="https://habrastorage.org/web/d7d/6b4/ba0/d7d6b4ba072147018d21a21e76beb300.jpg"><br><img src="https://habrastorage.org/web/84b/392/8f6/84b3928f68f848f0bda3d2cffa61819d.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are working very hard to pull PostgreSQL into AWS with the great capabilities that RDS currently provides. </font><font style="vertical-align: inherit;">Our AWS team has developed a system called STUPS. </font><font style="vertical-align: inherit;">It allows you to roll out docker images in Spilo, traceable and monitorable way. </font><font style="vertical-align: inherit;">Spilo with the help of three commands can roll out a PostgreSQL cluster on AWS, which will be high available, switch itself when one of the nodes is turned off, and choose a wizard. </font><font style="vertical-align: inherit;">But this is a topic for another discussion.</font></font><br><br><img src="https://habrastorage.org/files/a61/060/56f/a6106056fcce49a29cd997efd8bc97b9.png"></div><p>Source: <a href="https://habr.com/ru/post/326246/">https://habr.com/ru/post/326246/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326234/index.html">New version of Windows 10: sysadmin view</a></li>
<li><a href="../326236/index.html">Centrifugo - 3.5 million rpm</a></li>
<li><a href="../326238/index.html">RStudio Connect - Shiny "facelift" for corporate use</a></li>
<li><a href="../326240/index.html">Office in 100 machines, or a story about how I transferred the server from Windows to Centos 7. Prologue</a></li>
<li><a href="../326242/index.html">Performance is a holiday</a></li>
<li><a href="../326248/index.html">W3Tech: the share of nginx in the world rose to third, Apache fell below half</a></li>
<li><a href="../326252/index.html">Startup of the day (March 2017)</a></li>
<li><a href="../326254/index.html">Where to look for work: chat rooms in Telegram, groups in FB and other resources</a></li>
<li><a href="../326256/index.html">Machine War: PVS-Studio vs TensorFlow</a></li>
<li><a href="../326258/index.html">Internal mechanisms of TCP, affecting the download speed: part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>