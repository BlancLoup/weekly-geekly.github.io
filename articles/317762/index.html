<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Wrap algorithms in iterators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello dear readers. Today is Friday, and we have on-board intense review and analysis of new C ++, preferably taking into account C ++ 17. During this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Wrap algorithms in iterators</h1><div class="post__text post__text-html js-mediator-article">  Hello dear readers.  Today is Friday, and we have on-board intense review and analysis of new C ++, preferably taking into account C ++ 17. During this exciting lesson we came across the <a href="https://blog.galowicz.de/">blog of</a> Jacek Galovits (Jacek Galowicz).  Of the relatively fresh materials, we especially liked the article posted under the cut. <br><a name="habracut"></a><br>  It happens that you need to generate a range of numbers from an algorithm.  Whether it is a range of numbers, simply arranged in ascending order, or only odd numbers, or just prime numbers, etc.  Some operations can be optimized by memorizing the values ‚Äã‚Äãfor calculating the next number, exactly as is done with <b>Fibonacci numbers</b> .  In this article, I will tell you how to wrap such calculations in <b>iterators</b> so that powerful, beautifully encapsulated algorithms are obtained. <br><br>  <b>Fibonacci numbers</b> <br><br>  The number of Fibonacci numbers is widely known.  The generation of these numbers is a classic example of recursion, but, at least in standard imperative languages, the iterative version is more powerful: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fib(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> a {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> b {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i {<span class="hljs-number"><span class="hljs-number">0</span></span>}; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> old_b {b}; b += a; a = old_b; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre> <br>  Thus it is very easy to generate any Fibonacci number.  But if to solve a problem, you need to generate all Fibonacci numbers up to a certain limit, this solution can no longer be called convenient.  When calculating the Fibonacci number <code>N</code> and then <code>N+1</code> , the contents of the variables a and b could be reused, since each Fibonacci number is the sum of the two previous numbers of the same series. <br><br>  In this case, it would be convenient to have a class that controls a certain Fibonacci state in order to use it to quickly get exactly the next number. <br><br>  Many of us would simply implement the <code>fibonacci_number</code> class with some <code>next()</code> method, <code>current()</code> method - and use it.  This, of course, is good, but I propose to take another step and recall: after all, this is how iterators work.  By implementing this functionality in the language of iterators, it can be used in combination with STL, greatly enhancing the readability of the code. <br><br>  <b>Iterators</b> <br><br>  What needs to be done to implement the simplest possible iterator? <br><br>  This is what the C ++ compiler has for us if we want to iterate over the container class: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;item : <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> }</code> </pre><br>  Such a cycle declaration has existed since the days of C ++ 11.  The compiler will make the following equivalent code from it: <br><br><pre> <code class="cpp hljs">{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">it</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::begin(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::end(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; it != end; ++it) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">item</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*it)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> } }</code> </pre> <br>  We look at the extended cycle - and see what needs to be implemented.  First, we need to distinguish two types of objects: <code>vector</code> is an <b>iterative range</b> , and <code>it</code> is an <b>iterator</b> . <br><br>  The iterated range must implement the <code>begin()</code> and <code>end()</code> functions.  These functions return iterator objects. <br><br>  Note: in the example code, it returns not vector.begin () and vector.end (), but <code>std::begin(vector)</code> and <code>std::end(vector)</code> .  These STL functions do call vector.begin () and end (), but they are more versatile, that is, also applicable with raw arrays and automatically do what they need to get the initial and final iterators. <br><br>  Here is what should be implemented in the class <code>iterator</code> : <br><br><ul><li>  operator *, performing pointer dereference (pointers are also full iterators!) </li><li>  ++ operator (prefix) that increments the iterator to the next element </li><li>  the! = operator, necessary to check whether the loop should be completed ‚Äî that is, whether <code>it</code> has reached the position indicated at the <code>end</code> . </li></ul><br>  To implement any algorithmically generated range, first we need to make an iterator, which, in essence, hides the variables and the algorithm itself in the implementation of <code>operator++</code> .  Then, the iterated class will simply provide the starting and ending iterators, thus providing C ++-style for loops. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ...   ... public: //  iterator&amp; operator++() { /*  */ return *this; } T operator*() const { /*     */ } bool operator!= const (const iterator&amp; o) { /*   */ } }</span></span></code> </pre> <br>  The simplest iterator in the world is countable;  it simply wraps the integer variable, wraps it in operator ++, and returns an integer in <code>operator*</code> .  <code>operator!=</code> then simply compare this number with a number from another iterator. <br>  And now for the Fibonacci iterator. <br><br>  <b>Fibonacci iterator</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fibit</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> a {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> b {<span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i_)</span></span></span><span class="hljs-function"> : i</span></span>{i_}, a{a_}, b{b_} {} <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> fibit&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> old_b {b}; b += a; a = old_b; ++i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fibit &amp;o) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i != oi; } };</code> </pre> <br>  With this iterator, it is already possible to iterate over Fibonacci numbers: <br><br><pre> <code class="cpp hljs">fibit it; <span class="hljs-comment"><span class="hljs-comment">//       "i", //     ,   "i"   // 20,      const fibit end {0, 0, 20}; while (it != end) { std::cout &lt;&lt; *it &lt;&lt; std::endl; ++it; } //       STL: (  &lt;iterator&gt;) std::copy(it, end, std::ostream_iterator&lt;size_t&gt;{std::cout,"\n"});</span></span></code> </pre> <br>  For everything to be beautiful, as in C ++ 11, we need an iterable class: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fib_range</span></span></span><span class="hljs-class"> {</span></span> fibit begin_it; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> end_n; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib_range</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end_n_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> begin_n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : begin_it</span></span>{fibit_at(begin_n)}, end_n{end_n_} {} <span class="hljs-function"><span class="hljs-function">fibit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> begin_it; } <span class="hljs-function"><span class="hljs-function">fibit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, end_n}; } };</code> </pre> <br>  And now you can write ... <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> num : fib_range(<span class="hljs-number"><span class="hljs-number">10</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  ... and display the first 10 Fibonacci numbers <br><br>  What does the <code>fibit_at</code> function <code>fibit_at</code> ?  This is the <code>constexpr</code> function <code>constexpr</code> , if possible, advances the Fibonacci iterator at compile time, so that it reaches the Fibonacci number that the user needs: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> fibit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibit_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ fibit it; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i {<span class="hljs-number"><span class="hljs-number">0</span></span>}; i &lt; n; ++i) { ++it; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> it; }</code> </pre> <br>  For example, this function allows you to sort the numbers in the Fibonacci series from the hundredth to the hundred and fifth without needing to calculate the first 100 Fibonacci numbers at run time, since we can prepare the necessary starting position already at compile time. <br><br>  When working with C ++ 17, <code>fibit_at</code> useless, since it can be replaced by <code>std::next(fibit{}, n)</code> , since in C ++ 17 <code>STLstd::next</code> is a function of <code>constexpr</code> . <br><br>  To ensure that the 100th number in the Fibonacci series is already calculated when the compiler writes a binary program to disk, you can simply add a range to the <code>constexpr</code> variable: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fib_range hundred_to_hundredfive {<span class="hljs-number"><span class="hljs-number">105</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> num : hundred_to_hundredfive) { <span class="hljs-comment"><span class="hljs-comment">//  - }</span></span></code> </pre><br>  <b>We combine the Fibonacci iterator with STL algorithms</b> <br><br>  Suppose we need a vector with the first 1000 Fibonacci numbers.  We have already wrapped the Fibonacci algorithm into a convenient iterator class, and now we can use it with any STL algorithm from the <code>std:</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt; fib_nums; fib_nums.resize(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fib_range first1000 {<span class="hljs-number"><span class="hljs-number">1000</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(first1000), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(first1000), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(fib_nums));</code> </pre> <br>  Very nice and comfortable.  However, the code as presented here will not compile because we did not specify an iterator label.  This is done simply: let <code>fibit</code> explicitly inherit <code>std::iterator&lt;std::forward_iterator_tag, size_t&gt;</code> . <br><br>  <code>std::iterator</code> , being the base for our <code>fibit</code> class, will simply add a few type definitions that will help the STL algorithms figure out what this iterator is.  For iterators of a certain type in specific situations, there are other implementations of STL algorithms, whose performance is optimized (this is neatly hidden from the user!). <br><br>  The <code>std::forward_iterator</code> means that we have an iterator, which can be simply advanced step by step - and it will only move forward, but not backward. <br><br>  <b>Results</b> <br><br>  Many algorithms that generate numeric ranges can be implemented as iterators, which is completely natural.  In C ++, there is delicious syntactic sugar for iterators, making them organic interfaces for abstractions. <br><br>  Together with the STL algorithms and any STL-compatible data structures, they make readable, powerful code that is easy to test and maintain. <br><br>  The article talks about the iterator, and not the usual data pointer.  The implementation of the algorithm is interesting because at the increment stage something more complicated is computed than the new position of the internal pointer to the next element.  Interestingly, this way you can instantiate some iterated object that defines the range - and this requires serious calculations.  But they will not be executed until someone specifically requests a result (and the code requesting the result does not even ‚Äúknow‚Äù which algorithm is implicitly executed, since this information is hidden behind a simple iterator interface). <br><br>  This style is associated with lazy computing - this is a powerful and beautiful principle from purely functional programming languages. </div><p>Source: <a href="https://habr.com/ru/post/317762/">https://habr.com/ru/post/317762/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317752/index.html">We monitor the freelance site in slack</a></li>
<li><a href="../317754/index.html">About turning the sales funnel into a well on the example of the site of the repair team</a></li>
<li><a href="../317756/index.html">How the layout of the environment affects the complexity of the game</a></li>
<li><a href="../317758/index.html">Digital Transformation: Classic Businesses Migrate to IT</a></li>
<li><a href="../317760/index.html">History in each tab or multiple backstack</a></li>
<li><a href="../317764/index.html">Review (and videotapes) of the best presentations at the JPoint 2016 Java conference: BigData, JVM guts, and puzzle players</a></li>
<li><a href="../317766/index.html">How we ran Deep Learning</a></li>
<li><a href="../317770/index.html">Swagger in Magento 2</a></li>
<li><a href="../317772/index.html">Academy of Geniuses</a></li>
<li><a href="../317774/index.html">Oracle In-Memory Option Performance Testing with TPC-H Benchmark</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>