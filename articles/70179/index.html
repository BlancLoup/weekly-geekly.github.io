<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Part 2/3. Ideal VM compiler for ICFPC 2009, on Haskell, with popularizing comments</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Start here. 

 Now we understand how we will decode the entire file, not just one instruction. 

readMyFile = withBinaryFile "bin4.obf" ReadMode $ \ h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Part 2/3. Ideal VM compiler for ICFPC 2009, on Haskell, with popularizing comments</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://san13.habrahabr.ru/blog/68995/">Start here.</a> <br><br>  Now we understand how we will decode the entire file, not just one instruction. <br><br><blockquote><code>readMyFile <font color="#a52a2a"><b>=</b></font> withBinaryFile <font color="#ff00ff">"bin4.obf"</font> ReadMode <font color="#a52a2a"><b>$</b></font> <font color="#a52a2a"><b>\</b></font> h <font color="#a52a2a"><b>-&gt;</b></font> <font color="#a52a2a"><b>do</b></font> &lt;br&gt; <br> len <font color="#a52a2a"><b>&lt;-</b></font> hFileSize h&lt;br&gt; <br> buf <font color="#a52a2a"><b>&lt;-</b></font> mallocBytes <font color="#a52a2a"><b>$</b></font> fromInteger len&lt;br&gt; <br> hGetBuf h buf <font color="#a52a2a"><b>$</b></font> fromInteger len&lt;br&gt; <br> return (len, buf)&lt;br&gt; <br></code> </blockquote>  This is an imperative piece, because they mostly work with files.  withBinaryFile opens the file, performs the specified ‚Äúuser-defined‚Äù function, passing it the handle, and closes the file, and returns what the user-defined function returns.  Here, after the $ sign, we described a ‚Äúuser-defined‚Äù function with one parameter h (from the handle).  This function gets the file size, allocates a buffer, reads into a buffer, and returns the buffer itself and its length (in bytes).  Note that the ‚Äúuser function‚Äù has no name here and starts like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br> <code>\h -&gt; function_body --         <br></code> <br>  Further, the function of receiving instructions and data words from the buffer.  The current pointer to the buffer (already shifted to the desired number of bytes) is passed here, and the instruction index is passed.  From the specification, we remember about the even-odd index, and that the opcode and the data word are something like that.  That is, the instruction starts from the zero byte, then from the eighth, and the data word (floating), respectively, then from the fourth, then from the zero. <br><br><blockquote> <code>instruction <font color="#a52a2a"><b>::</b></font> Ptr a <font color="#a52a2a"><b>-&gt;</b></font> Int <font color="#a52a2a"><b>-&gt;</b></font> IO (Word32,Double)&lt;br&gt; <br> instruction ptr i <font color="#a52a2a"><b>=</b></font> <font color="#a52a2a"><b>do</b></font> &lt;br&gt; <br> <font color="#a52a2a"><b>let</b></font> (iaddr,daddr) <font color="#a52a2a"><b>=</b></font> <font color="#a52a2a"><b>if</b></font> i <font color="#a52a2a"><b>`mod`</b></font> <font color="#ff00ff">2</font> <font color="#a52a2a"><b>/=</b></font> <font color="#ff00ff">O</font> <font color="#a52a2a"><b>then</b></font> ( <font color="#ff00ff">O</font> , <font color="#ff00ff">4</font> ) <font color="#a52a2a"><b>else</b></font> ( <font color="#ff00ff">8</font> , <font color="#ff00ff">O</font> ) <font color="#0000ff">--  instruction/data</font> &lt;br&gt; <br> instr <font color="#a52a2a"><b>&lt;-</b></font> peek (plusPtr ptr iaddr) <font color="#a52a2a"><b>::</b></font> IO Word32 <font color="#0000ff">--  </font> &lt;br&gt; <br> dta <font color="#a52a2a"><b>&lt;-</b></font> peek (plusPtr ptr daddr) <font color="#a52a2a"><b>::</b></font> IO Double <font color="#0000ff">--  </font> &lt;br&gt; <br> return (instr, dta)&lt;br&gt; <br></code> </blockquote>  Note that the operation "unequal" sounds in a mathematical way: "/ =". <br>  Now let's go through the "cycle" throughout the buffer, and return the list of pairs (instruction given): <br><blockquote> <code>ast <font color="#a52a2a"><b>=</b></font> mapM ( <font color="#a52a2a"><b>\</b></font> i <font color="#a52a2a"><b>-&gt;</b></font> instruction (plusPtr buf <font color="#a52a2a"><b>$</b></font> i <font color="#a52a2a"><b>*</b></font> <font color="#ff00ff">12</font> ) i) [ <font color="#ff00ff">O</font> <font color="#a52a2a"><b>..</b></font> nframes <font color="#a52a2a"><b>-</b></font> <font color="#ff00ff">1</font> ]&lt;br&gt; <br></code> </blockquote>  A lot of things happen here.  First, the map function and others like it (in particular, mapM) work as follows: they are given a ‚Äúuser function‚Äù that converts one list item, and the list itself is passed to it, and then map applies this user function to each element of the list, and forms a new list of the values ‚Äã‚Äãof this function.  The cycle of the map is somewhere inside there (we will not go into details). <br><br> <code>let q = map (\h -&gt; h * 2) [1,2,3,4,5] <br></code> <br>  returns [2,4,6,8,10], this is a classic example.  And in our task, the input indices are (from zero to the end), and the output is a list of the results of calling the ‚Äúinstruction‚Äù function with each index.  It is sometimes difficult to understand right away, but it is time to go - python and ruby ‚Äã‚Äãare moving in this direction, and with them a cohort of languages ‚Äã‚Äã(of those that are not there, of course). <br><br> <code>ast <font color="#a52a2a"><b>=</b></font> mapM ( <font color="#a52a2a"><b>\</b></font> i <font color="#a52a2a"><b>-&gt;</b></font> instruction (plusPtr buf <font color="#a52a2a"><b>$</b></font> i <font color="#a52a2a"><b>*</b></font> <font color="#ff00ff">12</font> ) i) [ <font color="#ff00ff">O</font> <font color="#a52a2a"><b>..</b></font> nframes <font color="#a52a2a"><b>-</b></font> <font color="#ff00ff">1</font> ]&lt;br&gt; <br></code> <br>  Returning to our mapM, the function passed to it is called instruction, which is fed 0, 1, and so on, as the second argument, and as the first, the buffer is transferred with offsets of 12 bytes further and further for each iteration (1 opcode + 1 data word = 12 bytes).  plusPtr forms a new pointer, separated from the specified by the specified number of bytes. <br><br>  That's the whole cycle.  As a result, we have a list of "flat" opcodes (flat, because they are translated one by one according to the specification): <br><br> <code>[(Add 0 77 66, 0.0), (Sub 1 0 102, 0.0), ...] <br></code> <br>  What does it mean: add cells 77 and 66, put the result in 0. Then subtract the contents of cell 102 from the contents of cell 0, put the result in 1 ... and so on.  This is our code.  But the data: in the zero cell 0.0, in the first 0.0, and so on ... <br><br>  At this point, you can stop and generate a non-ideal code in any language, at least in assembly language (after all, operations from the specification of the problem are close to it).  To do this, you need to add a translation to the string (in the desired language) of each of the flat operations, and load the code in the loop.  But it will be a literal execution, and therefore slowly and tedious. <br><br>  Why slow?  Because there will be a write operation in memory of some results that are used only once, and which, in truth, it is better to store somewhere in registers or even on the stack (the C / Haskell / Java compiler or whatever, we will present our AST, and now we have Haskel as ‚Äúanything‚Äù.  And if we write a record in the structure field for every sneeze, then no compiler registers us from there, but only one record in memory. <br><br>  Therefore, we will analyze what categories our ‚Äúmemory‚Äù cells are divided into. <br><br>  1) constants: read only, never write <br>  2) real memory: read before write, write later read <br>  3) temporary variables: write, then several reads <br>  4) one-time variables: write, then one read.  Go to expressions with brackets. <br><br>  To understand who reads and writes to the memory cell, we need to describe the behavior of each instruction in the following section: some instructions only read memory (output from memory to port), others only write (from port to memory), most read and write (arithmetic, conditional). <br><br>  We describe the behavior of each instruction - what it reads (consumes). <br><br><blockquote> <code>consumesData (Add _ r1 r2) <font color="#a52a2a"><b>=</b></font> [r1,r2]&lt;br&gt; <br> consumesData (Sub _ r1 r2) <font color="#a52a2a"><b>=</b></font> [r1,r2]&lt;br&gt; <br> consumesData (Mul _ r1 r2) <font color="#a52a2a"><b>=</b></font> [r1,r2]&lt;br&gt; <br> consumesData (Div _ r1 r2) <font color="#a52a2a"><b>=</b></font> [r1,r2]&lt;br&gt; <br> consumesData (Output r1 r2) <font color="#a52a2a"><b>=</b></font> [r2]&lt;br&gt; <br> consumesData (If _ condr1 _ r1 r2) <font color="#a52a2a"><b>=</b></font> [condr1,r1,r2]&lt;br&gt; <br> consumesData (Sqrt _ r2) <font color="#a52a2a"><b>=</b></font> [r2]&lt;br&gt; <br> consumesData (Copy _ r2) <font color="#a52a2a"><b>=</b></font> [r2]&lt;br&gt; <br> consumesData _ <font color="#a52a2a"><b>=</b></font> []&lt;br&gt; <br></code> </blockquote>  The underlining in the latter case means ‚Äúall the others‚Äù, and in the first cases it means that we are not interested in what the constructor is in this place for the argument.  As you can see, pattern matching is again used here. <br><br>  Similarly, we describe the behavior of each operation with regard to what it writes (produces): <br><blockquote> <code>producesData (Add addr _ _) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (Sub addr _ _) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (Mul addr _ _) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (Div addr _ _ ) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (If _ _ addr _ _) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (Input addr _) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (Copy addr _) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData (Sqrt addr _ ) <font color="#a52a2a"><b>=</b></font> [addr]&lt;br&gt; <br> producesData _ <font color="#a52a2a"><b>=</b></font> []&lt;br&gt; <br></code> </blockquote>  We describe what each instruction does in relation to the ports - which ports it reads. <br><blockquote> <code>readsPort (Input _ port) <font color="#a52a2a"><b>=</b></font> [port]&lt;br&gt; <br> readsPort _ <font color="#a52a2a"><b>=</b></font> []&lt;br&gt; <br></code> </blockquote>  And the entry - what ports does she write: <br><blockquote> <code>writesPort (Output r1 _) <font color="#a52a2a"><b>=</b></font> [r1]&lt;br&gt; <br> writesPort _ <font color="#a52a2a"><b>=</b></font> []&lt;br&gt; <br></code> </blockquote>  Next, for a shorter entry (author fad) <br><blockquote> <code>cmap <font color="#a52a2a"><b>=</b></font> concatMap&lt;br&gt; <br></code> </blockquote>  What does concatMap do?  It does the same thing as map, only after that does concat.  Concat "glues the list one level."  A small example: <br><br> <code>concat [ <font color="#ff00ff">"hello"</font> , <font color="#ff00ff">"africa"</font> ] <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"helloafrica"</font> &lt;br&gt; <br> concat [[ <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">4</font> ],[ <font color="#ff00ff">5</font> , <font color="#ff00ff">6</font> , <font color="#ff00ff">7</font> , <font color="#ff00ff">8</font> ]] <font color="#a52a2a"><b>=</b></font> [ <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">4</font> , <font color="#ff00ff">5</font> , <font color="#ff00ff">6</font> , <font color="#ff00ff">7</font> , <font color="#ff00ff">8</font> ]&lt;br&gt; <br> concat [[]] <font color="#a52a2a"><b>=</b></font> []&lt;br&gt; <br> &lt;br&gt; <br> map ( <font color="#a52a2a"><b>\</b></font> i <font color="#a52a2a"><b>-&gt;</b></font> [ <font color="#ff00ff">1</font> <font color="#a52a2a"><b>..</b></font> i]) [ <font color="#ff00ff">1</font> <font color="#a52a2a"><b>..</b></font> <font color="#ff00ff">5</font> ] <font color="#a52a2a"><b>=</b></font> [[ <font color="#ff00ff">1</font> ],[ <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> ],[ <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> ],[ <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">4</font> ],[ <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">4</font> , <font color="#ff00ff">5</font> ]]&lt;br&gt; <br> concatMap ( <font color="#a52a2a"><b>\</b></font> i <font color="#a52a2a"><b>-&gt;</b></font> [ <font color="#ff00ff">1</font> <font color="#a52a2a"><b>..</b></font> i]) [ <font color="#ff00ff">1</font> <font color="#a52a2a"><b>..</b></font> <font color="#ff00ff">5</font> ] <font color="#a52a2a"><b>=</b></font> [ <font color="#ff00ff">1</font> , <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">4</font> , <font color="#ff00ff">1</font> , <font color="#ff00ff">2</font> , <font color="#ff00ff">3</font> , <font color="#ff00ff">4</font> , <font color="#ff00ff">5</font> ]&lt;br&gt; <br></code> <br><br>  Now the most terrible and big piece: <br><blockquote> <code>produceCode ast dta <font color="#a52a2a"><b>=</b></font> &lt;br&gt; <br> <font color="#a52a2a"><b>let</b></font> &lt;br&gt; <br> inports <font color="#a52a2a"><b>=</b></font> cmap readsPort ast <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br> outports <font color="#a52a2a"><b>=</b></font> cmap writesPort ast <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  apply readsPort / writesPort to each opcode, and add (concat) all lists into one list.  Thus, we received lists of input and output ports in general. <br><blockquote> <code><font color="#0000ff">-- consumes,produces,outputs to port [(memory/port ref,op address)] lookup tables</font> &lt;br&gt; <br> consumes <font color="#a52a2a"><b>=</b></font> cmap ( <font color="#a52a2a"><b>\</b></font> (d,a) <font color="#a52a2a"><b>-&gt;</b></font> consumesData d <font color="#a52a2a"><b>`zip`</b></font> [a,a <font color="#a52a2a"><b>..</b></font> ] ) (ast <font color="#a52a2a"><b>`zip`</b></font> [ <font color="#a52a2a"><b>O..</b></font> ]) <font color="#a52a2a"><b>::</b></font> [(Int,Int)]&lt;br&gt; <br> produces <font color="#a52a2a"><b>=</b></font> cmap ( <font color="#a52a2a"><b>\</b></font> (d,a) <font color="#a52a2a"><b>-&gt;</b></font> producesData d <font color="#a52a2a"><b>`zip`</b></font> [a,a <font color="#a52a2a"><b>..</b></font> ] ) (ast <font color="#a52a2a"><b>`zip`</b></font> [ <font color="#a52a2a"><b>O..</b></font> ])&lt;br&gt; <br> outputsPort <font color="#a52a2a"><b>=</b></font> cmap ( <font color="#a52a2a"><b>\</b></font> (d,a) <font color="#a52a2a"><b>-&gt;</b></font> writesPort d <font color="#a52a2a"><b>`zip`</b></font> [a,a <font color="#a52a2a"><b>..</b></font> ] ) (ast <font color="#a52a2a"><b>`zip`</b></font> [ <font color="#a52a2a"><b>O..</b></font> ])&lt;br&gt; <br></code> </blockquote>  here we built several lookup tables (reference books?) to which you can ask the following questions: <br><br>  What is the address of the instruction that writes to the specified address?  (in general, the question is stupid, because, by the definition of the problem, this instruction is located at address N, but this I just realized) <br>  What addresses are located instructions that read the specified cell? <br>  What is the address of the instruction that writes to the specified port? <br><br>  In Haskell, a primitive lookup table is a list of pairs (key, value).  We now have functions that search for all values ‚Äã‚Äãby a given key and return a list.  Here they are: <br><br><blockquote> <code><font color="#0000ff">-- op address that reads/writes given mem/port</font> &lt;br&gt; <br> reads m <font color="#a52a2a"><b>=</b></font> map snd <font color="#a52a2a"><b>$</b></font> filter ((m <font color="#a52a2a"><b>==</b></font> ) <font color="#a52a2a"><b>.</b></font> fst) consumes <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br> writes m <font color="#a52a2a"><b>=</b></font> map snd <font color="#a52a2a"><b>$</b></font> filter ((m <font color="#a52a2a"><b>==</b></font> ) <font color="#a52a2a"><b>.</b></font> fst) (produces) <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br> outputs m <font color="#a52a2a"><b>=</b></font> map snd <font color="#a52a2a"><b>$</b></font> filter ((m <font color="#a52a2a"><b>==</b></font> ) <font color="#a52a2a"><b>.</b></font> fst) outputsPort <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  They simply return the list of addresses who reads the specified memory location, or writes, or writes the specified port.  How it works: <br><blockquote> <code>reads m <font color="#a52a2a"><b>=</b></font> map snd <font color="#a52a2a"><b>$</b></font> filter ((m <font color="#a52a2a"><b>==</b></font> ) <font color="#a52a2a"><b>.</b></font> fst) consumes^M&lt;br&gt; <br></code> </blockquote>  means literally: take the second elements, first filtering all those who have the first element equal to the specified m from the directory consumes (calculated earlier).  How it works? <br><br>  the filter function takes as input a ‚Äúuser function‚Äù ((m ==). fst) and a list.  The custom function is fed to the input of each element from the list, and it returns True or False.  From this list, depending on the result, elements are included in the resulting list or not.  It remains a smaller list, therefore.  This list is the second argument of the map function (as was discussed earlier about the '$' operator).  Next map applies the snd function to each element of the list and generates a list of results. <br><br>  A few things left unresolved.  The snd / fst functions return the second or first element of the pair, respectively, that is, they are engaged in the decomposition of the pair, and in simple terms, they bite the second or first element: <br><br> <code>fst (1,2) = 1 <br> snd (1,2) = 2 <br> fst ("Hello", 2+2) = "Hello" <br> snd ("Hello", 2+2) = 4 <br></code> <br>  And now one of the interesting moments in HASKEL is the composition of functions.  Consider the example: <br><br> <code>fx = sin (cos (sqrt (x))),    - : <br> fx = sin $ cos $ sqrt x <br></code> <br>  Now move the brain and see that the ‚Äúx‚Äù always passes through the grinder of functions: first, sqrt, then cos, then through sin.  Surely it would be possible to plot the function fx, and since it is possible to plot a graph, then surely the sequence of applications of these three functions corresponds to one single function that gives the same result, only mathematicians did not give it another name !!!  Forgive me people with formal thinking. <br><br>  Now, suppose we have a function on a haskel that plots any transferred function, for example <br><br> <code>plot :: (Double -&gt; Double) -&gt; Double -&gt; Double -&gt; IO() ( IO ()  void,      :  plot      Double  Double,       Double (   ),   void) <br> plot sin 0 6.28 --    sin    0  6.28 <br> plot cos 0 3.14 --  ,   ,  . <br></code> <br>  Here we see that we pass the sin or cos function as such, the argument will be passed to it during the construction of the schedule, those who build it.  How can we pass on a whole grinder of functions, which did not come up with a name, but we know how it develops? <br><br>  There is an urgent need to describe such a meat grinder.  Consequently: <br><br> <code>fun1 = sin --    1  <br> fun2 = sin . cos . sqrt --     ,   -     <br></code> <br>  Now about the incomplete use.  Here we have a function that takes two arguments, for example, exponentiation: <br> <code>pow 2 3 = 8 --     <br>    pow2: <br> pow2 = pow 2 <br></code> <br>  It turns out that we passed only one of the two required arguments, but no one stopped or scolded us!  What is the type of the pow2 function?  Very simply, she wants another Double argument, and adds it, and calls the pow function with this argument, and the two is already there! <br><br> <code>pow2 4 = 16 <br></code>  It turns out that the notation for describing the Haskel types is also not taken from the ceiling: watch your hands: <br><br> <code>pow :: Double -&gt; Double -&gt; Double --  double,   double,  double <br> pow2 :: Double -&gt; Double --   double,  double <br></code> <br>  and since pow2 was obtained by specifying one argument to the pow function, we can conclude that adding one argument to pow generates a new function! <br><br> <code>pow :: Double -&gt; (Double -&gt; Double) --     . <br></code> <br>  Therefore, it is possible to add brackets to the right, but the meaning will be the same.  It also follows from this that: <br><br>  pow 2 3 = (pow 2) 3, that is, we first generate a function, and then add the missing argument to it (apply the function to the triple). <br><br>  Let's return to our sheep. <br><blockquote> <code>reads m <font color="#a52a2a"><b>=</b></font> map snd <font color="#a52a2a"><b>$</b></font> filter ((m <font color="#a52a2a"><b>==</b></font> ) <font color="#a52a2a"><b>.</b></font> fst) consumes&lt;br&gt; <br></code> </blockquote>  in the filter is a function: (m ==).  fst.  Here we see the point (composition) and partial application: m ==.  This m == is a function that receives 1 argument as input, substitutes it to the right of the equal sign, and voila!  The function m == returns the result of comparing its argument with m.  If m is 5, then ((m ==) 5) returns True. <br><br>  Now we read everything from right to left: we have a meat grinder, what goes into it, is first fed to the fst function (which, as we know, extracts the first element from the pair), then this value is fed to m ==, which takes a number, compares it to m and returns a boolean.  Thus, a couple (a, b) enters the meat grinder, and Boolean comes out, is it equal to this m. <br><br>  Now we have to choose all the references to the cells that are written or read in order to make a start from: <br><br><blockquote> <code><font color="#0000ff">-- all memory references (including temporaries etc - from plain program)</font> &lt;br&gt; <br> alldata <font color="#a52a2a"><b>=</b></font> nub <font color="#a52a2a"><b>$</b></font> sort <font color="#a52a2a"><b>$</b></font> cmap consumesData ast <font color="#a52a2a"><b>++</b></font> (map recast <font color="#a52a2a"><b>$</b></font> cmap producesData ast) <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  Here (read from right to left) "cmap producesDataAst ast" returns a list of all written cells in the form of a flat list of their addresses, similarly happens with consumesData, then both lists are simply glued together (++), then sorted, and then duplicates are removed from them (nub) .  In principle, nub does not require a sorted list, but I did not know this before: <br><br> <code>nub [1,2,1] = [1,2] <br> nub [2,1,2] = [2,1] <br></code> <br><blockquote> <code><font color="#0000ff">-- constants</font> &lt;br&gt; <br> constants <font color="#a52a2a"><b>=</b></font> filter ( <font color="#a52a2a"><b>\</b></font> m <font color="#a52a2a"><b>-&gt;</b></font> <font color="#ff00ff">O</font> <font color="#a52a2a"><b>==</b></font> (length <font color="#a52a2a"><b>$</b></font> writes m))  alldata <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  But here the following happened: we selected from alldata all addresses to which no one ever writes.  And since they only read from them, then this is certainly a constant.  So we made a list. <br><br><blockquote> <code><font color="#0000ff">-- all persistent (optimized memory)</font> &lt;br&gt; <br> persistents <font color="#a52a2a"><b>=</b></font> filter ( <font color="#a52a2a"><b>\</b></font> m <font color="#a52a2a"><b>-&gt;</b></font> (head <font color="#a52a2a"><b>$</b></font> reads m) <font color="#a52a2a"><b>&lt;=</b></font> (head <font color="#a52a2a"><b>$</b></font> writes m)) (alldata <font color="#a52a2a"><b>\\</b></font> constants) <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  And here we have selected all the variables that should be saved from time to time between iterations.  To do this, we took alldata, subtracted the constants from it (operation \\ is the difference of the lists), and found who reads first and who writes first.  If they read before the place where they write, then they assume that there is something there!  Remained from last time!  So, in this way they made a list of those places that are actually the memory of our black box, which is accessible for reading and writing. <br><br><blockquote> <code><font color="#0000ff">-- temporaries which are reused parts of expressions</font> &lt;br&gt; <br> lets <font color="#a52a2a"><b>=</b></font> filter ( <font color="#a52a2a"><b>\</b></font> m <font color="#a52a2a"><b>-&gt;</b></font> <font color="#ff00ff">1</font> <font color="#a52a2a"><b>&lt;</b></font> (length <font color="#a52a2a"><b>$</b></font> reads m))  (alldata <font color="#a52a2a"><b>\\</b></font> constants) <font color="#a52a2a"><b>\\</b></font> persistents <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  Now we are from the rest (because we have subtracted everything that we still know from alldata), we have found those cells that are read more than once.  Since these are not permanent data (we have excluded them), these are certainly temporary variables that are first calculated and then used several times.  Temporary variables are used within one iteration, and outside it they are not needed. <br><br><blockquote> <code><font color="#0000ff">-- expressions to inline (variables that are used 1 time)</font> &lt;br&gt; <br> onerefs <font color="#a52a2a"><b>=</b></font> filter ( <font color="#a52a2a"><b>\</b></font> m <font color="#a52a2a"><b>-&gt;</b></font> (length <font color="#a52a2a"><b>$</b></font> reads m) <font color="#a52a2a"><b>==</b></font> <font color="#ff00ff">1</font> <font color="#a52a2a"><b>&amp;&amp;</b></font> (length <font color="#a52a2a"><b>$</b></font> writes m) <font color="#a52a2a"><b>==</b></font> <font color="#ff00ff">1</font> ) &lt;br&gt; <br> ((alldata <font color="#a52a2a"><b>\\</b></font> constants) <font color="#a52a2a"><b>\\</b></font> persistents) <font color="#a52a2a"><b>::</b></font> [Int]&lt;br&gt; <br></code> </blockquote>  And here we calculated the variables that are written once and then read 1 time.  For them, we will not start anything at all, and expressions with brackets will be formed from them.  This class of variables was needed by the authors of the black box, because they have such a low-level language, and in our high-level result they will live in the registers of the processor, but the compiler will take care of this without our knowledge. <br><br>  Now we should from flat operations (in which only addresses that are read are written in the course of operation) are mentioned, go to the tree opcodes, that is, those that we have with the Exp suffix - they contain references to their own kind, forming a tree .  To do this, we describe the function that will be generated to us at the address of the whole tree Op.  It will be recursive.  Because if we give it the address where the constant lies, then we don‚Äôt have to do much.  And if we give it an address to which the result of the addition of two other cells is written, then we need to generate Op, which adds two other Opes, and they can be constants there, or suddenly there are multiplications ... <br><br><blockquote> <code><font color="#0000ff">-- geherates reference to the expression identified by given address,</font> &lt;br&gt; <br> <font color="#0000ff">-- this excludes address where to store it, only value is obtained</font> &lt;br&gt; <br> ref <font color="#a52a2a"><b>::</b></font> DestAddr <font color="#a52a2a"><b>-&gt;</b></font> Op&lt;br&gt; <br> ref a &lt;br&gt; <br> <font color="#a52a2a"><b>|</b></font> elem a constants <font color="#a52a2a"><b>=</b></font> Const (dta <font color="#a52a2a"><b>!!</b></font> a)&lt;br&gt; <br> <font color="#a52a2a"><b>|</b></font> elem a onerefs <font color="#a52a2a"><b>=</b></font> geneval a&lt;br&gt; <br> <font color="#a52a2a"><b>|</b></font> elem a lets <font color="#a52a2a"><b>=</b></font> ReadVarExp a&lt;br&gt; <br> <font color="#a52a2a"><b>|</b></font> elem a persistents <font color="#a52a2a"><b>=</b></font> ReadExp a&lt;br&gt; <br> <font color="#a52a2a"><b>|</b></font> otherwise <font color="#a52a2a"><b>=</b></font> trace <font color="#ff00ff">"oops1"</font> <font color="#a52a2a"><b>$</b></font> undefined&lt;br&gt; <br></code> </blockquote>  Here we have a ref function, in which there are some pre-conditions superimposed on the input parameter, the syntax of such conditions is a vertical line, then a condition, and then an equal sign, followed by the function body, if the condition is true.  It's like a big if ... elseif ... elseif ... else ... endif.  The last else we have described through trace "oops" $ undefined - will output an error (trace) and stop the program (undefined). <br><br>  We look, if the input address belongs to constants, then we generate access to the constant (just Op, denoting a constant).  What kind of constant - defines the parameter constructor Const - is simply the value of the memory at the specified address.  dta is a list containing all the memory cells sequentially, and dfa !! a is access to the a-th element of the list. <br><br>  If the input address belongs to onerefs (memory is written 1 time, then 1 time is read), then you just need to form a tree node with two other opami (operation with parentheses).  Called geneval (described below), which will generate from a simple Op (add two memory cells and put the result in a third) complex (add two other Op, return the result _ _) <br><br>  Similarly, for reading temporary variables (which are written once, read a lot), and for reading input ports. <br><br>  The geneval function itself is described below, it uses pattern matching.  From the resulting address, we choose a flat Op (from the ast list), and convert it to a tree.  Curiously, this function calls ref, described above, so the functions are mutually recursive. <br><br><blockquote> <code><font color="#0000ff">-- turns plain code in tree code, converting memory refs to ops via "ref"</font> &lt;br&gt; <br> geneval a <font color="#a52a2a"><b>=</b></font> e <font color="#a52a2a"><b>$</b></font> ast <font color="#a52a2a"><b>!!</b></font> a&lt;br&gt; <br> e (Add addr r1 r2) <font color="#a52a2a"><b>=</b></font> AddExp (ref r1) (ref r2)&lt;br&gt; <br> e (Sub addr r1 r2) <font color="#a52a2a"><b>=</b></font> SubExp (ref r1) (ref r2)&lt;br&gt; <br> e (Mul addr r1 r2) <font color="#a52a2a"><b>=</b></font> MulExp (ref r1) (ref r2)&lt;br&gt; <br> e (Div addr r1 r2) <font color="#a52a2a"><b>=</b></font> DivExp (ref r1) (ref r2)&lt;br&gt; <br> e (If cmdop cmdr addr r1 r2) <font color="#a52a2a"><b>=</b></font> IfExp cmdop (ref cmdr) (ref r1) (ref r2)&lt;br&gt; <br> e (Input addr r1) <font color="#a52a2a"><b>=</b></font> ReadPortExp r1&lt;br&gt; <br> e (Sqrt addr r1) <font color="#a52a2a"><b>=</b></font> SqrtExp (ref r1)&lt;br&gt; <br> e (Copy addr r1) <font color="#a52a2a"><b>=</b></font> ref r1&lt;br&gt; <br> e x <font color="#a52a2a"><b>=</b></font> trace (show x) <font color="#a52a2a"><b>$</b></font> undefined&lt;br&gt; <br></code> </blockquote>  Op Copy (Copy) simply means to take the result to the original address.  The Add / Sub / Mul / Div commands are literal transformations from flat to tree.  Input is converted to read from the port.  Reading from temporary variables or from constant variables is converted above into ref. <br><br>  Next we write the generation <br><blockquote> <code>retval <font color="#a52a2a"><b>=</b></font> <font color="#ff00ff">"module Vm where</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">data VMState = VMState { "</font> <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> (intercalate <font color="#ff00ff">","</font> <font color="#a52a2a"><b>$</b></font> &lt;br&gt; <br> map (( <font color="#ff00ff">"m"</font> <font color="#a52a2a"><b>++</b></font> ) <font color="#a52a2a"><b>.</b></font> show) persistents <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> map (( <font color="#ff00ff">"o"</font> <font color="#a52a2a"><b>++</b></font> ) <font color="#a52a2a"><b>.</b></font> show) outports&lt;br&gt; <br> ) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"::Double }</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br></code> </blockquote><br>  This generated part describing the structure itself.  Here, obviously, (++) is the gluing operator of lists (lines), intercalate is gluing several lists, interleaving them with the specified ones (read: insert a separating comma), and in the structure we will include all persistent fields with the prefix m (memory) and all output ports with the prefix o - output ports.  At the end we give them the type Double and the line feed will not be forgotten. <br><br>  You can give them not the type Double, but the type! Double, then this will be a structure not with lazy fields, but with non-lazy.  The study shows (see previous post) that when calculating all output ports, the difference in speed is more than 20 times, with lazy, of course, slower.  Well, it's up to the reader to substitute or not substitute strictness annotation (waxed sign).  Why did I say ‚Äúall output ports‚Äù?  Because with lazy calculations, you can get the value of this structure after the Nth iteration, and ask only one required port, for example.  A large scope of work will begin to unfold, and after a pause, the calculated value will come (for example, when we write <br><br> <code>putStrLn $ "o10=" ++ (show $ o10 vmlast) <br></code> <br><br>  then the following will happen: ‚Äúo10 =‚Äù will be written to the console, and then there will be a pause, and then the value will be displayed.  If the same putStrLn is written again, then there will be no delay, because  value is calculated.  If you then ask to write o11, then the delay will be again, but probably not so great, since most likely o10 and o11 have some kind of common part of the calculations, which has already been counted as a whole for o10, and will not be considered for o11. <br><br><blockquote> <code><font color="#ff00ff">"initState = VMState {"</font> <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> (intercalate <font color="#ff00ff">","</font> <font color="#a52a2a"><b>$</b></font> &lt;br&gt; <br> map ( <font color="#a52a2a"><b>\</b></font> a <font color="#a52a2a"><b>-&gt;</b></font> <font color="#ff00ff">"m"</font> <font color="#a52a2a"><b>++</b></font> (show a) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"="</font> <font color="#a52a2a"><b>++</b></font> (show <font color="#a52a2a"><b>$</b></font> dta <font color="#a52a2a"><b>!!</b></font> (recast a))) persistents <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> map (( <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"=O"</font> ) <font color="#a52a2a"><b>.</b></font> ( <font color="#ff00ff">"o"</font> <font color="#a52a2a"><b>++</b></font> ) <font color="#a52a2a"><b>.</b></font> show) outports&lt;br&gt; <br> ) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"}</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br></code> </blockquote>  This is where the function for creating the initial value of the black box state was generated.  All memory is initialized with values ‚Äã‚Äãfrom the binary that were in the right place (dta).  All output ports are initialized with zeros.  Haskell requires mandatory initialization of structures. <br><br><blockquote> <code><font color="#ff00ff">"nextState x ("</font> <font color="#a52a2a"><b>++</b></font> (intercalate <font color="#ff00ff">","</font> <font color="#a52a2a"><b>$</b></font> map (( <font color="#ff00ff">"i"</font> <font color="#a52a2a"><b>++</b></font> ) <font color="#a52a2a"><b>.</b></font> show) inports) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">")=</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">let</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> cmap ( <font color="#a52a2a"><b>\</b></font> a <font color="#a52a2a"><b>-&gt;</b></font> <font color="#ff00ff">"    t"</font> <font color="#a52a2a"><b>++</b></font> show a <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"=("</font> <font color="#a52a2a"><b>++</b></font> (ast2haskell <font color="#ff00ff">"x"</font> <font color="#a52a2a"><b>$</b></font> geneval a) <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">") :: Double</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> ) lets <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> <font color="#ff00ff">" in x {</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> intercalate <font color="#ff00ff">",</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> (&lt;br&gt; <br> map ( <font color="#a52a2a"><b>\</b></font> a <font color="#a52a2a"><b>-&gt;</b></font> <font color="#ff00ff">"    m"</font> <font color="#a52a2a"><b>++</b></font> show a <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"="</font> <font color="#a52a2a"><b>++</b></font> (ast2haskell <font color="#ff00ff">"x"</font> <font color="#a52a2a"><b>$</b></font> geneval a)) persistents <font color="#a52a2a"><b>++</b></font> &lt;br&gt; <br> map ( <font color="#a52a2a"><b>\</b></font> a <font color="#a52a2a"><b>-&gt;</b></font> <font color="#ff00ff">"    o"</font> <font color="#a52a2a"><b>++</b></font> show a <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"="</font> <font color="#a52a2a"><b>++</b></font> (ast2haskell <font color="#ff00ff">"x"</font> <font color="#a52a2a"><b>$</b></font> geneval <font color="#a52a2a"><b>$</b></font> head <font color="#a52a2a"><b>$</b></font> outputs a)) outports )&lt;br&gt; <br> <font color="#a52a2a"><b>++</b></font> <font color="#ff00ff">"}</font> <font color="#6a5acd">\n</font> <font color="#ff00ff">"</font> ;&lt;br&gt; <br></code> </blockquote>  Here the most volumetric part is generated.  To begin with, a tuple of input parameters is formed in a form similar to this: (i10, i11, i60000), then there is a ‚Äúlet‚Äù into which all temporary (non-permanent) variables fit, with the prefix ‚Äút‚Äù.  Then comes the formation of a new structure in which expressions are written for each of its members: x {m20 = expr1, m25 = expr2 ..., o10 = exprN}.  The expressions in the initializations of t and m refer to ‚ÄútNN‚Äù, ‚ÄúiNN‚Äù and ‚ÄúmNN x‚Äù - the latter means the value of the memory from the previous iteration. <br><br><blockquote> <code>in retval --      . <br></code> </blockquote><br><br>  <a href="http://san13.habrahabr.ru/blog/70185/">Ending</a> </div><p>Source: <a href="https://habr.com/ru/post/70179/">https://habr.com/ru/post/70179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../70170/index.html">Habrarazu tell me ...</a></li>
<li><a href="../70171/index.html">iXBT is infected, according to Yandex</a></li>
<li><a href="../70173/index.html">Doctrine integration in kohana 3</a></li>
<li><a href="../70174/index.html">simple editor bb codes</a></li>
<li><a href="../70176/index.html">What to wish before the death penalty</a></li>
<li><a href="../70181/index.html">Check of equality, inequality, identity of nodes in XPath</a></li>
<li><a href="../70185/index.html">Part 3/3. Ideal VM compiler for ICFPC 2009, on Haskell, with popularizing comments</a></li>
<li><a href="../70186/index.html">Singed netbook as a work of art</a></li>
<li><a href="../70188/index.html">Plugin for WordPress. Making LaTex image formulas using the Google API</a></li>
<li><a href="../70189/index.html">The study of site design portfolio - patterns and modern practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>