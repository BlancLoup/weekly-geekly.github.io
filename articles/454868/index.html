<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compiling C to WebAssembly without Emscripten</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The compiler is part of Emscripten . And what if you remove all the whistles and leave only him? 

 Emscripten is required to compile C / C ++ into We...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compiling C to WebAssembly without Emscripten</h1><div class="post__text post__text-html js-mediator-article">  The compiler is part of <a href="https://emscripten.org/">Emscripten</a> .  And what if you remove all the whistles and leave only him? <br><br>  Emscripten is required to compile C / C ++ into <a href="https://webassembly.org/">WebAssembly</a> .  But this is much more than just a compiler.  Emscripten's goal is to completely replace your C / C ++ compiler and run code on the web that was <b>not</b> originally <b>intended</b> for the Web.  For this, Emscripten emulates the entire POSIX operating system.  If the program uses <a href="http://man7.org/linux/man-pages/man3/fopen.3.html">fopen ()</a> , then Emscripten will provide file system emulation.  If OpenGL is used, then Emscripten will provide a C-compatible GL context supported by <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> .  This is a lot of work, and a lot of code that will have to be implemented in the final package.  But can you just ... remove it? <br><a name="habracut"></a><br>  The actual <i>compiler</i> in the Emscripten toolbox is LLVM.  It was he who translates the C code into WebAssembly byte code.  This is a modern modular framework for analyzing, transforming and optimizing programs.  LLVM is modular in the sense that it never compiles directly into machine code.  Instead, the built-in <i>front-end compiler</i> generates <i>an intermediate representation</i> (IR).  This intermediate presentation is actually called LLVM, an abbreviation of Low-Level Virtual Machine, hence the name of the project. <br><br>  Then the <i>backend compiler</i> translates the IR into host machine code.  The advantage of such a strict separation is that new architectures are supported by the ‚Äúsimple‚Äù addition of a new compiler.  In this sense, WebAssembly is just one of the many compilation goals that LLVM supports, and for some time it has been activated by a special flag.  Starting with LLVM 8, the goal of compiling WebAssembly is available by default. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On MacOS, you can install LLVM using <a href="https://brew.sh/">homebrew</a> : <br><br><pre><code class="bash hljs">$ brew install llvm $ brew link --force llvm</code> </pre> <br>  Check for WebAssembly support: <br><br><pre> <code class="bash hljs">$ llc --version LLVM (http://llvm.org/): LLVM version 8.0.0 Optimized build. Default target: x86_64-apple-darwin18.5.0 Host CPU: skylake Registered Targets: <span class="hljs-comment"><span class="hljs-comment"># ‚Ä¶,  ‚Ä¶ systemz - SystemZ thumb - Thumb thumbeb - Thumb (big endian) wasm32 - WebAssembly 32-bit # ! ! ! wasm64 - WebAssembly 64-bit x86 - 32-bit X86: Pentium-Pro and above x86-64 - 64-bit X86: EM64T and AMD64 xcore - XCore</span></span></code> </pre> <br>  It seems we are ready! <br><br><h1>  Compiling C in a Difficult Way </h1><br><blockquote>  <b>Note:</b> here we look at some low-level RAW WebAssembly formats.  If you find them hard to understand, this is normal.  <b>Good use of WebAssembly does not necessarily require an understanding of the entire text in this article.</b>  <b>If you are looking for code for copy-paste, see the compiler call in the "Optimization" section</b> .  But if you're interested, keep reading!  I previously wrote an introduction to <a href="https://dassur.ma/things/raw-wasm">clean Webassembly</a> and WAT: these are the basics you need to understand this post. </blockquote>  Warning: I deviate a little from the standard and at every step I will try to use readable formats (as far as possible).  Our program here will be very simple to avoid borderline situations and not be distracted: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Filename: add.c int add(int a, int b) { return a*a + b; }</span></span></code> </pre> <br>  What a magnificent engineering feat!  Especially because the program is called <i>add</i> , but in fact it does not <i>add</i> anything (does not add).  More importantly: the program does not use the standard library, and of the types here, only 'int'. <br><br><h3>  Turning C into an internal LLVM view </h3><br>  The first step is to turn our C program into LLVM IR.  This is the task of the <code>clang</code> front-end compiler, which is installed with LLVM: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ <span class="hljs-comment"><span class="hljs-comment"># Target WebAssembly -emit-llvm \ # Emit LLVM IR (instead of host machine code) -c \ # Only compile, no linking just yet -S \ # Emit human-readable assembly rather than binary add.c</span></span></code> </pre> <br>  As a result, we get <code>add.ll</code> with the internal representation of LLVM IR.  <b>I show it only for the sake of completeness</b> .  When working with WebAssembly or even clang, you, as a C developer, <i>never</i> come into contact with LLVM IR. <br><br><pre> <code class="cpp hljs">; ModuleID = <span class="hljs-string"><span class="hljs-string">'add.c'</span></span> source_filename = <span class="hljs-string"><span class="hljs-string">"add.c"</span></span> target datalayout = <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-i64:64-n32:64-S128"</span></span> target triple = <span class="hljs-string"><span class="hljs-string">"wasm32"</span></span> ; Function Attrs: norecurse nounwind readnone define hidden i32 @add(i32, i32) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">3</span></span> = mul nsw i32 %<span class="hljs-number"><span class="hljs-number">0</span></span>, %<span class="hljs-number"><span class="hljs-number">0</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = add nsw i32 %<span class="hljs-number"><span class="hljs-number">3</span></span>, %<span class="hljs-number"><span class="hljs-number">1</span></span> ret i32 %<span class="hljs-number"><span class="hljs-number">4</span></span> } attributes #<span class="hljs-number"><span class="hljs-number">0</span></span> = { norecurse nounwind readnone <span class="hljs-string"><span class="hljs-string">"correctly-rounded-divide-sqrt-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"disable-tail-calls"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"less-precise-fpmad"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"min-legal-vector-width"</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-string"><span class="hljs-string">"no-frame-pointer-elim"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-infs-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-jump-tables"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-nans-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-signed-zeros-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"no-trapping-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"stack-protector-buffer-size"</span></span>=<span class="hljs-string"><span class="hljs-string">"8"</span></span> <span class="hljs-string"><span class="hljs-string">"target-cpu"</span></span>=<span class="hljs-string"><span class="hljs-string">"generic"</span></span> <span class="hljs-string"><span class="hljs-string">"unsafe-fp-math"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> <span class="hljs-string"><span class="hljs-string">"use-soft-float"</span></span>=<span class="hljs-string"><span class="hljs-string">"false"</span></span> } !llvm.<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>.flags = !{!<span class="hljs-number"><span class="hljs-number">0</span></span>} !llvm.ident = !{!<span class="hljs-number"><span class="hljs-number">1</span></span>} !<span class="hljs-number"><span class="hljs-number">0</span></span> = !{i32 <span class="hljs-number"><span class="hljs-number">1</span></span>, !<span class="hljs-string"><span class="hljs-string">"wchar_size"</span></span>, i32 <span class="hljs-number"><span class="hljs-number">4</span></span>} !<span class="hljs-number"><span class="hljs-number">1</span></span> = !{!<span class="hljs-string"><span class="hljs-string">"clang version 8.0.0 (tags/RELEASE_800/final)"</span></span>}</code> </pre> <br>  <i>LLVM IR is full of additional metadata and annotations, which allows the compiler to make more informed decisions when generating machine code.</i> <br><br><h3>  Turn LLVM IR into Object Files </h3><br>  The next step is to call the backend compiler <code>llc</code> to make an object file from the internal representation. <br><br>  The output file <code>add.o</code> is already a valid WebAssembly module, which contains all the compiled code of our C file. But usually you will not be able to run the object files because they lack essential parts. <br><br>  If we had <code>-filetype=obj</code> in the command, we would get the LLVM assembler for WebAssembly, a human-readable format that is somewhat similar to WAT.  However, the <code>llvm-mc</code> tool for working with such files does not yet fully support the format and often cannot process files.  Therefore, we disassemble the object files after the fact.  To validate these object files, you need a specific tool.  In the case of a WebAssembly, this was <code>wasm-objdump</code> , part of <a href="https://github.com/WebAssembly/wabt">WebAssembly Binary Toolkit</a> or wabt for short. <br><br><pre> <code class="bash hljs">$ brew install wabt <span class="hljs-comment"><span class="hljs-comment"># in case you haven't $ wasm-objdump -x add.o add.o: file format wasm 0x1 Section Details: Type[1]: - type[0] (i32, i32) -&gt; i32 Import[3]: - memory[0] pages: initial=0 &lt;- env.__linear_memory - table[0] elem_type=funcref init=0 max=0 &lt;- env.__indirect_function_table - global[0] i32 mutable=1 &lt;- env.__stack_pointer Function[1]: - func[0] sig=0 &lt;add&gt; Code[1]: - func[0] size=75 &lt;add&gt; Custom: - name: "linking" - symbol table [count=2] - 0: F &lt;add&gt; func=0 binding=global vis=hidden - 1: G &lt;env.__stack_pointer&gt; global=0 undefined binding=global vis=default Custom: - name: "reloc.CODE" - relocations for section: 3 (Code) [1] R_WASM_GLOBAL_INDEX_LEB offset=0x000006(file=0x000080) symbol=1 &lt;env.__stack_pointer&gt;</span></span></code> </pre> <br>  The output shows that our add () function is in this module, but it also contains <i>custom</i> sections with metadata and, surprisingly, several imports.  At the next stage of the <i>layout,</i> custom sections will be analyzed and deleted, and the linker will understand the import. <br><br><h3>  Layout </h3><br>  Traditionally, the task of the linker is to assemble several object files into an executable file.  The LLVM linker is called <code>lld</code> , and it is called with the target symbolic link.  For WebAssembly, this was <code>wasm-ld</code> . <br><br><pre> <code class="bash hljs">wasm-ld \ --no-entry \ <span class="hljs-comment"><span class="hljs-comment"># We don't have an entry function --export-all \ # Export everything (for now) -o add.wasm \ add.o</span></span></code> </pre> <br>  The result is a 262-byte WebAssembly module. <br><br><h3>  Launch </h3><br>  Of course, the most important thing is to see that everything <i>really</i> works.  As in the <a href="https://dassur.ma/things/raw-wasm">previous article</a> , you can use a couple of lines of embedded JavaScript to load and run this WebAssembly module. <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(instance.exports.add(</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">)); } init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  If everything is fine, you will see the number 17 in the DevTool console. <b>We have just successfully compiled C into WebAssembly, without touching Emscripten.</b>  It is also worth noting that there is no glue code here to configure and load the WebAssembly module. <br><br><h1>  Compiling C is a bit simpler. </h1><br>  We have taken quite a few steps to compile C into WebAssembly.  As I said, for educational purposes, we have reviewed in detail all the steps.  Let's skip the human-readable intermediate formats and immediately apply the C compiler as a Swiss army knife, as it was designed: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -nostdlib \ <span class="hljs-comment"><span class="hljs-comment"># Don't try and link against a standard library -Wl,--no-entry \ # Flags passed to the linker -Wl,--export-all \ -o add.wasm \ add.c</span></span></code> </pre> <br>  Here we get the same <code>.wasm</code> file, but with one command. <br><br><h1>  Optimization </h1><br>  Let's look at the WAT of our WebAssembly module by running <code>wasm2wat</code> : <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) (local i32 i32 i32 i32 i32 i32 i32 i32) global.get 0 local.set 2 i32.const 16 local.set 3 local.get 2 local.get 3 i32.sub local.set 4 local.get 4 local.get 0 i32.store offset=12 local.get 4 local.get 1 i32.store offset=8 local.get 4 i32.load offset=12 local.set 5 local.get 4 i32.load offset=12 local.set 6 local.get 5 local.get 6 i32.mul local.set 7 local.get 4 i32.load offset=8 local.set 8 local.get 7 local.get 8 i32.add local.set 9 local.get 9 return) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br>  Wow, what a great code.  To my surprise, the module uses memory (as seen in <code>i32.load</code> and <code>i32.store</code> ), eight local and several global variables.  Probably, you can manually write a more concise version.  This program is so big because we have not applied any optimizations.  Let's do it: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ + -O3 \ <span class="hljs-comment"><span class="hljs-comment"># Agressive optimizations + -flto \ # Add metadata for link-time optimizations -nostdlib \ -Wl,--no-entry \ -Wl,--export-all \ + -Wl,--lto-O3 \ # Aggressive link-time optimizations -o add.wasm \ add.c</span></span></code> </pre> <br><blockquote>  <b>Note:</b> technically, optimizing with linking (LTO) does not provide any advantages, since we compose only one file.  In large projects, LTO will help to significantly reduce the file size. </blockquote>  After executing these commands, the <code>.wasm</code> file <code>.wasm</code> reduced from 262 to 197 bytes, and WAT also became much simpler: <br><br><pre> <code class="plaintext hljs">(module (type (;0;) (func)) (type (;1;) (func (param i32 i32) (result i32))) (func $__wasm_call_ctors (type 0)) (func $add (type 1) (param i32 i32) (result i32) local.get 0 local.get 0 i32.mul local.get 1 i32.add) (table (;0;) 1 1 anyfunc) (memory (;0;) 2) (global (;0;) (mut i32) (i32.const 66560)) (global (;1;) i32 (i32.const 66560)) (global (;2;) i32 (i32.const 1024)) (global (;3;) i32 (i32.const 1024)) (export "memory" (memory 0)) (export "__wasm_call_ctors" (func $__wasm_call_ctors)) (export "__heap_base" (global 1)) (export "__data_end" (global 2)) (export "__dso_handle" (global 3)) (export "add" (func $add)))</code> </pre> <br><h1>  Calling the standard library </h1><br>  Using C without the standard libc library seems rather rude.  It is logical to add it, but I will be honest: it will <i>not</i> be easy.  <b>In fact, we do not directly invoke any libc libraries in this article</b> .  There are several suitable ones, especially <a href="https://www.gnu.org/software/libc/">glibc</a> , <a href="https://www.musl-libc.org/">musl</a> and <a href="https://www.fefe.de/dietlibc/">dietlibc</a> .  However, most of these libraries are supposed to run on the POSIX operating system, which implements a specific set of system calls.  Since we do not have a kernel interface in JavaScript, we will have to independently implement these POSIX system calls, probably through JavaScript.  This is a difficult task and I am not going to do this here.  The good news is that <b>this is what Emscripten is doing for you</b> . <br><br>  Of course, not all libc functions rely on system calls.  Functions like <code>strlen()</code> , <code>sin()</code> or even <code>memset()</code> are implemented in simple C. This means that you can use these functions or even just copy / paste their implementation from some of the mentioned libraries. <br><br><h1>  Dynamic memory </h1><br>  Without libc, fundamental C interfaces such as <code>malloc()</code> and <code>free()</code> are not available to us.  In a non-optimized WAT, we have seen that the compiler uses memory if necessary.  This means that we cannot simply use the memory as we like without risking damage.  Need to understand how it is used. <br><br><h3>  LLVM memory models </h3><br>  The way that WebAssembly is segmented will surprise experienced programmers.  First, WebAssembly technically admits a null address, but often it is still treated as an error.  Secondly, the stack comes first and grows down (to lower addresses), and the heap appears later and grows up.  The reason is that the WebAssembly memory may increase at runtime.  This means that there is no fixed end for placing the stack or heap. <br><br>  Here is the layout of the <code>wasm-ld</code> : <br><br><img src="https://habrastorage.org/webt/kz/xv/z6/kzxvz60tlxzqdv_9tvxlm4m3gca.png"><br><br>  <i><font color="gray">The stack grows down, and the heap grows up.</font></i>  <i><font color="gray">The stack starts with <code>__data_end</code> , and the heap <code>__heap_base</code> with <code>__heap_base</code> .</font></i>  <i><font color="gray">Because the stack is placed first, it is limited to the maximum size set at compilation, that is, <code>__heap_base</code> minus <code>__data_end</code></font></i> <br><br>  If you go back and look at the globals section in our WAT, we find these values: <code>__heap_base</code> set to 66560, and <code>__data_end</code> is to 1024. This means that the stack can grow to a maximum of 64 KiB, which is not a lot.  Fortunately, <code>wasm-ld</code> allows you to change this value: <br><br><pre> <code class="bash hljs">clang \ --target=wasm32 \ -O3 \ -flto \ -nostdlib \ -Wl,--no-entry \ -Wl,--<span class="hljs-built_in"><span class="hljs-built_in">export</span></span>-all \ -Wl,--lto-O3 \ + -Wl,-z,stack-size=$[8 * 1024 * 1024] \ <span class="hljs-comment"><span class="hljs-comment"># Set maximum stack size to 8MiB -o add.wasm \ add.c</span></span></code> </pre> <br><h3>  Build allocator </h3><br>  It is known that the heap area begins with <code>__heap_base</code> .  Since the <code>malloc()</code> function is missing, we know that the next memory region can be safely used.  We can place the data there as you wish, and you don‚Äôt need to be afraid of memory damage as the stack grows in the opposite direction.  However, a heap free for all can quickly become clogged, so some kind of dynamic memory management is usually required.  One option is to take the full implementation of malloc (), such as <a href="http://g.oswego.edu/dl/html/malloc.html">the malloc implementation from Dag Lee</a> , which is used in Emscripten.  There are a few smaller implementations with different tradeoffs. <br><br>  But why not write your own <code>malloc()</code> ?  We are so deeply stuck that it makes no difference.  One of the simplest is the bump-allocator: it is super-fast, extremely small and easy to implement.  But there is a drawback: you cannot free memory.  Although at first glance, such an allocator seems incredibly useless, but when developing <a href="https://squoosh.app/">Squoosh</a> I ran into precedents where it would be an excellent choice.  The concept of a bump allocator is that we store the starting address of unused memory as global.  If the program requests <code>n</code> bytes of memory, we move the marker to <code>n</code> and return the previous value: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> __heap_base; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bump_pointer = &amp;__heap_base; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r = bump_pointer; bump_pointer += n; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// lol }</span></span></code> </pre> <br>  Global variables from WAT are actually defined by <code>wasm-ld</code> , so we can access them from our C code as ordinary variables if we declare them <code>extern</code> .  So, <b>we just wrote our own <code>malloc()</code> ... in five lines C.</b> <br><br><blockquote>  <b>Note:</b> our bump allocator is not fully compatible with <code>malloc()</code> from C. For example, we do not give any guarantees of alignment.  But it works well enough, so ... </blockquote><h3>  Dynamic Memory Usage </h3><br>  To check, let's make a function C, which takes an array of numbers of arbitrary size and calculates the sum.  Not very interesting, but it forces the use of dynamic memory, since we do not know the size of the array during assembly: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; len; i++) { sum += a[i]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum; }</code> </pre> <br>  The sum () function, I hope, is pretty clear.  A more interesting question is how to transfer an array from JavaScript to WebAssembly - after all, WebAssembly understands only numbers.  The general idea is to use <code>malloc()</code> <i>from JavaScript</i> to allocate a piece of memory, copy the values ‚Äã‚Äãthere and pass the address (number!) <i>Where the</i> array is located: <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">async</span></span></span><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> { instance } = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">await</span></span></span><span class="javascript"> WebAssembly.instantiateStreaming( fetch(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"./add.wasm"</span></span></span><span class="javascript">) ); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">const</span></span></span><span class="javascript"> jsArray = [</span><span class="hljs-number"><span class="javascript"><span class="hljs-number">1</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">2</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">3</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">4</span></span></span><span class="javascript">, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">]; </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// Allocate memory for 5 32-bit integers // and return get starting address. const cArrayPointer = instance.exports.malloc(jsArray.length * 4); // Turn that sequence of 32-bit integers // into a Uint32Array, starting at that address. const cArray = new Uint32Array( instance.exports.memory.buffer, cArrayPointer, jsArray.length ); // Copy the values from JS to C. cArray.set(jsArray); // Run the function, passing the starting address and length. console.log(instance.exports.sum(cArrayPointer, cArray.length)); } init(); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  After starting, you should see in the DevTools console the answer is 15, which is really the sum of all numbers from 1 to 5. <br><br><h1>  Conclusion </h1><br>  So, you read to the end.  Congratulations!  Again, if you feel a bit overwhelmed, everything is fine.  <b>It is not necessary to read all the details.</b>  <b>Understanding them is completely optional for a good web developer and is not even required for excellent use of WebAssembly</b> .  But I wanted to share this information, because it allows you to really appreciate all the work that a project like <a href="https://emscripten.org/">Emscripten</a> does for you.  At the same time, it gives an understanding of how small purely computational modules WebAssembly can be.  The Wasm module for the summation of the array contained just 230 bytes, <i>including the dynamic memory allocator</i> .  Compiling the same code with Emscripten will produce 100 bytes of WebAssembly code and 11K of junction JavaScript code.  We need to try for the sake of such a result, but there are situations when it is worth it. </div><p>Source: <a href="https://habr.com/ru/post/454868/">https://habr.com/ru/post/454868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454844/index.html">Odaydzhest: interesting for designers for the week</a></li>
<li><a href="../454850/index.html">Evolution of a single algorithm</a></li>
<li><a href="../454856/index.html">Parse SSL / TLS certificate verification vulnerabilities in non-browser software</a></li>
<li><a href="../45486/index.html">Street Performer Protocol Model - Possible Solution to Piracy Issues</a></li>
<li><a href="../454866/index.html">Siemplify, a Tel Aviv-based cyber security systems management company, raised $ 30 million in Round C</a></li>
<li><a href="../45487/index.html">How much is a hundred credit cards?</a></li>
<li><a href="../454872/index.html">Space Invaders: now in 512 bytes (Assembler x86)</a></li>
<li><a href="../454874/index.html">A little bit about multitasking in microcontrollers</a></li>
<li><a href="../454876/index.html">About designing a flexible system of character abilities in games</a></li>
<li><a href="../454878/index.html">We study MITER ATT & CK. Mobile Matrices: Device Access. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>