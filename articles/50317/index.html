<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experience setting up nginx on debian</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yesterday evening I devoted a fuss with the nginx http server as a front-end to apache. As you know, nginx is a lightweight reliable HTTP server writt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experience setting up nginx on debian</h1><div class="post__text post__text-html js-mediator-article">  Yesterday evening I devoted a fuss with the nginx http server as a front-end to apache.  As you know, <a href="http://nginx.net/">nginx</a> is a lightweight reliable HTTP server written by <a href="http://sysoev.ru/">Igor Sysoev</a> (an employee of <a href="http://rambler.ru/">Rambler</a> ).  It is great for issuing static pages, especially under load.  Usually, the nginx + apache bundle is configured, in which nginx serves all incoming requests to the server, gives static files on its own, and requests dynamic content to apache to apache. <br><br>  So, there are a lot of articles in the Internet on setting up the work of this couple, including in Russian, and there is no point in writing about it.  And I will tell you better about the nuances that I encountered yesterday when setting up nginx to work in the right mode, and at the same time I will show and comment on my configuration of this server. <br><br><a name="habracut"></a><br><h2>  My configuration </h2><br>  For a start, what was actually required to be done?  The server was configured for <a href="http://habrometr.ru/">Habrometer</a> .  He had to produce statics (logo and css) and dynamics (the actual pages of the site and png-habrometers).  At the same time, it was necessary to take into account that the habrometer is created on the fly if it is not in the cache (and the cache is cleaned every 2 hours when new data is requested).  Site pages also need to be cached.  That was the task. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The implementation was decided to do as follows.  nginx when processing a request must follow the following rules: <br><ol><li>  If static is requested, then just return it (all static in stuff stuff). </li><li>  If a site page is requested, you need to check the cache;  if the file is not found in the cache, send the request to the apache backend.  The page cache should be cleaned with a given frequency (for different pages the frequency is different). </li><li>  If the informer is requested, then you need to check the cache for the presence of a file.  If the file is not there, send a request to the backend. </li></ol><br>  The file system is selected for caching habrometers.  All generated informers are added to the / image_cache / directory and it is cleaned every 2 hours when the source data is updated.  Informers are drawn and put into this directory by a PHP script with the corresponding request. <br><br>  Memcache is selected for caching site pages.  it is easy and convenient to work with it (from both nginx and PHP) and it can clean the cached pages itself after a specified time interval, which cannot be done by the FS without additional scripts.  Yes, and memcache will work faster, because  All good is stored in the RAM. <br><br>  The result was the following server configuration: <br><br>  # cat /etc/nginx/nginx.conf <br><pre>  user www-data;
 worker_processes 4;
 error_log /var/log/nginx/error.log;
 pid /var/run/nginx.pid;
 events {
     worker_connections 1024;
 }
 http {
     include /etc/nginx/mime.types;
     default_type application / octet-stream;
     access_log /var/log/nginx/access.log;
     sendfile on;
     keepalive_timeout 65;
     tcp_nodelay on;
     gzip on;
     add_header Habrometr "hacker_mode_enabled;)";
     server {
         listen 80;
         server_name habrometr.server.valera.ws habrometr.ru www.habrometr.ru;
         access_log /var/log/nginx/habrometr.access.log;
         location / {
             root / home / habrometr / public_html;
             index index.html index.htm;
             if (-f $ document_root / image_cache $ {uri}) {
                 rewrite ^. * $ / image_cache / $ uri last;
                 break;
             }

             set $ memcached_key "habrometr $ uri";
             memcached_pass localhost: 11211;
             # if a resource is not found in memcached, send a request for Apache
             error_page 404 502 504 = @backend;
             add_header Content-Type "text / html; charset = UTF-8";
             gzip on;
             gzip_proxied any;
             gzip_types application / octet-stream;
     }

     location @backend {
         set $ proxy_uri http://habrometr.ru:99999$request_uri;
         proxy_pass $ proxy_uri;
         proxy_redirect off;
         proxy_set_header X-Real-IP $ remote_addr;
         proxy_set_header X_Forwarded-For $ proxy_add_x_forwarded_for;
         proxy_connect_timeout 20;
     }
     location / image_cache / {
         root / home / habrometr / public_html;
         expires modified + 2h;  # cache expires 2 hours after file modification
     }
     location / stuff / {
         root / home / habrometr / public_html;
         expires 30d;
     }
     location ~ /\.ht {
         deny all;
     }
 } </pre><br>  Given the above scenario, the entire configuration should be clear.  I note only that <a href="http://habrometr.ru/">habrometr.ru</a> : 99999 is apache, to which requests will be redirected.  The port I, of course, changed, in reality, usually use 8080 or something like that. <br><br><h2>  Tricks </h2><br>  And now that is non-trivial in this configuration (at least for a beginner in this field). <br><br><h3>  Version </h3><br>  First, the server works for me on Debian 4.0.  I naturally installed all software from standard repositories.  Put from there and nginx.  Installed nginx turned out to be version 0.4 with the latest version 0.7 available with a significant <a href="http://sysoev.ru/nginx/changes.html">list of changes</a> . <br><br>  It turned out that version 0.4 does not know how to do a lot of what was needed.  In particular: <br><ol><li>  The modified flag does not narrow down for the expire directive, but I needed this to indicate the expiration time of the informer cache (2 hours after creation: expire modified + 2h); </li><li>  proxy_pass did not know how to use variables, but I needed this opportunity; </li><li>  memcached did not use the $ memcached_key variable to determine the key, i.e.  it was impossible to set the key of the desired format. </li></ol><br>  In principle, all these problems could be solved by circumventing perverted ways, but I didn‚Äôt want to do this at all, so I just installed a fresh version of raw nginx.  Fortunately, this is done very simply. <br><br>  Before describing the installation process, I note that by default, when building from source, all nginx files are put into the / usr / local / nginx directory.  Of course, you can change it (--prefix =).  But note that installed from nginx packages scatters its files to the appropriate system directories (/ etc, / var, log, / var / run, etc.), which I definitely like more than / usr / local / nginx / *.  That's why I compiled nginx from raw files with settings for system directories, and then instead of make install I just manually replaced the old server binary in the / usr / sbin directory with a new one (/ usr / sbin / nginx).  There are no more significant files after the build for the server.  The config, naturally, remains the same. <br><br>  So, installing nginx on Debian etch from source over the installed package of the old version. <br><pre>  # wget http://sysoev.ru/nginx/nginx-0.7.31.tar.gz
 # tar xzf nginx-0.7.31.tar.gz
 # cd nginx-0.7.31
 # apt-get install libpcre3 libpcre3-dev libpcrecpp0
 # /etc/init.d/nginx stop;
 # ./configure --sbin-path = / usr / local / sbin --with-http_ssl_module
 --without-mail_pop3_module --without-mail_imap_module
 --without-mail_smtp_module --prefix = / var / lib / nginx
 --sbin-path = / usr / sbin --conf-path = / etc / nginx /
 --error-log-path = / var / log / nginx --http-log-path = / var / log / nginx
 --pid-path = / var / run --lock-path = / var / lock
 # cd objs
 # cp -f ./nginx / usr / sbin
 # /etc/init.d/nginx start; </pre><br>  After that, a fresh nginx server should be launched and serve requests, which can do all the things we need. <br><br><h3>  Documents from memcached </h3><br>  When nginx gives files directly, it passes the Content-type header according to the type of this file.  When nginx proxies apache, the content type comes from apache.  But when nginx picks up a document from memcached, the Content-type is not set.  So, the default is used.  And we default on the default_type application / octet-stream ;, and rightly so.  In this case, when retrieving a document from the cache, the type will be incorrectly transmitted, and some browsers will offer to save the binary file instead of opening the HTML page.  To remedy the situation, in case of return from memcached, we set headers (and, by the way, compression, too) in addition: <br><pre>  set $ memcached_key "habrometr $ uri";
 memcached_pass localhost: 11211;
 error_page 404 502 504 = @backend;
 add_header Content-Type "text / html; charset = UTF-8";
 gzip on;
 gzip_proxied any;
 gzip_types application / octet-stream; </pre><br>  At the same time from memcached we get only HTML in UTF-8. <br><br><h3>  Flies separately, cutlets separately. </h3><br>  As a separate magic, I would like to single out the very method of allocating habrometers by file name and serving them in a special way.  In the location / section, select these files: <br><pre>  if (-f $ document_root / image_cache $ {uri}) {
     rewrite ^. * $ / image_cache / $ uri last;
     break;
 } </pre><br>  If we find the file in the cache, then we simply return it to the user, informing that the file can be cached before the next update (modification of the file + 2 hours): <br><pre>  location / image_cache / {
     root / home / habrometr / public_html;
     expires modified + 2h;
 } </pre><br>  Note the presence of the rewrite last flag and the break directive;  for her.  Without the use of these two directives, I could not force nginx 0.4 (I did not check it with 0.7) immediately go to the location / image_cache / section, i.e.  after finding the file, he proceeded to skip, which is incorrect. </div><p>Source: <a href="https://habr.com/ru/post/50317/">https://habr.com/ru/post/50317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../50302/index.html">Table binding in Model :: find ()</a></li>
<li><a href="../50305/index.html">Fresh modification of the OSX.Trojan.iServices trojan</a></li>
<li><a href="../50310/index.html">The basics</a></li>
<li><a href="../50312/index.html">Building a relational structure from the ER model</a></li>
<li><a href="../50314/index.html">Four generations of SaaS</a></li>
<li><a href="../50321/index.html">Check for updates</a></li>
<li><a href="../50326/index.html">An indispensable assistant for large MySQL dumps</a></li>
<li><a href="../50327/index.html">Laws for life</a></li>
<li><a href="../50328/index.html">Methods for protecting a web form without captcha</a></li>
<li><a href="../50333/index.html">Ubuntu Open Week: Ubuntu hike to servers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>