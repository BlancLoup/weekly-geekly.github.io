<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prologue - a declarative language capable of solving any rebuses and proving theorems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine a high-level language in which you do not need to specify HOW to get the result, instead you just need to specify WHAT you want to receive. At...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prologue - a declarative language capable of solving any rebuses and proving theorems</h1><div class="post__text post__text-html js-mediator-article">  Imagine a high-level language in which you do not need to specify HOW to get the result, instead you just need to specify WHAT you want to receive.  At the same time, the scope of the language is not limited and the language is able to solve the same tasks as any other high-level language, like JAVA.  Sounds fantastic, doesn't it?  However, such a language is and it is called PROLOG.  Let's see how PROLOG does this task using the example of guessing the prologue of some riddles and ask PROLOG to give a proof of the theorem. <br><br><img src="https://habrastorage.org/files/66b/d0a/d94/66bd0ad9428943138aa8a102526cbe02.jpg" alt="image"><br><br><a name="habracut"></a><br><h4>  <u><b>Riddle 1.</b></u> Simple, mathematical.  "?" - an arbitrary mathematical operation (+, -, *, /), given the equation ((((1? 2)? 3)? 4)? 5)? 6 = 35.  Find unknown operations. </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start describing what we want to get.  Since the sign of the operation is unknown, it will be a parameter. <br><br>  formula (X1, X2, X3, X4, X5, X6, Sign1, Sign2, Sign3, Sign4, Sign5, Result): - <br>  operation (X1, X2, Sign1, PartialResult1), <br>  operation (PartialResult1, X3, Sign2, PartialResult2), <br>  operation (PartialResult2, X4, Sign3, PartialResult3), <br>  operation (PartialResult3, X5, Sign4, PartialResult4), <br>  operation (PartialResult4, X6, Sign5, Result). <br><br>  This line describes the formula 1? 2? 3? 4? 5? 6 = Result.  In fact, it means: the formula is correct if there is a partial result 1, a partial result 2 ... a partial result 4, such that the operations are correct.  However, the prologue does not know what an operation is, so we will describe in which cases they are correct: <br><br>  operation (X1, X2, "+", Result): - Result = X1 + X2. <br>  operation (X1, X2, "*", Result): - Result = X1 * X2. <br>  operation (X1, X2, "/", Result): - Result = X1 / X2. <br>  operation (X1, X2, "-", Result): - Result = X1 - X2. <br><br>  We have described the formula, and now we can ask any questions about it.  For example, we can ask the following questions: 1) if X1 = 1 X2 = 2 ... X6 = 6 Result = 35 then what are possible operations?  2) the part of the numerical parameters and the part of the operations are indicated, as well as the result, to find out what are the missing parameters?  3) all operations, numerical parameters, result are indicated;  find out if the formula is correct.  You do not need to worry about how the prologue will find the answer - you just need to ask a question. <br><br>  So the question is: <br>  askMainQuestion (): - <br>  formula (1,2,3,4,5,6, Sign1, Sign2, Sign3, Sign4, Sign5,35), <br>  stdio :: write (Sign1, Sign2, Sign3, Sign4, Sign5), <br>  stdio :: nl,% new line <br>  fail. <br><br>  Answer: ++ * ++, + ** + -, *** ++ (To ask a question about numeric parameters, you will have to write a couple more lines, but more on that later.) <br><br><div class="spoiler">  <b class="spoiler_title">View full program code (Visual Prolog 7.5)</b> <div class="spoiler_text">  implement main <br>  open core <br><br>  class predicates <br>  askMainQuestion :() procedure. <br>  operation: (real, real, string, real) multi (i, i, o, o). <br>  formula: (real, real, real, real, real, real, string, string, string, string, string, real) nondeterm (i, i, i, i, i, i, o, o, o, o, o i). <br>  abs: (real, real) nondeterm (i, o). <br>  clauses <br><br>  operation (X1, X2, "+", Result): - Result = X1 + X2. <br>  operation (X1, X2, "-", Result): - Result = X1 - X2. <br>  operation (X1, X2, "*", Result): - Result = X1 * X2. <br>  operation (X1, X2, "/", Result): - Result = X1 / X2. <br><br>  formula (X1, X2, X3, X4, X5, X6, Sign1, Sign2, Sign3, Sign4, Sign5, Result): - <br>  operation (X1, X2, Sign1, PartialResult1), <br>  operation (PartialResult1, X3, Sign2, PartialResult2), <br>  operation (PartialResult2, X4, Sign3, PartialResult3), <br>  operation (PartialResult3, X5, Sign4, PartialResult4), <br>  operation (PartialResult4, X6, Sign5, FinalResult), <br>  abs (FinalResult-Result, Difference), <br>  Difference &lt;0.0001.  % taking into account rounding errors when dividing <br><br>  abs (X, Result): - X&gt; = 0, Result = X. <br>  abs (X, Result): - X &lt;0, Result = -X. <br><br>  askMainQuestion (): - <br>  formula (1,2,3,4,5,6, Sign1, Sign2, Sign3, Sign4, Sign5,35), <br>  stdio :: write (Sign1, Sign2, Sign3, Sign4, Sign5), <br>  stdio :: nl, <br>  fail. <br><br>  askMainQuestion (). <br><br>  run (): - <br>  console :: init (), <br>  askMainQuestion (), <br>  _ = stdIO :: readchar (). <br><br>  end implement main <br><br>  goal <br>  mainExe :: run (main :: run). <br></div></div><br><br><h4>  <u><b>Riddle 2.</b></u> Unpretentious, non-mathematical.  Given the names of people and kinstenny relations between them.  Find all the brothers. </h4><br><br>  We indicate specific family ties: <br>  parent ("Tom", "Jake"). <br>  parent ("Jim", "Jake"). <br>  parent ("Timmi", "Tom"). <br>  uncle ("Tom", "Peter"). <br>  brother ("Timmi", "Cartman"). <br><br>  Now we will describe what a family relationship means: <br><br>  brother (Man1, Man2): - parent (Man1, Parent), parent (Man2, Parent), Man1 &lt;&gt; Man2. <br><br>  (Man1 and Man2 are brothers if there is a ManParent who is the parent for Man1 and Man2, and thus Man1 is not Man2). <br><br>  brother (Man1, Man2): - parent (ChildMan1, Man1), uncle (ChildMan1, Man2). <br><br>  (Man 1 and Man 2 brothers, if Man 1 has a child, and Man 2 is the uncle of this child). <br><br>  Now ask the question of who the brothers are: <br><br>  askMainQuestion (): - <br>  brother (X, Y) <br>  stdIO :: write (X, "", Y), <br>  stdio :: nl, <br>  fail. <br><br><div class="spoiler">  <b class="spoiler_title">View full program code</b> <div class="spoiler_text">  implement main <br>  open core <br><br>  class predicates <br>  askMainQuestion :() procedure. <br>  parent: (string, string) multi (o, o) nondeterm (o, i) nondeterm (i, o). <br>  brother: (string, string) nondeterm (o, o) nondeterm (i, o). <br>  uncle: (string, string) nondeterm anyflow. <br>  clauses <br><br>  parent ("Tom", "Jake"). <br>  parent ("Jim", "Jake"). <br>  parent ("Timmi", "Tom"). <br>  uncle ("Tom", "Peter"). <br><br>  / * uncle (Man1, Man2): - parent (Man1, ParentMan1), brother (ParentMan1, Man2).  uncommenting this line will drop the program * / <br>  brother ("Timmi", "Cartman"). <br>  brother (Man1, Man2): - parent (ChildMan1, Man1), uncle (ChildMan1, Man2). <br>  brother (Man1, Man2): - parent (Man1, Parent), parent (Man2, Parent), Man1 &lt;&gt; Man2. <br><br>  askMainQuestion (): - <br>  brother (X, Y) <br>  stdIO :: write (X, "", Y), <br>  stdio :: nl, <br>  fail. <br><br>  askMainQuestion (). <br><br>  run (): - <br>  console :: init (), <br>  askMainQuestion (), <br>  _ = stdIO :: readchar (). <br><br>  end implement main <br>  goal <br>  mainExe :: run (main :: run). <br></div></div><br><br>  Program output: Timmi Cartman, Jake Peter, Tom Jim, Jim Tom.  Compare how much code you would have to write in an imperative programming language. <br>  Now let's look at something more complicated than Hello World-based programs and talk about the prologue pitfalls. <br><br><h4>  <u><b>Riddle 3.</b></u> There are 8 queens on the chessboard.  No queen beats another queen.  Find the location of queens. </h4><br><br>  First we describe how the queen can walk: <br><br>  attack (X1, Y1, X2, Y2): - X2 = X1.  % queen can attack if the attacked cell and the source on the same vertical <br>  attack (X1, Y1, X2, Y2): - Y2 = Y1.  % queen can attack if the attacked cell and the source on the same horizontal <br>  attack (X1, Y1, X2, Y2): - abs (X2 - X1, Abs), abs (Y2 - Y1, Abs).  % ... on one diagonal <br><br>  Now let us indicate in which cases the queen cannot beat another queen: <br><br>  any (0). <br>  any (1). <br>  any (2). <br>  any (3). <br>  any (4). <br>  any (5). <br>  any (6). <br>  any (7). <br>  dontAttack (X1, Y1, X2, Y2): - <br>  any (X1), any (Y1), any (X2), any (Y2), not (attack (X1, Y1, X2, Y2)). <br><br>  This raises the question of why the enumeration of all possible coordinates of the queen (any) is necessary.  The point is that the prologue is designed in such a way that it cannot iterate through all possible numeric or string values.  All possible values ‚Äã‚Äãof the value for which the question is asked should be either listed in the code (such as the characters in the example about finding characters), or directly calculated based on the input data in the question (such as the result of the formula in the example about finding characters if the formula does not include rounding errors).  Of course, such a restriction makes the prologue not the most convenient language for solving equations;  however, this was never the main purpose of this language. <br><br>  So, we have described what ‚Äúone queen does not beat another queen‚Äù, now you need to specify that each of the 8 queens does not beat the other 7 queens, but writing 8 * 7 = 56 rules is exhausting, therefore we will describe this rule recursively.  We define an empty array and we will iteratively add one queen to it one by one. <br><br>  dontAttack ([]). <br><br>  (if there are no queens, then no queen beats any other) <br><br>  dontAttack (X, Y, []): - any (X), any (Y). <br><br>  (if there is one single queen, then he does not beat other queens) <br><br>  dontAttack (X1, Y1, [X2, Y2 | OtherElements]): - <br>  dontAttack ([X2, Y2 | OtherElements]), dontAttack (X1, Y1, X2, Y2), dontAttack (X1, Y1, OtherElements). <br><br>  (if there is a queen with X1 and Y1 coordinates and an array of queens, then none of the queen beats the other, if 1) inside the array of queens none of the queen beats the other 2) queen (X1, Y1) beats the first queen from an array of queens 3) if you remove the first queen from an array of queens, then none of the queens in the received set of queens beat another either) <br><br>  dontAttack ([X1, Y1 | OtherElements]): - <br>  dontAttack (X1, Y1, OtherElements). <br><br>  (if there is a queen with X1 and Y1 coordinates and an array of queens, and no queen beats the other, then if you add a queen to an array of queens, then no queen will still beat the other) <br><br>  Now it remains to ask a question about the coordinates of these queens.  However, in order not to get many identical answers, differing only in the number of queens, let's say that the first queen is in the first column, the second - in the second, and so on: <br><br>  askMainQuestion (): - <br>  X1 = 0, X2 = 1, X3 = 2, X4 = 3, X5 = 4, X6 = 5, X7 = 6, X8 = 7, <br>  dontAttack ([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X5, Y5, X6, Y6, X7, Y7, X8, Y8]), <br>  stdio :: write (X1, ":", Y1, "-", X2, ":", Y2, "-", X3, ":", Y3, "-", X4, ":", Y4, " - ", X5,": ", Y5," - ", X6,": ", Y6," - ", X7,": ", Y7," - ", X8,": ", Y8), <br>  stdio :: nl,% new line <br>  fail. <br><br>  Starting the program and in the same second we get all possible arrangements of queens on the chessboard. <br><br><div class="spoiler">  <b class="spoiler_title">View full program code</b> <div class="spoiler_text">  implement main <br>  open core <br><br>  class predicates <br>  askMainQuestion :() procedure. <br>  dontAttack: (integer, integer, integer, integer) nondeterm anyflow. <br>  attack: (integer, integer, integer, integer) nondeterm (i, i, i, i).  % nondeterm anyflow. <br>  any: (integer) multi (o) determ (i). <br>  dontAttack: (integer, integer, integer *) nondeterm anyflow. <br>  dontAttack: (integer *) nondeterm anyflow. <br>  abs: (integer, integer) nondeterm (i, o) nondeterm (i, i). <br>  clauses <br><br>  any (0). <br>  any (1). <br>  any (2). <br>  any (3). <br>  any (4). <br>  any (5). <br>  any (6). <br>  any (7). <br><br>  attack (X1, Y1, X2, Y2): - X2 = X1. <br>  attack (X1, Y1, X2, Y2): - Y2 = Y1. <br>  attack (X1, Y1, X2, Y2): - abs (X2 - X1, Abs), abs (Y2 - Y1, Abs). <br><br>  dontAttack (X1, Y1, X2, Y2): - <br>  any (X1), any (Y1), any (X2), any (Y2), not (attack (X1, Y1, X2, Y2)). <br><br>  dontAttack (X1, Y1, [X2, Y2 | OtherElements]): - <br>  dontAttack ([X2, Y2 | OtherElements]), dontAttack (X1, Y1, X2, Y2), dontAttack (X1, Y1, OtherElements). <br><br>  dontAttack (X, Y, []): - any (X), any (Y).  % Boundary condition <br><br>  dontAttack ([X1, Y1 | OtherElements]): - <br>  dontAttack (X1, Y1, OtherElements). <br><br>  dontAttack ([]). <br><br>  askMainQuestion (): - <br>  X1 = 0, X2 = 1, X3 = 2, X4 = 3, X5 = 4, X6 = 5, X7 = 6, X8 = 7, <br>  dontAttack ([X1, Y1, X2, Y2, X3, Y3, X4, Y4, X5, Y5, X6, Y6, X7, Y7, X8, Y8]), <br>  stdio :: write (X1, ":", Y1, "-", X2, ":", Y2, "-", X3, ":", Y3, "-", X4, ":", Y4, " - ", X5,": ", Y5," - ", X6,": ", Y6," - ", X7,": ", Y7," - ", X8,": ", Y8), <br>  stdio :: nl,% new line <br>  fail. <br><br>  askMainQuestion (). <br><br>  abs (X, Result): - X&gt; = 0, Result = X. <br>  abs (X, Result): - X &lt;0, Result = -X. <br><br>  run (): - <br>  console :: init (), <br>  askMainQuestion (), <br>  _ = stdIO :: readchar (). <br><br>  end implement main <br><br>  goal <br>  mainExe :: run (main :: run). <br></div></div><br><h4>  Now let's ask the prologue to prove a simple <b>theorem.</b> </h4><br>  We prove that a subset of a group is a subgroup if and only if, for any elements of A and B from this subset, the result of the product of A and its inverse to B lies in this subset.  In order to prove that a subset is a subgroup, it is necessary to prove three points: 1) the neutral element lies in the subset 2) for each element of the subset its inverse element lies in the subset 3) the product of any two elements of the subset lies in the subset. <br><br>  Denote the neutral element as ‚ÄúE‚Äù and define the neutral element: <br><br>  operation (A, "E", A): - any (A). <br>  operation ("E", A, A): - any (A). <br><br>  An element is neutral, if, when multiplying any element by a neutral element, the original element is obtained.  (for example, in integers 1 is the neutral element). <br><br>  Add a couple of specific items. <br><br>  any ("E"). <br>  any ("M"). <br>  any ("A"). <br>  any ("B"). <br>  any ("notA"). <br>  any ("notB"). <br><br>  There were introduced some other elements, besides ‚ÄúE‚Äù, we will explain what these elements are, describing their properties: <br><br>  ofGroup ("M", "Set"). <br>  ofGroup ("A", "SubSet"). <br>  ofGroup ("B", "SubSet"). <br><br>  A and B are elements from a subset, M is an element from a set. <br><br>  obratni ("B", "notB"). <br>  obratni ("notB", "B"). <br>  obratni ("A", "notA"). <br>  obratni ("notA", "A"). <br>  obratni ("E", "E"). <br><br>  ‚ÄúNotA‚Äù - back to ‚ÄúA‚Äù, ‚ÄúnotB‚Äù - back to ‚ÄúB‚Äù <br><br>  Now we give the definition of the inverse element: <br><br>  operation (A, B, "E"): - obratni (A, B). <br>  operation (B, A, ‚ÄúE‚Äù): - obratni (A, B). <br><br>  And the opposite of B, if multiplying A by B results in a neutral element (for example, 2 * 0.5 = 1).  As you can see, A and B do not have quotes here, which means that there are not specific elements ‚ÄúA‚Äù and ‚ÄúB‚Äù, but any elements. <br><br>  Subset definition: <br><br>  ofGroup (X, "Set"): - ofGroup (X, "SubSet"). <br><br>  (an element belongs to a set if it belongs to a subset) <br><br>  Now we point out that for any elements of A and B from a subset, the result of the product of A and its inverse to B lies in this subset (by the condition of the theorem). <br><br>  ofGroup (C, "SubSet"): - obratni (B, NotB), operation (A, NotB, C), ofGroup (A, "SubSet"), ofGroup (B, "SubSet"), stdio :: write (C , "is from subset, because", A, "*", NotB, "=", C, "."), stdio :: nl. <br><br>  As you can see, here we added the output to the screen (stdio :: write), this is done to trace the actions of the prologue, to learn how the prologue used this rule to see the progress of the proof of the theorem. <br><br>  Now it remains to prove three points from the theorem. <br>  Ask a question about the neutral element ‚ÄúE‚Äù: <br><br>  firstQuestion (): - <br>  ofGroup ("E", "SubSet"), <br>  stdio :: write ("E is from subset"), <br>  ! .. <br>  firstQuestion (): - stdio :: write ("E is NOT from subset"). <br><br>  About the inverse element: <br><br>  secondQuestion (): - <br>  ofGroup ("notA", "SubSet"), <br>  stdio :: write ("notA is from subset"), <br>  ! .. <br>  secondQuestion (): - stdio :: write ("NotA is NOT from subset"). <br><br>  Here you might have a question: you need to prove that for any element of the subset, its inverse element belongs to the subset, but in the prologue question we indicated one single specific element - ‚ÄúnotA‚Äù.  In fact, since we did not impose any restrictions on the ‚ÄúnotA‚Äù element (except that it is the inverse element of an element belonging to a subset), then if we take any inverse element, then the same arguments will be true for it applied to "notA".  Mathematicians often use this technique in proving theorems.  This technique is especially important for Prolog, because it cannot iterate through all string and numeric values. <br><br>  Well, now we will ask a question about belonging to a subset of the result of the product of two elements from a subset: <br><br>  operation ("A", "B", "AB"). <br>  thirdQuestion (): - <br>  operation ("A", "B", AB), <br>  ofGroup (AB, "SubSet"), <br>  stdio :: write ("A * B is from subset"), <br>  ! .. <br>  thirdQuestion (): - stdio :: write ("A * B is NOT from subset"). <br><br>  We start ... And the program crashes, hanging, from stack overflow!  Let's see why this happened.  In fact, the prologue tries to find a solution by looking at the facts entered into it.  When searching for the answer to the main question, the prologue goes through all the facts, at least somehow connected with the question.  If it is not known whether a fact is true, he in turn goes through all the facts related to this fact.  And so, until it reaches unconditional facts, for example, obratni (‚ÄúA‚Äù, ‚ÄúnotA‚Äù) - ‚ÄúnotA‚Äù is inverse to ‚ÄúA‚Äù.  The question was asked: does the neutral element belong to the subset?  The prologue sees the rule ofGroup (C, "SubSet"): - obratni (B, NotB), operation (A, NotB, C), ofGroup (A, "SubSet"), ofGroup (B, "SubSet") and understands that if we substitute a neutral element for C and find A and B that satisfy the rule, then according to the rule the neutral element will belong to a subset.  The first element among the existing ones is the reverse one (any (‚ÄúE‚Äù)), so Prolog chooses it as B. So, obratni (‚ÄúE‚Äù, NotB).  After this, Prolog asks the question: which element is inverse to ‚ÄúE‚Äù?  - and finds the answer (obratni ("E", "E")).  So, NotB = "E".  After this, Prolog goes further according to the rule and sees the operation (A, NotB, C), in this case the operation (A, "E", "E") and asks the question: what element when multiplied by "E" gives "E" - and finds the answer ‚ÄúE‚Äù (from the rule of operation (A, ‚ÄúE‚Äù, ‚ÄúE‚Äù): - obratni (A, ‚ÄúE‚Äù) and the fact obratni (‚ÄúE‚Äù, ‚ÄúE‚Äù).).  So, A = ‚ÄúE‚Äù. We follow the source rule further: ofGroup (A, ‚ÄúSubSet‚Äù), in this case ofGroup (‚ÄúE‚Äù, ‚ÄúSubSet‚Äù).  And here Prolog tries to answer the same question that we asked at the beginning - but does ‚ÄúE‚Äù belong to ‚ÄúSubSet‚Äù (neutral to a subgroup)?  The program loops and begins again to sort through the same facts and rules, walking in a vicious circle.  Well, let's rewrite the original rule: <br><br>  ofGroup (C, "SubSet"): - obratni (B, NotB), NotB &lt;&gt; "E", NotB &lt;&gt; "M", operation (A, NotB, C), ofGroup (A, "SubSet"), ofGroup (B, "SubSet"), stdio :: write (C, "is from subset, because", A, "*", NotB, "=", C, "."), Stdio :: nl. <br><br>  Now, you cannot use ‚ÄúE‚Äù and ‚ÄúM‚Äù as NotB, and the program will not hang (yes, and it also hangs on ‚ÄúM‚Äù). <br>  After that, the program at the same second gives proof of the three points of the theorem: <br><br>  E is from subset, because B * notB = E. <br>  E is from subset <br>  (A and B are in a subset, so the product of A and the inverse of B lies in a subset. In this case, the same element "B" is used instead of A and B. The proof can be made more detailed by adding more write commands to the rules ) <br><br>  E is from subset, because B * notB = E. <br>  notA is from subset, because E * notA = notA. <br>  notA is from subset <br><br>  E is from subset, because B * notB = E. <br>  notB is from subset, because E * notB = notB. <br>  AB is from subset, because A * B = AB. <br>  A * B is from subset <br><br><div class="spoiler">  <b class="spoiler_title">View full program code</b> <div class="spoiler_text">  implement main <br>  open core <br><br>  domains <br>  any = string. <br>  group = string. <br>  class predicates <br>  firstQuestion :() procedure. <br>  secondQuestion :() procedure. <br>  thirdQuestion :() procedure. <br>  operation: (any, any, any) nondeterm (i, i, i) nondeterm (o, i, i) nondeterm (i, i, o) nondeterm (o, o, i) nondeterm (o, o, o) nondeterm (i, o, i) nondeterm (i, o, o) nondeterm (o, i, o). <br>  obratni: (any, any) nondeterm (i, i) nondeterm (o, i) nondeterm (o, o) nondeterm (i, o). <br>  ofGroup: (any, group) nondeterm (i, i) nondeterm (o, i) nondeterm (i, o). <br>  any: (string) nondeterm (i) nondeterm (o). <br>  clauses <br><br>  operation (A, B, "E"): - obratni (A, B). <br>  operation (B, A, ‚ÄúE‚Äù): - obratni (A, B). <br>  operation (A, "E", A): - any (A). <br>  operation ("E", A, A): - any (A).  % commutativity with respect to neutral and inverse is a consequence of associativity, but is not included in the minimum definition of a group <br>  operation ("A", "B", "AB").  % multiplication of A by B is possible <br><br>  obratni ("M", "notM"). <br>  obratni ("notM", "M"). <br>  obratni ("B", "notB"). <br>  obratni ("notB", "B"). <br>  obratni ("A", "notA"). <br>  obratni ("notA", "A"). <br>  obratni ("E", "E"). <br><br>  any ("E"). <br>  any ("M"). <br>  any ("A"). <br>  any ("B"). <br>  any ("notA"). <br>  any ("notB"). <br>  any ("notM"). <br><br>  ofGroup (X, "Set"): - ofGroup (X, "SubSet").  % Subset definition <br>  ofGroup ("E", "Set"). <br>  ofGroup ("M", "Set"). <br>  ofGroup ("A", "SubSet"). <br>  ofGroup ("B", "SubSet"). <br>  ofGroup ("notB", "Set"). <br>  ofGroup ("notA", "Set"). <br><br>  ofGroup (C, "SubSet"): - obratni (B, NotB), NotB &lt;&gt; "E", NotB &lt;&gt; "M", operation (A, NotB, C), ofGroup (A, "SubSet"), ofGroup (B, "SubSet"), stdio :: write (C, "is from subset, because", A, "*", NotB, "=", C, "."), Stdio :: nl.  % a (-b) u Set <br><br>  firstQuestion (): - <br>  ofGroup ("E", "SubSet"), <br>  stdio :: write ("E is from subset"), <br>  ! .. <br><br>  firstQuestion (): - stdio :: write ("E is NOT from subset"). <br><br>  secondQuestion (): - <br>  ofGroup ("notA", "SubSet"), <br>  stdio :: write ("notA is from subset"), <br>  ! .. <br><br>  secondQuestion (): - stdio :: write ("NotA is NOT from subset"). <br><br>  thirdQuestion (): - <br>  operation ("A", "B", AB), <br>  ofGroup (AB, "SubSet"), <br>  stdio :: write ("A * B is from subset"), <br>  ! .. <br><br>  thirdQuestion (): - stdio :: write ("A * B is NOT from subset"). <br><br>  run (): - <br>  console :: init (), <br>  firstQuestion (), <br>  stdio :: nl, stdio :: nl, stdio :: nl, <br>  secondQuestion () <br>  stdio :: nl, stdio :: nl, stdio :: nl, <br>  thirdQuestion (), <br>  _ = stdIO :: readchar (). <br><br>  end implement main <br><br>  goal <br>  mainExe :: run (main :: run). <br></div></div><br><br><h4>  Conclusion </h4><br>  Prolog is a wonderful declarative language, but the constant hanging does not do him honor (if anyone knows how to deal with this, please share in the comments).  In fact, the task of searching for cycles in graphs has been solved a long time ago, and the elimination of a problem at the language level is a completely solvable problem!  If this problem were solved, it would be possible to compile a knowledge base of all known mathematical facts, and ask any questions!  Or, for example, change one of the basic axioms of mathematics and instantly find out how other laws will change (a la <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B5%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%258F_%25D0%259B%25D0%25BE%25D0%25B1%25D0%25B0%25D1%2587%25D0%25B5%25D0%25B2%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B3%25D0%25BE">Lobachevsky's geometry</a> in the blink of an eye)!  Of course, I am somewhat optimistic, and the language needs a little more refinement, but still ... For example, one of the possible improvements: Prolog should be able not only to get out of the loop, but also to be able to handle the looping according to certain rules in order to operate with endless sequences satisfying condition of the theorem, such as in the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%2591%25D0%25BE%25D0%25BB%25D1%258C%25D1%2586%25D0%25B0%25D0%25BD%25D0%25BE_%25E2%2580%2594_%25D0%2592%25D0%25B5%25D0%25B9%25D0%25B5%25D1%2580%25D1%2588%25D1%2582%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B0">Bolzano-Weierstrass theorem</a> .  However, in the current state, Prolog is vryat suitable for anything at all: it took me even longer to search for the causes of loops than to prove the theorem itself!  (IMHO, just my opinion) </div><p>Source: <a href="https://habr.com/ru/post/254133/">https://habr.com/ru/post/254133/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254121/index.html">Great review testing of programming languages</a></li>
<li><a href="../254123/index.html">Why bash script or carriage return did not work</a></li>
<li><a href="../254127/index.html">The Legend of Temptation: How to use Python to automate iOS</a></li>
<li><a href="../254129/index.html">I will calculate you over the networks: use the API of the largest social networks for my own selfish purposes</a></li>
<li><a href="../254131/index.html">Dedovskoye UX design: coder - pest</a></li>
<li><a href="../254137/index.html">How is the IT reception in Mail.Ru Group</a></li>
<li><a href="../254141/index.html">Private, financial and other non-public information of Fl.ru users is still in free access.</a></li>
<li><a href="../254143/index.html">IT rounded shapes as a factor</a></li>
<li><a href="../254145/index.html">Washington Post: Sit on Facebook all day? Be careful: your boss can keep an eye on you</a></li>
<li><a href="../254149/index.html">Android for developers. Perplexed and upset</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>