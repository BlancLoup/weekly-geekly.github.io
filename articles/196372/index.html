<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features of embedding in key mechanisms of Linux kernel using LSM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The embedding into a software system is understood as the process of introducing into it additional (third-party) program elements carried out in such...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features of embedding in key mechanisms of Linux kernel using LSM</h1><div class="post__text post__text-html js-mediator-article">  The embedding into a software system is understood as the process of introducing into it additional (third-party) program elements carried out in such a way that, on the one hand, its functioning is preserved, and on the other, its functionality is expanded or changed. <br><br>  Among the ways of embedding into the Linux kernel, it is worth noting a method based on the use of the Linux Security Modules framework (hereinafter referred to as LSM), designed to integrate various security models that serve to extend the basic Linux discretionary security model (DAC). <br><a name="habracut"></a><br><h4>  About LSM implementation in the Linux kernel </h4><br>  The features of the LSM implementation, which will be discussed later, allow using this subsystem to be embedded in key mechanisms of the Linux kernel.  At the same time, it is necessary to keep in mind that the main purpose of LSM is to provide the user with a unified extension interface for the current Linux security model and, therefore, has associated limitations. <br><br>  The LSM subsystem architecture is notable for its simplicity.  Technically, it is a set of hooks installed in the OS kernel that provide an interface for implementing your own handlers that are called by the system during various operations.  The basic security model description structure is the <code>security_operations</code> structure, which can be found in the <a href="">include / linux / security.h</a> file: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">security_operations</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> name[SECURITY_NAME_MAX + <span class="hljs-number"><span class="hljs-number">1</span></span>]; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inode_permission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode * inode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span></span>; ... }</code> </pre><br><br>  As you can see, the security model is described by the following parameters: the name and set of pointers to handler functions, the essence of which constitutes the main feature of the security model implemented - whether it is a mandatory, role-playing or other model.  The main thing here is the availability of interception control in the course of executing those parts of the kernel code that are responsible for the implementation of subjects access to objects. <br><br>  Being placed in key locations of the system, LSM-hooks are specially designed calls to a particular function of the current security model, while leaving the possibility of its change.  Technically, this is implemented by introducing an additional entity ‚Äî a pointer to the current active security model of <a href="">security_ops</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">security_o</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">perations</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">security_ops</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">security_o</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">perations</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_security_ops</span></span></span><span class="hljs-class"> = {</span></span> . name = <span class="hljs-string"><span class="hljs-string">"default"</span></span>, };</code> </pre><br><br>  The initial value of this pointer at system startup corresponds to the standard security model described by the <a href="">default_security_ops</a> structure and includes the implementation of the system default behavior.  At the same time, the content of handler functions is minimal.  However, if during the operation of the system it becomes necessary to activate another model, then this can be done by simply replacing the contents of this pointer.  Below is an example of using <code>security_ops</code> in the corresponding <a href="">hook</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">security_inode_permission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(IS_PRIVATE(inode))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> security_ops-&gt;inode_permission(inode, mask); }</code> </pre><br><br>  As you can see, the <code>inode_permission</code> handler <code>inode_permission</code> is <code>inode_permission</code> indirectly using the value of the <code>security_ops</code> pointer, which corresponds to what was said.  A good example would be the illustration of the implementation of access control using the example of <a href="">inode_permission</a> , a key function of the virtual file system (VFS) of the kernel that controls the access of the current process (subject) to the file system object: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inode_permission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct inode *inode, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval; retval = sb_permission(inode-&gt;i_sb, inode, mask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retval) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> __inode_permission(inode, mask); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __inode_permission(struct inode *inode, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mask) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> retval; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(mask &amp; MAY_WRITE)) { <span class="hljs-comment"><span class="hljs-comment">/* * Nobody gets write access to an immutable file. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IS_IMMUTABLE(inode)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -EACCES; } retval = do_inode_permission(inode, mask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retval) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; retval = devcgroup_inode_permission(inode, mask); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (retval) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> security_inode_permission(inode, mask); }</code> </pre><br><br>  LSM-hook <code>security_inode_permission</code> terminates a function and is the last frontier at the stage of verifying the accessibility of a process (subject) to the file (object) represented by the <code>inode</code> structure of the file system.  Thus, it will only work if all the previous checks pass successfully, which corresponds to the LSM concept, in which the security module does not replace the basic system model, but only complements and expands it. <br><br>  Summing up the brief description of LSM, it is worthwhile to separately dwell on interesting statistics reflecting the dynamics of the development of this framework in different periods of time.  Information gathered specifically for this purpose is presented in a graph reflecting the total number of LSM hooks, depending on the kernel version: <br><br><img src="https://habrastorage.org/storage3/d82/dd6/387/d82dd63873186daf095c4a3d6c1af5f0.png"><br><br>  First, their number attracts attention.  Indeed, if the kernel version <code>v2.6.11</code> accounted for 134 hooks, then the kernel version 3.8 accounted for 189, which is an indicator of the degree of LSM integration into the kernel.  Secondly, the dynamics of changes in the number of hooks indicates the rapid development of LSM to version <code>v2.6.34</code> and some stabilization after, which is an indicator of the subsystem maturity, its relative completeness and architectural stability. <br><br><h4>  About embedding using LSM </h4><br>  As a means of extending the underlying security model of the Linux kernel, LSM is not an integral component of it.  The presence of this framework in the core is determined by the state of the <code>CONFIG_SECURITY</code> configuration variable and is set at the compilation stage.  In practice, this means that the core of the target system can be assembled without LSM.  However, in other cases, the use of this possibility for embedding seems to be sufficiently practical, but it has its own characteristics, primarily related to the architecture of LSM itself.  Indeed, embedding capabilities are determined by the completeness of the LSM-hooks of the kernel code.  In other words, <i>it is possible to be built in only in those places in which it is provided</i> . <br><br>  In accordance with the architecture, the key Linux kernel object that provides the LSM mechanism is the <code>security_ops</code> pointer, which is a kernel memory cell that stores the address of the descriptor structure of the current (active) LSM model.  At the same time, due to the fact that all operations associated with accessing the model are carried out through this pointer, it can be argued that for embedding it is necessary and sufficient to have the ability to control this value. <br><br>  Speaking about the implementation of the LSM model by the kernel module, it is worth noting that there are features associated with the phased introduction of restrictions on LSM into the Linux kernel.  Thus, for security reasons, the interfaces were sequentially excluded from the kernel, allowing the current security model to be replaced during the operation of the system, namely: <br><br><ul><li>  From version <code>v2.6.24</code> , <code>security_ops</code> not exported and is marked as <code>static</code> (see commit <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/%3Fid%3D189b3b1c89761054fee3438f063d7f257306e2d8">189b3b1c89761054fee3438f063d7f257306e2d8</a> ); </li><li>  Since version v2.6.35, the register_security function is not exported and marked as <code>__init</code> , which means unloading the memory area containing its code after execution (see commit <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/%3Fid%3Dc1e992b99603a84d7debb188542b64f2d9232c07">c1e992b99603a84d7debb188542b64f2d9232c07</a> ); </li></ul><br><br>  These features are designed to limit the scope of LSM for embedding, however, it is worth noting that in fact they are not critical and there is a way to circumvent them, which will be discussed later. <br><br><h4>  Practical aspects of embedding </h4><br>  It was noted above that, starting with the <code>v2.6.34</code> kernel, <code>v2.6.34</code> no regular possibility of changing the current security model during the system operation.  However, this circumstance can be overcome if a way to determine the address of the current model pointer is found - <code>security_ops</code> .  One of the simple and reliable ways to determine it is disassembling the kernel code, namely, one of the functions where this pointer is used.  Indeed, it is worth considering as an example the listing of the <a href="">security_sb_copy_data</a> export function hook, obtained for a 64-bit x86 system using the <code>gdb</code> debugger: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">security_sb_copy_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *copy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> security_ops-&gt;sb_copy_data(orig, copy); } EXPORT_SYMBOL(security_sb_copy_data);</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># gdb vmlinux /proc/kcore (gdb) x/7i security_sb_copy_data 0xffffffff811f61b0: push %rbp 0xffffffff811f61b1: mov %rsp,%rbp 0xffffffff811f61b4: data32 data32 data32 xchg %ax,%ax 0xffffffff811f61b9: mov 0x881690(%rip),%rax # 0xffffffff81a77850 0xffffffff811f61c0: callq *0x98(%rax) 0xffffffff811f61c6: pop %rbp 0xffffffff811f61c7: retq (gdb) x/s* 0xffffffff81a77850 0xffffffff81850fa0: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"default"</span></span></span></span></code> </pre><br><br>  As you can see, the dispatching instruction <code>callq *0x98(%rax)</code> calls the handler function <code>sb_copy_data</code> at offset <code>0x98</code> , relative to the pointer stored in <code>%rax</code> .  Namely <code>%rax</code> and contains <code>security_ops</code> .  Thus, in order to obtain this pointer, it is necessary, sequentially, instruction by instruction, to scan commands from the beginning of this function until finding the command <code>mov 0x881690(%rip),%rax</code> , loading the desired value into <code>%rax</code> and, having performed a simple analysis of its operands , get the required pointer.  Below is the code that allows this for x86 using the <a href="http://udis86.sourceforge.net/">udis86</a> disassembler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_lsm_entry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* this one is exported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)&amp;security_sb_copy_data; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> struct security_operations ** </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_lsm_sop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ud_t</span></span> ud; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * entry = get_lsm_entry(), * result = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; ud_initialize(&amp;ud, BITS_PER_LONG, UD_VENDOR_ANY, entry, <span class="hljs-number"><span class="hljs-number">128</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ud_disassemble(&amp;ud) &amp;&amp; ud.mnemonic != UD_Iret) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ud.mnemonic == UD_Imov &amp;&amp; \ ud.operand[<span class="hljs-number"><span class="hljs-number">0</span></span>].type == UD_OP_REG &amp;&amp; ud.operand[<span class="hljs-number"><span class="hljs-number">1</span></span>].type == UD_OP_MEM) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_X86_64 result = entry + ud_insn_off(&amp;ud) + ud_insn_len(&amp;ud); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> result = result + ud.operand[1].lval.sdword; break; } } return result; }</span></span></code> </pre><br><br>  Thus, having received a pointer to the <code>security_ops</code> pointer, you can replace the active security model with your own implementation by simply replacing the value of this pointer.  As an example, I cite the code for the <a href="https://github.com/milabs/kmod_fakelsm">fakelsm</a> project, which replaces the <code>inode_permission</code> function. <br><br><h4>  Conclusion </h4><br>  In conclusion, the following should be said.  Despite the consistently introduced limitations of using LSM outside the kernel, this framework is of interest because  provides great opportunities for embedding in the core.  It should be understood, however, that its capabilities are limited by the extent to which the kernel code is covered by LSM hooks.  And although there are a huge amount of such kernels of modern ones, these limitations are obvious. <br><br>  In addition, the fact that the concept of the LSM architecture, being simple and effective, is not secure is important, since  in fact, the entire extended kernel security model is based on one single pointer ‚Äî <code>security_ops</code> ! <br><br><h4>  On read </h4><br><ol><li>  <a href="http://en.wikipedia.org/wiki/Linux_Security_Modules">Linux security modules</a> </li><li>  <a href="http://udis86.sourceforge.net/manual/">udis86's documentation</a> </li><li>  Criticism LSM from <a href="http://grsecurity.net/lsm.php">grsecurity</a> and <a href="http://www.rsbac.org/documentation/why_rsbac_does_not_use_lsm">RSBAC</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/196372/">https://habr.com/ru/post/196372/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../196362/index.html">AlfabankAPI to work with Alpha Client On-line</a></li>
<li><a href="../196364/index.html">The number of false positive positives of the Bloom filter [translation]</a></li>
<li><a href="../196366/index.html">How I wanted to run away from Admob. Story about advertising networks</a></li>
<li><a href="../196368/index.html">jQuery.BEM - a declarative approach to working with the imposition of the BEM method</a></li>
<li><a href="../196370/index.html">We write a simple analogue of the Yandex.Disk client under Linux (and Windows)</a></li>
<li><a href="../196374/index.html">Simple words about Fourier transform</a></li>
<li><a href="../196376/index.html">How to make a module 1C-Bitrix</a></li>
<li><a href="../196378/index.html">One Platform Foundation: AppDF and OpenIAB Overview</a></li>
<li><a href="../196380/index.html">Cline and creating an interactive command line application</a></li>
<li><a href="../196382/index.html">Some Python features you may not have known about</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>