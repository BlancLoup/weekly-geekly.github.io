<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IPP functions with border support for multi-stream image processing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As a result of prolonged use of even the best software products, one or another of their shortcomings is gradually revealed. Not an exception, and the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IPP functions with border support for multi-stream image processing</h1><div class="post__text post__text-html js-mediator-article">  As a result of prolonged use of even the best software products, one or another of their shortcomings is gradually revealed.  Not an exception, and the <a href="https://software.intel.com/en-us/intel-ipp">Intel Performance Primitives</a> Library <a href="https://software.intel.com/en-us/intel-ipp">(IPP).</a>  By the time of release of version 8.0, some problems emerged, some of which relate to the functions of processing two-dimensional images. <br>  To solve them, in IPP 8.0, many image processing functions are reduced to a common template, which allows to process images in blocks ( <i>tiles</i> ) and, therefore, effectively parallelize at the application level code containing calls to IPP functions.  The new API of the corresponding IPP functions supports several types of borders, does not use the internal allocation of dynamic memory, allows you to divide images into fragments of arbitrary size and process these fragments independently;  simplifies use and improves the performance of a number of functions.  This article details the new API and provides examples of its use. <br><a name="habracut"></a><br><h1>  1 Reasons for switching to a new API </h1><br>  As mentioned above, the IPP development team did a lot of work on changing the interface of two-dimensional functions and bringing it to a single standard ‚ÄúAPI with curb support‚Äù (‚Äúnew API‚Äù).  What for?  To answer this question, let's describe the problems that were present in previous versions. <br><br><h2>  1.1 Problems of the effectiveness of using OpenMP in IPP </h2><br>  So the first problem is how to use IPP in multi-threaded applications.  Sometimes the problem of parallel image processing is more effectively solved at the top level, i.e.  at the application level.  In this case, the application itself breaks the image into blocks and creates threads for their parallel processing.  The multi-threaded version of IPP uses OpenMP with nested parallelism disabled (in English <i>nested threading</i> ).  If an application uses another tool for multithreading or even OpenMP, but a different version, then when calling an IPP function from such an application, several threads will be created in turn, as shown in Fig.  one. <br><br><img src="https://habrastorage.org/files/d06/65d/a27/d0665da27bb24a8b81fcc424723c1a64.jpg" width="50%" height="50%"><br>  <i>Figure 1. Two-level parallelism (nested threading)</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Such a two-level parallelization instead of the desired acceleration can lead to a decrease in performance (in English <i>oversubscription</i> ), which can be explained by the fact that various parallelization tools work simultaneously and fight for queue resources, semaphores, physical flows, push competing threads from the cache, and t .P. <br>  The user's application, in contrast to IPP, has information on how the resulting image will be processed further, and can form parallel blocks so that the data remaining in the cache is used after the previous processing stage, and not read from memory (in English <i>cache locality</i> ).  Let us explain in more detail what is meant.  IPP is mostly used in client machines - desktops, laptops, the topology of which in the general case is as follows Fig.2 <br><br><img src="https://habrastorage.org/files/a83/8aa/b22/a838aab22a804998b279c7e8a0daaa6a.png" width="50%" height="50%"><br>  <i>Fig.</i>  <i>2: Modern HW topology, HW threads numeration</i> <br><br>  IPP is also used in the HPC segment, and it is assumed that HPC systems differ from client systems only in the number of X processors.  The numbering of flows in the figure is conditional and you can find out the physical number of the flow through the identifier belonging to it APIC (in English <i>Advanced Programmable Interrupt Controller</i> ), which is unique for each flow.  The correspondence between the logical and the physical thread number is assigned by the operating system or the parallelization tool used.  If you run an intensive computing task in the Windows system and watch it in the task manager, then you will notice that the system sometimes switches it from one core to another.  Therefore, there is no guarantee that the flow will be executed on the same core in two consecutive parallel regions.  To indicate the correspondence between a thread with a certain logical number and a physical one (in English <i>HW thread</i> from the word <i>hardware</i> ) there is a special term - affinity.  When affinity is installed, the operating system will start a logical stream in consecutive parallel regions on the same HW stream.  In the ideal case, a completely ‚Äúclean‚Äù system specifying affinity could help solve performance problems related to the fact that logical flows are switching from one HW flow to another.  However, in a real modern system hundreds and possibly thousands of processes are performed.  At any time, each such process can be taken out of sleep and started on some HW thread. <br><br>  Suppose that in some application the calculation volume for each stream was carefully calculated, and at the same time, in accordance with the established affinity, each application thread was launched on the corresponding HW stream.  In the picture - in green. <br><br><img src="https://habrastorage.org/files/a8e/965/2bb/a8e9652bbd424c47a97f077e20426b41.jpg" width="60%" height="60%"><br><br>  After some time, the operating system may start another process, for example, on HW stream # 3, which is shown in red.  Since all threads of the first application are tightly bound to HW threads, thread # 3 will wait for resources to be released by another process, and the operating system will not be able to switch it from HW thread # 3, although threads # 0-2 may already be completed and will be idle.  We consider the ideal situation, and we see that in the first case of a fixed affinity, 9 conventional units of time will be spent, and in the case where affinity is not specified, 7 units will be indicated.  So, in the end, such a fixed affinity installation leads to the fact that in some cases, the performance will be high, while in others it will be very bad. <br>  Now consider what problems may arise when affinity, on the contrary, is not installed, and the operating system can redistribute threads at its discretion.  Take a simple example that implements the Sobel filter.  It consists of several successive stages, each of which can be parallelized: <br>  Apply a Sobel vertical filter to the original image and get a temporary image A (ippiFilterSobelVertBorder_8u16s_C1R) <br>  Apply a horizontal Sobel filter to the original image and get a temporary image B (ippiFilterSobelHorizBorder_8u16s_C1R) <br>  Calculate the square of each element A and save the result again in A (ippiSqr_16s_C1IRSfs) <br>  Calculate the square of each element B and save the result again in B (ippiSqr_16s_C1IRSfs) <br>  We get the sum of images A and B, we can save the result again in A (ippiAdd_16s_C1IRSfs) <br>  The last stage is the square root of A (ippiSqrt_16u_C1IRSfs) and conversion to 8u (ippiConvert_16s8u_C1R) <br><br><img src="https://habrastorage.org/files/ae0/39b/f74/ae039bf7460a4acb96b5c01411fe46af.png" width="50%" height="50%"><br>  <i>Fig.</i>  <i>3 Stages of the implementation of the Sobel filter, which may have internal parallelization.</i> <br><br>  Each of the internal functions can be parallelized.  However, this approach seems to be inefficient, since there are 7 consecutive function calls, each of which has synchronization points for creating / terminating parallel regions.  The listed IPP functions use a simple blocking pattern in a parallel region. <br><br><img src="https://habrastorage.org/files/3ad/05b/fd9/3ad05bfd9957452f8e26837b17ceb1ee.jpg" width="50%" height="50%"><br>  <i>Fig.</i>  <i>4 Standard blocking method in IPP functions</i> <br><br>  Consider, for example, a sequential call ippiFilterSobelVertBorder_8u16s_C1R (src-&gt; A) and ippiSqr_16s_C1IRSfs (A-&gt; A2)).  First, the first parallel region (region # 1) is created for the ippiFilterSobelVertBorder_8u16s_C1R function, then the second (region # 2). <br><br><img src="https://habrastorage.org/files/bc0/f2a/3f8/bc0f2a3f8291414cbf55b3babd37c8ab.png" width="50%" height="50%"><br>  <i>Fig.</i>  <i>5 Distribution of logical flows by hw flows in two consecutive parallel regions.</i> <br><br>  The logical flow # 0 will be executed on the physical flow # 4 and therefore the portion of data of the SobelVert function will be stored in the L2 and L3 caches related to the physical flow # 4.  In the next parallel region # 2 created by the Sqr function, the image will be divided into blocks using the same pattern as in the first function, so the logical flow # 0 will wait for the data available in the cache.  However, the OS launched this logical stream # 0 on the physical # 3.  There will be no data in the cache and intensive data exchange between the caches of these threads will start, which will slow down the application execution time. <br><br>  Another problem was related to the fact that before the release of IPP version 8.0 gold, users had a situation that the application and library use the same version of OpenMP, but different linking models.  For example, the static version of IPP also used the OpenMP static library, and the user has a dynamic version in his application. In this case, OpenMP detects a conflict and issues a warning about possible performance degradation.  In IPP 8.0, only the dynamic version of OpenMP is now used, so after switching to this version of this kind, library users should no longer have problems. <br>  The result of the problems discussed above was that, despite the ubiquitous multi-core, functions with the new API have only the usual single-threaded implementation.  However, it takes into account the possibility of image processing in parallel.  However, for IPP functions that were already present in the IPP multithreaded OpenMP implementation was preserved. <br><br><h2>  1.2 Border problems in sequential image processing </h2><br>  The second problem of the previous version of the API appears when the image is sequentially processed by several filters.  It implies that all the necessary pixels along the edges of the region of interest (abbreviated ROI from the region of interest) are available in memory.  Therefore, to obtain an output image with a width of dstWidth and a height of dstHeight and a filter of size kernelWidth X kernelHeight, you must submit an input image of width dstWidth + kernelWidth-1 and height dstHeight + kernelHeight-1, fig.  6b) and 6c). <br><br><img src="https://habrastorage.org/files/3d5/511/886/3d5511886ab84f7c86781b31ecd4e8cb.jpg" width="50%" height="50%"><br>  Fig.6 The need for additional rows of pixels around the ROI for the sequential application of several filters in the old API. <br><br>  And if 2, .., N filters are applied in series, with the core sizes of kWidth1 X kHeight1, ..., kWidthN X kHeightN, then the size of the input image should be <br>  (dstWidth + kWidth1 + ... + kWidthN - N) X (dstHeight + kHeight1 + ... + kHeightN-N), fig.  6a).  In this example, in order to get a resulting image of 6x6 pixels in size, two filters of 5x5 and 3x3 are used.  The first image has a size of 6 + 5-1 + 3-1 X 6 + 5-1 + 3-1, i.e.  12 X 12 pixels, and the image obtained after the first filter is 8x8.  Applying the following 3x3 filter to it, we get the final image of 6x6.  In order to create image borders, you can use the ippiCopyReplicate (Mirror / Const) Border IPP functions, but this is very costly in terms of performance and the required additional memory for a new image with a border. <br>  The new API allows you to avoid calling such functions and provides a choice of three options for handling pixels outside of ROI ‚Äî to still consider them available in memory, substitute a fixed value for them, or use a copy of the pixels lying on the border of the image.  More details will be given below. <br><br><h2>  1.3 Direct order of filter coefficients and fixed anchor </h2><br>  In the previous version of the API of two-dimensional filters, the reverse order of the coefficients was used according to the formula <br><img src="https://habrastorage.org/files/b8d/2de/849/b8d2de849aa94650b0468d031a91f761.png" width="50%" height="50%"><br>  where <img src="https://habrastorage.org/files/46e/dd7/2a0/46edd72a0e5b4fe48c330f85033d65aa.png" width="5%" height="5%">  - kernel values <br><img src="https://habrastorage.org/files/028/099/09e/02809909e8274c33a7ba9681f56dab63.png" width="2%" height="2%">  , <img src="https://habrastorage.org/files/e3e/fd1/580/e3efd15804d649efb37a36defbb1de03.png" width="2%" height="2%">  - horizontal and vertical size of the core, <br><img src="https://habrastorage.org/files/c63/fd2/ca4/c63fd2ca429544dfb5c05b26e2e377e6.png" width="20%" height="20%">  , anchor.y anchor <i>Y</i> coordinate, <br><img src="https://habrastorage.org/files/cd2/28f/5a1/cd228f5a10164b7cb69a25d1276511a4.png" width="20%" height="20%">  , anchor.x is the <i>x</i> coordinate of the anchor. <br>  The term anchor means the position of a fixed cell inside the core, which is combined with the pixel currently being processed.  Thus, using an anchor, you can specify the location of the core relative to a pixel. <br>  In order to simplify the use of functions, the input filter coefficients are now used in direct order by the formula <br><img src="https://habrastorage.org/files/cb0/174/799/cb01747999b44742b69e94df88619963.png" width="40%" height="40%"><br><br><img src="https://habrastorage.org/files/250/f59/3f5/250f593f55e14f0fb7a4800ad35ffee0.png" width="20%" height="20%">  , <br><img src="https://habrastorage.org/files/c02/4ea/35b/c024ea35b5164edcb28efa1d55156a72.png" width="20%" height="20%">  . <br><br>  Fig.  6. demonstrates the differences between the inverse and direct order of using coefficients. <br><br><img src="https://habrastorage.org/files/c49/f81/198/c49f81198b8e4d2c8ba6f64e72f79680.png" width="30%" height="30%"><br>  <i>Fig.</i>  <i>6 Direct and inverse order of coefficients</i> <br><br>  Also in the new API, the concept of anchor (anchor) fig.7 was removed. <br>  It is now at a fixed position Q = anchor.x = (kernelWidth-1) / 2, P = anchor.y = (kernelHeight-1) / 2. <br><br><img src="https://habrastorage.org/files/c89/7f7/19b/c897f719be4349b6acd190b0ad5ba4d3.jpg" width="30%" height="30%"><br>  <i>Fig.</i>  <i>7. The fixed position of the anchor x = (kw-1) / 2, y = (kh-1) / 2</i> <br><br>  In principle, the anchor determines the offset in memory from the pointer to the ROI, so in the new API, in the case of a ‚Äúnon-standard‚Äù value of the anchor, it is enough to shift the ROI in the required direction, see Fig. 8, which shows the required for different values ‚Äã‚Äãof the anchor ROI shift in new API.  The same memory area is shown in gray, and the pointer to the ROI supplied to the function is shown in blue.  In the old it is unchanged, but in the new it moves. <br><br><img src="https://habrastorage.org/files/ccc/d78/398/cccd783985d44ce484b6ebac4a2d000f.jpg" width="40%" height="40%"><br>  <i>Fig.</i>  <i>8 ROI shift for ‚Äúnon-standard‚Äù armature value</i> <br><br>  For masks with an even width (height) when specifying the type of border that is in memory to the right (bottom) of the image, there should be one more rows of pixels available. <br><br><img src="https://habrastorage.org/files/85a/99a/93e/85a99a93e6b849c1b5018702f4a39eb7.png" width="20%" height="20%"><br>  <i>Fig.</i>  <i>9. For a mask with an even width (height), a row of pixels is required more to the right (bottom).</i> <br><br>  In addition to ease of use, the direct order allows you to reduce the overhead within the function associated with rearranging the coefficients.  Often, the coefficients of the kernel are symmetric and such transposing was unnecessary. <br><br><h2>  1.4 Lack of internal allocation of dynamic memory </h2><br>  Functions that have a new API do not use internal dynamic memory allocation using the malloc operation.  Since the allocation of such memory in any of the streams, all other streams are stopped.  The memory should now be allocated outside the processing functions, and the required size of the required buffers can be obtained using auxiliary functions of the ippiGetBufferSize type. <br><br><h1>  2 Operation of morphology of images by Erode / Dilate </h1><br>  The use of functions with the new API will be considered on the example of the operation morphology.  A detailed description of the properties of this operation can be found in the literature and on the Internet.  In general terms, the result of this operation is the minimum or maximum element within a certain neighborhood of a pixel.  In the first case, the operation is called Erode fig.11, in the second Dilate, fig.  12 <br><br><img src="https://habrastorage.org/files/823/383/784/8233837848c04c1cb8d7baec00073127.jpg" width="25%" height="25%"><br>  <i>Fig.</i>  <i>10 Original Image</i> <br><br><img src="https://habrastorage.org/files/c9b/586/6c6/c9b5866c6f8f473caa0f34a6ca35f1eb.jpg" width="25%" height="25%"><br>  <i>Fig.</i>  <i>11 Operation Erode</i> <br><br><img src="https://habrastorage.org/files/1a1/2f2/3a0/1a12f23a0bbc4fe0987fc8f7a67f7be1.jpg" width="25%" height="25%"><br>  <i>Fig.</i>  <i>12 Operation Dilate</i> <br><br>  At first glance, it seems that the name does not correspond to the result, however, everything is correct.  Since the Erode operation selects the minimum value, and black is formed with smaller values ‚Äã‚Äãthan white, the pixels adjacent to the letters are replaced with black and the effect of thickening of the letters appears.  In the case of the Dilate operation, on the contrary, the edges of the letters are replaced with white pixels and the letters become thinner. <br><br><h1>  3 General principles of the new API functions with border support </h1><br><br><h2>  3.1 Example code for morphology operation - Dilate </h2><br>  In order to get the result in Figure 12, you must use the following functions. <br><ul><li>  IppStatus <b>ippiMorphologyBorderGetSize_32f_C1R</b> (int roiWidth, IppiSize maskSize, int * pSpecSize, int * pBufferSize) </li><li>  IppStatus <b>ippiMorphologyBorderInit_32f_C1R</b> (int roiWidth, const Ipp8u * pMask, IppiSize maskSize, IppiMorphState * pMorphSpec, Ipp8u * pBuffer) </li><li>  IppStatus <b>ippiDilateBorder_32f_C1R</b> (const </li></ul><br>  The first function calculates the required size of buffers, the next initializes these buffers, and the third function performs image processing.  The code snippet using these functions is as follows. <br><br><div class="spoiler">  <b class="spoiler_title">Sheet.</b>  <b class="spoiler_title">1 standard function call sequence</b> <div class="spoiler_text"><pre><code class="hljs lisp">ippiMorphologyBorderGetSize_32f_C1R(<span class="hljs-name"><span class="hljs-name">roiSize</span></span>.width, maskSize, <span class="hljs-symbol"><span class="hljs-symbol">&amp;specSize</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;bufferSize</span></span>)<span class="hljs-comment"><span class="hljs-comment">; pMorphSpec = (IppiMorphState*)ippsMalloc_8u(specSize); pBuffer = (Ipp8u*)ippsMalloc_8u(bufferSize); ippiMorphologyBorderInit_32f_C1R(roiSize.width, pMask, maskSize, pMorphSpec, pBuffer); ippiDilateBorder_32f_C1R(pSrc, srcStep, pDst, dstStep, roiSize, border, borderValue, pMorphSpec, pBuffer);</span></span></code> </pre> <br></div></div><br><br>  And the whole code is given in the sheet.  2 <br><br><div class="spoiler">  <b class="spoiler_title">Sheet.</b>  <b class="spoiler_title">2 Image processing code</b> <div class="spoiler_text"><pre> <code class="hljs lua">#define WIDTH <span class="hljs-number"><span class="hljs-number">128</span></span> #define HEIGHT <span class="hljs-number"><span class="hljs-number">128</span></span> int morph_dilate_st() { IppiSize roiSize = { WIDTH, HEIGHT }; IppiSize maskSize = { <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; IppStatus <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>; int specSize = <span class="hljs-number"><span class="hljs-number">0</span></span>, bufferSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; IppiMorphState* pMorphSpec; Ipp8u* pBuffer; Ipp32f* pSrc; Ipp32f* pDst; int srcStep, dstStep; Ipp8u pMask[<span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }; IppiBorderType border = ippBorderRepl; int borderValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; int i, j; pSrc = ippiMalloc_32f_C1(WIDTH, HEIGHT, &amp;srcStep); pDst = ippiMalloc_32f_C1(WIDTH, HEIGHT, &amp;dstStep); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;HEIGHT; j++){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;WIDTH; i++){ pSrc[WIDTH*j + i] = rand();//make image } } <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = ippiMorphologyBorderGetSize_32f_C1R(roiSize.width, maskSize, &amp;specSize, &amp;bufferSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> != ippStsOk){ printf(<span class="hljs-string"><span class="hljs-string">"ippiMorphologyBorderGetSize_32f_C1R / %s\n"</span></span>, ippGetStatusString(<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } pMorphSpec = (IppiMorphState*)ippsMalloc_8u(specSize); pBuffer = (Ipp8u*)ippsMalloc_8u(bufferSize); <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = ippiMorphologyBorderInit_32f_C1R(roiSize.width, pMask, maskSize, pMorphSpec, pBuffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> != ippStsOk){ printf(<span class="hljs-string"><span class="hljs-string">"ippiMorphologyBorderInit_32f_C1R / %s\n"</span></span>, ippGetStatusString(<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>)); ippsFree(pMorphSpec); ippsFree(pBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = ippiDilateBorder_32f_C1R(pSrc, srcStep, pDst, dstStep, roiSize, border, borderValue, pMorphSpec, pBuffer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">status</span></span> != ippStsOk){ printf(<span class="hljs-string"><span class="hljs-string">"ippiMorphologyBorderGetSize_32f_C1R / %s\n"</span></span>, ippGetStatusString(<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>)); ippsFree(pMorphSpec); ippsFree(pBuffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } ippsFree(pMorphSpec); ippsFree(pBuffer); ippiFree(pSrc); ippiFree(pDst); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br></div></div><br><br><h2>  3.2 Common Border API Template </h2><br>  In this example, and in general, the call of all functions with the new API follows the following pattern. <br><br><img src="https://habrastorage.org/files/f40/390/000/f40390000da54441a6371739b70e598c.jpg" width="25%" height="25%"><br>  <i>Fig.</i>  <i>13 General pattern of calling IPP functions</i> <br><br><h2>  3.3 ippGetSize ‚Äî calculate buffer sizes </h2><br>  Functions that return the size of buffers contain a GetSize suffix in the name. <br>  IppStatus ippiMorphologyBorderGetSize_32f_C1R (int roiWidth, <br>  IppiSize (maskSize, int * pSpecSize, int * pBufferSize) <br>  Functions can have different input parameters characterizing the operation and the image, and return the size of the internal data structure used by pSpecSize (pStateSize) and the size used by the buffer function pBufferSize. <br>  Since the new API has eliminated the internal allocation of dynamic memory, it is necessary to use the means of the operating system malloc, new, etc. to allocate the required memory.  or use the IPP functions of ippMalloc / ippiMalloc, which are convenient in that they allocate memory and image strings at an address that is optimal for the architecture used.  On x86, in most cases, to increase performance, it is desirable that all arrays start at the 64-byte boundary.  These IPP functions allocate memory that is aligned exactly in this way.  And the ippiMalloc function also returns the step between the image lines such that the beginning of each line of the image will also be aligned. <br>  It is possible that the application will use several IPP functions in sequence.  In this case, you can select one maximum of all the largest buffer and submit it to all functions consistently, see fig.  below.  This approach will reduce the fragmentation of memory and, with high probability, the allocated buffer will be reused and, therefore, be in the cache. <br><br><img src="https://habrastorage.org/files/5b9/2e4/b1c/5b92e4b1c1f44f6688c7c0334365b45d.png" width="50%" height="50%"><br>  <i>Fig.</i>  <i>14 Using the maximum buffer size required reduces memory fragmentation and ‚Äúwarms up‚Äù the buffer.</i> <br><br><h2>  3.4 ippInit - initialization of the internal structure </h2><br>  The internal structures are initialized by the functions containing the Init suffix. <br>  IppStatus ippiMorphologyBorderInit_32f_C1R (int roiWidth, <br>  const Ipp8u * pMask, IppiSize maskSize, <br>  IppiMorphState * pMorphSpec, Ipp8u * pBuffer) <br>  The internal data structure contains coefficient tables, pointers and other pre-calculated data.  In IPP, the following rule is used: if the word Spec is used in the parameter name, then the contents of this structure are constant from the call to function call.  Therefore, it can be used simultaneously in multiple threads.  If the word State is used, this means some state, for example, a delay line in the filter and such a structure cannot be divided between streams.  The contents of the pBuffer can unambiguously change, so it is necessary to allocate a separate buffer for each stream. <br><br><h2>  3.5 ippFuncBorder - processing function </h2><br>  The directly processing functions of the new API contain the word Border in the title. <br>  IppStatus ippiDilateBorder_32f_C1R (const Ipp32f * pSrc, int srcStep, <br>  Ipp32f * pDst, int dstStep, IppiSize roiSize, <br>  IppiBorderType borderType, Ipp32f borderValue, <br>  const IppiMorphState * pMorphSpec, Ipp8u * pBuffer) <br><br><h2>  3.6 Supported Border Types </h2><br>  The new API uses three types of image borders. <br>  ippBorderInMem, ippBorderConst, ippBorderRepl, see fig.  15 <br><br><img src="https://habrastorage.org/files/94f/6c5/04a/94f6c504aeef485382d193a084e2cb53.jpg" width="50%" height="50%"><br>  <i>Figure 15. Three types of curb</i> <br><br>  In the first case, ippBorderInMem functions, the necessary pixels are available both inside the image and in memory.  The second, ippBorderConst, uses a fixed value for borderValue.  For multichannel images, an array of values ‚Äã‚Äãis used.  The formation of missing pixels in the case of ippBorderRepl is shown in fig.  15c).  The angular pixels of the image are duplicated in two external sides of the angle, and the remaining boundary pixels are only in the corresponding direction from the border. <br>  Modifiers with the following values ‚Äã‚Äãcan be applied to the specified types of borders. <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">ippBorderInMemTop</span></span> = 0x0010, ippBorderInMemBottom = 0x0020, ippBorderInMemLeft = 0x0040, ippBorderInMemRight = 0x0080</code> </pre><br>  These modifiers are designed to process images in blocks.  They are combined with the borderType parameter using the ‚Äú|‚Äù operation <br><br><h1>  4. Using API functions with support for borders for external parallelization of functions. </h1><br><br><h2>  4.1 Image splitting into blocks </h2><br>  The new API allows you to process images in multiple streams in blocks.  To properly connect the resulting individual image blocks into a single output image, you need to apply modifiers corresponding to the position of the block to the main type of border.  For example, if there are 16 streams and the ippBorderRepl border type is used, then the borderType value needs to be generated as follows.  sixteen <br><br><img src="https://habrastorage.org/files/e9c/6e3/b52/e9c6e3b525534bb5a6aa0cd9c14d7326.jpg" width="60%" height="60%"><br>  <i>Fig.</i>  <i>16 Image processing in 16 streams by blocks</i> <br><br>  Block number <b>0</b> is located in the upper left of the image.  Therefore, necessary for processing, but the missing pixels on the left and on the top of the block will be duplicated by the boundary ones, and the necessary pixels on the right and on the bottom of the block will be loaded from neighboring blocks <b>1</b> , <b>4</b> and <b>5</b> , in accordance with the ippBorderInMemRight | ippBorderInMemBottom modifiers.  Blocks <b>1</b> , <b>2</b> do not have pixels only from above, and on the other three sides and corners are surrounded by neighboring blocks in which the right pixels lie, therefore three ippBorderInMemBottom | ippBorderInMemRight | ippBorderInMemLeft modifiers are indicated.  For blocks <b>3,4,8,7, B, C, D, E, F</b> modifiers are set in the same way.  Blocks 5,6,9, and are inside the image and therefore you can specify all 4 modifiers for them, but it is easier to use a separate value of the ippBorderInMem border type.  Returning to block number <b>0</b> , the ippBorderInMemBottom | ippBorderInMemRight modifier combination allows the function to conclude that you need to use pixels from block number 5. And for block number <b>C,</b> pixels from block <b>D</b> will be duplicated in this area, but pixels on the right and on top will be used from block <b>9</b> .  All the logic of reading pixels from memory or duplicating pixels is structured in such a way that the result of image processing as a whole and in blocks completely coincides. <br>  Also, this approach assumes that when specifying the ippBorderInMem * modifier, the memory is actually available.  In some particular cases the following situation is possible, as in Figure 17 <br><br><img src="https://habrastorage.org/files/be3/4b6/cd3/be34b6cd35c34a4e8c887e12f25aec3d.jpg" width="15%" height="15%"><br>  <i>Fig.17 Going beyond the image boundary</i> <br><br>  If you divide an 1x2 image into two blocks one pixel at a time and use a 5x5 mask, then processing the left block and specifying the ippBorderInMemRight modifier for it as an ipBorderInMemRight modifier may cause the memory to go beyond the boundary with unpredictable consequences.  Therefore, when dividing an image into blocks and using the ippBorderInMem modifier, you should ensure that kernelWidth / 2 pixels are in memory in the right direction. <br><br><h2>  4.2 Splitting an image into stripes </h2><br>  Figure 16 depicts a general case of splitting an image into blocks for parallel processing and, generally speaking, the implementation of splitting into blocks may not be such a simple task and it is possible to more effectively divide an image not into blocks, but into bands, as shown in Figure 18 .  The Border API allows this blocking. <br><br><img src="https://habrastorage.org/files/97d/6d0/8bb/97d6d08bb0844ef09cbbcc122ce3ab29.jpg" width="25%" height="25%"><br>  <i>Fig.</i>  <i>18 Processing by strip.</i> <br><br><h2>  4.3 Sample code with a new API for processing in several OpenMP streams </h2><br>  Let's give an example of image processing in several streams.  For this we will use OpenMP. <br><div class="spoiler">  <b class="spoiler_title">Sheet.</b>  <b class="spoiler_title">3 Image processing code by block</b> <div class="spoiler_text"><pre> <code class="hljs mel">#define WIDTH <span class="hljs-number"><span class="hljs-number">128</span></span> #define HEIGHT <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> morph_dilate_omp() { IppiSize roiSize = { WIDTH, HEIGHT }; IppiSize maskSize = { <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; IppStatus status; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> specSize = <span class="hljs-number"><span class="hljs-number">0</span></span>, bufferSize = <span class="hljs-number"><span class="hljs-number">0</span></span>; IppiMorphState* pMorphSpec; Ipp8u* pBuffer; Ipp32f *pSrc, *pDst; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> srcStep, dstStep; Ipp8u pMask[<span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }; IppiBorderType border = ippBorderRepl; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> borderValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nThreads = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j; <span class="hljs-comment"><span class="hljs-comment">/*allocate memory*/</span></span> pSrc = ippiMalloc_32f_C1(WIDTH, HEIGHT, &amp;srcStep); pDst = ippiMalloc_32f_C1(WIDTH, HEIGHT, &amp;dstStep); <span class="hljs-comment"><span class="hljs-comment">/*fill image*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;HEIGHT; j++){ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;WIDTH; i++){ pSrc[WIDTH*j + i] = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(); } } <span class="hljs-comment"><span class="hljs-comment">/*get sizes of spec and buffer */</span></span> ippiMorphologyBorderGetSize_32f_C1R(roiSize.width, maskSize, &amp;specSize, &amp;bufferSize); <span class="hljs-comment"><span class="hljs-comment">/*allocate spec. It will be shared between all threads.*/</span></span> pMorphSpec = (IppiMorphState*)ippsMalloc_8u(specSize); <span class="hljs-comment"><span class="hljs-comment">/*allocate individual buffers for every thread*/</span></span> pBuffer = (Ipp8u*)ippsMalloc_8u(bufferSize * nThreads); <span class="hljs-comment"><span class="hljs-comment">/*initialize spec*/</span></span> ippiMorphologyBorderInit_32f_C1R(roiSize.width, pMask, maskSize, pMorphSpec, pBuffer); <span class="hljs-comment"><span class="hljs-comment">/*set number of threads*/</span></span> omp_set_num_threads(nThreads); { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t_w, t_wt, <span class="hljs-comment"><span class="hljs-comment">/*width and height per one block(thread)*/</span></span> t_h, t_ht; <span class="hljs-comment"><span class="hljs-comment">/*tails for last threads */</span></span> #pragma omp parallel { #pragma omp master { nThreads = omp_get_num_threads(); t_w = roiSize.width / <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*calculate blocks WxH*/</span></span> t_wt = roiSize.width % <span class="hljs-number"><span class="hljs-number">4</span></span>; t_h = roiSize.height / <span class="hljs-number"><span class="hljs-number">4</span></span>; t_ht = roiSize.height % <span class="hljs-number"><span class="hljs-number">4</span></span>; } #pragma omp barrier { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> t_id, <span class="hljs-comment"><span class="hljs-comment">/* id of thread*/</span></span> t_x, t_y; <span class="hljs-comment"><span class="hljs-comment">/*x and y position of block*/</span></span> IppiSize t_roi; Ipp32f* t_src; Ipp32f* t_dst; Ipp8u* t_buf; IppiBorderType t_bor = ippBorderRepl; t_id = omp_get_thread_num(); t_roi.width = t_w; t_roi.height = t_h; t_x = t_id &amp; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*get x and y for block.*/</span></span> t_y = t_id &gt;&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* image splitted at 4x4 blocks*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_x == <span class="hljs-number"><span class="hljs-number">3</span></span>) t_roi.width += t_wt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_y == <span class="hljs-number"><span class="hljs-number">3</span></span>) t_roi.height += t_ht; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t_bor |= ippBorderInMemLeft; <span class="hljs-comment"><span class="hljs-comment">/*analyze block position*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_x &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) t_bor |= ippBorderInMemRight; <span class="hljs-comment"><span class="hljs-comment">/*and set InMem* modifier*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t_bor |= ippBorderInMemTop; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_y &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) t_bor |= ippBorderInMemBottom; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t_x &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t_x &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> &amp;&amp; t_y &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; t_y &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) t_bor = ippBorderInMem; <span class="hljs-comment"><span class="hljs-comment">/*internal block*/</span></span> t_src = (Ipp8u*)pSrc + t_y * t_h * srcStep + t_x * t_w*sizeof(Ipp32f); <span class="hljs-comment"><span class="hljs-comment">/*get offset of source and dest for block */</span></span> t_dst = (Ipp8u*)pDst + t_y * t_h * dstStep + t_x * t_w*sizeof(Ipp32f); <span class="hljs-comment"><span class="hljs-comment">/*using x and y of block*/</span></span> t_buf = pBuffer + t_id * bufferSize; <span class="hljs-comment"><span class="hljs-comment">/*every thread uses own buffer*/</span></span> ippiDilateBorder_32f_C1R(t_src, srcStep, t_dst, dstStep, t_roi,t_bor, borderValue, pMorphSpec, t_buf); } } } }</code> </pre><br></div></div><br>  This example splits the image into 16 blocks according to fig.  16. The general data structure pMorphSpec is used, its position in the image is determined according to the stream identifier, after which the border modifiers are formed.  Also, each thread is allocated its own buffer t_buf. <br><br><h2>  5. Conclusion </h2><br>  Thus, the advantages of the new API functions with a border implemented in IPP 8.0 allow users of the IPP library to solve several important problems related to image processing - you can use arbitrary parallelization tools at the application level, the size of the resulting images does not decrease, and it is also possible to process large images by breaking them into blocks. </div><p>Source: <a href="https://habr.com/ru/post/255931/">https://habr.com/ru/post/255931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255917/index.html">Build Embedded Linux from Yocto for QEMU x86 and the first application to it</a></li>
<li><a href="../255921/index.html">Eco Driving: an overview of the driver behavior assessment tool.</a></li>
<li><a href="../255925/index.html">Data carriers. What we have year 2015 and what should we expect beyond its horizon?</a></li>
<li><a href="../255927/index.html">Intel Edison officially in Russia: pre-order and project competition</a></li>
<li><a href="../255929/index.html">Schneider Electric thanked the winner of the PHDays hacker contest</a></li>
<li><a href="../255933/index.html">What should we build an open data center? Some details about the structure of Facebook DC in Altoona</a></li>
<li><a href="../255935/index.html">Limbo game defense research. Keygen</a></li>
<li><a href="../255939/index.html">Unity Web Player and Java support disabled in Google Chrome 42</a></li>
<li><a href="../255941/index.html">Organization and use of segmentation in large mobile applications</a></li>
<li><a href="../255945/index.html">Neural Interfaces: From Photo Paper to Neural Dust</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>