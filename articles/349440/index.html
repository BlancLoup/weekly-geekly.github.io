<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a game on Lua and L√ñVE - 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents 


- Article 1 Part 1. Game cycle Part 2. Libraries Part 3. Rooms and areas Part 4. Exercises 
- Part 1. Game cycle 
- Part 2. Libra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a game on Lua and L√ñVE - 2</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/277/af4/cfe/277af4cfea1312469abb5cc1806a6a44.jpg" alt="image"></div><br><h2>  Table of contents </h2><br><ul><li>  <a href="https://habrahabr.ru/post/349276/">Article 1</a> <ul><li>  Part 1. Game cycle </li><li>  Part 2. Libraries </li><li>  Part 3. Rooms and areas </li><li>  Part 4. Exercises </li></ul></li><li>  <a href="https://habrahabr.ru/post/349440/">Article 2</a> <ul><li>  Part 5. Basics of the game </li><li>  Part 6. Basics of the Player Class </li></ul></li><li>  <a href="https://habrahabr.ru/post/349718/">Article 3</a> <ul><li>  Part 7. Player Parameters and Attacks </li><li>  Part 8. Enemies </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 4</a> <ul><li>  Part 9. Director and game cycle </li><li>  Part 10. Code Writing Practices </li><li>  Part 11. Passive skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 5</a> <ul><li>  Part 12. Other Passive Skills </li></ul></li></ul><br>  13. Skill Tree <br><br>  14. Console <br><br>  15. Final 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Part 5: The Basics of the Game </h2><br><h2>  Introduction </h2><br>  In this part we will finally start the game itself.  First, we will review the structure of the game in terms of gameplay, and then focus on the basics that are common to all parts of the game: its pixelated style, camera, and also physics simulation.  Then we will look at the basics of moving the player and, finally, we will deal with garbage collection and possible leaks of objects. <br><br><h2>  Structure of the gameplay </h2><br>  The game itself is divided into just three separate rooms: <code>Stage</code> , <code>Console</code> and <code>SkillTree</code> . <br><br>  In the Stage room the whole game process takes place.  It contains objects such as a player, enemies, shells, resources, bonuses, and so on.  Gameplay is very similar to <a href="http://store.steampowered.com/app/433950/" rel="nofollow">Bit Blaster XL</a> and is actually quite simple.  I chose such a simple gameplay, because it will allow me to focus on another aspect of the game (a huge skill tree). <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath51.gif"></div></div></div><br>  In the Console room, everything happens related to the ‚Äúmenu‚Äù: changing sound and video settings, viewing achievements, choosing a ship, accessing the skill tree, and so on.  Instead of creating different menus for a game with a similar style, it is more logical to give it a ‚Äúcomputerized‚Äù look (also known as ‚Äúart of lazy programmers‚Äù), because the console emulates a terminal and makes it clear that you (the player) are playing the game simply through a terminal . <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath52.gif"></div></div></div><br>  In the room SkillTree you can get all the passive skills.  In the Stage room a player can earn SP (skill points, skill points), which are created randomly or are given when killing enemies.  After death, the player can use these skill points to purchase passive skills.  I wanted to realize something huge, in the style of the <a href="https://www.pathofexile.com/passive-skill-tree" rel="nofollow">tree of passive skills Path of Exile</a> , and it seems to me that I have succeeded enough in this.  In the skill tree created by me about 600-800 nodes.  In my opinion, quite good. <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath53.gif"></div></div></div><br>  I will look at the creation of each of these rooms in detail, including all skills in the skill tree.  However, I highly recommend deviating as much as possible from what I am doing.  The many decisions I have made regarding gameplay are a matter of taste, and you can choose something else. <br><br>  For example, instead of a huge skill tree, you can choose a huge class system that allows you to create many combinations like those implemented in the <a href="http://www.tosbase.com/game/classes/" rel="nofollow">Tree of Savior</a> .  So instead of building a tree of passive skills, you can implement all the passive skills, and then build your own class system using these passive skills. <br><br>  This is just one of the ideas;  There are many areas in which you can choose your own variations.  I supplement these tutorials with exercises also in order to encourage people to work with the material on their own, and not just to copy the existing one;  It seems to me that this is how people learn better.  Therefore, when you see the opportunity to do something in your own way, I recommend that you do so. <br><br><h2>  Game size </h2><br>  Now let's get down to the Stage.  The first thing we need (and this will be true for all rooms, not just for the Stage) is to create a pixelated appearance of the room in low resolution.  For example, look at this circle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/9bf/074/e4e9bf07492721727e0a2e52c7db0161.png"></div><br>  And now look at this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e71/10c/aef/e7110caef6392b51f1ec221992a98542.png"></div><br>  I prefer the second option.  My motives are purely aesthetic and are my own preference.  There are many games that do not use a pixelated look, but at the same time they are still limited to simple shapes and colors, for example <a href="https://www.youtube.com/watch%3Fv%3D4iLW0X69mfo" rel="nofollow">, this one</a> .  That is, it depends on your stylistic preferences and on how much work you put into the game.  But in my game I will use a pixelated view. <br><br>  One of the ways to implement it is to define a very small default resolution, it is desirable that it be well scaled then the target resolution of the game window is <code>1920x1080</code> .  For this game, I will choose <code>480x270</code> , because this is <code>1920x1080</code> divided by 4. To change the size of the game to this value, we need to use the <a href="https://love2d.org/wiki/Config_Files" rel="nofollow"><code>conf.lua</code></a> file, which, as I explained in the previous part, is a configuration file that defines the parameters of the L√ñVE project by default, including the resolution of the window in which the game is launched. <br><br>  In addition, in this file I will also define two global variables <code>gw</code> and <code>gh</code> , corresponding to the width and height of the base resolution, and variables <code>sx</code> and <code>sy</code> , corresponding to the scale applied to this base resolution.  The <code>conf.lua</code> file should be in the same folder as the <code>main.lua</code> file, and still look like this: <br><br><pre> <code class="lua hljs">gw = <span class="hljs-number"><span class="hljs-number">480</span></span> gh = <span class="hljs-number"><span class="hljs-number">270</span></span> sx = <span class="hljs-number"><span class="hljs-number">1</span></span> sy = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.conf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span></span> t.identity = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">--    () t.version = "0.10.2" --  L√ñVE,      () t.console = false --   (boolean,   Windows) t.window.title = "BYTEPATH" --   () t.window.icon = nil --    ,     () t.window.width = gw --   () t.window.height = gh --   () t.window.borderless = false --       (boolean) t.window.resizable = true --      (boolean) t.window.minwidth = 1 --        () t.window.minheight = 1 --        () t.window.fullscreen = false --    (boolean) t.window.fullscreentype = "exclusive" --           () t.window.vsync = true --    (boolean) t.window.fsaa = 0 --      () t.window.display = 1 --  ,      () t.window.highdpi = false --    dpi     Retina (boolean) t.window.srgb = false --  - sRGB     (boolean) t.window.x = nil --  x      () t.window.y = nil --  y      () t.modules.audio = true --   (boolean) t.modules.event = true --    (boolean) t.modules.graphics = true --    (boolean) t.modules.image = true --    (boolean) t.modules.joystick = true --    (boolean) t.modules.keyboard = true --    (boolean) t.modules.math = true --    (boolean) t.modules.mouse = true --    (boolean) t.modules.physics = true --    (boolean) t.modules.sound = true --    (boolean) t.modules.system = true --    (boolean) t.modules.timer = true --    (boolean),    0 delta time  love.update    0 t.modules.window = true --    (boolean) t.modules.thread = true --    (boolean) end</span></span></code> </pre> <br>  If you start the game now, you will see that the window has become smaller. <br><br>  To get a pixelated view, as we zoom in on the window, we need to do additional work.  If you draw a circle in the center of the screen ( <code>gw/2, gh/2</code> ) now, like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9f/9e6/45b/e9f9e645b8dd708f341378f6345e9ea2.png"></div><br>  and scale the screen directly by calling <a href="https://love2d.org/wiki/love.window.setMode" rel="nofollow"><code>love.window.setMode</code></a> , for example, with a width of <code>3*gw</code> and a height of <code>3*gh</code> , you get something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c4/908/494/0c4908494ea27c684debbe3543d7e549.png"></div><br>  As you can see, the circle was not scaled along with the screen and remained just a small circle.  It is also not centered on the screen, because <code>gw/2</code> and <code>gh/2</code> no longer the center of the screen when it is tripled.  We want to be able to draw a small circle at a base resolution of <code>480x270</code> , so that when the screen is enlarged to the size of a regular monitor, the circle also scales proportionally (and pixelated), and its position also proportionally remains the same.  The simplest way to solve this problem is to use <a href="https://love2d.org/wiki/Canvas" rel="nofollow"><code>Canvas</code></a> , which is also called in other engines the frame buffer (framebuffer) or target render (render target).  First, we will create a canvas with the base resolution in the constructor of the <code>Stage</code> class: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area = Area(self) self.main_canvas = love.graphics.newCanvas(gw, gh) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This will create a canvas with a size of <code>480x270</code> , on which you can draw: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setCanvas(self.main_canvas) love.graphics.clear() love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>) self.area:draw() love.graphics.setCanvas() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The way to draw the canvas can be seen on the example from the page <a href="https://love2d.org/wiki/Canvas" rel="nofollow">Canvas</a> .  According to this page, when I want to draw something on the canvas, I have to call <a href="https://love2d.org/wiki/love.graphics.setCanvas" rel="nofollow"><code>love.graphics.setCanvas</code></a> , which redirects all the drawing operations to the current given canvas.  Then we call <a href="https://love2d.org/wiki/love.graphics.clear" rel="nofollow"><code>love.graphics.clear</code></a> , which clears the contents of this canvas in the current frame, because it was also drawn in the previous frame, and in each frame we want to draw everything from scratch.  Then, drawing everything we need, we reuse <code>setCanvas</code> , but this time without passing anything, so that our target canvas is no longer current and the redirection of drawing operations is no longer performed. <br><br>  If we stop here, nothing will happen on the screen.  This is because everything that has been drawn has gone to the canvas, but we do not actually draw the canvas itself.  Therefore, we need to draw the canvas itself on the screen, and it will look like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setCanvas(self.main_canvas) love.graphics.clear() love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>) self.area:draw() love.graphics.setCanvas() love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) love.graphics.setBlendMode(<span class="hljs-string"><span class="hljs-string">'alpha'</span></span>, <span class="hljs-string"><span class="hljs-string">'premultiplied'</span></span>) love.graphics.draw(self.main_canvas, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sx, sy) love.graphics.setBlendMode(<span class="hljs-string"><span class="hljs-string">'alpha'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We simply use <a href="" rel="nofollow"><code>love.graphics.draw</code></a> to draw the canvas on the screen, and then also wrap it with calls to <a href="https://love2d.org/wiki/love.graphics.setBlendMode" rel="nofollow"><code>love.graphics.setBlendMode</code></a> , which according to the Canvas page of the L√ñVE wiki is used to prevent blending.  If you run the program now, you will see a drawn circle. <br><br>  Notice that we used to increase the Canvas <code>sx</code> and <code>sy</code> .  While these variables have the value 1, but if you change their values, for example, by 3, the following will occur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0f/d17/52d/d0fd1752d6cdc160e6f9171bc8fe5a2c.png"></div><br>  We see nothing!  But this happened because the circle in the middle of the <code>480x270</code> canvas is now in the middle of the <code>1440x810</code> canvas.  Since the screen itself has a size of <code>480x270</code> , we cannot see the entire Canvas, because it is larger than the screen.  To fix this, we can create the <code>resize</code> function in <code>main.lua</code> , which, when it <code>main.lua</code> <code>sx</code> , <code>sy</code> , changes the size of the screen itself: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s)</span></span></span></span> love.window.setMode(s*gw, s*gh) sx, sy = s, s <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  So when we call <code>resize(3)</code> in <code>love.load</code> , the following should happen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9f1/934/e47/9f1934e471aaf5c69e22c49bb454ab3f.png"></div><br>  About this we and sought.  However, there is another problem: the circle looks blurry, not pixelated. <br><br>  The reason for this is that when L√ñVE increases or decreases the drawn objects, they use <a href="https://love2d.org/wiki/FilterMode" rel="nofollow">FilterMode</a> , and this filtering mode defaults to <code>'linear'</code> .  Since we want the game to have a pixelated appearance, we must change the value to <code>'nearest'</code> .  Calling <a href="https://love2d.org/wiki/love.graphics.setDefaultFilter" rel="nofollow"><code>love.graphics.setDefaultFilter</code></a> with the argument <code>'nearest'</code> at the beginning of <code>love.load</code> should fix the problem.  Another aspect is that we need to assign the value <code>'rough'</code> to <a href="https://love2d.org/wiki/LineStyle" rel="nofollow">LineStyle</a> .  Since it defaults to <code>'smooth'</code> , L√ñVE primitives will be rendered with aliasing, and this is not suitable for creating a pixel style.  If you do all this and run the code again, the screen should look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/fb2/f18/fe9fb2f1866b02caab444e7e4a308e17.png"></div><br>  Just that broken and pixelated appearance that we need!  Most importantly, we can now use one resolution to create the entire game.  If we want to create an object in the center of the screen, we can say that its <code>x, y</code> position should be equal to <code>gw/2, gh/2</code> , and regardless of the final resolution, the object will always be in the center of the screen.  This greatly simplifies the process: it means that we only need to worry once about how the game looks and how the objects are distributed on the screen. <br><br><h3>  Exercises on the size of the game </h3><br>  <strong>65.</strong> Look at the ‚ÄúPrimary Display Resolution‚Äù section in the <a href="http://store.steampowered.com/hwsurvey/" rel="nofollow">Steam Computer Configuration Survey</a> .  The most popular resolution used by almost half of Steam users is <code>1920x1080</code> .  The basic resolution of our game is perfectly scaled to him.  But the second most popular resolution is <code>1366x768</code> .  <code>480x270</code> does not scale to it.  What options can you offer to work with non-standard permissions when switching the game to full screen? <br><br>  <strong>66.</strong> Select a game from your collection, which uses the same or similar technique (increase the small base resolution).  It is usually used in games with pixel graphics.  What is the basic resolution of the game?  How does the game deal with non-standard permissions in which the basic resolution cannot be correctly entered?  Change the resolution of the desktop several times, launching the game with different resolutions each time to see the changes and understand how the game processes the variability. <br><br><h2>  Camera </h2><br>  In all three rooms the camera is used, so it would be logical to consider it now.  In the second part of the tutorial, we used the <a href="https://github.com/vrld/hump">hump</a> library for timers.  This library also has a useful camera module, which we also use.  However, I use a slightly modified version that has a screen shake function.  Files can be downloaded <a href="https://github.com/SSYGEN/ModifiedCamera">from here</a> .  Place the <code>camera.lua</code> file in the hump library folder (and overwrite the existing version of <code>camera.lua</code> ), and then add the require of the camera module to <code>main.lua</code> .  Place the <code>Shake.lua</code> file in the <code>objects</code> folder. <br><br>  (Additionally, you can also use the <a href="https://github.com/SSYGEN/STALKER-X">library</a> written by me, which already has all this functionality. I wrote this library after completing the tutorial, so it will not be used in it. If you decide to use this library, you can continue working with the tutorial, but transfer some aspects to use the functions of this library.) <br><br>  After adding the camera, we need the following function: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">random</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(min, max)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">min</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">min</span></span> &gt; <span class="hljs-built_in"><span class="hljs-built_in">max</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>()*(<span class="hljs-built_in"><span class="hljs-built_in">min</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>()*(<span class="hljs-built_in"><span class="hljs-built_in">max</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  It will allow you to get a random number between any two numbers.  It is necessary because it uses the <code>Shake.lua</code> file.  After defining this function in <code>utils.lua</code> try doing something like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... camera = Camera() <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'f3'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> camera:shake(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... camera:update(dt) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And then in the <code>Stage</code> class: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... camera = Camera() <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'f3'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> camera:shake(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... camera:update(dt) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  You will see that after pressing <code>f3</code> screen will start shaking: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/482/e16/fc8/482e16fc878b611a4e1dfd265ffbf074.gif"></div><br>  The shaking function is based on the function described in <a href="http://jonny.morrill.me/blog/view/14" rel="nofollow">this article</a> ;  it gets amplitude (in pixels), frequency, and duration.  The screen will be shaken with a gradual attenuation, starting with amplitude, for the specified number of seconds and the specified frequency.  The higher the frequency, the more actively the screen will oscillate between two limits (amplitude, -amplitude);  low frequencies lead to the opposite. <br><br>  It is also important to note that the camera is not yet tied to a certain point, so when shaken it will throw in all directions, that is, after the shaking is completed, it will be centered in another place, as can be seen in the previous gif-animation. <br><br>  One way to solve this problem is to center the camera, which can be implemented as the <a href="http://hump.readthedocs.io/en/latest/camera.html" rel="nofollow">camera: lockPosition function</a> .  In the modified version of the camera module, I changed all the functions of camera movement so that they first receive the <code>dt</code> argument.  And it will look like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> camera.smoother = Camera.smooth.damped(<span class="hljs-number"><span class="hljs-number">5</span></span>) camera:lockPosition(dt, gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>) self.area:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  To smooth the camera is set to <code>damped</code> with a value of <code>5</code> .  I derived these parameters through trial and error, but in general this allows the camera to focus on the target point in a smooth and pleasant way.  I put this code inside the Stage room because we are now working with the Stage room, and in this room the camera should always be centered in the middle of the screen and never move (except for screen shaking moments).  As a result, we get the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9a2/021/5e0/9a20215e0d3cf5bdfb79461d72f1f4ab.gif"></div><br>  For the whole game, we will use one global camera, because there is no need to create separate camera instances for each room.  In the Stage room the camera will not be used in any other way except for shaking, so I‚Äôll stop on this for now.  In the Console and SkillTree rooms, the camera will be used in a more complex way, but we'll get to that later. <br><br><h2>  Player physics </h2><br>  Now we have everything we need to start the game itself.  We'll start with the Player object.  Create a new file in the <code>objects</code> folder called <code>Player.lua</code> , which will look like this: <br><br><pre> <code class="lua hljs">Player = GameObject:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> Player.super.new(self, area, x, y, opts) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> Player.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  In this way, a new class of game objects should be created by default.  All of them will inherit from <code>GameObject</code> and have the same structure of the constructor, the update and draw functions.  Now we can create an instance of this Player object in the Stage room as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>, gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  To check how instantiation works, and make sure that the Player object is updated and the <code>Area</code> drawn, we can simply draw a circle in its position: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, <span class="hljs-number"><span class="hljs-number">25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This should give us a circle in the center of the screen.  It is interesting to note that the call <code>addGameObject</code> returns the created object, so we can store a link to the player inside the <code>self.player</code> Stage, and if necessary, include the death event of the Player object with an <code>self.player</code> key: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.player = self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>, gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'f3'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.player.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  When you press the <code>f3</code> key, the Player object should die, that is, the circle should stop drawing.  This happens as a result of how we set up the <code>Area</code> object code in the previous section.  It is also important to note that if we decide to store the links returned by <code>addGameObject</code> in this way, then if we do not specify a variable in which the reference to <code>nil</code> is stored, this object will never be deleted.  In addition, it is important not to forget to assign <code>nil</code> values ‚Äã‚Äãto the links (in our case, the string <code>self.player = nil</code> ), if you want the object to actually be deleted from memory (besides the fact that its attribute is assigned a <code>dead</code> true value). <br><br><hr><br>  We now turn to physics.  The player (as well as enemies, shells and resources) will be a physical object.  For this, I use box2d integration in L√ñVE, but in general this is not necessary for our game, because it will not get anything useful from using such a complete physics engine as box2d.  I use it because I'm used to it.  But I recommend that you either try to write your own collision handling procedures (which will be very easy for such a game), or use the library that will do this for you. <br><br>  In the tutorial, I‚Äôll use the <a href="https://github.com/SSYGEA/windfield">windfield</a> library that I created, which makes using box2d with L√ñVE much easier.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are other libraries for L√ñVE that also handle collisions: </font></font><a href="https://vrld.github.io/HardonCollider/index.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HardonCollider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bump.lua</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I highly recommend that you either implement the collisions yourself, or use one of these two libraries, and not repeat after the tutorial. So you force yourself to develop abilities that need to be developed all the time, for example, choosing between different solutions, finding solutions that suit your needs and working in the best way for you, as well as developing your own solutions to problems, and not just following tutorials.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, I repeat - one of the main reasons for the presence of exercises in this tutorial is that people learn only when they are actively involved in the development of the material. Exercises - this is another opportunity to get acquainted with the material. If you simply repeat after the tutorial and do not learn to cope with what you do not know, you will never really learn. Therefore, I </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">highly</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> recommend deviating here from the tutorial and implementing a part with physics / collisions on your own. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, you can download the library </font></font><code>windfield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and add its require to the file </font></font><code>main.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. According to her documentation, there are two basic concepts in her - </font></font><code>World</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>Collider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">World is the physical world in which the simulation takes place, and the Collider is a physical object simulated inside this world. </font><font style="vertical-align: inherit;">That is, our game will need a semblance of the physical world, and the player will be a collider inside this world. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will create a world inside a class </font></font><code>Area</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by adding a call </font></font><code>addPhysicsWorld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:addPhysicsWorld</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.world = Physics.newWorld(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we will set the attribute of the </font></font><code>.world</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">area containing the physical world. </font><font style="vertical-align: inherit;">We also need to update this world (and, if necessary, draw it for debugging purposes), if it exists:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.world <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.world:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = #self.game_objects, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.world <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.world:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, game_object <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.game_objects) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> game_object:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We update the physical world before updating all game objects, because we want to use updated information for game objects, and this is possible only if physics simulation will be performed before this frame. If we first updated the game objects, we would use the physical information from the previous frame and it would break the frame of the frame. In fact, this does not really affect the work of the program, but from a conceptual point of view it is more confusing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We added peace through challenge</font></font><code>addPhysicsWorld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rather than just adding it to the Area constructor because we don't want all regions to have physical worlds. </font><font style="vertical-align: inherit;">For example, the Console room will also use an object to manage its entities, but there is no need to attach the physical world to this Area. </font><font style="vertical-align: inherit;">Therefore, by calling one function, we make it optional. </font><font style="vertical-align: inherit;">We can create an instance of the physical world in the Area of ‚Äã‚Äãthe Stage room as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area = Area(self) self.area:addPhysicsWorld() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And now that we have a world, we can add a Player collider to it: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> Player.super.new(self, area, x, y, opts) self.x, self.y = x, y self.w, self.h = <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span> self.collider = self.area.world:newCircleCollider(self.x, self.y, self.w) self.collider:setObject(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice how it comes in here that the player has a link to the Area, because in this way we can access the World of the Area object to add new colliders to it. Such a pattern (access to entities within the Area) is often repeated, for example, I made it so that all objects </font></font><code>GameObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have the same constructor, in which they receive a reference to the object </font></font><code>Area</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to which they belong. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Player constructor, we use attributes </font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define its width and height as 12. Next, we add a new</font></font><a href="https://github.com/SSYGEA/windfield"><code>CircleCollider</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a radius equal to the width. It is not very logical to create a collider as a circle, if we define width and height, but this will be useful in the future, because when we add different types of ships, all ships will have a visual width and height, but physically the collider will always be around, so that all ships have the same chances and have predictable behavior for the player. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After adding the collider, we call the function </font></font><a href="https://github.com/SSYGEA/windfield"><code>setObject</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that binds the Player object to the newly created Collider. This is useful because when two colliders collide, we can get information from the point of view of colliders, not objects. For example, if a Player encounters Projectile, we will have two colliders representing Player and Projectile, but we may not have the objects themselves. </font></font><code>setObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(and</font></font><code>getObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) allows us to set and retrieve the object to which Collider belongs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can finally draw the Player according to its size:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.w) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you start the game now, we will see a small circle representing the player: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecc/b6c/965/eccb6c9650e1cb780c52bc603c2c77bf.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Physics exercises Player </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you decide to create collisions yourself or choose one of the alternative collision / physics libraries, then you do not need to do these exercises. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">67.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the gravity of the y axis of the physical world to 512. What happens to the Player object? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">68.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What does the third call argument do </font></font><code>.newWorld</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and what happens if you set it to false? </font><font style="vertical-align: inherit;">Are there any advantages to setting the value true / false?</font></font> What kind? <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player movement </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The player's movement in this game acts as follows: there is a constant speed with which the player moves, and an angle that can be changed by holding ‚Äúleft‚Äù or ‚Äúright‚Äù. To implement this, we need several variables:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> Player.super.new(self, area, x, y, opts) ... self.r = -<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> self.rv = <span class="hljs-number"><span class="hljs-number">1.66</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span> self.v = <span class="hljs-number"><span class="hljs-number">0</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">100</span></span> self.a = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I define </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as the angle at which the player moves. At first it matters </font></font><code>-math.pi/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, it points up. The angles in L√ñVE are shown clockwise, that is </font></font><code>math.pi/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is down and </font></font><code>-math.pi/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">up is (and 0 is to the right). A variable </font></font><code>rv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the rate at which the angle changes when the player presses "left" or "right." Then we have </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, denoting the speed of the player, and </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">denoting the maximum speed of the player. The last attribute is the </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">player acceleration. All values ‚Äã‚Äãare obtained by trial and error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To update the player‚Äôs position taking into account all these variables, we can do something similar:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> Player.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'left'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.r = self.r - self.rv*dt <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'right'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.r = self.r + self.rv*dt <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.v = <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(self.v + self.a*dt, self.max_v) self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first two lines define what happens when you press the left and right keys. It is important to note that according to the Input library we use, these bindings must be defined in advance, and I did this in the file </font></font><code>main.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(since we use the global Input object for everything):</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'left'</span></span>, <span class="hljs-string"><span class="hljs-string">'left'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'right'</span></span>, <span class="hljs-string"><span class="hljs-string">'right'</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And when a player presses ‚Äúleft‚Äù or ‚Äúright‚Äù, the attribute </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corresponding to the player‚Äôs angle changes by </font></font><code>1.66*math.pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radian in the corresponding direction. It is also important to note here that this value is multiplied by </font></font><code>dt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, this value is controlled on a per-second basis. That is, the rate of change of the angle is measured in </font></font><code>1.66*math.pi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">radians per second. This is the result of how the game loop works, which we analyzed in the first part of the tutorial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After that we set the attribute </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is a little more complicated, but if you did it in other languages, it should be familiar to you. The original calculation has the form </font></font><code>self.v = self.v + self.a*dt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, we simply increase the speed by the magnitude of the acceleration. In this case, we increase it by 100 per second. But we also defined the attribute</font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which should limit the maximum allowed speed. If we do not limit it, it </font></font><code>self.v = self.v + self.a*dt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will increase </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">infinitely, and our player will turn into Sonic. And we do not need this! One way to prevent this is to:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.v = self.v + self.a*dt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.v &gt;= self.max_v <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.v = self.max_v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the same time, when </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it becomes larger </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we limit it to this value, and not exceed it. Another brief way to write this is to use a function </font></font><a href="" rel="nofollow"><code>math.min</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that returns the minimum value among all the arguments passed to it. In our case, we pass the result </font></font><code>self.v + self.a*dt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>self.max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, if the result of the addition is greater </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it </font></font><code>math.min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will return </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since it is less than the sum. This is a very common and useful pattern in Lua (and in other programming languages ‚Äã‚Äãtoo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we </font></font><a href="https://love2d.org/wiki/Body:setLinearVelocity" rel="nofollow"><code>setLinearVelocity</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set the speed of the Collider using x and y equal to the attribute</font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multiplied by the appropriate value depending on the angle of the object. In general, when we want to move something in some direction, and we have an angle for this, we should use it </font></font><code>cos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to move along the x axis and </font></font><code>sin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to move along the y axis. This is also a very common pattern in the development of 2D games. I will not explain this by suggesting that you‚Äôve got it sorted out at school (if it‚Äôsn‚Äôt, search Google for the basics of trigonometry). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last change we can make to the class </font></font><code>GameObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and it is quite simple. Since we use the physics engine, we have two representations in some variables, for example, speed and position. We get the position and speed of the player using the attributes </font></font><code>x, y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the position and speed of the Collider - using</font></font><a href="https://love2d.org/wiki/Body:getPosition" rel="nofollow"><code>getPosition</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><a href="https://love2d.org/wiki/Body:getLinearVelocity" rel="nofollow"><code>getLinearVelocity</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It will be logical to synchronize these two views, and one of the ways to achieve this automatically is to change the parent class of all game objects:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameObject:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.timer <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.x, self.y = self.collider:getPosition() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the following happens: if an object has an attribute defined </font></font><code>collider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">then </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be set to the position of this collider. </font><font style="vertical-align: inherit;">And when the position of the collider changes, the representation of this position in the object itself will also change accordingly. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you run the program now, you will see the following:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/023/0d5/2f4/0230d52f4d695398ca75e6aa68dbf1f7.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we see that the Player object moves in the usual way around the screen and changes direction when you press the "left" or "right" keys. </font><font style="vertical-align: inherit;">Here one detail is also important: in the Area object, a call is </font></font><code>world:draw()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drawn by the Collider. </font><font style="vertical-align: inherit;">In fact, we want to draw not only colliders, so it would be logical to comment out this line and draw the Player object directly:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.w) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last useful thing we can do is visualize the direction in which the player ‚Äúlooks‚Äù. </font><font style="vertical-align: inherit;">This can be done by simply drawing a line from the player‚Äôs position to the side where he is directed:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.w) love.graphics.line(self.x, self.y, self.x + <span class="hljs-number"><span class="hljs-number">2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And it will look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/133/0cc/6bc/1330cc6bc216ddfd1b1a90e73841fbdf.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is also the basis of trigonometry, here we use the same idea that we used before. </font><font style="vertical-align: inherit;">When we want to get a position </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is in </font></font><code>distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">units of a position </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, such that the position </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is at a certain angle </font></font><code>angle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relative to the position </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the pattern will be something like this: </font></font><code>bx = ax + distance*math.cos(angle)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>by = ay + distance*math.sin(angle)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is very often used in the development of 2D games (at least, I think so) and an intuitive understanding of this pattern will be useful for you.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with player movement </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transform the following angles into degrees (mentally) and tell which quadrant they belong to (top left, top right, bottom left or bottom right). </font><font style="vertical-align: inherit;">Do not forget that in L√ñVE the angles are counted clockwise, and not against how we were taught in school.</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">-5</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">6</span></span> -<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span></code> </pre> <br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Is the acceleration attribute required to exist </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">What will the player‚Äôs update function look like if it didn‚Äôt exist? </font><font style="vertical-align: inherit;">Are there any advantages to its existence? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Get the position of the </font></font><code>(x, y)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the position </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if the angle used is equal </font></font><code>-math.pi/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the distance is </font></font><code>100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cf/c51/22f/8cfc5122fd1e023f6a5b1852339c518e.png"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">72.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Get the position of the </font></font><code>(x, y)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">point </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the position </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if the angle used is equal </font></font><code>math.pi/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the distance is equal </font></font><code>50</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Positions </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as well as the distance and angle between them remain the same as in the previous exercise.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/993/ea3/bc8/993ea3bc84379fda480a00951961f4ca.png"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">73.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Based on the previous two exercises, tell me, what is the general pattern used when you need to get from a point </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to a certain point </font></font><code>C</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and is it permissible to use only a set of intermediate points that can be reached through angles and distances? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In synchronization of Player attribute and Collider attribute views, positions and speeds are mentioned, but what about the rotation? </font><font style="vertical-align: inherit;">The collider has a turn that can be accessed through </font></font><a href="https://love2d.org/wiki/Body:getAngle" rel="nofollow"><code>getAngle</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Why not synchronize it through the attribute </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Garbage collection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have added the code for the physics engine and motion, we can focus on what we have missed, namely, working with memory leaks. One of the problems that can arise in any programming environment is a memory leak that can lead to all sorts of negative consequences. In languages ‚Äã‚Äãwith managed code such as Lua, this can be even more annoying because data is more hidden in black boxes than with full memory management. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The garbage collector works as follows - when no reference points to an object, it is deleted. That is, if you have a table that is referenced only by a variable </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then when performing the assignment</font></font><code>a = nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the garbage collector will understand that the table to which they referred to is no longer referenced, so it can be removed from memory in the future garbage collection cycle. The problem occurs when one object is referred to several times and you forget to remove links from all these points. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, when we create a new object with </font></font><code>addGameObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the object is added to the list </font></font><code>.game_objects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This is considered a single link pointing to this object. However, the object itself is also returned in this function. Therefore, earlier we did something like </font></font><code>self.player = self.area:addGameObject('Player', ...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, in addition to storing the object reference in the list inside the Area object, we also store the reference to it in a variable </font></font><code>self.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, when we say</font></font><code>self.player.dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the Player object is removed from the list of game objects in the Area object, it still cannot be deleted from memory, because it still points to it </font></font><code>self.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, in this case, in order to really remove the Player object from memory, we need to set both </font></font><code>dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true and then execute </font></font><code>self.player = nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is just one example of what can happen, but such a problem is ubiquitous. You need to be especially careful when using third-party libraries. For example, in the physical library written by me there is a function</font></font><code>setObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to which we pass an object so that Collider stores a link to it. If the object dies, will it be removed from memory? No, because Collider still holds a link to it. The same problem, only in other conditions. One way to solve the problem is to explicitly delete objects using the function created for them </font></font><code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will deal with the removal of links. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, we can add the following to all objects:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameObject:destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.timer:destroy() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.collider <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.collider:destroy() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.collider = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now all objects have this function by default </font></font><code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This function calls the functions </font></font><code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the EnhancedTimer object, as well as the </font></font><a href="https://github.com/SSYGEA/windfield"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">function of the collider (Collider)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . These functions perform the dereferencing of items that the user probably wants to remove from memory. For example, in </font></font><code>Collider:destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one of the actions is a call </font></font><code>self:setObject(nil)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: since we want to destroy this object, we do not need Collider to keep a link to it anymore. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also change the update function of the Area as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.world <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.world:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = #self.game_objects, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> game_object = self.game_objects[i] game_object:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> game_object.dead <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> game_object:destroy() <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(self.game_objects, i) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the </font></font><code>dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object </font><font style="vertical-align: inherit;">attribute </font><font style="vertical-align: inherit;">is true, then in addition to deleting game objects from the list, we also call its destroy function, which gets rid of references to it. </font><font style="vertical-align: inherit;">We can expand this concept and realize that the physical world itself has </font></font><a href="https://github.com/SSYGEA/windfield"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">World: destroy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we can use it when we destroy the Area: object</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = #self.game_objects, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> game_object = self.game_objects[i] game_object:destroy() <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>(self.game_objects, i) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.game_objects = {} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.world <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.world:destroy() self.world = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you destroy an Area, we first destroy all the objects in it, and then destroy the physical world, if it exists. </font><font style="vertical-align: inherit;">Now we can change the room Stage to adapt to these actions:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:destroy() self.area = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can also change the function </font></font><code>gotoRoom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gotoRoom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(room_type, ...)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> current_room.destroy <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> current_room:destroy() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> current_room = <span class="hljs-built_in"><span class="hljs-built_in">_G</span></span>[room_type](...) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We check whether an </font></font><code>current_room</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">existing variable </font><font style="vertical-align: inherit;">is </font><font style="vertical-align: inherit;">present and if it contains an attribute </font></font><code>destroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in fact, we ask if it contains a real room); </font><font style="vertical-align: inherit;">if so, we call the destroy function. </font><font style="vertical-align: inherit;">And then we make the transition to the target room. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also important to remember that after adding the destroy function, all objects should follow this pattern:</font></font><br><br><pre> <code class="lua hljs">NewGameObject = GameObject:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameObject:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> NewGameObject.super.new(self, area, x, y, opts) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameObject:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> NewGameObject.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameObject:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewGameObject:destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> NewGameObject.super.destroy(self) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this is of course good, but how can we check whether we actually remove the elements from the memory? </font><font style="vertical-align: inherit;">I found the answer in one </font></font><a href="http://bitsquid.blogspot.com.br/2011/08/fixing-memory-issues-in-lua.html" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">post</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I liked </font><font style="vertical-align: inherit;">, which also has a relatively simple solution for tracking leaks:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> seen = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> count_table count_table = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> seen[t] <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> f(t) seen[t] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(t) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">"table"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> count_table(v) <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(v) == <span class="hljs-string"><span class="hljs-string">"userdata"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> f(v) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> count_table(<span class="hljs-built_in"><span class="hljs-built_in">_G</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> counts = {} <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> enumerate = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> t = type_name(o) counts[t] = (counts[t] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> count_all(enumerate) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counts <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> global_type_table = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> global_type_table == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> global_type_table = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">_G</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> global_type_table[v] = k <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> global_type_table[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">"table"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> global_type_table[<span class="hljs-built_in"><span class="hljs-built_in">getmetatable</span></span>(o) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not parse this code, because it is explained in a post, but we will add it to </font></font><code>main.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then add the </font></font><code>love.load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">following </font><font style="vertical-align: inherit;">inside </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'f1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Before collection: "</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">collectgarbage</span></span>(<span class="hljs-string"><span class="hljs-string">"count"</span></span>)/<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">collectgarbage</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"After collection: "</span></span> .. <span class="hljs-built_in"><span class="hljs-built_in">collectgarbage</span></span>(<span class="hljs-string"><span class="hljs-string">"count"</span></span>)/<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Object count: "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> counts = type_count() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">pairs</span></span>(counts) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(k, v) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"-------------------------------------"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What this code does: when the user clicks </font></font><code>f1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it shows the amount of memory before and after the garbage collection cycle, and also displays the types of objects in memory. </font><font style="vertical-align: inherit;">This is useful because now we can, for example, create a new Stage room with objects inside, delete it, and then make sure that the memory remains the same (or almost the same, hehe) as before creating the Stage. </font><font style="vertical-align: inherit;">If it remains the same, there are no memory leaks, and if not, then we have problems and we need to look for their sources.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/887/692/5098876929c8f79c12e794b3f8f8528d.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Garbage collection exercises </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">75.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assign a key </font></font><code>f2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to creating and activating a new Stage room with a call </font></font><code>gotoRoom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">76.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bind the key </font></font><code>f3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to the destruction of the current room. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">77.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Check several times the amount of used memory by pressing </font></font><code>f1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Thereafter ponazhimayte key several times </font></font><code>f2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>f3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to create and destroy new rooms. Now again check the amount of used memory by repeatedly pressing </font></font><code>f1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Is the amount of memory left as it was before, or has it become more? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">78.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Set the Stage room to create 100 Player objects instead of one by doing something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Player'</span></span>, gw/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), gh/<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also change the Update function of the Player so that the Player objects no longer move (comment out the movement code). Now repeat the process from the previous exercise. </font><font style="vertical-align: inherit;">Has the amount of occupied memory changed? </font><font style="vertical-align: inherit;">Have the overall results changed?</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 6: Player Class Basics </font></font></h2><br><h2>  Introduction </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, we will focus on adding functionality to the Player class. </font><font style="vertical-align: inherit;">First we look at the attack of the player and the object Projectile. </font><font style="vertical-align: inherit;">Then we focus on two main player characteristics: Boost and Cycle / Tick. </font><font style="vertical-align: inherit;">And finally, we will begin to create the first part of the content that will be added to the game, namely the various player ships. </font><font style="vertical-align: inherit;">Starting from this part, we will focus only on gameplay related moments (the previous five parts were preliminary preparations).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player attack </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The player in this game attacks as follows: every </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second the attack is triggered and starts automatically. </font><font style="vertical-align: inherit;">In the end, we will have 16 types of attacks, but most of them will be associated with firing projectiles in the direction of the player‚Äôs gaze. </font><font style="vertical-align: inherit;">For example, this is an attack of suggestive missiles:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/3ff/488/6d43ff488cd0e00d3cdc4695d8da49f9.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This attack shoots faster, but at random angles: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath61.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attacks and shells will have all sorts of properties and will be affected by various aspects, but their very basis is always the same. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we need to make the player attack every </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second. </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is a number that varies depending on the attack, but by default it matters </font></font><code>0.24</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This can be easily implemented using the timer library, which we described in the previous sections:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.24</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:shoot() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we will call the function </font></font><code>shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">every 0.24 seconds, and inside this function we will locate the code that will create the object of the projectile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can set what will happen inside the shoot function. For a start, we will have a small effect, denoting the shot. In practice, I developed the following rule: when creating or deleting an entity from a game, the accompanying effect should appear, which will hide the fact that the entity simply appears / disappears from the screen to nowhere. In addition, it should improve the overall appearance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create this new effect, we first need to create a new game object called</font></font><code>ShootEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(now you should already know how to do it). </font><font style="vertical-align: inherit;">This effect should be a simple square, remaining on the screen for a short period of time next to the position in which the projectile was created. </font><font style="vertical-align: inherit;">The easiest way to achieve this is to use something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ShootEffect'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShootEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.w = <span class="hljs-number"><span class="hljs-number">8</span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, self, {w = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShootEffect:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(default_color) love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, self.x - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.y - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.w, self.w) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And it will look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/37e/946/85e37e94699beaa5eec7a861c1c0e63c.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The effect code is quite simple. It's just a square with a width of 8, living for 0.1 seconds, the width of which during this time goes to 0 using the function </font></font><code>tween</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. So far we have one problem: the position of the effect is static and does not follow the player. This seems like a minor detail, because the duration of the effect is small, but try changing it to 0.5 seconds or more, and you will see what I mean. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One way to solve the problem is to pass a Player object as a reference to the ShootEffect object. Thus, the ShootEffect object will be able to synchronize its position with the Player object:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ShootEffect'</span></span>, self.x + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {player = self, d = d}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShootEffect:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ShootEffect.super.update(self, dt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.player <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.x = self.player.x + self.d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.player.r) self.y = self.player.y + self.d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.player.r) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShootEffect:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, self.player.r + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">4</span></span>) love.graphics.setColor(default_color) love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, self.x - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.y - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.w, self.w) love.graphics.pop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The attribute </font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShootEffect object through the table </font></font><code>opts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the function of the shoot player is assigned a value </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This means that access to the link to the Player object can be obtained through </font></font><code>self.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the ShootEffect object. In general, we transfer object references to each other in this way, because usually objects are created from functions of other objects, that is, by transferring </font></font><code>self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we get what we need. In addition, we assign the attribute the </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value of the distance at which the effect should appear from the center of the Player object. This is also implemented using the table </font></font><code>opts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, in the ShootEffect update function, we assign its position to the player‚Äôs position value. It is always important to check whether the variable is set to which we will access (</font></font><code>if self.player then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), because if it is not, then an error will occur. Also very often in the process of creating the game, there will be cases when entities will be referenced from somewhere else, and we will try to get access to their values, but since they have already died, these values ‚Äã‚Äãwill not be set, and we will get an error. It is important not to forget about this, referring to the entities within each other in this way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the last thing to do here is to synchronize the square with the player‚Äôs angle, and then also rotate it 45 degrees so that it looks prettier. For this we use a function </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that looks like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushRotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, r)</span></span></span></span> love.graphics.push() love.graphics.translate(x, y) love.graphics.rotate(r <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) love.graphics.translate(-x, -y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a simple function that passes transitions to the transition stack. </font><font style="vertical-align: inherit;">In essence, it turns everything on </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">around a point </font></font><code>x, y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until we call </font></font><a href="" rel="nofollow"><code>love.graphics.pop</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">That is, in this example we have a square and we rotate it around its center at the player's angle plus 45 degrees (pi / 4 radians). </font><font style="vertical-align: inherit;">For the sake of completeness, you can show another version of this function, also containing scaling:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pushRotateScale</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y, r, sx, sy)</span></span></span></span> love.graphics.push() love.graphics.translate(x, y) love.graphics.rotate(r <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) love.graphics.scale(sx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, sy <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> sx <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.translate(-x, -y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> These functions are quite useful and we will use them throughout the game, so experiment with them and understand them well! </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with player attacks </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">80.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For now we only use the initial timer call in the player's constructor, which causes the shoot function to be called every 0.24 seconds. </font><font style="vertical-align: inherit;">Suppose there is an attribute in Player </font></font><code>self.attack_speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that changes every 5 seconds to a random value in the interval from 1 to 2:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.attack_speed = <span class="hljs-number"><span class="hljs-number">1</span></span> self.timer:every(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.attack_speed = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) self.timer:every(<span class="hljs-number"><span class="hljs-number">0.24</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:shoot() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How do you change the player's object so that instead of shooting every 0.24 seconds, he shoots every </font></font><code>0.24/self.attack_speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second? </font><font style="vertical-align: inherit;">Note that a simple change in a call </font></font><code>every</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that calls the shoot function will not work. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">81</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous section, we looked at garbage collection and said that forgotten links can be dangerous and lead to leaks. In this part, using the example of the Player and ShootEffect objects, I explained that we can refer to objects from each other. In this case, when ShootEffect is a non-durable object that contains a link to the Player, should we worry about dereference of the link to the Player so that this object can be deleted by the garbage collector, or is it not necessary? More generally, when do we need to take care of dereferencing objects that reference each other in this way? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">82.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With the help </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turn the player around its center by 180 degrees. It should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd1/54e/38c/dd154e38c29cf672a36226ca687a7281.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">83.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using, </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotate the line indicating the direction of the player‚Äôs movement around its center by 90 degrees. </font><font style="vertical-align: inherit;">It should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a4/4e3/d1e/1a44e3d1ec1e15abe884b16cb1420e20.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">84.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using Using, </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotate the line indicating the player‚Äôs direction around the player‚Äôs center by 90 degrees. </font><font style="vertical-align: inherit;">It should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/368/d83/f87/368d83f8721ebf80f5e7203aaaba41df.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">85.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using, </font></font><code>pushRotate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rotate the ShootEffect object around the center of the player by 90 degrees (beyond that it already rotates relative to the player‚Äôs direction). </font><font style="vertical-align: inherit;">It should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ea/7c9/4be/4ea7c94bea3372d277d2185055ed1ee6.gif"></div></div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player's shell </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have a shooting effect, we can go to the projectile itself. </font><font style="vertical-align: inherit;">The projectile will have a movement mechanism, very similar to the player's mechanism in that it will be a physical object with an angle for which you can set the speed according to this angle. </font><font style="vertical-align: inherit;">First, let's write a call inside the shoot function:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'Projectile'</span></span>, self.x + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y + <span class="hljs-number"><span class="hljs-number">1.5</span></span>*d*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {r = self.r}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there is nothing unexpected. </font><font style="vertical-align: inherit;">To set the initial position of the Projectile, we use the same variable </font></font><code>d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that was previously defined, and then pass the angle of the player as an attribute </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Note that unlike the ShootEffect object, the Projectile object doesn‚Äôt require anything other than the player‚Äôs corner when creating it, so we don‚Äôt need to pass the player as a link. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's do the Projectile constructor. </font><font style="vertical-align: inherit;">The Projectile object will also have a collider circle (like the Player), speed and direction of motion:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> Projectile.super.new(self, area, x, y, opts) self.s = opts.s <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">2.5</span></span> self.v = opts.v <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> self.collider = self.area.world:newCircleCollider(self.x, self.y, self.s) self.collider:setObject(self) self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The attribute </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is the radius of the collider, it is not designated as </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because we already use this variable for the angle of motion. In general, I would object to specify the size of the variables to use </font></font><code>w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The first two are when the object is a rectangle, and the last two are when it is a circle. In cases where the variable is </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">already used for the direction (as in this case), the radius will be used </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. These attributes are mainly used for visualization, because most often these objects already have a collider that does all the work associated with collisions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another aspect that we use here is the construction described earlier </font></font><code>opts.attribute or default_value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Thanks to how</font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> working in Lua, we can use this design as a quick way to transfer the following: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> opts.attribute <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.attribute = opts.attribute <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.attribute = default_value <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We check if the attribute exists, and then set some variable to this attribute, and if it does not exist, then we give it a default value. </font><font style="vertical-align: inherit;">In case, </font></font><code>self.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it will be assigned a value </font></font><code>opts.s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if it is defined, otherwise it is assigned a value </font></font><code>2.5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The same applies to </font></font><code>self.v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Finally, we specify the velocity of the projectile using </font></font><a href="https://love2d.org/wiki/Body:setLinearVelocity" rel="nofollow"><code>setLinearVelocity</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, indicating the initial velocity of the projectile and the angle transmitted from the Player. </font><font style="vertical-align: inherit;">It uses the same approach as when moving the Player, so you should already understand this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we now update and render the projectile as follows:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> Projectile.super.update(self, dt) self.collider:setLinearVelocity(self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.v*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(default_color) love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.s) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> then it will look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea0/d64/caa/ea0d64caa7a191db2a77103e3ce10c9b.gif"></div></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with player projectiles </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">86.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the function of the shoot player, change the size / radius of the shells being created by 5, and their speed by 150. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">87.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the shoot function so that it creates not one, but three projectiles, and two of them should be created with player direction angles + - 30 degrees. </font><font style="vertical-align: inherit;">It should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a5/933/e64/1a5933e644506e4d403702f6ffa970dc.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">88.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the shoot function so that it creates not one, but three projectiles so that the position of each side projectile is offset from the center by 8 pixels. </font><font style="vertical-align: inherit;">It should look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3d/79c/344/f3d79c34486e1a7bf70fd82e7032fb19.gif"></div></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">89.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the initial velocity of the projectile to 100 and set it to accelerate to 400 within 0.5 seconds after creation.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Death of a player and projectile </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, when the Player can move and make the simplest attacks, you need to attend to additional rules of the game. </font><font style="vertical-align: inherit;">One of these rules is that if a player touches the edge of the playing area, then he must die. </font><font style="vertical-align: inherit;">The same applies to the shells, because while they are created, but never destroyed, and at some point they will become so many that the game will begin to slow down. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with the object Projectile:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.x &gt; gw <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.y &gt; gh <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We know that the center of the game area is in </font></font><code>gw/2, gh/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, the upper left corner is in </font></font><code>0, 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the lower right is in </font></font><code>gw, gh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And we need only add a few conditional constructions to the update function of the projectile, checking its position, and if it is outside the bounds, then we must call the function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same logic applies to the Player object:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.x &gt; gw <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.y &gt; gh <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is very simple and, in essence, the only thing it does is to set the </font></font><code>dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entity </font><font style="vertical-align: inherit;">attribute </font><font style="vertical-align: inherit;">to true, and then create visual effects. For a projectile, the effect created will be called </font></font><code>ProjectileDeathEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; as in the case of ShootEffect, it will be a square, remaining on the screen for a short period of time, and then disappearing, but with some differences. The main difference is that ProjectileDeathEffect will flicker for a while, then switch to its normal color and fade. This creates a light, but interesting cotton effect. So the constructor will look like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectileDeathEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> ProjectileDeathEffect.super.new(self, area, x, y, opts) self.first = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.first = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.second = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:after(<span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.second = <span class="hljs-literal"><span class="hljs-literal">false</span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have identified two attributes - </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will indicate what stage the effect is at. </font><font style="vertical-align: inherit;">If it is in the first stage, then it will have a white color, and in the second it will take its real color. </font><font style="vertical-align: inherit;">After the second stage is completed, the effect ‚Äúdies‚Äù, which is done by assigning the </font></font><code>dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value true. </font><font style="vertical-align: inherit;">All this happens within 0.25 seconds (0.1 + 0.15), that is, it is a very short-lived and fast effect. </font><font style="vertical-align: inherit;">The effect will be rendered in a manner very similar to the ShootEffect drawing method:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProjectileDeathEffect:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.first <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> self.second <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(self.color) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, self.x - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.y - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span>, self.w, self.w) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we simply set the color according to the effect stage, and then draw a rectangle of that color. </font><font style="vertical-align: inherit;">We implement this effect in a function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the Projectile object:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Projectile:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ProjectileDeathEffect'</span></span>, self.x, self.y, {color = hp_color, w = <span class="hljs-number"><span class="hljs-number">3</span></span>*self.s}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I forgot to mention earlier that the game will have a finite number of colors. </font><font style="vertical-align: inherit;">I am not an artist and I don‚Äôt want to spend much time thinking about colors, so I just chose several well-matched colors and used them throughout the game. </font><font style="vertical-align: inherit;">These colors are defined in </font></font><code>globals.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and look like this:</font></font><br><br><pre> <code class="lua hljs">default_color = {<span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span>, <span class="hljs-number"><span class="hljs-number">222</span></span>} background_color = {<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>} ammo_color = {<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-number"><span class="hljs-number">164</span></span>} boost_color = {<span class="hljs-number"><span class="hljs-number">76</span></span>, <span class="hljs-number"><span class="hljs-number">195</span></span>, <span class="hljs-number"><span class="hljs-number">217</span></span>} hp_color = {<span class="hljs-number"><span class="hljs-number">241</span></span>, <span class="hljs-number"><span class="hljs-number">103</span></span>, <span class="hljs-number"><span class="hljs-number">69</span></span>} skill_point_color = {<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">198</span></span>, <span class="hljs-number"><span class="hljs-number">93</span></span>}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the projectile death effect, I use color </font></font><code>hp_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(red) to show how the effect looks, but in the future it will be right to use the color of the projectile object. </font><font style="vertical-align: inherit;">Different types of attacks will have different colors, so the effect of death will also have different colors depending on the attack. </font><font style="vertical-align: inherit;">Now the effect is as follows:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f65/fea/6ba/f65fea6ba0b9cdc93c2c217e15ab9daf.gif"></div></div></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We now turn to the effect of death Player. The first thing to do is copy the function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the Projectile object and set the attribute </font></font><code>dead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to true when the player reaches the edges of the screen. By doing this, you can add visual effects to death. The main special effect at the death of the player will be a particle beam, called </font></font><code>ExplodeParticle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a bit like an explosion. In general, the particles will be lines moving at random angles from the initial position and slowly decreasing in length. You can implement it in this way:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExplodeParticle:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> ExplodeParticle.super.new(self, area, x, y, opts) self.color = opts.color <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> default_color self.r = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>) self.s = opts.s <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) self.v = opts.v <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">150</span></span>) self.line_width = <span class="hljs-number"><span class="hljs-number">2</span></span> self.timer:tween(opts.d <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>), self, {s = <span class="hljs-number"><span class="hljs-number">0</span></span>, v = <span class="hljs-number"><span class="hljs-number">0</span></span>, line_width = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have defined several attributes, most of them speak for themselves. Additionally, in the interval between 0.3 and 0.5 seconds, we use tween to change the size, speed and width of the line to 0, and after the transition is completed, the particle "dies". The particle motion code is similar to Projectile and Player, so I‚Äôll skip it. It simply follows the angle with its speed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, the particle is drawn as a line:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExplodeParticle:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, self.r) love.graphics.setLineWidth(self.line_width) love.graphics.setColor(self.color) love.graphics.line(self.x - self.s, self.y, self.x + self.s, self.y) love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) love.graphics.setLineWidth(<span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.pop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, when you need to draw something that turns (in our case, the angle of the particle), we draw it as if it is at an angle of 0 (pointing to the right). </font><font style="vertical-align: inherit;">That is, in our case, we need to draw a line from left to right, the center of which will be the turning position. </font><font style="vertical-align: inherit;">That is </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it is actually half the size of the line, not the full size. </font><font style="vertical-align: inherit;">We also use the </font></font><a href="https://love2d.org/wiki/love.graphics.setLineWidth" rel="nofollow"><code>love.graphics.setLineWidth</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">line first to be oily and thinner over time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Particles are created in a fairly simple way. </font><font style="vertical-align: inherit;">Just create a random number of them in the function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ExplodeParticle'</span></span>, self.x, self.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing we can do is bind the key to trigger the </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Player </font><font style="vertical-align: inherit;">function </font><font style="vertical-align: inherit;">, because we cannot see the effect on the border of the screen:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:bind(<span class="hljs-string"><span class="hljs-string">'f4'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:die() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And it will look like this: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93b/480/6a9/93b4806a994855c48c0656a83a40c2e1.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the picture was not very impressive. </font><font style="vertical-align: inherit;">To make the moment more dramatic, you can slow down a bit. </font><font style="vertical-align: inherit;">Most people will not notice this, but if you look closely, many games slow down a bit when the player takes damage or dies. </font><font style="vertical-align: inherit;">Downwell is a good example, </font></font><a href="https://www.youtube.com/watch%3Fv%3DkY83H8BdxhI" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this video</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shows its gameplay. </font><font style="vertical-align: inherit;">I noted the time when the damage is done, so that you can observe and notice it yourself. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing it yourself is pretty easy. </font><font style="vertical-align: inherit;">First, we can define a global variable </font></font><code>slow_amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>love.load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and assign it an initial value of 1. We will use this variable to multiply the delta passed in all update functions. </font><font style="vertical-align: inherit;">So when we need to slow down time by 50%, we will assign</font></font><code>slow_amount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a value of 0.5. </font><font style="vertical-align: inherit;">Performing this multiplication looks like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> timer:update(dt*slow_amount) camera:update(dt*slow_amount) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> current_room:update(dt*slow_amount) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now we need to determine the function that causes it to fire. </font><font style="vertical-align: inherit;">In general, we want the time dilation to return to the original after a short period of time. </font><font style="vertical-align: inherit;">Therefore, it will be logical to add to this function along with the level of slowing down its duration:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">slow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amount, duration)</span></span></span></span> slow_amount = amount timer:tween(<span class="hljs-string"><span class="hljs-string">'slow'</span></span>, duration, <span class="hljs-built_in"><span class="hljs-built_in">_G</span></span>, {slow_amount = <span class="hljs-number"><span class="hljs-number">1</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, the call </font></font><code>slow(0.5, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will mean that the game will first slow down to 50% speed, and then return to full speed after 1 second. </font><font style="vertical-align: inherit;">It is important to note here that the string is used in the tween function </font></font><code>'slow'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As explained in the previous sections, this means that when the slow function is called, when the tween of the other slow function is still active, this previous tween will be canceled and the new tween will continue, which will prevent the two tween functions from performing one variable at the same time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we call </font></font><code>slow(0.15, 1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the player at the time of death, we get the following:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33e/973/0d6/33e9730d6fcd554196fd33980a83607e.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we can also add screen shake. </font><font style="vertical-align: inherit;">The camera module already has a function </font></font><code>:shake</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we can add the following:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... camera:shake(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we can make the screen flicker for several frames. </font><font style="vertical-align: inherit;">This is another effect that is used in many games that you may not notice, but it creates a good impression of the visual effect as a whole. </font><font style="vertical-align: inherit;">This effect is quite simple: when called </font></font><code>flash(n)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the screen will flicker with the background color for n frames. </font><font style="vertical-align: inherit;">One way to implement this possibility is to define a global variable </font></font><code>flash_frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>love.load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is initially nil. </font><font style="vertical-align: inherit;">When </font></font><code>flash_frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal to nil, this means that the effect is inactive, and when it is not equal to nil, then it is active. </font><font style="vertical-align: inherit;">The blink function looks like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(frames)</span></span></span></span> flash_frames = frames <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can configure it in the function </font></font><code>love.draw</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">love.draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> current_room:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flash_frames <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> flash_frames = flash_frames - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flash_frames == <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> flash_frames = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> flash_frames <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(background_color) love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sx*gw, sy*gh) love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we decrease each frame </font></font><code>flash_frames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by 1, and then, when it reaches, </font></font><code>-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we assign it nil, because the effect is complete. </font><font style="vertical-align: inherit;">And when the effect is not complete, we simply draw a large rectangle with a color </font></font><code>background_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that covers the whole screen. </font><font style="vertical-align: inherit;">Adding this to a function </font></font><code>die</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">looks like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:die</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> flash(<span class="hljs-number"><span class="hljs-number">4</span></span>) camera:shake(<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>) slow(<span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, love.<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ExplodeParticle'</span></span>, self.x, self.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In this case, we get the following: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/16f/6f3/1c6/16f6f31c6931d54eb42dda3af4b1b57b.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is a very weak and inconspicuous effect, but such small details make the whole picture more powerful and beautiful. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Death Exercises Player / Projectile </font></font></h3><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What other way can you achieve the effect of changing the colors of a ProjectileDeathEffect object without using attributes </font></font><code>first</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and using only a new attribute </font></font><code>current_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">91.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the function </font></font><code>flash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it receives the duration in seconds, not frames. </font><font style="vertical-align: inherit;">Which one is better, or is it just a matter of taste? </font><font style="vertical-align: inherit;">Can a timer be used to measure the duration of frames instead of seconds?</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player Tact </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we come to another important aspect of the Player - its loop mechanism. </font><font style="vertical-align: inherit;">The game works in such a way that in the passive skills tree there are skills that have a probability of triggering in each cycle. </font><font style="vertical-align: inherit;">And the cycle is just a counter that fires every n seconds. </font><font style="vertical-align: inherit;">We need to configure its main tasks. </font><font style="vertical-align: inherit;">And for this we simply make sure that the function is </font></font><code>tick</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">called every 5 seconds:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:tick() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the tick function, for the beginning, we only add a small visual effect </font></font><code>TickEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is triggered by each measure. </font><font style="vertical-align: inherit;">This effect is similar to the effect of refresh in Downwell (see video about Downwell above), it is a large rectangle that briefly overlaps with the player.</font></font> It looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc4/de3/63d/cc4de363de6d0f9bf7302bb0fb8d1d3b.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing to notice is that the large rectangle covers the player and becomes smaller over time. </font><font style="vertical-align: inherit;">But besides that, he, as a ShootEffect, follows the player. </font><font style="vertical-align: inherit;">That is, we understand that it will be necessary to pass a Player object to the TickEffect object as a reference:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:tick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'TickEffect'</span></span>, self.x, self.y, {parent = self}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TickEffect:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.parent <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.x, self.y = self.parent.x, self.parent.y <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also see that the rectangle becomes smaller with time, but only in height. </font><font style="vertical-align: inherit;">The easiest way to do this is:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TickEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> TickEffect.super.new(self, area, x, y, opts) self.w, self.h = <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.13</span></span>, self, {h = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if you try to do this, you will see that the rectangle does not rise up as it should, but simply becomes smaller near the player‚Äôs center. </font><font style="vertical-align: inherit;">One way to solve this problem is to introduce an attribute </font></font><code>y_offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that </font><font style="vertical-align: inherit;">increases with time </font><font style="vertical-align: inherit;">and is subtracted from the position </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the TickEffect object:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TickEffect:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.y_offset = <span class="hljs-number"><span class="hljs-number">0</span></span> self.timer:tween(<span class="hljs-number"><span class="hljs-number">0.13</span></span>, self, {h = <span class="hljs-number"><span class="hljs-number">0</span></span>, y_offset = <span class="hljs-number"><span class="hljs-number">32</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TickEffect:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.parent <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.x, self.y = self.parent.x, self.parent.y - self.y_offset <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And in this way we will manage to get the desired effect. </font><font style="vertical-align: inherit;">For now, this is all that tick will do. </font><font style="vertical-align: inherit;">Later we will add features and passive skills, and a new code will appear in it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player acceleration </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another important aspect of the gameplay is acceleration. When the user presses "up", the player should start moving faster. And when the user presses "down", the player should start to move more slowly. This acceleration mechanic is a basic part of the gameplay; as in the case of bars, we will first create the basics, and then we will add new features to them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First we need to set up key management. The player has an attribute </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that sets the maximum speed at which a player can move. We want to make it so that when you press "up" / "down" this value changes and becomes more / less. The problem here is that after the key is released, we need to return to the normal value. Therefore, we need another variable that stores the base value and another one that contains the current value.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The presence in the game of characteristics (for example, speed), which must be changed by modifiers (i.e. basic and current values ‚Äã‚Äãare necessary), is a very common pattern. Later we will add new features and passive skills to the game and consider this in more detail. But for now we will add an attribute </font></font><code>base_max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containing the initial / base value of the maximum speed, and the usual attribute </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will contain the current maximum speed to which all possible modifiers are applied (for example, acceleration).</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.base_max_v = <span class="hljs-number"><span class="hljs-number">100</span></span> self.max_v = self.base_max_v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.max_v = self.base_max_v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'up'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">1.5</span></span>*self.base_max_v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'down'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*self.base_max_v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this code, we assign a </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value </font><font style="vertical-align: inherit;">in each frame </font></font><code>base_max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then check whether the up / down keys are pressed and change them accordingly </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It is important to note that this means that the call </font></font><code>setLinearVelocity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using </font></font><code>max_v</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it should occur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that, otherwise everything will fall apart! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have a basic acceleration capability, we can add visual effects. To do this, we will add traces of exhaust to the player‚Äôs object:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/e4c/e30/a18e4ce305e3664bcc37255af2480179.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creating traces follows a common pattern. I will create a new object in each frame or so, and then reduce the size of the object with the tween function for a certain time. Over time, we will create an object behind the object, and they will be drawn next to each other. Created earlier will become smaller, and just created will be more. All of them will be created in the lower part of the player, and with his movement we will get the desired effect of the trace. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement this, we can create a new object </font></font><code>TrailParticle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will simply be around a certain radius, for a certain time, reduced by the function tween:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrailParticle:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> TrailParticle.super.new(self, area, x, y, opts) self.r = opts.r <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) self.timer:tween(opts.d <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>), self, {r = <span class="hljs-number"><span class="hljs-number">0</span></span>}, <span class="hljs-string"><span class="hljs-string">'linear'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.dead = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different transition modes, for example, </font></font><code>'in-out-cubic'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead </font></font><code>'linear'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, will give a different shape to the trail. I used linear because it seems to me the most beautiful, but you can choose another one. The draw function simply draws a circle of the corresponding color and radius using an attribute </font></font><code>r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the Player object, we can create a new TrailParticles like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.trail_color = skill_point_color self.timer:every(<span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'TrailParticle'</span></span>, self.x - self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r), self.y - self.h*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r), {parent = self, r = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), d = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0.25</span></span>), color = self.trail_color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, every 0.01 seconds (that is, in each frame), we create a new TrailParticle object for the player with a random radius from 2 to 4, random duration from 0.15 to 0.25 seconds and color </font></font><code>skill_point_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(yellow). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, when you press "up" or "down" we can change the color of the particles to blue. </font><font style="vertical-align: inherit;">To do this, we need to add logic to the acceleration code, namely, we need to report when acceleration occurs, and for this we need an attribute </font></font><code>boosting</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">With this attribute, we can find out when acceleration occurs and change the color to which it refers accordingly </font></font><code>trail_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... self.max_v = self.base_max_v self.boosting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'up'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">1.5</span></span>*self.base_max_v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'down'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.boosting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.max_v = <span class="hljs-number"><span class="hljs-number">0.5</span></span>*self.base_max_v <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.trail_color = skill_point_color <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.boosting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.trail_color = boost_color <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we achieved that when the player accelerates the color will change from </font></font><code>trail_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>boost_color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(blue).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Player ship graphics </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last thing we look at in this part is the ships! The game will have many different types of ships, each with its own characteristics, passive skills and appearance. For now we will focus only on the appearance and add one ship, and in the exercise you will have to create seven more. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also worth mentioning the content: when you need to add content to the game ‚Äî ships, passive skills, various menu options, visual construction of a skill tree, etc., you will have to do most of the work yourself. In the tutorial, I‚Äôll do this with just one example, and then you‚Äôll have to manually add new content like this yourself, so I‚Äôll take this work into exercises.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I decided to do this for two reasons: first, a detailed explanation of everything would take too much time and the tutorial would be very long; secondly, you need to learn how to do manual work to add content to the game yourself. Most of the game development is simply adding content without creating something ‚Äúnew.‚Äù You may not like it, because you have to do a lot of work that you may not be interested in. It is better to understand this sooner than later. If you do not want this, then you can, for example, focus on creating games that do not require much manual labor. But my game is a completely different case. There will be about 800 nodes in the skill tree, and all of them need to be set manually (and you will have to do the same if your tree is as big), so this is a great opportunity to understand, do you like this kind of work,or not.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, let's start with one ship. </font><font style="vertical-align: inherit;">Here is what it will look like:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/633/e3e/20d633e3ef642d80e6066081b03fad38.gif"></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, it consists of three parts: the main body and two wings. </font><font style="vertical-align: inherit;">We will draw it from a set of simple polygons, that is, we need to define three separate polygons. </font><font style="vertical-align: inherit;">We will determine the position of the polygons as if the ship is turned to the right (as I explained above, this is angle 0). </font><font style="vertical-align: inherit;">We get something like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.ship = <span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> self.polygons = {} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.ship == <span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.polygons[<span class="hljs-number"><span class="hljs-number">1</span></span>] = { ... } self.polygons[<span class="hljs-number"><span class="hljs-number">2</span></span>] = { ... } self.polygons[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { ... } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inside each polygon table we define the vertices of the polygon. </font><font style="vertical-align: inherit;">To draw these polygons we have to do some work. </font><font style="vertical-align: inherit;">First, we need to rotate the polygons around the player‚Äôs center:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, self.r) love.graphics.setColor(default_color) <span class="hljs-comment"><span class="hljs-comment">--    love.graphics.pop() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After that we need to consider each of the polygons: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, self.r) love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, polygon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.polygons) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--     end love.graphics.pop() end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And then draw each polygon: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> pushRotate(self.x, self.y, self.r) love.graphics.setColor(default_color) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, polygon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.polygons) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> points = fn.map(polygon, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(k, v)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.x + v + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.y + v + <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) love.graphics.polygon(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, points) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.pop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing we do is properly arrange all points. Each polygon must be defined locally, that is, the distance from its center is considered equal </font></font><code>0, 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This means that each polygon does not yet know in which position of the world it is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><a href=""><code>fn.map</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bypasses each element in the table and applies a function to it. In this case, the function will check the index for parity. If it is odd, it denotes the component x, and if it is even, then the component y. That is, in each of these cases, we simply add the player‚Äôs x or y position to the top, as well as a random number in the range from -1 to 1, so that the ship looks a bit more fuzzy and interesting. Then, finally, it is called </font></font><a href="https://love2d.org/wiki/love.graphics.polygon" rel="nofollow"><code>love.graphics.polygon</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to draw all these points. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the definition of each polygon:</font></font><br><br><pre> <code class="lua hljs">self.polygons[<span class="hljs-number"><span class="hljs-number">1</span></span>] = { self.w, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">-- 1 self.w/2, -self.w/2, -- 2 -self.w/2, -self.w/2, -- 3 -self.w, 0, -- 4 -self.w/2, self.w/2, -- 5 self.w/2, self.w/2, -- 6 } self.polygons[2] = { self.w/2, -self.w/2, -- 7 0, -self.w, -- 8 -self.w - self.w/2, -self.w, -- 9 -3*self.w/4, -self.w/4, -- 10 -self.w/2, -self.w/2, -- 11 } self.polygons[3] = { self.w/2, self.w/2, -- 12 -self.w/2, self.w/2, -- 13 -3*self.w/4, self.w/4, -- 14 -self.w - self.w/2, self.w, -- 15 0, self.w, -- 16 }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is the main body, the second is the upper wing, the third is the lower wing. </font><font style="vertical-align: inherit;">All vertices are defined in counterclockwise order, the first point of the line is always the component x, the second is the component y. </font><font style="vertical-align: inherit;">Here is how the binding of each vertex to pairs of numbers specified above:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d74/351/8dc/d743518dc4095dd8558246b480d157bf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, the first point is far to the right and aligned with the center, that is, it has coordinates </font></font><code>self.w, 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The next one is to the left and above the first one, that is, its coordinates </font></font><code>self.w/2, -self.w/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, after adding points, we can make the tracks correspond to the ship. </font><font style="vertical-align: inherit;">In our case, as seen from the above gif, there are two tracks, not one:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> ... self.timer:every(<span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.ship == <span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'TrailParticle'</span></span>, self.x - <span class="hljs-number"><span class="hljs-number">0.9</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r) + <span class="hljs-number"><span class="hljs-number">0.2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r - <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>), self.y - <span class="hljs-number"><span class="hljs-number">0.9</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r) + <span class="hljs-number"><span class="hljs-number">0.2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r - <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>), {parent = self, r = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), d = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0.25</span></span>), color = self.trail_color}) self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'TrailParticle'</span></span>, self.x - <span class="hljs-number"><span class="hljs-number">0.9</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r) + <span class="hljs-number"><span class="hljs-number">0.2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(self.r + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>), self.y - <span class="hljs-number"><span class="hljs-number">0.9</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r) + <span class="hljs-number"><span class="hljs-number">0.2</span></span>*self.w*<span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(self.r + <span class="hljs-built_in"><span class="hljs-built_in">math</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">pi</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span>), {parent = self, r = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), d = <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(<span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0.25</span></span>), color = self.trail_color}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we use the following technique: we pass from point to point on the basis of the angle necessary to reach the goal. </font><font style="vertical-align: inherit;">The target points we need are behind the player (behind on </font></font><code>0.9*self.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), but each is shifted a short distance ( </font></font><code>0.2*self.w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) along an axis opposite to the player‚Äôs movement. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All this will look like this:</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20d/633/e3e/20d633e3ef642d80e6066081b03fad38.gif"></div></div></div><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Exercises with graphics ships </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small note: tagged </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> labeled exercises, which are themselves the content of the game. The exercises marked in this way will have no answers and you will have to do them completely yourself! From this point on, these will be more and more exercises, because we are starting to move on to the game itself, and a huge part of it is in the simple manual addition of content. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">92. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add seven more types of ships. To add a new type of ship, you just need to add another conditional construction </font></font><code>elseif self.ship == 'ShipName' then</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">both to the definition of polygons and to the definition of a trace. Here are the ships created by me (but you, of course, can create and invent your own design):</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f83/523/a65/f83523a6507cb8d561a7e3a99e265ebe.gif"></div></div></div><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you like these tutorials and you want to stimulate me to write something like this in the future: </font></font><br><br><ul><li> <a href="http://store.steampowered.com/app/760330/BYTEPATH/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTEPATH on Steam</font></font></a> </li><li> <a href="https://ssygen.itch.io/bytepath-tutorial" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BYTEPATH tutorial on itch.io</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By purchasing a tutorial on itch.io, you will have access to the full source code of the game, answers to exercises 1-9, code that is broken down into parts (the code will look like it should look at the end of each part of the tutorial), and also the key of the game on Steam. </font></font></div><p>Source: <a href="https://habr.com/ru/post/349440/">https://habr.com/ru/post/349440/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349430/index.html">NetApp storage systems - generational continuity, problems and solutions</a></li>
<li><a href="../349432/index.html">How to try on a crown</a></li>
<li><a href="../349434/index.html">Questions for the interview backend developer</a></li>
<li><a href="../349436/index.html">How to predict an Oscar winner according to social networks or how I spent my day off</a></li>
<li><a href="../349438/index.html">Moscow JS 40 in Avito - announcement</a></li>
<li><a href="../349442/index.html">JBreak 2018 Java Conference Program Overview: Absolute Balance</a></li>
<li><a href="../349444/index.html">"Do not fit, kill!" Or the whole truth about the security of automated process control systems</a></li>
<li><a href="../349446/index.html">DevDay about .NET: lazy authorization & DSL and C # union</a></li>
<li><a href="../349448/index.html">Key transparency & Coniks to protect data structures</a></li>
<li><a href="../349450/index.html">Microsoft Office Security: Document Formats</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>