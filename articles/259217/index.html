<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Screen with an infinite number of pixels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last week I updated my monitors. I threw out the Apple Cinema Display and in their place took 4K monitors from Dell. As a printer, I liked the previou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Screen with an infinite number of pixels</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e55/565/86e/e5556586e98f36032fdd2a5341f9143f.jpg" alt="image"><br><br>  Last week I updated my monitors.  I threw out the Apple Cinema Display and in their place took 4K monitors from Dell.  As a printer, I liked the previous upgrade from black and white to grayscale monitors in the 90s.  But 4K is even better.  High-resolution displays have already arrived on smartphones and tablets.  It's nice that they appear in laptops and dekstopov.  Fonts look wonderful. <br><br>  Although - good fonts look wonderful.  The bad ones look worse - they can no longer hide behind the poorly visible edges of coarse pixels.  If you work with text - read, write, program, draw (and this covers almost all professions), then the 4K upgrade is worth it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/3c8/fa5/0f0/3c8fa50f0c52e208ec761106d02e07da.jpg" alt="image"><br><br>  But what is "4K"?  With a light hand of marketers, this is a screen of 3840 by 2160 pixels (3840 is almost 4000).  On each side, the resolution is twice as large as that of HDTV, that is, 1920x1080. <br><br>  At first, people said that 4K screens had ‚Äútwice as many pixels‚Äù.  In fact, if you double the number of pixels linearly, it‚Äôs like you cut each pixel both vertically and horizontally.  That is, on a 4K screen 4 times more pixels than HDTV. <br><br>  And, characteristically, no one is going to stop at this, on the horizon there are already 7680 x 4320 displays, known as 8K.  On the other hand, the resolution perceived by the human eye has limits.  The transition to 4K is noticeable.  At 8K - less noticeable.  At some point, you will need to stop dividing the pixels. <br><br>  But what if they don't stop?  What if they divide pixels endlessly?  How many pixels will there be on the screen? <br><br>  a) by the number of positive integers <br>  b) less <br>  c) more <br><br>  If you are not interested in mathematics, then the result of the article is: buy a 4K monitor.  Do not mention it. <br><a name="habracut"></a><br><h4>  Compare infinity </h4><br>  To begin with, you may be surprised at point c), which refers to a number greater than the number of positive integers.  Isn't their number infinite?  Infinity - this is "plenty"?  Yes? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b4/7e9/7f0/3b47e97f0ad9a7022a271767895ce61b.jpg" alt="image"><br>  <i>Georg Cantor looks at you as beginning mathematicians</i> <br><br>  Not really.  When the German mathematician Georg Cantor began his activities in the 1860s, infinity has been used in mathematics for quite some time.  But with them there were always some vagueness and understatement.  Cantor explained everything. <br><br>  One of the questions he studied is the size of all infinite sets the same?  But how to compare infinite sets?  If we had finite sets, we could recalculate them.  Who has more elements, he won. <br><br>  OK, we cannot count the infinite multitude directly.  But imagine that we cannot recalculate a finite set directly.  How can we imagine, for example, the number five?  You can show your hand and say "here are so many fingers."  That is, we compare the number of known set - the number of fingers.  The number of elements of a set is also called its capacity.  If we have a set of a certain power, we can compare it with other sets, comparing the elements of one set with the elements of another.  If the two sets have a one-to-one correspondence of all the elements, their sets are equal. <br><br>  For example, we want to know the power of many toes.  We can touch each finger to our toes.  Therefore, we conclude that the powers of the finger and arm sets are equal. <br><br>  And if we have two bags of objects and we need to compare, do they contain the same number of them, without counting them?  We can take out one piece from each bag until they run out in one of the bags.  If at this moment they end in another, their powers are equal.  And this method does not depend on the number of things. <br><br>  So Cantor thought so: although we cannot count the infinities, we can compare their powers.  If they coincide, then we can make a one-to-one correspondence (bijection) from the two sets.  Or, we can prove that there is no such correspondence - then the power of one of the sets is greater. <br><br>  Bijection is a simple, but also useful tool for work.  For example, we can find out the answer to the question of which integers are more - all positive or only even.  One could simply answer that there are more positive ones, because the set of positive ones includes both even and odd ones. <br><br>  But it is not.  A bijection shows that we can put into correspondence sets of positive numbers and even numbers: <br><br>  1, 2, 3, 4, ... <br>  2, 4, 6, 8, ... <br><br>  And no matter how far we go - there is always an element in one set that corresponds to an element in another.  Therefore, the power of these sets is the same.  It sounds strange, but it is. <br><br><h4>  Big infinity </h4><br>  To show that the power of one set is greater than another, it is necessary to prove that there is no bijection for them.  And Kantor has shown that this is possible.  His proof uses diagonalization and is as follows. <br><br>  Cantor started with an infinitely long binary string: <br><br>  10010101001011101010 ... <br><br>  Then he thought about the set of all such lines: <br><br>  10010101001010101010 ... <br>  01001010100101001001 ... <br>  10010011110001001000 ... <br>  ... <br><br>  And he asked: how many of them exist?  Obviously, an infinite number.  And we can find a bijection with positive integers by simply listing all these lines in some way: <br><br>  1: 10010101001010101010 ... <br>  2: 01001010100101001001 ... <br>  3: 10010011110001001000 ... <br>  four:‚Ä¶ <br><br>  If such a bijection is possible, then the set of infinite binary lines has the same capacity as the set of positive integers. <br><br>  And then suddenly Kantor notes that if we select the nth digit in the nth line and compose a new infinite number of them, replacing 0 with 1 and 1 with 0, we will get a new line: <br><br>  1: <b>1</b> 0010101001010101010 ... <br>  2: 0 <b>1</b> 001010100101001001 ... <br>  3: 10 <b>0</b> 10011110001001000 ... <br>  four:‚Ä¶ <br><br>  001 ... <br><br>  The resulting string will also be infinite and binary.  So she will belong to our set.  But she will not be in a beection.  Why?  Because we built it this way: the new line is different from any line in our list by at least 1 character. <br><br>  In other words, in any way to match the set of infinite binary strings with the set of positive integers, you can always construct such a line that is not included in the bijection.  That is, a bijection is impossible.  Therefore, although both sets are infinite, the power of the set of infinite binary strings is greater. <br><br>  These two different powers are quite common, so they have their own names.  The power of the set of positive integers is called countable.  A set with the same capacity as a set of infinite binary strings is called uncountable. <br><br><h4>  Back to the screen with an infinite number of pixels </h4><br>  Remember that pixels are divided on the screen an infinite number of times?  Now we know that our "infinity" refers to countable infinity.  Why?  Because we can create a bijection between positive integers and pixel division. <br><br>  If we start with a giant pixel: <br><br><table><tbody><tr><td></td></tr></tbody></table><br><br>  In step 1, divide it in half horizontally: <br><br><table><tbody><tr><td></td></tr><tr><td></td></tr></tbody></table><br><br>  Step 2 - Vertical <br><br><table><tbody><tr><td></td><td></td></tr></tbody></table><br><br>  On 3, we divide everything horizontally <br><br><table><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><br><br>  4 - vertical <br><br><table><tbody><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><br><br>  Etc. <br><br>  Each section corresponds to a positive integer, so we get a bijection with a countable infinite set. <br><br>  And how many pixels do we get?  An infinite number.  Moreover, since we have made a countable infinite number of cuts, we must get a countable infinite number of pixels.  Or not? <br><br>  Could it be that we suddenly get an uncountable infinite number of pixels?  Let's try to make a bijection between the number of pixels and some uncountable infinite set.  For example, the same set of infinite binary lines. <br><br>  10010101001010101010 ... <br>  01001010100101001001 ... <br>  10010011110001001000 ... <br>  ... <br><br>  Recall that we made our screen by cutting a pixel either vertically or horizontally.  Each of the binary lines can be mapped to a specific pixel on the screen using numbers from a string. <br><br>  In the first step, we made a horizontal cut.  If the first digit in the line is 0, we select the top of the pixel.  If 1 is lower. <br><br><table><tbody><tr><td><code>0...</code> </td> </tr><tr><td> <code>1...</code> </td> </tr></tbody></table><br><br>  In the second step, we made a vertical cut.  Then, if our second number is 0, we select the left half of the pixel.  If 1 is right. <br><br><table><tbody><tr><td> <code>00...</code> </td> <td> <code>01...</code> </td> </tr></tbody></table><br><br>  Now we just repeat this process - the numbers will indicate top or bottom, then left or right.  After step 4: <br><br><table><tbody><tr><td> <code>0000...</code> </td> <td> <code>0001...</code> </td> <td> <code>0100...</code> </td> <td> <code>0101...</code> </td> </tr><tr><td> <code>1000...</code> </td> <td> <code>1001...</code> </td> <td> <code>1100...</code> </td> <td> <code>1101...</code> </td> </tr></tbody></table><br><br>  Further cells will decrease, and binary lines will increase.  And we get one-to-one correspondence of each pixel to each infinite binary string.  That is, we get a bijection.  And, since the number of infinite binary strings is uncountable, then the number of pixels is uncountable. <br><br><h4>  Cunningham Act: the best way to get an answer online is to publish the wrong </h4><br>  After the first publication of the article, I received letters that indicated a gap in the reasoning.  And in the end it turned out that the screen with an infinite number of pixels contains a countable number of them. <br><br>  Find a gap in the reasoning.  I stated that the pixel cutting technology would allow each pixel to be assigned to each infinite binary string.  Several readers tried to find a contradiction with the help of diagonalization, saying that you can think of a way to make a line that does not correspond to a pixel.  But it is not. <br><br>  Because the problem of my bijection is not in the fact that it cannot attach every infinite binary string, but in the fact that it cannot attach any of them. <br><br>  Although each line is infinite, it corresponds to the exact number - a certain point on the screen.  This should not confuse you.  For example, remember that the number 1/3 is on the segment between 0 and 1. But the decimal notation of this number is infinite 0.3333 (3).  The more digits we add, the closer to 1/3.  And while 1/3 is the limit of this series of numbers after the decimal point, it will never be recorded exactly.  In a sense, the limit is ‚Äúbeyond‚Äù a series of approximations. <br><br>  So the pixels in my design represent approximations of infinite binary strings, being their limits.  But since there is no way to add 0.3333 (3) to exactly 1/3, there is no way to find a pixel until you reach a certain point represented by a specific infinite binary string.  Therefore, my assumption about the bijection was false. <br><br>  By adopting the idea that each pixel is an approximation, we can use our design to recalculate pixels.  Let's enumerate the initial pixel 1. <br><br><table><tbody><tr><td> <code>1</code> </td> </tr></tbody></table><br><br>  Now we add a binary digit each time we divide a pixel in the same way as before: <br><br><table><tbody><tr><td> <code>10</code> </td> </tr><tr><td> <code>11</code> </td> </tr></tbody></table><table><tbody><tr><td>  <code>100</code> <code>101</code> </td><td>  <code>110</code> <code>111</code> </td></tr></tbody></table><br><br>  Jump to step 4: <br><br><table><tbody><tr><td> <code>10000</code> </td> <td> <code>10001</code> </td> <td> <code>10100</code> </td> <td> <code>10101</code> </td> </tr><tr><td> <code>11000</code> </td> <td> <code>11001</code> </td> <td> <code>11100</code> </td> <td> <code>11101</code> </td> </tr></tbody></table><br><br>  Thus, you can assign a unique integer (whether binary or decimal) to each pixel.  The total number of pixels is infinite, but any infinite subset of positive integers can be found a bijection with many positive integers.  Therefore, there will be no more pixels than integers. <br><br><h4>  Bonus </h4><br>  What about endless binary strings?  It turns out that there are more of them (since their set is uncountable) than the pixels on the screen (since their set is countable).  Can we put these two infinities in any correspondence?  I think so. <br><br>  Cantor's theorem says that for any set of objects, the set of their subsets is always greater (that is, it has more power).  This is easy to see with a small set.  The set of three elements {x, y, z} has eight subsets: {x}, {y}, {z}, {x, y}, {x, z}, {y, z}, {x, y , z} and {} (empty).  This set of subsets is also known as the degree of a set, or boolean. <br><br>  How big is a boolean?  Creating a subset, we essentially make several decisions about whether or not to include each element.  That is, in the set {x, y, z} there are three elements, and three solutions.  And since  each decision has two options (to accept and not to accept), then the number of possible subsets is 2 * 2 * 2 = 8. That is, for a finite set the size of the boolean will be 2 to the extent of the number of elements of the set. <br><br>  The trick of Cantor's Theorem is that it also works for infinite sets.  Consider a boolean of positive integers - that is, all possible subsets of positive integers.  A boolean itself will be an infinite set, but, according to Cantor's Theorem, will also have more power than a set of positive integers. <br><br>  This idea, with the fact that one is more than another, still seems strange and abstract.  Let's go back to our screen with an infinite number of pixels.  Let's see how we can denote these subsets.  Each subset is a set of solutions to include / not include, therefore we can designate inclusion by ‚Äú1‚Äù, and not inclusion - by ‚Äú0‚Äù.  Then we just need to write one digit for each of the positive integers: <br><br>  10010101001011101010 ... <br><br>  So a complete boolean for positive integers will look something like this: <br><br>  10010101001010101010 ... <br>  01001010100101001001 ... <br>  10010011110001001000 ... <br>  ... <br><br>  Familiar.  We returned to the Cantor set of infinite binary strings.  Recall that the diagonalization showed that this set has more power than whole numbers.  Cantor's theorem says the same thing, but only in relation to the boolean. <br><br><h4>  Too many bits </h4><br>  A sequence of zeros and ones reminds us of a bitstream.  If a boolean can be written as a sequence of bits, is it possible to somehow describe it in informational terms? <br><br>  Well, then.  Consider a boolean as a measure of the information capacity of a set.  We have seen that the set of three elements {x, y, z} can be used to create eight different subsets.  It's like three bits in a computer can express eight numbers.  Such equivalence will be preserved for any finite set.  And according to the Cantor Theorem - and for the infinite too. <br><br>  Check it out.  We have a screen of countable infinity pixels.  Pixels are suitable for us, since they are needed just to display information.  Let they can take only two colors - white (on) and black (off). <br><br>  Turn on the computer.  There will be a bitmap on the screen.  It is defined as a set of white pixels - which will be a subset of the whole screen.  Of course, when using a computer, the image changes, and we get different subsets of pixels. <br><br>  So: how many bitmaps can be displayed on the screen with an infinite number of pixels?  That is, what is the information capacity of such a screen? <br><br>  Since any selected image is represented by a subset of pixels, the set of all possible images is the set of all possible subsets of pixels, that is, boolean.  And the boolean of a countable set is an uncountable set. <br><br>  It turns out that, despite the fact that our screen can only contain a countable infinite number of pixels, it will be able to display an uncountable infinite number of images.  If you need a presentation of a set of infinite binary lines - then take such a screen, because it will be able to display them all. <br><br>  Well, otherwise just update the display to 4K.  It will have a lot of pixels. <br><br><h4>  Reader Exercise </h4><br>  If we build our screen from an infinite number of pixels of a given size that will make up an infinite grid - will there be more pixels on this screen than on our original screen, less, or as many? </div><p>Source: <a href="https://habr.com/ru/post/259217/">https://habr.com/ru/post/259217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259207/index.html">The digest of interesting materials from the world of web development and IT for the last week? 162 (May 15 - 31, 2015)</a></li>
<li><a href="../259209/index.html">Comparison of PHP7 and Hack type systems</a></li>
<li><a href="../259211/index.html">Delays are a stumbling block to the Internet of Things</a></li>
<li><a href="../259213/index.html">We write a simple code analyzer on Roslyn</a></li>
<li><a href="../259215/index.html">Application KolibriOS. Part 2: Core Exposure for Iron Developers</a></li>
<li><a href="../259219/index.html">Cheat sheet on mongodb: e-commerce, migration, frequently used operations and a little about transactions</a></li>
<li><a href="../259223/index.html">jQuery is considered harmful</a></li>
<li><a href="../259225/index.html">Gulp.watch: catch errors correctly</a></li>
<li><a href="../259227/index.html">Network warrior. Demand study</a></li>
<li><a href="../259229/index.html">Some aspects of pricing policy in the field of information recovery services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>