<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interception of API function calls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Dad, I ran for the trolley and saved five kopecks! 
 - Son, would run for a taxi - would save five rubles! 
 

 Today I want to tell you how to save...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interception of API function calls</h1><div class="post__text post__text-html js-mediator-article">  <em>- Dad, I ran for the trolley and saved five kopecks!</em> <em><br></em>  <em>- Son, would run for a taxi - would save five rubles!</em> <em><br></em> <br><br>  Today I want to tell you how to save 10 thousand dollars.  And at the same time, what is much less interesting is to teach how to intercept calls to Win32 API functions, and not only.  Although, first of all - of course, it is them. <br><a name="habracut"></a><br><br><h1>  Main provisions </h1><br>  There are exactly two well-known methods for intercepting API functions, all the rest are their variations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The idea of ‚Äã‚Äãthe first method is based on the fact that calls of any functions in the process from third-party DLLs are performed through the function import table.  This table is populated when the DLL is loaded into the process and the addresses of all imported functions that the process may need are specified in it.  Accordingly, in order to intercept an API function call, it is necessary to find the import table, in it, the function we want to intercept, save the address stored there (the same pointer to the function body) to some variable (to be able to call original), after which place a pointer to its function.  Naturally, this must be done for each module (exe or dll), which is in the process, since each of them has its own import table.  In addition, to implement the interception of functions that are called using the late binding mechanism, you should likewise infiltrate the export table of the module that exports this function (this time, only into one) and make a similar replacement.  After that, you should prevent the unloading of your DLL for the duration of the interception (for example, DllCanUnloadNow should return false, or make an extra Lock), so that during the dll operation it will not be unloaded, the interception address will not become invalid and you will not get access violation with all the consequences. <br><br>  This method, in principle, has been repeatedly described in the relevant literature, and ready-made implementations can be found, for example, on the RSDN <a title="How to replace the API function?" href="">[1]</a> , <a title="Interception of API functions in Windows NT / 2000 / XP" href="">[2]</a> .  Therefore, we will not dwell on it. <br><br>  Much more interesting is the second method - interception of a function through code injection.  His idea is also quite primitive, and has been repeatedly described.  All we need is to overwrite the first few bytes of the original function code, inserting the unconditional transition instruction to our interceptor function, perform the necessary processing, then, if we need to call the original function, first execute the code of the erased function start, then do unconditional transition to the body of the original function, skipping, of course, the worn beginning. <br><br>  It sounds simple enough, however, for a person who has written all his life in high-level languages, it can become an insoluble task.  The problem is further complicated by the fact that there are no definite problems, which I will discuss a little later, of ready-made implementations of this method.  Although ... of course, I'm a little cunning.  Microsoft has a whole framework dedicated to solving exactly this problem.  It is called Microsoft Detours <a title="Software packaged for detouring Win32 and application APIs." href="http://research.microsoft.com/en-us/projects/detours/">[3]</a> , easily googled and costs 10 thousand dollars for the commercial version. <br><br>  Naturally, for such money they will buy it only if it is necessary.  And if it‚Äôs not really necessary, but I want to - then my implementation of the second method, which I will describe here now, will do.  Naturally, this implementation is far from universal, but some features of the Win32 API allow it to work in our applications and successfully replace the expensive framework. <br><br><h1>  Implementation of code injection method </h1><br><br>  Let's start from the beginning.  Let's prepare a small test stand for ourselves on which we will check the success of our actions.  This will be a console project in C ++.  For development, I will use MS Visual Studio 2010 BETA, and you can adjust my actions depending on the IDE used. <br><br><blockquote><code><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> <font color="black">Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> <ol> <li> <code><font color="black"><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> </li> <li> <code><font color="black"><a href="http://s-c.me/6492/s"></a> <a href="http://s-c.me/6492/h"></a> Copy Source | Copy HTML <font color="#0000ff">int</font> _tmain( <font color="#0000ff">int</font> argc, _TCHAR* <font color="#2b91af">argv</font> []) { HANDLE hFile = CreateFile(L <font color="#A31515">"d:\\test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); CloseHandle(hFile); <font color="#0000ff">return</font> <font color="#A31515">0</font> ; }</font></code> </li> </ol></blockquote><br><br>  Our task will be to intercept the CreateFile and CloseHandle functions. <br><br>  So let's start from the beginning.  Run the program for execution by setting the breakpoint on the CreateFile function.  As soon as the program stops, select the Go To Disassembly item in the context menu of our code.  And that's what we'll see there. <br><br><blockquote> <code><font color="black">HANDLE hFile = CreateFile(L"d:\\test.txt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); <br> 01138A8B mov esi,esp <br> 01138A8D push 0 <br> 01138A8F push 80h <br> 01138A94 push 2 <br> 01138A96 push 0 <br> 01138A98 push 0 <br> 01138A9A push 40000000h <br> 01138A9F push offset string L"d:\\test.txt" (11415B0h) <br> 01138AA4 call dword ptr [__imp__CreateFileW@28 (114527Ch)] <br> 01138AAA cmp esi,esp <br> 01138AAC call @ILT+1000(__RTC_CheckEsp) (11313EDh) <br> 01138AB1 mov dword ptr [hFile],eax <br></font></code> </blockquote><br><br>  Now, pressing F10, we reach the instruction call dword ptr [__imp__CreateFileW @ 28 (114527Ch)] - this, in fact, is the function call, and press F11.  We‚Äôll get into the body of the CreateFile function. <br><br><blockquote> <code><font color="black">76D60B7D mov edi,edi <br> 76D60B7F push ebp <br> 76D60B80 mov ebp,esp <br> 76D60B82 push ecx <br> 76D60B83 push ecx <br> 76D60B84 push dword ptr [ebp+8] <br> 76D60B87 lea eax,[ebp-8] <br> 76D60B8A push eax <br> 76D60B8B call dword ptr ds:[76D11568h] <br></font></code> </blockquote><br><br>  So what we see here? <br><br>  The first command is mov edi, edi is nothing more than a two-byte nop (not an operation).  The point of this command is to gobble up one processor cycle without doing anything.  Well, at the same time, take two bytes in the code.  It would seem, what a waste, however, the presence of this instruction is very useful for us. <br><br>  The next two commands take three bytes and they do the following.  The esp register, as is known, points to the top of the stack, in which all parameters passed to the function are stored via the push instruction.  At the top of the esp register (in the assembler, this address is written as [esp]) is the return point address, which is placed there by the instruction call (in our case, it will be 0x01138AAA), and then, up the stack (the stack is known to grow down) at [esp + 4] is the file name, [esp + 8] is the opening parameters, and so on. <br><br>  The stack also contains local variables that are used by the function itself.  If you look closely at the code, you will see two instructions. <br><br><blockquote> <code><font color="black">76D60B82 push ecx <br> 76D60B83 push ecx <br></font></code> </blockquote><br><br>  These instructions simply reserve 8 bytes per stack, that is, they leave room for two DWORD variables.  This call is interpreted in this way because the function uses the stdcall calling convention (that is, it passes parameters through the stack, not through registers, such as fastcall), and the ecx register is a general-purpose register, and if the function did not put any -or the values, then it can contain any garbage that was left there by the previous code.  There is no sense in transmitting any garbage data to the parent function, so we interpret this call in this way. <br><br>  However, after executing the push instruction, the top of the esp stack will move 4 bytes down, and [esp] will no longer point to the return point address, but to the garbage value just put there.  That is, we will lose access to the variables passed to the function!  This can not be allowed, but because the next thing is done. <br><br><blockquote> <code><font color="black">76D60B7F push ebp <br> 76D60B80 mov ebp,esp <br></font></code> </blockquote><br><br>  The stack stores the current value of the base register, and the current register register is placed in the base register.  Now we can address the variables passed to the function through the base register (at [ebp] we have the stored value of the stack register, [ebp + 4] is the return point address, [ebp + 8] is the file name, etc.) by freely manipulating the stack. <br><br>  This pair of instructions (push ebp / mov ebp, esp) is called a standard prolog and has its own mirror image - a standard epilogue that looks like this: <br><br><blockquote> <code><font color="black">pop ebp <br></font></code> </blockquote><br><br>  However, here we will not find it - it is replaced by the leave command, which does the same. <br><br><blockquote> <code><font color="black">76D60BC7 leave <br> 76D60BC8 ret 1Ch <br></font></code> </blockquote><br><br>  The last command is a return from a function, removing 0x1c bytes from the stack, which is required by stdcall agreement, when the function is required to clear the stack itself after the work is finished. <br><br>  After analyzing other API functions, you can understand that they all start in exactly the same way: <br><br><blockquote> <code><font color="black">mov edi,edi <br> push ebp <br> mov ebp,esp <br></font></code> </blockquote><br><br>  That is, in 99% of cases, for us, ‚Äúhousehold‚Äù interception is guaranteed at the beginning of the function 5 bytes, which we can safely replace with our code, and then restore it somewhere else.  This is good, so the size limit of our jump instruction can be 5 bytes.  This is more than enough. <br><br>  So, now we have figured out how the function call occurs and are ready for its interception.  Only one detail remains - how can you actually intercept? <br><br>  For this, all we need is to put the jmp instruction at the beginning of the function with the address that will indicate the beginning of our function.  However, not all so simple.  The fact is that the jmp instruction that would take the absolute address of our function, 5 bytes in size, simply does not exist.  The only jump that works with absolute addresses is jump far, which takes 6 bytes. <br><br>  Therefore, we will use jump near, which takes a relative address (that is, the difference between the address of the destination point and the instruction following the jump near).  In fact, to calculate the operation parameter jump near, you need to subtract the address of the starting point from the address of the destination point and add 5 bytes (this is how much this instruction takes). <br><br><blockquote> <code><a href="http://s-c.me/6495/s"></a> <a href="http://s-c.me/6495/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  size_t _CalculateDispacement ( <font color="#0000ff">void</font> * lpFirst, <font color="#0000ff">void</font> * lpSecond) </li><li>  { </li><li>  <font color="#0000ff">return</font> reinterpret_cast &lt; <font color="#0000ff">char</font> *&gt; (lpSecond) - (reinterpret_cast &lt; <font color="#0000ff">char</font> *&gt; (lpFirst) + <font color="#A31515">5</font> ); </li><li>  } </li></ol></blockquote><br><br>  Turning to the literature, we learn that the jump near opcode is 0xe9.  Thus, we can perform interception as follows: <br><br><blockquote> <code><a href="http://s-c.me/6494/s"></a> <a href="http://s-c.me/6494/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  HANDLE WINAPI _My_CreateFileW (LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurity, DWORD dwCreationDisp, DWORD dwFlags, HANDLE hTemplate) </li><li>  { </li><li>  OutputDebugStringA (__ FUNCTION__); </li><li>  <font color="#0000ff">return</font> (HANDLE) - <font color="#A31515">1</font> ; </li><li>  } </li><li></li><li></li><li>  <font color="#cc6633">#pragma</font> pack (push, <font color="#A31515">1</font> ) </li><li>  <font color="#0000ff">struct</font> <font color="#2b91af">jump_near</font> </li><li>  { </li><li>  BYTE opcode;  <font color="#008000">// 0xe9</font> </li><li>  DWORD relativeAddress; </li><li>  }; </li><li>  <font color="#cc6633">#pragma</font> pack (pop) </li><li></li><li>  <font color="#0000ff">int</font> _tmain ( <font color="#0000ff">int</font> argc, _TCHAR * <font color="#2b91af">argv</font> []) </li><li>  { </li><li>  HMODULE hKernel32 = GetModuleHandle (L <font color="#A31515">"kernel32.dll"</font> ); </li><li>  <font color="#2b91af">jump_near</font> * lpFunc = reinterpret_cast &lt; <font color="#2b91af">jump_near</font> *&gt; (GetProcAddress (hKernel32, <font color="#A31515">"CreateFileW"</font> )); </li><li>  lpFunc-&gt; opcode = 0xe9; </li><li>  lpFunc-&gt; relativeAddress = _CalculateDispacement (lpFunc, &amp; _My_CreateFileW); </li><li></li><li>  HANDLE hFile = CreateFile (L <font color="#A31515">"d: \\ test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); </li><li>  CloseHandle (hFile); </li><li>  <font color="#0000ff">return</font> <font color="#A31515">0</font> ; </li><li>  } </li></ol></blockquote><br><br>  In order to eliminate the parasitic effects of optimization by the compiler of structures to align the data sections, we use the #pragma pack directive, which, in our case, aligns the data to a byte boundary (that is, it does not align at all). <br><br>  We launch for execution, and ... op, access violation.  The fact is that the code pages, for protection against buffer overflow, are write-protected. <br><br>  However, not everything is so bad.  They are protected from the outside, and we work from the inside, and therefore we can bypass this mechanism using the VirtualProtect function.  Put before the recording opcode call: <br><br><blockquote> <code><font color="black">DWORD dwProtect = PAGE_READWRITE; <br> VirtualProtect(lpFunc, sizeof(jump_near), dwProtect, &amp;dwProtect); <br></font></code> </blockquote><br><br>  And after the call: <br><br><blockquote> <code><font color="black">VirtualProtect(lpFunc, sizeof(jump_near), dwProtect, &amp;dwProtect); <br></font></code> </blockquote><br><br>  We start on performance - and, voila, interception is carried out. <br><br>  Now, there is a second problem - we need to call the original function.  For this, we must do the following: <br>  1. Save the pointer to the beginning of the function. <br>  2. Create a block of 10 bytes in memory with permissions to execute the code (without them, when trying to execute the code, we will receive an access violation due to the implementation of the NX-Bit protection system) <br>  3. Copy there the first 5 bytes of the original function before installing the interceptor there. <br>  4. Create in the last 5 bytes a similar instruction jump near, which will forward the execution of the function to the original handler, passing 5 bytes overwritten by us. <br>  5. Save the address of a 10-byte block and bring it to the CreateFileWProc type, which is described as follows: <br>  typedef HANDLE (WINAPI * CreateFileWProc) (LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE); <br>  6. Now, if we need to call the original, we simply use this pointer. <br><br>  The code that implements this functionality in a more general case is available here: <br><br>  <a href="http://pastebin.com/5gZdr6Hm">pastebin.com/5gZdr6Hm</a> (header file Detours.h) <br>  <a href="http://pastebin.com/RCJ896TM">pastebin.com/RCJ896TM</a> (implementation of Detours.cpp) <br><br>  I will briefly tell you how this works in the end. <br><br>  Let's connect both files to our project, define a couple of interceptors and run the code for execution from the breakpoint on CreateFile. <br><br><blockquote> <code><a href="http://s-c.me/6496/s"></a> <a href="http://s-c.me/6496/h"></a> <font color="black">Copy Source | Copy HTML</font></code> <ol> <li>  <font color="#cc6633">#include</font> <font color="#A31515">"Detours.h"</font> </li><li></li><li>  typedef HANDLE (WINAPI * CreateFileWProc) (LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE); </li><li>  typedef BOOL (WINAPI * CloseHandleProc) (HANDLE); </li><li></li><li>  CreateFileWProc _Std_CreateFileW; </li><li>  CloseHandleProc _Std_CloseHandle; </li><li></li><li>  HANDLE WINAPI _My_CreateFileW (LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurity, DWORD dwCreationDisp, DWORD dwFlags, HANDLE hTemplate) </li><li>  { </li><li>  OutputDebugStringA (__ FUNCTION__); </li><li>  <font color="#0000ff">return</font> _Std_CreateFileW (lpFileName, dwDesiredAccess, dwShareMode, lpSecurity, dwCreationDisp, dwFlags, hTemplate); </li><li>  } </li><li></li><li>  BOOL WINAPI _My_CloseHandle (HANDLE handle) </li><li>  { </li><li>  OutputDebugStringA (__ FUNCTION__); </li><li>  <font color="#0000ff">return</font> _Std_CloseHandle (handle); </li><li>  } </li><li></li><li>  <font color="#0000ff">int</font> _tmain ( <font color="#0000ff">int</font> argc, _TCHAR * <font color="#2b91af">argv</font> []) </li><li>  { </li><li>  HMODULE hKernel32 = GetModuleHandle (L <font color="#A31515">"kernel32.dll"</font> ); </li><li>  <font color="#0000ff">void</font> * lpFunc = GetProcAddress (hKernel32, <font color="#A31515">"CreateFileW"</font> ); </li><li>  Detours :: HookFunction (lpFunc, _My_CreateFileW, reinterpret_cast &lt; <font color="#0000ff">void</font> **&gt; (&amp; _ Std_CreateFileW)); </li><li>  lpFunc = GetProcAddress (hKernel32, <font color="#A31515">"CloseHandle"</font> ); </li><li>  Detours :: HookFunction (lpFunc, _My_CloseHandle, reinterpret_cast &lt; <font color="#0000ff">void</font> **&gt; (&amp; _ Std_CloseHandle)); </li><li>  HANDLE hFile = CreateFile (L <font color="#A31515">"d: \\ test.txt"</font> , GENERIC_WRITE, <font color="#A31515">0</font> , NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); </li><li>  CloseHandle (hFile); </li><li>  <font color="#0000ff">return</font> <font color="#A31515">0</font> ; </li><li>  } </li></ol></blockquote><br><br>  Out of habit, go to Disassembly, get to the instructions <br><br><blockquote> <code><font color="black">000D8AD0 call dword ptr [__imp__CreateFileW@28 (0E527Ch)] <br></font></code> </blockquote><br><br>  And press F11. <br><br>  Where are we? <br><br><blockquote> <code><font color="black">76D60B7D jmp _My_CreateFileW (0D13E8h) <br></font></code> </blockquote><br><br>  This is the transition code set by our interceptor.  This means that the interception was successful! <br><br>  Press F10 a couple of times (skipping one more intermediate buffer, which the compiler puts in the DEBUG versions), and ... <br><br><blockquote> <code><font color="black">HANDLE WINAPI _My_CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurity, DWORD dwCreationDisp, DWORD dwFlags, HANDLE hTemplate) <br> { <br> 000D8910 push ebp <br> 000D8911 mov ebp,esp <br> 000D8913 sub esp,0C0h <br> 000D8919 push ebx <br> 000D891A push esi <br> 000D891B push edi <br> 000D891C lea edi,[ebp-0C0h] <br> 000D8922 mov ecx,30h <br> 000D8927 mov eax,0CCCCCCCCh <br> 000D892C rep stos dword ptr es:[edi] <br></font></code> </blockquote><br><br>  Now, the most interesting moment.  Let's get to the original function call. <br><br><blockquote> <code><font color="black">000D8960 call dword ptr [_Std_CreateFileW (0E4240h)] <br></font></code> </blockquote><br><br>  And press F11. <br><br><blockquote> <code><font color="black">00060000 mov edi,edi <br> 00060002 push ebp <br> 00060003 mov ebp,esp <br> 00060005 jmp 76D60B82 <br></font></code> </blockquote><br><br>  We hit the so-called springboard - this is a piece of code that performs the operations we have replaced and transfers control to the original function.  Let's get to jmp, hit F10 and see a wonderful picture. <br><br><blockquote> <code><font color="black">76D60B7D jmp _My_CreateFileW (0D13E8h) <br> 76D60B82 push ecx <br> 76D60B83 push ecx <br></font></code> </blockquote><br><br>  This time we skipped the jmp instruction and immediately got on the first significant instruction - push ecx.  So everything works as it should. <br><br><h1>  Potential problems and opportunities for modernization </h1><br><br>  Unfortunately, the code is not universal - it determines the possibility of interception by the presence of the standard WinAPI prolog.  It is difficult to build a universal solution - at the beginning of a function, in general, there can be absolutely any instructions, including indirect addressing instructions, which will have to be corrected during the transfer.  Microsoft Detours solves this problem by having a tabular disassembler and an instruction corrector. <br><br>  In addition, if the size of the function is less than 5 bytes, interception is simply impossible.  Such functions are sometimes found, but I have never come across tasks that require their interception.  Microsoft Detours in this case folds. <br><br>  To create a springboard function in memory, you cannot use the new and delete operators to work with dynamic memory, since the memory is allocated in the data section with the prohibition on code execution, and by changing the rights to the dynamic memory you open to detractors the ability to overflow the buffer.  Now the program works irrationally, allocating 4 KB of memory for each interceptor - this is due to the fact that this size is minimal for the allocation of virtual memory.  In theory, you need to write your own memory manager and use it.  MS Detours does this. <br><br>  However, what I wrote is quite a working code, which is useful if you really need it, but there is no money.  The absence of a table analyzer in it can be replaced with a private analyzer - to do this, you need to demobilize the required functions and analyze their code, then add signatures to _Analyze.  A 4 KB of memory per interceptor, if the program has 5-6 interceptors - not so much. <br><br><h1>  References </h1><br>  1. Barry Bray.  Intel microprocessors.  Architecture, programming and interfaces.  Sixth edition.  BHV-Petersburg, 2005 </div><p>Source: <a href="https://habr.com/ru/post/90377/">https://habr.com/ru/post/90377/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../90367/index.html">Will take the mark of 100 000 cu in the auction for the sale of the domain AM.RU?</a></li>
<li><a href="../90369/index.html">Outsourcing life, vodka, matryoshka</a></li>
<li><a href="../90370/index.html">"Developers-Developers-Developers-Developers" (c)</a></li>
<li><a href="../90373/index.html">Crossbrowser HTML Inclusion \ (^ _ ^) /</a></li>
<li><a href="../90376/index.html">How to open a studio without start-up capital</a></li>
<li><a href="../90378/index.html">New textbooks "Informatics and ICT" are already in schools</a></li>
<li><a href="../90381/index.html">Wanted to volunteer to rewrite the man2hlp utility included in Midnight Commander</a></li>
<li><a href="../90384/index.html">HTML 5 in Internet Explorer</a></li>
<li><a href="../90386/index.html">Heavy and unsightly life of an IT specialist</a></li>
<li><a href="../90388/index.html">Is Viruss-scanner.com closed? Only for the naive!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>