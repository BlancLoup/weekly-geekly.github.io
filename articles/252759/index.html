<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a Windows Runtime component in Visual C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The thorny road through the wilds of C # and the thickets of C ++ / CX development for the Windows Runtime at some point led me to the WRL template li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a Windows Runtime component in Visual C ++</h1><div class="post__text post__text-html js-mediator-article">  The thorny road through the wilds of C # and the thickets of C ++ / CX development for the Windows Runtime at some point led me to the WRL template library, which makes writing WinRT and COM applications and components easier.  When working with this library, I wanted to find out what the code hides under itself: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pch.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RAWinRT.WRL.h"</span></span></span><span class="hljs-meta"> using namespace Microsoft::WRL::Wrappers; using namespace Microsoft::WRL; using namespace ABI::RAWinRT::WRL; using namespace ABI::Windows::ApplicationModel::Background; class ABI::RAWinRT::WRL::TestTask : public RuntimeClass </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; RuntimeClassFlags&lt;WinRt&gt;, IBackgroundTask &gt; { InspectableClass(RuntimeClass_RAWinRT_WRL_TestTask, BaseTrust); public: STDMETHODIMP Run(IBackgroundTaskInstance *taskInstance) override { return S_OK; } }; ActivatableClass(TestTask);</span></span></span></span></code> </pre> <br>  and these mysterious macros, templates, library functions. <br>  And I decided to start with the simplest.  Write the Windows Runtime component, which has a single ‚Äúclass‚Äù of background task, in Visual C ++. <br><br>  If you are wondering what came out of this, then welcome under cat. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Creating and setting up a component project </h4><br>  First, I created an empty solution file in Visual Studio 2013 IDE and added a DLL project for the Windows Store application to it. <br><br><img src="https://habrastorage.org/files/a2a/5b4/48e/a2a5b448edd642e09eb6ca6523e89216.jpeg"><br><br><img src="https://habrastorage.org/files/183/398/ace/183398ace9d14b68bfce57a92e23e5ad.jpeg"><br><br>  For the project, I chose the name NMSPC.TestComponent, where NMSPC is some namespace.  I did this for demonstration purposes, since such naming is a fairly common practice when creating projects.  Also, changed the default namespace from NMSPC_TestComponent to the corresponding project name. <br><br><img src="https://habrastorage.org/files/4a9/967/593/4a99675933d8403abff9aa86ac8bf621.jpeg"><br><br>  For files, I prefer shorter names, so I renamed the header file and the source file to TetsComponent.  Before proceeding with the implementation of the component in the code, added a few additional files.  TestComponent.def is a definition file for functions exported by the dynamic library, TestComponent.idl is an interface description file. <br><br><img src="https://habrastorage.org/files/a26/a43/515/a26a4351531544db96184dec5d957650.jpeg"><br><br><img src="https://habrastorage.org/files/f96/02a/644/f9602a644f4a4b87aba5b68af82292bd.jpeg"><br><br>  Having added these files to the project, I started to set it up.  In order not to change the settings for each configuration separately, it was enough for me to select all configurations and platforms, and then proceed to editing the parameters.  The warning level settings have been set, the parameter for generating metadata has been specified, the header file generated by MIDL has been changed by the compiler header, the layout has been added with runtimeobject.lib, and a subsystem has been selected. <br><br><img src="https://habrastorage.org/files/a88/d75/c6a/a88d75c6a15f462b8326977dcfb1d85d.jpeg"><br><br><img src="https://habrastorage.org/files/382/3ce/7e6/3823ce7e6ffb4d8ba080b54bd62e05df.jpeg"><br><br><img src="https://habrastorage.org/files/619/f6d/f40/619f6df4094f4712805f2beff6db8123.jpeg"><br><br><img src="https://habrastorage.org/files/080/f3e/670/080f3e670f1b4a958e5d59e5fa7de777.jpeg"><br><br><img src="https://habrastorage.org/files/658/2ad/422/6582ad422bd7402e987f009ad0d7d6d2.jpeg"><br><br><img src="https://habrastorage.org/files/689/4f1/d7e/6894f1d7e1e049168bcd5bd22b0785e8.jpeg"><br><br>  Next, set up an additional step of building the project.  About him I will tell a little more. <br><br><img src="https://habrastorage.org/files/455/bef/8a9/455bef8a959c402794acfd4c4e3b97f6.jpeg"><br><br><img src="https://habrastorage.org/files/100/6e2/b26/1006e2b26d894193a3669231fe478fa9.jpeg"><br><br>  This step is designed to correctly generate project metadata.  The command line was set as follows: <br><br><pre> <code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">del</span></span> "$(OutDir)$(TargetName).winmd" &amp;&amp; mdmerge -partial -i "$(OutDir)." -o "$(OutDir)Output" -metadata_dir "$(WindowsSDK_MetadataPath)" &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">del</span></span> "$(OutDir)*.winmd" &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span> /y "$(OutDir)Output\*" "$(OutDir)" &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">rd</span></span> /q /s "$(OutDir)Output"</code> </pre><br>  It consists of a small number of consecutive steps, each of which performs a certain task. <ol><li>  Remove from the destination folder the project metadata file NMSPC.TestComponent.winmd. </li><li>  We combine our metadata files.  The result will be placed in the Output folder in $ (OutDir). </li><li>  Copy the metadata files from the Ouput folder to the $ (OutDir) folder. </li><li>  Delete the Output folder along with its contents. </li></ol>  Having done all these preliminary steps, I was finally able to start writing the code. <br><br><h4>  DEF, MIDL, PCH </h4><br>  Any self-respecting Windows Runtime component library should export two very important functions, DllGetActivationFactory and DllCanUnloadNow, which are used by the runtime.  The export of these functions was defined in the TestComponent.def file (they will also need to be implemented in the code, but more on that later). <br><br><pre> <code class="cpp hljs">EXPORTS DllGetActivationFactory PRIVATE DllCanUnloadNow PRIVATE</code> </pre><br>  Next, I described the class interface in the TestComponent.idl file. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"Windows.ApplicationModel.Background.idl"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> NMSPC { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> TestComponent { [version(<span class="hljs-number"><span class="hljs-number">1.0</span></span>)] [activatable(<span class="hljs-number"><span class="hljs-number">1.0</span></span>)] [marshaling_behavior(agile)] [threading(both)] runtimeclass TestBackgroundTask { [<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>] interface Windows.ApplicationModel.Background.IBackgroundTask; }; } }</code> </pre><br>  The first directive imports the file with the description of the background task interface Windows :: ApplicationModel :: Background :: IBackgroundTask.  Since this file is sufficient for the MIDL compiler, there is no need to import other interface description files (for the Windows Store 8.1 platform, interface description files and header files are located in C: \ Program Files (x86) \ Windows Kits \ 8.1 \ Include \ winrt) .  The namespace for the class was selected according to the project name NMSPC :: TestComponent.  The attributes were used to set the class version (version), a sign of the presence of a default constructor (activatable), work with threads (threading) and marshaling (marshaling_behavior).  Having compiled the data using the MIDL compiler, I got the header file TetsComponent.h. <br><br>  To reduce the compilation time, he also issued directives to include the activation.h and new header files in the pch.h file (which is used to generate precompiled header files).  The need to include these header files is explained by the dependency on the IActivationFactory interface and the std :: nothrow constant. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"targetver.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> WIN32_LEAN_AND_MEAN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIN32_LEAN_AND_MEAN </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Exclude rarely-used stuff from Windows headers #endif #include &lt;windows.h&gt; #include &lt;activation.h&gt; #include &lt;new&gt;</span></span></span></span></code> </pre><br>  It only remained to implement the class, the factory and the exported functions in the code. <br><br><h4>  Code </h4><br>  First of all, I included in the TestComponent.cpp code file, in addition to the precompiled header file, the TestComponent.h header file generated by MIDL by the compiler.  By convention, all interfaces generated by MIDL compilers are located in the ABI namespace, so the interfaces for the class and its declaration will be located in ABI :: NMSPC :: TestComponent, and the interfaces for implementing the background task in ABI :: Windows :: ApplicationModel :: Background ( I did not import the entire namespace, instead indicated the use of only separate interfaces). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pch.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"TestComponent.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     using namespace ABI::NMSPC::TestComponent; //     ABI::Windows::ApplicationModel::Background using ABI::Windows::ApplicationModel::Background::IBackgroundTask; using ABI::Windows::ApplicationModel::Background::IBackgroundTaskInstance;</span></span></span></span></code> </pre><br>  The implementation class for the background task is pretty simple.  In essence, it was necessary to implement the IUnknown, IInspectable and IBackgroundTask interfaces. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . //  "" IBackgroundTask class ABI::NMSPC::TestComponent::TestBackgroundTask sealed : public IBackgroundTask { //       ULONG m_count; public: TestBackgroundTask() throw() : m_count(1) { //      InterlockedIncrement(&amp;m_objectsCount); } ~TestBackgroundTask() throw() { //      InterlockedDecrement(&amp;m_objectsCount); } #pragma region IUnknown // COM       STDMETHODIMP_(ULONG) AddRef() throw() override final { //        return InterlockedIncrement(&amp;m_count); } // COM       STDMETHODIMP_(ULONG) Release() throw() override { //        auto const count = InterlockedDecrement(&amp;m_count); //     if (0 == count) { //  delete this; } //   return count; } // COM       STDMETHODIMP QueryInterface(const IID&amp; riid, void** ppvObject) throw() override final { //      //     IBackgroundTask  IInspectable // IInspectable  IUnknown if (__uuidof(IUnknown) == riid || __uuidof(IInspectable) == riid || __uuidof(IBackgroundTask) == riid) { *ppvObject = this; } else { *ppvObject = nullptr; //  ,      return E_NOINTERFACE; } //     //   static_cast&lt;IInspectable*&gt;(*ppvObject)-&gt;AddRef(); return S_OK; } #pragma endregion #pragma region IInspectable // WINRT       STDMETHODIMP GetIids(ULONG* iidCount, IID** iids) throw() override { //    GUID, ..       //  CoTaskMemAlloc, ..        CoTaskMemFree *iids = static_cast&lt;GUID*&gt;(CoTaskMemAlloc(sizeof(GUID))); //  NULL if (!*iids) { //    return E_OUTOFMEMORY; } //    *iidCount = 1; //    IBackgroundTask (*iids)[0] = __uuidof(IBackgroundTask); return S_OK; } // WINRT    Runtime  STDMETHODIMP GetRuntimeClassName(HSTRING* className) throw() override final { //    //   E_OUTOFMEMORY     //       if (S_OK != WindowsCreateString( RuntimeClass_NMSPC_TestComponent_TestBackgroundTask, _countof(RuntimeClass_NMSPC_TestComponent_TestBackgroundTask), className)) { return E_OUTOFMEMORY; } return S_OK; } // WINRT   TrustLevel  STDMETHODIMP GetTrustLevel(TrustLevel* trustLevel) throw() override final { *trustLevel = BaseTrust; return S_OK; } #pragma endregion #pragma region IBackgroundTask // IBackgroundTask     STDMETHODIMP Run(IBackgroundTaskInstance* task_instance) throw() override final { //      OutputDebugStringW(L"Hello from background task.\r\n"); return S_OK; } #pragma endregion };</span></span></code> </pre><br>  Now that the class was ready, it was necessary to write a class of the object factory.  This factory class must implement the IActivationFactory interface, which is defined in the activation.h header file.  This interface, in addition to IInspectable inheritance (and therefore IUnknown), defines the method <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> HRESULT STDMETHODCALLTYPE </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActivateInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* [out] */</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __RPC__deref_out_opt IInspectable **instance)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  The implementation of the GetRuntimeClassName method should also differ, as described in the documentation for the method on MSDN: <br><br>  <a href="https://msdn.microsoft.com/en-us/library/br205823(v%3Dvs.85).aspx">https://msdn.microsoft.com/en-us/library/br205823(v=vs.85).aspx</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    . class TestBackgroundTaskFactory sealed : public IActivationFactory { //       ULONG m_count; public: TestBackgroundTaskFactory() throw() : m_count(1) { //      InterlockedIncrement(&amp;m_objectsCount); } ~TestBackgroundTaskFactory() throw() { //      InterlockedDecrement(&amp;m_objectsCount); } // COM       STDMETHODIMP_(ULONG) AddRef() throw() override final { //        return InterlockedIncrement(&amp;m_count); } // COM       STDMETHODIMP_(ULONG) Release() throw() override { //        auto const count = InterlockedDecrement(&amp;m_count); //     if (0 == count) { //  delete this; } //   return count; } // COM       STDMETHODIMP QueryInterface(const IID&amp; riid, void** ppvObject) throw() override final { if (__uuidof(IUnknown) == riid || __uuidof(IInspectable) == riid || __uuidof(IActivationFactory) == riid) { *ppvObject = this; } else { *ppvObject = nullptr; return E_NOINTERFACE; } static_cast&lt;IInspectable*&gt;(*ppvObject)-&gt;AddRef(); return S_OK; } // WINRT       STDMETHODIMP GetIids(ULONG* iidCount, IID** iids) throw() override final { //    GUID, ..       //  CoTaskMemAlloc, ..        CoTaskMemFree *iids = static_cast&lt;GUID*&gt;(CoTaskMemAlloc(sizeof(GUID))); //  NULL if (*iids) { //    return E_OUTOFMEMORY; } //    *iidCount = 1; //    IBackgroundTask (*iids)[0] = __uuidof(IActivationFactory); return S_OK; } // WINRT    Runtime  STDMETHODIMP GetRuntimeClassName(HSTRING*) throw() override final { //  , ..    return E_ILLEGAL_METHOD_CALL; } // WINRT   TrustLevel  STDMETHODIMP GetTrustLevel(TrustLevel* trustLevel) throw() override final { *trustLevel = BaseTrust; return S_OK; } // IActivationFactory    STDMETHODIMP ActivateInstance(IInspectable** instance) throw() override final { //   null if (nullptr == instance) { //  return E_INVALIDARG; } //  //    ,      *instance = new (std::nothrow) TestBackgroundTask(); //        return *instance ? S_OK : E_OUTOFMEMORY; } };</span></span></code> </pre><br>  An attentive reader might have noticed a strange detail in the constructors and destructors of classes, namely, the increment and decrement of the m_objectsCount variable.  I declared this variable immediately after using directives before the code of classes.  And it is used in the DllCanUnloadNow function exported library: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       HRESULT WINAPI DllCanUnloadNow() throw() { //        return m_objectsCount ? S_FALSE : S_OK; }</span></span></code> </pre><br>  In addition to this function, another DllGetActivationFactory was defined, intended to get the factory by class identifier (in the Windows Runtime, this is a string with all namespaces included). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      ,   activatableClassId HRESULT WINAPI DllGetActivationFactory(HSTRING activatableClassId, IActivationFactory **factory) throw() { //       if (WindowsIsStringEmpty(activatableClassId) || nullptr == factory) { //       return E_INVALIDARG; } //          if (0 == wcscmp(RuntimeClass_NMSPC_TestComponent_TestBackgroundTask, WindowsGetStringRawBuffer(activatableClassId, nullptr))) { //  *factory = new (std::nothrow) TestBackgroundTaskFactory(); return *factory ? S_OK : E_OUTOFMEMORY; } *factory = nullptr; return E_NOINTERFACE; }</span></span></code> </pre><br>  Before we talk about using a component in a C # application, I will also mention the explicit implementation of the DllMain function defined in the dllmain.cpp file.  I used it only for diagnostic purposes, but the use cases may be different from mine. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pch.h"</span></span></span><span class="hljs-meta"> BOOL APIENTRY DllMain(HMODULE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* hModule */</span></span></span><span class="hljs-meta">, DWORD ul_reason_for_call, LPVOID </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* lpReserved */</span></span></span><span class="hljs-meta">) { OutputDebugStringW(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">L"Hello from DLL.\r\n"</span></span></span><span class="hljs-meta">); return TRUE; }</span></span></code> </pre><br>  This completes the implementation of the component library.  And I was able to begin its practical use in the application. <br><br><h4>  C # application </h4><br>  Having created the NMSPC.CSTestAppp application project using the Blank App template, I added references to the component project and the Microsoft Visual C ++ 2013 Runtime Package to it. <br><br><img src="https://habrastorage.org/files/d1e/100/973/d1e100973af541ebac05e63daf8bd947.jpeg"><br><br><img src="https://habrastorage.org/files/f87/d19/fc2/f87d19fc22f741b9a6e321b0eda6be9b.jpeg"><br><br><img src="https://habrastorage.org/files/ce0/430/1f7/ce04301f70b146e1984cb992c0708560.jpeg"><br><br>  It only remained to edit the application manifest file, add the definition of the background task to it, and write the code that performs the registration of the background task. <br><br><img src="https://habrastorage.org/files/ff3/a95/374/ff3a953742cb4355bfc3d6137007f928.jpeg"><br><br>  The code is placed in the OnLaunched method of the App class.  The code is simple: first removes all task registrations, then creates a buiilder object for the task, sets the trigger specified in the manifest, and registers the task. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> BackgroundTaskRegistration.AllTasks) { pair.Value.Unregister(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taskBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BackgroundTaskBuilder { Name = <span class="hljs-string"><span class="hljs-string">"TestBackgroundTask"</span></span>, TaskEntryPoint = <span class="hljs-string"><span class="hljs-string">"NMSPC.TestComponent.TestBackgroundTask"</span></span> }; taskBuilder.SetTrigger(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SystemTrigger(SystemTriggerType.TimeZoneChange, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)); taskBuilder.Register();</code> </pre><br>  In order to be able to go to breakpoints in C ++ code, set the Mixed process type (Managed and Native) in the debug settings of the application project.  By the way, this setting is also relevant for C ++ / CX applications. <br><br><img src="https://habrastorage.org/files/866/cb3/c43/866cb3c43b7042b9ab21112711f95a1d.jpeg"><br><br>  Now it was possible to start the application in debug mode, execute the component registration code and test the launch of the background task using the Lifecycle Events button in the Debug Locations section. <br><br><img src="https://habrastorage.org/files/6cc/723/092/6cc723092ab84773848984c944a59bad.jpeg"><br><br>  Having done this, I saw the most cherished lines in the Output window, the output of which was programmed in C ++ code using the OutputDebugStringW function. <br><br><pre> <code class="dos hljs">Hello from DLL. Hello from background task.</code> </pre><br><h4>  Conclusion </h4><br>  As it turned out, it is possible to write component code without using WRL.  Solving this problem allowed us to better understand the execution mechanisms and principles of interaction between the components of the Windows Runtime environment. <br>  Source code available on github <br>  <a href="https://github.com/altk/RuntimeComponent">https://github.com/altk/RuntimeComponent</a> </div><p>Source: <a href="https://habr.com/ru/post/252759/">https://habr.com/ru/post/252759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252747/index.html">Best Practices for SSL / TLS Deployment, Part 2. Configuration</a></li>
<li><a href="../252749/index.html">Detect blocked resources using Google webmaster tools</a></li>
<li><a href="../252751/index.html">High website availability: site file geo-replication with lsyncd</a></li>
<li><a href="../252753/index.html">DaData.ru prompts email and determines the city by IP</a></li>
<li><a href="../252755/index.html">Tales of the antivirus forest</a></li>
<li><a href="../252761/index.html">Optimizing the ToArray and ToList methods by providing the number of elements</a></li>
<li><a href="../252763/index.html">Virtual Link Trunking (VLT) Technology for Dell Network Factories</a></li>
<li><a href="../252767/index.html">We program in a cloud: the review popular IDE</a></li>
<li><a href="../252769/index.html">Align the modal window in the center</a></li>
<li><a href="../252771/index.html">Perspective matrices in graphic API or the devil hides in details</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>