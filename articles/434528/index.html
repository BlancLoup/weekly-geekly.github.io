<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Postcard-sized ray tracer decoding</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúHe did it again!‚Äù - this is what first came to my mind when I looked at the back of the Pixar flyer [1] , which was completely filled with code. The ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Postcard-sized ray tracer decoding</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  ‚ÄúHe did it again!‚Äù - this is what first came to my mind when I looked at the back of the Pixar flyer <sup>[1]</sup> , which was completely filled with code.  The accumulation of constructions and expressions was signed in the lower right corner by none other than Andrew Kensler.  For those who do not know him, I will say: Andrew is a programmer who invented in 2009 a 1337-byte <a href="http://fabiensanglard.net/rayTracing_back_of_business_card">ray tracer the size of a business card</a> . <br><br>  This time, Andrew came up with something more voluminous, but with a much more interesting visual result.  Since I finished writing my Game Engine Black Books about <a href="http://fabiensanglard.net/gebbwolf3d">Wolf3D</a> and <a href="http://fabiensanglard.net/gebbdoom">DOOM</a> , I had time to study the insides of its mysterious code.  And almost immediately I was literally fascinated by the techniques found in it.  They were very different from the previous work of Andrew, based on the "standard" ray tracer.  I was interested in learning about ray marching, the functions of constructive volumetric geometry, Monte-Carlo rendering / tracing, and the many other tricks he used to squeeze code into such a small piece of paper. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2>  Source </h2><br><hr><br>  The front of the flyer is an advertisement for the Pixar recruitment department.  Printed on the back side are 3,037 bytes of C ++ code obfuscated to occupy as little surface as possible. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2>  Does he even work? </h2><br><hr><br>  With the code there is an instruction for its launch.  The idea is to redirect standard output to a file.  By extension, we can assume that the output format is a text image format called NetPBM <sup>[2]</sup> . <br><br><pre>  $ clang -o card2 -O3 raytracer.cpp
 $ time ./card&gt; pixar.ppm<font></font>
<font></font>
 real 2m58.524s
 user 2m57.567s
 sys 0m0.415s </pre><br>  After two minutes and fifty eight seconds <sup>[3]</sup> , the next image is generated.  It's amazing how little code is required for it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br>  Very much can be learned from the image shown above.  Grit is an obvious sign of a path tracer.  This type of renderer differs from raytracing in that the rays are not traced back to the light sources.  In this method, thousands of rays per pixel are emitted from sources and the program watches them, hoping that they will find the source of illumination.  This is an interesting technique that is much better than ray tracing, coping with the rendering of ambient occlusion, soft shadows, caustics and radiosity. <br><br><h2>  Break the code into parts </h2><br><hr><br>  Passing input to CLion formats the code (see the output <a href="http://fabiensanglard.net/postcard_pathtracer/formatted.html">here</a> ) and breaks it up into smaller parts / tasks. <br><br><pre>  <font color="grey">#include &lt;stdlib.h&gt; // card&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey">#include &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey">#include &lt;math.h&gt;</font> </pre><br><pre>  <font color="fuchsia">#define R return</font> <font color="fuchsia">
</font>  <font color="fuchsia">#define O operator</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef float F; typedef int I;</font> </pre><pre>  <font color="blue">struct V {F x, y, z; V (F v = 0) {x = y = z = v;} V (F a, F b, F</font> <font color="blue">
</font>  <font color="blue">c = 0) {x = a; y = b; z = c;} V O + (V r) {RV (x + rx, y + ry, z + rz);} VO * (V r) {RV ( x * rx, y * r.</font> <font color="blue">
</font>  <font color="blue">y, z * rz);} FO% (V r) {R x * r.x + y * r.y + z * rz;} VO! () {R * this * (1 / sqrtf (* this% * this)</font> <font color="blue">
</font>  <font color="blue">);}};</font> </pre><pre>  <font color="orange">FL (F l, F r) {R l &lt;r? L: r;} FU () {R (F) rand () / RAND_MAX;} FB (V p, V l, V h) {l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1; h = h + p * -1; RL (L (L (lx, hx), L (ly, hy)), L (lz, hz));}</font> </pre><pre>  <font color="LimeGreen">FS (V p, I &amp; m) {F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9; V f = p; fz = 0; char l [] = "5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO "; for (I i = 0; i &lt;60; i + = 4) {V b = V (l [i] -79, l [i + 1] -79) *. 5, e = V (l [ i + 2] -79, l</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79) *. 5 + b * -1, o = f + (b + e * L (-L ((b + f * -1)% e / (e% e), 0), 1)) * - 1; d = L (d, o% o);} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf (d); V a [] = {V (-11,6), V (11,6)}; for (I i = 2; i -;) {V o = f + a [i] * -1; d = L (d, ox&gt; 0? F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf (sqrtf (o% o) -2) :( o.y + = oy&gt; 0? -2: 2, sqrtf (o% o)));} d = powf (powf (d, 8) + powf (pz ,</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8),. 125) -. 5; m = 1; F r = L (-L (B (p, V (-30, -. 5, -30), V (30,18,30)), B (p, V (-25,17, -25), V</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">(25,20,25))), B (V (fmodf (fabsf (px), 8), py, pz), V (1.5,18.5, -25), V (6.5,20,25)))</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">; if (r &lt;d) d = r, m = 2; F s = 19.9-py; if (s &lt;d) d = s, m = 3; R d;}</font> </pre><pre>  <font color="black">IM (V o, V d, V &amp; h, V &amp; n) {I m, s =</font> <font color="black">
</font>  <font color="black">0; F t = 0, c; for (; t &lt;100; t + = c) if ((c = S (h = o + d * t, m)) &lt;. 01 || ++ s&gt; 99) R n =! V (S (h + V (.01,0</font> <font color="black">
</font>  <font color="black">), s) -c, S (h + V (0, .01), s) -c, S (h + V (0,0, .01), s) -c), m; R 0;}</font> </pre><pre>  <font color="SkyBlue">VT (V o, V d) {V h, n, r, t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1, l (! V (.6, .6,1)); for (I b = 3; b -;) {I m = M (o, d, h, n); if (! M) break ; if (m == 1) {d = d + n * (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n% d * -2); o = h + d * .1; t = t * .2;} if (m == 2) {F i = n% l, p = 6.283185 * U (), c = U (), s = sqrtf (1-c),</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0? -1: 1, u = -1 / (g + nz), v = nx * ny * u; d = V (v, g + ny * ny * u, -ny) * (cosf (p) * s) + V (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u, g * v, -g * nx) * (sinf (p) * s) + n * sqrtf (c); o = h + d * .1; t = t *. 2; if (i&gt; 0 &amp;&amp; M (h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * .1, l, h, n) == 3) r = r + t * V (500,400,100) * i;} if (m == 3) {r = r + t * V (50,80,100) ; break;}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">R r;}</font> </pre><pre>  <font color="red">I main () {I w = 960, h = 540, s = 16; V e (-22,5,25), g =! (V (-3,4,0) + e * -1), l =! V (gz,</font> <font color="red">
</font>  <font color="red">0, -gx) * (1./w), u (gy * lz-gz * ly, gz * lx-gx * lz, gx * ly-gy * lx); printf ("P \</font> <font color="red">
</font>  <font color="red">6% d% d 255 ", w, h); for (I y = h; y -;) for (I x = w; x -;) {V c; for (I p = s; p- -;) c = c + T (e</font> <font color="red">
</font>  <font color="red">,! (g + l * (xw / 2 + U ()) + u * (yh / 2 + U ()))); c = c * (1./s) + 14. / 241; V o = c + 1; c = V (cx / ox, c.</font> <font color="red">
</font>  <font color="red">y / oy, cz / oz) * 255; printf ("% c% c% c", (I) cx, (I) cy, (I) cz);}}</font> </pre><pre>  <font color="LightGray">// Andrew Kensler</font> </pre><br>  Each section is described in detail in the remainder of this article: <br>  <font color="fuchsia">‚ñ†</font> - common tricks, <font color="blue">‚ñ†</font> - Vector class, <font color="orange">‚ñ†</font> - auxiliary code, <font color="LimeGreen">‚ñ†</font> - database, <font color="black">‚ñ†</font> - Ray marching, <font color="SkyBlue">‚ñ†</font> - sampling, <font color="red">‚ñ†</font> - main code. <br><br><h2>  Common tricks with #define and typedef </h2><br><hr><br>  Common tricks are using #define and typedef to significantly reduce the amount of code.  Here we denote F = float, I = int, R = return, and O = operator.  Reverse engineering is trivial. <br><br><h2>  Class V </h2><br><hr><br>  Next comes the class V, which I renamed to Vec (even though, as we will see below, it is also used to store RGB channels in float format). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br>  Note that there is no subtraction operator (-), so instead of writing "X = A - B", you use "X = A + B * -1".  The inverse square root is further useful for normalizing vectors. <br><br><h2>  Main function </h2><br><hr><br>  main () is the only character that cannot be obfuscated because it is called by the _start function of the libc library.  It is usually worth starting with it because it will be easier to work this way.  It took me some time to figure out the meanings of the first letters, but still managed to create something readable. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br>  Note that float literals do not contain the letter ‚Äúf‚Äù, and the fractional part is discarded to save space.  The same trick is used below, where the integer part is dropped (float x = .5).  Also unusual is the ‚Äúfor‚Äù construction with an iteration expression inserted into the break condition. <br><br>  This is a fairly standard main function for the ray / path tracer.  Here, camera vectors are defined and rays are emitted for each pixel.  The difference between the ray tracer and the path tracer is that several rays are emitted per pixel in the TS, which are slightly shifted randomly.  Then the color obtained for each ray in the pixel accumulates in the three float channels R, B, G.  At the end, a tonal correction of the result of the Reinhard method is performed. <br><br>  The most important part is sampleCount, which theoretically can be assigned the value 1 to speed up rendering and iterations.  Here are examples of visualizations with sample values ‚Äã‚Äãfrom 1 to 2048. <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler header</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  one <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  four <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  eight <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  sixteen <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2>  Auxiliary code </h2><br><hr><br>  Another simple code snippet is helper functions.  In this case, we have a trivial min () function, a random value generator in the interval [0,1], and a much more interesting boxTest (), which is part of the Constructive Solid Geometry (CSG) system used to cut the world.  CSG is covered in the next section. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2>  Functions of constructive volumetric geometry </h2><br><hr><br>  There are no vertices in the code.  Everything is done using the functions of the CSG.  If you are unfamiliar with them, then it is enough just to say that these are functions that describe whether the coordinate is inside or outside the object.  If the function returns a positive distance, then the point is inside the object.  A negative distance indicates that the point is outside the object.  There are many functions for describing different objects, but for the sake of simplification, let's take for example the sphere and two points, A and B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="image"></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  The testSphere () function returns -1 for point A (that is, it is outside) and 1 for B (that is, it is inside).  The signs for distances are just a trick, allowing you to get two pieces of information instead of one in the case of a single value.  A similar type of function can also be written to describe a parallelogram (this is exactly what is performed as a function of BoxTest). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br>  Now let's see what happens if we flip the sign of the return value. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br>  Now we do not describe a solid object, but declare the whole world solid and cut out empty space in it.  Functions can be used as building blocks, which, when combined with an I can combine, describe more complex shapes.  Using the logical addition operator (min function), we can cut a pair of rectangles one above the other and the result will look like this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br>  If you think about it, it looks like the room we are examining, because this is how the lower room is expressed - with the help of two parallelograms cut out. <br><br>  Now, having mastered the powerful knowledge of the CSG, we can return to the code and consider the function of the database, which is the hardest to deal with. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br>  You can see here the function of ‚Äúcutting out‚Äù a parallelogram, in which only two rectangles are used to construct the whole room (our brain does the rest, it represents that these are walls).  A horizontal ladder is a slightly more complex CSG function using division with remainder.  And, finally, the letters of the word PIXAR are composed of 15 lines with a pair of "origin / delta" and two special cases for the curves in the letters P and R. <br><br><h2>  Ray marching </h2><br><hr><br>  Having a database of CSG functions describing the world, it is enough for us to skip all the rays emitted in the main () function.  Ray marching uses the distance function.  This means that the sampling position shifts forward to the nearest obstacle. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br>  The idea of ‚Äã‚Äãray marching taking into account the distance is to move forward to the distance to the nearest object.  In the end, the beam will approach the surface so much that the point can be considered the point of falling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br>  Note that ray marching does not return a true intersection with a surface, but an approximation.  That is why the code marching stops when d &lt;0.01f. <br><br><h2>  Putting it all together: sampling </h2><br><hr><br>  Trace path research is almost complete.  We lack a bridge that would connect the main () function to ray marcher.  This last part, which I renamed ‚ÄúTrace‚Äù, is the ‚Äúbrain‚Äù in which the rays are reflected or stopped, depending on what they encounter. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br>  I experimented a bit with this feature to change the maximum number of permissible reflections of the beam.  The value ‚Äú2‚Äù gives the letters a surprisingly beautiful Vantablack lacquer paint <sup>[4]</sup> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>one</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>four</i> <br><br><h2>  Fully cleaned source code </h2><br><hr><br>  To put everything together, I created a completely clean <a href="http://fabiensanglard.net/postcard_pathtracer/formatted_full.html">source code</a> . <br><br><h2>  Reference materials </h2><br><hr><br>  [1] Source: <a href="https://twitter.com/lexfrench/status/1049196936161415169">lexfrench Twitter post October 8, 2018</a> <br><br>  [2] Source: <a href="https://en.wikipedia.org/wiki/Netpbm_format.">Wikipedia: NetPBM image format</a> <br><br>  [3] Source: <a href="http://fabiensanglard.net/postcard_pathtracer/">Visualization done on the most powerful MacBook Pro, 2017</a> <br><br>  [4] Source: <a href="https://en.wikipedia.org/wiki/Vantablack">Wikipedia: Vantablack</a> </div><p>Source: <a href="https://habr.com/ru/post/434528/">https://habr.com/ru/post/434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434516/index.html">Easy way to deal with your career aspirations</a></li>
<li><a href="../434518/index.html">Applause and cheers: carefully managed drama in Apple stores</a></li>
<li><a href="../434522/index.html">Patterns and antipatterns of task justification</a></li>
<li><a href="../434524/index.html">Kubernetes Ingress through the eyes of a novice</a></li>
<li><a href="../434526/index.html">"Yandex" explained why deleted from the search results of the official site Telegram</a></li>
<li><a href="../434530/index.html">Default calendar, fixes in LDAP and other innovations in Zimbra 8.8.11</a></li>
<li><a href="../434532/index.html">The story of one project: when there is no senior developer in the team</a></li>
<li><a href="../434534/index.html">ONYX BOOX "My first book": harmless reading for mom and child</a></li>
<li><a href="../434536/index.html">After installing the Windows 10 update on some Lenovo laptops, you will need to disable the Secure Boot</a></li>
<li><a href="../434538/index.html">Fight for space: what is happening in the satellite Internet market</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>