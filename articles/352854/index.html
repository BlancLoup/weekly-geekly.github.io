<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We keep the design of the system under control using isolated unit testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Agree, the situation when we want to throw out a bunch of ready-made code is very annoying. In this article, together with Andrey Kolomensky, we will ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We keep the design of the system under control using isolated unit testing</h1><div class="post__text post__text-html js-mediator-article">  Agree, the situation when we want to throw out a bunch of ready-made code is very annoying.  In this article, together with <strong>Andrey Kolomensky,</strong> we will try to figure out what the reasons may be for this, and how to find out how our system should look like at the point of maximum productivity.  Let us consider which approach will drag us into a vicious circle of insufficiently careful design, and which will allow us to obtain a testable system, which ultimately leads to a high-quality system design and reduces the risk of defects. <br><br><img src="https://habrastorage.org/webt/vv/tv/aa/vvtvaail8shjor4_p78zgx-xykg.png"><br><br>  Today we talk about 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  How to make testing complex dependencies? <br></li><li>  How to achieve a large test coverage? <br></li><li>  How do tests affect design? <br></li><li>  What to do when a lot of logic in the database? <br></li><li>  How to keep a compromise between design and "not design". <br></li></ul><br><iframe width="560" height="315" src="https://www.youtube.com/embed/P6IGmy3VZ00" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong><em>About the speaker:</em></strong> Andrei Kolomensky - Agile Coach at <a href="https://onagile.ru/">OnAgile</a> , has been writing code for over 10 years, working on complex domain models, such as payment systems, and on developing complex legacy codes when they had to be rescued and restored to work on them. . <br><br>  For all the time of my work, I noticed the following problem.  When we are just starting a project or are already working on it, we always expect that we will move at a constant speed (as in the title picture).  But in reality, reality does not agree with us. <br><br>  All of us very often slide into wild unproductiveness.  At the beginning, the business is happy that we, as programmers, implement a lot of features, and in the end we complain that we supply few features.  As a result, in the middle zone, approximately where the question mark is placed, we have a strong desire to rewrite everything or conduct a major refactoring. <br><br>  The situation when we want to throw out the code annoys me greatly.  This is a very close topic to me.  I developed a bank wallet solution for a year and a half.  All this time we did not go into production, and when we almost had everything ready, the license was revoked from the bank. <br><br>  The business decides not to drop the code and make another product: a payment aggregator, instead of a wallet solution.  The subject area is very similar: we take money from users, pick up a commission, give money to the store. <br><br>  We threw out all our code, because we could not make such a <em>pivot</em> , even in a similar subject area.  There were several reasons for this. <br><br><ul><li>  Our code was too hard.  Rigidity ( <strong>rigidity)</strong> says that the system resists making changes.  To make changes to the system, we need to touch on a lot of components. <br></li><li>  Our system was fragile.  This is the tendency of the system to break down in a variety of places when making seemingly small changes. <br></li><li>  Our system was intolerable - <strong>immobility</strong> .  This is the quality of the system, which suggests that we cannot reuse code from one system to another.  More precisely, we can, but the cost of extraction will be more expensive than the cost of writing code from the very beginning. <br></li><li>  Our system contained unnecessary duplications ( <strong>needless repetition</strong> ) and excessive complexity ( <strong>needless complexity</strong> ). <br></li><li>  The clarity ( <strong>opacity</strong> ) of the expression of intentions was rather low, even though we focused on it.  A common mistake of programmers is that when we launch a new product and do not go into production for a long time, we make the groundwork for the future in order to save.  Because of this, we did not understand exactly how those parts of the system that were stubs should be arranged, what exactly those elements should represent from themselves, and what behaviors and dependencies should have.  The dysfunctions I listed above prevented clarity from reaching the rest of the system. <br></li><li>  The last parameter <strong>viscosity</strong> I rendered separately.  This is an attribute of quality, which indicates how much the system resists the application of high-quality architectural solutions.  For example, if the tests pass an hour and there is no talk about TDD, this is a system with a huge viscosity. <br></li></ul><br>  <strong>Question: how to find out how our system should look like at the point of maximum productivity?</strong> <br><br>  The code we threw was covered with tests.  We took care of its quality, refactored, but as a result, we threw out almost all. <br><br>  We need some kind of tool to get feedback from the system, which would help us to understand how we should design our system.  The knowledge that we have in our head may not be enough to know at any given moment how our system should look like in general. <br><br><h2>  Unit tests - the main tool for getting feedback from the system </h2><br>  When we write unit tests, we can at least guarantee the correctness of the system and some small quality of its testability. <br><br>  Let's look at one test. <br><br><img src="https://habrastorage.org/webt/5p/4z/hm/5p4zhmllbtmovucdfnahvj0srke.png"><br><br>  There is an example in vacuum BuyProductsAction - we buy some products.  I have questions to this test, the main one being: what can I learn about the quality of the system from this test?  Virtually nothing: I can iterate through the input parameters, add more asserts, somehow provide additional checks.  Moreover, you need to check quite a lot, because we have too many product and user characteristics and too many parameters in the database. <br><br>  I don‚Äôt know <strong>anything</strong> about system design here.  This is the reason why we threw out all the code - because what we learned from our tests did not allow us to reasonably improve the design of our system. <br><br>  What can BuyProductsAction do within itself?  Create an order, send notifications, debit money from the account, charge interest bonuses - he can do a lot within himself. <br><br><h2>  What is an integrated test? </h2><br>  I‚Äôll go away from the concept of unit test, because it‚Äôs too vague, everyone understands it in his own way. <br><br><blockquote>  Integrated tests are tests that pass or drop. <br>  depends on more than one unit of nontrivial behavior. <br></blockquote><br>  That is, we can not specifically show the point why this test fell.  When we see that there is an error somewhere, that some component from the testing area has fallen, and not a specific one place, then this test is integrated. <br><br><blockquote>  Isolated tests are tests for one non-trivial unit. <br>  behavior, the passage or fall of which depends only on this <br>  behavior. <br></blockquote><br>  In fact, this is a test for one method or for one section of the system, and the rest of the non-trivial behavior is replaced by moki. <br><br>  Suppose that we do, if we try to make the test for the BuyProductsAction method isolated, so as not to test everything entirely, but run only the run method, which will be isolated from any nontrivial dependency behavior it contains. <br><br>  Most likely, we will not be able to do this, because systems that are written with such tests do not have such a strong impact on the system design so that we can immediately write isolated tests.  Even if we can do it, most likely there will be trash: <br><br><img src="https://habrastorage.org/webt/mb/sv/s1/mbsvs1pjsxk6n1evhoe5ycgusms.png"><br><br>  We begin by saying that we have some kind of AnaliticsComponent, where the input parameters are passed.  We thrust this business into a service locator.  We still have some components whose behavior we are asking. <br><br><div class="spoiler">  <b class="spoiler_title">More components that do not need to be read are simply to make the volume clear.</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/ym/6r/4g/ym6r4gzt5r0_ouj-rtel8yylulm.png"><br><br><img src="https://habrastorage.org/webt/-1/sq/qv/-1sqqvsc76kadrj0hzyvi87ynfa.png"><br><br><img src="https://habrastorage.org/webt/jj/8d/ki/jj8dkii6fmeg3n5o0xv8bponcka.png"><br><br><img src="https://habrastorage.org/webt/5b/h-/8z/5bh-8z3gng9bjuka7zseaww3swk.png"><br></div></div><br>  The number of dependencies that we see in an isolated test, when we explicitly prescribe them, is usually quite large if there is no practice of writing isolated tests in a company.  Even if we can write an isolated test, the situation usually looks like this. <br><br><img src="https://habrastorage.org/webt/f9/81/gg/f981gghpqjtasr8y3pps4oris0m.png"><br><br>  The first thing I do when I refactor the system into a testable state, I start cramming dependencies into classes and explicitly injecting them into the constructor. <br><br>  The main question you can ask when looking at this test is <strong>what do I learn about the quality of the system from this test?</strong> <br><br>  I see that I have clearly violated the principle of sole responsibility.  There is no longer a subjective argument about "clarity."  I see that this test is hard for me to read and write.  I see that this test will constantly fall, because any change I have will be made in this class.  This fictional test was hard for me even to prepare for the presentation. <br><br>  If we wrote this production code, we would just go crazy. <br><br><blockquote>  I use isolated tests to improve the quality of the system design and its reasonable refactoring. </blockquote><br>  They give the most complete feedback about my system. <br><br><img src="https://habrastorage.org/webt/on/9b/ew/on9bew-q7bw3y_1kp5pddour0c0.png"><br><br>  If the integrated tests give me practically nothing but a basic understanding that part of my system works correctly on the part of the input parameters, then isolated tests allow me to clearly see what is happening in my system.  <strong>The degree of discomfort with which I write isolated tests will correspond to the degree of testability of my system.</strong> <br><br><h2>  System rotting </h2><br>  We passed all unit tests, but the QA department found some kind of defect.  We understand that the problem is at the junction of two components, and we decide to write an integrated test, because it‚Äôs easier and because we have to check the real work - how our system works, because we still had a bug. <br><br><blockquote>  By the way, I do not recommend using the word <strong>bug</strong> .  This is a fly that <br>  flew into servers at the dawn of our industry.  An example of a bug from IT <br>  development is when I copied a SQL request from Skype, pasted it into the code, and it does not work there, because Skype instead of a space inserted <br>  non-breaking space.  When this happens, this is a bug.  In the rest <br>  I prefer to use the word <strong>defect in</strong> cases <br>  as an incorrect program behavior is not an accident, but the direct responsibility of programmers.  Defect much more powerful wording <br>  than removing the responsibility "bug."  There are no specific proofs, but one <br>  the team managed simply by passing from the word bug to the word defect, to increase the quality, simply by increasing awareness and responsibility. <br></blockquote><br>  Since we wrote an integrated test, it has less impact on the design of our system.  When we write an integrated test, we can write its implementation in different ways: insert a bunch of dependencies, make a call to static methods that change the behavior of the system, call from the service locator just a shroud of calls ‚Äî absolutely anything ‚Äî we have complete freedom. <br><br>  Therefore, from the easy life, we begin to design the system less carefully.  We do not care how our system will be arranged - only on our own sense of inner beauty, we look at the system and think how best.  But no pressure from the test occurs. <br><br>  This leads to the fact that the testability of our system decreases, and now we can not write a small isolated test.  At least, even if we can write, it has become harder to do. <br><br>  In this regard, we have a greater risk of defects, because testing our system becomes more difficult.  We have less time to write quality small isolated unit tests. <br><br><img src="https://habrastorage.org/webt/ku/no/un/kunouncnwtoebstessrgpzqhc2q.png"><br><br>  We return to the circle and eventually come to the decision to write only integrated tests, because isolated tests are difficult to write.  As a result, we get a situation where nothing influences the design of our system, only we, as we want, or write. <br><br><h2>  Alternative option. </h2><br>  The same situation - the unit passed the test, but there was a defect.  What will happen if we write a small isolated test.  We will face a bunch of problems with the fact that the system prevents us from writing these small isolated tests. <br><br>  In order to make life easier and just start writing these isolated tests with high quality, so that we understand what is happening there, we start designing the system more carefully so that we don‚Äôt have to write huge tests. <br><br>  In order for the tests to be small, you need to try very hard to make the system high-quality and consistent with the principle of sole responsibility.  This leads to the fact that the testability of our system increases.  We try to make our system as testable as possible so that we can write isolated unit tests more easily. <br><br><img src="https://habrastorage.org/webt/x5/mx/2t/x5mx2t7xfqqkywjiklor3h7seh0.png"><br><br>  As a result, with a testable system, we have more time to write small isolated unit tests, which leads to a high-quality system design and reduces the risk of defects.  What about not doing ‚Äúreal work‚Äù?  Before I cover this topic, I want to touch on one more thing.  My point is that: <br><br><blockquote>  Continuing to maintain high productivity is only possible. <br>  practicing the discipline of test driven development. <br></blockquote><br><br>  Although the opposite opinion is also quite common (for example, a <a href="https://www.youtube.com/watch%3Fv%3DKtHQGs3zFAM">video</a> on this topic). <br><br><h2>  Test Driven Development </h2><br>  Test Driven Development is a discipline.  Discipline implies a limitation that we impose upon ourselves by applying it.  This is not a Red-Green-Refactoring, but a series of specific rules: <br><br><ol><li>  As long as you do not have a falling unit test, you cannot write production code. <br></li><li>  You are forbidden to write more unit test code than enough to drop it.  Any compilation error is a crash.  You immediately stop writing a unit test as soon as it crashes, even with a compilation error. <br></li><li>  You are forbidden to write more production code than it is enough to pass one falling unit test, and you cannot write that production code that does not relate to a specific falling unit test. <br></li></ol><br>  We do not just write a test, and then the implementation is not just Red-Green-Refactoring, these are additional restrictions.  This - Test Driven Development - that allows you to maintain our system in a qualitative state and <strong>maintain the highest possible productivity</strong> over a long period of time. <br><br><h2>  Legacy code </h2><br>  According to the definition given by Michaels C. Feathers, a <strong>legacy code is a code without unit tests</strong> .  It's simple.  In my practice, I notice a direct correlation between the lack of tests and the presence of a huge number of problems with the design of the system, as well as the presence of integrated tests and about the same dependence with the problems of system design.  The less small isolated tests, the more problems with the design of the system. <br><br><img src="https://habrastorage.org/webt/zb/ul/0u/zbul0uu3qjeoqys5kqeqscuyvug.png"><br><br>  When there are no tests, it is legacy. <br><br>  I like another definition that is less accurate, but reflects reality. <br><br><blockquote>  Legacy code is a code that is scary to change. </blockquote><br>  Dave Thomas once said something like: ‚ÄúIn some cases, I don‚Äôt write tests at all; I can design a good quality system well anyway.‚Äù <br><br>  First of all, he has a huge amount of unit testing experience.  Secondly, when I work with such a system without tests, for me this system will be legacy, because it will be scary for me to make changes to it.  Fear of making changes is the main cause of code rot.  Discipline Test Driven Development - medicine.  With a committed use of this discipline, the fear of making a change goes away, since you get feedback on every line of your code. <br><br>  Robert Martin proposes that in our profession we should take an oath similar to the Hippocratic Oath for doctors.  I bring it here to clearly demonstrate why unit tests are at least important for our industry, and, as a maximum, Test Driven Development, as a discipline, important for us as programmers. <br><br><h2>  Oath programmer </h2><br>  In order to protect and preserve the honor of the profession of programmers, I promise that to the best of my abilities and judgment: <br><br>  <strong>1. I will not create malicious code.</strong> <br><br>  This applies not only to viruses, but also to the code that creates losses for our company.  If we wrote the code that caused the company losses - this is malicious code. <br><br>  <strong>2. The code that I create will always be my best work.</strong> <br><br>  I will not consciously allow my code to be defective, both in behavior and in structure.  In the behavior, of course, we can not guarantee its correctness, if we do not have some kind of verification.  In the structure, if there are no small isolated unit tests, we cannot guarantee that the design of our system is testable and of high quality. <br><br>  <strong>3. I will provide with each release a quick, reliable, and repeatable proof that each element of the code works as it should.</strong> <br><br>  The importance of this item is especially noticeable if you see how much money many companies spend on manual testing, something that can be automated and used at the same time to improve the quality of the code, and as a result, to speed up development. <br><br>  <strong>4. I will make frequent, small releases so as not to interfere with the progress of others.</strong> <br><br>  In order to deliver quickly, we need to make small releases.  I personally cannot do small releases with a sufficient degree of quality without tests. <br><br>  <strong>5. I will fearlessly and tirelessly improve my code at every opportunity.</strong>  <strong>I will never reduce its quality.</strong> <br><br>  In order to refactor the code, we need to not be afraid to change it.  My old pattern looked like this: I see a place in the system and 2 ways to make changes to this system: an easy way (‚Äúcrutch‚Äù) and a complicated way when I need to do a serious refactoring. <br><br>  If I do not have tests, I will not seriously change the structure of the subject area, because I can break something.  And I do not want to break something, so I choose the easy way. <br><br>  With unit tests, I have no such problem.  While practicing Test Driven Development, there are no problems at all - my code is always correct.  If something breaks there, it is a pain for me as a professional, because I feel that I screwed up somewhere, because the situation was under my complete control.  For me personally, the occurrence of defects is a serious challenge. <br><br>  <strong>6. I will do everything I can in order to maintain the productivity of myself and others as high as possible.</strong>  <strong>I will not do anything that reduces this productivity</strong> <br><br>  It is often said that Test Driven Development reduces productivity, or increases it when we practice it for a long time.  In fact, it keeps productivity at a constant level. <br><br>  Our task is not to move faster, our task is to move at a constant speed and to make sure that we get rid of the losses associated with weak architectural solutions. <br><br>  Test Driven Development allows us to do this. <br><br>  <strong>7. I will constantly make sure that others can replace me, and I could replace them</strong> <br><br>  If I see the code of another person and there are no tests there, this is a problem for me.  I can figure out what is happening there, but I am afraid to make changes there, since I can not take something into account.  If our team practices pair programming and full coverage with unit tests, it‚Äôs very easy for us to replace each other and work on different parts of the system - everything is safe. <br><br>  <strong>8. I will give assessments that are honest, both in their correctness and accuracy.</strong>  <strong>I will not make promises without the confidence that I can keep them</strong> <br><br>  If we have a terrible law, and we say that it will take a week, and then we dig out a place with bad code, this week turns into three - a very frequent phenomenon with legacy code. <br><br>  <strong>9. I will never stop learning my craft.</strong> <br><br><h2>  Little exercise </h2><br>  I suggest you check the statement that Test Driven Development allows you to keep productivity at a maximum constant level.  I want you to try to find in your product a part of the system that you consider well designed, for which, perhaps, there are tests, but they are integrated, and try to write a small isolated unit test for this part of the system.  Then I will show how I write them personally. <br><br>  <strong>The degree of discomfort you will experience is consistent with the quality level of this system.</strong>  A small isolated test will give you an understanding of how well or poorly designed your system is. <br><br>  If you realize that the system is not very well designed, this is a reason to start thinking about using Test Driven Development. <br><br><h2>  Simplest example </h2><br><img src="https://habrastorage.org/webt/cs/d9/7c/csd97cywn7figts10-e-bosjsfw.png"><br><br>  There is a client that depends on the server.  The client is context independent, testing it is very easy.  We simply call the methods and look at the output.  It is more difficult to test the server, now it is tied with nails to the client.  In order to test it independently, we need to separate them. <br><br>  We have to insert the interface in the middle.  Now we can <strong>test the server, regardless of the client</strong> .  Probably, many have heard the advice of programming on the basis of the interface, and not the implementation, but did not understand why this advice is good. <br><br>  This is a demonstration of why this is so.  If we want to write small isolated unit tests that help us with the design of our system, we must somehow separate our components.  In order to separate them, we need to insert something in the middle.  In this case, it is an interface. <br><br><img src="https://habrastorage.org/webt/-p/8j/jd/-p8jjd8mfml-m8wbl0wajfzw5is.png"><br><br>  An interface is not just a set of methods and signatures for incoming and outgoing parameters.  The interface is also a contract, that is, the client's expectation, which must be satisfied when he asks something from the interface. <br><br>  Suppose we ask the interface to return active users.  It is not enough just to check that we have an array of users in the outgoing parameter.  We need to be active.  Therefore, we write a test in which we ask: "Interface, please give us active users!" <br><br>  And we imitate real work - because we don‚Äôt need to do real work, we write an isolated test. <br><br><img src="https://habrastorage.org/webt/cf/yi/ny/cfyinygnxvqnm_6wqikrnt3dtmq.png"><br><br>  Stub-ohm return some value: <br><br><ul><li>  An empty array means no users. <br></li><li>  1 user - immediately enter into the profile of one user. <br></li><li>  If there are many users, we display a list of tables. <br></li></ul><br>  All - we wrote three tests.  Now our task is to make the contract run in some kind of implementation.  We really climb into the database, we get something and check that we really get active users.  We act in accordance with the contract interface. <br><br><img src="https://habrastorage.org/webt/0s/mp/zr/0smpzrvy9wdsa3qrjxi8avwvloe.png"><br><br>  Thus, on the left, we specifically ask how our system behaves with a different result of the interface, on the right - that the system actually fulfills the expectations, as a result we get that everything works together. <br><br>  We do not need to test the client and server together in order to verify their correctness.  It is enough that we: <br><br><ul><li>  we ask correctly <br></li><li>  process correctly <br></li><li>  we act correctly <br></li><li>  check correctly. <br></li></ul><br>  It's enough. <br><br><h2>  The 4 Rules of Simple Design </h2><br>  This concept came up with Kent Beck.  In order of priority, a system can be considered simple if it passes all tests. <br><br><img src="https://habrastorage.org/webt/jo/ua/5r/joua5r8wxve8z8rlolcno7q3k1u.png"><br><br>  If there are no tests in the system or the code does not pass the tests, it cannot be considered simple, at least, because the viscosity of the system is very high.  This code is scary to change and this is a problem because the system will start to rot.  As a result, productivity will fall. <br><br>  <strong>Tests</strong> - a prerequisite for the code to be considered simple. <br><br>  Then we can concentrate on <strong>clarifying our intentions.</strong>  I do not remember who said that the code should be read as well-written prose.  After all the tests work for us, we can take care that our code is read as well-written prose and <strong>remove unnecessary duplication</strong> . <br><br>  At the very end, we can already think about the fact that our system consists of the <strong>smallest number of elements</strong> . <br><br><img src="https://habrastorage.org/webt/e3/pp/zm/e3ppzmohx7alcjocdgcnbgixq-q.png"><br><br>  I advise you to add these guys as friends in the social.  networks: <br><br><ul><li>  <strong>Kent Beck</strong> is the founder of the extreme programming movement and the Test Driven Development discipline. <br></li><li>  <strong>J. B. Rainsberger</strong> - founder of JetBrains. <br></li><li>  <strong>Robert Martin</strong> - I am sure you know about him, if not - give maximum priority to reading his blog and books. <br></li></ul><br>  Subscribe to them, take an example from them, read blogs, study what they write. <br><br><h2>  What's next? </h2><br>  I want to challenge you.  Returning to a small exercise: try to take the part of the system that you consider well designed, and write a small isolated unit test on it. <br><br>  Most likely, you will encounter the fact that you cannot do this, and if you decide to do something with it, I advise you to look at these resources: <br><br>  <a href="https://cleancoders.com/">https://cleancoders.com</a> <br><br>  <a href="https://online-training.jbrains.ca/p/wbitdd-01">https://online-training.jbrains.ca/p/wbitdd-01</a> <br><br>  Thank you for your commitment to reading this article. <br><br>  You can write to Andrew in a telegram <a href="https://t.me/akolomensky">https://t.me/akolomensky</a> to ask questions or ask for advice on engineering, process or product cases, he promised to answer everyone, so do not hesitate. <br><br><blockquote>  We want to note, isn‚Äôt it in order to comply with the clause of the oath ‚Äú <strong>I will never stop learning my craft</strong> ‚Äù, and continuously improve <strong>myself</strong> , we meet at conferences.  After all, the intensive flow of ideas and cases from practice, received at conferences, gives impetus to self-improvement for at least six months.  And so that the development schedule does not look like a bad production schedule, it‚Äôs time to get a new charge - the <a href="http://ritfest.ru/">RIT ++</a> festival will be <strong>on May 28 and 29</strong> , and <a href="http://www.highload.ru/siberia/">Highload ++ Siberia</a> <strong>on June 25 and 26 in Novosibirsk</strong> .  On the last <strong>until April 30,</strong> you can have time to submit applications. <br><br>  ++  ,    <a href="http://backendconf.ru/">BackendConf</a> ,        ,     ,  <a href="https://conf.ontico.ru/conference/join/rit2018.html%3Fpopup%3D3"> </a> . ,      <strong> </strong>  2   ¬´ <a href="http://backendconf.ru/2018/abstracts/3348">    Scala</a> ¬ª.   ,   -  ,      . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/352854/">https://habr.com/ru/post/352854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352844/index.html">We write a simple plugin for VirtualDub</a></li>
<li><a href="../352846/index.html">Distrust of authority and economy: main trends of millenial investment activity according to Robinhood service statistics</a></li>
<li><a href="../352848/index.html">Backend United # 1. The vinaigrette. Announcement</a></li>
<li><a href="../352850/index.html">We are preparing an iOS client for GraphQL</a></li>
<li><a href="../352852/index.html">Excel-calculator of complex wave resistance transformation on waveguide line segments</a></li>
<li><a href="../352856/index.html">AWS framework for serverless applications</a></li>
<li><a href="../352858/index.html">Tehnostrim. Learning to build the Internet</a></li>
<li><a href="../352860/index.html">DANOS: First Open Network Operating System Presented</a></li>
<li><a href="../352864/index.html">Simple, affordable and useful Wi-Fi lab. Do it yourself</a></li>
<li><a href="../352868/index.html">Is the keyboard an output device?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>