<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Features work with Multicast</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share some experience with multicast data transfer technology, or UDP Multicast, and the problem of a feature that arises when writing cross...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Features work with Multicast</h1><div class="post__text post__text-html js-mediator-article">  I want to share some experience with multicast data transfer technology, or UDP Multicast, and the <s>problem of a</s> feature that arises when writing cross-platform code. <br><a name="habracut"></a><br><br>  I‚Äôll just make a reservation that in this article the technology and the UDP protocol will not be considered, for this it is better to turn to <a href="http://ru.wikipedia.org/wiki/UDP">UDP</a> and then to <a href="http://ru.wikipedia.org/wiki/Multicast">Multicast</a> . <br><br>  So, all the work begins with the creation of a socket and its "settings".  In general, it looks like this <br>  1. create a socket <br>  2. make a bind <br>  3. connect with multicast group. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now in order <br><br><h1>  Socket creation </h1><br>  It's all simple and no dirty tricks <br><pre><code class="cpp hljs">sockfd = socket(AF_INET, SOCK_DGRAM, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><br><h1>  Socket binding </h1><br>  The first thing we need to do is allow PORT to reuse, because  besides us, someone else can work with this port. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> optval = <span class="hljs-number"><span class="hljs-number">1</span></span>; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(optval));</code> </pre><br>  The <a href="http://www.opennet.ru/man.shtml%3Ftopic%3Dsetsockopt%26category%3D2%26russian%3D0">setsockopt</a> function allows you to set options for a socket.  An interesting point is that the option value is passed by pointer to void, since  Some options require not just the on / off flag, but structures with additional data. <br>  Next, we need to bind the socket to the port.  Or maybe an address?  Here the first <s>problem</s> comes into force - a different ideology of the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms737550(v%3Dvs.85).aspx">Windows</a> and <a href="http://linux.die.net/man/2/bind">Linux kernels</a> .  Namely, that under Windows we cannot bind to the address of the Multicast group (we get an error) and must bind to INADDR_ANY <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addr</span></span></span><span class="hljs-class">;</span></span> bzero(&amp;addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = htonl(INADDR_ANY); bind(sockfd, (sockaddr *)&amp;addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr));</code> </pre><br>  On Linux, we can also bind to INADDR_ANY, but in this case we will receive all the datagrams that came to the port that we zabindenny.  In order to receive datagrams only from the necessary group, it is necessary to bind to the address of this group (well, of course, the port will not be forgotten). <br><br><h1>  Connect to group </h1><br>  The main feature of Multicast is that our host will not receive data until we connect to the Multicast group.  User level connection looks like setting options for a socket. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ip_mreq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mreq</span></span></span><span class="hljs-class">;</span></span> inet_aton(ip_addr, &amp;(mreq.imr_multiaddr)); mreq.imr_interface.s_addr = htonl(INADDR_ANY); setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(mreq));</code> </pre><br>  where ip_mreq.imr_multiaddr is the multicast group address.  And ip_mreq.imr_interface is the address of the interface at which we expect to receive datagrams.  INADDR_ANY in this case means that we reserve this right for the kernel, which will select the interface based on the routing table.  Next, the kernel will check if we are already connected to this group, and if not, then send a request to the nearest Multicast server.  That, in turn, further, etc.  After that, we will receive datagrams sent to this Multicast group to the host. <br><br>  But what to do with Windows which is on INADDR_ANY?  Will he receive all the datagrams sent to the listening port?  Apparently, the Windows kernel, when specifying this option for a socket, itself filters the received data.  And in this way, only the subscribed groups are delivered to the socket. <br><br>  <b>On Linux, in order to receive data on the socket only from the connected Multicast group, you need to bind to its address.</b> <br><br>  If you do not believe me (and I didn‚Äôt believe it at the beginning) then trust him <br><blockquote>  Unix Network Programming 3 edition.  chapter 21.6 page 599 <br>  - To receive a multicast datagram, the process must join the group, and also bind the UDP socket with the port number to be used as the destination port number for the datagrams sent to the group. <br>  ... <br>  When connecting a port, the application indicates to UDP that it is required to receive datagrams sent to this port.  Some applications, in addition to port binding, also associate a multicast address with a socket using the bind function.  This prevents any other datagrams that may have been received for this port from being delivered to the socket. <br></blockquote><br><br><h1>  And how in boost'e? </h1><br>  I will disappoint you, in boost everything is similar to the API, no adaptation to the same logic is made.  So, using it to write a cross-platform application, you still have to do <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> WIN32 boost::asio::ip::udp::endpoint listen_endpoint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0.0.0.0"</span></span></span><span class="hljs-meta">, multicast_port); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> boost::asio::ip::udp::endpoint listen_endpoint(multicast_address, multicast_port); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> socket_.open(listen_endpoint.protocol()); socket_.set_option(boost::asio::ip::udp::socket::reuse_address(true)); socket_.bind(listen_endpoint); ocket_.set_option(boost::asio::ip::multicast::join_group(multicast_address));</span></span></code> </pre><br><br><h1>  Multiple groups for one socket </h1><br>  While writing the post, I realized that the path suggested for Linux hides one limitation.  We have to work on the principle of one socket - one multicast group.  Since it is hardly possible to bind at once not several addresses. <br><br>  Describe the situation.  There is a server, it broadcasts data in several multicast groups on one port. <br><br>  There is a client, he wants to receive data from the server only in a few groups.  Then he needs to take the following actions: <br><br>  1. bend on INADDR_ANY <br>  2. then filter all received datagrams manually defining their destination <sup>1</sup> address. <br><br>  The process of filtering received at the destination address datagrams on the socket follows from the fact that there is a situation when there is another software on the client‚Äôs machine that connects to some other groups but with the same port and then both sockets will receive datagrams from all connected groups on this port . <br>  But at the same time face the problem of data redundancy. <br><br>  Well, actually I wanted to tell you about these features of working with Multicast, without knowing which you risk stepping on a rake. <br><br>  Ps.  In order to feel all this I propose to do the following steps. <br>  1. Assemble the <a href="">receiver</a> <br>  2. Collect <a href="">sender</a> <br>  Next on Linux run <br>  3. Start: receiver 0.0.0.0 239.192.100.1 <br>  4. Run: receiver 0.0.0.0 239.192.100.2 <br>  5. Run: sender 239.192.100.1 <br>  6. Ensure that both receivers will receive data <br>  Next, also run on Windows <br>  7. Make sure that the data will receive only the one to whom we sent them. <br><br><hr><br>  <sup>1</sup> Another UDP feature is that the sender and recipient address is not explicitly indicated in the UDP message header.  But it is taken into account when calculating a chex, thus, receiving a UDP datagram, the module must compile its <i>pseudo header</i> , calculate the cheksum and compare it with the received one, make a decision that the datagram was addressed to us.  Apparently Linux does this check, using the address to which we bind as the destination, which is why the <s>problem</s> described above turns out <s>to be a</s> feature. </div><p>Source: <a href="https://habr.com/ru/post/141021/">https://habr.com/ru/post/141021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../141013/index.html">Private chat on node.js - what could be easier?</a></li>
<li><a href="../141016/index.html">Red Hat will be the first billionaire company in the world of open source software</a></li>
<li><a href="../141018/index.html">New SimCity will work only when connected to the web</a></li>
<li><a href="../141019/index.html">We invite you to the webinar March 31: "Small business: how to open your service center"</a></li>
<li><a href="../141020/index.html">Google's App Vault - monitoring and archiving messages for users of App for Business</a></li>
<li><a href="../141022/index.html">The sources of Prince of Persia were found after 23 years</a></li>
<li><a href="../141024/index.html">Google uses reCaptcha to recognize street names and house numbers.</a></li>
<li><a href="../141025/index.html">Google Account Activity</a></li>
<li><a href="../141026/index.html">Second beta released Ubuntu 12.04</a></li>
<li><a href="../141027/index.html">Three social extensions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>