<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to cryptography and encryption, part two. Lecture in Yandex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We return to the most brief introduction to cryptographic theory from Vladimir ivlad Ivanov. This is the second half of the lecture - we published the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to cryptography and encryption, part two. Lecture in Yandex</h1><div class="post__text post__text-html js-mediator-article">  We return to the most brief introduction to cryptographic theory from Vladimir <a href="https://habrahabr.ru/users/ivlad/" class="user_link">ivlad</a> Ivanov.  This is the second half of the lecture - we published the <a href="https://habrahabr.ru/company/yandex/blog/324866/">first part</a> a few days ago.  To her you can even <a href="https://github.com/ivladdalvi/2hourscrypto">send pullrequests</a> on a githaba. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/M_Ohbwoxf-E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Under the cut - decoding and part of the slide. <br><br><a name="habracut"></a><hr><br>  - The real situation is as follows: a collision between two random samples of 256 bits in length will reach a probability of ¬Ω at about 4 billion samples.  So, if we consider a stream of blocks with a length of 64 random bits, then with probability ¬Ω among 2 <sup>32</sup> such blocks there will be two identical ones. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is the practical value of this scientific fact?  The output of the encryption function can be viewed as a random number, and the ideal encryption function is indistinguishable from a random number.  So, if we consider blocks encrypted, for example, by DES or GOST-28147, then taking 2 <sup>32</sup> such blocks, we will, with probability ¬Ω, find out that two of them are encrypted in the same way. <br><br>  Let's think someone counts: 2 <sup>32</sup> blocks of 64 bits or 8 bytes - how much?  32 gigabytes?  It looks like the truth.  Now we divide 32 gigabytes into 10 gigabits.  If we have an encryption algorithm with 64-bit blocks, then a little later than after 32 seconds, we will see a collision.  We will see two blocks that are encrypted in the same way.  As found out in the SVS, these two blocks do not have to be with the same plaintext.  Plain text may be different. <br><br>  What will it mean?  If we have some C <sub>i</sub> block, then what was encrypted in CBC mode? <br><img src="https://habrastorage.org/files/3c8/869/fdb/3c8869fdb5064faa97ba4e3b89dc1e02.jpg"><br>  Let's say we watched a collision after 30 seconds.  The two parts are equal.  Encryption is one-to-one.  Thus, since the encryption functions are equal, then the encoding is also equal. <br><br>  C <sub>j-1</sub> and C <sub>i-1</sub> - we saw them, because they had just been transmitted in the communication channel. <br><br>  In other words, if we have such a small block size, then even with absolutely strong encryption, after some time we will begin to get differences between some two random open texts.  This property is not necessarily transformed into a real attack, but in practice it is not very good.  Because of him, the CBC mode is the cause of many ills. <br><br>  The last of these troubles is the attack (indiscernible - ed.), Published just a couple of weeks ago.  It is extreme, but, I think, not the last in this series.  And all because of the unfortunate properties of the CBC, which I described. <br><br>  However, CBC is still a widespread encryption mode.  It can be found anywhere. <br><br>  <i>- If you need to take the last 10 bits, we will have to count sequentially ...</i> <br><br>  - Yes, of course, the CBC has a problem: to decrypt 1 gigabyte and read the last 10 bytes in it, you must first generate it all. <br><br>  Despite all the difficulties with CBC, it is still the most common encryption mode: TLS is accurate, but I think that in IPsec, that is, in real-life protocols. <br><br>  How to deal with this in real life?  First and foremost, Triple DES is no longer widely used.  Further, if you look at AES with a block size of 128 bits, then the probability of a ¬Ω collision occurs after about 2 <sup>64</sup> blocks, and this is a lot of traffic.  Therefore, in real life, the likelihood that we stumble upon a collision is low.  So do not use Triple DES and GOST-28147, if you are not a government organization and do not have to use them. <br><img src="https://habrastorage.org/files/091/111/d63/091111d631fd47cf9ffe057effc07d57.jpg"><br>  CBC is not the only encryption mode.  There are still CFB.  He, if you look closely, is very different from the CBC.  We take the initialization vector, copy the plaintext with it and get the ciphertext.  We encrypt the result again, we repeat the plaintext with it, we get the second block of text, etc. <br><br>  Why did I even talk about CFB?  Because, unlike CBC, the CFB variant is standardized for GOST.  If you look closely, in this sense it is no better than CBC - it has the same problem.  In closed systems, you can meet with the specified implementation, with it, in principle, some problems arise. <br><br>  What other problems do these algorithms have?  To decrypt every next block, we need encrypted plaintext.  Without an accessible plaintext block, we cannot generate the next encryption block.  In order to get rid of this problem, OFB mode was invented, which is arranged like this: an initialized vector is given, it is encrypted with a key, the result is encrypted with a key again, again ... In fact, we take and encrypt the initialization vector many times - as many blocks as we need. <br><img src="https://habrastorage.org/files/c99/98d/270/c9998d270ce943e2b2f38c2e2874f63f.jpg"><br>  We add the blocks with clear text.  Why is this convenient?  If you look closely, block encryption mode becomes streaming.  If there is little traffic now and the processor is free, we can generate several blocks ahead of time and then use them up with a possible surge in traffic.  Very comfortably.  And we do not need the knowledge of plaintext to encrypt the next block.  You can type and keep a few gigabytes in memory - in case you need it. <br><br>  All the flaws of stream ciphers are also present here. <br><img src="https://habrastorage.org/files/55b/336/881/55b3368812b74a85967421ccf666bea9.jpg"><br>  A slightly different encryption method is the so-called counter mode or CTR.  It is arranged simply: we take a certain random number, we place it at the beginning of the block, and at the end we simply put the counter from zero to as many as you like.  For example, up to 64 bits.  We take and divide in half: we give the left 64 bits to a random number, and the right 64 bits to the counter. <br><br>  Encrypt each such number and reduce the result with clear text. <br><br>  What is convenient CTR?  It allows us to encrypt the 125th block without encrypting the previous 124 blocks, that is, solves the problem of decrypting the last 16 bytes from a 10-gigabyte file.  It is quite convenient in all other senses.  If we talk about a surge in traffic, you can generate blocks for encryption ahead of time. <br><br>  This is the case with messages longer than one block.  And what if they are shorter than one block?  In other words, we want to encrypt not 16, but 8 bytes. <br><br>  <i>- Finish to 16.</i> <br><br>  - But as?  Suppose we deciphered a block, at the end of which has four zeros.  How do we know that these four zeros are finished by us, and not a fragment of our blocks? <br><br>  <i>- Before transmitting the encrypted message, report the length in bytes.</i> <br><br>  - A convenient way, but it is inconvenient because you don‚Äôt always know the size before the transfer.  If email - you know, and if not? <br><br>  After the transfer?  Okay, maybe you can.  And where is there to look for differences?  It is necessary to store in a separate place.  The question is which one? <br><br>  <i>- Not within the scope of encryption.</i> <br><br>  - If not within the scope of encryption to transmit the length of the message, you will disclose it.  I think we were hiding her. <br><br>  Welcome to my personal hell, namely to the system with padding.  The idea that you need to write at the end of the message how long it is is not very bad.  It is only important to think of a way to complement the block, which will uniquely establish that this piece at the end is an addition, not part of the data. <br><br>  There are several modes of padding, and unfortunately, the most common of them has several unpleasant properties. <br><br>  We take and at the end of the last block we add each free byte to the number of free bytes.  If at the end there are 3 bytes left - we take and write them: 3, 3, 3. <br><br>  If the length of the message falls exactly on the border, we supplement it with another block, where we write, I think, four zeros.  Not fundamentally.  This encoding method is always unambiguous.  We open, find out the last byte and, if it is not zero, we understand - it is necessary to count how many bytes.  In fact, this is a cleverly coded message length.  If the last byte is zero, we can discard the entire block.  And we know that a full block can never end with zero: then we would complement it with another completely zero block. <br><br>  If the last block ends with a unit, then it is complete and we will definitely supplement it with one more block. <br><br>  It would seem normal.  Before us is the working mechanism of padding. <br><br>  Suppose we are attacking.  We have an Oracle system - it is so called in cryptography.  This is not the Oracle that makes the database.  This is a box whose device you do not know, but in this case it is an encryption or decryption algorithm.  You do not know which key is inside, although it gives you some kind of answer.  However, it will definitely not give you an answer on whether the line you put in it was correctly or incorrectly deciphered. <br><br>  So, you have the specified box.  In this case, you saw one message and know for sure that it was decoded normally.  Oddly enough, in real systems such a message is easy to get. <br><br>  Then you take the message and send it to the box, changing in it one last byte.  A box can return two states to you.  Either you learn that your construction was somehow well deciphered, or - that it was not deciphered due to a padding error. <br><br>  How does everything work?  Your program code is trying to decrypt something, decrypts and further checks the padding at the end.  If the padding does not meet the standard, you see "333" or something is wrong, not the entire last block is zero, then it will tell you: "padding error".  At the expense of such a scheme you can sort out the last bytes of the last block in a rather simple way.  For example, if you use the unfortunate mode of CBC, then, having disassembled a piece of plain-text, you can understand what was there. <br><br>  It would seem that everything looks pretty harmless.  But in practice, the problem with padding oracle attacks, for example, led to the remote execution of malicious code in Windows 2003 sometime in 2008. <br><br>  Why it happens?  We are trying to decipher something without verifying that the incoming message was really sent by the one from whom we are waiting for something. <br><br>  Welcome to authentication.  Everything we talked about just ensured the confidentiality of the message.  Using encryption, we send the message and we can be sure that no one except the recipient will read it.  But when the recipient receives the message, how can he verify that the message was actually received from the sender?  For such a test, there is a separate set of message authentication protocols.  In English, this is called a MAC - message authentication code. <br><img src="https://habrastorage.org/files/c8d/cc8/aed/c8dcc8aed14e4cc5ae96e86c04cd685d.jpg"><br>  What are the problems here?  There is a problem with streaming encryption algorithms.  Suppose there is a message about which we know nothing.  There is a gamma that is somehow generated.  Ciphertext is obtained.  Suppose the cipher is absolutely strong and everything is fine with it.  But imagine that the attacker took and changed some bit in the message that we receive.  Will we detect an error?  Obviously not. <br><br>  If he changed the zero bit to one, he unpredictably changed the plaintext.  If he changed the unit to zero in the ciphertext and in the original message there was also zero in this place, it will change to one.  If we "flip" a bit in ciphertext, it flips in cleartext.  And this problem cannot be detected by means of a single encryption algorithm. <br><br>  It is clear that in the block cipher there will be more problems, that they will accumulate and that you will surely encounter the problem of padding, but in general, this problem is still there.  Encryption alone does not provide message authentication.  Need a separate mechanism. <br><br>  The mechanism is called MAS.  How does he work? <br><img src="https://habrastorage.org/files/896/3af/105/8963af105f494cb087dd17d3a4b84d38.jpg"><br>  We take the message and pass through a special function called the MAC algorithm.  At the input, the MAC algorithm receives not only a message, but also a key that is different from the encryption key. <br><br>  When we want to send a message, we attach the result of the algorithm to it.  The recipient takes the message, performs the same operation and compares the MAS, which he calculated, with the MAS, which he received.  If they match, then the message has not been changed in the process.  And if the two IASs did not match, then a problem happened along the way. <br><br>  What can be used as a MAC function?  You can use the number of units, but it seems that such a scheme is easily forged. <br><br>  The hash function is the obvious answer.  And more? <br><br>  For a long time, SAF MAS were distributed.  We take a construction in which there is no initialization vector, and everything else is the same.  We take a ciphertext - we encrypt, we ‚Äúcrawl‚Äù, we cipher, we ‚Äúcrawl‚Äù ... It turns out the last block, where all the information about our text is accumulated.  Very comfortably. <br><br>  But it is also quite true that you can use any cryptographic hash as an element of the MAS.  There are several cryptographic hashes, the most common of which is MD5, the SHA family, GOST 34.11 ... and the competition for SHA-3 recently ended, in which Keccak won. <br><br>  Hashs are more complex than encryption algorithms, but in its principle the idea of ‚Äã‚Äãbuilding a hash function is similar to the block encryption algorithm.  In other words, we take some kind of data block and consistently, several times apply to it a set of fairly primitive operations.  If you look at MD5, then there is only addition modulo 2 and cyclic shifts.  We use them many times - as a rule, much more than in the case of block encryption algorithms.  If there is a text along the way, from which we need to take a function longer than one block, then we follow them using a method a little bit similar to CBC.  We add these fragments to our calculated function. <br><br>  The result of the hash calculation is numbers.  The length of the number is always fixed.  Typical hash output sizes for MD5 are 128 bits, for SHA-1 - 168 bits, for SHA-256 - 256 bits, for SHA-384 - 384 bits, and for SHA-512 - 512 bits. <br><br>  What else is important to say about hashes?  With small changes in the input, the hash is required to provide large changes in the output.  So, if we changed one bit in the plaintext at the input, then ideally the hash, the result of the calculation of the hash function, should change exactly by half. <br><br>  Now in actual practice it is recommended to use SHA-2, and specifically SHA-256 or SHA-384 - depending on your needs.  MD4 is broken for a long time, MD5 - in principle, also broken: just yesterday, a new attack on MD5 was published, where the guys use Sony PlayStation to generate collisions coolly.  We can assume that the use of MD5 is no longer necessary.  In real life, always use SHA-2. <br><br>  Where else besides authentication, hash functions are used?  In the key generation protocol, for example in PBKDF2.  Suppose you need to encrypt a file.  You take the user and, as a rule, ask for the password with which you need to encrypt the file.  In a real-life situation, the user enters something like a sequence from 1 to 5 as a password, and his work will be completed. <br><br>  On the one hand, you want your encryption key to be not as predictable as ‚Äú12345‚Äù, and that the distribution of bits is more uniform.  On the other hand, if an attacker begins to sort through all possible passwords, each brute-force attack should take as much time as possible.  The indicated class of KDF-functions is aimed at exactly that. <br><br>  PBKDF2 is a specific function from the class of key generation functions.  It is arranged very simply.  It only does that it applies a hash algorithm several tens of thousands of times.  And along the way - at each stage - it mixes up additional data so that it is rather difficult to calculate it in advance. <br><br>  Since the hash function has been running for quite a long time, performing hash functions several thousand times takes even longer.  In other words, we are protected in a convenient way from an attacker who tries to sort out several common passwords. <br><br>  In real life, when the KDF function is used, it is recommended to choose the number of iterations so that it is, on the one hand, acceptable to an impatient user, and on the other, unacceptable to an attacker who wants to pick up several million keys.  In real life, select such a number of iterations in KDF, so that, for example, it is executed in one second.  For an attacker, one second is an absolutely indecent time, while the user, pressing the button and waiting for the password to be verified, is quite capable of waiting for one second. <br><br>  Storing passwords is the same use of hashes.  Anton <a href="https://academy.yandex.ru/events/system_administration/kit_2014/">in the story about UNIX</a> will definitely tell about it. <br><br>  Since we have padding oracle and similar attacks, when we generate a message, there are two options. <br><br>  There is a crypto-primitive type of MAS, and there is a crypto-primitive for encryption.  We want to send a message and authenticate it.  There are two ways.  We can encrypt the message, then take the MAC from this thing and attach it to the message.  Entirely it will look like this: E (T) ||  MAC (E (T)). <br><br>  The second way is the following: we take the message, encrypt it and take the MAC from the plaintext.  Because why do we need an extra operation? <br><br>  In fact, one is called MAC before encrypt, and the second is encrypt before MAC. <br><br>  The question is - which is better?  Equally?  Okay, more versions? <br><br>  There is another great way - they say, let's encrypt the MAS so that no knowledge about the plaintext is leaking. <br><br>  Indeed, there is a problem with this method: if you encrypt a message with it, there will be a risk of encountering a padding oracle attack.  Padding oracle doesn't care if you have MAC at the end or some other data.  You will have a box that first tries to decrypt the message.  If due to improper padding, it does not decrypt, the box will not even check the MAC, and will immediately respond to the attacker or someone else that "I could not decipher this thing."  Enough unpleasant.  Therefore, here is a general recommendation for the design of such systems - if you do not know what you are doing, it is better to use such a thing, and if you know, this one: E (T) ||  MAC (E (T)). <br><br>  Just six months ago, Anton and I discussed about one place, and I insisted on using the second design.  I thought I knew what I was doing.  And I still think that I knew what I was doing, because there was no padding oracle. <br><br>  We are able to encrypt our message, we are able to verify that the received message really came from the sender.     : A  B     ,           . <br><br>   ,   ,    ,  , ,           .     - KDF-    :     ,       .     . <br><br>   ?      ‚Äî    .     ‚Äî    .  ‚Äî  .    100 ,     .    ,   100  ,         ‚Äî   . <br><br> ,  ,        ,          . <br><br>       ‚Äî      . <br><br>      ? <br><img src="https://habrastorage.org/files/7a7/309/454/7a7309454bfd4186b17414f42bdcc455.jpg"><br>       k <sub>1</sub>  k <sub>2</sub> ,   .       k <sub>1</sub> ,        k <sub>2</sub> .   ,   . <br><br> : k <sub>1</sub>  k <sub>2</sub>    , ,  ,   .    ,   . <br><br> ,    ,    .     ,      ,    -   . <br><br>  ,       ,     ,    ,  P = NP.         .     RSA,   ,   .      . <br><br>   ,      ,    .      - (DH).  ,         ,    . <br><br>    .         P  G.     . <br><br>            a   .     . <br><img src="https://habrastorage.org/files/963/5ba/d14/9635bad14c1b4fb593cff2ce7ff45178.jpg"><br>   -   ,        B   .    G  P    .      , G  P    .       . <br><br>  What happens next?       .         ,    ,   ,     b.  :  <sup>a</sup> = A <sup>b</sup> .   . <br><br>  ,     ,    ,     .  It turned out very convenient. <br><br> ,     ,      ,      , ‚Äî        0. <br><br>     ,     ,      ‚Äî RSA. <br><img src="https://habrastorage.org/files/a34/f99/b1c/a34f99b1ca4841288202f2a7ab5e170e.jpg"><br>     .   ‚Äî 1024 .      2048, 4096   8192:     ,  . <br><br>    ‚Äî . <br><br>       (n-1)(p-1).   ‚Äî   ,         . <br><br>     ,    : ,   .   - .       . <br><img src="https://habrastorage.org/files/28d/4ce/9c3/28d4ce9c3c0e4180b198726c76feb8fb.jpg"><br>              ‚Äî      .  ,            . <br><br>      ,  d ‚Äî  .         .  ,   ,         .        RSA. <br><img src="https://habrastorage.org/files/b1a/c7f/fcb/b1ac7ffcb0304ff9a0ad572fec0a7050.jpg"><br> ,      ,        .  ,        k,    ,  k ‚Äî  . <br><img src="https://habrastorage.org/files/def/ba5/076/defba5076e2f4fb192bbe5e152205a86.jpg"><br><img src="https://habrastorage.org/files/b07/221/982/b07221982399414bbfdf16d79fc6dfd1.jpg"><br> ,    - ,    -   ,           n.         .    ,       ,   . <br><br>      -,      d. <br><br>   de = 1      n,  , M <sup>ed</sup> mod n, ,   M <sup>1</sup>   n.     . M <sup>1</sup> = M. <br><br>        RSA,        ?    , k <sub>1</sub>  k <sub>2</sub> ,   ,  ‚Äî .     ‚Äî  , d ‚Äî . ,      ,     ,  ,      ,   .   :  M <sup>e</sup> ,     d,  M <sup>d</sup> ,     . <br><br>        RSA,       ? <br><br> , - .     XOR  ,       .      ,  ,   .       .         ‚Äî   ,     ,     . <br><br>    .  ,         ,    .   RSA       ,     ‚Äî  .    .      :     - ,   -       ,           ,      -. <br><br> RSA    1024, 2048, 4096  ‚Äî  .    AES, DES  Salsa    : 256, 128    64    DES. <br><br> ,     ‚Äî RSA-2048  AES-256?  RSA   ,    ,   AES        2 <sup>256</sup> ,   RSA ‚Äî    .        ,         .     2 <sup>2048</sup>  . <br><img src="https://habrastorage.org/files/a62/407/f6c/a62407f6cb0f403a823e0280bec71687.jpg"><br>   ,   ,  -    -     .       ,   .   ,    ,         .  ,         . <br><br>   -  ,        .  ,  2014   AES     78-80 .     ,   RSA,    1300-1400 .    keylength.com  ,   .     ‚Äî 160-170 .   SHA1  2014           ,     ‚Äî 168 . <br><br>    - ,      ,        . <br><br>    .  , ,  ,          . <br><br>    .  :            . :          .  ,        . <br><br>    .  ,  email.  ,        ? <br><br>     ‚Äî ,  128 .   ?  ,       .           . <br><br>      ,       . <br><br>  ,         ,         ,          . <br><br>     . <br><br>        .  .  ,   ,     -  .      ,     . <br><br>      . <br><br>    128- ,     .    128- ,   ,   .     ,      .             .          . <br><br>   ?     ,    .       ,          .    ,    ,     ‚Ä¶  -   ? <br><br>  ,         .        .    ? <br><br>   ,   ,       ‚Ä¶  ,     .        padding oracle,      ,    ,     . <br><br>   ?   , , ,     .      ,    .  ,      ,      ‚Äî    ,    . <br><br>           ,   ,       .       :   , ,  . -,      ‚Äî    . -,          ,      . <br><br>    ?  ,       ,     . <br><br>     .  ,     ,  S/MIME  PGP.    ,   ,     ,   . <br><br>   ,     .     ,       .   ,     ,       . ,   .     ?  What is the difference? <br><br>  :     ,     DH ,  ,   .     . <br><br>    ,       DH, ,  ,       . <br><br>   DH     (. man-in-the-middle  MITM ‚Äî . .).  ,       ,      ,        .     ,      ,      - ,   ,      ,     ,   -        .   DH-   ‚Äî   .   ,     ,       . <br><br>  What to do?  ,  . <br><br> <i>‚Äî        ,   ‚Äî ‚Ä¶</i> <br><br> ‚Äî    ?   ? <br><br> <i>‚Äî    ‚Ä¶</i> <br><br> ‚Äî ?    . <br><br> <i>‚Äî     ,         .</i> <br><br> ‚Äî          .   ,     ? <br><br> <i>‚Äî ‚Ä¶    .</i> <br><br> ‚Äî   ?  ,   DH    : ,      ,     . <br><br> <i>‚Äî      DH-   MITM?</i> <br><br>  - Not.   ,   DH-?   ,     DH-    . MITM ,     ?  I do not believe. <br><br>   ,     ?  Signature.   ,    A       .  Everything.        . <br><br>   ?         ,     .        ,       .    ‚Äî , -,     ,      ,  -,     ,    . <br><br>        :  ,  ,      ,         .    .       DH. <br><br> ,        .     ,      -.         ,        ,      . <br><br>    ,       .     .      - DH-,    ,     ? <br><br>      ? ,   .     .     ?   .  -   ?     ,            .    . <br><br> ,          - .     .    .     :   ,    ,  ,  , ‚Äî    .   .    ,    ,   MD5  SHA,    .     ,  - .     HMAC.    ,    . <br><br>      ,   ,  .     ,     ,     .   C <sub>1</sub> .     ,     C <sub>2</sub> ,     ,    . <br><br>           .      ,   .   DH,    DH  .       ,   -     KDF-,      :     .     ,     .          ‚Äî :     ,     .  ‚Äî  KDF-. <br><br> ,   ,      ,       ,     . <br><br>  ,      ,     .     ,     .     ,         .       HTTPS  ,    ,       . <br><br>         .   .   ,    .        .  ,     .     ,    .   ‚Äî   . <br><br>  ,     ? </div><p>Source: <a href="https://habr.com/ru/post/327636/">https://habr.com/ru/post/327636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327620/index.html">What awaits us in ReactOS version 0.4.5?</a></li>
<li><a href="../327622/index.html">Retail Sales Model</a></li>
<li><a href="../327624/index.html">MeteorJS, Nginx, mongodb, iptables ... production</a></li>
<li><a href="../327628/index.html">Automated generation of circuit components from PDF files for Altium Designer</a></li>
<li><a href="../327630/index.html">Tmux Cheat Sheet (Terminal Multiplexer)</a></li>
<li><a href="../327638/index.html">Nodejs MVC framework or regular bike</a></li>
<li><a href="../327640/index.html">Introducing CockroachDB and creating a failover cluster with it on Ubuntu 16.04</a></li>
<li><a href="../327642/index.html">How laser roulette works: reverse engineering</a></li>
<li><a href="../327644/index.html">SVG support and CompactOverlay mode in UWP applications</a></li>
<li><a href="../327646/index.html">First time (sketches from one workshop)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>