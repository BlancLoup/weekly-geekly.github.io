<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use Voronoi diagrams to control AI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Which route will be the safest, where are the most enemies and where is the nearest first-aid kit? All these frequently encountered problems of spatia...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use Voronoi diagrams to control AI</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/72e/ae3/85472eae3f21727c4aadfe6e2d4163ed.jpg" alt="image"></div><br>  Which route will be the safest, where are the most enemies and where is the nearest first-aid kit?  All these frequently encountered problems of spatial relationships can be effectively solved using mathematical partitions called ‚ÄúVoronoi diagrams‚Äù.  From this post you will learn how to analyze game cards and receive information that ensures the realism and success of artificial intelligence. <br><br><hr><br><h2>  Spatial relationship </h2><br>  A spatial relationship is any information that describes how one object in space is related to another.  Examples: the distance between them, the area covered by each of them space and the intersection of these areas, the number of such objects located in one area. <br><br>  Such relationships are constantly used in video games and can provide very useful AI information, as well as to the player himself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <hr><br><h2>  Voronoi has an answer </h2><br>  <em>The Voronoi diagram</em> describes the spatial relationship between closely spaced points or their nearest neighbors.  This is a set of connected polygons obtained from points or locations.  Each line of Voronoi‚Äôs ‚Äúarea‚Äù is located in the middle between two points. <br><a name="habracut"></a><br>  To understand, take a look at the picture: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68f/3dc/436/68f3dc436fad96e06d62ef41be9ef82f.jpg"></div><br>  As you can see, each line is exactly in the middle between two points, and all of them are connected in the center.  Add a few more points to the scene and see what happens: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/7d5/6f9/c2d7d56f92f8db40003f0e1399ae0f9f.jpg"></div><br>  The picture has become more interesting!  We are already having real areas. <br><br>  What does each of the areas tell us?  We know that being in the area are guaranteed to be located closest to one point, which is also in the area.  This tells us a lot about what's nearby;  such is the fundamental spatial relation in Voronoi diagrams. <br><br><hr><br><h2>  Turn Voronoi inside out: Delaunay triangulation </h2><br>  The system opposite to the Voronoi diagram is called Delaunay triangulation.  This diagram consists of lines from each point to its nearest neighbors, and each line is perpendicular to the Voronoi edge it intersects.  Here's what it looks like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/012/979/fb1/012979fb1c8f4520fb9d1db58017aaac.jpg"></div><br>  White marks the Delaunay line.  Each Delaunay line corresponds to one and only one Voronoi edge.  At first, it seems that some of them cross several edges, but looking closely, you will understand that this is not so. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df7/349/118/df734911841a7152f0f5a3ad1af1db3b.jpg"></div><br>  In the figure, the green Delaunay line corresponds to the pink rib of Voronoi.  Just imagine that the pink rib goes further and you see that they intersect. <br><br>  Thanks to Delaunay triangulation, we see that instead of polygons we now have many triangles.  This is incredibly useful because we divided the area into triangles that can be rendered.  This technique can be used for tessellation or triangulation of figures.  Fine! <br><br>  In addition, this is a great way to create a graph from multiple points in case we want to move from one point to another.  For example, dots may indicate cities. <br><br><hr><br><h2>  Voronoi data structure </h2><br>  We already know what the Voronoi diagram looks like;  Now let's see how its data structure will look.  First, we need to save the points that are the basis of the Voronoi diagram: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiPoint</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> y VoronoiRegion* region }</code> </pre> <br>  Each <code>VoronoiPoint</code> has a location <code>(x, y)</code> and a link to the area in which it is located. <br><br>  Next we need to describe <code>VoronoiRegion</code> : <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiRegion</span></span></span><span class="hljs-class"> </span></span>{ VoronoiPoint* point Edge *edges[] <span class="hljs-comment"><span class="hljs-comment">// our list of edges }</span></span></code> </pre> <br>  The area stores a link to its <code>VoronoiPoint</code> , as well as a list of <code>VoronoiEdges</code> edges <code>VoronoiEdges</code> . <br><br>  Let's see what <code>VoronoiEdges</code> looks <code>VoronoiEdges</code> : <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiEdge</span></span></span><span class="hljs-class"> </span></span>{ VoronoiPoint* pointA VoronoiPoint* pointB <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> distance <span class="hljs-comment"><span class="hljs-comment">// distance between point A and point B float x1, z1, x2, z2 // to visualize start &amp; end of the edge }</span></span></code> </pre> <br>  An edge knows two points that define it, as well as the distance between them.  For visual display, as well as for constructing the shape of the polygonal region, we need to store the start and end points of the edge. <br><br>  And that is all.  With this information, we can easily build a Voronoi diagram.  Below we will learn how the Voronoi diagram is generated.  But for now, let's look at a couple of examples of how this data can be used. <br><br><hr><br><h2>  Find your nearest medicine cabinet </h2><br>  Again, look at the Voronoi diagram for points. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6cc/2eb/30f/6cc2eb30f8f91dce85a0543392806f96.jpg"></div><br>  If each point indicates a first-aid kit, then we can quickly determine where the closest to us is, but first we need to determine the area in which we are.  Voronoi diagrams do not provide an effective way to define an area, however, to speed up the search, we can store a link to each area in the <a href="https://gamedev.tutsplus.com/tutorials/implementation/quick-tip-use-quadtrees-to-detect-likely-collisions-in-2d-space/">quad tree</a> or in the <a href="http://en.wikipedia.org/wiki/R-tree">R-tree</a> .  And having learned the region, we will be able to recognize its neighbors, and the neighbors of its neighbors. <br><br>  For example, if there are no more first-aid kits in your area, then you need to find a path to another nearest one.  From the data structure and the pseudo-code shown above, we can understand that knowing the region, we can recognize its edges.  And with the help of these ribs we can get neighbors.  We will take the closest neighbor and see if there is a first-aid kit in it. <br><br>  Here you can also apply Delaunay triangulation.  It consists of lines between the first-aid kits.  Then you can get around it using the A * path search algorithm to find the nearest first-aid kit. <br><br><hr><br><h2>  Search for a safe route </h2><br>  Replace all first-aid kits with enemy watchtowers.  You need to find the safest route between them so as not to be caught.  The standard way of graph traversal in video games is to use <a href="http://en.wikipedia.org/wiki/A*_search_algorithm">the A * algorithm</a> .  Since the Voronoi diagram is a graph, it is very easy to implement a search.  All we need is an A * algorithm that supports general graph structures;  plan ahead and it will help you in the future. <br><br>  Having prepared the graph, you need to assign weight to each edge.  For us, the weight value will be the distance to these watch towers, and you can get it directly from the data structure: each <code>VoronoiEdge</code> already knows its distance between two points.  Usually, the smaller the value on the edge A *, the better, but in our case, the larger the value, because it indicates the distance to the tower. <br><br>  This is what the initial graph looks like if we want to move from point A to point B: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/f97/d9b/cabf97d9bca898552adbdf4af9b67da2.jpg"></div><br>  Applying weight to each edge, we will see which route is better to choose: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c9f/5b2/0c1/c9f5b20c1d46a46a629a7c5f2f35622f.jpg"></div><br>  Red ribs indicate the nearest contacts with the towers.  Orange indicates longer ones;  yellow even more distant, and finally, green - the safest.  After executing A * with these weights, we get the following path: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/854/72e/ae3/85472eae3f21727c4aadfe6e2d4163ed.jpg"></div><br>  With this use of the scales, not <em>the fastest</em> , but <em>the safest</em> way will be chosen, which is what we need.  AI should adhere to this path and not deviate from it! <br><br>  You can take another step to <em>guarantee a</em> safe path: eliminate all edges that are closer than the minimum safe distance.  For example, if each watchtower has a radius of visibility of 30 units, then all edges, the distance to which points are shorter, can be removed from the graph and not bypassed. <br><br>  You can also use this method to find the widest route for large units that are unable to pass through bottlenecks.  Each edge has a distance between two points, so we know if they can pass in this space. <br><br>  You can also perform the opposite operation - use the Delaunay triangulation diagram, and get the lines coming from each watchtower.  The guards' AI will be able to quickly determine which other towers are nearby and, if necessary, go to their aid. <br><br><hr><br><h2>  Search for a tightly positioned item set </h2><br>  Suppose we need to drop a catnip parcel from a plane for a bunch of seals sitting on the ground.  What is the best place to drop it so that the largest number of cats can use it?  This can be extremely costly.  But, fortunately, we can make a reasonable assumption using the Delaunay triangulation. <br><br>  <strong>Hint:</strong> do not forget that Delaunay triangulation is just the inverse of the Voronoi diagram.  It is formed by connecting each Voronoi point with neighboring points obtained from the list of edges. <br><br>  With this collection of triangles, you can explore the area covered by each of the triangles.  If we find the triangle with the smallest area, then we have three nearest points, or cats.  This may not be the densest average cluster on the surface, but it will be a good assumption.  If we could discard a few parcels with mint, we would just mark the triangles already selected and move on to the next ones in increasing size. <br><br>  The designation of such regions is also called the <em>circumscribed circles of the</em> Delaunay triangulation.  Each circle is the largest circle that can fit at the points of the triangle.  Here is an image of the circumscribed circles for the Voronoi diagram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e96/176/069/e96176069d2be2556c43483ea43c297f.jpg"></div><br>  You can use the exact center of the circles to determine the center of the area where the catnip is shipped.  In fact, the radius of the circle is a more suitable way to determine the best triangle to fold instead of the area of ‚Äã‚Äãthe triangle, especially if the two points of the triangle are very close to each other and the third is far away;  then we get a very sharp triangle with a small area, but the points that define it are actually very far apart. <br><br><hr><br><h2>  Implementation of Voronoi diagrams </h2><br>  There are several ways to generate Voronoi diagrams, and the choice of the method used depends on the time at which we receive the data. <br><br><h3>  Fortune Algorithm </h3><br>  The fastest way is called <a href="http://en.wikipedia.org/wiki/Fortune%2527s_algorithm">Fortune's algorithm</a> .  It runs in <code>O(n log(n))</code> and requires that all points used to generate the graph be known at the time the generation starts.  If you add new points later, you will have to regenerate the entire graph.  If there are few points, then this may not cause problems, but if you have 100 thousand of them, then this can take a lot of time! <br><br>  The implementation of this algorithm is nontrivial.  Cross parabolas and special cases.  However, this is the fastest method.  Fortunately, there are many implementations of this open source algorithm that you can use, and I have provided links to them below. <br><br>  Let's see how it works. <br><br>  The algorithm consists in sliding a line (vertical or horizontal) over an area with dots.  When he meets a point, he begins to draw a parabola out of it, which continues with a sweeping line.  Here is the animation of this process: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/dd5/e7b/275dd5e7b349677ce90353a2265cdfbc.gif"></div><br>  Intersecting parabolas form the Voronoi ribs.  But why parabolas? <br><br>  To understand this, imagine each point as containing an inflatable balloon that inflates until it collides with another ball.  You can transfer this idea to circles expanding on a 2D plane.  We will make another ball forward and place at each point an inverted cone with an angle of inclination of 45 degrees, increasing to infinity.  Then imagine a sweeping line in the form of a line, also at 45 degrees, which slides along until it collides with the cones.  Since the plane and the cones are located at the same angle, when they cross, they form parabolas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08d/c72/10f/08dc7210fe8d7a078dd389c9be6ced12.jpg"></div><br>  Growing up, the cones sooner or later intersect with one or more other cones.  If we look at the intersection of the cones, or circles, we get straight lines of the Voronoi edges.  In the figure, the red line indicates the intersection of the cones.  If the cones grow even further (vertically up to infinity), then the red line will continue to stretch. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0f/b43/7f1/b0fb437f1d95b9773f3c554336cfe1db.jpg"></div><br>  When the plane slides and the first contact with the cone occurs, the resulting line will be like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68e/134/96a/68e13496a2d98c84ad6da32be5dabc15.jpg"></div><br>  With further movement of the plane along the cones, we will see how parabolas form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b6/1ba/04a/0b61ba04af4c8f93e475d88f76bb408d.jpg"></div><br>  The plane continues to move around the stage.  For each point it encounters, it examines neighboring points on the sweeping line that already have parabolas and starts a new parabola at that point.  She continues to move on and grow until this new parabola begins to overlap not with the one that was previously superimposed.  Then this previous parabola closes.  This is the point at which Voronoi‚Äôs lines of three points meet. <br><br>  As stated above, this is pretty hard to understand, so here are links to open source implementations that you can use and learn: <br><br><ul><li>  Java on GitHub.  Authors: Benny Kj√¶r Nielsen and Allan Odgaard <a href="https://github.com/sorbits/visual-fortune-algorithm/tree/master">https://github.com/sorbits/visual-fortune-algorithm/tree/master</a> <br></li><li>  Python on GitHub: <a href="https://github.com/MikkoJo/Voronoi">https://github.com/MikkoJo/Voronoi</a> .  Posted by: Mikko Johansson </li><li>  A detailed implementation of Fortune's algorithm: <a href="http://blog.ivank.net/fortunes-algorithm-and-implementation.html">http://blog.ivank.net/fortunes-algorithm-and-implementation.html</a> </li></ul><br><h3>  Incremental Triangle Insertion </h3><br>  Another method is to incrementally insert one point at a time, starting with a base triangle of three points outside the possible area of ‚Äã‚Äãall other points.  This method runs with <code>O(n^2)</code> and does not require all points at the time of generation. <br><br>  When you insert a new point, it defines the existing area in which it falls.  This area is then subdivided and new areas are created. <br><br>  Here is an open source example to use and learn: <br><br><ul><li>  Java source.  Posted by: <a href="http://www.cs.cornell.edu/Info/People/chew/chew.html">Paul Chew</a> .  For free use.  <a href="">Download the zip file</a> .  Source: <a href="http://www.cs.cornell.edu/home/chew/Delaunay.html">http://www.cs.cornell.edu/home/chew/Delaunay.html</a> </li></ul><br><hr><br><h2>  Conclusion </h2><br>  Now you have to imagine what Voronoi diagrams can give your game and its AI.  If you have a properly structured graph of nodes and edges, you can request important information so that everyone gets their first-aid kits, catnip and makes their way past enemy towers. </div><p>Source: <a href="https://habr.com/ru/post/460813/">https://habr.com/ru/post/460813/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460803/index.html">Reading for the summer: books for techies</a></li>
<li><a href="../460805/index.html">How to transfer data between microcontrollers at 100 Mbps</a></li>
<li><a href="../460807/index.html">Measure seven times, once implement BI tool</a></li>
<li><a href="../46081/index.html">Data encryption in php with public key</a></li>
<li><a href="../460811/index.html">Common components by different teams. Yandex Report</a></li>
<li><a href="../460815/index.html">Inventing the vusb library</a></li>
<li><a href="../460819/index.html">WorldSkills: Review from the participant of the Olympiad</a></li>
<li><a href="../460821/index.html">The digest of interesting materials for the mobile developer # 307 (July 15 - 21)</a></li>
<li><a href="../460823/index.html">Digital events in Moscow from July 22 to July 28</a></li>
<li><a href="../460825/index.html">Introduction to Screen Capture API - Scan QR codes in a browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>