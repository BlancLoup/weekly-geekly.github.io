<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of buck-converter on STM32F334: principle of operation, calculations, prototyping</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my last two articles, I talked about the power module and the control board based on the STM32F334R8T6 microcontroller, which were created specific...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of buck-converter on STM32F334: principle of operation, calculations, prototyping</h1><div class="post__text post__text-html js-mediator-article">  In my last two articles, I talked about the power module and the control board based on the STM32F334R8T6 microcontroller, which were created specifically to implement control systems for power converters and electric drives.  An example of a DC / AC converter was also considered, which was a demonstration, not a complete construction.  Now it's time to do something simple, but useful, and most importantly complete. <br><br>  Most of the issues related to the project and power electronics are related to specific topologies: someone is interested in knowing the PFC control algorithm, someone wants to learn how to build a half-bridge LLC, but the most popular topology is undoubtedly buck.  After all, a buck converter (also known as a buck converter) is the main one for most interesting projects: it is a driver for LED luminaires, and the basis of an MPPT controller for solar panels, and chargers, and much more. <br><br>  There is a lot of information on the buck in the network, including datasheets, but it is scattered and I personally haven‚Äôt met any material that describes in detail the process of creating a digital-controlled buck converter.  It's time to fix it.  There is practically no mathematics, an explanation ‚Äúon the fingers‚Äù, so it will be interesting to anyone who is somehow connected with electronics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href=""><img src="https://habrastorage.org/webt/j4/jp/fv/j4jpfvx10zexln6bwiv8gd6dbkc.jpeg"></a> <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  First you need to understand what we want to get in the end and what kind of input we have.  The buck topology is downward, that is, it allows you to build a downward voltage converter.  As you will see below, the voltage at the output of the buck-converter is almost linearly dependent on the input voltage, so you need to add feedback.  Today I will talk about simple voltage feedback (voltage mode), which is the most obvious and will allow you to understand the principle of operation, and you will have enough of such feedback for most tasks. <br><br>  At the end of the article we will get a working stabilized voltage source in the ‚Äúsynchronous buck‚Äù topology, operating at a sufficiently high frequency with digital control, implemented on the STM32F334R8T6 using the High Resolution PWM (HRPWM).  The input voltage range is 15 ... 60V, the output voltage is 12V, the maximum output current is 2A. <br><br><h2>  Chapter 1. The principle of the buck topology </h2><br>  I will begin to tell from the very basics and will gradually improve our converter, since  ‚ÄúSynchronous buck‚Äù is an improved version with increased efficiency and control complexity.  The basic topology, which you probably used, is as follows: <br><br><img src="https://habrastorage.org/webt/of/mv/yq/ofmvyqyaxkystxgvsiiauznkfqs.png"><br><br>  This topology is used in low-power voltage converters, for example, to power digital circuits and other low-power devices.  The dc / dc downgrades that you use in your devices are most likely implemented on microchips for this topology.  An example of such a chip <a href="https://www.digikey.com/product-detail/en/texas-instruments/LMR16006YQ3DDCRQ1/296-42514-1-ND/5416012">LMR16006</a> . <br><br>  The principle of operation of this circuit is very simple, the PWM signal is sent to the VT1 transistor, the work itself is divided into 2 stages, which alternate one after another: <br><br><ul><li>  <b>Stage of energy storage in the LC circuit.</b>  At this stage, the transistor VT1 is open and the current flows through the transistor to the load, simultaneously accumulating energy in the inductance coil and output capacitance: <br><br><img src="https://habrastorage.org/webt/xb/x9/fi/xbx9fi3blibz8mc6t-unq7qeaau.png"></li><li>  <b>Stage of discharge.</b>  At this stage, the transistor VT1 closes and the most interesting begins.  A choke is such a thing that accumulates energy if a potential is applied to it (open VT1) and gives it away if the potential disappears (VT1 is closed).  At the same time, he seeks not only to give energy, but to preserve the current value and its direction, therefore, in order to use this property, you need to add a VD1 diode to close the circuit, because the current flows only in a closed circuit: <br><br><img src="https://habrastorage.org/webt/fm/qr/z2/fmqrz2uboiwpztct_hjh9stsgws.png"></li></ul><br>  When I got acquainted with this topology at 6-7m class, I didn‚Äôt understand right away why the diode does not conduct current at the 1st stage, now it seems trivial, but I think it is worth mentioning.  When VT1 is open, a + VIN potential is applied to the cathode of the VD1 diode, for example, + 20V, and a ground potential is applied to the diode anode.  In order for the current to flow through the diode it should be exactly the opposite: the potential at the anode must be greater than the potential at the cathode, therefore, in a buck, the diode is ‚Äúclosed‚Äù at the energy accumulation stage.  At the stage of discharge, the diode already closes the circuit, the potential + VIN does not act on its cathode and does not ‚Äúlock‚Äù it.  I hope clearly explained. <br><br>  Here you should have a question: ‚ÄúAnd what voltage will be at the output, if we applied to the input 20V?‚Äù.  As always, everything is simple: <br><br><img src="https://habrastorage.org/webt/hv/oz/g6/hvozg6kwwhf1nekotraxpmdo2gc.png"><br><br>  As can be seen from the formula, the output voltage linearly depends on the duty cycle (duty) of the PWM signal, which we apply to the VT1 transistor.  If someone does not know or has forgotten the ‚Äúduty ratio‚Äù is the ratio of the time that the transistor is in the open state to the period duration.  This ratio can take a value from 0 to 1 or from 0 to 100%.  Then we will operate with this particular figure when controlling the converter, but for understanding the essence let's substitute this relation into the formula: <br><br><img src="https://habrastorage.org/webt/c5/ij/ax/c5ijaxxjgvlviopshgx_uumfvh4.png"><br><br>  The frequency of the buck-converter value is constant and is selected when designing, during operation it does not change, and therefore the period (T) is constant.  It turns out that the output voltage directly depends on two physical quantities: <br><br><ul><li>  from the time at which we open the upper transistor (VT1) - the longer it is open, the more energy accumulates in the LC filter and, accordingly, the higher the output voltage; </li><li>  from the input voltage, for example, if we fixed the filling to 50% and change the Vin from 20 to 40V, then the output voltage will also vary from 10 to 20V. </li></ul><br>  I think you have started to see the overall picture and the principle of work, let's fix it now and look at the real oscillograms and check this ratio in practice.  I have assembled a buck model, which is loaded with a 10W LED.  I used 3 oscilloscope channels, which are included in the following points: <br><br><img src="https://habrastorage.org/webt/xo/pd/by/xopdbyfozm6wgh3fgz8pdeuojum.png"><br><br>  <b>Test ‚Ññ1 - Input voltage (Vin) constant 20V, changing the fill factor</b> <br><br><ul><li>  Vin = 20V, D = 25%, Vout = D * Vin = 0.25 * 20V = 5V <br><br><img src="https://habrastorage.org/webt/i3/5k/p5/i35kp5uw2m0tsofihsydvow6xws.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0.5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/lg/zt/bb/lgztbbg8ztwdqwwni9zfgzrdyg4.png"></li></ul><br>  As you can see on the oscillograms, the relation between the output voltage and the fill factor is correct.  Of course, this was an ‚Äúidealized‚Äù experiment; in reality, the input voltage is not stable and floats in a fairly wide range.  Let's now see what will be the dependence on the input voltage with a fixed filling. <br><br>  <b>Test No 2 - The input voltage (Vin) changes, the fill factor is constant and is 50%.</b> <br><br><ul><li>  Vin = 15V, D = 50%, Vout = D * Vin = 0.5 * 15V = 7.5V <br><br><img src="https://habrastorage.org/webt/er/at/_k/erat_kgnli3usl6pf2gnvs4tgky.png"></li><li>  Vin = 20V, D = 50%, Vout = D * Vin = 0.5 * 20V = 10V <br><br><img src="https://habrastorage.org/webt/u7/_1/ek/u7_1ekajdvcyhccqmttgiiiqbzy.png"></li><li>  Vin = 30V, D = 50%, Vout = D * Vin = 0.5 * 30V = 15V <br><br><img src="https://habrastorage.org/webt/ak/1z/na/ak1znaux-gyaj1o6uxx49ewcisu.png"></li></ul><br>  Now we are convinced in practice that the output voltage also linearly depends on the input voltage with a fixed fill factor.  Understand how to stabilize the output?  The principle of stabilization is simple as the formula itself - Vout is 12V and a constant, we can change the fill factor using a microcontroller, so if Vin increases, then the output voltage increases and at this point we decrease the fill factor (duty) again until 12V.  Accordingly, with a decrease in Vin, we begin to increase the fill factor until, again, the voltage Vout becomes 12V. <br><br>  What else would you like to pay attention to in the theoretical section ... Oh, yes!  Surely you wonder how PWM with an amplitude of 20V after the transistor eventually turned into a constant voltage with scanty pulsations?  Indeed, if we put the red probe of the oscilloscope at the source of the transistor VT1, the green probe after the LC filter, we will see the following picture: <br><br><img src="https://habrastorage.org/webt/pe/3o/ox/pe3ooxj5ghth4p2ibxtpubt-rg8.png"><br><br>  You can see how the LC-filter "lubricates" the alternating voltage into a constant, but the point is that the energy stored in the inductance and capacitance cannot be instantly consumed, hence the voltage cannot instantly change.  We get that at the moment when the PWM before the choke is 0V, the output voltage is provided by the energy stored in the filter, which does not dissolve instantly and is enough to maintain the voltage at the time of closing VT1.  This is all on the fingers of course, if it is interesting to go deeper, then as always I advise you to start the book <b>B.Yu.</b>  <b>Semenova "Power electronics: from simple to complex"</b> , there is a whole chapter on the buck (chopper). <br><br><h3>  Fight for efficiency </h3><br>  As I wrote a little earlier - it was a basic version of the topology.  Its main disadvantage is high losses on the blocking diode.  What current in the simple systems working on MK and CPLD?  Usually within 1A, sometimes 2A, if there is some TFT display.  In this case, the loss even when using a Schottky diode will be 0.4V * 2A = 0.8W.  In principle, it is tolerable, it is possible to dissipate so much on the SMA / SMB case without problems, although at a voltage of 3.3V and 2A a loss of 0.8V is still 12% efficiency! <br><br>  Now imagine a case where the current is 20A.  It could be an MPPT controller, a large FPGA power system and much more.  In this case, the loss will be 0.4V * 20A = 8 W!  What does it mean?  For example, in the case of MPPT, you will have less energy stored in the battery, in the case of powering the FPGA it will be an additional 8 W of heat that needs to be dissipated somewhere and in both cases it is undoubtedly a loss of overall efficiency.  What can be done?  And let's replace the VD1 diode with another N-channel Mosfet and get the following circuit: <br><br><img src="https://habrastorage.org/webt/nb/om/7b/nbom7baf8horcmhuevpeeelxkoc.png"><br><br>  Now the transistor VT2 acts as a diode, that is, conducts a current when VT1 is closed.  The diode, which was in the basic version did not require control, but now we have to pay for an improvement in performance with an additional control channel with a PWM signal. <br><br>  First, let's calculate how much we have reduced losses.  The resistance of the channel of the modern mosfet is a few mŒ©.  As an example, let's take a transistor from my power module, which I described in previous articles - <a href="https://www.digikey.com/products/en%3Fkeywords%3DIPP083N10N5A">IPP083N10N5AKSA1</a> with a channel resistance of 8.3 megohms.  We get static losses equal to 0.0083 * 20A * 20A = 3.32 W.  Of course, there will also be dynamic losses, which with an adequately designed driver will be no more than 20%, that is, the total losses will be 4W.  We get that the transition from the usual buck-to synchronous allows halving the losses on the diode. <br><br>  Let us now analyze the complicated management.  As we already understood, the blocking diode conducted the current when VT1 was closed.  From this it follows that VT2 must be closed when VT1 is open and, accordingly, VT2 is open when VT1 is closed.  If it is simpler, the transistors work alternately: or one is open or the other, if both transistors open, a through current will arise, since  they are closed between themselves VIN and GND.  Let's see what should be the signal, where the ‚Äúyellow channel‚Äù is a VT1 transistor and the ‚Äúgreen channel‚Äù is a VT2 transistor: <br><br><img src="https://habrastorage.org/webt/wu/bc/mo/wubcmogqwk-__w6eroszeyozsv0.png"><br><br>  As you can see, if the logical channel ‚Äú1‚Äù is set in the yellow channel (on VT1), then at that time a logical ‚Äú0‚Äù should be set in the green channel (on VT2).  We obtain that VT1 pumps energy into the LC filter, and VT2 closes the circuit at the stage of discharge. <br><br>  There is one more thing about which you have already heard or read above - <b>through</b> - <b>through current</b> .  The fact is that a real, not an ideal transistor (mosfet) has a certain capacity on the gate, that is, in reality, it does not instantly go from log.0 to log.1, and the energy in the transistor does not dissolve instantly, resulting in transistors for a short time at the moment of switching may both be open.  This can lead in the best case to increased losses, which means heating up and in the worst case to the woman, since  Through current is a common short circuit (short circuit).  To avoid this, between turning off one transistor and turning on another, a delay, or so-called dead-time, is introduced.  It looks like this: <br><br><img src="https://habrastorage.org/webt/u8/wg/if/u8wgifnybpzrkjg1gfxua-w0gye.png"><br><br>  I think you noticed that there is a small space on the signal switching edge.  I installed it obviously large (about 3%) so that you can see it, in reality it is much smaller.  In general, dead-time (further dt) is set as short as possible, but at the same time sufficient for the transistors to close.  It can be calculated, or it can be chosen empirically, I personally think that this and that option is normal, but bearded Jedi will surely tell you: ‚ÄúIt must be considered necessary, but it is better to simulate!‚Äù.  This is certainly correct, but decide for yourself - if you are not too lazy to model in LTspice taking into account the parasitic inductances and capacitances of conductors and components. <br><br>  For the stand in this article, I set the dt to ~ 100 ns (actually 104).  My module allows you to install it significantly less, because  The driver is very harshly applied, but surely many of you will assemble your layout without my module, which means there will most likely be snot there.  I‚Äôll leave dt with a margin so that I don‚Äôt bang because of the snot, and if you have a normal layout on the board, then you can reduce it yourself - then in the chapter on the code you will see how, but in the meantime we‚Äôre actually looking at dt: <br><br><img src="https://habrastorage.org/webt/b-/tm/ft/b-tmftfkzmq7xezwdbbd67gaxf4.png"><br><br>  Here you can see that dt lasts 2.5 divisions and each division is 40 ns - it means that the duration is ~ 100 ns as intended.  I hope you understand why dt is needed, how long it should be, and how the buck topology works in general.  If you do not understand, then as usual the questions in the comments, HP and the mail are accepted, while I seem to be answering everything. <br><br><h2>  Chapter 2. The calculation of the main components </h2><br>  In this part of the article, I will show how to quickly and simply calculate the main power components for a synchronous buck-converter, namely: choke, input and output capacitors, transistors. <br><br>  <u>I recall the introductory data:</u> <br><br><ul><li>  Input voltage: 15 ... 30V </li><li>  Output voltage: 12V </li><li>  Rated output current: 2A </li><li>  Switching frequency: 100 kHz </li></ul><br>  Output voltage 12V is selected because  As a load, I plan to use a 12V 20W LED, which is at hand and is a very visual load.  Anticipating the questions of the ‚Äúexperts‚Äù in the comments - yes, I am aware that the LED needs current stabilization, but we do a voltage regulator and the LED is just a load. <br><br>  The input voltage is chosen from the bald, you can do 15 ... 60V, so if you are interested in a different range, you can calculate the value of the components for it.  A rated current of 2A is chosen to obtain an output power of 12V * 2A = 24 W, that is, slightly more than is needed for the LED.  The LED itself at 12V consumes about 1.82 ... 1.9A. <br><br>  The most interesting parameter remained - the operating frequency of the converter.  What should it be?  Here you have to answer yourself, in my case it is 100 kHz.  The choice is based on two theses: <br><br><ul><li>  Increasing the frequency leads to a decrease in the required inductance of the choke, the input and output capacitors.  Simply put, as the frequency increases, the size of the device decreases.  With decreasing frequency, dimensions increase. </li><li>  Reducing the frequency leads to an increase in efficiency, because  dynamic losses when switching transistors are reduced.  Increasing the frequency increases the dynamic component of the transistors and accordingly reduces the efficiency. </li></ul><br>  Now I will not talk about the choice of frequency, just accept that 100 kHz.  After I show the calculation method, we will return to this question, because  the formulas will more clearly show the dependence of the denominations of the main components of the operating frequency. <br><br>  <b>Step 1. Select transistors</b> <br><br>  We will be mainly interested in 3 parameters: maximum drain-source voltage, channel resistance in the open state and gate capacitance.  The entire potential of the voltage source (Vin) is applied to the transistor, and there are also spikes at the moment of switching.  You have 2 options: take the transistor VT1 and VT2 with a voltage margin or the story RC snubber at VT2.  In my case, there are 100V transistors on the power module, and with an input 30V, this is a huge voltage margin, even 60V was enough to do without snubber and protect the transistor from breakdown. <br><br>  Channel resistance - here the less, the better, but there is one BUT.  With a decrease in channel resistance, we reduce static losses (I <sup>2</sup> * R), but the technology is such that the capacity of the shutter increases, and this leads to an increase in dynamic losses.  You have to find a middle ground between the "channel resistance" and "gate capacity".  For voltages up to 100V, I advise you to pay attention to Infineon's OptiMOS series transistors; you can already look at high voltages for parametric search or even towards IGBT transistors.  The latter are also supported by my power module and do not require any changes in the driver. <br><br>  <b>Step 2. Calculate the inductor inductance</b> <br><br>  It is necessary to calculate the minimum value of inductance, which will allow our dc / dc converter to work in the continuous current mode (L <sub>min</sub> ): <br><br><img src="https://habrastorage.org/webt/mj/np/-j/mjnp-jzmvy7qfodji_da3ryjeya.png"><br><br>  For variables, I think everything is clear, except - k <sub>ind</sub> .  These are permissible ripple currents in the choke, usually choose the value of 20 ... 50%, but I almost always set 30%.  The smaller the ripple of current, the further we will be from the saturation limit of the core on which the choke is wound, but as can be seen from the formula, we need a large inductance of the choke. <br><br>  Now we calculate the minimum value of inductance, which is needed for my input data, ripple, I will lay 30% as already written above: <br><br><img src="https://habrastorage.org/webt/ri/t9/2h/rit92hfsubagcqaozaebmcl7alw.png"><br><br>  It should be understood that this is the minimum inductance required for the buck-converter to operate in the continuous current mode, but again there is a nuance.  In the process of increasing the current acting in the winding, the permeability of the core and the inductance of the choke WITHOUT current and With the current are slightly different, somewhat different for different materials.  In order to avoid the situation when the inductance decreased below L <sub>min</sub> and the dc / dc did not go into the discontinuous current mode when the current increased in the inductor, it is necessary to slightly increase the inductance, that is, add a couple of extra turns during the winding.  Increasing the inductance by 10-15% will be enough for the material Kool Mu, and my choke will be on it. <br><br>  <b>Step 3. Calculation and manufacture of the throttle</b> <br><br>  I wanted to describe this procedure in the ‚Äúprototyping‚Äù section, but then the inductance calculation stage would have remained less clear for you, and probably missed the interesting pictures, so I‚Äôll describe everything here.  For the manufacture of the throttle, I will take the throttle R26 / 14/11 (R is a ring, and the numbers are dimensions) from the material Kool Mu with permeability 60, download the documentation on it and you can buy it here - <a href="https://ferrite.ru/warehouse/r-27-7-x-14-1-x-12-serdechnik-0077894a7.html">Lepkos</a> . <br><br><img src="https://habrastorage.org/webt/kc/mp/e1/kcmpe19wpeprrdiz0qznmnefxyk.jpeg"><br><br>  Now you need to count how many turns and which wire to wind.  Let's start with the number of turns perhaps.  In the documentation on the core there is such a convenient parameter - A <sub>L</sub> , which is equal to 75 nH / revolution <sup>2</sup> .  Here carefully - the turns in the square!  To find the inductance of the core, you must multiply A <sub>L</sub> by the number of turns in the square.  Hence, the formula for finding the number of turns looks like this: <br><br><img src="https://habrastorage.org/webt/ls/dn/zr/lsdnzrojp7ab0aijmv46pxllh0q.png"><br><br>  In order to obtain the minimum required inductance, it is necessary to wind 40 turns, but as we have already discussed, it is necessary to slightly increase the inductance, say, throw +3 turns.  Take the ring and wind 43 turns, we get the following choke: <br><br><img src="https://habrastorage.org/webt/un/5e/ij/un5eijbi_ksbefygjbn4pkrckli.jpeg"><br><br>  Now for the sake of interest let's calculate what inductance should be: <br><br><img src="https://habrastorage.org/webt/rj/yl/mm/rjylmmkynrrleoebfmoilq1oyzm.png"><br><br>  And for reliability, we check the inductance of the choke with tweezers: <br><br><img src="https://habrastorage.org/webt/tm/ze/qj/tmzeqjuzno3yp3tkpkcmy8jozoa.jpeg"><br><br>  137 ŒºH, great!  The results agreed, the error is within ¬± 8% for A <sub>L.</sub>  Here it is worth noting - if you do not have the ability to measure inductance, then do not buy cores for aliexpress, in ChiD, complex, electronic engineer and other ‚Äúeatery‚Äù - there is a chance to get a core from another material or not that permeability, but with proper marking - verified.  Without the ability to measure inductance, you will not be able to test A <sub>L</sub> and you will be able to spend a lot of time searching for the cause of the ‚Äúbroadshaft‚Äù of your converter. <br><br>  Then a reasonable question will appear - ‚Äúwill we have enough of the core and its dimensions?  Maybe it was necessary more? ".  For the material Kool Mu, the magnetic induction limit is 0.5 T, in practice it is better not to climb over the threshold above 0.45 T without obvious need.  It turns out that the winding wound on the core does not have to create an induction at each point of the core more than 0.45 T, so check: <br><br><img src="https://habrastorage.org/webt/1w/vf/me/1wvfmenl-jqsxqbnhsj-itnzgoe.png"><br><br>  As you can see, the value of magnetic induction 0.06 T is much lower than the limit 0.5 T.  Two conclusions can be drawn from this: firstly, the throttle will not go into saturation, and secondly, the core is very large and powerfully take a ring of substantially smaller size.  I took the ring R26 simply because I have a whole box of them, there is no other secret meaning here. <br><br>  It remains to determine what wire size to take for the choke.  Firstly, I strongly advise you not to take a wire with a diameter of more than 1 ... 1.2 mm at such high frequencies, since  The skin effect already has a significant effect and reduces the effective cross section.  Secondly, the current density in the wire must be selected based on the conditions of cooling and power.  At low powers (up to 10‚Äì20 W), it is possible to safely lay a current density of 8. 10 A / mm <sup>2</sup> even without airflow.  At powers up to several kilowatts, it is better to lay the current density in the range of 5 ... 6 A / mm <sup>2</sup> , and at powers from 10 kW and further it will be reasonable to reduce the current density to 3 ... 4 A / mm <sup>2</sup> . <br><br>  I had a varnished wire with a diameter of 0.8 mm on hand.  Its cross section, respectively, is ~ 0.5 mm <sup>2</sup> .  At a current of 2A, we obtain a current density in the winding of about 4 A / mm <sup>2</sup> .  I could use a wire and half the size of the cross section, but my core is large enough, so the wire of a larger cross section got in without problems.  When you optimize your device, you will have to first read and then buy the wire of the desired cross section, then you will be able to get the optimal dimensions of the choke. <br><br>  <b>Step 4. Calculate the output capacitor</b> <br><br>  At this stage, as in the case of inductance, we will consider the minimum value of the capacitance, which must be installed in the LC filter at the output of the buck converter.  Accordingly, if you install more, it will be better and then you will see why.  Calculate capacity: <br><br><img src="https://habrastorage.org/webt/qn/_v/sf/qn_vsfifikijddrrspohgtod9a8.png"><br><br>  Of course, the capacity must also be set with a certain margin, especially if you use only ceramics at the outlet, since  its capacity is greatly reduced depending on the voltage applied to it.  You should also pay attention to the dependence on pulsations - the variable V <sub>pulse</sub> .  This is the maximum value of the ripple at the output, that is, ideally with a capacity of 147.8 microfarads, the amplitude of the ripple will be 0.2 V, that is, the output voltage will float in the range of 11.9 ... 12.1 V.  Want to reduce ripple?  Then reduce them in the formula and the value of the resulting capacity will increase accordingly, of course, you will not get a laboratory power supply simply by increasing the output capacity.  It is also necessary to take into account the need for a low ESR, for this purpose, 1-2 electrolytes are usually put in parallel and in parallel they are hung with ceramics a few microfarads with the X7R dielectric desirable.  If the budget allows, then you can replace the electrolytic capacitor with polymer tantalum (as in a GPU) and so ceramics are not needed, they have an ESR and so little. <br><br>  <b>Frequency considerations</b> <br><br>  Now, as I said, let us return to the question of choosing the operating frequency of the converter.  Let me divide the conclusions into several thoughts: <br><br><ul><li>      ,    ,              ‚Äî         </li><li>          ,         ,        2     4 .   ,          ,       ,     </li><li>      ,     ‚Äî     ,     ,    .  ! </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now for the bad ... The frequency increases, which means that the dynamic losses of transistors increase and this obviously leads to a decrease in the overall efficiency. </font><font style="vertical-align: inherit;">For any significant power, a reasonable frequency limit for a buck converter on mosfet s is 200 kHz and lower. </font><font style="vertical-align: inherit;">Want more power (hundreds of watts) and a huge frequency? </font><font style="vertical-align: inherit;">Welcome to the world of GaN transistors or resonant topologies</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think from these theses it became clear to you what the switching frequency affects, now you need to independently learn how to find the "middle ground" between losses on transistors and the size of the device. </font><font style="vertical-align: inherit;">In one of the following articles I will teach you how to optimize the working frequency for maximum efficiency, the main thing is not to forget that I was going to do it.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chapter 3. We collect the layout of the buck-converter </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, the most tedious, but important, part is over, now the hardware and code will go. Let's put together a model on which we will implement theoretical calculations. To do this, we need two modules about which I described in previous articles: the </font></font><a href="https://habr.com/post/428550/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">power module</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><a href="https://habr.com/post/430908/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">control module on the STM32F334</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . You can also collect a half-bridge from any IR2110 waste trap yourself on the breadboard, and use any MC: STM32-Discovery, LaunchPad, Arduino and simply adapt the operation logic and code to your favorite MC; nothing will be difficult if You understood from the first two chapters how the buck converter works.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, let's make our structural diagram of the buck more ‚Äúrealistic‚Äù by adding the nominal values ‚Äã‚Äãof all the components to it and correctly reflect the number of capacitors, as well as what part my power module can implement:</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/bo/qw/hx/boqwhxzou-myasxcamvspvq_oac.png"></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As can be seen from the diagram, the module already contains a half bridge (two transistors) for the implementation of a synchronous buck and input capacitor. By the way, the module has a huge margin in the module - there are 3 electrolytes of 1000 ¬µF each and 100V, which is enough to build a buck for 500 -800 watts. It remains for us to add a choke, which we have already manufactured and output capacitors, the latter, too, by the way, with a margin, since I found only 4700 microfarads of 25V for low voltage, but they are some kind of Chinese, so I also decided to pair a couple. In fact, 470 uF of one is enough, but I simply didn‚Äôt have such little things in the hatchet. It turns out this design:</font></font><br><br><img src="https://habrastorage.org/webt/sh/_r/ku/sh_rkup3otnnyiokil-egegoena.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As previously mentioned, a high power 20W LED is used as a load. </font><font style="vertical-align: inherit;">I don‚Äôt know how much he is shining, and it‚Äôs not very interesting, but at 12V it consumes just 21 ... 22 W, which is what my buck converter is designed for. </font><font style="vertical-align: inherit;">The LED itself smeared KPT-8 and screwed it to the radiator, it is of course not enough, but it lasts 5-7 minutes of operation without problems (heats up to +40 ... 50 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C), and I don‚Äôt need more. </font><font style="vertical-align: inherit;">We connect from the control module 2 signals HRPWM, GND and through the divider we catch the output of the buck to the ADC, as a result we have the following stand:</font></font><br><br><img src="https://habrastorage.org/webt/dl/ll/9v/dlll9v0povwnn86na34l1z1nvtc.jpeg"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chapter 4. We write software and run the converter </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we have everything we need to start writing code and liven up our buck converter. First, let's look at the pin-out for the STM32F334R8T6 microcontroller, which stands in the control module: </font></font><br><br><img src="https://habrastorage.org/webt/bw/0i/ao/bw0iaobhw935ug8xttkq_q73uio.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we understand what the microcontroller pins will be used. On the module itself, I will need only 1 of 5 channels to control the power section; we will use channel ‚ÄúA‚Äù. This channel, like the others, has 2 high-precision PWM outputs (HRPWM), 1 error input (we don‚Äôt use it), GND for combining the ground of the boards and 2 ADC channels (we‚Äôll use only one for voltage). </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little bit about HRPWM</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the open spaces of the Russian-speaking segment of the Internet, I practically did not encounter any training materials on HRPWM and did not meet at all materials on working with HRPWM based on STM32 microcontrollers, and this is a very useful peripheral. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article I will not delve into the theory of this periphery, so I will describe the essence. </font><font style="vertical-align: inherit;">HRPWM or High Resolution PWM is a PWM module that is familiar to us, which has a higher resolution setting of the duty ratio and, in addition, usually has more flexible settings.</font></font><br><br> <a href=""><img src="https://habrastorage.org/webt/mx/kb/ct/mxkbctdf9dhgu2ssfv1briuowmm.png"></a> <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The microcontroller STM32F334R8T6 has 10 HRPWM channels, which are combined into 5 groups of 2 channels each. </font><font style="vertical-align: inherit;">These 2 channels within the group can work both independently and form a complementary pair - the last one we need;</font></font></li><li>     2-      dead-time     ; </li><li>  10      ‚Äî Master timer,                .      Timer A...E    ; </li><li>   HRPWM  ,       72   HRPWM  144     (2)  PLL.          ; </li><li>     , ,           ,   4   (comp),      0  1       / ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There are modes for specific topologies, for example, the push-pull mode, which allows you to implement multiple push-pull topologies. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And this is only a small part of the features, on the HRPWM device diagram you can still see the possibility of synchronization with a bunch of events, DACs, built-in comparators to the MC, and alongside this flowchart there are many more documented features. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There remains the last question that needs to be addressed - ‚Äúwhy is this PWM high-bit?‚Äù. To do this, consider a simple example. Imagine that you decided to use the MK without HRPWM, say STM32F103C8T6, which also operates at 72 MHz. We need to control a half bridge at a frequency of 70 kHz, which step of regulation we can get: 72,000,000 / 1025 steps = 70,243 Hz. Yeah, we have 1025 steps and when adjusting we can change the output voltage with a theoretical step of 1/1025 = ~ 0.1%. Now we take STM32F334, with a clocking frequency of 144 MHz and a timer shift depth of 32 bits, we get the equivalent frequency of 144 MHz * 32 = 4.608 GHz. For those who are frightened and questioned in the figure:</font></font><br><br><img src="https://habrastorage.org/webt/7n/ot/o2/7noto2gpr5ht4fnztxskohfhx-m.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No, this is not the operating frequency, this is the equivalent frequency. What does this give us? We take the equivalent frequency of 4,608,000,000 Hz / 70,300 Hz = 65,535 steps. Now we can adjust the voltage (or current) at the output in 1/65 535 increments = ~ 0.001%, that is, 100 times more accurate!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now let's do it - the frequency is 700 kHz, which is normal for a multi-phase buck, for example. F103 will have 72 000 000 Hz / 700 000 Hz = 102 steps, which allows at best to get a regulation of 1%, but this is 1% for duty, that is, in reality, with so many steps you will have voltage to float at the output as if stabilizing and no special. Whereas for F334 the number of steps will be approximately 6500, which still allows you to build a very accurate voltage or current regulator. We get that the resolution (step) of the setting of the duty ratio is much higher / more often than that of a conventional MK with a standard PWM module inside. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setting up the clocking system</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a development environment in this article, I used TrueSTUDIO, because it is free, not as poor as Keil or IAR</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yes yes, tell me about his wonderful debugger</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cross-platform and perhaps the best solution for beginners and not only. </font><font style="vertical-align: inherit;">At the end of the article there will be an archive with the project for this particular IDE. </font><font style="vertical-align: inherit;">I will not tell you how to create and customize a project, just leave a link to the video, where everything is shown in detail - </font></font><a href="https://www.youtube.com/watch%3Fv%3DW6BczU1ua30%26list%3DPLUYH9oDZsrZ3TqCQg88m6N1l_hxTsUIlS%26index%3D16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">look</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After the project has been created and the LED has flashed, it is necessary to adjust the clocking system, namely from 8 MHz, raise the frequency to 72 MHz and feed it to the core, and then adjust the divider to reduce the frequency applied to the ADC:</font></font><br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartInitClock</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;CR |= RCC_CR_HSEON; <span class="hljs-comment"><span class="hljs-comment">// Enable HSE while (!(RCC-&gt;CR &amp; RCC_CR_HSERDY)); FLASH-&gt;ACR |= FLASH_ACR_LATENCY_1; RCC-&gt;CFGR |= RCC_CFGR_PLLMUL9; // PLL mult x9 RCC-&gt;CFGR |= RCC_CFGR_PLLSRC; // Source HSE RCC-&gt;CFGR2 |= RCC_CFGR2_ADCPRE12_DIV10; // ADC source AHB/10 RCC-&gt;CR |= RCC_CR_PLLON; while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0){} RCC-&gt;CFGR &amp;= ~RCC_CFGR_SW; RCC-&gt;CFGR |= RCC_CFGR_SW_PLL; // Select source SYSCLK = PLL while((RCC-&gt;CFGR &amp; RCC_CFGR_SWS) != RCC_CFGR_SWS_1) {} // Wait PLL }</span></span></code> </pre> <br>  Everything is simple, I think, the setup algorithm is as follows: <i>goes to external quartz (HSE) -&gt; wait for the transition to complete and set the ready flag -&gt; send the PLL signal from the quartz to the input -&gt; multiply 8 MHz by 9 -&gt; 72 MHz, divide by 10 to clock the ADC -&gt; turn on the PLL -&gt; wait until it turns on and sets the ready flag -&gt; feed the system bus and the core with the PLL -&gt; wait until the switch is completed -&gt; ready.</i> <br><br>  <b>HRPWM Setup</b> <br><br>  Here everything is somewhat more complicated.  There is a lot of functionality for this module, a lot of configurations and the amount of documentation is very large, but this is a minus and at the same time a plus - you have to pay for flexibility. <br><br><pre> <code class="cpp hljs">RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN;</code> </pre><br>  It is necessary to indicate that HRTIM is clocked from the PLL, the multiplier x2 is already on by default.  Then we just turn on clocking for HRTIM, here is the first feature - as we understand the timer is clocked by PLL, but turned on for APB2.  This is not entirely logical, but in a file with CMSIS it is easy to search or in the documentation. <br><br><pre> <code class="cpp hljs"> RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; <span class="hljs-comment"><span class="hljs-comment">// Alternative PP GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; // Very high speed GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; GPIOA-&gt;AFR[1] |= 0xDD; // PA8 and PA9 - AF13</span></span></code> </pre><br>  PA8 and PA9 is the output of Timer A, which on my module goes to channel No. 1, which you can see on the diagram and pin-out.  The legs are configured as a push-pull with an alternative function, the number of the function for both legs is the 13th.  It is also important to tune to the maximum GPIO frequency, otherwise it will be an incomprehensible blockage of the front and the fall of the signal, which is extremely critical for power electronics. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET);</code> </pre><br>  Before you start, you need to calibrate the timer, because  it works with minimal delays, then just wait for the ready flag. <br><br><pre> <code class="cpp hljs">HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].PERxR = PeriodTimerA; <span class="hljs-comment"><span class="hljs-comment">// Period for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Duty for timer A</span></span></code> </pre><br>  That went flexibility.  Firstly, we can set our own frequency for each timer A ... E, then we simply record the period of our PWM.  Secondly, by default we have the PIMA alignment at the beginning of the period, that is, the signal goes to log.1 at the beginning of the new period, and now we need to choose when it returns to log.0, in this case by comparator No. 1, that is I ask in it the essence of the fill factor (duty). <br><br>  For example, you can translate PWM not at the beginning of the period, but by comparator # 1, but return to log.0 by comparator # 2 and thus move the phase by hardware. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK;</span></span></code> </pre><br>  At this stage, we include the dead-time and set it up, in principle there are all the formulas in the comments, they can also be found in the reference manual.  DT with a duration of ~ 100 ns you have already seen on the oscillogram in the theoretical chapter of this article.  Dead time can be set separately on the front and on the decline of the signal.  By the way, [0] is Timer A, respectively [1] is Timer B and so on. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2;</span></span></code> </pre><br>  For me it was not the most obvious point.  Essentially, I want to make it so that at 10% of the duration of the Timer A period, an event is generated that would trigger the ADC conversion and measure the feedback signal.  Why 10%?  Just ideally, the measurement should not occur at the time of the transition of PIM from 0 to 1 or vice versa, because  at this moment transients and disturbances occur in the power section, and we do not need to measure them.  Therefore, in my case, 10% is optimal, since  at 12V output and 30V input voltage of the duty cycle (duty) does not fall to 10% and the switching time of the transistor does not exactly coincide with the measurement of the ADC. <br><br>  Now we need to look at the event communication system between HRTIM and the ADC: <br><br><img src="https://habrastorage.org/webt/r7/p6/g2/r7p6g2w3zcs-vrrsvzeev7uhwbc.png"><br><br>  In the first line, we choose exactly when the comparator will work, in my case it is 10% of the period of timer A. Next, we select a specific trigger in the ADC that MK will contact, 1 or 3 is available.  Now it simply indicates which event will send a signal to the ADC, in my case it is comparator # 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN;</span></span></code> </pre><br>  And the final chord!  We allow HRTIM to output signals from Timer A to our GPIO.  Now we select the mode, it can be infinite (I have it), and it happens that the timer is turned on for 1 period and after that it must be started again.  Next, set the period for the Master timer and turn it on with the last step, it starts clocking the channel timers and the PWM signal appears at the output. <br><br>  It was a setup function, it remains to make a function that will set the fill factor (duty), it is with it that we will work when creating the regulator: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDutyTimerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duty)</span></span></span><span class="hljs-function"> </span></span>{ HRTIM1-&gt;sTimerxRegs[<span class="hljs-number"><span class="hljs-number">0</span></span>].CMP1xR = duty; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Listing the function settings and set the fill factor</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// f = 102,4 kHz #define PeriodTimerA ((uint16_t)45000) void InitHRPWM (void) { RCC-&gt;CFGR3 |= RCC_CFGR3_HRTIM1SW_PLL; RCC-&gt;APB2ENR |= RCC_APB2ENR_HRTIM1EN; /************************************************ * Setting GPIO ***********************************************/ RCC-&gt;AHBENR |= RCC_AHBENR_GPIOAEN; // Alternative PP GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER8; GPIOA-&gt;MODER |= GPIO_MODER_MODER8_1; // Very high speed GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR8; GPIOA-&gt;MODER &amp;= ~GPIO_MODER_MODER9; GPIOA-&gt;MODER |= GPIO_MODER_MODER9_1; GPIOA-&gt;OSPEEDR |= GPIO_OSPEEDER_OSPEEDR9; // PA8 and PA9 - AF13 GPIOA-&gt;AFR[1] |= 0xDD; /************************************************ * Setting timer A ***********************************************/ HRTIM1-&gt;sCommonRegs.DLLCR |= HRTIM_DLLCR_CAL | HRTIM_DLLCR_CALEN; while ((HRTIM1-&gt;sCommonRegs.ISR &amp; HRTIM_ISR_DLLRDY) == RESET); // Period for timer A HRTIM1-&gt;sTimerxRegs[0].PERxR = PeriodTimerA; // Duty for timer A HRTIM1-&gt;sTimerxRegs[0].CMP1xR = 0; // Deadtime enable HRTIM1-&gt;sTimerxRegs[0].OUTxR |= HRTIM_OUTR_DTEN; // Tdtg = 6.94 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTPRSC_0 | HRTIM_DTR_DTPRSC_1; // Deadtime rising = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTR_0 | HRTIM_DTR_DTR_1 | HRTIM_DTR_DTR_2 | HRTIM_DTR_DTR_3; // Deadtime falling = 15*Ttg = 104 ns HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTF_0 | HRTIM_DTR_DTF_1 | HRTIM_DTR_DTF_2 | HRTIM_DTR_DTF_3; HRTIM1-&gt;sTimerxRegs[0].DTxR |= HRTIM_DTR_DTFSLK | HRTIM_DTR_DTRSLK; // Event forces the output to active state for TA1 HRTIM1-&gt;sTimerxRegs[0].SETx1R |= HRTIM_SET1R_PER; // Event forces the output to inactive state for TA1 HRTIM1-&gt;sTimerxRegs[0].RSTx1R |= HRTIM_RST1R_CMP1; /************************************************ * ADC trigger intialization (with CMP2 event) ************************************************/ // Samples in middle of ON time HRTIM1-&gt;sTimerxRegs[0].CMP2xR = PeriodTimerA / 10; // ADC trigger 1 update: Timer A HRTIM1-&gt;sCommonRegs.CR1 |= HRTIM_CR1_ADC1USRC_0; // ADC trigger 1 event: Timer A compare 2 HRTIM1-&gt;sCommonRegs.ADC1R |= HRTIM_ADC1R_AD1TAC2; /************************************************ * HRTIM start ***********************************************/ // Enable output PWM for TA1 and TA2 HRTIM1-&gt;sCommonRegs.OENR |= HRTIM_OENR_TA1OEN | HRTIM_OENR_TA2OEN; // Continuous mode HRTIM1-&gt;sTimerxRegs[0].TIMxCR |= HRTIM_TIMCR_CONT; // Period for master timer HRTIM1-&gt;sMasterRegs.MPER = 65000; // Enable counter for Master and timer A HRTIM1-&gt;sMasterRegs.MCR |= HRTIM_MCR_MCEN | HRTIM_MCR_TACEN; } void SetDutyTimerA (uint16_t duty) { HRTIM1-&gt;sTimerxRegs[0].CMP1xR = duty; }</span></span></code> </pre><br></div></div><br>  Now let's find out if we are going the right way.  In the <i>main</i> function, we initialize the HRTIM setting and set the duty cycle, say 22500. With an input voltage of 20V and a period of 45000, our fill factor will be 50% and the output will be about 10V.  This is not enough to blow up the LED to the full, but it should catch fire and we will understand if the power part is working, is everything good with dt and so on.  I started everything from the first time: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HTLbf9aMAGs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  You can see that all previous theoretical calculations have been confirmed.  With a fixed duty cycle (duty) of 50%, the output voltage was simply divided into 2: 20V -&gt; 10V, 22V -&gt; 11V, 18V -&gt; 9V.  Now let's make it so that the voltage at the output is stable and does not depend on the input, that is, we add feedback. <br><br>  <b>Setting ADC and regulator</b> <br><br>  About ADC in STM32 a lot has already been written to me, I elaborated on only setting up a trigger tied to the HRTIM comparator.  I will briefly tell you about the rest of the ADC settings.  We look at the initialization function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitBasicADC</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC-&gt;AHBENR |= RCC_AHBENR_ADC12EN; RCC-&gt;AHBENR |= RCC_AHBENR_GPIOCEN; <span class="hljs-comment"><span class="hljs-comment">/************************************************ * Calibration ***********************************************/</span></span> ADC2-&gt;CR &amp;= ~ADC_CR_ADVREGEN; ADC2-&gt;CR |= ADC_CR_ADVREGEN_0; <span class="hljs-comment"><span class="hljs-comment">// Vref enable Delay(10); ADC2-&gt;CR &amp;= ~ADC_CR_ADCALDIF; ADC2-&gt;CR |= ADC_CR_ADCAL; // Start calibration while (ADC2-&gt;CR &amp; ADC_CR_ADCAL); // Wait end calibration /************************************************ * Select event trigger and channel ***********************************************/ // Enable start conversion external trigger ADC2-&gt;CFGR |= ADC_CFGR_EXTEN_0; // Event 7 - HRTIM ADC2-&gt;CFGR |= ADC_CFGR_EXTSEL_0 | ADC_CFGR_EXTSEL_1 | ADC_CFGR_EXTSEL_2; // Select ADC2 channel IN5 ADC2-&gt;SQR1 |= ADC_SQR1_SQ1_0 | ADC_SQR1_SQ1_2; // Length regular ADC channel = 1 ADC2-&gt;SQR1 &amp;= ~ADC_SQR1_L; ADC2-&gt;IER |= ADC_IER_EOCIE; // Interrupt enable NVIC_EnableIRQ(ADC1_2_IRQn); // enable interrupt ADC1 and ADC2 /************************************************ * Start ADC ***********************************************/ ADC2-&gt;CR |= ADC_CR_ADEN; // Enable ADC2 Delay(10); ADC2-&gt;CR |= ADC_CR_ADSTART; }</span></span></code> </pre><br>  I use the regular channel mode, I have only one channel and it is selected in the <i>SQR1</i> register.  Enabled the ADC number 2, namely, its input IN5, it is fast and can operate at the maximum sampling frequency, but not this time.  The sampling rate is equal to the PWM frequency, since  1 period = 1 sample, in principle, this is more than enough. <br><br>  We <i>also</i> need to select an event in the <i>CFGR</i> register that will trigger the conversion, that is, <i>Event 7</i> , why exactly?  Look in RM: <br><br><img src="https://habrastorage.org/webt/mr/f0/wn/mrf0wnno0sft4episcxokfnsduy.png"><br><br>  Trigger 1 from the HRPWM module comes to Event 7 for our ADC No. 2, which in this case works as a slave, it is controlled from the HRPWM module.  I think now it is clear how to connect 2 modules, in principle, the algorithm is similar for any periphery and any timer, except the register name will be different. <br><br>  Upon reaching the period counter, the master timer will start the conversion, which after about 15 cycles (how many exactly look at RM-e) will cause an interrupt and you can pick up the result.  It is in this interruption that we organize the control algorithm.  Yes, it‚Äôs better not to do something massively inside the interrupt, it‚Äôs better to set the flag and transfer the execution further, but I allow myself this simplification, because in this case my controller is not particularly loaded and it will be able to calculate and exit the interrupt with 146% probability the appearance of a new one. <br><br>  <b>Little about management</b> <br><br>  Imagine that you entered the bathroom and decided to wash your hands in the sink.  You slightly open the water, touch with your hand, cold?  Add more hot water, warmer?  Good!  Add more hot water?  Almost what you want?  Good!  Add more hot water, try with your hand, burn it?  Come on now, let‚Äôs cool down a little.  Good?  And so indefinitely you will turn the tap until the water temperature is perfect.  This is the easiest regulator! <br><br>  Only in our country it is not the amount of hot water that is regulated, but the fill factor of PIM.  Instead of a hand, we have an ADC with measured result.  It remains only to implement the logic.  We will calculate that we must issue an ADC at 12V at the output, and then using the <i>if</i> condition, we force our controller to support this value by changing the fill factor (duty). <br><br>  To begin with, let's hang up a voltage divider on the output in order to reduce 12V to 2-2.5V, for example, since  The ADC can measure from 0 to + 3.3V, and if you apply 12V, the microcontroller will burn simply.  Therefore, I will put a divider with nominal values ‚Äã‚Äãof 10 kŒ© and 2 kŒ©, which will give a division factor of 6 and, accordingly, our + 12V will turn into + 2V.  Our ADC will produce the result: adcResult = (V <sub>out</sub> / k) / V <sub>ref</sub> * 2 <sup>12</sup> = (12V / 6) / 3.3 * 4095 = 2481. Now we write the code for the interrupt handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ADC1_2_IRQHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ ADC2-&gt;ISR |= ADC_ISR_EOC; adcResult = ADC2-&gt;DR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adcResult &gt; <span class="hljs-number"><span class="hljs-number">2480</span></span>) { dutyControl = dutyControl - <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { dutyControl = dutyControl + <span class="hljs-number"><span class="hljs-number">10</span></span>; } SetDutyTimerA(dutyControl); }</code> </pre><br>  The first thing after getting into the interrupt handler is to reset the flag of the interrupt itself, otherwise the second time you will not get into it.  Then we read the result and save it as <i>adcResult</i> variable.  Now, knowing the voltage at the output, you need to make an adjustment to the value of the fill factor for PWM, I realized this simply through the <i>if</i> condition.  In each PWM period, we measure, increase or decrease the fill factor and set the result for the next period.  Everything is simple, fast and visible essence.  We look at the result of the work: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JxpeGDzYd3A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  As you can see, everything works and when the input voltage changes, the output itself remains stable at 12V.  Strongly attentive can notice small needles skipping, then you just need to hang up the X7R ceramics at the output of 1-10 microfarads and they will leave, I'm just too lazy to look for it and solder it.  Now the oscillogram itself, so as not to spoil the eyes: <br><br><img src="https://habrastorage.org/webt/ff/xf/be/ffxfbeq791q3wqwwfmohhheyg10.png"><br><br>  Here you can see how the output voltage rises.  The fact is that due to the control algorithm, the filling must reach values ‚Äã‚Äãfrom 0 to 10,000, for example, a thousand periods are needed, or approximately 10 ms.  It suits me because soft-start, if you want to shorten the rise time, then just complicate the algorithm and add +1000, not +10, and the closer you get to the specified 12V, the less regulation step you take until you reach +10 .  In general, in terms of management, you can do a lot of things, so you have a field for experiments. <br><br>  Another interesting point is the oscillations at the moment of shutdown, such an "accordion".  The fact is that after turning off the power, my digital part continues to work from another power supply unit and it tries to keep the desired value at the output.  Where does energy come from?  Yes, from the input capacitor, these are those that are 1000 microfarads each, as many as 3 pieces, this is such an interesting phenomenon. <br><br><h2>  Conclusion </h2><br>  The article came out is not small, but you wanted everything and immediately say, let's get a finished piece of metal - you will get it.  I hope you enjoy the article, tried to make it more likely not scientific, but popular science, so that the material was available to people with different levels of knowledge and experience.  Perhaps in the future I will analyze similarly other topologies like boost, full bridge and others. <br><br>  By the way, this article and code will serve for the new MPPT controller at 20A, which I am designing.  Now I <a href="https://www.pcbway.com/">am</a> waiting for <a href="https://www.pcbway.com/">PCBway boards</a> , which, in <a href="https://www.pcbway.com/">fact</a> , volunteered to sponsor my open source projects with printed circuit boards, the source code for MPPT will also be open to all my modules. <br><br>  Most importantly forgot!  Keep the project with the code for TrueSTDIO - <a href="https://drive.google.com/open%3Fid%3D12C1LgKgKoFC3VIhR-tPKWKNzQehn_mDg">RAR</a> . </div><p>Source: <a href="https://habr.com/ru/post/432778/">https://habr.com/ru/post/432778/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432768/index.html">Wireless headphones for "serial marathons": in Dolby they will be offered for $ 599</a></li>
<li><a href="../432770/index.html">Botnets and their types: what is known in 2018</a></li>
<li><a href="../432772/index.html">How did we do the service of advertising campaigns that comply with the provisions of GDPR</a></li>
<li><a href="../432774/index.html">Frontend DevDay. Record of reports</a></li>
<li><a href="../432776/index.html">The book "React in action"</a></li>
<li><a href="../432780/index.html">Why do we need empathy in the world of technology</a></li>
<li><a href="../432782/index.html">Multi-server installation Zimbra Collaboration Suite</a></li>
<li><a href="../432784/index.html">Bot playing in Castlevania</a></li>
<li><a href="../432786/index.html">.NET - localization without pain. (N) gettext + poedit</a></li>
<li><a href="../432788/index.html">Prototypes: how to create a successful product and save</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>