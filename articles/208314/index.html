<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write virtual clipboard on C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot of work has to be done with textual data, such as code, articles, posts, etc. At the time when I lived under Linux, I used clipboard history man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write virtual clipboard on C #</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/bd7/39a/86d/bd739a86d9609189cae02350c4adc974.png" alt="VirtualClipBoard" align="left">  A lot of work has to be done with textual data, such as code, articles, posts, etc.  At the time when I lived under Linux, I used <u>clipboard history managers</u> , who remembered, what got into text into the buffer and by clicking on the tray I could return the desired value to the buffer without returning to the source. <br>  Recently I had to spend most of my time on Windows, I did not find a satisfying alternative for such a simple application.  Something in the found variants did not suit: not free software, a lot of unnecessary functionality (which just interfered) or worked inconveniently for me (for example: I had to open the program window to get the previous buffer value).  Without thinking twice decided to do, as I wanted. <br><br>  Since the application should work exclusively in Windows, it was decided to write it in C # - besides, I had never written anything on it before - there was reason to try. <br><br><h4>  Task </h4><br><ul><li>  The program should listen and remember changes in the text clipboard. </li><li>  Through the context menu in the tray or through the program window by clicking on the selected history item, the desired value should automatically go back to the buffer. </li><li>  History should not be lost after rebooting the system. </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Interface </h4><br><ul><li>  Ability to put the application on startup in the registry. </li><li>  Change the amount of stored history. </li><li>  Change the number of the last elements of the buffer displayed via the context menu in the tray. </li><li>  Forced clear history. </li><li>  Exit the program, because when you close the program should be minimized to tray. </li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c5b/c5a/3e9/c5bc5a3e99c89b52160da4faad2d92b7.png" alt="VirtualClipBoard"><br><br><blockquote>  I will post the main parts of the code with some explanations.  At the end, under the spoiler, a full listing of the program is posted, as well as a link to the complete project zipped archive + separately link to the compiled version of the program as an exe file. </blockquote><br><br><h4>  Directly the code itself </h4><br><br>  I didn‚Äôt want to reinvent the bike for storing program settings, so I used <u>Properties.SettingDefault for</u> ‚Äúhistory size‚Äù and ‚Äúnumber of displayed items in the tray‚Äù: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    private void history_size_ValueChanged(object sender, EventArgs e) { Properties.Settings.Default.history_size = (int)history_size.Value; Properties.Settings.Default.Save(); Console.WriteLine("  : " + Properties.Settings.Default.history_size); reload_list_clipboard(); //  ListBox } //       private void size_tray_ValueChanged(object sender, EventArgs e) { Properties.Settings.Default.size_tray = (int)size_tray.Value; Properties.Settings.Default.Save(); Console.WriteLine("    : " + Properties.Settings.Default.size_tray); reload_tray(); //   }</span></span></code> </pre> <br><br>  Startup, the program, as previously agreed, is implemented through the registry. <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//      //   -      private void autoload_CheckedChanged(object sender, EventArgs e) { RegistryKey reg = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run\", true); if (reg.GetValue(VirtualClipBoard_Name) != null) { try { reg.DeleteValue(VirtualClipBoard_Name); Console.WriteLine(" " + VirtualClipBoard_Name + "     "); } catch { Console.WriteLine("  " + VirtualClipBoard_Name + "    "); } } if(autoload.Checked) { reg.SetValue(VirtualClipBoard_Name, Application.ExecutablePath); Console.WriteLine(" " + VirtualClipBoard_Name + "     "); } reg.Close(); }</span></span></code> </pre><br><br>  When you close the window, the program should be minimized to tray, and not shut down <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//       protected override void OnClosing(CancelEventArgs e) { e.Cancel = true; // ShowInTaskbar = false; Hide(); }</span></span></code> </pre><br><br>  Method to close the program <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//        private void exit_Click(object sender, EventArgs e) { Application.Exit(); }</span></span></code> </pre><br><br>  Since, checking on the timer changes in the clipboard is a perversion + an unjustified waste of resources, we will use <b>User32.dll</b> .  To do this, we need to add our window to the clipboard window chain and use WndProc to receive messages, more specifically <i>WM_DRAWCLIPBOARD = 0x0308</i> , which will notify us of the change in the exchange buffer. <br><br>  So, 1. We connect libraries: <br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">DllImport(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"User32.dll"</span></span></span><span class="hljs-meta">)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetClipboardViewer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hWndNewViewer</span></span></span><span class="hljs-function">)</span></span>; [DllImport(<span class="hljs-string"><span class="hljs-string">"User32.dll"</span></span>, CharSet = CharSet.Auto)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ChangeClipboardChain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr hWndRemove, IntPtr hWndNewNext</span></span></span><span class="hljs-function">)</span></span>; [DllImport(<span class="hljs-string"><span class="hljs-string">"user32.dll"</span></span>, CharSet = CharSet.Auto)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IntPtr hwnd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> wMsg, IntPtr wParam, IntPtr lParam</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><br>  2. Implementation of the WndProc method of receiving messages and sending them further along the chain: <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//   private IntPtr nextClipboardViewer; //  public const int WM_DRAWCLIPBOARD = 0x0308; public const int WM_CHANGECBCHAIN = 0x030D; //         .. protected override void WndProc(ref Message m) { switch (m.Msg) { case WM_DRAWCLIPBOARD: { ClipboardChanged(); SendMessage(nextClipboardViewer, m.Msg, m.WParam, m.LParam); break; } case WM_CHANGECBCHAIN: { if (m.WParam == nextClipboardViewer) { nextClipboardViewer = m.LParam; } else { SendMessage(nextClipboardViewer, WM_CHANGECBCHAIN, m.WParam, m.LParam); } m.Result = IntPtr.Zero; break; } default: { base.WndProc(ref m); break; } } }</span></span></code> </pre><br><br>  3. In the form upload method, register our window: <br><pre> <code class="cs hljs">nextClipboardViewer = (IntPtr)SetClipboardViewer((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Handle);</code> </pre><br><br>  4. Now we need to react to the change in the buffer and write them into history, for this we will create the <b>ClipboardChanged</b> method.  History will be written to the Dictionary dictionary <i>&lt;int, string&gt; VirtualClipBoard_History = new Dictionary &lt;int, string&gt; ();</i>  if the number of elements in the dictionary is larger than the size of the history, in the method we also introduce a clearing of older elements.  Also, to be able to get the history of the previous session, we will write new elements to the file <i>VirtualClipBoard_DAT</i> . <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//     private void ClipboardChanged() { if (Clipboard.ContainsText() &amp;&amp; Clipboard.GetText().Length &gt; 0 &amp;&amp; VirtualClipBoard_TARGET != Clipboard.GetText()) { VirtualClipBoard_TARGET = Clipboard.GetText(); //      VirtualClipBoard_History.Add((VirtualClipBoard_History.Last().Key + 1), VirtualClipBoard_TARGET); reload_tray(); //    reload_list_clipboard(); //  ListBox //      if (VirtualClipBoard_History.Count() &gt; Properties.Settings.Default.history_size) { int clear_items_count = VirtualClipBoard_History.Count() - Properties.Settings.Default.history_size; var list = VirtualClipBoard_History.Keys.ToList(); list.Sort(); foreach (var key in list) { VirtualClipBoard_History.Remove(key); if (clear_items_count == 1) { break; } else { clear_items_count--; } } } //       StreamWriter writer = new StreamWriter(VirtualClipBoard_DAT, true, System.Text.Encoding.UTF8); writer.WriteLine(@"&lt;item&gt;" + VirtualClipBoard_TARGET.Replace(@"&lt;", @"&lt;").Replace(@"&gt;", @"&gt;") + @"&lt;/item&gt;"); writer.Close(); Console.WriteLine("    : " + VirtualClipBoard_TARGET); } }</span></span></code> </pre><br><br>  To output elements to the tray, create the <i>reload_tray</i> method.  We will use <i>ContextMenuStrip</i> .  For each <i>ToolStripMenuItem</i> we will use the <i>TAG</i> , in which we will transfer the key in the dictionary, so that when selecting an item in the context menu, it is easy to pull the necessary item from the dictionary. <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//     private void reload_tray() { ContextMenuStrip contextMenu = new ContextMenuStrip(); ToolStripMenuItem menuItem; int free_slot_to_tray = Properties.Settings.Default.size_tray; var list = VirtualClipBoard_History.OrderByDescending(x =&gt; x.Key); foreach (var item in list) { menuItem = new ToolStripMenuItem(); menuItem.Tag = item.Key; if (item.Value.Length &gt; 60) { menuItem.Text = item.Value.Replace("\n", "\t").Replace("\r", "\t").Substring(0, 60); } else { menuItem.Text = item.Value.Replace("\n", "\t").Replace("\r", "\t"); } menuItem.Click += new System.EventHandler(menu_item_click); contextMenu.Items.Add(menuItem); if (free_slot_to_tray == 1) { break; } else { free_slot_to_tray--; } } //  contextMenu.Items.Add(new ToolStripSeparator()); // / menuItem = new ToolStripMenuItem(); menuItem.Text = ""; menuItem.Click += new System.EventHandler(menu_item_config); contextMenu.Items.Add(menuItem); //    menuItem = new ToolStripMenuItem(); menuItem.Text = ""; menuItem.Click += new System.EventHandler(exit_Click); contextMenu.Items.Add(menuItem); _notifyIcon.ContextMenuStrip = contextMenu; }</span></span></code> </pre><br><br>  Click handling events in the tray context menu: <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//          private void menu_item_click(object sender, EventArgs e) { Clipboard.SetText(VirtualClipBoard_History[(int)(sender as ToolStripMenuItem).Tag]); }</span></span></code> </pre><br><br>  List generation for ListBox in the form of the program itself.  For convenience, we will use the additional dictionary <i>VirtualClipBoard_Index_ListBox = new Dictionary &lt;int, int&gt; ();</i>  to associate a <i>ListBox</i> with a element in the <i>VirtualClipBoard_History</i> history dictionary: <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//    ListBox private void reload_list_clipboard() { VirtualClipBoard_Index_ListBox = new Dictionary&lt;int, int&gt;(); int list_target_item = 0; //     ListBox list_clipboard.Items.Clear(); //   String string_name_ite; int free_slot_to_tray = Properties.Settings.Default.history_size; var list = VirtualClipBoard_History.OrderByDescending(x =&gt; x.Key); foreach (var item in list) { if (item.Value.Length &gt; 150) { string_name_ite = item.Value.Replace("\n", "\t").Replace("\r", "\t").Substring(0, 60); } else { string_name_ite = item.Value.Replace("\n", "\t").Replace("\r", "\t"); } list_clipboard.Items.Add(string_name_ite); VirtualClipBoard_Index_ListBox.Add(list_target_item, item.Key); if (free_slot_to_tray == 1) { break; } else { free_slot_to_tray--; } list_target_item++; //      ListBox } }</span></span></code> </pre><br><br>  When selecting an item in <i>ListBox</i> , the <i>list_clipboard_SelectedIndexChanged</i> event: <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//    ListBox private void list_clipboard_SelectedIndexChanged(object sender, EventArgs e) { Clipboard.SetText(VirtualClipBoard_History[VirtualClipBoard_Index_ListBox[list_clipboard.SelectedIndex]]); }</span></span></code> </pre><br><br>  While the program is loading, we read the history from the <i>VirtualClipBoard_DAT</i> file and parse the data as XML. <br>  Clipboard history elements cannot be stored separately in each line in our case, because the elements may have carriage-transfer characters (\ n) that may damage our data integrity when reading. <br>  If you use serialize, you can lose on the program speed with each change of the buffer. <br>  Of course, it would be more correct to save the history to a file when the program was closed, but I didn‚Äôt like this option in this case, so I organized it in this way (I can hook someone on this - I apologize right away). <br>  I also did not want to encode the data, I wanted to leave the original view of the data so that if necessary I could read the history file through notepad. <br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//     String XMLString = ""; XMLString += @"&lt;items&gt;"; if (File.Exists(VirtualClipBoard_DAT)) { StreamReader stream = new StreamReader(VirtualClipBoard_DAT); while (stream.Peek() &gt; -1) { XMLString += stream.ReadLine() + "\n"; } stream.Close(); XMLString += @"&lt;/items&gt;"; int index_new_history = 2; XDocument doc = XDocument.Parse(XMLString); var items = doc.Element("items").Elements("item"); foreach (XElement item in items) { VirtualClipBoard_History.Add(index_new_history, item.Value); index_new_history++; //     } }</span></span></code> </pre><br><br><h4>  All project code </h4><br><div class="spoiler">  <b class="spoiler_title">All project code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Win32; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.InteropServices; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data.Sql; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Xml.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">VirtualClipBoard</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">VirtualClipBoard</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { String VirtualClipBoard_Name = <span class="hljs-string"><span class="hljs-string">"VirtualClipBoard"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   public String VirtualClipBoard_TARGET; //     public String VirtualClipBoard_DAT; //     Dictionary&lt;int, string&gt; VirtualClipBoard_History = new Dictionary&lt;int, string&gt;(); //    Dictionary&lt;int, int&gt; VirtualClipBoard_Index_ListBox; //         //   WIN [DllImport("User32.dll", CharSet = CharSet.Auto)] public static extern IntPtr SetClipboardViewer(IntPtr hWndNewViewer); [DllImport("User32.dll", CharSet = CharSet.Auto)] public static extern bool ChangeClipboardChain(IntPtr hWndRemove, IntPtr hWndNewNext); [DllImport("user32.dll", CharSet = CharSet.Auto)] public static extern int SendMessage(IntPtr hwnd, int wMsg, IntPtr wParam, IntPtr lParam); //  Form public VirtualClipBoard() { InitializeComponent(); load_configs(); nextClipboardViewer = (IntPtr)SetClipboardViewer((IntPtr)this.Handle); reload_tray(); //    reload_list_clipboard(); //  ListBox _notifyIcon.Text = VirtualClipBoard_Name; _notifyIcon.MouseDoubleClick += new MouseEventHandler(_notifyIcon_MouseDoubleClick); } //    ListBox private void reload_list_clipboard() { VirtualClipBoard_Index_ListBox = new Dictionary&lt;int, int&gt;(); int list_target_item = 0; //     ListBox list_clipboard.Items.Clear(); //   String string_name_ite; int free_slot_to_tray = Properties.Settings.Default.history_size; var list = VirtualClipBoard_History.OrderByDescending(x =&gt; x.Key); foreach (var item in list) { if (item.Value.Length &gt; 150) { string_name_ite = item.Value.Replace("\n", "\t").Replace("\r", "\t").Substring(0, 60); } else { string_name_ite = item.Value.Replace("\n", "\t").Replace("\r", "\t"); } list_clipboard.Items.Add(string_name_ite); VirtualClipBoard_Index_ListBox.Add(list_target_item, item.Key); if (free_slot_to_tray == 1) { break; } else { free_slot_to_tray--; } list_target_item++; //      ListBox } } //    ListBox private void list_clipboard_SelectedIndexChanged(object sender, EventArgs e) { Clipboard.SetText(VirtualClipBoard_History[VirtualClipBoard_Index_ListBox[list_clipboard.SelectedIndex]]); } //     private void reload_tray() { ContextMenuStrip contextMenu = new ContextMenuStrip(); ToolStripMenuItem menuItem; int free_slot_to_tray = Properties.Settings.Default.size_tray; var list = VirtualClipBoard_History.OrderByDescending(x =&gt; x.Key); foreach (var item in list) { menuItem = new ToolStripMenuItem(); menuItem.Tag = item.Key; if (item.Value.Length &gt; 60) { menuItem.Text = item.Value.Replace("\n", "\t").Replace("\r", "\t").Substring(0, 60); } else { menuItem.Text = item.Value.Replace("\n", "\t").Replace("\r", "\t"); } menuItem.Click += new System.EventHandler(menu_item_click); contextMenu.Items.Add(menuItem); if (free_slot_to_tray == 1) { break; } else { free_slot_to_tray--; } } //  contextMenu.Items.Add(new ToolStripSeparator()); // / menuItem = new ToolStripMenuItem(); menuItem.Text = ""; menuItem.Click += new System.EventHandler(menu_item_config); contextMenu.Items.Add(menuItem); //    menuItem = new ToolStripMenuItem(); menuItem.Text = ""; menuItem.Click += new System.EventHandler(exit_Click); contextMenu.Items.Add(menuItem); _notifyIcon.ContextMenuStrip = contextMenu; } //    private void menu_item_config(object sender, EventArgs e) { // ShowInTaskbar = true; Show(); WindowState = FormWindowState.Normal; } //          private void menu_item_click(object sender, EventArgs e) { // Console.WriteLine((int)(sender as ToolStripMenuItem).Tag); Clipboard.SetText(VirtualClipBoard_History[(int)(sender as ToolStripMenuItem).Tag]); } //         private void _notifyIcon_MouseDoubleClick(object sender, MouseEventArgs e) { Console.WriteLine(WindowState); if (WindowState == FormWindowState.Normal || WindowState == FormWindowState.Maximized) { // ShowInTaskbar = false; Hide(); WindowState = FormWindowState.Minimized; } else { // ShowInTaskbar = true; Show(); WindowState = FormWindowState.Normal; } } //        private void load_configs() { VirtualClipBoard_DAT = Application.UserAppDataPath + "\\history.dat"; Console.WriteLine(" : " + VirtualClipBoard_DAT); history_size.Value = Properties.Settings.Default.history_size; Console.WriteLine("    : " + Properties.Settings.Default.history_size); size_tray.Value = Properties.Settings.Default.size_tray; Console.WriteLine("      : " + Properties.Settings.Default.size_tray); RegistryKey reg = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run\", true); if (reg.GetValue(VirtualClipBoard_Name) != null){ autoload.Checked = true; Console.WriteLine("   . (   Checked = true)"); } reg.Close(); //     String XMLString = ""; XMLString += @"&lt;items&gt;"; if (File.Exists(VirtualClipBoard_DAT)) { StreamReader stream = new StreamReader(VirtualClipBoard_DAT); while (stream.Peek() &gt; -1) { XMLString += stream.ReadLine() + "\n"; } stream.Close(); XMLString += @"&lt;/items&gt;"; int index_new_history = 2; XDocument doc = XDocument.Parse(XMLString); var items = doc.Element("items").Elements("item"); foreach (XElement item in items) { VirtualClipBoard_History.Add(index_new_history, item.Value); index_new_history++; //     } } //    if (VirtualClipBoard_History.Count() &gt; Properties.Settings.Default.history_size) { int clear_items_count = VirtualClipBoard_History.Count() - Properties.Settings.Default.history_size; var list = VirtualClipBoard_History.Keys.ToList(); list.Sort(); foreach (var key in list) { VirtualClipBoard_History.Remove(key); if (clear_items_count == 1) { break; } else { clear_items_count--; } } } //    StreamWriter writer = new StreamWriter(VirtualClipBoard_DAT, false, System.Text.Encoding.UTF8); var new_list = VirtualClipBoard_History.Keys.ToList(); new_list.Sort(); foreach (var key in new_list) { writer.WriteLine(@"&lt;item&gt;" + VirtualClipBoard_History[key].Replace(@"&lt;", @"&lt;").Replace(@"&gt;", @"&gt;") + @"&lt;/item&gt;"); } writer.Close(); //   ,    Console.WriteLine(VirtualClipBoard_History.Count()); if (VirtualClipBoard_History.Count() == 0) { VirtualClipBoard_TARGET = Clipboard.GetText(); VirtualClipBoard_History.Add(1, VirtualClipBoard_TARGET); } VirtualClipBoard_TARGET = VirtualClipBoard_History.Last().Value; } //      //   -      private void autoload_CheckedChanged(object sender, EventArgs e) { RegistryKey reg = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run\", true); if (reg.GetValue(VirtualClipBoard_Name) != null) { try { reg.DeleteValue(VirtualClipBoard_Name); Console.WriteLine(" " + VirtualClipBoard_Name + "     "); } catch { Console.WriteLine("  " + VirtualClipBoard_Name + "    "); } } if(autoload.Checked) { reg.SetValue(VirtualClipBoard_Name, Application.ExecutablePath); Console.WriteLine(" " + VirtualClipBoard_Name + "     "); } reg.Close(); } //        private void exit_Click(object sender, EventArgs e) { Application.Exit(); } //    private void history_size_ValueChanged(object sender, EventArgs e) { Properties.Settings.Default.history_size = (int)history_size.Value; Properties.Settings.Default.Save(); Console.WriteLine("  : " + Properties.Settings.Default.history_size); reload_list_clipboard(); //  ListBox } //       private void size_tray_ValueChanged(object sender, EventArgs e) { Properties.Settings.Default.size_tray = (int)size_tray.Value; Properties.Settings.Default.Save(); Console.WriteLine("    : " + Properties.Settings.Default.size_tray); reload_tray(); //   } //     private void ClipboardChanged() { if (Clipboard.ContainsText() &amp;&amp; Clipboard.GetText().Length &gt; 0 &amp;&amp; VirtualClipBoard_TARGET != Clipboard.GetText()) { VirtualClipBoard_TARGET = Clipboard.GetText(); //      VirtualClipBoard_History.Add((VirtualClipBoard_History.Last().Key + 1), VirtualClipBoard_TARGET); reload_tray(); //    reload_list_clipboard(); //  ListBox //      if (VirtualClipBoard_History.Count() &gt; Properties.Settings.Default.history_size) { int clear_items_count = VirtualClipBoard_History.Count() - Properties.Settings.Default.history_size; var list = VirtualClipBoard_History.Keys.ToList(); list.Sort(); foreach (var key in list) { VirtualClipBoard_History.Remove(key); if (clear_items_count == 1) { break; } else { clear_items_count--; } } } //       StreamWriter writer = new StreamWriter(VirtualClipBoard_DAT, true, System.Text.Encoding.UTF8); writer.WriteLine(@"&lt;item&gt;" + VirtualClipBoard_TARGET.Replace(@"&lt;", @"&lt;").Replace(@"&gt;", @"&gt;") + @"&lt;/item&gt;"); writer.Close(); Console.WriteLine("    : " + VirtualClipBoard_TARGET); } } //    private void clear_Click(object sender, EventArgs e) { StreamWriter writer = new StreamWriter(VirtualClipBoard_DAT, false, System.Text.Encoding.Default); writer.Write(""); writer.Close(); VirtualClipBoard_History = new Dictionary&lt;int, string&gt;(); VirtualClipBoard_TARGET = Clipboard.GetText(); VirtualClipBoard_History.Add(1, VirtualClipBoard_TARGET); reload_tray(); //    reload_list_clipboard(); //  ListBox } //       protected override void OnClosing(CancelEventArgs e) { e.Cancel = true; //ShowInTaskbar = false; Hide(); WindowState = FormWindowState.Minimized; } //   private IntPtr nextClipboardViewer; //  public const int WM_DRAWCLIPBOARD = 0x308; public const int WM_CHANGECBCHAIN = 0x030D; //         .. protected override void WndProc(ref Message m) { // Console.WriteLine("WndProc"); switch (m.Msg) { case WM_DRAWCLIPBOARD: { ClipboardChanged(); Console.WriteLine("WM_DRAWCLIPBOARD ClipboardChanged();"); SendMessage(nextClipboardViewer, WM_DRAWCLIPBOARD, m.WParam, m.LParam); break; } case WM_CHANGECBCHAIN: { if (m.WParam == nextClipboardViewer) { nextClipboardViewer = m.LParam; } else { SendMessage(nextClipboardViewer, WM_CHANGECBCHAIN, m.WParam, m.LParam); } m.Result = IntPtr.Zero; break; } default: { base.WndProc(ref m); break; } } } } }</span></span></code> </pre></div></div><br><br><h4>  Bibliography: </h4><br>  <a href="http://msdn.microsoft.com/ru-ru/library/bb397755(v%3Dvs.110).aspx">Properties.Settings.Default - saving custom application settings</a> <br>  <a href="http://msdn.microsoft.com/ru-ru/library/microsoft.win32.registry.localmachine(v%3Dvs.110).aspx">Registry.LocalMachine - working with the registry</a> <br>  <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms649052(v%3Dvs.85).aspx">SetClipboardViewer - we add a defined window to the chain of clipboard view windows.</a> <br>  <a href="http://msdn.microsoft.com/ru-ru/library/system.io.streamwriter(v%3Dvs.110).aspx">class StreamWriter - write to file</a> <br>  <a href="http://msdn.microsoft.com/ru-ru/library/system.windows.forms.contextmenustrip(v%3Dvs.110).aspx">ContextMenuStrip class - context menu</a> <br>  <a href="http://msdn.microsoft.com/ru-ru/library/xfhwa508(v%3Dvs.110).aspx">class Dictionary - Represents a collection of keys and values.</a> <br>  <a href="http://msdn.microsoft.com/ru-ru/library/system.windows.forms.clipboard(v%3Dvs.110).aspx">Clipboard class - Provides methods for putting data into the system clipboard and retrieving data from the system clipboard.</a> <br><br><h4>  Links to the project: </h4><br>  <a href="">Download the source of the entire project for VS in zip (133KB)</a> <br>  <a href="">Download compiled EXE file (225KB)</a> <br><br>  <b>UPDATE 1:</b> Filled source on github: <a href="https://github.com/yanzlatov/ClipBoard">https://github.com/yanzlatov/ClipBoard</a> <br><br>  <b>UPDATE 2:</b> Corrected the code a bit, because I noticed the feature if you set <b>ShowInTaskbar = false</b> ( <i>Gets or sets a value indicating whether the form is displayed in the Windows taskbar.</i> ) Our window falls off the clipboard update listening chain and does not receive an update later . <br><br>  <b>UPDATE 3:</b> Replaced <u><i>Microsoft.Win32.Registry.LocalMachine</i></u> with <u><i>Microsoft.Win32.Registry.CurrentUser</i></u> .  (Thanks <a href="http://habrahabr.ru/post/208314/">xaizek</a> ). </div><p>Source: <a href="https://habr.com/ru/post/208314/">https://habr.com/ru/post/208314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208294/index.html">27-inch hybrid candybar and tablet from Lenovo</a></li>
<li><a href="../208296/index.html">Welding of optical fibers. Part 3: review of the wiring connection schemes, review of network construction schemes, a little about reflectometers and optical testers</a></li>
<li><a href="../208302/index.html">CES 2014: First look at the mini-flagship Sony Xperia Z1 Compact (+ video)</a></li>
<li><a href="../208306/index.html">Raspberry Pi and a cup of Java, please! (Part 1)</a></li>
<li><a href="../208308/index.html">About statistics, karma and rating</a></li>
<li><a href="../208318/index.html">Home CNC router as an alternative to 3D printer, part one - the choice of machine</a></li>
<li><a href="../208320/index.html">To work with a clear conscience</a></li>
<li><a href="../208322/index.html">Will SAFE replace convertible notes?</a></li>
<li><a href="../208326/index.html">MVVM: a new look</a></li>
<li><a href="../208328/index.html">Create a behavior for Yii2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>