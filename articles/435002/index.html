<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IDA Pro Upgrade. Debugger for Sega Mega Drive (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all, 


 In the previous article, we successfully modified the core of the emulator of games on the Sega Mega Drive / Genesis , adding to it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IDA Pro Upgrade. Debugger for Sega Mega Drive (part 2)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/uc/ln/ec/uclnecmakoun2veml3ooxfvaete.png"></p><br><p>  Hello to all, </p><br><p> In the <a href="https://habr.com/post/434992/">previous article,</a> we successfully modified the core of the emulator of games on the <code>Sega Mega Drive</code> / <code>Genesis</code> , adding to it the possibility of debugging.  Now it's time to write the plugin debugger for <code>IDA Pro</code> , version <code>7.0</code> .  Let's get started <a name="habracut"></a></p><br><h2 id="chast-vtoraya-plagin-otladchik">  Part Two: Plugin Debugger </h2><br><p>  To begin with, we will create a new empty <code>DLL</code> project: <code>File</code> -&gt; <code>New</code> -&gt; <code>Project</code> -&gt; <code>Windows Desktop Wizard</code> -&gt; <code>Dynamic link library (.dll)</code> , also by checking the <code>Empty Project</code> , and removing all others: </p><br><p><img src="https://habrastorage.org/webt/59/de/45/59de456d6d52f649312722.png"></p><br><p>  We will unpack the <code>IDA SDK</code> and write it in the <code>Visual Studio</code> macros (I will use the <code>2017 Community</code> ) so that in the future you can easily link to it.  At the same time, we will add a macro for the path to <code>IDA Pro</code> . </p><br><p>  Go to <code>View</code> -&gt; <code>Other Windows</code> -&gt; <code>Property Manager</code> : </p><br><p><img src="https://habrastorage.org/webt/59/de/41/59de412a0dc50466086740.png"></p><br><p>  Since  we are working with the <code>SDK 7.0</code> version <code>SDK 7.0</code> , the compilation will be done by the <code>x64</code> compiler.  Therefore, choose <code>Debug | x64</code>  <code>Debug | x64</code> -&gt; <code>Microsoft.Cpp.x64.user</code> -&gt; <code>Properties</code> : </p><br><p><img src="https://habrastorage.org/webt/59/de/42/59de423c59c08942765331.png"></p><br><p>  Click the <code>Add Macro</code> button in the <code>User Macros</code> section, and write the <code>IDA_SDK</code> macro <code>IDA_SDK</code> with the path you have unpacked the <code>SDK</code> : </p><br><p><img src="https://habrastorage.org/webt/59/de/43/59de43354eef5656763373.png"></p><br><p>  We do the same with <code>IDA_DIR</code> (the path to your <code>IDA Pro</code> ): </p><br><p><img src="https://habrastorage.org/webt/59/de/43/59de4393df765196799873.png"></p><br><p>  I note that <code>IDA</code> is set by default to <code>%Program Files%</code> , which requires administrative rights. </p><br><p>  Let's also remove the <code>Win32</code> configuration (in this article I will not affect the compilation on the <code>x86</code> system), leaving only the <code>x64</code> option. </p><br><p>  Now, take the debugger event queue class template: </p><br><div class="spoiler">  <b class="spoiler_title">Source code ida_debmod.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;deque&gt; #include &lt;ida.hpp&gt; #include &lt;idd.hpp&gt; //-------------------------------------------------------------------------- // Very simple class to store pending events enum queue_pos_t { IN_FRONT, IN_BACK }; struct eventlist_t : public std::deque&lt;debug_event_t&gt; { private: bool synced; public: // save a pending event void enqueue(const debug_event_t &amp;ev, queue_pos_t pos) { if (pos != IN_BACK) push_front(ev); else push_back(ev); } // retrieve a pending event bool retrieve(debug_event_t *event) { if (empty()) return false; // get the first event and return it *event = front(); pop_front(); return true; } };</span></span></span></span></code> </pre> </div></div><br><p>  Now the studio project will be able to set defaults for the compiler, therefore we add the following: </p><br><pre> <code class="cpp hljs">__NT__ __IDP__ __X64__</code> </pre> <br><p>  Add a new empty <code>ida_debug.cpp</code> file and paste the following template into it: </p><br><div class="spoiler">  <b class="spoiler_title">Source code ida_debug.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ida.hpp&gt; #include &lt;idd.hpp&gt; #include &lt;auto.hpp&gt; #include &lt;funcs.hpp&gt; #include &lt;idp.hpp&gt; #include &lt;dbg.hpp&gt; #include "ida_debmod.h" #include "debug_wrap.h" static dbg_request_t *dbg_req = NULL; static void pause_execution() { send_dbg_request(dbg_req, REQ_PAUSE); } static void continue_execution() { send_dbg_request(dbg_req, REQ_RESUME); } static void stop_debugging() { send_dbg_request(dbg_req, REQ_STOP); } eventlist_t g_events; static qthread_t events_thread = NULL; // TODO: Implement status register bits mask static const char *const SRReg[] = { }; #define RC_GENERAL (1 &lt;&lt; 0) // TODO: define different register types register_info_t registers[] = { // TODO: Implement registers description }; static const char *register_classes[] = { "General Registers", // TODO: Add other register group names NULL }; static void finish_execution() { if (events_thread != NULL) { qthread_join(events_thread); qthread_free(events_thread); qthread_kill(events_thread); events_thread = NULL; } } static bool idaapi init_debugger(const char *hostname, int portnum, const char *password) { set_processor_type(ph.psnames[0], SETPROC_LOADER); // reset proc to "M68000" return true; } static bool idaapi term_debugger(void) { dbg_req-&gt;is_ida = 0; close_shared_mem(&amp;dbg_req); return true; } static int idaapi process_get_info(procinfo_vec_t *procs) { return 0; } static int idaapi check_debugger_events(void *ud) { while (dbg_req-&gt;dbg_active || dbg_req-&gt;dbg_events_count) { dbg_req-&gt;is_ida = 1; int event_index = recv_dbg_event(dbg_req, 0); if (event_index == -1) { qsleep(10); continue; } debugger_event_t *dbg_event = &amp;dbg_req-&gt;dbg_events[event_index]; debug_event_t ev; switch (dbg_event-&gt;type) { case DBG_EVT_STARTED: ev.eid = PROCESS_START; ev.pid = 1; ev.tid = 1; ev.ea = BADADDR; ev.handled = true; ev.modinfo.name[0] = 'E'; ev.modinfo.name[1] = 'M'; ev.modinfo.name[2] = 'U'; ev.modinfo.name[3] = 'L'; ev.modinfo.name[4] = '\0'; ev.modinfo.base = 0; ev.modinfo.size = 0; ev.modinfo.rebase_to = BADADDR; g_events.enqueue(ev, IN_FRONT); break; case DBG_EVT_PAUSED: ev.pid = 1; ev.tid = 1; ev.ea = dbg_event-&gt;pc; ev.handled = true; ev.eid = PROCESS_SUSPEND; g_events.enqueue(ev, IN_BACK); break; case DBG_EVT_BREAK: ev.pid = 1; ev.tid = 1; ev.ea = dbg_event-&gt;pc; ev.handled = true; ev.eid = BREAKPOINT; ev.bpt.hea = ev.bpt.kea = ev.ea; g_events.enqueue(ev, IN_BACK); break; case DBG_EVT_STEP: ev.pid = 1; ev.tid = 1; ev.ea = dbg_event-&gt;pc; ev.handled = true; ev.eid = STEP; g_events.enqueue(ev, IN_BACK); break; case DBG_EVT_STOPPED: ev.eid = PROCESS_EXIT; ev.pid = 1; ev.handled = true; ev.exit_code = 0; g_events.enqueue(ev, IN_BACK); break; default: break; } dbg_event-&gt;type = DBG_EVT_NO_EVENT; qsleep(10); } return 0; } static int idaapi start_process(const char *path, const char *args, const char *startdir, int dbg_proc_flags, const char *input_path, uint32 input_file_crc32) { g_events.clear(); dbg_req = open_shared_mem(); if (!dbg_req) { show_wait_box("HIDECANCEL\nWaiting for connection to plugin..."); while (!dbg_req) { dbg_req = open_shared_mem(); } hide_wait_box(); } events_thread = qthread_create(check_debugger_events, NULL); send_dbg_request(dbg_req, REQ_ATTACH); return 1; } static void idaapi rebase_if_required_to(ea_t new_base) { } static int idaapi prepare_to_pause_process(void) { pause_execution(); return 1; } static int idaapi emul_exit_process(void) { stop_debugging(); finish_execution(); return 1; } static gdecode_t idaapi get_debug_event(debug_event_t *event, int timeout_ms) { while (true) { // are there any pending events? if (g_events.retrieve(event)) { return g_events.empty() ? GDE_ONE_EVENT : GDE_MANY_EVENTS; } if (g_events.empty()) break; } return GDE_NO_EVENT; } static int idaapi continue_after_event(const debug_event_t *event) { dbg_notification_t req = get_running_notification(); switch (event-&gt;eid) { case STEP: case BREAKPOINT: case PROCESS_SUSPEND: if (req == dbg_null || req == dbg_run_to) continue_execution(); break; } return 1; } static void idaapi stopped_at_debug_event(bool dlls_added) { } static int idaapi thread_suspend(thid_t tid) // Suspend a running thread { return 0; } static int idaapi thread_continue(thid_t tid) // Resume a suspended thread { return 0; } static int idaapi set_step_mode(thid_t tid, resume_mode_t resmod) // Run one instruction in the thread { switch (resmod) { case RESMOD_INTO: ///&lt; step into call (the most typical single stepping) send_dbg_request(dbg_req, REQ_STEP_INTO); break; case RESMOD_OVER: ///&lt; step over call send_dbg_request(dbg_req, REQ_STEP_OVER); break; } return 1; } static int idaapi read_registers(thid_t tid, int clsmask, regval_t *values) { if (!dbg_req) return 0; if (clsmask &amp; RC_GENERAL) { dbg_req-&gt;regs_data.type = REG_TYPE_M68K; send_dbg_request(dbg_req, REQ_GET_REGS); // TODO: Set register values for IDA } // TODO: Implement other registers reading return 1; } static void set_reg(register_type_t type, int reg_index, unsigned int value) { dbg_req-&gt;regs_data.type = type; dbg_req-&gt;regs_data.any_reg.index = reg_index; dbg_req-&gt;regs_data.any_reg.val = value; send_dbg_request(dbg_req, REQ_SET_REG); } static int idaapi write_register(thid_t tid, int regidx, const regval_t *value) { // TODO: Implement set registers for emulator return 1; } static int idaapi get_memory_info(meminfo_vec_t &amp;areas) { memory_info_t info; // Don't remove this loop for (int i = 0; i &lt; get_segm_qty(); ++i) { segment_t *segm = getnseg(i); info.start_ea = segm-&gt;start_ea; info.end_ea = segm-&gt;end_ea; qstring buf; get_segm_name(&amp;buf, segm); info.name = buf; get_segm_class(&amp;buf, segm); info.sclass = buf; info.sbase = 0; info.perm = SEGPERM_READ | SEGPERM_WRITE; info.bitness = 1; areas.push_back(info); } // Don't remove this loop return 1; } static ssize_t idaapi read_memory(ea_t ea, void *buffer, size_t size) { // TODO: Implement memory regions reading return size; } static ssize_t idaapi write_memory(ea_t ea, const void *buffer, size_t size) { return 0; } static int idaapi is_ok_bpt(bpttype_t type, ea_t ea, int len) { switch (type) { //case BPT_SOFT: case BPT_EXEC: case BPT_READ: // there is no such constant in sdk61 case BPT_WRITE: case BPT_RDWR: return BPT_OK; } return BPT_BAD_TYPE; } static int idaapi update_bpts(update_bpt_info_t *bpts, int nadd, int ndel) { for (int i = 0; i &lt; nadd; ++i) { ea_t start = bpts[i].ea; ea_t end = bpts[i].ea + bpts[i].size - 1; bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; switch (bpts[i].type) { case BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; break; case BPT_READ: bpt_data-&gt;type = BPT_M68K_R; break; case BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; break; case BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; break; } bpt_data-&gt;address = start; bpt_data-&gt;width = bpts[i].size; send_dbg_request(dbg_req, REQ_ADD_BREAK); bpts[i].code = BPT_OK; } for (int i = 0; i &lt; ndel; ++i) { ea_t start = bpts[nadd + i].ea; ea_t end = bpts[nadd + i].ea + bpts[nadd + i].size - 1; bpt_data_t *bpt_data = &amp;dbg_req-&gt;bpt_data; switch (bpts[nadd + i].type) { case BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; break; case BPT_READ: bpt_data-&gt;type = BPT_M68K_R; break; case BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; break; case BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; break; } bpt_data-&gt;address = start; send_dbg_request(dbg_req, REQ_DEL_BREAK); bpts[nadd + i].code = BPT_OK; } return (ndel + nadd); } //-------------------------------------------------------------------------- // // DEBUGGER DESCRIPTION BLOCK // //-------------------------------------------------------------------------- debugger_t debugger = { IDD_INTERFACE_VERSION, "DBGNAME", 0x8000 + 1, "m68k", DBG_FLAG_NOHOST | DBG_FLAG_CAN_CONT_BPT | DBG_FLAG_FAKE_ATTACH | DBG_FLAG_SAFE | DBG_FLAG_NOPASSWORD | DBG_FLAG_NOSTARTDIR | DBG_FLAG_CONNSTRING | DBG_FLAG_ANYSIZE_HWBPT | DBG_FLAG_DEBTHREAD, register_classes, RC_GENERAL, registers, qnumber(registers), 0x1000, NULL, NULL, 0, DBG_RESMOD_STEP_INTO | DBG_RESMOD_STEP_OVER, init_debugger, term_debugger, process_get_info, start_process, NULL, NULL, rebase_if_required_to, prepare_to_pause_process, emul_exit_process, get_debug_event, continue_after_event, NULL, stopped_at_debug_event, thread_suspend, thread_continue, set_step_mode, read_registers, write_register, NULL, get_memory_info, read_memory, write_memory, is_ok_bpt, update_bpts, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, };</span></span></span></span></code> </pre> </div></div><br><p>  Next, create another file, call it <code>ida_plugin.cpp</code> and paste the following code into it: </p><br><div class="spoiler">  <b class="spoiler_title">Source code ida_plugin.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ida.hpp&gt; #include &lt;dbg.hpp&gt; #include &lt;idd.hpp&gt; #include &lt;loader.hpp&gt; #include &lt;idp.hpp&gt; #include &lt;offset.hpp&gt; #include &lt;kernwin.hpp&gt; #include "ida_plugin.h" #include "ida_debmod.h" extern debugger_t debugger; static bool plugin_inited; static bool my_dbg; static int idaapi idp_to_dbg_reg(int idp_reg) { int reg_idx = idp_reg; if (idp_reg &gt;= 0 &amp;&amp; idp_reg &lt;= 7) reg_idx = 0 + idp_reg; else if (idp_reg &gt;= 8 &amp;&amp; idp_reg &lt;= 39) reg_idx = 8 + (idp_reg % 8); else if (idp_reg == 91) reg_idx = 16; else if (idp_reg == 92 || idp_reg == 93) reg_idx = 17; else if (idp_reg == 94) reg_idx = 15; else { char buf[MAXSTR]; ::qsnprintf(buf, MAXSTR, "reg: %d\n", idp_reg); warning("SEND THIS MESSAGE TO you@mail.com:\n%s\n", buf); return 0; } return reg_idx; } #ifdef _DEBUG static const char* const optype_names[] = { "o_void", "o_reg", "o_mem", "o_phrase", "o_displ", "o_imm", "o_far", "o_near", "o_idpspec0", "o_idpspec1", "o_idpspec2", "o_idpspec3", "o_idpspec4", "o_idpspec5", }; static const char* const dtyp_names[] = { "dt_byte", "dt_word", "dt_dword", "dt_float", "dt_double", "dt_tbyte", "dt_packreal", "dt_qword", "dt_byte16", "dt_code", "dt_void", "dt_fword", "dt_bitfild", "dt_string", "dt_unicode", "dt_3byte", "dt_ldbl", "dt_byte32", "dt_byte64", }; static void print_insn(insn_t *insn) { if (my_dbg) { msg("cs=%x, ", insn-&gt;cs); msg("ip=%x, ", insn-&gt;ip); msg("ea=%x, ", insn-&gt;ea); msg("itype=%x, ", insn-&gt;itype); msg("size=%x, ", insn-&gt;size); msg("auxpref=%x, ", insn-&gt;auxpref); msg("segpref=%x, ", insn-&gt;segpref); msg("insnpref=%x, ", insn-&gt;insnpref); msg("insnpref=%x, ", insn-&gt;insnpref); msg("flags["); if (insn-&gt;flags &amp; INSN_MACRO) msg("INSN_MACRO|"); if (insn-&gt;flags &amp; INSN_MODMAC) msg("OF_OUTER_DISP"); msg("]\n"); } } static void print_op(ea_t ea, op_t *op) { if (my_dbg) { msg("type[%s], ", optype_names[op-&gt;type]); msg("flags["); if (op-&gt;flags &amp; OF_NO_BASE_DISP) msg("OF_NO_BASE_DISP|"); if (op-&gt;flags &amp; OF_OUTER_DISP) msg("OF_OUTER_DISP|"); if (op-&gt;flags &amp; PACK_FORM_DEF) msg("PACK_FORM_DEF|"); if (op-&gt;flags &amp; OF_NUMBER) msg("OF_NUMBER|"); if (op-&gt;flags &amp; OF_SHOW) msg("OF_SHOW"); msg("], "); msg("dtyp[%s], ", dtyp_names[op-&gt;dtype]); if (op-&gt;type == o_reg) msg("reg=%x, ", op-&gt;reg); else if (op-&gt;type == o_displ || op-&gt;type == o_phrase) msg("phrase=%x, ", op-&gt;phrase); else msg("reg_phrase=%x, ", op-&gt;phrase); msg("addr=%x, ", op-&gt;addr); msg("value=%x, ", op-&gt;value); msg("specval=%x, ", op-&gt;specval); msg("specflag1=%x, ", op-&gt;specflag1); msg("specflag2=%x, ", op-&gt;specflag2); msg("specflag3=%x, ", op-&gt;specflag3); msg("specflag4=%x, ", op-&gt;specflag4); msg("refinfo["); opinfo_t buf; if (get_opinfo(&amp;buf, ea, op-&gt;n, op-&gt;flags)) { msg("target=%x, ", buf.ri.target); msg("base=%x, ", buf.ri.base); msg("tdelta=%x, ", buf.ri.tdelta); msg("flags["); if (buf.ri.flags &amp; REFINFO_TYPE) msg("REFINFO_TYPE|"); if (buf.ri.flags &amp; REFINFO_RVAOFF) msg("REFINFO_RVAOFF|"); if (buf.ri.flags &amp; REFINFO_PASTEND) msg("REFINFO_PASTEND|"); if (buf.ri.flags &amp; REFINFO_CUSTOM) msg("REFINFO_CUSTOM|"); if (buf.ri.flags &amp; REFINFO_NOBASE) msg("REFINFO_NOBASE|"); if (buf.ri.flags &amp; REFINFO_SUBTRACT) msg("REFINFO_SUBTRACT|"); if (buf.ri.flags &amp; REFINFO_SIGNEDOP) msg("REFINFO_SIGNEDOP"); msg("]"); } msg("]\n"); } } #endif typedef const regval_t &amp;(idaapi *getreg_func_t)(const char *name, const regval_t *regvalues); static ssize_t idaapi hook_idp(void *user_data, int notification_code, va_list va) { switch (notification_code) { case processor_t::ev_get_idd_opinfo: { idd_opinfo_t * opinf = va_arg(va, idd_opinfo_t *); ea_t ea = va_arg(va, ea_t); int n = va_arg(va, int); int thread_id = va_arg(va, int); getreg_func_t getreg = va_arg(va, getreg_func_t); const regval_t *regvalues = va_arg(va, const regval_t *); opinf-&gt;ea = BADADDR; opinf-&gt;debregidx = 0; opinf-&gt;modified = false; opinf-&gt;value.ival = 0; opinf-&gt;value_size = 4; insn_t out; if (decode_insn(&amp;out, ea)) { op_t op = out.ops[n]; #ifdef _DEBUG print_insn(&amp;out); #endif int size = 0; switch (op.dtype) { case dt_byte: size = 1; break; case dt_word: size = 2; break; default: size = 4; break; } opinf-&gt;value_size = size; switch (op.type) { case o_mem: case o_near: case o_imm: { flags_t flags; switch (n) { case 0: flags = get_optype_flags0(get_flags(ea)); break; case 1: flags = get_optype_flags1(get_flags(ea)); break; default: flags = 0; break; } switch (op.type) { case o_mem: case o_near: opinf-&gt;ea = op.addr; break; case o_imm: opinf-&gt;ea = op.value; break; } opinfo_t info; if (get_opinfo(&amp;info, ea, n, flags) != NULL) { opinf-&gt;ea += info.ri.base; } } break; case o_phrase: case o_reg: { int reg_idx = idp_to_dbg_reg(op.reg); regval_t reg = getreg(dbg-&gt;registers(reg_idx).name, regvalues); if (op.phrase &gt;= 0x10 &amp;&amp; op.phrase &lt;= 0x1F || // (A0)..(A7), (A0)+..(A7)+ op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) // -(A0)..-(A7) { if (op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) reg.ival -= size; opinf-&gt;ea = (ea_t)reg.ival; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } else opinf-&gt;value = reg; opinf-&gt;debregidx = reg_idx; } break; case o_displ: { regval_t main_reg, add_reg; int main_reg_idx = idp_to_dbg_reg(op.reg); int add_reg_idx = idp_to_dbg_reg(op.specflag1 &amp; 0xF); main_reg.ival = 0; add_reg.ival = 0; if (op.specflag2 &amp; 0x10) { add_reg = getreg(dbg-&gt;registers(add_reg_idx).name, regvalues); if (op.specflag1 &amp; 0x10) { add_reg.ival &amp;= 0xFFFF; add_reg.ival = (uint64)((int16_t)add_reg.ival); } } if (main_reg_idx != 16) main_reg = getreg(dbg-&gt;registers(main_reg_idx).name, regvalues); ea_t addr = (ea_t)main_reg.ival + op.addr + (ea_t)add_reg.ival; opinf-&gt;ea = addr; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory(addr, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory(addr, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory(addr, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } break; } opinf-&gt;ea &amp;= 0xFFFFFF; return 1; } } break; default: { #ifdef _DEBUG if (my_dbg) { msg("msg = %d\n", notification_code); } #endif } break; } return 0; } //-------------------------------------------------------------------------- static void print_version() { static const char format[] = NAME " debugger plugin v%s;\nAuthor: Dr. MefistO."; info(format, VERSION); msg(format, VERSION); } //-------------------------------------------------------------------------- // Initialize debugger plugin static int idaapi init(void) { if (ph.id == PLFM_68K) { dbg = &amp;debugger; plugin_inited = true; my_dbg = false; hook_to_notification_point(HT_IDP, hook_idp, NULL); print_version(); return PLUGIN_KEEP; } return PLUGIN_SKIP; } //-------------------------------------------------------------------------- // Terminate debugger plugin static void idaapi term(void) { if (plugin_inited) { unhook_from_notification_point(HT_IDP, hook_idp); plugin_inited = false; } } //-------------------------------------------------------------------------- // The plugin method - usually is not used for debugger plugins static bool idaapi run(size_t arg) { return false; } //-------------------------------------------------------------------------- char comment[] = NAME " debugger plugin by Dr. MefistO."; char help[] = NAME " debugger plugin by Dr. MefistO.\n" "\n" "This module lets you debug Genesis roms in IDA.\n"; //-------------------------------------------------------------------------- // // PLUGIN DESCRIPTION BLOCK // //-------------------------------------------------------------------------- plugin_t PLUGIN = { IDP_INTERFACE_VERSION, PLUGIN_PROC | PLUGIN_DBG | PLUGIN_MOD, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint help, // multiline help about the plugin NAME " debugger plugin", // the preferred short name of the plugin "" // the preferred hotkey to run the plugin };</span></span></span></span></code> </pre> </div></div><br><p>  Now let's understand, and at the same time write code. </p><br><h3 id="realizaciya-otladchika">  Debugger implementation </h3><br><p>  The <code>dbg_req</code> variable will have a pointer to the memory shared with the debugger kernel.  It is in it that we will send requests, and receive answers from it. </p><br><p>  The functions <code>pause_execution()</code> , <code>continue_execution()</code> and <code>stop_debugging()</code> are needed to control the debugging process. </p><br><p>  <code>eventlist_t g_events</code> is a list of debugger events that <code>IDA</code> will wait for in response to some of our actions (for example, start / stop emulation, triggered breakpoint). </p><br><p>  Well, the list will be <code>events_thread</code> , which will monitor the presence of debugger events in shared memory, and convert them to the corresponding <code>IDA</code> events. </p><br><p>  Let's write the function <code>finish_execution()</code> , which will simply end the wait for debug events: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish_execution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (events_thread != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { qthread_join(events_thread); qthread_free(events_thread); qthread_kill(events_thread); events_thread = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } }</code> </pre> <br><p>  So, we figured it out.  Now we will be engaged in the description of registers. <br>  Register information is a structure of the following form: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">register_info_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *name; uint32 flags; <span class="hljs-keyword"><span class="hljs-keyword">register_class_t</span></span> register_class; <span class="hljs-keyword"><span class="hljs-keyword">op_dtype_t</span></span> dtype; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *bit_strings; <span class="hljs-keyword"><span class="hljs-keyword">uval_t</span></span> default_bit_strings_mask; };</code> </pre> <br><p>  The <code>name</code> field is the text name of the register.  While in different groups of registers can not be the same name.  For example, if you want to display the <code>PC</code> register from two different processors (and in the <code>Sega Mega Drive</code> there are two: <code>Motorola 68000</code> and <code>Z80</code> ), you will have to rename it. </p><br><p>  The <code>flags</code> field can contain one or more of the following flags: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_READONLY 0x0001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///&lt; the user can't modify the current value of this register #define REGISTER_IP 0x0002 ///&lt; instruction pointer #define REGISTER_SP 0x0004 ///&lt; stack pointer #define REGISTER_FP 0x0008 ///&lt; frame pointer #define REGISTER_ADDRESS 0x0010 ///&lt; may contain an address #define REGISTER_CS 0x0020 ///&lt; code segment #define REGISTER_SS 0x0040 ///&lt; stack segment #define REGISTER_NOLF 0x0080 ///&lt; displays this register without returning to the next line ///&lt; allowing the next register to be displayed to its right (on the same line) #define REGISTER_CUSTFMT 0x0100 ///&lt; register should be displayed using a custom data format. ///&lt; the format name is in bit_strings[0] ///&lt; the corresponding ::regval_t will use ::bytevec_t</span></span></span></span></code> </pre> <br><p>  It is clear that you cannot combine <code>REGISTER_IP</code> and <code>REGISTER SP</code> , but you can indicate that the field contains an address using the <code>REGISTER_ADDRESS</code> flag. </p><br><p>  <code>register_class</code> is the mask number of the group of registers you have implemented.  For example, I added the following three: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RC_GENERAL (1 &lt;&lt; 0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RC_VDP (1 &lt;&lt; 1) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RC_Z80 (1 &lt;&lt; 2)</span></span></code> </pre> <br><p>  <code>dtype</code> is an indication of the size of the register.  The options are as follows: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> dt_byte 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">///&lt; 8 bit #define dt_word 1 ///&lt; 16 bit #define dt_dword 2 ///&lt; 32 bit #define dt_float 3 ///&lt; 4 byte #define dt_double 4 ///&lt; 8 byte #define dt_tbyte 5 ///&lt; variable size (\ph{tbyte_size}) #define dt_packreal 6 ///&lt; packed real format for mc68040 #define dt_qword 7 ///&lt; 64 bit #define dt_byte16 8 ///&lt; 128 bit #define dt_code 9 ///&lt; ptr to code (not used?) #define dt_void 10 ///&lt; none #define dt_fword 11 ///&lt; 48 bit #define dt_bitfild 12 ///&lt; bit field (mc680x0) #define dt_string 13 ///&lt; pointer to asciiz string #define dt_unicode 14 ///&lt; pointer to unicode string #define dt_ldbl 15 ///&lt; long double (which may be different from tbyte) #define dt_byte32 16 ///&lt; 256 bit #define dt_byte64 17 ///&lt; 512 bit</span></span></span></span></code> </pre> <br><p>  Actually, I need only <code>dt_word</code> , <code>dt_dword</code> . </p><br><p>  The <code>bit_strings</code> field <code>bit_strings</code> needed if, for example, you want to output some register in the form of its individual bits.  In particular, this can be used for the register of flags: <code>Negative</code> , <code>Overflow</code> , <code>Zero</code> , <code>Carry</code> , etc.  Example: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SRReg[] = { <span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-string"><span class="hljs-string">"V"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z"</span></span>, <span class="hljs-string"><span class="hljs-string">"N"</span></span>, <span class="hljs-string"><span class="hljs-string">"X"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"I"</span></span>, <span class="hljs-string"><span class="hljs-string">"I"</span></span>, <span class="hljs-string"><span class="hljs-string">"I"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"S"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-string"><span class="hljs-string">"T"</span></span> };</code> </pre> <br><p>  Bits start from top to bottom (from low to high).  If the value of the bit is not necessary to output, instead of the name we specify <code>NULL</code>  If several bits in the register belong to the same flag, specify the same name the required number of times. </p><br><p>  Well, the last field <code>default_bit_strings_mask</code> is the bitmask that will be used before getting the register bit values. </p><br><p>  Here is an example of my implementation of the list of registers for the <code>Sega Mega Drive</code> (I included the registers M68K, Z80 and VDP, as well as a couple of custom ones): </p><br><div class="spoiler">  <b class="spoiler_title">Register Description for Debugger</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register_info_t</span></span> registers[] = { { <span class="hljs-string"><span class="hljs-string">"D0"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D1"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D2"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D3"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D4"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D5"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D6"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"D7"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A0"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A1"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A2"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A3"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A4"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A5"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A6"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"A7"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"PC"</span></span>, REGISTER_ADDRESS | REGISTER_IP, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"SR"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, RC_GENERAL, dt_word, SRReg, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> }, { <span class="hljs-string"><span class="hljs-string">"SP"</span></span>, REGISTER_ADDRESS | REGISTER_SP, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"USP"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"ISP"</span></span>, REGISTER_ADDRESS, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"PPC"</span></span>, REGISTER_ADDRESS | REGISTER_READONLY, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, { <span class="hljs-string"><span class="hljs-string">"IR"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, RC_GENERAL, dt_dword, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-comment"><span class="hljs-comment">// VDP Registers { "v00", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v01", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v02", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v03", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v04", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v05", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v06", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v07", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v08", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v09", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0A", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0B", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0C", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0D", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0E", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v0F", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v10", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v11", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v12", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v13", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v14", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v15", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v16", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v17", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v18", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v19", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1A", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1B", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1C", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1D", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1E", NULL, RC_VDP, dt_byte, NULL, 0 }, { "v1F", NULL, RC_VDP, dt_byte, NULL, 0 }, { "DMA_LEN", REGISTER_READONLY, RC_VDP, dt_word, NULL, 0 }, { "DMA_SRC", REGISTER_ADDRESS | REGISTER_READONLY, RC_VDP, dt_dword, NULL, 0 }, { "VDP_DST", REGISTER_ADDRESS | REGISTER_READONLY, RC_VDP, dt_dword, NULL, 0 }, // Z80 regs { "zPC", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zSP", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zAF", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zBC", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zDE", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zHL", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zIX", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zIY", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zWZ", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zAF2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zBC2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zDE2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zHL2", NULL, RC_Z80, dt_dword, NULL, 0 }, { "zR", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zR2", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zIFFI1", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zIFFI2", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zHALT", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zIM", NULL, RC_Z80, dt_byte, NULL, 0 }, { "zI", NULL, RC_Z80, dt_byte, NULL, 0 }, };</span></span></code> </pre> </div></div><br><p>  Next comes the <code>register_classes[]</code> list, in which we must specify the text names of the register groups.  They can be opened in separate windows when debugging. </p><br><p><img src="https://habrastorage.org/webt/qf/mg/h6/qfmgh6-849gg62-8cugjnxqtss4.png"></p><br><p>  Here is my implementation (the last element should be <code>NULL</code> ): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *register_classes[] = { <span class="hljs-string"><span class="hljs-string">"General Registers"</span></span>, <span class="hljs-string"><span class="hljs-string">"VDP Registers"</span></span>, <span class="hljs-string"><span class="hljs-string">"Z80 Registers"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><h3 id="kolbeki-neobhodimye-ida">  Callbacks required by IDA </h3><br><h4 id="init_debugger">  init_debugger () </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *hostname, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> portnum, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *password)</span></span></span><span class="hljs-function"> </span></span>{ set_processor_type(ph.psnames[<span class="hljs-number"><span class="hljs-number">0</span></span>], SETPROC_LOADER); <span class="hljs-comment"><span class="hljs-comment">// reset proc to "M68000" return true; }</span></span></code> </pre> <br><p>  Since <code>IDA</code> implements several versions of the Motorola processor, I forcibly drop it on the very first in the list. </p><br><h4 id="term_debugger">  term_debugger () </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term_debugger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ dbg_req-&gt;is_ida = <span class="hljs-number"><span class="hljs-number">0</span></span>; close_shared_mem(&amp;dbg_req); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><p>  <strong>Fun fact</strong> : the <code>init_debugger()</code> function is called once the first time the emulation is <code>term_debugger()</code> per session, and the <code>term_debugger()</code> function is <code>term_debugger()</code> each time the debugging process is completed.  Therefore, I close the open shared memory here. </p><br><p>  Both functions must return <code>true</code> if successful. </p><br><h4 id="process_get_info">  process_get_info () </h4><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_get_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">procinfo_vec_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *procs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  If during debugging you are working with several processes, you need to implement this callback, which will inform <code>IDA</code> information on each of them, namely the <code>PID</code> and name. </p><br><p>  I do not need this function, so I return <code>0</code> . </p><br><h4 id="check_debugger_events---ne-kolbek-no-ochen-vazhen">  check_debugger_events () is not a callback, but very important </h4><br><p>  Actually, it is a thread waiting for debug events.  Here it is necessary to tell in more detail. </p><br><p>  When you start debugging, the first event that <code>IDA</code> expects to receive should be <code>PROCESS_START</code> .   , ,    , <code>IDA</code>  . </p><br><p>       .   : </p><br><ul><li> <code>PROCESS_SUSPEND</code> ‚Äî  ,          ,    . </li><li> <code>BREAKPOINT</code> ‚Äî   <code>IDA</code>  ,      ‚Äî  ,  ,   .   <em></em> ?        <code>PROCESS_SUSPEND</code> ,      ,    <code>IDA</code> </li><li> <code>STEP</code> ‚Äî    ,   <code>IDA</code>  ,   <code>Step Into</code>  <code>Step Over</code> , ,  ,     <code>PROCESS_SUSPEND</code> </li><li> <code>PROCESS_EXIT</code> ‚Äî    <code>IDA</code>    ,   .     <code>Stop</code>   , <code>IDA</code>       ,    , <del>    , </del>       . </li></ul><br><p>       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">debug_event_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event_id_t</span></span> eid; <span class="hljs-comment"><span class="hljs-comment">///&lt; Event code (used to decipher 'info' union) pid_t pid; ///&lt; Process where the event occurred thid_t tid; ///&lt; Thread where the event occurred ea_t ea; ///&lt; Address where the event occurred bool handled; ///&lt; Is event handled by the debugger?. ///&lt; (from the system's point of view) ///&lt; Meaningful for ::EXCEPTION events union { module_info_t modinfo; ///&lt; ::PROCESS_START, ::PROCESS_ATTACH, ::LIBRARY_LOAD int exit_code; ///&lt; ::PROCESS_EXIT, ::THREAD_EXIT char info[MAXSTR]; ///&lt; ::LIBRARY_UNLOAD (unloaded library name) ///&lt; ::INFORMATION (will be displayed in the ///&lt; messages window if not empty) e_breakpoint_t bpt; ///&lt; ::BREAKPOINT e_exception_t exc; ///&lt; ::EXCEPTION }; };</span></span></code> </pre> <br><p> <code>eid</code> ‚Äî     ,    <br> <code>pid</code> , <code>tid</code> ‚Äî , <em>Process ID</em>  <em>Thread ID</em> ,     <br> <code>ea</code> ‚Äî ,    <br> <code>handled</code> ‚Äî      , ,     <code>IDA SDK</code> ,    ,      ( ?).    <code>true</code> </p><br><p>   ,        . </p><br><p>  <code>PROCESS_START</code>      ( ), <code>ImageBase</code> ,    , ,   <code>ImageBase</code> ,     ,      <code>IDB</code> .        ,   ,  <code>BADADDR</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DBG_EVT_STARTED: ev.eid = PROCESS_START; ev.pid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.tid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.ea = BADADDR; ev.handled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'G'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'P'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-string"><span class="hljs-string">'G'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-string"><span class="hljs-string">'X'</span></span>; ev.modinfo.name[<span class="hljs-number"><span class="hljs-number">4</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; ev.modinfo.base = <span class="hljs-number"><span class="hljs-number">0</span></span>; ev.modinfo.size = <span class="hljs-number"><span class="hljs-number">0</span></span>; ev.modinfo.rebase_to = BADADDR; g_events.enqueue(ev, IN_FRONT); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br><p>  <code>BREAKPOINT</code>   <code>bpt</code>  <code>hardware</code> ‚Äî  <code>kernel</code> -  .         ,   <code>IDA</code>  ,         . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DBG_EVT_BREAK: ev.pid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.tid = <span class="hljs-number"><span class="hljs-number">1</span></span>; ev.ea = dbg_event-&gt;pc; ev.handled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ev.eid = BREAKPOINT; ev.bpt.hea = ev.bpt.kea = ev.ea; g_events.enqueue(ev, IN_BACK); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br><p>   <code>PROCESS_EXIT</code>   <code>exit_code</code> . </p><br><h4 id="start_process"> start_process() </h4><br><p>    ,    ,    ,      . </p><br><p>       ,         (     ),     ,        . </p><br><p>  <code>1</code>   . </p><br><h4 id="rebase_if_required_to"> rebase_if_required_to() </h4><br><p>    , ..     , ,     : </p><br><div class="spoiler"> <b class="spoiler_title"> rebase_if_required_to</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rebase_if_required_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ea_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> new_base)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> currentbase = new_base; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> imagebase = inf.startIP; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (imagebase != currentbase) { <span class="hljs-keyword"><span class="hljs-keyword">adiff_t</span></span> delta = currentbase - imagebase; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> code = rebase_program(delta, MSF_FIXONCE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (code != MOVE_SEGM_OK) { msg(<span class="hljs-string"><span class="hljs-string">"Failed to rebase program, error code %d\n"</span></span>, code); warning(<span class="hljs-string"><span class="hljs-string">"IDA failed to rebase the program.\n"</span></span> <span class="hljs-string"><span class="hljs-string">"Most likely it happened because of the debugger\n"</span></span> <span class="hljs-string"><span class="hljs-string">"segments created to reflect the real memory state.\n\n"</span></span> <span class="hljs-string"><span class="hljs-string">"Please stop the debugger and rebase the program manually.\n"</span></span> <span class="hljs-string"><span class="hljs-string">"For that, please select the whole program and\n"</span></span> <span class="hljs-string"><span class="hljs-string">"use Edit, Segments, Rebase program with delta 0x%08a"</span></span>, delta); } } }</code> </pre> </div></div><br><h4 id="prepare_to_pause_process"> prepare_to_pause_process() </h4><br><p>     <code>Pause</code>  <code>IDA</code> ,    . <br>  <code>1</code>      . </p><br><h4 id="get_debug_event"> get_debug_event() </h4><br><p> ,   <code>IDA</code> ,     .    (?) .   ,   <code>debug_event_t</code>   <code>*event</code> ,  : </p><br><ul><li> <code>GDE_ONE_EVENT</code> ,     ,      </li><li> <code>GDE_MANY_EVENTS</code> ,      ,   </li><li> <code>GDE_NO_EVENT</code> ,      </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> gdecode_t idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_debug_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">debug_event_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *event, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout_ms)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// are there any pending events? if (g_events.retrieve(event)) { return g_events.empty() ? GDE_ONE_EVENT : GDE_MANY_EVENTS; } if (g_events.empty()) break; } return GDE_NO_EVENT; }</span></span></code> </pre> <br><h4 id="continue_after_event"> continue_after_event() </h4><br><p>  ,         -  <code>IDA</code> .    . </p><br><p>  ,   ,  ,   -      .    : </p><br><ol><li>   <code>STEP</code> </li><li> <code>IDA</code>            ,   .. </li><li>   , ,  <code>Step In</code> </li><li>   <code>continue_after_event()</code> ,      <em></em>    .    ‚Äî <code>STEP</code> </li><li> <code>IDA</code>   <code>STEP</code> </li></ol><br><p>    , ,       ,        , <strong>  </strong> ! <br>   ,  ,     <code>3</code>   <code>Step Into</code> , <code>Step Over</code> ,  <code>F9</code> ,   . </p><br><p>    <code>STEP</code> , <code>BREAKPOINT</code>  <code>PROCESS_SUSPEND</code> ,       <code>F9</code> ,        <code>continue_execution()</code> .   <code>F9</code>  <code>Run to</code>    : </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">dbg_notification_t</span></span> req = get_running_notification(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req == dbg_null || req == dbg_run_to) continue_execution();</code> </pre> <br><h4 id="stopped_at_debug_event"> stopped_at_debug_event() </h4><br><p>    ,   .   . </p><br><h4 id="thread_suspend-thread_continue"> thread_suspend(), thread_continue() </h4><br><p>   ,        / ,  .   ,        ,   <code>0</code> .       ,        . </p><br><h4 id="set_step_mode"> set_step_mode() </h4><br><p>  ,       <code>Step Into</code> , <code>Step Over</code> , <code>Step Out</code> .        (     <code>debugger_t</code> ,     ). <br>  <code>1</code>   . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_step_mode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">resume_mode_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resmod)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (resmod) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESMOD_INTO: send_dbg_request(dbg_req, REQ_STEP_INTO); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> RESMOD_OVER: send_dbg_request(dbg_req, REQ_STEP_OVER); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h4 id="read_registers"> read_registers() </h4><br><p>  <code>IDA</code>   <code>STEP</code> , <code>BREAKPOINT</code>  <code>PROCESS_SUSPEND</code> (.. ,   ),     ,      . </p><br><p>    : </p><br><ul><li> <code>clsmask</code> ‚Äî        ?   .         </li><li> <code>values</code> ‚Äî   ,    .        <code>registers[]</code> . </li></ul><br><p>      : </p><br><div class="spoiler"> <b class="spoiler_title"> read_registers()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_registers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> clsmask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">regval_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *values)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!dbg_req) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clsmask &amp; RC_GENERAL) { dbg_req-&gt;regs_data.type = REG_TYPE_M68K; send_dbg_request(dbg_req, REQ_GET_REGS); <span class="hljs-keyword"><span class="hljs-keyword">regs_68k_data_t</span></span> *reg_vals = &amp;dbg_req-&gt;regs_data.regs_68k; values[REG_68K_D0].ival = reg_vals-&gt;d0; values[REG_68K_D1].ival = reg_vals-&gt;d1; values[REG_68K_D2].ival = reg_vals-&gt;d2; values[REG_68K_D3].ival = reg_vals-&gt;d3; values[REG_68K_D4].ival = reg_vals-&gt;d4; values[REG_68K_D5].ival = reg_vals-&gt;d5; values[REG_68K_D6].ival = reg_vals-&gt;d6; values[REG_68K_D7].ival = reg_vals-&gt;d7; values[REG_68K_A0].ival = reg_vals-&gt;a0; values[REG_68K_A1].ival = reg_vals-&gt;a1; values[REG_68K_A2].ival = reg_vals-&gt;a2; values[REG_68K_A3].ival = reg_vals-&gt;a3; values[REG_68K_A4].ival = reg_vals-&gt;a4; values[REG_68K_A5].ival = reg_vals-&gt;a5; values[REG_68K_A6].ival = reg_vals-&gt;a6; values[REG_68K_A7].ival = reg_vals-&gt;a7; values[REG_68K_PC].ival = reg_vals-&gt;pc &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; values[REG_68K_SR].ival = reg_vals-&gt;sr; values[REG_68K_SP].ival = reg_vals-&gt;sp &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; values[REG_68K_PPC].ival = reg_vals-&gt;ppc &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>; values[REG_68K_IR].ival = reg_vals-&gt;ir; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clsmask &amp; RC_VDP) { dbg_req-&gt;regs_data.type = REG_TYPE_VDP; send_dbg_request(dbg_req, REQ_GET_REGS); <span class="hljs-keyword"><span class="hljs-keyword">vdp_regs_t</span></span> *vdp_regs = &amp;dbg_req-&gt;regs_data.vdp_regs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(vdp_regs-&gt;regs_vdp) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(vdp_regs-&gt;regs_vdp[<span class="hljs-number"><span class="hljs-number">0</span></span>]); ++i) { values[REG_VDP_00 + i].ival = vdp_regs-&gt;regs_vdp[i]; } values[REG_VDP_DMA_LEN].ival = vdp_regs-&gt;dma_len; values[REG_VDP_DMA_SRC].ival = vdp_regs-&gt;dma_src; values[REG_VDP_DMA_DST].ival = vdp_regs-&gt;dma_dst; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clsmask &amp; RC_Z80) { dbg_req-&gt;regs_data.type = REG_TYPE_Z80; send_dbg_request(dbg_req, REQ_GET_REGS); <span class="hljs-keyword"><span class="hljs-keyword">regs_z80_data_t</span></span> *z80_regs = &amp;dbg_req-&gt;regs_data.regs_z80; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (REG_Z80_I - REG_Z80_PC + <span class="hljs-number"><span class="hljs-number">1</span></span>); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt;= <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PC &lt;-&gt; HL2 { values[REG_Z80_PC + i].ival = ((unsigned int *)&amp;z80_regs-&gt;pc)[i]; } else if (i &gt;= 13 &amp;&amp; i &lt;= 19) // R &lt;-&gt; I { values[REG_Z80_PC + i].ival = ((unsigned char *)&amp;z80_regs-&gt;r)[i - 13]; } } } return 1; }</span></span></code> </pre> </div></div><br><p>  <code>1</code>   . </p><br><h4 id="write_register"> write_register() </h4><br><p>      ‚Äî    .            . </p><br><p>  : </p><br><div class="spoiler"> <b class="spoiler_title"> write_register()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">thid_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tid, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> regidx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">regval_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_68K_D0 &amp;&amp; regidx &lt;= REG_68K_D7) { set_reg(REG_TYPE_M68K, regidx - REG_68K_D0, (uint32)value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_68K_A0 &amp;&amp; regidx &lt;= REG_68K_A7) { set_reg(REG_TYPE_M68K, regidx - REG_68K_A0, (uint32)value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_PC) { set_reg(REG_TYPE_M68K, REG_68K_PC, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_SR) { set_reg(REG_TYPE_M68K, REG_68K_SR, (uint16)value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_SP) { set_reg(REG_TYPE_M68K, REG_68K_SP, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_USP) { set_reg(REG_TYPE_M68K, REG_68K_USP, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx == REG_68K_ISP) { set_reg(REG_TYPE_M68K, REG_68K_ISP, (uint32)value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFFFFFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_VDP_00 &amp;&amp; regidx &lt;= REG_VDP_1F) { set_reg(REG_TYPE_VDP, regidx - REG_VDP_00, value-&gt;ival &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regidx &gt;= REG_Z80_PC &amp;&amp; regidx &lt;= REG_Z80_I) { set_reg(REG_TYPE_Z80, regidx - REG_Z80_PC, value-&gt;ival); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> </div></div><br><p>  <code>1</code>   . </p><br><h4 id="get_memory_info"> get_memory_info() </h4><br><p>       <em></em>  ,       .    :    <code>IDB</code>    - ,     .              . </p><br><p>        - ,      ,      .    : </p><br><pre> <code class="cpp hljs"> info.name = <span class="hljs-string"><span class="hljs-string">"DBG_VDP_VRAM"</span></span>; info.start_ea = <span class="hljs-number"><span class="hljs-number">0xD00000</span></span>; info.end_ea = info.start_ea + <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; info.bitness = <span class="hljs-number"><span class="hljs-number">1</span></span>; areas.push_back(info); info.name = <span class="hljs-string"><span class="hljs-string">"DBG_VDP_CRAM"</span></span>; info.start_ea = info.end_ea; info.end_ea = info.start_ea + <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; info.bitness = <span class="hljs-number"><span class="hljs-number">1</span></span>; areas.push_back(info); info.name = <span class="hljs-string"><span class="hljs-string">"DBG_VDP_VSRAM"</span></span>; info.start_ea = info.end_ea; info.end_ea = info.start_ea + <span class="hljs-number"><span class="hljs-number">0x10000</span></span>; info.bitness = <span class="hljs-number"><span class="hljs-number">1</span></span>; areas.push_back(info);</code> </pre> <br><p>  <code>1</code>   . </p><br><h4 id="read_memory"> read_memory() </h4><br><p>    .    ,    ,     <code>XTRN</code> , <code>IDA</code>   . <br>      <code>ea</code> ,    ,   <code>size</code> ,   ,     <code>buffer</code> ,          . </p><br><div class="spoiler"> <b class="spoiler_title">  read_memory()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ssize_t idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ea_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ea, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buffer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((ea &gt;= <span class="hljs-number"><span class="hljs-number">0xA00000</span></span> &amp;&amp; ea &lt; <span class="hljs-number"><span class="hljs-number">0xA0FFFF</span></span>)) { dbg_req-&gt;mem_data.address = ea; dbg_req-&gt;mem_data.size = size; send_dbg_request(dbg_req, REQ_READ_Z80); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(buffer, &amp;dbg_req-&gt;mem_data.z80_ram[ea &amp; <span class="hljs-number"><span class="hljs-number">0x1FFF</span></span>], size); <span class="hljs-comment"><span class="hljs-comment">// Z80 } else if (ea &lt; MAXROMSIZE) { dbg_req-&gt;mem_data.address = ea; dbg_req-&gt;mem_data.size = size; send_dbg_request(dbg_req, REQ_READ_68K_ROM); memcpy(buffer, &amp;dbg_req-&gt;mem_data.m68k_rom[ea], size); } else if ((ea &gt;= 0xFF0000 &amp;&amp; ea &lt; 0x1000000)) { dbg_req-&gt;mem_data.address = ea; dbg_req-&gt;mem_data.size = size; send_dbg_request(dbg_req, REQ_READ_68K_RAM); memcpy(buffer, &amp;dbg_req-&gt;mem_data.m68k_ram[ea &amp; 0xFFFF], size); // RAM } return size; }</span></span></code> </pre> </div></div><br><h4 id="write_memory"> write_memory() </h4><br><p>   ,   -      :  ,   RAM,  ,      . </p><br><p>       ,    <code>0</code> .   <code>1</code> . </p><br><p>     ,     ,    ,  <code>buffer</code>  ‚Äî   ,   . </p><br><h4 id="is_ok_bpt"> is_ok_bpt() </h4><br><p>                 <code>len</code>   <code>type</code>   <code>ea</code> . </p><br><p>   ,  <code>BPT_OK</code> ,  ‚Äî <code>BPT_BAD_TYPE</code> . </p><br><h4 id="update_bpts"> update_bpts() </h4><br><p> ,       <code>IDA</code>   .  ,         ,  .      <code>F9</code> ( <em>Continue</em> ). </p><br><p>       : </p><br><ol><li>     <code>bpts</code> ,    ,  : , , ,        <code>nadd</code>   <code>ndel</code> ,       . </li><li>  ,      ,  <code>bpts[i].code</code>  <code>BPT_OK</code> . </li></ol><br><p>      +  .   <code>nadd + ndel</code> . </p><br><div class="spoiler"> <b class="spoiler_title"> update_bpts()</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_bpts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">update_bpt_info_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bpts, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nadd, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ndel)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nadd; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> start = bpts[i].ea; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> end = bpts[i].ea + bpts[i].size - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bpt_data_t</span></span> *bpt_data = &amp;dbg_req-&gt;bpt_data; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bpts[i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_READ: bpt_data-&gt;type = BPT_M68K_R; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } bpt_data-&gt;address = start; bpt_data-&gt;width = bpts[i].size; send_dbg_request(dbg_req, REQ_ADD_BREAK); bpts[i].code = BPT_OK; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; ndel; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> start = bpts[nadd + i].ea; <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> end = bpts[nadd + i].ea + bpts[nadd + i].size - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bpt_data_t</span></span> *bpt_data = &amp;dbg_req-&gt;bpt_data; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bpts[nadd + i].type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_EXEC: bpt_data-&gt;type = BPT_M68K_E; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_READ: bpt_data-&gt;type = BPT_M68K_R; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_WRITE: bpt_data-&gt;type = BPT_M68K_W; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> BPT_RDWR: bpt_data-&gt;type = BPT_M68K_RW; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } bpt_data-&gt;address = start; send_dbg_request(dbg_req, REQ_DEL_BREAK); bpts[nadd + i].code = BPT_OK; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (ndel + nadd); }</code> </pre> </div></div><br><h3 id="struktura-debugger_t">  debugger_t </h3><br><p>     ,     (,  ,  <code>IDA</code>    ,   ,   , ,   ). </p><br><p>    : </p><br><div class="spoiler"> <b class="spoiler_title"> debugger_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">debugger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-comment"><span class="hljs-comment">///&lt; Expected kernel version, ///&lt; should be #IDD_INTERFACE_VERSION const char *name; ///&lt; Short debugger name like win32 or linux int id; ///&lt; one of \ref DEBUGGER_ID_ /// \defgroup DEBUGGER_ID_ Debugger API module id /// Used by debugger_t::id //@{ #define DEBUGGER_ID_X86_IA32_WIN32_USER 0 ///&lt; Userland win32 processes (win32 debugging APIs) #define DEBUGGER_ID_X86_IA32_LINUX_USER 1 ///&lt; Userland linux processes (ptrace()) #define DEBUGGER_ID_ARM_WINCE_ASYNC 2 ///&lt; Windows CE ARM (ActiveSync transport) #define DEBUGGER_ID_X86_IA32_MACOSX_USER 3 ///&lt; Userland MAC OS X processes #define DEBUGGER_ID_ARM_EPOC_USER 4 ///&lt; Symbian OS #define DEBUGGER_ID_ARM_IPHONE_USER 5 ///&lt; iPhone 1.x #define DEBUGGER_ID_X86_IA32_BOCHS 6 ///&lt; BochsDbg.exe 32 #define DEBUGGER_ID_6811_EMULATOR 7 ///&lt; MC6812 emulator (beta) #define DEBUGGER_ID_GDB_USER 8 ///&lt; GDB remote #define DEBUGGER_ID_WINDBG 9 ///&lt; WinDBG using Microsoft Debug engine #define DEBUGGER_ID_X86_DOSBOX_EMULATOR 10 ///&lt; Dosbox MS-DOS emulator #define DEBUGGER_ID_ARM_LINUX_USER 11 ///&lt; Userland arm linux #define DEBUGGER_ID_TRACE_REPLAYER 12 ///&lt; Fake debugger to replay recorded traces #define DEBUGGER_ID_ARM_WINCE_TCPIP 13 ///&lt; Windows CE ARM (TPC/IP transport) #define DEBUGGER_ID_X86_PIN_TRACER 14 ///&lt; PIN Tracer module #define DEBUGGER_ID_DALVIK_USER 15 ///&lt; Dalvik //@} const char *processor; ///&lt; Required processor name. ///&lt; Used for instant debugging to load the correct ///&lt; processor module uint32 flags; ///&lt; \ref DBG_FLAG_ /// \defgroup DBG_FLAG_ Debugger module features /// Used by debugger_t::flags //@{ #define DBG_FLAG_REMOTE 0x00000001 ///&lt; Remote debugger (requires remote host name unless #DBG_FLAG_NOHOST) #define DBG_FLAG_NOHOST 0x00000002 ///&lt; Remote debugger with does not require network params (host/port/pass). ///&lt; (a unique device connected to the machine) #define DBG_FLAG_FAKE_ATTACH 0x00000004 ///&lt; ::PROCESS_ATTACH is a fake event ///&lt; and does not suspend the execution #define DBG_FLAG_HWDATBPT_ONE 0x00000008 ///&lt; Hardware data breakpoints are ///&lt; one byte size by default #define DBG_FLAG_CAN_CONT_BPT 0x00000010 ///&lt; Debugger knows to continue from a bpt. ///&lt; This flag also means that the debugger module ///&lt; hides breakpoints from ida upon read_memory #define DBG_FLAG_NEEDPORT 0x00000020 ///&lt; Remote debugger requires port number (to be used with DBG_FLAG_NOHOST) #define DBG_FLAG_DONT_DISTURB 0x00000040 ///&lt; Debugger can handle only ///&lt; get_debug_event(), ///&lt; prepare_to_pause_process(), ///&lt; exit_process(). ///&lt; when the debugged process is running. ///&lt; The kernel may also call service functions ///&lt; (file I/O, map_address, etc) #define DBG_FLAG_SAFE 0x00000080 ///&lt; The debugger is safe (probably because it just emulates the application ///&lt; without really running it) #define DBG_FLAG_CLEAN_EXIT 0x00000100 ///&lt; IDA must suspend the application and remove ///&lt; all breakpoints before terminating the application. ///&lt; Usually this is not required because the application memory ///&lt; disappears upon termination. #define DBG_FLAG_USE_SREGS 0x00000200 ///&lt; Take segment register values into account (non flat memory) #define DBG_FLAG_NOSTARTDIR 0x00000400 ///&lt; Debugger module doesn't use startup directory #define DBG_FLAG_NOPARAMETERS 0x00000800 ///&lt; Debugger module doesn't use commandline parameters #define DBG_FLAG_NOPASSWORD 0x00001000 ///&lt; Remote debugger doesn't use password #define DBG_FLAG_CONNSTRING 0x00002000 ///&lt; Display "Connection string" instead of "Hostname" and hide the "Port" field #define DBG_FLAG_SMALLBLKS 0x00004000 ///&lt; If set, IDA uses 256-byte blocks for caching memory contents. ///&lt; Otherwise, 1024-byte blocks are used #define DBG_FLAG_MANMEMINFO 0x00008000 ///&lt; If set, manual memory region manipulation commands ///&lt; will be available. Use this bit for debugger modules ///&lt; that can not return memory layout information #define DBG_FLAG_EXITSHOTOK 0x00010000 ///&lt; IDA may take a memory snapshot at ::PROCESS_EXIT event #define DBG_FLAG_VIRTHREADS 0x00020000 ///&lt; Thread IDs may be shuffled after each debug event. ///&lt; (to be used for virtual threads that represent cpus for windbg kmode) #define DBG_FLAG_LOWCNDS 0x00040000 ///&lt; Low level breakpoint conditions are supported. #define DBG_FLAG_DEBTHREAD 0x00080000 ///&lt; Supports creation of a separate thread in ida ///&lt; for the debugger (the debthread). ///&lt; Most debugger functions will be called from debthread (exceptions are marked below) ///&lt; The debugger module may directly call only #THREAD_SAFE functions. ///&lt; To call other functions please use execute_sync(). ///&lt; The debthread significantly increases debugging ///&lt; speed, especially if debug events occur frequently (to be tested) #define DBG_FLAG_DEBUG_DLL 0x00100000 ///&lt; Can debug standalone DLLs. ///&lt; For example, Bochs debugger can debug any snippet of code #define DBG_FLAG_FAKE_MEMORY 0x00200000 ///&lt; get_memory_info()/read_memory()/write_memory() work with the idb. ///&lt; (there is no real process to read from, as for the replayer module) ///&lt; the kernel will not call these functions if this flag is set. ///&lt; however, third party plugins may call them, they must be implemented. #define DBG_FLAG_ANYSIZE_HWBPT 0x00400000 ///&lt; The debugger supports arbitrary size hardware breakpoints. #define DBG_FLAG_TRACER_MODULE 0x00800000 ///&lt; The module is a tracer, not a full featured debugger module #define DBG_FLAG_PREFER_SWBPTS 0x01000000 ///&lt; Prefer to use software breakpoints //@} const char **register_classes; ///&lt; Array of register class names int register_classes_default; ///&lt; Mask of default printed register classes register_info_t *_registers; ///&lt; Array of registers. Use registers() to access it int registers_size; ///&lt; Number of registers int memory_page_size; ///&lt; Size of a memory page const uchar *bpt_bytes; ///&lt; Array of bytes for a breakpoint instruction uchar bpt_size; ///&lt; Size of this array uchar filetype; ///&lt; for miniidbs: use this value ///&lt; for the file type after attaching ///&lt; to a new process ushort resume_modes; ///&lt; \ref DBG_RESMOD_ /// \defgroup DBG_RESMOD_ Resume modes /// Used by debugger_t::resume_modes //@{ #define DBG_RESMOD_STEP_INTO 0x0001 ///&lt; ::RESMOD_INTO is available #define DBG_RESMOD_STEP_OVER 0x0002 ///&lt; ::RESMOD_OVER is available #define DBG_RESMOD_STEP_OUT 0x0004 ///&lt; ::RESMOD_OUT is available #define DBG_RESMOD_STEP_SRCINTO 0x0008 ///&lt; ::RESMOD_SRCINTO is available #define DBG_RESMOD_STEP_SRCOVER 0x0010 ///&lt; ::RESMOD_SRCOVER is available #define DBG_RESMOD_STEP_SRCOUT 0x0020 ///&lt; ::RESMOD_SRCOUT is available #define DBG_RESMOD_STEP_USER 0x0040 ///&lt; ::RESMOD_USER is available #define DBG_RESMOD_STEP_HANDLE 0x0080 ///&lt; ::RESMOD_HANDLE is available //@} #if !defined(_MSC_VER) // this compiler complains :( static const int default_port_number = 23946; #define DEBUGGER_PORT_NUMBER debugger_t::default_port_number #else #define DEBUGGER_PORT_NUMBER 23946 #endif /// Initialize debugger. /// This function is called from the main thread. /// \return success bool (idaapi *init_debugger)(const char *hostname, int portnum, const char *password); /// Terminate debugger. /// This function is called from the main thread. /// \return success bool (idaapi *term_debugger)(void); /// Return information about the running processes. /// This function is called from the main thread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *get_processes)(procinfo_vec_t *procs); /// Start an executable to debug. /// This function is called from debthread. /// \param path path to executable /// \param args arguments to pass to executable /// \param startdir current directory of new process /// \param dbg_proc_flags \ref DBG_PROC_ /// \param input_path path to database input file. /// (not always the same as 'path' - eg if you're analyzing /// a dll and want to launch an executable that loads it) /// \param input_file_crc32 CRC value for 'input_path' /// \retval 1 ok /// \retval 0 failed /// \retval -2 file not found (ask for process options) /// \retval 1 | #CRC32_MISMATCH ok, but the input file crc does not match /// \retval -1 network error int (idaapi *start_process)(const char *path, const char *args, const char *startdir, int dbg_proc_flags, const char *input_path, uint32 input_file_crc32); /// \defgroup DBG_PROC_ Debug process flags /// Passed as 'dbg_proc_flags' parameter to debugger_t::start_process //@{ #define DBG_PROC_IS_DLL 0x01 ///&lt; database contains a dll (not exe) #define DBG_PROC_IS_GUI 0x02 ///&lt; using gui version of ida #define DBG_PROC_32BIT 0x04 ///&lt; application is 32-bit #define DBG_PROC_64BIT 0x08 ///&lt; application is 64-bit #define DBG_NO_TRACE 0x10 ///&lt; do not trace the application (mac/linux) #define DBG_HIDE_WINDOW 0x20 ///&lt; application should be hidden on startup (windows) //@} #define CRC32_MISMATCH 0x40000000 ///&lt; crc32 mismatch bit (see return values for debugger_t::start_process) /// Attach to an existing running process. /// event_id should be equal to -1 if not attaching to a crashed process. /// This function is called from debthread. /// \param pid process id to attach /// \param event_id event to trigger upon attaching /// \param dbg_proc_flags \ref DBG_PROC_ /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *attach_process)(pid_t pid, int event_id, int dbg_proc_flags); /// Detach from the debugged process. /// May be called while the process is running or suspended. /// Must detach from the process in any case. /// The kernel will repeatedly call get_debug_event() and until ::PROCESS_DETACH. /// In this mode, all other events will be automatically handled and process will be resumed. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *detach_process)(void); /// Rebase database if the debugged program has been rebased by the system. /// This function is called from the main thread. void (idaapi *rebase_if_required_to)(ea_t new_base); /// Prepare to pause the process. /// Normally the next get_debug_event() will pause the process /// If the process is sleeping then the pause will not occur /// until the process wakes up. The interface should take care of /// this situation. /// If this function is absent, then it won't be possible to pause the program. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *prepare_to_pause_process)(void); /// Stop the process. /// May be called while the process is running or suspended. /// Must terminate the process in any case. /// The kernel will repeatedly call get_debug_event() and until ::PROCESS_EXIT. /// In this mode, all other events will be automatically handled and process will be resumed. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *exit_process)(void); /// Get a pending debug event and suspend the process. /// This function will be called regularly by IDA. /// This function is called from debthread. /// IMPORTANT: commdbg does not expect immediately after a BPT-related event /// any other event with the same thread/IP - this can cause erroneous /// restoring of a breakpoint before resume /// (the bug was encountered 24.02.2015 in pc_linux_upx.elf) gdecode_t (idaapi *get_debug_event)(debug_event_t *event, int timeout_ms); /// Continue after handling the event. /// This function is called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *continue_after_event)(const debug_event_t *event); /// Set exception handling. /// This function is called from debthread or the main thread. void (idaapi *set_exception_info)(const exception_info_t *info, int qty); /// This function will be called by the kernel each time /// it has stopped the debugger process and refreshed the database. /// The debugger module may add information to the database if it wants. /// /// The reason for introducing this function is that when an event line /// LOAD_DLL happens, the database does not reflect the memory state yet /// and therefore we can't add information about the dll into the database /// in the get_debug_event() function. /// Only when the kernel has adjusted the database we can do it. /// Example: for imported PE DLLs we will add the exported function /// names to the database. /// /// This function pointer may be absent, ie NULL. /// This function is called from the main thread. void (idaapi *stopped_at_debug_event)(bool dlls_added); /// \name Threads /// The following functions manipulate threads. /// These functions are called from debthread. /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error //@{ int (idaapi *thread_suspend) (thid_t tid); ///&lt; Suspend a running thread int (idaapi *thread_continue)(thid_t tid); ///&lt; Resume a suspended thread int (idaapi *set_resume_mode)(thid_t tid, resume_mode_t resmod); ///&lt; Specify resume action //@} /// Read thread registers. /// This function is called from debthread. /// \param tid thread id /// \param clsmask bitmask of register classes to read /// \param values pointer to vector of regvals for all registers. /// regval is assumed to have debugger_t::registers_size elements /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *read_registers)(thid_t tid, int clsmask, regval_t *values); /// Write one thread register. /// This function is called from debthread. /// \param tid thread id /// \param regidx register index /// \param value new value of the register /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *write_register)(thid_t tid, int regidx, const regval_t *value); /// Get information about the base of a segment register. /// Currently used by the IBM PC module to resolve references like fs:0. /// This function is called from debthread. /// \param answer pointer to the answer. can't be NULL. /// \param tid thread id /// \param sreg_value value of the segment register (returned by get_reg_val()) /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *thread_get_sreg_base)(ea_t *answer, thid_t tid, int sreg_value); /// \name Memory manipulation /// The following functions manipulate bytes in the memory. //@{ /// Get information on the memory ranges. /// The debugger module fills 'ranges'. The returned vector MUST be sorted. /// This function is called from debthread. /// \retval -3 use idb segmentation /// \retval -2 no changes /// \retval -1 the process does not exist anymore /// \retval 0 failed /// \retval 1 new memory layout is returned int (idaapi *get_memory_info)(meminfo_vec_t &amp;ranges); /// Read process memory. /// Returns number of read bytes. /// This function is called from debthread. /// \retval 0 read error /// \retval -1 process does not exist anymore ssize_t (idaapi *read_memory)(ea_t ea, void *buffer, size_t size); /// Write process memory. /// This function is called from debthread. /// \return number of written bytes, -1 if fatal error ssize_t (idaapi *write_memory)(ea_t ea, const void *buffer, size_t size); //@} /// Is it possible to set breakpoint?. /// This function is called from debthread or from the main thread if debthread /// is not running yet. /// It is called to verify hardware breakpoints. /// \return ref BPT_ int (idaapi *is_ok_bpt)(bpttype_t type, ea_t ea, int len); /// \defgroup BPT_ Breakpoint verification codes /// Return values for debugger_t::is_ok_bpt //@{ #define BPT_OK 0 ///&lt; breakpoint can be set #define BPT_INTERNAL_ERR 1 ///&lt; interr occurred when verifying breakpoint #define BPT_BAD_TYPE 2 ///&lt; bpt type is not supported #define BPT_BAD_ALIGN 3 ///&lt; alignment is invalid #define BPT_BAD_ADDR 4 ///&lt; ea is invalid #define BPT_BAD_LEN 5 ///&lt; bpt len is invalid #define BPT_TOO_MANY 6 ///&lt; reached max number of supported breakpoints #define BPT_READ_ERROR 7 ///&lt; failed to read memory at bpt ea #define BPT_WRITE_ERROR 8 ///&lt; failed to write memory at bpt ea #define BPT_SKIP 9 ///&lt; update_bpts(): do not process bpt #define BPT_PAGE_OK 10 ///&lt; update_bpts(): ok, added a page bpt //@} /// Add/del breakpoints. /// bpts array contains nadd bpts to add, followed by ndel bpts to del. /// This function is called from debthread. /// \return number of successfully modified bpts, -1 if network error int (idaapi *update_bpts)(update_bpt_info_t *bpts, int nadd, int ndel); /// Update low-level (server side) breakpoint conditions. /// This function is called from debthread. /// \return nlowcnds. -1-network error int (idaapi *update_lowcnds)(const lowcnd_t *lowcnds, int nlowcnds); /// \name Remote file /// Open/close/read a remote file. /// These functions are called from the main thread //@{ int (idaapi *open_file)(const char *file, uint64 *fsize, bool readonly); // -1-error void (idaapi *close_file)(int fn); ssize_t (idaapi *read_file)(int fn, qoff64_t off, void *buf, size_t size); //@} /// Map process address. /// This function may be absent. /// This function is called from debthread. /// \param off offset to map /// \param regs current register values. if regs == NULL, then perform /// global mapping, which is independent on used registers /// usually such a mapping is a trivial identity mapping /// \param regnum required mapping. maybe specified as a segment register number /// or a regular register number if the required mapping can be deduced /// from it. for example, esp implies that ss should be used. /// \return mapped address or #BADADDR ea_t (idaapi *map_address)(ea_t off, const regval_t *regs, int regnum); /// Set debugger options (parameters that are specific to the debugger module). /// See the definition of ::set_options_t for arguments. /// See the convenience function in dbg.hpp if you need to call it. /// The kernel will call this function after reading the debugger specific /// config file (arguments are: keyword="", type=#IDPOPT_STR, value="") /// This function is optional. /// This function is called from the main thread const char *(idaapi *set_dbg_options)( const char *keyword, int pri, int value_type, const void *value); /// Get pointer to debugger specific functions. /// This function returns a pointer to a structure that holds pointers to /// debugger module specific functions. For information on the structure /// layout, please check the corresponding debugger module. Most debugger /// modules return NULL because they do not have any extensions. Available /// extensions may be called from plugins. /// This function is called from the main thread. const void *(idaapi *get_debmod_extensions)(void); /// Calculate the call stack trace. /// This function is called when the process is suspended and should fill /// the 'trace' object with the information about the current call stack. /// If this function is missing or returns false, IDA will use the standard /// mechanism (based on the frame pointer chain) to calculate the stack trace /// This function is called from the main thread. /// \return success bool (idaapi *update_call_stack)(thid_t tid, call_stack_t *trace); /// Call application function. /// This function calls a function from the debugged application. /// This function is called from debthread /// \param func_ea address to call /// \param tid thread to use /// \param fti type information for the called function /// \param nargs number of actual arguments /// \param regargs information about register arguments /// \param stkargs memory blob to pass as stack arguments (usually contains pointed data) /// it must be relocated by the callback but not changed otherwise /// \param retregs function return registers. /// \param[out] errbuf the error message. if empty on failure, see 'event'. /// should not be filled if an appcall exception /// happened but #APPCALL_DEBEV is set /// \param[out] event the last debug event that occurred during appcall execution /// filled only if the appcall execution fails and #APPCALL_DEBEV is set /// \param options appcall options, usually taken from \inf{appcall_options}. /// possible values: combination of \ref APPCALL_ or 0 /// \return ea of stkargs blob, #BADADDR if failed and errbuf is filled ea_t (idaapi *appcall)( ea_t func_ea, thid_t tid, const struct func_type_data_t *fti, int nargs, const struct regobjs_t *regargs, struct relobj_t *stkargs, struct regobjs_t *retregs, qstring *errbuf, debug_event_t *event, int options); /// \defgroup APPCALL_ Appcall options /// Passed as 'options' parameter to debugger_t::appcall //@{ #define APPCALL_MANUAL 0x0001 ///&lt; Only set up the appcall, do not run. ///&lt; debugger_t::cleanup_appcall will not be called by ida! #define APPCALL_DEBEV 0x0002 ///&lt; Return debug event information #define APPCALL_TIMEOUT 0x0004 ///&lt; Appcall with timeout. ///&lt; If timed out, errbuf will contain "timeout". ///&lt; See #SET_APPCALL_TIMEOUT and #GET_APPCALL_TIMEOUT //@} /// Cleanup after appcall(). /// The debugger module must keep the stack blob in the memory until this function /// is called. It will be called by the kernel for each successful appcall(). /// There is an exception: if #APPCALL_MANUAL, IDA may not call cleanup_appcall. /// If the user selects to terminate a manual appcall, then cleanup_appcall will be called. /// Otherwise, the debugger module should terminate the appcall when the called /// function returns. /// This function is called from debthread. /// \retval 2 ok, there are pending events /// \retval 1 ok /// \retval 0 failed /// \retval -1 network error int (idaapi *cleanup_appcall)(thid_t tid); /// Evaluate a low level breakpoint condition at 'ea'. /// Other evaluation errors are displayed in a dialog box. /// This call is rarely used by IDA when the process has already been suspended /// for some reason and it has to decide whether the process should be resumed /// or definitely suspended because of a breakpoint with a low level condition. /// This function is called from debthread. /// \retval 1 condition is satisfied /// \retval 0 not satisfied /// \retval -1 network error int (idaapi *eval_lowcnd)(thid_t tid, ea_t ea); /// This function is called from main thread ssize_t (idaapi *write_file)(int fn, qoff64_t off, const void *buf, size_t size); /// Perform a debugger-specific function. /// This function is called from debthread int (idaapi *send_ioctl)(int fn, const void *buf, size_t size, void **poutbuf, ssize_t *poutsize); /// Enable/Disable tracing. /// "trace_flags" can be a set of STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE. /// See thread_t::trace_mode in debugger.h. /// This function is called from the main thread. bool (idaapi *dbg_enable_trace)(thid_t tid, bool enable, int trace_flags); /// Is tracing enabled? ONLY used for tracers. /// "trace_bit" can be one of the following: STEP_TRACE, INSN_TRACE, BBLK_TRACE or FUNC_TRACE bool (idaapi *is_tracing_enabled)(thid_t tid, int tracebit); /// Execute a command on the remote computer. /// \return exit code int (idaapi *rexec)(const char *cmdline); /// Get (store to out_pattrs) process/debugger-specific runtime attributes. /// This function is called from main thread. void (idaapi *get_debapp_attrs)(debapp_attrs_t *out_pattrs); /// Get the path to a file containing source debug info for the given module. /// This allows srcinfo providers to call into the debugger when looking for debug info. /// It is useful in certain cases like the iOS debugger, which is a remote debugger but /// the remote debugserver does not provide dwarf info. So, we allow the debugger client /// to decide where to look for debug info locally. /// \param path output path (file might not exist) /// \param base base address of a module in the target process /// \return success, result stored in 'path' bool (idaapi *get_srcinfo_path)(qstring *path, ea_t base); };</span></span></code> </pre> </div></div><br><p>       ,   , ,    . </p><br><h3 id="a-otladchik-ved-tozhe-plagin">      </h3><br><p> , .      <code>ida_plugin.cpp</code> .  ,     . </p><br><h4 id="funkciya-idp_to_dbg_reg">  idp_to_dbg_reg() </h4><br><p>           (  <a href="https://habr.com/company/pt/blog/424263/"> </a> )   . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idp_to_dbg_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idp_reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reg_idx = idp_reg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; idp_reg &lt;= <span class="hljs-number"><span class="hljs-number">7</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">0</span></span> + idp_reg; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> &amp;&amp; idp_reg &lt;= <span class="hljs-number"><span class="hljs-number">39</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">8</span></span> + (idp_reg % <span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg == <span class="hljs-number"><span class="hljs-number">91</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg == <span class="hljs-number"><span class="hljs-number">92</span></span> || idp_reg == <span class="hljs-number"><span class="hljs-number">93</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">17</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idp_reg == <span class="hljs-number"><span class="hljs-number">94</span></span>) reg_idx = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[MAXSTR]; ::qsnprintf(buf, MAXSTR, <span class="hljs-string"><span class="hljs-string">"reg: %d\n"</span></span>, idp_reg); warning(<span class="hljs-string"><span class="hljs-string">"SEND THIS MESSAGE TO you@mail.com:\n%s\n"</span></span>, buf); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reg_idx; }</code> </pre> <br><h4 id="funkciya-hook_idp">  hook_idp() </h4><br><p>     <code>hook_to_notification_point()</code> : </p><br><pre> <code class="cpp hljs">hook_to_notification_point(HT_IDP, hook_idp, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br><p>   <code>unhook_from_notification_point()</code> : </p><br><pre> <code class="cpp hljs">unhook_from_notification_point(HT_IDP, hook_idp);</code> </pre> <br><p>       : <em>debugger hints</em> .     "": </p><br><p><img src="https://habrastorage.org/webt/qs/al/rr/qsalrrtxwyil4zzbcen_k1okmtw.png"></p><br><p> ,    ,      -      ,    .       ,  ,      <code>IDA</code> ,  .   . </p><br><p>            <code>notification_code</code>   <code>ev_get_idd_opinfo</code> .      ,   ,          , , ,           . </p><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">processor_t</span></span>::ev_get_idd_opinfo: { <span class="hljs-keyword"><span class="hljs-keyword">idd_opinfo_t</span></span> * opinf = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">idd_opinfo_t</span></span> *); <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span> ea = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">ea_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> thread_id = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">getreg_func_t</span></span> getreg = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">getreg_func_t</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">regval_t</span></span> *regvalues = va_arg(va, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">regval_t</span></span> *); opinf-&gt;ea = BADADDR; opinf-&gt;debregidx = <span class="hljs-number"><span class="hljs-number">0</span></span>; opinf-&gt;modified = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; opinf-&gt;value.ival = <span class="hljs-number"><span class="hljs-number">0</span></span>; opinf-&gt;value_size = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">insn_t</span></span> out; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (decode_insn(&amp;out, ea)) { <span class="hljs-keyword"><span class="hljs-keyword">op_t</span></span> op = out.ops[n]; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _DEBUG print_insn(&amp;out); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> int size = 0; switch (op.dtype) { case dt_byte: size = 1; break; case dt_word: size = 2; break; default: size = 4; break; } opinf-&gt;value_size = size; switch (op.type) { case o_mem: case o_near: case o_imm: { flags_t flags; switch (n) { case 0: flags = get_optype_flags0(get_flags(ea)); break; case 1: flags = get_optype_flags1(get_flags(ea)); break; default: flags = 0; break; } switch (op.type) { case o_mem: case o_near: opinf-&gt;ea = op.addr; break; case o_imm: opinf-&gt;ea = op.value; break; } opinfo_t info; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (get_opinfo(&amp;info, ea, n, flags) != NULL) { opinf-&gt;ea += info.ri.base; } } break; case o_phrase: case o_reg: { int reg_idx = idp_to_dbg_reg(op.reg); regval_t reg = getreg(dbg-&gt;registers(reg_idx).name, regvalues); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (op.phrase &gt;= 0x10 &amp;&amp; op.phrase </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;= 0x1F || // (A0)..(A7), (A0)+..(A7)+ op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) // -(A0)..-(A7) { if (op.phrase &gt;= 0x20 &amp;&amp; op.phrase &lt;= 0x27) reg.ival -= size; opinf-&gt;ea = (ea_t)reg.ival; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory((ea_t)reg.ival, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } else opinf-&gt;value = reg; opinf-&gt;debregidx = reg_idx; } break; case o_displ: { regval_t main_reg, add_reg; int main_reg_idx = idp_to_dbg_reg(op.reg); int add_reg_idx = idp_to_dbg_reg(op.specflag1 &amp; 0xF); main_reg.ival = 0; add_reg.ival = 0; if (op.specflag2 &amp; 0x10) { add_reg = getreg(dbg-&gt;registers(add_reg_idx).name, regvalues); if (op.specflag1 &amp; 0x10) { add_reg.ival &amp;= 0xFFFF; add_reg.ival = (uint64)((int16_t)add_reg.ival); } } if (main_reg_idx != 16) main_reg = getreg(dbg-&gt;registers(main_reg_idx).name, regvalues); ea_t addr = (ea_t)main_reg.ival + op.addr + (ea_t)add_reg.ival; opinf-&gt;ea = addr; switch (size) { case 1: { uint8_t b = 0; dbg-&gt;read_memory(addr, &amp;b, 1); opinf-&gt;value.ival = b; } break; case 2: { uint16_t w = 0; dbg-&gt;read_memory(addr, &amp;w, 2); w = swap16(w); opinf-&gt;value.ival = w; } break; default: { uint32_t l = 0; dbg-&gt;read_memory(addr, &amp;l, 4); l = swap32(l); opinf-&gt;value.ival = l; } break; } } break; } opinf-&gt;ea &amp;= 0xFFFFFF; return 1; } } break;</span></span></span></span></code> </pre> </div></div><br><p> ,       . </p><br><h4 id="init"> init() </h4><br><p>       ,     . <br>      ,     <code>id</code>   <code>ph</code> . </p><br><p>        <code>PLFM_68K</code> .       <code>dbg</code>       <code>debugger_t</code> . </p><br><p>   <code>HT_IDP</code> ,   <code>PLUGIN_KEEP</code> . ,        ,  <code>PLUGIN_SKIP</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ph.id == PLFM_68K) { dbg = &amp;debugger; plugin_inited = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; my_dbg = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; hook_to_notification_point(HT_IDP, hook_idp, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); print_version(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PLUGIN_KEEP; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PLUGIN_SKIP; }</code> </pre> <br><h4 id="term"> term() </h4><br><p>    <code>IDB</code> -.      ,     <code>init()</code> . </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> idaapi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (plugin_inited) { unhook_from_notification_point(HT_IDP, hook_idp); plugin_inited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br><h4 id="run"> run() </h4><br><p>  -    .  <code>false</code> . </p><br><h3 id="struktura-plugin_t">  plugin_t </h3><br><p>   :  , ,  ,  ,  : </p><br><div class="spoiler"> <b class="spoiler_title"> plugin_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">plugin_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version; <span class="hljs-comment"><span class="hljs-comment">///&lt; Should be equal to #IDP_INTERFACE_VERSION int flags; ///&lt; \ref PLUGIN_ /// \defgroup PLUGIN_ Plugin features /// Used by plugin_t::flags //@{ #define PLUGIN_MOD 0x0001 ///&lt; Plugin changes the database. ///&lt; IDA won't call the plugin if ///&lt; the processor module prohibited any changes. #define PLUGIN_DRAW 0x0002 ///&lt; IDA should redraw everything after calling the plugin. #define PLUGIN_SEG 0x0004 ///&lt; Plugin may be applied only if the current address belongs to a segment #define PLUGIN_UNL 0x0008 ///&lt; Unload the plugin immediately after calling 'run'. ///&lt; This flag may be set anytime. ///&lt; The kernel checks it after each call to 'run' ///&lt; The main purpose of this flag is to ease ///&lt; the debugging of new plugins. #define PLUGIN_HIDE 0x0010 ///&lt; Plugin should not appear in the Edit, Plugins menu. ///&lt; This flag is checked at the start. #define PLUGIN_DBG 0x0020 ///&lt; A debugger plugin. init() should put ///&lt; the address of ::debugger_t to dbg. #define PLUGIN_PROC 0x0040 ///&lt; Load plugin when a processor module is loaded. (and keep it ///&lt; until the processor module is unloaded) #define PLUGIN_FIX 0x0080 ///&lt; Load plugin when IDA starts and keep it in the memory until IDA stops #define PLUGIN_SCRIPTED 0x8000 ///&lt; Scripted plugin. Should not be used by plugins, ///&lt; the kernel sets it automatically. //@} int (idaapi *init)(void); ///&lt; Initialize plugin - returns \ref PLUGIN_INIT /// \defgroup PLUGIN_INIT Plugin initialization codes /// Return values for plugin_t::init() //@{ #define PLUGIN_SKIP 0 ///&lt; Plugin doesn't want to be loaded #define PLUGIN_OK 1 ///&lt; Plugin agrees to work with the current database. ///&lt; It will be loaded as soon as the user presses the hotkey #define PLUGIN_KEEP 2 ///&lt; Plugin agrees to work with the current database and wants to stay in the memory //@} void (idaapi *term)(void); ///&lt; Terminate plugin. This function will be called ///&lt; when the plugin is unloaded. May be NULL. bool (idaapi *run)(size_t arg); ///&lt; Invoke plugin const char *comment; ///&lt; Long comment about the plugin. ///&lt; it could appear in the status line ///&lt; or as a hint const char *help; ///&lt; Multiline help about the plugin const char *wanted_name; ///&lt; The preferred short name of the plugin const char *wanted_hotkey; ///&lt; The preferred hotkey to run the plugin };</span></span></code> </pre> </div></div><br><p>  , , . ,  ,          .  ,      <code>IDA</code>    ,     . </p><br><p>   ,   : <br> <a href="https://github.com/lab313ru/gpgx_debugger">GPGX Debugger</a> <br> <a href="https://github.com/lab313ru/smd_ida_tools">Smd IDA Tools</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/435002/">https://habr.com/ru/post/435002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../434990/index.html">Using the Cisco 800 Series (for example Cisco 857) as a home router</a></li>
<li><a href="../434992/index.html">IDA Pro Upgrade. Debugger for Sega Mega Drive (part 1)</a></li>
<li><a href="../434994/index.html">Android: Creating Dynamic Product Flavors and Signing Configs</a></li>
<li><a href="../434996/index.html">How I shared the location through the VC API</a></li>
<li><a href="../435000/index.html">The concept of the interaction of advertising channels and its application in practice</a></li>
<li><a href="../435006/index.html">Where and how do nuclear reactors do</a></li>
<li><a href="../435008/index.html">Preliminary data on the production and sale of Tesla electric vehicles for the 4th quarter and for the 2018th year</a></li>
<li><a href="../435010/index.html">Digital Lyrics: Mega-compilation of songs and clips about programming and programmers</a></li>
<li><a href="../435012/index.html">The first video game for Alice, or voice assistant as a game controller</a></li>
<li><a href="../435014/index.html">Dart vs Node.js: compare performance on HTTP server implementations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>