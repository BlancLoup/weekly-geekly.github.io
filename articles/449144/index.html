<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript engine basics: prototype optimization. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon friends! The course ‚ÄúSecurity of Information Systems‚Äù has been launched; in connection with this, we are sharing with you the final par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript engine basics: prototype optimization. Part 2</h1><div class="post__text post__text-html js-mediator-article">  Good afternoon friends!  The course <a href="https://otus.pw/Xq2Q/">‚ÄúSecurity of Information Systems‚Äù has been</a> launched; in connection with this, we are sharing with you the final part of the article ‚ÄúBasics of JavaScript engines: prototype optimization‚Äù, the first part of which can be found <a href="https://habr.com/ru/company/otus/blog/447870/">here</a> . <br><br>  We also remind that the current publication is a continuation of these two articles: <a href="https://habr.com/ru/company/otus/blog/446446/">‚ÄúBasics of JavaScript engines: common forms and Inline caching.</a>  <a href="https://habr.com/ru/company/otus/blog/446446/">Part 1</a> , <a href="https://habr.com/ru/company/otus/blog/447220/">Basics of JavaScript engines: common forms and inline caching.</a>  <a href="https://habr.com/ru/company/otus/blog/447220/">Part 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Classes and Prototype Programming</b> <br><br>  Now that we know how to get quick access to the properties of JavaScript objects, we can take a look at the more complex structure of JavaScript classes.  This is what the JavaScript class syntax looks like: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Although it seems to be a relatively new concept for JavaScript, it‚Äôs just ‚Äúsyntactic sugar‚Äù for prototype programming that has always been used in JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Here we assign the <code>getX</code> property to the <code>getX</code> object.  This will work the same as with any other object, since prototypes in JavaScript are the same objects.  In prototype programming languages, such as JavaScript, methods are accessed through prototypes, while fields are stored in specific instances. <br><br>  Let's take a closer look at what happens when we create a new instance of <code>Bar</code> , which we call <code>foo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  The instance created using this code has a form with a single property <code>'x'</code> .  The prototype of <code>foo</code> is <code>Bar.prototype</code> , which belongs to the class <code>Bar</code> . <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  This <code>Bar.prototype</code> has the form of itself, containing the only property <code>'getX'</code> , whose value is determined by the function <code>'getX'</code> , which when called returns <code>this.x</code>  The prototype <code>Bar.prototype</code> is the <code>Object.prototype</code> , which is part of the JavaScript language.  <code>Object.prototype</code> is the root of the prototype tree, whereas its prototype is <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  When you create a new instance of the same class, both instances have the same form, as we already understood earlier.  Both instances will point to the same <code>Bar.prototype</code> object. <br><br>  <b>Access to prototype properties</b> <br><br>  Well, now we know what happens when we define a class and create a new instance.  But what happens if we call a method on an instance, as we did in the following example? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  You can view any method call as two separate steps: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  The first step is to load the method, which is actually a property of the prototype (whose value is a function).  The second step is a function call with an instance, for example, the value of <code>this</code> .  Let's take a closer look at the first step, in which the <code>getX</code> method is <code>getX</code> from the <code>foo</code> instance. <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  The engine runs an instance of <code>foo</code> and understands that the form <code>foo</code> does not have any property <code>'getX'</code> , so it has to go through a prototype chain to find it.  We get to <code>Bar.prototype</code> , we look at the prototype form, we see that it has the property <code>'getX'</code> at zero offset.  We look for the value at this offset in <code>Bar.prototype</code> and find the <code>JSFunction getX</code> we were looking for. <br><br>  JavaScript flexibility allows the links of the prototype chain to change, for example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true Object.setPrototypeOf(foo, null); foo.getX(); // ‚Üí Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  In this example, we call <pre> <code class="javascript hljs">foo.getX()</code> </pre>  twice, but each time it has completely different meanings and results.  That is why, despite the fact that prototypes are just objects in JavaScript, speeding up access to prototype properties is even more important task for JavaScript engines than speeding up access to properties for regular objects. <br><br>  In everyday practice, loading prototype properties is quite a frequent operation: this happens every time you call a method! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Earlier we talked about how engines optimize the loading of regular (regular), own properties by using forms and inline caches.  How can I optimize the loading of prototype properties for objects of the same form?  From above, we have seen how properties are loaded. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  In order to do this quickly with repeated downloads in this particular case, you need to know the following three things: <br><br><ul><li>  The form <code>foo</code> does not contain <code>'getX'</code> and it has not changed.  This means that no one has changed the foo object by adding or removing a property or changing one of the attributes of a property. </li><li>  The prototype of foo is still the original <code>Bar.prototype</code> .  So no one changed the prototype of <code>foo</code> using <code>Object.setPrototypeOf()</code> or assigning it to a special <code>_proto_</code> property. </li><li>  The form <code>Bar.prototype</code> contains <code>'getX'</code> and has not changed.  This means that no one has changed <code>Bar.prototype</code> by adding or removing a property or changing one of the attributes of a property. </li></ul><br>  In general, this means that you need to make one check of the instance itself and two more checks for each prototype, up to the prototype that contains the desired property.  1 + 2N checks, where N is the number of prototypes used, does not sound so bad in this case, since the prototype chain is relatively shallow.  However, engines often have to deal with much longer chains of prototypes, as is the case with regular DOM classes.  For example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  We have <code>HTMLAnchorElement</code> and we call the <code>getAttribute()</code> method.  The chain for this element already includes 6 prototypes!  Most of the interesting DOM methods are not in the prototype of <code>HTMLAnchorElement</code> , but somewhere upstream. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  The <code>getAttribute()</code> method is in the <code>Element.prototype</code> .  This means that every time we call <code>anchor.getAttribute()</code> , the JavaScript engine needs to: <br><br><ol><li>  Check that <code>'getAttribute'</code> not an <code>anchor</code> object itself; </li><li>  Check that the final prototype is <code>HTMLAnchorElement.prototype</code> ; </li><li>  Confirm the absence of <code>'getAttribute'</code> there; </li><li>  Check that the next prototype is <code>HTMLElement.prototype</code> ; </li><li>  Confirm the absence of <code>'getAttribute'</code> ; </li><li>  Check that the next prototype is <code>Element.prototype</code> ; </li><li>  Check that <code>'getAttribute'</code> present. </li></ol><br>  Total 7 checks obtained.  Since this type of code is quite common on the web, the engines use various tricks to reduce the number of checks needed to load prototype properties. <br><br>  Returning to an earlier example in which we did only three checks when we requested <code>'getX'</code> for <code>foo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  For each object that occurs before the prototype containing the desired property, it is necessary to check the forms for the absence of this property.  It would be nice if we could reduce the number of checks by presenting a prototype check as a check for the absence of a property.  In fact, this is exactly what the engines do with simple tricks: instead of storing the prototype link to the instance itself, the engines keep it in shape. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Each form indicates a prototype.  This means that each time the <code>foo</code> prototype changes, the engine moves to a new form.  Now we need to check only the shape of the object to confirm the absence of certain properties, as well as to protect the prototype link (guard the prototype link). <br><br>  With this approach, we can reduce the number of required checks from 2N + 1 to 1 + N to speed up access.  This is still a fairly expensive operation, since it is still a linear function of the number of prototypes in the circuit.  The engines use various tricks to further reduce the number of checks to a certain constant value, especially in the case of sequential loading of the same properties. <br><br>  <b>Valid cells</b> <br><br>  V8 handles prototype forms specifically for this purpose.  Each prototype has a unique form that is not used in conjunction with other objects (in particular, with other prototypes), and each of these prototype forms has a special <code>ValidityCell</code> , which is associated with it. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  This <code>ValidityCell</code> invalidated every time when someone changes the prototype associated with it or any other prototype above it.  Let's see how it works. <br>  To speed up subsequent downloads from prototypes, the V8 places the inline cache in place with four fields: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  When the inline cache is heated when the code is first run, V8 remembers the offset by which the property was found in the prototype, this prototype (for example, <code>Bar.prototype</code> ), the instance form (in our case, the form <code>foo</code> ), and also binds the current <code>ValidityCell</code> to the prototype obtained from the form instance (in our case <code>Bar.prototype</code> is taken). <br><br>  The next time the Inline cache is used, the engine needs to check the instance form and <code>ValidityCell</code> .  If it is still valid, the engine directly uses the offset on the prototype, skipping the extra search steps. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  When the prototype changes, a new form is highlighted, and the previous <code>ValidityCell</code> cell is disabled.  Because of this, the inline cache is skipped the next time it starts up, resulting in poor performance. <br><br>  Let's go back to the DOM example.  Every change in <code>Object.prototype</code> not only invalidates Inline caches for <code>Object.prototype</code> , but also for any prototype in the chain under it, including <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., to the <code>HTMLAnchorElement.prototype</code> itself. <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  In fact, modifying the <code>Object.prototype</code> for as long as the code runs is a terrible loss of performance.  Do not do this! <br><br>  Let's look at a specific example to better understand how this works.  Let's say we have a class <code>Bar</code> and a function <code>loadX</code> , which calls a method on objects of type <code>Bar</code> .  We call the <code>loadX</code> function several times with instances of the same class. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  The inline cache in <code>loadX</code> now pointing to <code>ValidityCell</code> for <code>Bar.prototype</code> .  If you then change (mutate) <code>Object.prototype</code> , which is the root of all the prototypes in JavaScript, <code>ValidityCell</code> becomes invalid and existing Inline caches will not be used next time, which leads to poor performance. <br><br>  Changing <code>Object.prototype</code> is always a bad idea, as it invalidates any inline caches for loaded prototypes at the time of the change.  Here is an example of how NOT to do: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  We are expanding <code>Object.prototype</code> , which invalidates all Inline prototype caches loaded by the engine at this point.  Then we run some code that uses the method we described.  The engine will have to start from the very beginning and configure inline caches for any access to the prototype property.  And then, finally, ‚Äútidying up after ourselves‚Äù and removing the method of the prototype, which we added earlier. <br><br>  You think cleaning is a good idea, isn't it?  Well, in this case, it will further worsen the situation!  Deleting properties changes the <code>Object.prototype</code> , so that all Inline caches are again invalidated, and the engine has to start work from the very beginning again. <br><br>  <b>To summarize</b> .  Despite the fact that prototypes are just objects, they are specially processed by JavaScript engines in order to optimize the performance of searching methods by prototypes.  <b>Leave the prototypes alone!</b>  Or, if you really need to deal with them, do it before executing the code, so at least you do not invalidate all attempts to optimize your code in the process of its execution! <br><br><blockquote>  <b>Summarize</b> <br><br>  We learned how JavaScript stores objects and classes, and how forms, inline caches, and validity cells help optimize operations with prototypes.  Based on this knowledge, we realized how to improve performance from a practical point of view: do not touch the prototypes!  (or if you really need it, do it before executing the code). </blockquote><br>  ‚Üê <a href="https://habr.com/ru/company/otus/blog/447870/">First part</a> <br><br>  Was this publication series helpful to you?  Write in the comments. </div><p>Source: <a href="https://habr.com/ru/post/449144/">https://habr.com/ru/post/449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449124/index.html">So hard to find, easy to miss and impossible to issue.</a></li>
<li><a href="../449132/index.html">Top 17 plug-ins for Android Studio</a></li>
<li><a href="../449138/index.html">5 reasons for crypto heyta. Why IT people dislike bitcoin</a></li>
<li><a href="../44914/index.html">19 inventions that make life easier ... or not</a></li>
<li><a href="../449142/index.html">Microbiota What bacteria live in the intestines of Russians</a></li>
<li><a href="../449148/index.html">Art children's books about sotsinzhiniring</a></li>
<li><a href="../44915/index.html">And what is it?</a></li>
<li><a href="../449154/index.html">FAQ on mandatory labeling of shoes: Everything that you did not know and were afraid to ask</a></li>
<li><a href="../449158/index.html">Rough Koster: Community Cookbook</a></li>
<li><a href="../449162/index.html">C ++ Russia 2019. A small report from the scene and the announcement of the next conference in St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>