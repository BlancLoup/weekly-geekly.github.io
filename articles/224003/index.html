<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Order-Independent Transparency algorithm using link lists on Direct3D 11 and OpenGL 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The implementation of order-independent transparency (OIT) can probably be considered a classic computer graphics programming task. In fact, the OIT a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Order-Independent Transparency algorithm using link lists on Direct3D 11 and OpenGL 4</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fac/585/379/fac585379c0b651029eb171d603497c9.png" alt="image" align="right">  The implementation of <a href="http://en.wikipedia.org/wiki/Order-independent_transparency">order-independent transparency</a> (OIT) can probably be considered a classic computer graphics programming task.  In fact, the OIT algorithms solve one simple application problem - how to draw a set of translucent objects so as not to worry about the order of their drawing.  The rules for mixing colors during rendering require us to have translucent objects drawn in order from far to near, but this is difficult to achieve in the case of extended objects or objects of complex shape.  The implementation of one of the most advanced algorithms, OIT using linked lists, <a href="http://developer.amd.com/wordpress/media/2012/10/OIT%2520and%2520Indirect%2520Illumination%2520using%2520DX11%2520Linked%2520Lists_forweb.ppsx">was presented by AMD</a> for Direct3D 11 back in 2010.  Frankly, the performance of the algorithm on the widely available graphics cards of those years did not impress me properly.  4 years have passed, I dug up the AMD presentation and decided to implement the algorithm not only on Direct3D 11, but also on OpenGL 4.3.  Those to whom it is interesting that it turned out from this invention, I ask under kat. <br><a name="habracut"></a><br>  Before you start talking about the implementation of the algorithm itself, I note that the demo is available to a wide audience <a href="https://github.com/rokuz/GraphicsDemo">here</a> .  The project is called Demo_OIT.  You will need Visual Studio 2012/2013 and <a href="http://www.cmake.org/">CMake</a> to build.  Useful terminology is provided at the end of the post. <br><br><h4>  Overview of OIT Algorithms </h4><br>  Rendering of translucent objects has a number of features: <br><ol><li>  When rendering opaque objects, faces that are not visible to the observer are usually discarded.  This allows you to save on rasterization and processing fragments.  In the case of translucent objects, reverse faces cannot be dropped; </li><li>  The depth test should not be conducted among semi-transparent objects, since some semi-transparent objects can be seen through others.  However, the depth of the opaque part of the scene must be taken into account, since an opaque object may partially or completely overlap the translucent; </li><li>  It is necessary to draw translucent objects in order from the far to the near.  This is dictated by the rules of mixing colors by alpha channel (alpha blending).  As already noted, the OIT algorithms can get rid of this limitation. </li></ol><br>  The generalized OIT algorithm can be represented as follows: <br><ol><li>  Draw opaque objects of the scene, save the depth buffer; </li><li>  For each fragment of a translucent object, using the depth buffer obtained in step 1, determine whether it is necessary to draw this fragment; </li><li>  For each displayed translucent fragment, keep its color, depth and position on the screen; </li><li>  For translucent fragments, sort by the depth value from the far to the nearest; </li><li>  Draw translucent fragments in the resulting order, mixing their colors according to the value of the alpha channel. </li></ol><br>  The main difficulty here are items 3 and 4, namely, how to get fragments with different depths, where to save and how to sort. <br><ul><li>  The <a href="http://steps3d.narod.ru/tutorials/depth-peel-tutorial.html">Depth Peeling algorithm</a> (and its variations <a href="http://orenk2k.blogspot.ru/2010/10/oit-order-independent-transparency-3.html">Reverse Depth Peeling</a> , <a href="http://developer.download.nvidia.com/SDK/10/opengl/src/dual_depth_peeling/doc/DualDepthPeeling.pdf">Dual Depth Peeling</a> , etc.) allows you to get a scene by layers.  In the first layer, the fragments closest to the observer are stored, in the second layer - the second closest ones, etc.  In the classical implementation, each layer has its own texture, and the translucent part of the scene is drawn as many times as necessary layers.  Sorting fragments explicitly does not need enough to mix layers from the far to the near.  The disadvantages of the algorithm include the repeated drawing of the scene, the need to store the texture for each layer (not for all variations of the algorithm, this is true), a selection of many textures when mixing colors.  The advantage of the algorithm is that it can be implemented even on Direct3D 9. </li><li>  The Stencil Routed A-Buffer algorithm assumes the storage of scene layers in an MSAA texture.  This algorithm is faster, eliminates the need for multiple drawing of translucent objects, but it deprives us of the built-in anti-aliasing.  In addition, the number of MSAA levels is limited (up to 8x-16x on most modern equipment), and therefore the number of layers is limited.  I once implemented this algorithm, the details, if interesting, <a href="http://www.uraldev.ru/articles/40">here</a> . </li><li>  The OIT using Linked Lists algorithm, to which this post is dedicated, is devoid of the drawbacks of the above described algorithms.  Here, the translucent part of the scene is drawn once, MSAA support is possible.  The implementation of the algorithm on Direct3D 11 using compute shaders without MSAA support can be found <a href="http://www.uraldev.ru/articles/36">here</a> , there is also a slightly more detailed description of the algorithm. </li></ul><br><br><h4>  Implement the Order-Independent Transparency using Linked Lists algorithm </h4><br>  To begin with, I define the requirements for implementation: <br><ol><li>  The algorithm works on Direct3D 11 and OpenGL 4.3; </li><li>  The algorithm does not use compute shaders.  Quite a fragmentary shader; </li><li>  The algorithm supports MSAA. </li></ol><br>  The main essence of the algorithm is as follows: for each displayed semi-transparent fragment, we form a coherent list of fragments, which are located in the same position on the screen.  To form such a set of linked lists allows the possibility of modern graphic equipment to conduct an arbitrary record in a dedicated memory block directly from the shaders.  Having such linked lists for each translucent fragment, you can sort the fragments by depth and then mix the colors in the correct order. <br>  To implement the algorithm, we need: <br><ol><li>  An integer format (unsigned int) that is the same size as the screen for storing head elements of linked lists; </li><li>  Buffer in memory for storing linked list items.  The minimum content of a linked list element includes the fragment color, depth, and a link to the next element (the address in the buffer); </li><li>  The counter of translucent fragments in order to determine the nearest free element in the buffer. </li></ol><br>  For a better understanding of the principle of operation, consider the following figure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/98f/d7a/28e/98fd7a28e6afb065ca3156786ac603a4.png"><br><br>  In the figure we see the texture for storing the head elements of the list, in which the addresses of the corresponding fragments in the buffer are stored, and the buffer itself.  Places where there are no translucent fragments contain -1.  If several translucent fragments had to be in one position on the screen, a list is formed (the fragment with index 0 contains a link to the fragment with index 2).  The count of fragments in this situation is 5, i.e.  the next fragment will be written to the buffer at address 5, and the counter is incremented. <br>  At first glance it seems that everything is simple, let's move on to the implementation details. <br><br><h5>  Implementation on Direct3D 11 </h5><br>  To implement this algorithm on Direct3D 11, we need the so-called Unordered-Access resources: a texture ( <i>RWTexture2D</i> ) and a structured buffer ( <i>RWStructuredBuffer</i> ).  The peculiarity of these resources is that they are read and written in shaders.  For them, there is a special set of commands in the Direct3D API, for example, to associate UA resources with variables in shaders, use the <i>OMSetRenderTargetsAndUnorderedAccessViews</i> method.  This method is not mentioned randomly.  The organization of Direct3D 11 is such that UA resources compete with render targets when they form a bundle with pixel shaders, i.e.  if the equipment provides MRT in 8 textures, and 2 slots occupy the render target, then no more than 6 slots remain for UA resources.  Work with UA-resources should be done using atomic operations, due to the highly parallel architecture of the GPU. <br>  The fragment count will be implemented using the <i>D3D11_BUFFER_UAV_FLAG_COUNTER</i> flag for the structured buffer.  Direct3D 11 allows you to attach an atomic counter to a structured buffer; in our case, it is logical to use a buffer to store the elements of linked lists. <br>  To implement the algorithm on Direct3D 11, create: <br><ol><li>  Texture to store the addresses of the head elements of the lists.  Format - <i>DXGI_FORMAT_R32_UINT</i> , flags for communicating with shaders - <i>D3D11_BIND_UNORDERED_ACCESS |</i>  <i>D3D11_BIND_SHADER_RESOURCE</i> , size is equivalent to the size of the back buffer; </li><li>  Structured buffer for storing linked list items.  Each list item on the HLSL is represented by the following structure: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ListNode { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> packedColor; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> depthAndCoverage; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> next; };</code> </pre> <br>  Thus, each item in the list is 12 bytes.  There are several such elements for each fragment of the back buffer.  Let us imagine a situation where right in front of the camera there are 8 parallel semitransparent planes that occupy the entire screen.  In this case, for each fragment of the back buffer a list of 8 elements will be formed.  To store this amount of data, you need a buffer of 12 * <i>W</i> * <i>H</i> * 8 bytes, where <i>W, H</i> is the length and width of the back buffer.  A rare computer game requires so many visible translucent fragments in a frame, so we take these 8 planes as a limiting case.  For a 1920x1080 back buffer resolution, the size of a structured buffer will be approximately 190MB.  Attach the fragment counter to the same buffer using the flag described above. </li></ol><br>  We will draw the frame as follows: <br><ol><li>  Clear the texture of the addresses of the head elements of the lists with the value 0xffffffff.  For this there is a special method <i>ClearUnorderedAccessViewUint</i> .  We reset the fragment counter; </li><li>  Set the back buffer as the zero render target, index 1 will receive the head element texture, index 2 - structured list element buffer; </li><li>  We are drawing the opaque part of the scene (a skybox and several opaque kettles are drawn in the demo); </li><li>  We create lists of fragments of the translucent part of the scene.  In order to succeed, it is necessary to disable the cut-off of reverse faces ( <i>D3D11_CULL_NONE</i> ), disable the recording of new values ‚Äã‚Äãin the depth buffer (but do not disable the depth test), disable the recording of color in the texture (we have nothing to draw at this step, we only create lists).  The pixel shader that forms the fragment lists is shown below. <br><br><pre> <code class="hljs go">#include &lt;common.h.hlsl&gt; #include &lt;pscommon.h.hlsl&gt; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ListNode { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> packedColor; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> depthAndCoverage; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> next; }; globallycoherent RWTexture2D&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; headBuffer; globallycoherent RWStructuredBuffer&lt;ListNode&gt; fragmentsList; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> packColor(float4 color) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(color.r * <span class="hljs-number"><span class="hljs-number">255</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">24</span></span>) | (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(color.g * <span class="hljs-number"><span class="hljs-number">255</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>) | (<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(color.b * <span class="hljs-number"><span class="hljs-number">255</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) | <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>(color.a * <span class="hljs-number"><span class="hljs-number">255</span></span>); } [earlydepthstencil] float4 main(VS_OUTPUT input, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> coverage : SV_COVERAGE, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> frontFace : SV_IsFrontFace) : SV_TARGET { float4 color = computeColorTransparent(input, frontFace); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> newHeadBufferValue = fragmentsList.IncrementCounter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newHeadBufferValue == <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } uint2 upos = uint2(input.position.xy); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> previosHeadBufferValue; InterlockedExchange(headBuffer[upos], newHeadBufferValue, previosHeadBufferValue); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> currentDepth = f32tof16(input.worldPos.w); ListNode node; node.packedColor = packColor(float4(color.rgb, color.a)); node.depthAndCoverage = currentDepth | (coverage &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>); node.next = previosHeadBufferValue; fragmentsList[newHeadBufferValue] = node; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> float4(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Consider the most interesting places in this code.  The <i>earlydepthstencil modifier</i> plays a very important role.  The fact is that the fragment tests (depth test, stencil, etc.) are usually performed at the final stage of the graphics pipeline, after the pixel shaders are executed.  In our case, this is unacceptable, since all the fragments drawn at this stage fall into linked lists.  To cut off unnecessary fragments before entering the lists, it is necessary to conduct an early depth test (before the pixel shader). <br>  It is easy to see that the color of the fragment is stored in the structure as uint.  Packing float4 values ‚Äã‚Äãin uint saves 12 bytes.  The 32-bit depth is packaged in 16-bit, and the free 16-bits are used to store the coverage value (required for MSAA implementation). <br>  The <i>IncrementCounter</i> method calculates a new address for the head element of the list, and the <i>InterlockedExchange</i> function atomically changes the current value of the head element of the list to a new one.  It is not difficult to see that the list grows with the head, and the code described above is practically a classical implementation of the insertion in the beginning for a simply connected list. </li><li>  At the final step, it is necessary to sort the obtained lists of fragments by depth and display them on the screen, mixing them by alpha channel.  To display the translucent part of the scene, the so-called full-screen quad (in fact, two triangles covering the entire screen) is used.  When rendering quad, you need to turn off the depth test and enable alpha blending.  Since the opaque part of the scene has already been drawn, the blending formula will be as follows: <br><br>  <i>Fragment color</i> = <i>Current fragment color</i> * 1 + <i>Fragment color from the shader</i> * <i>Alpha fragment from the shader</i> ; <br><br>  Those who are familiar with the classical formula of <a href="http://en.wikipedia.org/wiki/Alpha_compositing">alpha blending</a> may be surprised to see this.  In fact, we use the classical formula, just a part of this formula is implemented in the shader, and the above formula is the final stage of mixing with the color of the fragments already drawn on the screen. <br>  As a sorting algorithm, we use <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BA%25D0%25B0%25D0%25BC%25D0%25B8">sorting inserts</a> .  For small data sets, this primitive algorithm is quite effective, besides this algorithm is stable, i.e.  does not change the order of already sorted items.  When rendering semitransparent fragments, we can theoretically get partially ordered by depth lists, for this we need to additionally sort out translucent objects by distance from the observer and draw objects in that order.  In some cases, this will reduce the number of permutations of the sorted elements in the memory. <br>  The code for sorting fragments in a pixel shader is shown below. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> insertionSortMSAA(uint startIndex, uint sampleIndex, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> NodeData sortedFragments[MAX_FRAGMENTS], <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> counter) { counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; uint <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = startIndex; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_FRAGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> != <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>) { uint coverage = (fragmentsList[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>].depthAndCoverage &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coverage &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; sampleIndex)) { sortedFragments[counter].packedColor = fragmentsList[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>].packedColor; sortedFragments[counter].depth = f16tof32(fragmentsList[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>].depthAndCoverage); counter++; } <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = fragmentsList[<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>].next; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">1</span></span>; k &lt; MAX_FRAGMENTS; k++) { <span class="hljs-type"><span class="hljs-type">int</span></span> j = k; NodeData t = sortedFragments[k]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (sortedFragments[j - <span class="hljs-number"><span class="hljs-number">1</span></span>].depth &lt; t.depth) { sortedFragments[j] = sortedFragments[j - <span class="hljs-number"><span class="hljs-number">1</span></span>]; j<span class="hljs-comment"><span class="hljs-comment">--; if (j &lt;= 0) { break; } } if (j != k) { sortedFragments[j] = t; } } }</span></span></code> </pre> <br>  It is also appropriate to mention the <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/cc627092(v%3Dvs.85).aspx">implementation of MSAA in Direct3D 11</a> .  When MSAA is enabled, for each fragment a set of points (samples) is formed inside the fragment with slightly different positions.  The number of such points corresponds to the number of MSAA levels (usually 2, 4, 8, 16).  For each point, its membership in the triangle (coverage test) is checked, and if at least one point is inside the triangle, the pixel shader is executed for the current fragment, and the result is interpolated between all the samples that passed the test.  In order to understand which of the samples are inside the triangle (that is, passed the test and affect the resulting color of the fragment), a mask is formed, called coverage.  This is the value we kept for each semi-transparent fragment at the previous step. <br>  Now, when rendering, we can choose from the list the fragments that correspond to a particular sample using the simple condition <i>coverage &amp; (1 &lt;&lt; sampleIndex)! = 0</i> .  You should also pay attention to the constant <i>MAX_FRAGMENTS</i> .  Effectively sorting the coherent lists is not easy even on the CPU, on the GPU we are even more limited.  Therefore, before sorting, the linked list is copied into a fixed-length array, which limits the number of translucent fragments in the chain. <br>  Interestingly, after filtering fragments by the mask <i>coverage</i> , fragments with exactly the same depth and slightly different color remain in the list.  This leads to the formation of artifacts on the edges of the polygonal model, especially with low quality MSAA.  In order to eliminate the artifact, it is necessary to average the color of the fragments with the same depth.  Since the output list of fragments is sorted by depth, fragments with the same depth value go in a row.  It remains only to calculate and collect them.  The full shader code is hidden under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Pixel shader code for this stage</b> <div class="spoiler_text"><pre> <code class="hljs django"><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">tpcommon.h.hlsl</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> float4 main(VS_OUTPUT input, uint sampleIndex : SV_SAMPLEINDEX) : SV_TARGET { uint2 upos = uint2(input.position.xy); uint index = headBuffer[upos]; clip(index == 0xffffffff ? -1 : 1); float3 color = float3(0, 0, 0); float alpha = 1; NodeData sortedFragments[MAX_FRAGMENTS]; [unroll] for (int j = 0; j </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">MAX_FRAGMENTS</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">++) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sortedFragments</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">(NodeData)0;</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">insertionSortMSAA</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">index</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sampleIndex</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sortedFragments</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span></span><span class="xml"><span class="hljs-tag">); // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolve</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">multisampling</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveBuffer</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">MAX_FRAGMENTS</span></span></span></span><span class="xml"><span class="hljs-tag">]; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">float4</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">colors</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">MAX_FRAGMENTS</span></span></span></span><span class="xml"><span class="hljs-tag">]; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveIndex</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">prevdepth</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">-1.0f;</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">unroll</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">MAX_FRAGMENTS</span></span></span></span><span class="xml"><span class="hljs-tag">)] </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sortedFragments</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">]</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.depth</span></span></span></span><span class="xml"><span class="hljs-tag"> != </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">prevdepth)</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveIndex</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">-1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveBuffer</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">colors</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">unpackColor(sortedFragments[i].packedColor);</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveIndex</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveIndex</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">i</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">; } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">colors</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveIndex</span></span></span></span><span class="xml"><span class="hljs-tag">] += </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">unpackColor(sortedFragments[i].packedColor);</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveBuffer</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveIndex</span></span></span></span><span class="xml"><span class="hljs-tag">]++; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveBuffer</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">prevdepth</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">sortedFragments[i].depth;</span></span></span></span><span class="xml"><span class="hljs-tag"> } // </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">gather</span></span></span></span><span class="xml"><span class="hljs-tag"> [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">unroll</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">MAX_FRAGMENTS</span></span></span></span><span class="xml"><span class="hljs-tag">)] </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">counter</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++) { [</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">branch</span></span></span></span><span class="xml"><span class="hljs-tag">] </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveBuffer</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">] != </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0)</span></span></span></span><span class="xml"><span class="hljs-tag"> { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">float4</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">colors[i]</span></span></span></span><span class="xml"><span class="hljs-tag"> / </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">float</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">resolveBuffer</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">]); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alpha</span></span></span></span><span class="xml"><span class="hljs-tag"> *= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">(1.0</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ca</span></span></span></span><span class="xml"><span class="hljs-tag">); </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">lerp(color,</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">c.rgb</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">ca</span></span></span></span><span class="xml"><span class="hljs-tag">); } } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">float4</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">alpha</span></span></span></span><span class="xml"><span class="hljs-tag">); }</span></span></span></span></code> </pre> </div></div></li></ol><br>  The results of the algorithm, implemented by means of Direct3D 11, can be seen below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/df7/96b/c39/df796bc39452d72b63d6d1c2387a6394.png"><br><br><h5>  Implementation on OpenGL 4.3 </h5><br>  The implementation on OpenGL 4.3 is very similar to the previous implementation.  The analogue of structured buffers here are storage blocks (added to the standard just in version 4.3).  To work with textures that can be read and written from shaders, there are special types in GLSL (we will need <i>uimage2D</i> ).  So, to implement the algorithm, we need: <br><ol><li>  Integer texture ( <i>GL_R32UI</i> ) for storing addresses of the head elements of linked lists; </li><li>  A buffer with the <i>GL_SHADER_STORAGE_BUFFER</i> type for storing linked list items.  The buffer size is calculated in the same way as in the implementation on Direct3D 11; </li><li>  A buffer with type <i>GL_ATOMIC_COUNTER_BUFFER</i> for storing the fragment counter.  Unlike Direct3D in OpenGL, the storage for the atomic counter is created explicitly; </li><li>  Textures for rendering the scene and the depth buffer.  In the implementation of the algorithm on OpenGL we need a texture depth (more on that below).  Although it is possible to get the standard depth buffer from the WGL, it is unreliable, since the format of the stencil depth buffer, which was selected during the initialization of the WGL window, can be different for different equipment.  It is easier and safer to draw in your own framebuffer. </li></ol><br>  The frame rendering procedure has one key feature.  OpenGL offers us to manually manage read-write synchronization.  To do this, there is a special function <i>glMemoryBarrier</i> , which we will call as follows: <br><br><pre> <code class="cpp hljs">glMemoryBarrier(GL_SHADER_IMAGE_ACCESS_BARRIER_BIT | GL_ATOMIC_COUNTER_BARRIER_BIT | GL_SHADER_STORAGE_BARRIER_BIT);</code> </pre><br>  This ensures the integrity of the data between the different stages of drawing a frame. <br><br>  We will draw the frame as follows: <br><ol><li>  Clear the texture with the addresses of the head elements of linked lists with the value 0xffffffff.  In OpenGL 4.3, for this you need to call a shader, which will perform the following operation for each fragment: <br><pre> <code class="hljs lisp">imageStore(<span class="hljs-name"><span class="hljs-name">headBuffer</span></span>, upos, uvec4(<span class="hljs-number"><span class="hljs-number">0</span></span>xffffffff))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre></li><li>  Reset the fragment count ( <i>glClearBufferSubData</i> ); </li><li>  We set the framebuffer to render; </li><li>  We draw the opaque part of the scene; </li><li>  We create lists of fragments of the translucent part of the scene.  At this stage, there is a feature previously announced.  OpenGL can produce an early depth test only for fragment shaders without ‚Äúside effects‚Äù.  Unfortunately, the ‚Äúside effects‚Äù include an entry in the storage block.  The important role of the early depth test for this algorithm was discussed earlier, so we have no choice but to implement the depth test ourselves.  Part of the fragment shader on GLSL is shown below. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { outputColor = vec4(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> newHeadBufferValue = atomicCounterIncrement(fragmentsListCounter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newHeadBufferValue == <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>) discard; ivec2 upos = ivec2(gl_FragCoord.xy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth = texelFetch(depthMap, upos, <span class="hljs-number"><span class="hljs-number">0</span></span>).r; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gl_FragCoord.z &gt; depth) discard; vec4 color = computeColorTransparent(gl_FrontFacing); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> previosHeadBufferValue = imageAtomicExchange(headBuffer, upos, newHeadBufferValue); <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> currentDepth = packHalf2x16(vec2(psinput.worldPos.w, <span class="hljs-number"><span class="hljs-number">0</span></span>)); fragments[newHeadBufferValue].packedColor = packColor(vec4(color.rgb, color.a)); fragments[newHeadBufferValue].depthAndCoverage = currentDepth | (gl_SampleMaskIn[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-number"><span class="hljs-number">16</span></span>); fragments[newHeadBufferValue].next = previosHeadBufferValue; }</code> </pre><br>  The recording in depth and color buffers, as well as the cut-off of the reverse faces should be disabled at this stage in a manner similar to the implementation on Direct3D. </li><li>  Sort the resulting lists of fragments by depth and output them to the framebuffer, mixing them by alpha channel.  The sorting, blending, and alpha blending settings are similar to Direct3D.  The only exception is the fact that after filtering the fragments by the coverage mask, there are no fragments that have exactly the same depth in the list, so the fragment shader is somewhat simplified. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> main() { ivec2 upos = ivec2(gl_FragCoord.xy); uint <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = imageLoad(headBuffer, upos).x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> == <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">discard</span></span>; vec3 color = vec3(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f; NodeData sortedFragments[MAX_FRAGMENTS]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_FRAGMENTS; i++) { sortedFragments[i] = NodeData(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f); } <span class="hljs-type"><span class="hljs-type">int</span></span> counter; insertionSort(<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>, gl_SampleID, sortedFragments, counter); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; MAX_FRAGMENTS; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; counter) { vec4 c = unpackColor(sortedFragments[i].packedColor); alpha *= (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - ca); color = mix(color, c.rgb, ca); } } outputColor = vec4(color, alpha); }</code> </pre><br></li><li>  We copy from framebuffer to screen using glBlitFramebuffer function. </li></ol><br>  Visually, the result obtained when rendering on OpenGL 4.3 is no different from Direct3D 11. <br><br><h4>  Problems </h4><br>  The algorithm has 3 key problems: <br><ol><li>  The value <i>MAX_FRAGMENTS</i> , limiting the maximum number of semi-transparent fragments in the list.  We ourselves can choose this value on the basis of the required level of quality and the time margin that can be given for the calculation of OIT.  By the way, the inclusion of MSAA increases the number of translucent fragments, especially in the edges of polygonal models.  Below is shown what happens if the list size is not enough. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b11/4f6/5b6/b114f65b66022e914c5867196848d904.png"><br></li><li>  Buffer size for storing list items.  I used a buffer of 190Mb in size and could not reproduce the overflow on the stage of 36 dummies, but on polygonal models of complex shape this is possible and very likely.  The buffer size can be increased, since graphical APIs do not explicitly limit the size of structured buffers and storage blocks.  I reduced the buffer size 8 times to show what happens during an overflow. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/955/04d/eec/95504deece6318fa5e597a8d4244cc63.png"><br></li><li>  The complexity of the pixel (fragmentary) shader at the final stage of the algorithm.  With an increase in <i>MAX_FRAGMENTS</i> and the inclusion of MSAA, the shader becomes increasingly heavy, which negatively affects the fillrate and can lead to serious ‚Äúbrakes‚Äù. </li></ol><br><br><h4>  Performance </h4><br>  Performance measurements were taken on a computer with the following configuration: AMD Phenom II X4 970 3.79GHz, 16Gb RAM, AMD Radeon HD 7700 Series, running Windows 8.1. <br><br>  Average frame time.  Direct3D 11 / 1920x1080 / 400k-800k translucent fragments. <br><table><tbody><tr><th>  MSAA / MAX_FRAGMENTS </th><th>  eight </th><th>  sixteen </th><th>  32 </th></tr><tr><td>  0 </td><td>  1.4835ms </td><td>  1.67446ms </td><td>  2.1275ms </td></tr><tr><td>  2x </td><td>  3.49895ms </td><td>  6.66149ms </td><td>  8.52533ms </td></tr><tr><td>  4x </td><td>  5.78841ms </td><td>  12.3358ms </td><td>  15.7224ms </td></tr><tr><td>  8x </td><td>  8.93051ms </td><td>  18.4825ms </td><td>  24.8538ms </td></tr></tbody></table><br>  Average frame time.  OpenGL 4.3 / 1920x1080 / 400k-800k translucent fragments. <br><table><tbody><tr><th>  MSAA / MAX_FRAGMENTS </th><th>  eight </th><th>  sixteen </th><th>  32 </th></tr><tr><td>  0 </td><td>  3.25259ms </td><td>  4.10712ms </td><td>  16.8482ms </td></tr><tr><td>  2x </td><td>  5.06972ms </td><td>  7.16611ms </td><td>  33.6713ms </td></tr><tr><td>  4x </td><td>  7.22944ms </td><td>  12.3625ms </td><td>  62.5776ms </td></tr><tr><td>  8x </td><td>  11.2621ms </td><td>  19.0938ms </td><td>  115.026ms </td></tr></tbody></table><br>  Average frame time.  Direct3D 11 / 1920x1080 / ~ 5000k translucent fragments. <br><table><tbody><tr><th>  MSAA / MAX_FRAGMENTS </th><th>  eight </th><th>  sixteen </th><th>  32 </th></tr><tr><td>  0 </td><td>  4.94471ms </td><td>  5.73306ms </td><td>  7.95545ms </td></tr><tr><td>  2x </td><td>  9.91625ms </td><td>  26.6783ms </td><td>  40.4808ms </td></tr><tr><td>  4x </td><td>  16.653ms </td><td>  50.7367ms </td><td>  77.038ms </td></tr><tr><td>  8x </td><td>  28.3847ms </td><td>  91.0873ms </td><td>  143.419ms </td></tr></tbody></table><br>  Average frame time.  OpenGL 4.3 / 1920x1080 / ~ 5000k translucent fragments. <br><table><tbody><tr><th>  MSAA / MAX_FRAGMENTS </th><th>  eight </th><th>  sixteen </th><th>  32 </th></tr><tr><td>  0 </td><td>  16.2532ms </td><td>  22.0057ms </td><td>  139.678ms </td></tr><tr><td>  2x </td><td>  22.1646ms </td><td>  35.0568ms </td><td>  275.324ms </td></tr><tr><td>  4x </td><td>  30.4289ms </td><td>  56.7788ms </td><td>  536.241ms </td></tr><tr><td>  8x </td><td>  46.6934ms </td><td>  197.024ms </td><td>  1009.09ms </td></tr></tbody></table><br><br>  It is easy to see that the implementation of the algorithm on Direct3D 11 is faster than on OpenGL 4.3.  And on 5 million translucent fragments, the implementation on OpenGL ‚Äúdies‚Äù with MSAA enabled and large values ‚Äã‚Äãof <i>MAX_FRAGMENTS</i> .  The results of the profiling showed that the algorithm spends most of the time on the final stage, i.e.  on sorting and mixing colors of fragments.  You should also take into account that my video card is far from the newest, and these figures show only the dynamics of the frame time change. <br><br><h4>  findings </h4><br>  The use of linked lists, probably, can be considered the most modern approach to the implementation of OIT.  The algorithm works very quickly with reasonable settings for the quality and complexity of the semi-transparent part of the scene.  5 million visible translucent fragments in the frame is, in my opinion, enough even for the most modern game (about 2.5 times to cover the screen with a resolution of 1920x1080 with translucent fragments).  MSAA, which can slow down the algorithm, can be discarded altogether if necessary or replaced by another anti-aliasing algorithm.  The algorithm, of course, has flaws, but they are all clear, and can be fought with. <br><br><h4>  A little about terminology </h4><br>  It so happened that the terminology of computer graphics is almost entirely foreign.  Below under the spoiler, I gave a number of terms that can be useful when reading the post. <br><div class="spoiler">  <b class="spoiler_title">Terms</b> <div class="spoiler_text">  <b>Rendering</b> is the process of drawing a three-dimensional scene on a two-dimensional medium (screen, texture). <br>  <b>Shader</b> - a program for the graphics processor (GPU), which allows you to control one stage of the graphics pipeline.  The vertex shader operates with vertices, the geometry with primitives (triangles, lines, etc.), the pixel (fragment) with the pixels formed at the output. <br>  <b>Rasterization</b> is the process of forming a raster image from the vector representation of an object. <br>  <b>Depth Test</b> - a test obtained when rendering fragments, which allows you to cut off fragments depending on the depth of the already drawn part of the scene.  Usually, the depth of the fragment closest to the observer is recorded in the depth buffer. <br>  <b>MSAA (multi-sampling antialiasing)</b> is one of the anti-aliasing algorithms implemented in both OpenGL and Direct3D. <br>  <b>MSAA texture</b> - texture for rendering with anti-aliasing.  It has a special format, type and set of operations in shaders. <br>  <b>Render target</b> - where rendering.  The term is commonly used when painting a scene into a texture. <br>  <b>MRT (multiple render targets)</b> is a technology that allows rendering to <b>multiple render targets</b> at once. <br>  <b>Compute-shader</b> - a program for the GPU, designed to solve a general-purpose task (perhaps not related to computer graphics). <br>  <b>Back buffer (back buffer)</b> - in the multi-buffer rendering model, the buffer in which rendering is usually performed, and which changes places with the front buffer (front buffer) after the frame is finished drawing. <br>  <b>Framebuffer</b> is a special object in OpenGL that allows you to combine multiple render targets and a depth buffer. <br>  <b>Fillrate</b> - roughly the speed of filling the screen with pixels. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/224003/">https://habr.com/ru/post/224003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223993/index.html">In Dubai, for the mark of people in photos on Facebook you can go to jail</a></li>
<li><a href="../223995/index.html">Analysis of the new version of Miniduke</a></li>
<li><a href="../223997/index.html">Cloud copy-paste - open source</a></li>
<li><a href="../223999/index.html">Steam In-Home Streaming - or take your gaming computer to the balcony</a></li>
<li><a href="../224001/index.html">Installing Alfresco Community 4.2.f on the Jelasctic.com cloud service</a></li>
<li><a href="../224005/index.html">Cube iWork10 - a tablet on a full Windows 8.1 Pro</a></li>
<li><a href="../224017/index.html">Introduced an updated collection of Metro 2033 and Metro: Last Light on Linux, Windows and new consoles</a></li>
<li><a href="../224023/index.html">IT guy on vacation: what about the telescope?</a></li>
<li><a href="../224025/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ110 (May 18 - 24, 2014)</a></li>
<li><a href="../224027/index.html">Steam Files. Part 1 - GCF / NCF</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>