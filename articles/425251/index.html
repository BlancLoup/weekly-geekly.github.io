<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>LoJax: the first known UEFI rootkit used in a malicious campaign</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Sednit cyber group, also known as APT28, Strontium and Fancy Bear, has been operating since at least 2004. It is believed that the group is behind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>LoJax: the first known UEFI rootkit used in a malicious campaign</h1><div class="post__text post__text-html js-mediator-article">  The Sednit cyber group, also known as APT28, Strontium and Fancy Bear, has been operating since at least 2004.  It is believed that the group is behind a number of resonant cyber attacks.  Some <a href="https://www.crowdstrike.com/blog/bears-midst-intrusion-democratic-national-committee/">security companies</a> and the <a href="https://assets.documentcloud.org/documents/4598895/DOJ-Russia-DNC-Hack-Indictment.pdf">US Department of Justice</a> called Sednit responsible for hacking the Democratic National Committee before the 2016 US elections.  The group is credited with <a href="https://www.bbc.com/news/technology-37590375">hacking the</a> global television network TV5Monde, e-mail <a href="https://www.wired.com/story/russian-fancy-bears-hackers-release-apparent-ioc-emails/">leakage</a> of the World Anti-Doping Agency (WADA) and other incidents.  Sednit has many goals and a wide range of tools, some of which we have already <a href="http://www.welivesecurity.com/wp-content/uploads/2016/10/eset-sednit-full.pdf">documented</a> earlier, but in this paper we will describe in detail for the first time the use of a UEFI rootkit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ai/yf/nq/aiyfnqxa7dzic4myqh6eircpapo.jpeg"></div><br><a name="habracut"></a><h2>  Short review </h2><br>  We found that, at least since the beginning of 2017, Sednit has been using a trojanized version of the old user agent program to protect devices against theft from the developer Absolute Software - LoJack.  The tool attracted the attention of IB specialists because of the use of the UEFI / BIOS module as a mechanism for ensuring persistence.  We called the trojanized version of this program <b>LoJax</b> . <br><br>  The presence of known Sednit tools along with LoJax samples in the infected systems, and the fact that some of the command servers used by trojanized agents were previously part of the Sednit infrastructure, allow us to link the UEFI rootkit with this group with a high degree of confidence. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Together with the LoJax agents, tools were found to read the UEFI system firmware, and in one of the cases this tool could dump, patch and rewrite part of the system's SPI flash memory.  The ultimate goal of the tool is to install a malicious UEFI module in a system whose SPI flash memory protection is vulnerable or misconfigured. <br><br>  The UEFI module is responsible for introducing the LoJax agent into the system; this is the first UEFI rootkit of the Sednit group identified.  Since it is in the system firmware, it can survive reinstalling Windows and replacing the hard disk. <br><br>  There was at least one case where this rootkit was successfully installed into the system SPI flash memory.  According to our information, this is the first UEFI rootkit detected in-the-wild. <br><br><h2>  Introduction </h2><br>  The Sednit group uses a number of malware families.  A detailed description of the frequently used tools of the group was given in the <a href="http://www.welivesecurity.com/wp-content/uploads/2016/10/eset-sednit-full.pdf">report</a> . <br><br>  We have been monitoring Sednit for several years and have released many reports on the work of the group, from <a href="https://www.welivesecurity.com/2017/05/09/sednit-adds-two-zero-day-exploits-using-trumps-attack-syria-decoy/">describing</a> zero-day vulnerabilities to custom programs such as <a href="https://www.welivesecurity.com/2018/04/24/sednit-update-analysis-zebrocy/">Zebrocy</a> .  The components described in this report form a separate group. <br><br>  UEFI rootkits were described in the reports of information security companies earlier.  Known, for example, is the rkloader, which appeared in a <a href="https://blog.trendmicro.com/trendlabs-security-intelligence/hacking-team-uses-uefi-bios-rootkit-to-keep-rcs-9-agent-in-target-systems/">presentation</a> about data leakage in the Hacking Team, and DerStarke, an implant in the macOS EFI / UEFI download, from <a href="https://wikileaks.org/ciav7p1/cms/page_13763820.html">Vault7</a> documents.  We know about the existence of these tools, but reports on UEFI‚Äôs compromising rootkits were not issued. <br><br>  Now we have not only proved the in-the-wild use of the firmware with the malicious LoJax UEFI module, but also discovered the whole range of tools that were most likely used to install it.  It is interesting to note that Sednit uses the DownDelph bootkit, which was used in 2013 and 2014 for the persistence of Downdelph, one of the Sednit backdoors of the first stage.  The idea is similar, but in the new version of UEFI, the use of bootkits is no longer possible.  Thus, these two components are significantly different in behavior. <br><br>  This work is divided into three sections.  In the first, we will examine the early LoJack / Computrace security studies and the possibilities of malicious use of the program.  The second section is devoted to the research process, which eventually led us to the UEFI rootkit.  Finally, in the third section, we describe in detail the various components of LoJax and how they ensure persistence in the system even after reinstalling Windows and replacing the hard disk. <br><br><h4>  Attribution </h4><br>  While many vendors have already made statements regarding the Sednit group in the past, ESET does not in any way determine the geopolitical affiliation.  Since the publication of the <a href="http://www.welivesecurity.com/wp-content/uploads/2016/10/eset-sednit-full.pdf">study in</a> 2016, our position has not changed.  Identifying the source of a cyber attack based on a scientific approach is a complex task that is outside the scope of the competence of ESET specialists.  What we call the ‚ÄúSednit group‚Äù is simply a collection of software and an associated network infrastructure that we cannot authoritatively link to any particular organization. <br><br><h4>  Goals </h4><br>  During the study, we found a small number of different images of LoJax.  Based on our telemetry data and the study of other Sednit programs found in-the-wild, we are confident that this particular module was rarely used in comparison with other tools.  The targets were mainly state organizations located in the Balkans, in Central and Eastern Europe. <br><br><h2>  Early Computertrace / LoJack research </h2><br>  LoJack - software to protect computers from theft and loss, developed by Absolute Software.  Early versions of the agent are known as Computrace.  As the previous name suggests, after activating the service, the computer can contact its command server ‚Äî the owner will be notified of the device's location in case of loss or theft. <br><br>  The rest of this section describes the old LoJack architecture.  Only the old version of the software was trojanized by the attackers, so we will focus on it.  In addition, Absolute Software released in May 2018 a <a href="https://www.absolute.com/en-gb/resources/faq/absolute-response-to-arbor-research">statement</a> that the vulnerabilities described below do not affect the performance of the latest versions of their agents. <br><br>  The Computrace program attracted the attention of information security professionals because it used an unusual persistence method.  Its goal is to protect against theft, so resistance to reinstalling the OS and replacing the hard disk is important for it ‚Äî all of this is implemented in the UEFI / BIOS module that can survive after these actions.  The solution is pre-installed in the firmware of a significant part of laptops from different manufacturers, the user only needs to activate this function.  Activation can be performed in the BIOS, as shown in the figure below. <br><br><img src="https://habrastorage.org/webt/rf/vx/i_/rfvxi_hexr1f29e0hqddhak97ag.png"><br>  <i>Figure 1. Activating Computrace in BIOS</i> <br><br>  One of the first LoJack / Computrace implementation reports was published in 2009.  The global product architecture, the UEFI / BIOS module dropping the user agent to disk and the way the agent communicates with the web server managed by Absolute Software was disclosed.  The scheme can be understood from the figure below. <br><br><img src="https://habrastorage.org/webt/mh/5a/u2/mh5au2bhmrriy8sn8dtsd1g1avw.png"><br>  <i>Figure 2. LoJack persistence mechanism (approximately 2008)</i> <br><br>  The following is a description of the steps listed above: <br><br>  1. When activated, the UEFI / BIOS module runs at boot.  He is trying to find the partition FAT / FAT32 / NTFS.  Then, using the NTFS driver, he creates a backup of the <code>autochk.exe</code> file and overwrites its contents using the dropper, which is responsible for installing the user agent component.  The <code>autochk.exe</code> file is a Windows executable that runs at an early stage of the system boot to check for possible damage to the hard disk. <br><br>  2. When the modified <code>autochk.exe</code> launched, its main purpose is to deploy the <code>rpcnetp.exe</code> mini-agent and add it as a service so that it starts at each reboot.  The last stage of this component is to restore the original version of <code>autochk.exe</code> . <br><br>  3. Mini-agent <code>rpcnetp.exe</code> is a small executable file whose purpose is to ensure the operation of the main agent.  If the primary agent does not work, <code>rpcnetp.exe</code> attempts to connect to the Absolute Software command and control C &amp; C server to download and execute it.  First, the mini-agent will make a copy of itself, then make changes to the PE header for conversion to a DLL.  This library is then loaded into memory, calls the <code>svchost.exe</code> process and injects the DLL there.  Next, the <code>iexplore.exe</code> Internet Explorer process starts, and the DLL is injected into it.  The latter process will then be used for communication over the Internet.  Injecting to third-party processes performed by the Computrace mini-agent is often found in malware and is rarely associated with legitimate software. <br><br>  4. Now the full-featured agent works on the system and can use the Computrace features for tracking and recovery. <br><br>  <a href="https://www.blackhat.com/docs/us-14/materials/us-14-Kamluk-Computrace-Backdoor-Revisited-WP.pdf">A description of</a> this process and the network protocol involved between the mini-agent and the C &amp; C server was published in 2014.  Due to the lack of an authentication mechanism, if attackers control the server with which the mini-agent communicates, they can force it to download arbitrary code.  There are several mechanisms that allow an attacker to contact a mini-agent directly.  The most important for us is using the method of getting the address of the C &amp; C server by the mini-agent.  In fact, this information is stored in the configuration file in the executable file itself. <br><br><img src="https://habrastorage.org/webt/qc/ww/es/qcwwesoicwoyw1aghae1smpgnao.png"><br>  <i>Figure 3. Encrypted LoJack configuration file with partial decryption on the right</i> <br><br>  The figure shows the LoJack mini-agent configuration file.  The ‚Äúencryption‚Äù method used is a simple XOR with a single-byte key.  The key 0xB5 is the same for all studied mini-agents.  As can be seen from the figure, the C &amp; C domain is specified in the file.  The four preceding bytes contain the IP address of the command C &amp; C server.  In the absence of validation of the contents of the configuration file, attackers with write permissions in <code>%WINDIR%</code> can change its contents so that the mini-agent will contact their command server, instead of the legitimate one.  Understanding the network protocol, you can force the mini-agent to download and execute arbitrary code.  These risks have long been known, but until recently the mechanism was not used in practice. <br><br><h4>  LoJack turns into LoJax </h4><br>  In May 2018, Trojanized samples of LoJack mini-agent, rpcnetp.exe, were described in the Arbor Network <a href="https://asert.arbornetworks.com/lojack-becomes-a-double-agent/">blog</a> .  Their hard-coded network settings were changed in such a way that the malicious samples established communication with the C &amp; C server of the attackers instead of the legitimate Absolute Software server.  Some of the domains found in trojnized samples have been encountered before - they were used at the end of 2017 as the domains of the C &amp; C servers for SedUploader, the backdoor of the first stage of the Sednit cyber group.  The figure below shows an example of a modified configuration in one of the LoJax mini-agents. <br><br><img src="https://habrastorage.org/webt/om/ts/md/omtsmdgqzbkn-fbqrpjd59abp7a.png"><br>  <i>Figure 4. Left - legitimate configuration file, right - modified</i> <br><br>  The differences between legitimate and trojanized agents are extremely small; almost everything is listed above.  LoJax mini-agent samples that we were able to detect are trojanized versions of the same Computrace mini-agent sample, <code>rpcnetp.exe</code> .  All of them have identical compilation timestamps and only a few dozen bytes are different from the original.  In addition to changes in the configuration file, there are differences in timer variables that determine the intervals between connections to the command C &amp; C server. <br><br>  At the time of publication, we discovered various LoJax mini-agents used in attacks on various organizations in the Balkans, in Central and Eastern Europe, but we had no idea how to install them.  An obvious explanation would be the installation using one of the famous Sednit backdoors.  Do not forget that LoJack, as a well-proven tool, has been whitelisted by many anti-virus vendors.  Thus, even if only a mini-agent was used in this campaign, which did not survive after reinstalling Windows, it still had an advantage - less likelihood of being detected as malware.  But what if the compromise was even deeper, and the attackers tried to copy LoJack to get to the system firmware? <br><br><h2>  Hunting component of the lower level </h2><br>  We recorded LoJax attacks targeting several organizations in the Balkans, in Central and Eastern Europe.  In all of them we managed to find traces of Sednit malware, including: <br><br><ul><li>  SedUploader, the first stage backdoor </li><li>  XAgent, the flagship backdoor Sednit </li><li>  Xtunnel, a network proxy tool that can transfer any network traffic between a C &amp; C server on the Internet and a destination computer on a local network </li></ul><br>  We found traces of the Sednit tools in most of the systems studied, which became LoJax targets, as well as a pair of systems where only LoJax was present.  It can be assumed that in some cases LoJax was used as a separate tool, probably as an additional backdoor for restoring Sednit operators access to the network. <br><br>  The XAgent backdoor usually drops additional modules into a compromised system, so it immediately comes to mind that LoJax samples were delivered in the same way, without any other mechanisms.  One would assume that Sednit borrowed only a mini-agent from the LoJack solution.  However, shortly after the start of the analysis, we found several clues indicating that the source of inspiration was somewhat more extensive. <br><br><h4>  RWEverything (RwDrv) and info_efi.exe driver </h4><br>  The first piece of evidence was found thanks to an intruder's custom tool, which, when executed, uploaded the information about the lower-level system settings to a text file.  The tool was found along with some LoJax samples.  The following figure shows a fragment of the file with the logs of this tool under the logical name <code>info_efi.exe</code> . <br><br><img src="https://habrastorage.org/webt/8j/9x/kc/8j9xkcnbmste_xynugnkenaar6g.png"><br>  <i>Figure 5. Excerpt from log files generated by info_efi .exe</i> <br><br>  To read this type of information, the tool includes a driver called <code>RwDrv.sys</code> .  The kernel driver comes with <a href="http://rweverything.com/">RWEverything</a> , a free utility available on the network that can be used to read information on almost all of the lower level settings, including the PCI Express interface, memory, PCI Option ROMs, etc.  The kernel driver is legitimate software and is signed with a valid certificate. <br><br><img src="https://habrastorage.org/webt/2u/o-/mb/2uo-mbk6so15sdz9iusnxzl15qq.png"><br>  <i>Figure 6. RwDrv.sys code signature certificate</i> <br><br>  RWEverything software comes bundled with a graphical user interface that allows you to access all of this information. <br><br><img src="https://habrastorage.org/webt/if/yp/dp/ifypdpu-hnounvupxelxhcp5el4.png"><br>  <i>Figure 7. Screenshot of the RWEverything interface</i> <br><br>  The discovery of the <code>info_efi</code> tool was the first sign that the LoJax UEFI module can exist.  When trying to update the system firmware, it is important to have information about its vendor, version, etc.  Given the presence of vulnerabilities that allow user processes to access and modify the contents of the SPI flash memory, where UEFI modules are stored, obtaining data on the system firmware is the first step to a successful attack. <br><br>  The final clue that allowed us to find the first UEFI rootkit of the Sednit group was two tools - to dump the SPI flash memory and to write to it. <br><br><h4>  Dump SPI flash memory </h4><br>  The first piece of the puzzle was a file called <code>ReWriter_read.exe</code> .  It contained all the code required to dump the system SPI flash memory using the RWEverything driver, <code>RwDrv.sys</code> .  For the device driver to perform the necessary operations, the dump tool must send the correct I / O control codes (IOCTL).  While <code>RwDrv.sys</code> supports many different IOCTL codes, the dumper tool and recording tool described in this and the next section use only four of them. <br><br>  RwDrv.sys: supported IOCTL codes: <br><br>  <i>0x22280c</i> - writes to the memory area allocated for input-output <br>  <i>0x222808</i> - reads the memory area allocated for I / O <br>  <i>0x222840</i> - read dword from specified PCI configuration register <br>  <i>0x222834</i> - writes a byte to the specified PCI configuration register <br><br>  <code>ReWriter_read</code> first creates a service with the kernel driver <code>RwDrv.sys</code> and writes the UEFI / BIOS configuration information, the corresponding values ‚Äã‚Äãof the three fields contained in the BIOS control register (BIOS_CNTL): BIOS Lock Enable (BLE), BIOS Write Enable (BIOSWE) and SMM BIOS Write Protect Disable (SMM_BWP).  Although <code>ReWrite_read</code> does not use these values, in the following sections we will explain why these fields are of interest for this tool. <br><br>  The next task of the tool is to obtain the base address of the BIOS memory area in SPI and its size.  This information is contained in the main SPI register as the BIOS Flash Primary Region.  All registers are mapped in memory in the Root Complex Register Block (RCRB), the base address of which can be obtained by reading the desired configuration register PCI Configuration Register.  <code>ReWriter_read</code> obtains this address by using RwDrv IOCTL 0x22840 and reading the correct indent (in our case, 0xF0).  As soon as the base address of the BIOS area and its size are known, the dump tool reads the corresponding contents of the SPI flash memory and writes it to a disk file.  The process of reading the SPI flash is illustrated in the following figure.  The abbreviations are defined below in the glossary. <br><br><img src="https://habrastorage.org/webt/mw/wm/tb/mwwmtbzbrwmm18l1w7-2iugvpxc.png"><br>  <i>Figure 8. Working sequence of reading from SPI flash memory</i> <br><br>  In addition to the first two steps, which are performed only once, the operations are repeated in a cycle until all the data from the SPI flash memory has been read.  The process is also well described <a href="https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf">here</a> .  Then <code>ReWriter_read</code> validates the size of the merged image.  It parses the image memory descriptor to get the BIOS range, Gigabit Ethernet (GbE) areas, and Management Engine (ME).  Adding the dimensions of these three areas allows the dumper tool to calculate the entire contents of the SPI flash memory.  If the size matches the size obtained from reading the BIOS Flash Primary register area, the image is considered valid. <br><br><h4>  UEFI firmware patch </h4><br>  The second piece of the puzzle was a file called <code>ReWriter_binary.exe</code> .  This file contains proof of the fact that Sednit got to the firmware.  The file contains the code for applying the UEFI unloaded image patch and writing back the trojanized version to the SPI flash memory.  In this section we describe how this binary file is arranged. <br><br>  After the contents of the flash memory are unloaded and checked by the above tool, a malicious UEFI module is added to the image.  To do this, the image of UEFI must be analyzed to highlight the necessary information. <br><br>  The data stored in the UEFI image is expanded into volumes using the file system (FFS).  As the name suggests, this is a special file system for storing firmware images.  Volumes contain files with GUIDs.  Each file usually consists of a set of sections, one of which contains the actual PE / COFF executable, which is a UEFI image.  Below for a simpler understanding of the scheme is a screenshot of <a href="https://github.com/LongSoft/UEFITool">UEFITool</a> , an open source project for working with UEFI firmware images. <br><br><img src="https://habrastorage.org/webt/s6/th/mp/s6thmpgjnornwankifoul8d9zlk.png"><br>  <i>Figure 9. An example of a UEFI firmware image loaded into UEFITool</i> <br><br>  ReWriter_binary analyzes all firmware volumes found in the BIOS BIOS SPI area and searches for specific files: <br><br><ul><li>  Ip4dxe (8f92960f-2880-4659-b857-915a8901bdc8) </li><li>  NtfsDxe (768bedfd-7b4b-4c9f-b2ff-6377e3387243) </li><li>  SmiFlash (bc327dbd-b982-4f55-9f79-056ad7e987c5) </li><li>  Dx core </li></ul><br><img src="https://habrastorage.org/webt/zt/ou/kc/ztoukch8w0mdyv-whzpkaibpc9u.png"><br>  <i>Figure 10. The result of using the Hex-Rays decompiler in the firmware volumes</i> <br><br>  Ip4Dxe and NtfsDxe - DXE drivers.  In UEFI firmware, DXE drivers are PE / COFF images created either for hardware abstraction or for organizing services for use by other DXE drivers or UEFI applications.  Such drivers are detected and loaded by the DXE Foundation via the DXE dispatcher (DXE core) at an early stage of the boot process.  After this phase is completed, all services, such as the OS loader, are available to work with UEFI applications.  Normally, DXE drivers are stored in the same volume.  However, the DXE dispatcher may be separate. <br><br>  <code>ReWriter_binary</code> searches for Ip4Dxe only to see if a given volume contains DXE drivers.  As we will describe later, this volume becomes a candidate for installing the malicious DXE driver.  It also searches for the DXE kernel and adds the volume in which it is located, as another candidate for a place to record the rootkit.  The free available space in each of these volumes is stored and later used to test the sufficiency for adding a malicious driver. <br><br>  NtfsDxe - AMI NTFS DXE driver.  If it is present in the firmware volume, its location is saved and later used to remove this file from the volume.  In the section on UEFI rootkit, we will see why it deletes this file. <br><br>  As for the SmiFlash image, the information relating to it is stored, but is not used anywhere in Malvari.  Interestingly, the image <a href="https://threatvector.cylance.com/en_us/home/gigabyte-brix-systems-vulnerabilities.html">is vulnerable</a> .  Therefore, we believe that Sednit operators can work on exploiting these vulnerabilities.  This may allow them to write flash memory to even properly configured systems in SPI.  As we will describe later, in the current view, the tool can only write to the BIOS area of ‚Äã‚Äãincorrectly configured or fairly old systems (on motherboards with chipsets older than Platform Controller Hub, introduced around 2008). <br><br>  After highlighting the necessary metadata, <code>ReWriter_binary</code> patches a UEFI image dump and adds a malicious DXE driver.  First, it creates the file header (EFI_FFS_FILE_HEADER).  He then selects the destination volume based on the location of the Ip4Dxe and the DXE core, as well as the free space available in these volumes.  <code>ReWriter_binary</code> embeds a compressed section containing a PE image and a User interface section defining the human-readable file name: SecDxe.  A compressed section is added to the file header and written to the end of the volume, in free space.  The figure below shows the structure - its display in UEFITool. <br><br><img src="https://habrastorage.org/webt/g6/9-/-a/g69--aub7xrb5b1iinzwrtpxyo8.png"><br>  <i>Figure 11. UEFITool view of the SecDxe file</i> <br><br>  Finally, if the NtfsDxe driver is present in the image, it will be removed.  The firmware file system stores files and their contents sequentially, so the process is quite simple: <br><br><ul><li>  is indented to the free space at the end of the volume </li><li>  over the image of NtfsDxe 0xFF bytes are written </li><li>  the subsequent part of the firmware volume is copied, starting at the indent where NtfsDxe was located </li><li>  the rest of the file system is filled with 0xFF bytes, i.e. free space </li></ul><br><h4>  Write patched firmware back to SPI flash memory </h4><br>  After successfully making changes to the firmware image, the next step is to write it back to the SPI flash memory.  Before diving into this process, we need to characterize some of the BIOS write protections that are important in this case.  Other existing mechanisms, such as BIOS Range Write Protection, remain on the sidelines, as ReWriter_binary does not check them. <br><br>  The platform uses several defense mechanisms to block unauthorized attempts to write to the BIOS area.  It must be said that these mechanisms are not included by default.  The firmware is responsible for their correct setting.  These configurations are presented in the BIOS control register (BIOS_CNTL).  It contains the BIOS Write Enable (BIOSWE) bit, which must be switched to ‚Äú1‚Äù in order to be able to write to the BIOS area of ‚Äã‚Äãthe SPI flash memory.  Since the platform should not allow any attempts to write to the BIOS area, there is another bit in BIOS_CNTL to protect the BIOSWE - this is BIOS Lock Enable (BLE).  When set, the mechanism should block the BIOSWE bit and leave a value of "0".  However, the solution has a vulnerability.  When the BIOSWE bit request request comes to "1", the BIOSWE bit is set to "1", and only after that the platform interrupts the task using System Management Interrupt (SMI), the code of this SMI performs a BIOSWE bit change back to "0". <br><br>  In this version of the solution there are many problems.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, the SMI handler is left for the developers of the firmware. </font><font style="vertical-align: inherit;">Therefore, if this code is not implemented in the firmware, the BLE bit is useless, since the BIOSWE bit will not be set back to ‚Äú0‚Äù. </font><font style="vertical-align: inherit;">Secondly, in this case, we have a ‚Äú </font></font><a href="https://www.kb.cert.org/vuls/id/766164"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">race condition vulnerability,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù which allows you to completely bypass this mechanism, even if the SMI handler is implemented correctly. </font><font style="vertical-align: inherit;">To exploit this vulnerability, an attacker needs to start a stream that continuously sets the BIOSWE to "1", while another stream must write data to SPI flash memory. </font><font style="vertical-align: inherit;">According to the </font></font><a href="https://bromiumlabs.files.wordpress.com/2015/01/speed_racer_whitepaper.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">work of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kallenberg and Wojtchuk, this attack runs on multi-core processors and can also be successfully used on single-core processors with Hyper-Threading technology enabled.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, a new protection mechanism has been added to the platform, configured via BIOS_CNTL. It is introduced in the Intel Platform Controller Hub (PCH) chipset family. If the configuration bit is set, SMM BIOS Write Protect Disable (SMM_BWP) will provide the ability to write to the BIOS area only if all the cores are running in System Management Mode (SMM) and the BIOSWE is set to the value "1". This effectively protects the system from the ‚Äúrace condition vulnerability‚Äù described above. However, as in the case of BLE, SMM_BWP must be activated from the firmware side. Therefore, the firmware in which these mechanisms are incorrectly configured leaves in the system the risk of granting unauthorized write rights to the BIOS area. </font></font><br><br> <code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reads the contents of the BIOS control register to select the correct path.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, it checks whether the BIOSWE is set. If so, it goes into the recording phase. If BIOSWE is disabled, it checks the value of the BLE bit. If it is not installed, it changes the value of the BIOSWE bit and starts recording the patched firmware. If the BLE bit is set, it checks the disabled SMM_BWP state and applies the ‚Äúrace state vulnerability‚Äù described above. If the SMM_BWP bit is set, the operation fails. The figure below illustrates the process. </font></font><br><br><img src="https://habrastorage.org/webt/db/3t/n5/db3tn5tpff0bgjciq9ciiy3a6p4.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 12. Decision-making tree during the recording process</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assuming that the particular file being analyzed was </font></font><code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to deploy the UEFI rootkit, it can be concluded that either the firmware has incorrectly configured the BIOS write protection or the victim's chipset is older than Platform Controller Hub.</font></font><br><br> <code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would not be able to replace the UEFI firmware on a well-tuned modern system. However, when searching for a vulnerable SmiFlash UEFI image, parsing UEFI firmware volumes suggests that attackers could work with more advanced </font></font><a href="https://threatvector.cylance.com/en_us/home/gigabyte-brix-systems-vulnerabilities.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIOS write protection bypass</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> techniques </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a manner very similar to the reading procedure, writing to the SPI flash memory takes place: </font></font><br><br><img src="https://habrastorage.org/webt/ct/wi/v3/ctwiv38relsl9rpveltd8imrpjy.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 13. The writing sequence in the SPI flash memory</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Besides the first two steps, which are performed only once, these operations are repeated in a loop until all the information is written to the SPI flash memory . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the write process is done, the contents of the SPI flash are unloaded once again into the file </font></font><code>image.bin</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The same integrity check that was performed</font></font><code>ReWriter_read</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, performed on a new merged image. </font><font style="vertical-align: inherit;">Then the image read from the SPI flash memory is compared with the patched image in the memory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If any bytes are different, their address is logged. </font><font style="vertical-align: inherit;">The presence or absence of differences does not affect the progress of the malicious program. </font><font style="vertical-align: inherit;">This information is recorded only so that the operators understand what is happening. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the final stage, the registry key is set to the value: </font></font><br><br> <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\BootExecute = ‚Äúautocheck autochk *‚Äù</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then the RwDrv service is stopped and deleted. </font><font style="vertical-align: inherit;">It is important that the key of the Windows system registry is assigned the value of this string, since the UEFI rootkit searches for this string in order to modify it and execute its component during the Windows startup process. </font><font style="vertical-align: inherit;">We will tell you more about this when we describe the UEFI rootkit and its components.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Technical Analysis LoJax </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The tool for dumping, patching and writing to SPI flash memory is customized for a specific firmware image and cannot be used on any system. In this case, the full module UEFI can be selected. The first thing we did after receiving this module was to study the telemetry data to find out if it had been encountered before. In this, we had to rely on a new UEFI scanner that can scan the system firmware. We found that the UEFI module of the Sednit group was installed at least once in the system, which means that this rootkit is actually in-the-wild.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It has not yet been established how malicious tools were delivered to compromised systems. Most likely, other programs were used for this - for example, XAgent. Tools for dumping and writing were found in the same system, but at different times, the operators probably worked in several stages. First, they unloaded the firmware on the target machine, made sure that the tool for making adjustments to the program works without failures, and then re-uploaded it and already actually patched the firmware. We found only one version of the tool for dumping and writing, but there is a possibility that there are other versions for other firmware with vulnerabilities that they could find.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure below provides an overview of the operation of the UEFI rootkit up to the OS boot. </font><font style="vertical-align: inherit;">First, the SecDxe DXE driver is loaded by the DXE controller. </font><font style="vertical-align: inherit;">This is how the event group notification function is configured </font></font><code>EFI_EVENT_GROUP_READY_TO_BOOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When the firmware is ready to select the boot device and start the OS loader, the notification function is called. </font><font style="vertical-align: inherit;">She performs three actions:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loads the built-in NTFS DXE driver to provide access and write access to NTFS partitions </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> writes two files to the NTFS section of Windows: rpcnetp.exe and autoche.exe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes the registry key 'HKEY_LOCAL_MACHINE \ SYSTEM \ CurrentControlSet \ Control \ Session Manager \ BootExecute': to: 'autocheck autochk *'; </font><font style="vertical-align: inherit;">after: 'autocheck autoche *'.</font></font></li></ul><br><img src="https://habrastorage.org/webt/at/qy/ec/atqyecti3adwerrfljy0ccirxgy.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 14. The boot process of a UEFI rootkit-infected system</font></font></i> <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SecDxe: Malicious DXE driver </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, we will reveal the sequence of events occurring in the compromised system. Let's start with a description of the rootkit, and then follow the chain of events down to the final components deployed at the operating system level. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The UEFI rootkit of the Sednit group is a DXE driver with a GUID identifier </font></font><code>682894B5-6B70-4EBA-9E90-A607E5676297</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is not signed, so it cannot be run on a system with Secure Boot protection enabled. After being deployed to one of the firmware volumes, the DXE Foundation loads it on every system startup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SecDxe is a small DXE driver that basically does two things. It establishes a protocol defined by GUID</font></font><code>832d9b4d-d8d5-425f-bd52-5c5afb2c85dc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which is never used. It then creates an event associated with the notification function. The notification function is configured to call, by a signal to the group </font></font><code>EFI_EVENT_GROUP_READY_TO_BOOT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The signal for this group of events comes from the download manager when it is ready to select a device for loading. </font></font><br><br><img src="https://habrastorage.org/webt/sj/ff/6o/sjff6ohskqe2ewtsv8xnyis3oss.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 15. The result of the Hex-Rays decompiler passing through the event creation process</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The notification function uses the malicious behavior of the Sednit rootkit UEFI. She writes components to the NTFS Windows file system. As a rule, the UEFI firmware alone works with the EFI partition, so the NTFS driver is usually not included. Only FAT file systems are supported as partitions for download. Therefore, UEFI firmware does not necessarily come bundled with NTFS drivers. For this reason, SecDxe has its own built-in NTFS driver. This driver is loaded first and connects to the disk device. That is, it installs </font></font><code>EFI_SIMPLE_FILE_SYSTEM_PROTOCOL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on disk devices with NTFS partitions, thus including file access to them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that you are ready to write files to Windows partitions, SecDxe resets </font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>autoche.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. It </font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is </font><font style="vertical-align: inherit;">then </font><font style="vertical-align: inherit;">installed </font></font><code>%WINDIR%\SysWOW64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on 64-bit versions of Windows or</font></font><code>%WINDIR%\System32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on 32-bit versions. </font><font style="vertical-align: inherit;">A </font></font><code>autoche.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set to </font></font><code>%WINDIR%\SysWOW64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The following figure shows the process responsible for writing these files to disk. </font></font><br><br><img src="https://habrastorage.org/webt/si/jo/pn/sijopnar5xrablwh02xdrv5e37a.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 16. The result of the Hex-Rays decompiler passing through the process of writing files to a disk.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then SecDxe opens a </font></font><code>%WINDIR%\System32\config\SYSTEM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file with a backup of a set of registry keys </font></font><code>HKLM\SYSTEM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It parses the file until it finds </font></font><code>'autocheck autochk *'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and replaces </font></font><code>'k'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in </font></font><code>'autochk'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with </font></font><code>'e'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As a result, </font></font><code>'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\ BootExecute'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes to </font></font><code>'autocheck autoche *'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The next time you boot Windows, autoche.exe will be launched instead </font></font><code>autochk.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NTFS driver from Hacking Team </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As previously discussed, the NTFS driver is built into the SecDxe module. There is strong evidence that the Sednit operators did not write their own driver, but compiled a copy of the published NTFS DXE driver from the Hacking Team. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Their NTFS driver uses the ntfs-3g project as the kernel. This is just a wrapper to make it work as a UEFI DXE driver. The INF file itself with the Hacking Team driver build information lists the ntfs-3g project file names. Many of these file names are also listed in the SecDxe NTFS driver code lines: </font><font style="vertical-align: inherit;">It is interesting to note that the path to the project is the same as what can be found in vector-edk, the Hacking Team project on EFI development. There is a subproject in vector-edk</font></font><br><br> <code>- c:\edk2\NtfsPkg\NtfsDxe\ntfs\inode.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\volume.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\bootsect.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\unistr.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\attrib.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\mft.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\index.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\cache.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\misc.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\dir.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\runlist.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\logfile.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\uefi_io.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\ntfsinternal.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\mst.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\lcnalloc.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\compress.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\bitmap.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\collate.c <br> - c:\edk2\NtfsPkg\NtfsDxe\ntfs\security.c</code> <br> <br><font style="vertical-align: inherit;"></font><code>NtfsPkg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with absolutely identical directory scheme. The source code files for the ntfs-3g project are located at the same address path. And although the paths themselves are not remarkable, we believe that this is not a mere coincidence. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparing the source code leaked to the network with what we got at the output of the Hex-Rays decompiler, it becomes obvious that this is the same project. The figure below shows an example of comparing a function </font></font><code>NtfsDriverBindingStart</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">taken from </font></font><code>vector-edk/NtfsPkg/NtfsDxe/Ntfs.c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Comments from the original HT code are removed for better perception. The logic and sequence of function calls are the same. Both projects even use the same variable (LockedByMe) to save the locked state. </font></font><br><br><img src="https://habrastorage.org/webt/qn/-k/ut/qn-kutvxgtnyuqkcvvo8zwfglya.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 17. Comparison of results at the output of the Hex-Rays NTFS decompiler of the Sednit driver (left) and the NTFS HT driver (right)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Above is the code for developers from the Hacking Team, not in the open source ntfs-3g. As mentioned in the section </font></font><code>ReWriter_binary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, in the process of parsing the firmware file system, the executable file tries to remove the AMI NTFS driver. We wanted to figure out why it is being removed instead of being used.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We analyzed the driver and found that it can only perform read operations. Since the record in the file system is not available, the developers could not use it for their own purposes. It is also likely that the Sednit operators encountered difficulties due to the fact that the firmware already has another NTFS driver, so they decided to just remove it. In addition to implementing the ability to read and write, the Hacking Team driver does not comply with file permissions. For example, it can rewrite the file as read-only, without causing any error.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, we have already described the various operations to compromise the system performed by the UEFI rootkit. </font><font style="vertical-align: inherit;">We also discussed the reasons why we believe that the Sednit operators used the Hacking Team vector-edk source code to develop their NTFS driver to write files to the NTFS partitions of Windows. </font><font style="vertical-align: inherit;">In the following, we will present an analysis of the components delivered by SecDxe.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autoche.exe vs. </font><font style="vertical-align: inherit;">autochk.exe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The malware is </font></font><code>autoche.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to ensure the persistence of the mini-agent </font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As can be seen in the following figure, it uses native calls to the Windows API to create a service. </font></font><br><br><img src="https://habrastorage.org/webt/wc/dk/fv/wcdkfvfmcoog14t1orjmryouwd4.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 18. Malicious autoche .exe configures the rpcnetp.exe persistence.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It should be noted that the service name is the same as the legitimate Computrace agent uses. After creating the service, it restores the previous value of the registry key </font></font><code>BootExecute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/yz/wc/lj/yzwclj1loxeconb728wvsxqvyse.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 19. Malicious autoche.exe restores the original value of the registry key BootExecute</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since the process occurs during Windows startup, the user is unlikely to notice a change in the key value</font></font><code>BootExecute</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It should be noted that in autoche .exe there are some similarities with the autochk.exe module in Computrace, for example, the API calls used and the registration of services, but the rest is quite different. </font><font style="vertical-align: inherit;">The Computrace module is larger and it restores the original executable file </font></font><code>autochk.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead of changing the registry key. </font><font style="vertical-align: inherit;">It is also responsible for introducing a mini-agent to disk, while for LoJax this is done by the UEFI rootkit.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rpcnetp.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While the mini-agent </font></font><code>rpcnetp.exe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be implemented by a UEFI rootkit, there is a chance that in most cases, when we found a Trojanized version of LoJack, the mini-agent did not use this component. It is likely that they proceeded from opportunistic considerations and installed a UEFI rootkit, only when they had such an opportunity, and in organizations that are most interesting to them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">During the investigation, we discovered various versions of the LoJax mini-agent. The list of indicators of compromise shows their hashes and corresponding domains / IP addresses. As we have said, all the samples found were a trojanized version of the same old Computrace agent compiled in 2008.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have never seen a LoJax agent download and install additional modules, but we know that such functionality exists. </font><font style="vertical-align: inherit;">Since the best qualities of LoJax are stealth and persistence, it can be accurately used to provide access to key resources.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preventing and eliminating consequences </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To prevent an attack, a complex ecosystem consisting of many active components is needed. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first security mechanism that could block such an attack is the Secure Boot. When Secure Boot is enabled, each firmware downloadable component of the firmware itself must be properly signed, thus ensuring its integrity.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We recommend </font></font><a href="https://habr.com/company/eset/blog/425251/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enabling</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secure Boot, this is a basic defense against attacks on UEFI firmware. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As with software, the UEFI firmware should always be updated in a timely manner. Visit the website of the motherboard manufacturer to make sure you have the latest version available.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You should also make sure that all your systems are equipped with modern chipsets with Platform Controller Hub (starting with Intel Series 5 chipsets and beyond). This will ensure the operation of security mechanisms against the ‚Äúrace condition vulnerability,‚Äù which, as we </font></font><a href="https://www.kb.cert.org/vuls/id/766164"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have indicated</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , is present in the platform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another part of the security firmware in the hands of vendors UEFI / BIOS. The security mechanisms provided by the platform must be properly configured with system firmware in order to truly ensure its protection. Therefore, the firmware should be initially built with an understanding of security measures. Fortunately, more and more security researchers are paying attention to the security of the firmware, attracting the attention of vendors. Also worth mentioning is </font></font><a href="https://github.com/LongSoft/UEFITool"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CHIPSEC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, an open source framework that performs a low-level security assessment to help determine if the platform is properly configured. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eliminating the consequences of compromising through UEFI firmware is a difficult task. There are no easy ways to clean up the system from such threats, and there are no special security products that could fix everything. In the case described here, to remove the rootkit, you need to flash the SPI flash memory. This is not a trivial task, it is not suitable for the average user. Updating the UEFI firmware can remove the rootkit if the entire SPI area of ‚Äã‚Äãthe flash memory is copied. If a UEFI flashing is not possible, the only solution is to replace the motherboard of the infected system.</font></font><br><br><h2>  findings </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UEFI rootkit is one of the most dangerous and powerful tools of attackers due to the high persistence and immunity to reinstalling the OS and replacing the hard drive, as well as the exceptional difficulty of detection and removal. Although the UEFI system image is difficult to change, few solutions allow you to scan UEFI modules and identify malicious ones among them. Moreover, cleaning the UEFI firmware means flashing it, not an ordinary operation that a regular user cannot perform. These advantages explain why cyber-groups that are not limited in resources will continue to attack UEFI systems. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For any questions about this work, please contact threatintel@eset.com. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We want to thank those who work on the opensecuritytraining.info project. Course</font></font><a href="http://opensecuritytraining.info/IntroBIOS.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction to BIOS &amp; SMM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> helped us a lot when we analyzed interactions with the SPI flash chip.</font></font><br><br><h2>  Glossary </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See the </font></font><a href="https://www.intel.com/content/dam/www/public/us/en/documents/datasheets/7-series-chipset-pch-datasheet.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specifications </font><font style="vertical-align: inherit;">for a more detailed description of abbreviations. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- BIOS_CNTL: BIOS Control Register </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- BIOSWE: BIOS Write Enabled </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- BLE: BIOS Lock Enabled </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- FADDR: Flash Address </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- FDATAX: Flash Data from FDATA0 to FDATAN </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- FDBC: Flash Data Byte Count </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- FGO: Flash Cycle Go </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- HSFC: Hardware Sequencing Flash Control </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- HSFS: Hardware Sequencing Flash Status </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- IOCTL: Input / Output Control </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- PCH: Platform Controller Hub </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- RCBA: Root Complex Register Address </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Block </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- RCRB: </font><font style="vertical-align: inherit;">Root Complex Register Block </font><font style="vertical-align: inherit;">- SCIP: SPI Cycle in Progress </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- SMI: System Management Interrupt </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- SMM: System Management Mode</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- SMM_BWP: SMM BIOS Write Protect Disable </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- SPI: Serial Peripheral Interface</font></font><br><br><h2>  Indicators of compromise </h2><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ReWriter_read.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection of ESET </font></font><br> <code>Win32/SPIFlash.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>ea728abe26bac161e110970051e1561fd51db93b</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ReWriter_binary.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection of ESET </font></font><br> <code>Win32/SPIFlash.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>cc217342373967d1916cb20eca5ccb29caaf7c1b</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secdxe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection of ESET </font></font><br> <code>EFI/LoJax.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>f2be778971ad9df2082a266bd04ab657bd287413</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> info_efi.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection of ESET </font></font><br> <code>Win32/Agent.ZXZ</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>4b9e71615b37aea1eaeb5b1cfa0eee048118ff72</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autoche.exe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection of ESET </font></font><br> <code>Win32/LoJax.A</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>700d7e763f59e706b4f05c69911319690f85432e</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EXE mini agent </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detection of ESET </font><font style="vertical-align: inherit;">SHA-1</font></font><br> <code>Win32/Agent.ZQE <br> Win32/Agent.ZTU</code> <br><font style="vertical-align: inherit;"></font><br> <code>1771e435ba25f9cdfa77168899490d87681f2029 <br> ddaa06a4021baf980a08caea899f2904609410b9 <br> 10d571d66d3ab7b9ddf6a850cb9b8e38b07623c0 <br> 2529f6eda28d54490119d2123d22da56783c704f <br> e923ac79046ffa06f67d3f4c567e84a82dd7ff1b <br> 8e138eecea8e9937a83bffe100d842d6381b6bb1 <br> ef860dca7d7c928b68c4218007fb9069c6e654e9 <br> e8f07caafb23eff83020406c21645d8ed0005ca6 <br> 09d2e2c26247a4a908952fee36b56b360561984f <br> f90ccf57e75923812c2c1da9f56166b36d1482be</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Team Server Domain Names </font></font></h4><br> <code>secao[.]org <br> ikmtrust[.]com <br> sysanalyticweb[.]com <br> lxwo[.]org <br> jflynci[.]com <br> remotepx[.]net <br> rdsnets[.]com <br> rpcnetconnect[.]com <br> webstp[.]com <br> elaxo[.]org</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Team Server IP Addresses </font></font></h4><br> <code>185.77.129[.]106 <br> 185.144.82[.]239 <br> 93.113.131[.]103 <br> 185.86.149[.]54 <br> 185.86.151[.]104 <br> 103.41.177[.]43 <br> 185.86.148[.]184 <br> 185.94.191[.]65 <br> 86.106.131[.]54</code> <br> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mini agent dll </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detecting ESET </font></font><br> <code>Win32/Agent.ZQE</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHA-1 </font></font><br> <code>397d97e278110a48bd2cb11bb5632b99a9100dbd</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Command Server Domain Names Command Server </font></font><br> <code>elaxo.org</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP Addresses</font></font><br> <code>86.106.131[.]54</code> </div><p>Source: <a href="https://habr.com/ru/post/425251/">https://habr.com/ru/post/425251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425241/index.html">Developer 20 years later: Vasily Lebedev about ICRE, education, his book and programming</a></li>
<li><a href="../425243/index.html">The john willis handbook</a></li>
<li><a href="../425245/index.html">Preview RamblerFront & # 6</a></li>
<li><a href="../425247/index.html">Crowdsourcing Testing</a></li>
<li><a href="../425249/index.html">How is familiarity with the LLP at ITMO University: the course "Low-level programming"</a></li>
<li><a href="../425253/index.html">Making a machine learning project in Python. Part 1</a></li>
<li><a href="../425255/index.html">Broo lossless compression algorithm and delta encoding, compared with Xdelta3. Home project development</a></li>
<li><a href="../425259/index.html">Backing up your site with git and a makefile</a></li>
<li><a href="../425261/index.html">EV certificates are dead</a></li>
<li><a href="../425263/index.html">IFEST festival will be held in Nizhny Novgorod</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>