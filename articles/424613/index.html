<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Experience of using redux without reducers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to share my experience of using redux in an enterprise application. Speaking about corporate software within the article, I focus on the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Experience of using redux without reducers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/nn/at/cx/nnatcxzguqw8cg7b1nx315f3c8y.jpeg"><br><br>  I would like to share my experience of using redux in an enterprise application.  Speaking about corporate software within the article, I focus on the following features: <br><br><ul><li>  First, it is the amount of functionality.  These are systems that have been developed for many years, continuing to build new modules, or to infinity complicating what is already there. </li><li>  Secondly, often, if we consider not a presentation screen, but someone's workplace, then a huge number of linked components can be mounted on one page. </li><li>  Thirdly, the complexity of business logic.  If we want to get a responsive and pleasant-to-use application, much of the logic will have to be made client-side. </li></ul><br>  The first two points impose limitations on the performance margin.  More on this later.  And now, I propose to discuss the problems that you encounter, using the classic redux - workflow, developing something more complicated than the TODO - list. <br><a name="habracut"></a><br><h3>  Classic redux </h3><br>  For example, consider the following application: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://image.ibb.co/ej3Pwp/1.png" alt="image"><br><br>  The user drives a poem - gets an assessment of his talent.  The control with the verse input is controlled and the estimate is recalculated for each change.  There is also a button that resets the text with the result, and a message is shown to the user that he can start from the beginning.  Source code in this <a href="https://github.com/dmitrii-khr/selectorsTreeExample/tree/1_ClassicRedux">thread</a> . <br><br>  Code organization: <br><br><img src="https://image.ibb.co/dyXv2U/2.png" alt="image"><br><br>  There are two modules.  More precisely, one direct module is poemScoring.  And the root of the application with functions common to the whole system is app.  There we have information about the user, display messages to the user.  Each module has its own reduction gear, actions, controls, etc. As the application grows, new modules multiply. <br><br>  The cascade of reduers, using the redux-immutable, forms the following fully immutable state: <br><br><img src="https://image.ibb.co/nFrYp9/3.png" alt="image"><br><br>  How it works: <br><br>  1. Control action-creator dispatch: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants/actionTypes'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemTextChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getstate</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: at.POEM_TYPE, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: text }); }; }</code> </pre> <br>  The action type constants are moved to a separate file.  First, we are so safe from typos.  Secondly, we will be available intellisense. <br><br>  2. Then it comes to the reducer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logic <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../logic/poem'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemScoringReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = Immutable.Map(</span></span></span><span class="hljs-function">), </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> at.POEM_TYPE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logic.onType(state, action.payload); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; } }</code> </pre> <br>  The processing of logic is moved to a separate <a href="https://redux.js.org/recipes/structuringreducers/refactoringreducersexample">case function</a> .  Otherwise, the code of the viewer will quickly become unreadable. <br><br>  3. Logic of processing of pressing, using lexical analysis and artificial intelligence: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { onType(state, text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state .set(<span class="hljs-string"><span class="hljs-string">'poemText'</span></span>, text) .set(<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calcScore(text)); }, calcScore(text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(text.length / <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">5</span></span> : score; } };</code> </pre> <br>  In the case of the ‚ÄúNew poem‚Äù button, we have the following action-creator: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newPoem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getstate</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: at.POEM_TYPE, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }); dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: appAt.SHOW_MESSAGE, <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: <span class="hljs-string"><span class="hljs-string">'You can begin a new poem now!'</span></span> }); }; }</code> </pre> <br>  First, dispute the same action, which resets our text and evaluation.  Then, we send an action that will be caught by another reducer and will display a message to the user. <br>  Everything is beautiful.  Let's create our own problems: <br><br><h3>  Problems: </h3><br>  We posted our app.  But our users, having seen that they were asked to write poems, naturally began to post their work, which is incompatible with the corporate standards of poetic language.  In other words, we need to moderate obscene words. <br><br>  What do we do: <br><br><ul><li>  In the entered text it is necessary to replace all uncultured words with <b>* censored *</b> </li><li>  In addition, if the user hammered a dirty word, you need to warn him with a message that he is doing wrong. </li></ul><br>  Good.  We just need to, in the course of the text analysis, in addition to calculating the assessment, replace bad words.  No problem.  And yet, for the message to the user, you will need a list of what we deleted.  The source code is <a href="https://github.com/dmitrii-khr/selectorsTreeExample/tree/2_ClassicRedux_problem">here</a> . <br><br>  We are remaking the logic function so that it, in addition to the new state, returns the information necessary for the message to the user (replaced words): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> { onType(state, text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { reductedText, censoredWords } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.redactText(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> newState = state .set(<span class="hljs-string"><span class="hljs-string">'poemText'</span></span>, reductedText) .set(<span class="hljs-string"><span class="hljs-string">'score'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.calcScore(reductedText)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { newState, censoredWords }; }, calcScore(text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(text.length / <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score &gt; <span class="hljs-number"><span class="hljs-number">5</span></span> ? <span class="hljs-number"><span class="hljs-number">5</span></span> : score; }, redactText(text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = { <span class="hljs-attr"><span class="hljs-attr">reductedText</span></span>:text }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> censoredWords = []; obscenseWords.forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">badWord</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.reductedText.indexOf(badWord) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { result.reductedText = result.reductedText.replace(badWord, <span class="hljs-string"><span class="hljs-string">'*censored*'</span></span>); censoredWords.push(badWord); } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (censoredWords.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { result.censoredWords = censoredWords.join(<span class="hljs-string"><span class="hljs-string">' ,'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } };</code> </pre> <br>  Let's apply it now.  But how?  In the reducer, we no longer have to call it, since we will put the text and the assessment in the state, but what to do with the message?  To send a message, we, in any case, have to dispute the appropriate action.  So we are finalizing the action-creator. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemTextChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> globalState = getState(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scoringStateOld = globalState.get(<span class="hljs-string"><span class="hljs-string">'poemScoring'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        const { newState, censoredWords } = logic.onType(scoringStateOld, text); dispatch({ //        type: at.POEM_TYPE, payload: newState }); if (censoredWords) { //    ,    const userName = globalState.getIn(['app', 'account', 'name']); const message = `${userName}, avoid of using word ${censoredWords}, please!`; dispatch({ type: appAt.SHOW_MESSAGE, payload: message }); } }; }</span></span></code> </pre> <br>  It is also required to modify the reducer, since it no longer calls the logic function: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (action.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> at.POEM_TYPE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action.payload; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state;</code> </pre> <br>  What happened: <br><br><img src="https://image.ibb.co/nkmzU9/4.png" alt="image"><br><br>  <b>And now, the question arises.</b>  Why do we need a reducer, which, for the most part of the actions, will simply return payload instead of a new state?  When other actions appear that process the logic in the action, will it be necessary to register the new type action-type?  Or maybe create one common SET_STATE?  Probably not, because then, there will be a mess in the inspector.  Means we will produce the same case? <br><br>  The essence of the problem is as follows.  If the processing of logic involves working with a piece of state, for which several reducers are responsible, then you have to write all sorts of perversions.  For example, the intermediate results of case functions, which are then necessary with the help of several actions, should be scattered across various reducers. <br><br>  A similar situation, if for the case function you need more information than there is in your reducer, you have to make its call to the action, where there is access to global steel content, and then send the new state as payload.  And it will be necessary to split up reductors anyway, if there is a lot of logic in the module.  And it creates great inconvenience. <br><br>  Let's look at the situation on the one hand.  We in our action get a piece of state from the global.  This is required to <i>mutate</i> it ( <i>globalState.get ('poemScoring');</i> ).  It turns out, we already in the action know with which piece of the state we are working.  We have a new piece of state.  We know where to put it.  But instead of putting it into the global one, we run it with some text constant across the cascade of reducers, so that it passes through each switch-case, and substitutes one single time.  From the realization of this, roar me.  I understand that this is done for ease of development and reduced connectivity.  But in our case, it no longer has a role. <br><br>  <b>Now, I will list all the points that I don‚Äôt like in the current implementation, if I‚Äôll have to scale it in breadth and deeper for an unlimited time</b> : <br><br><ol><li>  Significant inconvenience when working with a state that is outside of the reducer. </li><li>  The problem of code separation.  Every time we dispute an action, it passes through each reducer, passes through each case.  This is convenient, do not bother when you have a small application.  But, if you have a monster that has been built for several years with dozens of reducers and hundreds of cases, then I begin to think about the expediency of such an approach.  Perhaps, even with thousands of cases, it can not have a significant impact on speed.  But, realizing that when typing a text, each press will cause a passage through hundreds of cases, I cannot leave it as it is.  Any, the smallest lag multiplied by infinity tends to infinity.  In other words, if you do not think about such things, sooner or later, problems will appear. <br><br>  What are the options? <br><br>  <b>a.</b>  Isolated applications with their own <a href="https://redux.js.org/recipes/isolatingsubapps">providers</a> .  It is necessary to duplicate the common parts of the state (account, messages, etc.) in each module (sub-application). <br><br>  <b>b.</b>  Use plug-in <a href="https://gist.github.com/gaearon/0a2213881b5d53973514">asynchronous reducers</a> .  This is not recommended by Dan himself. <br><br>  <b>c.</b>  Use <a href="https://redux.js.org/recipes/structuringreducers/beyondcombinereducers">action filters</a> in the reducer.  That is, each dispatch is accompanied by information on which module it is sent to.  And in the root modules reducer, set the appropriate conditions.  I tried.  This amount of involuntary errors was not before or after.  Constant confusion with where the action is sent. </li><li>  Every time there is an action dispatch, not only the run on each reducer takes place, but also the return state is collected.  It doesn‚Äôt matter if the condition in the reducer has changed - it will be replaced in combineReducers. </li><li>  Each dispatch causes the mapStateToProps to be processed for each associated component that is mounted on the page.  If we split up reductors, we have to split up disputes.  Is it critical that we use the button to wipe the text and display a message using different dispatch?  Probably not.  But I have optimization experience when reducing the number of disputes from 15 to 3 allowed us to significantly increase the responsiveness of the system, while the amount of business logic that was processed was unchanged.  I know that there are libraries that can combine several disputes into one batch, but this is a struggle with the investigation with the help of crutches. </li><li>  When crushing disputes, it is sometimes very difficult to see what happens after all.  No one place, everything is scattered in different files.  It is necessary to search where the processing is implemented through the search for constants for all sources. </li><li>  In the above code, components and actions refer directly to the global state: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userName = globalState.getIn([<span class="hljs-string"><span class="hljs-string">'app'</span></span>, <span class="hljs-string"><span class="hljs-string">'account'</span></span>, <span class="hljs-string"><span class="hljs-string">'name'</span></span>]); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> text = state.getIn([<span class="hljs-string"><span class="hljs-string">'poemScoring'</span></span>, <span class="hljs-string"><span class="hljs-string">'poemText'</span></span>]);</code> </pre> <br>  This is not good for several reasons: <br><br>  <b>a.</b>  Modules should ideally be isolated.  They do not need to know where in the state they live. <br><br>  <b>b.</b>  Mentioning the same paths in different places is often fraught with not only errors / misprints, but it also makes it extremely difficult to refactor if the global state changes or changes its storage method. <br></li><li>  Increasingly, while writing a new action, I had the impression that I was writing code for the sake of code.  Suppose we want to add a box to the check page and reflect its boolean state in the stack.  If we want a uniform organization of actions / reduers, we will have to: <br><br>  - Register action-type constant <br>  - Write action crater <br>  - In control, import it and register in mapDispatchToProps <br>  - Register in PropTypes <br>  - Create a handleCheckBoxClick in the control and enter it in the check box <br>  - Add a switch in the reducer with a case function call <br>  - Write a case function in logic <br><br>  For the sake of one boxing check! </li><li>  The state that is generated by combineReducers is static.  It doesn't matter if you entered module B or not, this piece will be in the stack.  Empty, but will be.  It is not convenient to use the inspector when there are a lot of unused empty nodes in the stack. </li></ol><br><h3>  How we try to solve some of the problems described above. </h3><br>  So, we have stupid redusers, and in action-craytor / logic we write footcloths code to work with deeply embedded immutable structures.  To get rid of this, I use the mechanism of hierarchical selectors, which allow not only access to the required piece of state, but also carry out its replacement (convenient setIn).  I posted this in the <a href="https://www.npmjs.com/package/immutable-selectors">immutable-selectors</a> package. <br><br>  <b>Let's take a look at our example of how it works</b> ( <a href="https://github.com/dmitrii-khr/selectorsTreeExample">repository</a> ): <br>  We describe in the poemScoring module, the object of selectors.  We describe those fields from the state that we want to have direct read / write access to.  Any nesting and parameters for accessing the elements of the collections are allowed.  It is not necessary to describe all possible fields in our stack. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> extendSelectors <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'immutable-selectors'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectors = { <span class="hljs-attr"><span class="hljs-attr">poemText</span></span>:{}, <span class="hljs-attr"><span class="hljs-attr">score</span></span>:{} }; extendSelectors(selectors, [ <span class="hljs-string"><span class="hljs-string">'poemScoring'</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> selectors;</code> </pre> <br>  Further, the extendSelectors method turns each field in our object into a selector function.  The second parameter indicates the path to that part of the state, which is controlled by the selector.  We do not create a new object, but modify the current one.  This gives us a bonus in the form of worker intelligence: <br><br><img src="https://image.ibb.co/iYdDp9/5.png" alt="image"><br><br>  What is our object - the selector after its expansion: <br><br><img src="https://image.ibb.co/iAGcGp/5_5.png" alt="image"><br><br>  The <i>selectors.poemText (state)</i> function simply executes <i>state.getIn (['poemScoring', 'poemText'])</i> . <br><br>  The <i>root (state)</i> function gets 'poemScoring'. <br><br>  Each selector has its own function <i>replace (globalState, newPart)</i> , which through setIn returns a new global state with the corresponding part replaced. <br><br>  Also, a <i>flat</i> object is added to which all unique selector keys are duplicated.  That is, if we use the deep state of the form <br><br><pre> <code class="javascript hljs">selectors = { <span class="hljs-attr"><span class="hljs-attr">dive</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">in</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">to</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">the</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">deep</span></span>:{} } } } }}</code> </pre> <br>  You can get deep as <i>selectors.dive.in.to.the.deep (state)</i> or <i>selectors.flat.deep (state)</i> . <br><br>  Go ahead.  We need to update the data acquisition in the controls: <br><br>  Poem: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapStateToProps</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, ownprops</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">text</span></span>:selectors.poemText(state) || <span class="hljs-string"><span class="hljs-string">''</span></span> }; }</code> </pre> <br><br>  Score: <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapStateToProps</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, ownprops</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> score = selectors.score(state); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { score }; }</code> </pre> <br>  Next, change the root reducer: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> initialState <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./initialState'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setStateReducer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state = initialState, action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.setState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> action.setState; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> state; <span class="hljs-comment"><span class="hljs-comment">// return combinedReducers(state, action); // } } export default setStateReducer;</span></span></code> </pre> <br>  If desired, we can combine using combineReducers. <br><br>  Action-caster, on the example of poemTextChange: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poemTextChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dispatch, getState</span></span></span><span class="hljs-function">) </span></span>{ dispatch({ <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'Poem typing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">setState</span></span>: logic.onType(getState(), text), <span class="hljs-attr"><span class="hljs-attr">payload</span></span>: text }); }; }</code> </pre> <br>  We can no longer use action-type constants, since type is now used only for visualization in the inspector.  We in the project write full-text descriptions of the action in Russian.  You can also get rid of payload, but I try to save it, so that in the inspector, if necessary, to understand with what parameters the action was called. <br><br>  And, actually, the logic itself: <br><br><pre> <code class="javascript hljs"> onType(gState, text) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { reductedText, censoredWords } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.redactText(text); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> poemState = selectors.root(gState) || Immutable.Map(); <span class="hljs-comment"><span class="hljs-comment">//     const newPoemState = poemState //  .set('poemText', reductedText) .set('score', this.calcScore(reductedText)); let newGState = selectors.root.replace(gState, newPoemState); //    if (censoredWords) { //  ,    const userName = appSelectors.flat.userName(gState); const messageText = `${userName}, avoid of using word ${censoredWords}, please!`; newGState = message.showMessage(newGState, messageText); } return newGState; },</span></span></code> </pre> <br>  At the same time, <i>message.showMessage is</i> imported from the logic of the neighboring module, which describes its selectors: <br><br><pre> <code class="javascript hljs"> showMessage(gState, text) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> selectors.message.text.replace(gState, text); }.</code> </pre> <br>  What happens: <br><br><img src="https://image.ibb.co/hviDp9/6.png" alt="image"><br><br>  Note that we had one dispatch, the data in two modules changed. <br>  All this allowed us to get rid of the reducers and constants of action-types, as well as to solve or circumvent the majority of the bottlenecks indicated above. <br><br><h4>  How else can this be applied? </h4><br>  This approach is convenient to use when it is necessary to ensure that your controls or modules provide work with different pieces of the state.  Suppose we lack one poem.  We want the user to compose poems in different disciplines (children, romantic) on two parallel tabs.  In this case, we can not import selectors in logic / controls, but indicate them as a parameter in the external control: <br><br><pre> <code class="javascript hljs"> &lt;Poem selectors = {selectors.hildPoem}/&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Poem</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">selectors</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{selectors.romanticPoem}/</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  And, further, to transfer this parameter to action-craters.  This is enough to make the complex combination of components and logic completely closed, making it easy to reuse. <br><br>  <b>Limitations when using immutable-selectors:</b> <br><br>  It will not be possible to use the key in the ‚Äúname‚Äù state, since for the parent function there will be an attempt to redefine the reserved property. <br><br><h3>  What is the result </h3><br>  As a result, a fairly flexible approach was obtained, the implicit code links by text constants were excluded, the overheads were reduced, while maintaining the convenience of development.  Also remained fully functioning redux inspector with the possibility of time travel.  I have no desire to return to standard reducers. <br><br>  In general, everything.  Thank you for your time.  Maybe someone will be interested in trying out! </div><p>Source: <a href="https://habr.com/ru/post/424613/">https://habr.com/ru/post/424613/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424603/index.html">The book "Why we are wrong. Traps thinking in action. " Excerpts part 1</a></li>
<li><a href="../424605/index.html">Zuckerberg funds: Collaboration + Technology + Open Science</a></li>
<li><a href="../424607/index.html">Helidon's takeoff</a></li>
<li><a href="../424609/index.html">How to expand Kubernetes</a></li>
<li><a href="../424611/index.html">How to create an employee from a freelancer</a></li>
<li><a href="../424615/index.html">Outputting the curve function for smoothly limiting parameters, signals and not only in Wolfram Mathematica</a></li>
<li><a href="../424619/index.html">Yandex will launch an open top runet site before the end of the year</a></li>
<li><a href="../424621/index.html">Non-carved superheroes. Who and how protects the construction site of Lakhta Center from fires?</a></li>
<li><a href="../424623/index.html">Let's process the sound on Go</a></li>
<li><a href="../424625/index.html">The leak of the source code of web services "Aeroflot"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>