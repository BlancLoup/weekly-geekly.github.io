<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Assembler for simulation tasks. Part 1: guest assembler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instructions, registers, and assembler directives are always required. 
 golang.org/doc/asm  On Habr√© and the Internet as a whole, there is quite a lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Assembler for simulation tasks. Part 1: guest assembler</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <sup>Instructions, registers, and assembler directives are always required.</sup> <sup><br></sup>  <sup><a href="https://golang.org/doc/asm">golang.org/doc/asm</a></sup> </blockquote>  On Habr√© and the Internet as a whole, there is quite a lot of information about the use of assembly languages ‚Äã‚Äãfor various architectures.  Scrolling through the available materials, I found that the areas of use of the assembler and related technologies that are most often highlighted in them are as follows: <br><ol><li>  Embedded (embedded) systems. </li><li>  Decompilation, reverse engineering, computer security. </li><li>  High performance computing (HPC) and program optimization. </li></ol> And of course, in each of these areas there are specific requirements, and therefore their own concepts about the tools and "their" assembler.  Embaders look into the code through the editor and debugger, reverse engineers see it in decompilers like IDA and radare2 and ICE debuggers, and HPC specialists through profilers such as Intel¬Æ VTune ‚Ñ¢ Amplifier, <code>xperf</code> or <code>perf</code> . <br>  And I wanted to talk about another programming area in which assemblers are frequent satellites.  Namely - about their role in the development of software models of computing systems, in common people called simulators. <br><a name="habracut"></a><br>  The objectives of this and subsequent articles are as follows. <br><ul><li>  Show another facet of using assembly language and programming in machine codes. </li><li>  To illustrate all three ways of using assembler in modern programs: through intrinsiki, through assembler inserts and through separate files. </li><li>  <s>Encourage yourself to update your own notes on how to write simulators of central processing units.</s> </li></ul><habracut><br>  The task of a software model of a computing device, such as a central processor, is to correctly simulate the operation of each machine instruction that occurs during the operation of a computer. <br>  The programmer working on the simulator is faced with the need to use the assembler at least three times: when parsing machine code instructions, when writing code that simulates their behavior, as well as when debugging your model. <br><br><h2>  Back and forth: decoding </h2><br>  The first thing that needs to be done with the machine instruction after retrieving it from memory is to find out its function, as well as with what arguments it operates. <br>  <i>Decoding</i> (in simulation) is the translation of a machine word read from the program's memory into an <i>internal representation of the</i> simulator, facilitating subsequent modeling.  In the decoding process, the bit fields described in the specification are extracted from the stream of generally faceless zeros and ones, their values ‚Äã‚Äãare compared with the valid ones, the values ‚Äã‚Äãof some fields are combined into one whole.  In general, the level of abstraction of available information about instructions increases: instead of shifting from the current instruction, the absolute address to go, instead of stubs of a literal argument, is a constant already collected and correctly extended by sign, instead of a mash of prefixes that redefine each other‚Äôs meaning and instructions in general ‚Äî accurate information about the width of the data address and the width of the operands, etc. <br><div class="spoiler">  <b class="spoiler_title">About decoder generation by description</b> <div class="spoiler_text">  The task of (soft) decoding machine instructions on the structure resembles the parsing of strings when parsing high-level languages ‚Äã‚Äã(which is done in the compiler frontends).  Both there and there at the entrance there is a language with a well-known grammar, and at the output - an intermediate representation corresponding to the phrase that was parsed.  In both cases, grammars are often difficult to implement parsing for them manually, so code generators from DSL (domain specific language) descriptions are used. <br>  For high-level languages, parser generators have been developed and successfully used: lexers in conjunction with scanners.  Here and <a href="http://tldp.org/HOWTO/Lex-YACC-HOWTO.html">Lex / YACC</a> , and <a href="http://www.antlr.org/">ANTLR,</a> and many other tools for all sorts of target languages. <br>  For machine languages, there are also decoder generators: <a href="">SimGen</a> , <a href="http://citeseerx.ist.psu.edu/viewdoc/download%3Bjsessionid%3D2446080A04B2DAF6544465AFC3D46787%3Fdoi%3D10.1.1.12.8498%26rep%3Drep1%26type%3Dpdf">ISDL</a> , <a href="">The New Jersey Machine-Code Toolkit</a> . <br>  What surprised me was the lack of projects on the use of classical parser generators to describe the grammar of machine languages.  Always use something of their own, self-made bicycle, albeit effective.  Machine languages ‚Äã‚Äãare not too simple, so that activating the Yacc turns out to be ‚Äúshooting sparrows with a cannon.‚Äù  They are hardly too complex for the expressiveness of ANTLR to be enough. <br>  I was so interested in the question that I even started a <a href="https://groups.google.com/forum/">discussion</a> on the ANTLR forum, but did not receive a clear answer there. <br></div></div><br>  <i>Disassembling</i> - translation of information about instructions from a machine representation into a text line, convenient for reading, processing and memorizing by a person - into <i>mnemonics</i> .  Unlike decoding results that are processed by a soulless machine and therefore must be unambiguous, the result of disassembling should be understandable to people.  In this case, it is even allowed to introduce a light ambiguity.  For example, the same mnemonic opus ‚ÄúPUSH‚Äù for Intel¬Æ IA-32 architecture will be used for a rather scattered group of machine instructions, some of which work with general-purpose registers, some with segment registers, some with memory operands, and part with literal constants.  The machine code and semantics of all variants of PUSH are very different, whereas the mnemonic record will be similar. <br>  It is no secret that even the syntax used for the mnemonic representation may be different;  talk about this in more detail below. <br>  In the simulator, disassembling is useful when implementing the built-in debugger, which allows even in the absence of the application source code to figure out whether it works correctly and whether the model executes instructions correctly. <br>  <i>(For) encoding</i> - the inverse decoding conversion from an internal representation to a machine code.  The ability to code instructions of the target architecture is essential and essential for assembler programs, whereas it is rarely required in the simulator.  For a simulator, the ability to code-generate is important if it ‚Äúwrites itself‚Äù, i.e.  is a binary translator.  In this case, it is required to create a code not for the guest (simulated, target), but for the host architecture.  More on this in the second part of the article. <br>  <i>Assembly</i> - translation of instructions from the mnemonic record to the intermediate representation (or immediately to the machine code).  This is the area of ‚Äã‚Äãresponsibility for various assembler programs: MASM, TASM, GAS, NASM, YASM, WASM, &lt;insert your favorite ASM&gt; ... <br><a name="variable-length"></a>  Since mnemonics are involved in the assembly process, we can expect ambiguities in the transformation.  Indeed, the assembler has the right to choose for any mnemonic any valid and satisfying machine code.  Most often he chooses the most compact format.  In the following listing, I use the <code>objdump</code> disassembler to illustrate what the vector VADDPS instruction with various arguments converted to the GNU <code>as</code> assembler translates to: <br><br><pre> <code class="hljs mel">$ cat vaddps1.s #  ,    - vaddps %ymm0, %ymm1, %ymm1 vaddps %ymm1, %ymm1, %ymm1 vaddps %ymm2, %ymm1, %ymm1 vaddps %ymm3, %ymm1, %ymm1 vaddps %ymm4, %ymm1, %ymm1 vaddps %ymm5, %ymm1, %ymm1 vaddps %ymm6, %ymm1, %ymm1 vaddps %ymm7, %ymm1, %ymm1 vaddps %ymm8, %ymm1, %ymm1 vaddps %ymm9, %ymm1, %ymm1 vaddps %ymm10, %ymm1, %ymm1 vaddps %ymm11, %ymm1, %ymm1 vaddps %ymm12, %ymm1, %ymm1 vaddps %ymm13, %ymm1, %ymm1 vaddps %ymm14, %ymm1, %ymm1 vaddps %ymm15, %ymm1, %ymm1 $ as vaddps1.s #  $ objdump -d a.out #  a.out: <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> pe-x86<span class="hljs-number"><span class="hljs-number">-64</span></span> Disassembly of section .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> c8 vaddps %ymm0,%ymm1,%ymm1 #  VEX <span class="hljs-number"><span class="hljs-number">4</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> c9 vaddps %ymm1,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">8</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> ca vaddps %ymm2,%ymm1,%ymm1 c: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> cb vaddps %ymm3,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">10</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> cc vaddps %ymm4,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">14</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> cd vaddps %ymm5,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">18</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> ce vaddps %ymm6,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">1</span></span>c: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> cf vaddps %ymm7,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">20</span></span>: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> c8 vaddps %ymm8,%ymm1,%ymm1 #  VEX <span class="hljs-number"><span class="hljs-number">25</span></span>: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> c9 vaddps %ymm9,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">2</span></span>a: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ca vaddps %ymm10,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">2</span></span>f: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> cb vaddps %ymm11,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">34</span></span>: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> cc vaddps %ymm12,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">39</span></span>: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> cd vaddps %ymm13,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">3</span></span>e: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> ce vaddps %ymm14,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">43</span></span>: c4 c1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> cf vaddps %ymm15,%ymm1,%ymm1</code> </pre><br>  In this example, I changed one of the source registers, going through all its options, from YMM0 to YMM15.  The instructions with the first eight registers YMM0-YMM7 could be encoded using the shorter two-byte prefix VEX, and GAS chose this format.  Whereas, for the YMM8-YMM15 range, instructions could only be presented using a three-byte VEX, and therefore turned out to be a byte longer.  In principle, nothing prevented the use in all cases of a three-byte VEX, but not: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs mel">$ cat vaddps2.s .byte <span class="hljs-number"><span class="hljs-number">0xc5</span></span>, <span class="hljs-number"><span class="hljs-number">0xf4</span></span>, <span class="hljs-number"><span class="hljs-number">0x58</span></span>, <span class="hljs-number"><span class="hljs-number">0xc8</span></span> #    VEX,      .byte <span class="hljs-number"><span class="hljs-number">0xc4</span></span>, <span class="hljs-number"><span class="hljs-number">0xe1</span></span>, <span class="hljs-number"><span class="hljs-number">0x74</span></span>, <span class="hljs-number"><span class="hljs-number">0x58</span></span>, <span class="hljs-number"><span class="hljs-number">0xc8</span></span> #    VEX $ as vaddps2.s $ objdump.exe -d a.out a.out: <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span> pe-x86<span class="hljs-number"><span class="hljs-number">-64</span></span> Disassembly of section .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>: <span class="hljs-number"><span class="hljs-number">0000000000000000</span></span> &lt;.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">0</span></span>: c5 f4 <span class="hljs-number"><span class="hljs-number">58</span></span> c8 vaddps %ymm0,%ymm1,%ymm1 <span class="hljs-number"><span class="hljs-number">4</span></span>: c4 e1 <span class="hljs-number"><span class="hljs-number">74</span></span> <span class="hljs-number"><span class="hljs-number">58</span></span> c8 vaddps %ymm0,%ymm1,%ymm1 #   ,    </code> </pre><br>  In this example, I show that the same mnemonic VADDPS with the first register YMM0 can be represented by at least two machine code sequences. <br><br>  And there are a lot of such tricks that assemblers of different architectures do.  For example, many RISC architectures do not have a machine representation for the operation ‚Äúcopy register X to register Y‚Äù, so the assembler converts the mnemonic <code>mov r1, r2</code> into code corresponding to <code>add 0, r1, r2</code> , i.e.  "Add r1 with zero and put the result in r2".  Another example: an assembler for the IA-64 architecture (Intel¬Æ Itanium) has to pack several instructions into one 128-bit machine bundle.  However, not all instructions are freely combined with each other: it is impossible to take and put them together because of a conflict over the computing resources that they consume.  We have to assembler or signal an error, or try to scatter instructions on different bundles.  The second approach requires the assembler to be aware of the number and organization of the execution nodes within the VLIW processor;  this is more like the work performed by the compiler. <br>  The inconvenience already mentioned above when using assemblers is that there are ugly many options for mnemonic instruction records (I leave aside non-architecture assembler differences, such as macro processing capabilities, supported ELF, PE output formats, and other ‚Äúsugar‚Äù).  How many tools, so many formats.  Even within the same target architecture, almost everything can differ in the record: the naming of opcodes, the naming of registers, the order of the operands, the way the addresses are written.  What to say about the different architectures! <br>  Once again, I want to emphasize that the underdeterminedness of a mnemonic record distinguishes disassembling from decoding and makes the first unsuitable for intermediate representation tasks. <br>  On the one hand, the ‚Äúcorrect‚Äù can be considered the syntax used by the original vendor of the equipment for which the assembler wants to use.  As written in the documentation for the processor, so the assembler should look. <br>  On the other hand, de facto for many architectures, a common entry is an assembler in a so-called.  AT &amp; T notation, the default in GNU binutils toolkit.  I use it in this article, even for examples of Intel architectures.  Somehow got used to it more.  GNU <code>as</code> is able to generate code for a very large number of systems, and it is practical to be able to understand exactly this notation. <br><br><div class="spoiler">  <b class="spoiler_title">Is there a standard for assembly language?</b> <div class="spoiler_text">  Good news: it turns out there is a standard - IEEE 694-1985 - IEEE Standard for Microprocessor Assembly Language.  The bad news: it turned out to be unnecessary, and is in the status of "withdrawn".  It was not possible to link all the variety of formats for CISC, RISC, VLIW, DSP into one book and still the devil knows which architectures. <br></div></div><br>  But in practice?  But in practice, you need to be able to recognize and read everything ‚Äî both the Intel notation, the AT &amp; T notation, and the notation of your favorite or unloved assembler program. <br>  The relationship between machine code views and their transformative processes is illustrated in the following figure. <br><img src="https://habrastorage.org/files/8fe/a04/8fd/8fea048fdabb409b9d2c2510529a822c.png"><br>  Temporarily miss the most interesting thing - the development of a simulation core;  leave it for dessert.  We now turn to another important task when creating a software simulator, namely, to test it. <br><br><h2>  Testing </h2><br>  How can I test the processor simulator?  Of course, you can try to run and debug software immediately compiled for it, including the BIOS, OS, and application programs.  However, the path is unproductive: debugging will be like a nightmare.  It is strategically more correct to first ensure that individual instructions are simulated correctly.  That is, check your code on unit tests. <br>  What operations should be in a unit test for a machine manual? <br><ol><li>  Set the registers and device memory to a known input state. </li><li>  Write the machine instruction code into memory and set the instruction pointer (PC, IP, RIP, IC register) at its beginning. </li><li>  Give the simulator a command to execute one instruction. </li><li>  Read the final state of the registers and memory. </li><li>  Compare condition with expected.  If there are differences, then look for the error either in the test or in the implementation of the simulating procedure. </li></ol><br>  Each such test will test one aspect of the instruction.  For the most complete test, many such tests will be required: some of them will check for ‚Äúnormal‚Äù work, another - situations in which exceptions should be generated (and they should check that an exception has actually occurred), and still others - ‚Äúboundary cases‚Äù in the instruction which, it seems, should not arise in normal programs, but in practice, according to Murphy's law, they will ‚Äúshoot‚Äù constantly. <br>  While ordinary applications run under the control of a particular operating system, it is not needed for unit tests.  Moreover, it is harmful: it takes time to load the OS, then it prevents processes from accessing system resources, the task scheduler tries to run something of its own, etc.  In general, the OS will consider itself the mistress of the system.  But this is what we command here with a simulator! <br>  An assembler comes to the rescue.  In most cases, for a unit test, we need to load the initial values ‚Äã‚Äãinto registers and memory, execute the instruction being studied and compare the changed values ‚Äã‚Äãin the registers and memory with the reference ones.  This is all fully formulated in assembly language;  higher-level languages ‚Äã‚Äãare often less convenient, as they may either not have the means to express the required functionality, or it may be helpful to ‚Äúoptimize‚Äù the resulting code by rearranging and replacing machine instructions. <br>  This assembly source file with the test should then be translated into the ELF or even a ‚Äúraw‚Äù memory image, loaded into the simulator, set the instruction pointer to the first one, determine what is the condition for the end of the test (a predetermined number of commands executed, ‚Äúmagic‚Äù instruction, achievement debug point, attempt to access the device, etc.) and what is the condition for success in the test (setting the flag, the known state of the processor). <br>  Of course, I'm a little cunning.  The minimum efficient environment for a unit test is not always easy to prepare.  Often, virtual memory is required, which means that the page tables set up for it, access rights and other pleasures.  The possibility of exceptions and interrupts requires at least a minimum configuration of the interrupt tables (in the Intel IA-32 architecture, IDT and GDT).  And checking work for instructions related to virtualization without the help of the OS means manual configuration of the virtual machine structures (in the case of Intel IA-32, this is VMCS). <br>  On the other hand, once created environment can be repeatedly reused in all tests, and how to configure it can be peeped in operating systems.  Well, or read the processor documentation. <br><br><h3>  To be continued </h3><br>  That's all for today.  In the next article I will show the place of the assembler when building a simulator kernel, directly involved in modeling guest code. <br><br>  Thanks for attention! </habracut></div><p>Source: <a href="https://habr.com/ru/post/254419/">https://habr.com/ru/post/254419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../254407/index.html">White paper on the availability of PhoneGap</a></li>
<li><a href="../254409/index.html">Payler 2.0 - work on the creation of a new site</a></li>
<li><a href="../254413/index.html">Grid, Data Grouping and OData</a></li>
<li><a href="../254415/index.html">Become the master of loading Linux</a></li>
<li><a href="../254417/index.html">How to get a neighbor or Karaoke on GStreamer</a></li>
<li><a href="../254423/index.html">How to create and earn SaaS | Part 17 | Personal data and medical secrets in the cloud</a></li>
<li><a href="../254425/index.html">JSONB requests in PostgreSQL</a></li>
<li><a href="../254429/index.html">Driver packs and their indices</a></li>
<li><a href="../254431/index.html">Quite simple about minimal perfect graph-based hashing</a></li>
<li><a href="../254433/index.html">Polite invitation to develop</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>