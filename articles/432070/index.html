<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Briefly about redux-saga channels</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon dear friends. 


 In this article I would like to describe the mechanism of the redux-saga channels as simple and concise as possible, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Briefly about redux-saga channels</h1><div class="post__text post__text-html js-mediator-article"><p>  Good afternoon dear friends. </p><br><p>  In this article I would like to describe the mechanism of the redux-saga channels as simple and concise as possible, using examples close to real cases, I hope it happened to me. </p><br><p>  So, let's begin. </p><a name="habracut"></a><br><h3 id="problema-modeli-watch-and-fork">  Watch-and-fork problem </h3><br><p>  Suppose that we have the usual watch-and-fork model, of the following form: </p><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { take, fork } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga/effects'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {payload} = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(<span class="hljs-string"><span class="hljs-string">'INIT_REQUEST'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,     yield fork(makeRequest, payload); } } function* makeRequest(payload) { //   }</span></span></code> </pre> <br><p>  This approach is bad because when catching several <code>INIT_REQUEST</code> events <code>INIT_REQUEST</code> one after another, several <code>makeRequest</code> executions will be launched, respectively.  Which in turn can cause their ‚Äúrace‚Äù. </p><br><p>  And here the channel mechanism comes to our rescue. </p><br><p>  The channels have buffers, thereby helping to queue <code>INIT_REQUEST</code> events (for example, <code>INIT_REQUEST</code> ), and organize their sequential execution (for example, <code>makeRequest</code> will <code>makeRequest</code> executed sequentially several times). </p><br><p>  Roughly speaking, the channels form a FIFO queue for sequential execution. </p><br><p>  They are classified by event source: </p><br><ul><li>  <code>channel</code> - events are queued manually using <code>put</code> ; </li><li>  <code>actionChannel</code> - events are caught near the redux store; </li><li>  <code>eventChannel</code> - external source of events, most often web socket; </li></ul><br><p>  So, let's briefly analyze each. </p><br><h3 id="podrobnee-o-channel">  More about channel </h3><br><p>  Such channels usually solve the problem of communication between sagas.  Used very rarely.  For example, if you need to reconcile several requests that start at the same time. </p><br><pre> <code class="javascript hljs">channel([buffer])</code> </pre> <br><p>  It has a single <code>buffer</code> argument - the accumulating buffer (we'll take a closer look at the buffers below). </p><br><h3 id="podrobnee-ob-actionchannel">  Read more about actionChannel </h3><br><p>  Most often used when it is necessary to respond to events from the redux store. </p><br><pre> <code class="javascript hljs">actionChannel(pattern, [buffer])</code> </pre> <br><p>  Takes two arguments: </p><br><ul><li>  <code>pattern</code> - the pattern of the required events, as well as <code>take</code> ; </li><li>  <code>buffer</code> - storage buffer; </li></ul><br><p>  Brief example of use: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { take, actionChannel, call } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga/effects'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">watchRequest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requestChannel = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> actionChannel(<span class="hljs-string"><span class="hljs-string">'INIT_REQUEST'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {payload} = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> take(requestChannel); <span class="hljs-comment"><span class="hljs-comment">//      yield call(makeRequest, payload); } } function* makeRequest(payload) { //   }</span></span></code> </pre> <br><h3 id="podrobnee-ob-eventchannel">  More on eventChannel </h3><br><p>  Usually through him solve the problem of communication through the web socket. </p><br><pre> <code class="javascript hljs">eventChannel(subscribe, [buffer], [matcher])</code> </pre> <br><p>  Takes three arguments: </p><br><ul><li>  <code>subscribe</code> is a function that initializes an external source of events (in the example below, setTimeout).  The arguments callback, called emitter, which will be called when you need to send data to the channel from the source.  Return should function unsubscribe; </li><li>  <code>buffer</code> - storage buffer; </li><li>  <code>matcher</code> is a function for filtering incoming messages. </li></ul><br><p>  Brief example of use: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { eventChannel, END } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { take, put, call } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga/effects'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initSocketChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">query</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eventChannel(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">emitter</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     web socket const handshakeTimeoutId = setTimeout(() =&gt; { emitter('handshake - ok'); }, 100); const messageTimeoutId = setTimeout(() =&gt; { emitter('message'); }, 500); const endTimeoutId = setTimeout(() =&gt; { emitter(END); }, 1000); //     return () =&gt; { clearTimeout(handshakeTimeoutId); clearTimeout(messageTimeoutId); clearTimeout(endTimeoutId); } } ) } export function* saga() { const chan = yield call(initSocketChannel, query) try { while (true) { const message = yield take(chan); //    END   brake console.log(`socket : ${message}`) } } finally { console.log('socket terminated') } }</span></span></code> </pre> <br><p>  Surely you have noticed the presence of the constant <code>END</code> - this is an action that means the end of communication with the channel. </p><br><p>  In the source code, redux-saga is represented as follows: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CHANNEL_END_TYPE = <span class="hljs-string"><span class="hljs-string">'@@redux-saga/CHANNEL_END'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> END = { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: CHANNEL_END_TYPE }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isEnd = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEnd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &amp;&amp; a.type === CHANNEL_END_TYPE; };</code> </pre> <br><p>  and in the <code>eventChannel</code> source code <code>eventChannel</code> see the following script </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eventChannel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">subscribe</span></span></span><span class="hljs-function">) </span></span>{ ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isEnd(input)) { close(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre> <br><h3 id="chto-zhe-takoe-buffer">  What is a buffer? </h3><br><p>  It deserves attention, since each channel has a base buffer, and with it, a queue for processing is formed. </p><br><p>  Buffer creation example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { buffers } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'redux-saga'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = buffers.sliding(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  <code>buffers</code> are instances of buffer factories with different strategies. </p><br><p>  Only 5 strategies, they correspond to the methods: </p><br><ul><li>  <code>buffers.none()</code> - no buffering, new messages will be lost if there are no pending participants; </li><li>  <code>buffers.fixed(limit)</code> - new messages will be buffered to the limit.  An overflow error will result in an error (exeption).  The default limit is 10; </li><li>  <code>buffers.expanding(initialSize)</code> - like fixed, but overflow will result in the buffer expanding dynamically; </li><li>  <code>buffers.dropping(limit)</code> - the same as fixed, but the overflow will silently discard messages; </li><li>  <code>buffers.sliding(limit)</code> is the same as fixed, but overflow will add a new message to the end and delete the oldest message in the buffer. </li></ul><br><h3 id="vmesto-zklyucheniya">  Instead of </h3><br><p>  So, we have disassembled why the mechanism of channels was invented, and what practical tasks are used. </p><br><p>  Hopefully, after reading, a general idea is formed and the world has become a bit simpler. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/432070/">https://habr.com/ru/post/432070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../432058/index.html">What's new in AppCode 2018.3</a></li>
<li><a href="../432060/index.html">The best ways to memorize English words</a></li>
<li><a href="../432062/index.html">AI development on the example of the game Dicey Dungeons</a></li>
<li><a href="../432064/index.html">How to escape from the "hares". Instructions for dealing with ultraviolet</a></li>
<li><a href="../432068/index.html">How to facilitate learning English: 5 useful services</a></li>
<li><a href="../432072/index.html">Three types of memory leaks</a></li>
<li><a href="../432074/index.html">How players rip Spelunky's reality fabric with shotguns</a></li>
<li><a href="../432076/index.html">Uncalled function slows down the program 5 times</a></li>
<li><a href="../432078/index.html">Traffic at the end of the tunnel or DNS in pentest</a></li>
<li><a href="../432080/index.html">Misconceptions players in assessing risks. Control random number generator in development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>