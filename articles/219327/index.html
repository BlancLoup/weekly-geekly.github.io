<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>VSDCT on OpenGL ES 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to make a VSDCT demo on my mobile phone. VSDCT (Virtual Shadow Depth Cubemap Texture) is a representation of a cubemap texture, whe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>VSDCT on OpenGL ES 3</h1><div class="post__text post__text-html js-mediator-article">  I have long wanted to make a VSDCT demo on my mobile phone.  VSDCT (Virtual Shadow Depth Cubemap Texture) is a representation of a cubemap texture, when instead of 6 separate faces, one regular 2D atlas texture is used, in which the original faces of the cube map are placed in the form of tightly packed tiles.  Let's see how to make shadows from a point source of light using this technique. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f1/dbe/ef1/7f1dbeef1bca0094134ee7de435ff96e.jpg" alt="image"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Implementation </h5><br><br>  I will not dwell on the basic omni-directional shadow mapping algorithm, you can read the relevant resources in the links.  We will use 6 linear projections and go straight to the VSDCT implementation. <br><br>  Let's figure out what we want to do.  We need to get 6 shadow maps that would cover all the directions visible from a point source of illumination.  Those.  one map for each of the directions ¬± X, ¬± Y, ¬± Z.  So that there are no gaps between the cards, we will establish an FOV of 90 degrees for each of the projections: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/170/abd/035/170abd035e67b2d0460a1a9263fbde10.png" alt="image"><br><br>  6 model-view matrices are constructed in this way (P - coordinates of the light source): <br><br><pre><code class="cpp hljs">Math::ViewMatrix( vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), P ); Math::ViewMatrix( vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), P ); Math::ViewMatrix( vec3( <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), P ); Math::ViewMatrix( vec3( <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), P ); Math::ViewMatrix( vec3( <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span> ), P ); Math::ViewMatrix( vec3( <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ), vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> ), P ); <span class="hljs-function"><span class="hljs-function">LMatrix4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ViewMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> LVector3&amp; X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> LVector3&amp; Y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> LVector3&amp; Z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> LVector3&amp; Position )</span></span></span><span class="hljs-function"> </span></span>{ LMatrix4 Matrix; Matrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = Xx; Matrix[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = Xy; Matrix[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = Xz; Matrix[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>] = -X.Dot( Position ); Matrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = Yx; Matrix[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = Yy; Matrix[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = Yz; Matrix[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>] = -Y.Dot( Position ); Matrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = Zx; Matrix[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = Zy; Matrix[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = Zz; Matrix[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = -Z.Dot( Position ); Matrix[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; Matrix[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; Matrix[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; Matrix[<span class="hljs-number"><span class="hljs-number">3</span></span>][<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Matrix; }</code> </pre> <br><br>  All projections are identical, perspective with aspect 1: 1 and angle of 90 degrees: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NearCP = <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> FarCP = <span class="hljs-number"><span class="hljs-number">512.0f</span></span>; Math::Perspective( <span class="hljs-number"><span class="hljs-number">90.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, NearCP, FarCP );</code> </pre><br><br>  When drawing each of the 6 shadow maps, we save the distance from the light source to the current pixel and package it in the 8-bit RGBA format. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> D = distance( v_WorldPosition, u_LightPosition.xyz ); <span class="hljs-attribute"><span class="hljs-attribute">out_FragColor</span></span> = Pack( D / <span class="hljs-number"><span class="hljs-number">512</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ); } <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> Pack(float Value) { <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> vec4 BitSh = vec4( <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">const</span></span> vec4 BitMsk = vec4( <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> / <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> / <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> / <span class="hljs-number"><span class="hljs-number">256</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> ); <span class="hljs-attribute"><span class="hljs-attribute">vec4</span></span> Comp = fract( Value * BitSh ); <span class="hljs-attribute"><span class="hljs-attribute">Comp</span></span> -= Comp.xxyz * BitMsk; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> Comp; }</code> </pre><br><br>  When drawing into separate regions of the atlas, you just need to set the corresponding viewport and scissor.  To divide an arbitrary atlas into N identical regions (we do not always need exactly 6), we use the following code: <br><br><pre> <code class="cpp hljs"> LRectDivider( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Size, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumSubRects ) : FSize( Size ) , FNumSubRects( NumSubRects ) , FCurrentX( <span class="hljs-number"><span class="hljs-number">0</span></span> ) , FCurrentY( <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Sqrt = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>( FNumSubRects ) ); FNumSlotsWidth = ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> )<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>( Sqrt ); FNumSlotsHeight = ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> )Sqrt; FSlotWidth = FSize / FNumSlotsWidth; FSlotHeight = FSize / FNumSlotsHeight; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNextRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* Y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* W, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">* H )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( X ) { *X = FCurrentX * FSlotWidth; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( Y ) { *Y = FCurrentY * FSlotHeight; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( W ) { *W = FSlotWidth; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( H ) { *H = FSlotHeight; } NextRect(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ++FCurrentX &gt;= FNumSlotsWidth ) { FCurrentX = <span class="hljs-number"><span class="hljs-number">0</span></span>; FCurrentY++; } }</code> </pre><br><br>  Approximately (approximately, because in fact we packed a 32-bit float distance into 4 channels, including alpha), this will look like an atlas for this scene: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/619/4ed/28b/6194ed28ba43583046612b0806d15dbd.jpg" alt="image"><br><br>  Now we can draw all this ourselves.  In many implementations of VSDCT, an additional cubic map, indirection cubemap, is used, which converts 3D coordinates to 2D coordinates within a texture atlas.  It was decided to do without it and convert the coordinates directly in the fragment shader.  First we turn to paragraph 8.13 of the Cube Map Texture Selection from the <a href="http://www.opengl.org/registry/doc/glspec44.core.pdf">OpenGL 4.4 Core Profile Specification</a> .  Table 8.18 tells us what to do with the 3D coordinates: <br><br><table><tbody><tr><td>  Major Axis Direction </td><td>  Target </td><td>  Sc </td><td>  Tc </td><td>  Ma </td></tr><tr><td>  + Rx </td><td>  POSITIVE_X </td><td>  -Rz </td><td>  -Ry </td><td>  Rx </td></tr><tr><td>  -Rx </td><td>  NEGATIVE_X </td><td>  Rz </td><td>  -Ry </td><td>  Rx </td></tr><tr><td>  + Ry </td><td>  POSITIVE_Y </td><td>  Rx </td><td>  Rz </td><td>  Ry </td></tr><tr><td>  -Ry </td><td>  NEGATIVE_Y </td><td>  Rx </td><td>  -Rz </td><td>  Ry </td></tr><tr><td>  + Rz </td><td>  POSITIVE_Z </td><td>  Rx </td><td>  -Ry </td><td>  Rz </td></tr><tr><td>  -Rz </td><td>  NEGATIVE_Z </td><td>  -Rx </td><td>  -Ry </td><td>  Rz </td></tr></tbody></table><br><br>  The resulting Sc, Tc and Ma are substituted into these formulas and we get the 2D coordinates s, t: <br><br><pre> <code class="cpp hljs">s = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ( Sc / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(Ma) + <span class="hljs-number"><span class="hljs-number">1</span></span> ) t = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ( Tc / <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(Ma) + <span class="hljs-number"><span class="hljs-number">1</span></span> )</code> </pre><br><br>  Here is the shader code for GLSL, which performs all the transformations of the texture coordinates and drives the resulting s and t inside the atlas: <br><br><pre> <code class="hljs pgsql">vec2 GetShadowTC( vec3 Dir ) { <span class="hljs-type"><span class="hljs-type">float</span></span> Sc; <span class="hljs-type"><span class="hljs-type">float</span></span> Tc; <span class="hljs-type"><span class="hljs-type">float</span></span> Ma; <span class="hljs-type"><span class="hljs-type">float</span></span> FaceIndex; <span class="hljs-type"><span class="hljs-type">float</span></span> rx = Dir.x; <span class="hljs-type"><span class="hljs-type">float</span></span> ry = Dir.y; <span class="hljs-type"><span class="hljs-type">float</span></span> rz = Dir.z; vec3 adir = abs(Dir); Ma = max( max( adir.x, adir.y ), adir.z ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( adir.x &gt; adir.y &amp;&amp; adir.x &gt; adir.z ) { Sc = ( rx &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) ? rz : -rz; Tc = ry; FaceIndex = ( rx &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) ? <span class="hljs-number"><span class="hljs-number">0.0</span></span> : <span class="hljs-number"><span class="hljs-number">1.0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( adir.y &gt; adir.x &amp;&amp; adir.y &gt; adir.z ) { Sc = rx; Tc = ( ry &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) ? rz : -rz; FaceIndex = ( ry &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) ? <span class="hljs-number"><span class="hljs-number">2.0</span></span> : <span class="hljs-number"><span class="hljs-number">3.0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Sc = ( rz &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) ? -rx : rx; Tc = ry; FaceIndex = ( rz &gt; <span class="hljs-number"><span class="hljs-number">0.0</span></span> ) ? <span class="hljs-number"><span class="hljs-number">4.0</span></span> : <span class="hljs-number"><span class="hljs-number">5.0</span></span>; } <span class="hljs-type"><span class="hljs-type">float</span></span> s = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ( Sc / Ma + <span class="hljs-number"><span class="hljs-number">1.0</span></span> ); <span class="hljs-type"><span class="hljs-type">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * ( Tc / Ma + <span class="hljs-number"><span class="hljs-number">1.0</span></span> ); //    s = s / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; t = t / <span class="hljs-number"><span class="hljs-number">2.0</span></span>; <span class="hljs-type"><span class="hljs-type">float</span></span> Flr = floor(FaceIndex / <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-type"><span class="hljs-type">float</span></span> Rmd = FaceIndex - (<span class="hljs-number"><span class="hljs-number">3.0</span></span> * Flr); s += Rmd / <span class="hljs-number"><span class="hljs-number">3.0</span></span>; t += Flr / <span class="hljs-number"><span class="hljs-number">2.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec2( s, t ); }</code> </pre><br><br>  The very rendering of the shadow in the scene is extremely simple: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ComputePointLightShadow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { vec3 LightDirection = v_WorldPosition - u_LightPosition.xyz; vec2 IndirectTC = GetShadowTC( normalize( LightDirection ) ); vec4 Light = texture( Texture7, IndirectTC ); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LightD = Unpack( Light ) * <span class="hljs-number"><span class="hljs-number">512.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( LightD &lt; length( LightDirection ) + u_ShadowDepthBias ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u_ShadowIntensity; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unpack</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vec4 Value</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vec4 BitShifts = vec4( <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / (<span class="hljs-number"><span class="hljs-number">256.0</span></span> * <span class="hljs-number"><span class="hljs-number">256.0</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">256.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dot( Value, BitShifts ); }</code> </pre><br><br>  That's all! <br><br>  This technique has a problem with artifacts on the edges of texture maps.  They will be especially noticeable if you apply PCF shadow filtering or the like.  To reduce such problems, you can add a black border between the individual textures inside the atlas. <br><br><h5>  Demo </h5><br><br>  If you have an Android device with OpenGL ES 3.0 and Android 4.4, then you can try running the application: <a href="http://play.google.com/store/apps/details%3Fid%3Dcom.linderdaum.engine.vsdct">play.google.com/store/apps/details?id=com.linderdaum.engine.vsdct</a> <br><br><h4>  Links </h4><br><br>  <a href="http://www.linderdaum.com/">Linderdaum engine</a> <br>  <a href="http://www.amazon.com/ShaderX3-Advanced-Rendering-DirectX-Graphics/dp/1584503572">ShaderX3: Advanced Rendering with DirectX and OpenGL</a> <br>  <a href="http://www.gamedev.ru/code/forum/%3Fid%3D69603">VSDCT for omnidirectional shadow mapping</a> <br>  <a href="http://blog.linderdaum.com/2014/01/19/omnidirectional-shadows-and-vsdct/">Omnidirectional shadows and VSDCT on OpenGL ES 3</a> <br>  <a href="http://www.altdevblogaday.com/2011/01/30/omni-directional-shadow-mapping/">Omni-directional shadow mapping</a> </div><p>Source: <a href="https://habr.com/ru/post/219327/">https://habr.com/ru/post/219327/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219307/index.html">Arch Linux on Raspberry Pi</a></li>
<li><a href="../219311/index.html">What is a Tomita-parser, how Yandex understands natural language with its help, and how you can use it to extract facts from texts</a></li>
<li><a href="../219315/index.html">Charger from body heat</a></li>
<li><a href="../219317/index.html">Choose LTE2600 or LTE1800 from the position of the operator</a></li>
<li><a href="../219325/index.html">New technology for dating a child before conception</a></li>
<li><a href="../219329/index.html">Yii 2.0 beta</a></li>
<li><a href="../219331/index.html">DARPA turns obsolete drones into flying Wi-Fi access points</a></li>
<li><a href="../219333/index.html">Approximation of the curve in the boom trajectory for the game St.Val</a></li>
<li><a href="../219335/index.html">What else does Heartbleed threaten a simple user with?</a></li>
<li><a href="../219337/index.html">Harmonic vibrations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>