<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>FeatureBranch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the spread of distributed version control systems (DVCS), such as Git and Mercurial, I increasingly see discussions on the proper use of branchin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>FeatureBranch</h1><div class="post__text post__text-html js-mediator-article">  With the spread of distributed version control systems (DVCS), such as Git and Mercurial, I increasingly see discussions on the proper use of branching (branch) and merging (merge), and how this fits into the idea of ‚Äã‚Äãcontinuous integration (CI).  There is a certain ambiguity in this question, especially when it comes to feature branching (a branch on functionality) and its correspondence to CI ideas. <br><br><h5>  Simple (Isolated) Feature Branch </h5><br>  The main idea of ‚Äã‚Äãthe feature branch is to create a new branch when you start working on some functionality.  In DVCS, you do this in your own repository, but the same principles work in centralized VCS. <br><br>  I will illustrate my thoughts with the following number of diagrams.  In them, the main development line (trunk) is marked in blue, and two developers marked in green and purple (Reverend Green and Professor Plum). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/7e5/9c8/ea2/7e59c8ea261067a76f2d1e2e80764458.png" alt="image"><br><br><a name="habracut"></a><br><br>  I use the designated colored rectangles as symbols for local commits in branching.  The arrows between the branches indicate mergers, the orange rectangles select the merges themselves.  In this example, there are updates in the main line, say a couple of fixed bugs.  When this happens, our developers merge them into their local branches.  In order to get a sense of time, let's assume that we are talking about several days of work, when each developer commits his changes about once a day. <br><br>  To make sure that the code works, they can run builds and tests on their branches.  In this article, we will assume that with each commit and merge, automatic builds and tests for the branch in which it was made run. <br><br>  The main advantage of feature branching is that each developer can work on his task and be isolated from what is happening around.  They can merge changes from the main line at their own pace and be sure that this does not interfere with the functionality being developed.  Moreover, it allows the team to choose what to make of the new developments in the release, and what to leave for later.  If Reverend Green is late, we can provide a version with only changes to Professor Plum.  Or, on the contrary, we can postpone the additions of the professor, perhaps because we are not sure that they work the way we want.  In this case, we simply ask the professor not to merge his changes into the main line until we are ready to release its functionality.  This approach gives us the opportunity to be selective, the team decides what functionality to merge before each release. <br><br>  Despite the attractiveness of this image, there may be some problems with this approach. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/93d/b7c/0b9/93db7c0b95454dcfc16ea34b7e2c0509.png" alt="image"><br><br>  Although developers can work on their functionality in isolation, at some point the result of their work should be integrated.  In our example, Professor Plum easily updates the main line with his changes, there is no merger, because he already received all the changes in the main line to his branch (and passed the build).  However, not everything is so simple for Reverend Green, it must merge all its changes (G1-6) with the changes by Professor Plum (P1-5). <br><br>  (In this example, many DVCS users may feel that I miss many of the details in such a simple, even simplified explanation of feature branching. I will explain a more complex diagram later.) <br><br>  I made this rectangle merge huge because it is a dangerous merge.  It can go without problems, it is likely that the developers worked on different parts of the code without interactions, and then the merge will go smoothly.  But they could also work on the parts that interact, and then he would be in complete hell. <br><br>  Nightmares can take various forms, and development tools can save <i>from some</i> .  The most standard can be in the difficulties of merging sources, when two developers are working on the same theme files.  Modern DVCS cope well with such problems, sometimes it even seems that not without the help of magic.  Git has a reputation as a tool that knows how to deal well with complex conflicts.  So good that we even leave this question beyond the scope of this article. <br><br>  The problem that worries us more is semantic conflicts.  The simplest example is the case in which Professor Plum changes the name of a method that Reverend Green calls in its code.  Tools for refactoring will help you rename the method without problems, but only in your code.  Therefore, if G1-6 contains a new code that calls foo, Professor Plum will not know about it, because this change is not in its branch.  Awareness of where the dog is buried will come to us only in the big merj. <br><br>  Renaming a function is the clearest example of semantic conflict.  In practice, they can be much more secretive.  Tests are the key to them, but the more code you need to merge, the more chances of conflicts and the harder it is to fix them.  The risk of conflict in general and semantic in particular makes great mergers terrible. <br><br>  The consequence of the fear of big merdzhi is the reluctance of re-factoring.  Keeping the code clean requires constant effort and in order to succeed everyone must clean up the garbage when he sees it.  However, such a refactoring in the feature branch is problematic, insofar as it makes the Big Scary Merge even bigger and more scary.  As a result, developers are afraid of refactoring as a fire and the code is cluttered with freaks. <br><br>  In the above problem, I see the main reason why feature branching is a bad idea.  At that moment when the team is afraid of refactoring to maintain a healthy code - they are in a long peak without a chance for an elegant way out. <br><br><h5>  Continuous integration </h5><br>  It is these problems that continuous integration should solve.  With CI, my diagram will look like this. <br><img src="https://habrastorage.org/getpro/habr/post_images/ffc/4d9/053/ffc4d905357943c30399326e9d98fe18.png" alt="image"><br><br>  There are a lot more merdzhey here, but merging is one of those things that it‚Äôs better to do a little bit often than rarely and in tons.  As a result, if Professor Plum changes a part of the code on which Reverend Green depends, our green colleague will find out this much earlier, in P1-2.  At the moment, he needs to change G1-2 to work with these changes, instead of G1-6 (as it was in the last example). <br><br>  CI is effective in neutralizing big merge problems, but beyond that it is also a crucial communication mechanism.  In this scenario, a potential conflict will manifest itself when Professor Plum merges G1 and realizes that Reverend Green is using professor libraries.  Then Professor Plum can find Reverend Green and together they can discuss the interaction of their functionality.  Perhaps the functionality of Professor Pum requires some changes that do not get along with the functionality of Reverend Green.  Together, they can make much better design decisions that will not interfere with their work.  With isolated transfers, our developers do not know about the problem until the last moment, when it is often too late to resolve the conflict without serious consequences.  Communication is one of the key factors in software development and one of the main features of CI is promoting it. <br><br>  It is important to mention that in most cases, branching has a different approach to CI.  One of the principles of CI is that everyone commits to the main line every day, so if the feature branch lives more than one day, it turns it into something very far from CI.  I heard people say that they use CI because their builds run on the CI server, on each branch and for each commit.  This is a continuous build, which is good, but there is no <i>integration</i> , so this is not CI. <br><br><h5>  "Messy" integration </h5><br>  Earlier, I said in brackets that there are other ways to feature branching.  Let's say Professor Plum and Reverend Green at the beginning of the iteration brew flavored green tea together and discuss their tasks.  They discover that there are interacting parts among the tasks and decide to integrate between each other like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e2/26f/0a4/5e226f0a4a65146e61cf464ccf1e51fe.png" alt="image"><br><br>  With this approach, they merge with the main line at the end, as in the first example, but they also often do the merdzh among themselves to avoid the Big Scary Merdzh.  The idea is that the main advantage of feature branching is isolation.  When you isolate isolate your branches, there is a risk of nasty conflict escalating beyond your knowledge.  Then isolation is an illusion that will painfully break sooner or later. <br><br>  Still, is this more labor-intensive integration a form of CI or is it a completely different beast?  I think they are different, again, a key property of CI is that each integrates with the <i>main line</i> every day.  Integration among feature branches, which I will call ‚Äúpromiscuous integration, PI,‚Äù with your permission, does not include and does not even need a main line.  I think this difference is very important. <br><br><blockquote>  I see CI mainly as a means for the birth of a release candidate at each commit.  The task of the CI system and the deployment process is to refute the readiness for the production of the current release candidate.  This model needs some kind of main line of development which represents the current state of the full picture. <br><br>  - <a href="http://www.davefarley.net/">Dave Farley</a> </blockquote><br><br><h5>  Random integration vs continuous integration </h5><br>  And yet, if PI is different from CI, then for what case is PI better than CI? <br><br>  With CI, you lose the ability to use a version control system to selectively change.  Each developer affects the main line, so all the functionality grows in it.  With CI, the main line should always be healthy, and in theory (and often in practice) you can make a release after each commit.  Having a half-completed functionality, or the functionality that you prefer not to release, you will not damage the functionality of the entire system, but will require some kind of masking to hide it from the user interface, such as not turning on a new item in the menu. <br><br>  In such cases, PI can provide something in the middle. This allows Reverend Green to choose when to accept the changes to Professor Plum.  If Professor Plum makes any changes to the kernel API of the system in P2, Reverend Green can import P1-2 but leave the rest until Professor Plum finishes its work and merges into the main branch. <br><br>  However, in general, I do not think that fetching functionality for a release using VCS is a good idea. <br><br><blockquote>  Feature branching is a modular architecture for beggars, instead of building a system with the ability to easily replace functionality during raintime / deployment, people tie themselves to the source control for this mechanism through manual merge. <br><br>  - <a href="https://twitter.com/DanielBodart">Dan Bodart</a> </blockquote><br><br>  I prefer to design software so that you can turn on and off functionality with a configuration change.  To do this, there are two useful techniques <a href="http://martinfowler.com/bliki/FeatureToggle.html">FeatureToggles</a> and <a href="http://martinfowler.com/bliki/BranchByAbstraction.html">BranchByAbstraction</a> .  They require you to think more about what and how to divide into modules and how to control these options, but we came to the conclusion that the result is much more accurate than what comes out, if you hope for VCS. <br><br>  What bothers me most about PI is his susceptibility to communication skills within the team.  With CI, the main line serves as a communication point.  Even if Professor Plum and Reverend Green never spoke, they will find an emerging conflict on the day of its formation.  With PI, they will have to notice that they are working on interacting code.  Constantly updating the main line contributes to everyone‚Äôs confidence that it integrates with everyone, it‚Äôs not necessary to find out who does what, and therefore there is less chance of changes that remain hidden until late integration. <br><br>  PI originated from open source and, presumably, a less intense open source project speed may be a factor for it.  In the full-time job, you work quite a few hours a day on a project.  This allows you to work on the functionality with priorities.  With open source, people often donate an hour here and a couple of days there.  Functionality can take one developer a lot of time to complete, while others, with plenty of free time, can bring their changes to acceptable quality before.  In such a situation, a selective approach may be more important. <br><br>  It is important to realize that the tools you use do not depend on the strategy you choose.  Although many associate DVCS with feature branching, they can also be used with CI.  All you need to do is mark one of the branches as the main line.  If everyone does pull and push to this thread every day, then you have the most basic line.  In fact, in a well-disciplined team, I would prefer to use DVCS for a CI project than a centralized VCS.  With a less disciplined team, I‚Äôll worry that using DVCS will push people to long-lived branches, at the moment when centralized VCS and complication of branching will push them to frequent commits to the main line. <br><br>  <b><i>PS From the translator</i></b> <i>to the study of questions to the approaches of using VCS, <a href="http://habrahabr.ru/post/170589">this article</a> inspired me, thanks to which I began to look for more detailed descriptions of the "correct" use of branching and came across the above translated text.</i>  <i>Although I do not pretend to the quality of the translation, I just want to get into the tape to the developers and give them a reason to think from the opposite approach adopted in the open source (forking).</i>  <i>Do not hurt with sticks, but constructively criticize, I do it for the first time :-)</i> . </div><p>Source: <a href="https://habr.com/ru/post/181924/">https://habr.com/ru/post/181924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../181908/index.html">Texet TM-607TV: phone disguised as an Android smartphone</a></li>
<li><a href="../181910/index.html">Recovery of iPhoto when the import hangs</a></li>
<li><a href="../181912/index.html">ChibiOS: Lightweight RTOS</a></li>
<li><a href="../181914/index.html">Working with class variables of the heir class in the base class</a></li>
<li><a href="../181922/index.html">Public discussion of the GOST project on digitized audio data compression</a></li>
<li><a href="../181928/index.html">How does Yandex.Mail for domains work?</a></li>
<li><a href="../181930/index.html">Cambot - Robot Photographer on Raspberry Pi</a></li>
<li><a href="../181932/index.html">Review of possible problems when installing Ubuntu second system on SSD</a></li>
<li><a href="../181934/index.html">We bring Skype icons to the general style of the system.</a></li>
<li><a href="../181936/index.html">Non-standard way to get unavailable information on iOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>