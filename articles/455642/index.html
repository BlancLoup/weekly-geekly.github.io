<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The architecture of the service of distributed message queues in Yandex. Oblak</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Vasily Bogonatov. I am one of those who had a hand and a head and invested their soul in the service of distributed persistent message ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The architecture of the service of distributed message queues in Yandex. Oblak</h1><div class="post__text post__text-html js-mediator-article">  Hi, my name is Vasily Bogonatov.  I am one of those who had a hand and a head and invested their soul in the service of distributed persistent message queues Yandex Message Queue.  The service was publicly available at the end of May, but inside Yandex it has long been actively used in various products. <br><br>  Today I want to tell Habr's readers about message queues in general and about Yandex Message Queue in particular.  First, I want to explain what a ‚Äúdistributed persistent message queue‚Äù is and why it is needed.  Show its practical value, the mechanics of working with messages, talk about the API and usability.  In the second half of the material, we will look at the technical side: how Yandex Database is used in our queues (this is a solid foundation of our service), what a naive and improved approach to building architecture looks like, what distributional problems cause and how they can be solved. <br><br><img src="https://habrastorage.org/webt/xy/ht/eb/xyhtebqslkofciotlmohtwlopb4.png"><br><a name="habracut"></a><br><h3>  What is a distributed persistent message queue? </h3><br>  Wikipedia defines the <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2587%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B4%25D1%258C_%25D1%2581%25D0%25BE%25D0%25BE%25D0%25B1%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">message queue</a> as a ‚Äúsoftware engineering component used for inter-process or inter-thread communication within a single process‚Äù.  In fact, this concept is somewhat broader: processes interacting with the help of a queue can be located on different servers and even in different data centers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will clarify terms a bit. <br><br>  <b>A message queue</b> is a repository that stores and reads data in a specific order. <br><br>  Two types of entities usually interact with the queue: <br><br><ul><li>  <b>writers (producers)</b> - send messages to the queue; </li><li>  <b>readers (consumers)</b> - get (read) messages from the queue. </li></ul><br>  When using the queue, readers and writers are independent of each other.  They can work with different performance, reliability, availability, and can even be written in different programming languages. <br><br>  The main scenario for the queue: reliably and quickly transfer messages from the writer to the reader.  Unlike the database, the queue is not intended for long-term storage of messages.  In many popular implementations, there is a corresponding parameter - ‚ÄúMessage retention period‚Äù.  It determines how long the message is stored until it is permanently deleted. <br><br>  We figured out the concept of the queue, go to the "distribution" and "persistence." <br><br><ul><li>  <b>Distribution</b> in our case means the presence of a cluster that stores and processes the data and metadata of the queues, combining all its nodes into a coherent whole with the help of a computer network. </li><li>  <b>Persistence</b> implies that all messages in the queue are written to disk, and the writer receives confirmation of sending only after successful recording. </li></ul><br>  Distribution and persistence do not affect the main functionality of the queue, they provide fault tolerance and reliability of data storage.  What types of failures can happen in our system, we will look at a little later.  However, I can not deny myself the pleasure and slightly reveal the cards: in the entire history of the service, we have not lost a single saved client message. <br><br><h3>  What is the message queue for? </h3><br>  The queue allows you to separate the logically independent parts of the services from each other, that is, provides <b>decoupling</b> , which is so in demand in the currently popular microservices.  This increases scalability and reliability: you can always increase the flow of writing to the queue and add more readers - message handlers, while the refusal of readers does not affect the work of writers. <br><br>  Queues smooth load peaks: they serve as a buffer for readers.  If there are not enough readers for instant processing of all incoming messages of the current capacity, the messages placed in the queue will be processed later when the load decreases.  Buffering is useful for services with unstable load, where instant processing of incoming events is not needed. <br><br>  Let's take a look at how this works, using the example of a <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BE%25D1%2582">search robot</a> (after all, Yandex began with a search!), Which downloads, processes, and puts web pages into a database.  Take just such an architecture. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/oe/dh/zooedh0t0qs4uu1lhpdc0psa2qi.png" width="600" height="778"></div><br><br>  The message queue solves the following problems here: <br><br><ol><li>  The robot is much faster than the workers who are responsible for parsing and loading pages into the database.  Without a queue, links would accumulate and fill up the available memory or disk.  The same thing would happen if the workers were temporarily unavailable. </li><li>  Without a queue, the robot needs to ‚Äúknow‚Äù the working interface of the workers in order to assign them tasks.  The interface may change as the product develops. </li><li>  The individual worker has low reliability, so there is no guarantee that the link will be processed by him completely. </li></ol><br>  The queue provides reliable data storage with scaling, allows you to postpone the processing of links.  If one worker fails, the raw link will be returned to the queue after a certain period of time for processing by another worker.  The queue has its own interface, which has been tested and described in the documentation, so that the systems of the search robot and the workers can develop different commands in different programming languages.  This will not affect overall performance. <br><br><h3>  How Yandex Message Queue works with messages </h3><br>  Here there are three main stages: <br><br><ul><li>  <b>write</b> message to the queue; </li><li>  <b>reading a</b> message from the queue; </li><li>  <b>remove</b> message from queue. </li></ul><br>  Record is considered successful if the message has been reliably saved and will soon be available to readers.  It is possible to record with deduplication: when a repeated attempt to write the sent message is ignored. <br><br>  At the time of reading the message is hidden from the queue for a period of time, which is called Visibility Timeout, and becomes inaccessible to other readers.  If the visibility timeout expires, the message returns to the queue and becomes available again for processing.  The order in which messages are read is determined by the queue, not by the reader. <br><br>  The reader itself and the network connection to it are potentially unreliable.  A visibility timeout is needed to be able to return a message to the queue when the reader crashes or the connection is broken.  Otherwise, there is a chance that a single message will never be processed correctly. <br><br>  After successful reading, the message is sent to the client along with the ReceiptHandle identifier.  The identifier indicates specific data that should be removed from the message queue. <br><br><h3>  Types of queues in Yandex Message Queue </h3><br>  The first and most frequently used type is the Standard Queue.  It is characterized by high throughput (thousands of messages per second), excellent performance and low execution time of basic operations.  Standard queues consist of logical shards and support almost linear bandwidth scaling. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wy/p0/jp/wyp0jpi_pmhorpq2mikwm_mgl-u.png"></div><br>  Standard queues do not support message deduplication when writing to a queue and do not guarantee the order of reading.  Due to the use of sharding, a read request may not return a single message, even if they are in the queue.  Most often this happens in <a href="https://en.wikipedia.org/wiki/Polling_(computer_science)">short polling</a> mode, when reading comes from one randomly selected shard. <br><br>  The second type - <abbr title="First In First Out">FIFO</abbr> - the opposite of the standard queue.  Provides a strict reading order, supports deduplication when writing and retrying reading messages.  Performance and scalability are lower than the standard.  FIFO queue performance is limited to 30 requests per second.  FIFO is recommended when trying to ensure the delivery semantics is ‚Äúexactly once‚Äù.  Usually, the word "queue" means exactly FIFO. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yr/jy/l5/yrjyl5kbyfzqzkruqhaoqdrsxzs.png" width="421" height="801"></div><br><h3>  Yandex Message Queue API </h3><br>  <a href="https://ru.wikipedia.org/wiki/API">API</a> is a very important part of any product.  A good software interface should be simple and straightforward, requiring minimal familiarity with the documentation for effective use.  Should not allow doing strange or unnecessary actions and protect against stupid mistakes, in time reporting a violation of the "contract". <br><br>  If the system has such an API, it quickly gains loyal users and becomes cluttered with convenient ‚Äúwrappers‚Äù for different platforms and programming languages. <br><br>  <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/Welcome.html">Amazon Simple Queue Service API (AWS SQS API)</a> is an example of such an interface, proven by time and a huge number of clients.  Therefore, we decided not to invent a unique interface for Yandex Message Queue, but implemented support for the AWS SQS API, and very carefully. <br><br>  In most cases, the SQS user only needs to change the endpoint (service address), the region (at the moment we only use ‚Äúru-central1‚Äù) and get new access details (credentials) within Yandex.Lamp.  Everything else, for example, a script using the <a href="https://aws.amazon.com/ru/cli/">AWS command line</a> , code using the AWS SDK or a ready service on <a href="http://www.celeryproject.org/">Celery</a> or <a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sqs.html">boto</a> , most likely, will not have to be touched.  The logic and functionality of the queue service will remain the same. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_r/td/kn/_rtdknyixiytyqo63khne5gz4uq.png"></div><br>  Detailed description of Yandex Message Queue API methods is in the <a href="https://cloud.yandex.ru/docs/message-queue/api-ref/">service documentation</a> . <br><br><h3>  A little about convenience </h3><br>  Yandex Message Queue is a managed service, that is, Yandex.Oblaco is responsible for the performance of servers and software.  The service team monitors the health of the queues, promptly replaces the failed drives, eliminates network breaks and rolls updates.  Updating occurs without stopping the service: as long as we install the new version of YMQ on one server group, the load balancer diligently redirects traffic to others.  So users do not notice anything. <br><br>  To make it easier for you to control the work of the queues, we added a large number of visual graphs to the YMQ, here only a small part of them is shown.  Charts are located in the console Yandex. Oblaka, in the "Statistics". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/cp/nn/bicpnn5tjwzqustzy9ye5abnrho.png"></div><br>  We will tell you about the four most useful graphics in our opinion: <br><br><ul><li>  The <b>‚ÄúMessages in Queue‚Äù</b> graph helps to monitor the accumulation of data in the queue.  The growth of the graph may mean that the handlers are not coping with the load or the processing has stopped. </li><li>  The <b>‚ÄúAge of the oldest message in the queue‚Äù</b> graph: large values ‚Äã‚Äãsignal problems with message processing.  If everything works correctly, the messages should not be long in the queue. </li><li>  The graph <b>‚ÄúNumber of attempts to read a message‚Äù</b> shows when messages begin to be read several times.  This may mean that handlers crash when they receive some messages. </li><li>  The graph <b>‚ÄúTime in queue‚Äù</b> tells how much time passes from the moment the message is sent to the queue until it is received by the processor. </li></ul><br>  Charts help to instantly assess the dynamics of the queue and the presence of failures without the need to view the logs. <br><br>  We discussed more or less general points, now let's get to the details. <br><br><h3>  How Yandex Database used Queue Database </h3><br>  The Yandex Message Queue service is built on top of the <a href="https://cloud.yandex.ru/services/ydb">Yandex Database (YDB)</a> geo-distributed, fault-tolerant database, which provides strict consistency and support for ACID transactions.  We will not now disassemble its device and characteristics, we restrict ourselves to the general scheme. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uq/5m/o3/uq5mo3fm83hovqxkgt7no-yjevg.png" width="742" height="860"></div><br>  A queue in YMQ consists of logical shards, represented by some fixed set of tables YDB.  Each table stores its own piece of information.  For example, there is a common state table called State, which stores the offset and the actual number of messages.  There is a table with data and message metadata.  There is a table with related attributes. <br><br>  All the main operations with the queue - working with messages, changing attributes, creating and deleting - this is working with a hierarchy of tables and directories YDB, or transactional requests to one or more tables in the queue.  The data inside the queue tables is the source of absolute truth.  Therefore, in addition to the correct and stable operation of the database, it is necessary to ensure reliable storage and high availability of data. <br><br>  Our information is stored in several replicas: one copy in each of the three Yandex data centers.  In case of unavailability of one of the data centers, the number of replicas in the remaining doubles.  Thus, the required level of reliability is restored.  Even if the whole data center fails and one service counter in the other, the data will be fully accessible. <br><br><h3>  The first version of the architecture Yandex Message Queue </h3><br>  The first version of the YMQ architecture, which we ourselves called naive, looked like this. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aj/qc/eu/ajqceuaoisynocw4u3ffek3epjo.png"></div><br>  The diagram shows the path of the HTTPS request from the YMQ client to the YDB repository.  Let's look at the main components: <br><br><ol><li>  The L3 balancer sends the request to the Yandex data center closest to the user.  This reduces network delays, although the load is unevenly distributed. </li><li>  Nginx on the Yandex.Cloud virtual machine terminates HTTPS connections, provides protection against network attacks, and proxies the request further to the YMQ server, already in HTTP. </li><li>  The YMQ HTTP server implements the SQS HTTP API logic, validates, and translates the request into the strongly typed protobuf format. </li><li>  YMQ Actor system - <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">actor system</a> .  It simultaneously launched thousands of different actors sharing information.  The actor system of each host is part of a cluster.  All cluster actors live and act as one.  The business logic of YMQ is implemented in various actors implementing query transactions to YDB. </li><li>  YDB tablets ("tablets") - part of the YDB core, which is responsible for working with tables in queries and transactions.  The tablets themselves do not store data.  These are control structures in memory that are able to recover in the event of a hardware failure. </li><li>  Storage - reliable, distributed, fault-tolerant storage. </li></ol><br>  This architecture has a flaw: all servers in the cluster work independently with tables in the same queue.  This adversely affects performance and makes it difficult to organize reliable caches of hidden and readable messages.  It is difficult to limit the flow of requests, and this is very important for any high-load service. <br><br><h3>  Yandex Message Queue architecture with queue masters </h3><br>  Load firing showed that the first version of the architecture withstands about 450 messages per second per queue with one shard.  It was very small. <br>  The main problem was contention requests.  A large number of logically conflicting transactions quickly brought hidden message caches to an inconsistent state.  To solve the problem, we introduced a special entity - the queue master. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gc/b4/om/gcb4omkmhk28uhwe2hrlewhzsig.png"></div><br>  <b>A queue master</b> is an actor that normally exists in a cluster in a single copy and passes all requests related to a specific queue through itself.  If the request to the queue comes to the server where the required master is missing, a special proxy actor redirects the request and then transmits the response received from the master back. <br><br>  When using the queue wizard, the correct cache of unblocked messages reduces contention when working with tables.  The implementation of restricting the flow of requests is simplified, for example, through the <a href="https://en.wikipedia.org/wiki/Leaky_bucket">Leaky bucket</a> .  Fast and accurate queue metrics are available: number of messages, total traffic, and the like.  You can group similar requests. <br><br>  In theory, such an architecture has certain disadvantages associated with centralization: <br><br><ol><li>  Reduced fault tolerance: if a virtual machine with a master fails, all queues with masters on it will be unavailable.  However, special YDB mechanisms allow you to raise new masters within a cluster in just a few seconds.  This largely solves the problem. </li><li>  Limited scalability: all requests go through the same host.  The disadvantage is leveled tablets YDB.  They are the ones who do all the hard work with data.  And the master asynchronously sends requests and processes the received results.  This makes it a ‚Äúlight‚Äù entity that does not create a bottleneck effect under load testing. </li></ol><br><h3>  Quest queuing in queue masters </h3><br>  Distributed transactions with database tables lead to certain additional costs, so the idea of ‚Äã‚Äãreducing the number of queries seemed logical to us.  One hundred transactions to write messages one by one is better to turn into one transaction to write one hundred messages at once.  With queue masters, it is much easier to implement such batch processing (batching, batching). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/rn/0j/ycrn0j7obrbg0_cimvkyzj5izr4.png"></div><br>  Butching increases latency somewhat when performing operations.  In exchange, throughput is greatly increased.  With a batching, a single-queue queue can handle up to 30,000 requests per second. <br><br>  In general, the loading of queues is very different: and thousands of messages per second, and several messages per day.  We needed to optimize work with queues using a flexible algorithm.  Frontal options with the accumulation of messages in the buffer to a threshold number or reset by timer did not suit us.  Therefore, we developed an adaptive batching algorithm for YMQ that works well in both cases.  His work is shown in a timeline format. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/g2/rx/qmg2rx2e8pllaxuajav0gyxe2kg.png"></div><br>  Here, when a new message arrives, one of three scenarios is possible: <br><br><ol><li>  A transaction starts instantly if there are no other transactions of this type running. </li><li>  If there are transactions running, the message is added to the buffer and waits for the completion of transactions. </li><li>  If the buffer size exceeds the threshold value, another parallel transaction is started.  The number of concurrently running transactions is limited. </li></ol><br>  The idea of ‚Äã‚Äãadaptive batching resembles <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259D%25D0%25B5%25D0%25B9%25D0%25B3%25D0%25BB%25D0%25B0">Nagle</a> ‚Äôs TCP / IP <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259D%25D0%25B5%25D0%25B9%25D0%25B3%25D0%25BB%25D0%25B0">algorithm</a> .  And what is interesting: according to the results of load tests, we found out that adaptive batching reduces the latency of operations a little.  The number of simultaneous transactions decreases, and with it the load on the tables.  By the sum of factors, the solution with adaptive batching surpassed the first naive solution in all variants of scenarios. <br><br><h3>  What happens to the masters when problems arise </h3><br>  In Yandex Message Queue, as in any distributed system, emergencies may arise.  Servers are denied, disks are inhibited, the network inside and between data centers is torn. <br><br>  In such cases, YDB automatically transfers the affected tablets to a more suitable server within the cluster within a few seconds.  YMQ queuing wizards are carried along with their pills. <br><br>  Not in all cases it is possible to reliably determine the status of the server over the network, so there are situations when a new master is already running and the old one has not yet stopped working. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/yb/ay/olybayeljh8jcdbcmod9dpylopw.png" width="808" height="712"></div><br>  For YMQ, this is not a problem.  Requests to the database do not make assumptions about the accuracy of the cache of visible messages and check each of them again during the process of hiding.  Therefore, the existence of "extra" wizards only leads to a small temporary decrease in performance. <br><br><h3>  How we achieved resiliency when creating a queue </h3><br>  In YDB, it is impossible to create multiple tables and modify data in a single transaction.  For us, this meant that a queue, which is physically a set of tables, cannot be created ‚Äútransactionally‚Äù.  When racing in parallel requests or in case of machine failures, you can get an inconsistent state from which it is impossible to get out without outside intervention.  We thought and developed just such a scheme for solving the problem. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/em/eg/egemegamvnhmv-c5t8pw4im73u0.png" width="661" height="685"></div><br>  The basic idea is this: for each request for creating a queue, the necessary queue data structures are created in parallel and independently.  Thus, versions are created that at the end are ‚Äúcommitted‚Äù as a string to a special table.  The winner version is chosen, and all the ‚Äúlosers‚Äù requests understand which version has ‚Äúwon‚Äù and return the correct link. <br><br>  Such an algorithm in the ‚Äúall or nothing‚Äù paradigm is resistant to failures due to the independence of the created structures and the presence of the final transaction with the commit version.  If the commit is completed successfully, we can assume that the requested queue was created correctly. <br><br><h3>  How testing and monitoring is organized in Yandex Message Queue </h3><br>  Yandex Message Queue is a complex software and hardware complex.  He has many possible points of failure.  We must be confident in the quality of service that we provide.  Therefore, we regularly test it. <br><br><ul><li>  <b>Unit tests</b> verify the correctness of parsing requests, validation of parameters, attributes, and so on.  These tests are as fast and focused as possible. </li><li>  <b>Functional tests</b> allow you to verify the full performance of the implemented API in different situations, normal and not so.  Long enough, they are necessarily run after each change of the code in the repository. </li><li>  <b>System tests</b> do what a real user would do: they create and delete queues, set up the necessary parameters and then run a certain number of messages through them.  Check that nothing is lost and has not changed.  Also check the boundary values ‚Äã‚Äãof the parameters and the correctness of the processing of incorrect behavior.  Implemented using the boto library, working 24/7, including in the production cluster under the guise of an individual user. </li><li>  <b>Load tests</b> use the same code as the system <b>tests</b> , but they work with an increased frequency of requests and the number of messages.  Repeatedly helped us find bottlenecks in architecture. </li></ul><br>  In addition to running the tests, it is important to monitor the state of production.  To do this, we have various online checks and graphs with set thresholds and configured alerts.  Alerts come on duty.  Our daily team is involved in the daily duty. <br><br>  First of all, we track: <br><br><ul><li>  the number of errors with code 5xx, which ideally should not be at all; </li><li>  number of unsuccessful YDB transactions; </li><li>  CPU, disk, network, actor cluster system load; </li><li>  the correctness and performance of the model load, simulating the actions of a real user; </li><li>  operability of Yandex.Oblak virtual machines with our service and all related equipment. </li></ul><br>  All this helps us to ensure high reliability and availability of service through the efforts of a small team and concentrate on the development of the product. <br><br><h3>  Finally </h3><br>  The task of infrastructure teams in Yandex is to create and maintain reliable, scalable and productive solutions, based on which you can quickly and successfully launch new products that improve the lives of end users.  Inside the company, our queue service proved its usefulness long ago and became part of the Yandex.Video, Yandex.Market, Yandex.Education, Yandex.Taxi and other services architecture. <br><br>  Now it is available in the Yandex.Oblak ecosystem and can be used to build services inside and outside the Cloud itself.  Now new users receive a <a href="https://cloud.yandex.ru/docs/free-trial%3Futm_source%3Dhabr%26utm_content%3Dpost110619">cash grant</a> for registration during registration, so you can <a href="https://cloud.yandex.ru/services/message-queue%3Futm_source%3Dhabr%26utm_content%3Dpost110619">try</a> Yandex Message Queue for free. </div><p>Source: <a href="https://habr.com/ru/post/455642/">https://habr.com/ru/post/455642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../455634/index.html">Mathematics and the game "Set"</a></li>
<li><a href="../455636/index.html">The first wave affected by the Exim vulnerability. Treatment script</a></li>
<li><a href="../455638/index.html">Alan Kay did not invent objects</a></li>
<li><a href="../45564/index.html">Apple spends more money on advertising than Microsoft</a></li>
<li><a href="../455640/index.html">Marvin Minsky "The Emotion Machine": Chapter 4. "How We Recognize Consciousness"</a></li>
<li><a href="../455646/index.html">Security Week 24: factory backdoors on Android smartphones</a></li>
<li><a href="../45565/index.html">Working with get requests in JSF</a></li>
<li><a href="../455658/index.html">Legendary Intel Core i7-2600K: Sandy Bridge Testing in 2019 (Part 3)</a></li>
<li><a href="../45566/index.html">Social blog widget</a></li>
<li><a href="../455662/index.html">Large mechanical cam display as a decoder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>