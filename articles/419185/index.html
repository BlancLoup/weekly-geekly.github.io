<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An overview of current protocols for achieving consensus in a decentralized environment</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article focuses on a superficial overview of key approaches to achieving consensus in a decentralized environment. The material will allow to dea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An overview of current protocols for achieving consensus in a decentralized environment</h1><div class="post__text post__text-html js-mediator-article">  This article focuses on a superficial overview of key approaches to achieving consensus in a decentralized environment.  The material will allow to deal with the tasks that solve the considered protocols, the scope of their application, features of design and use, and also allow to evaluate the prospects for their development and implementation in decentralized accounting systems. <br><a name="habracut"></a><br>  Note that in a decentralized network, the principle of redundancy applies, which is based on the fact that nodes can do the same work.  For a centralized network, this, of course, is inefficient, and for a decentralized network, this is imperative.  We turn to the basic requirements. <br><br><h2>  Consensus protocol requirements </h2><br>  Protocols must ensure reliable operation of users in fairly harsh conditions and at the same time meet the minimum requirements.  The following are the main ones. <br><br>  <i>The absence of a central trusted party</i> .  The network consists of peers.  If an attacker or a third party tries to disable a certain number of nodes, the network will continue to operate normally until fair participants monitor the vast majority of network nodes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Honest members do not know which nodes are controlled by intruders</i> .  It is assumed that other nodes can fail at any time or function in an arbitrary manner, including coordinated by attackers to conduct an attack on the network.  Again, honest participants do not know which nodes are honest and which are bad, or unreliable. <br><br>  It is assumed that the <i>network is deliberately unreliable</i> .  Some messages may be delivered with a serious delay, while others may be lost on the network and remain completely undeliverable.  It is in such conditions that the decentralized consensus should continue to function normally: all honest nodes should come to the same state of the database of confirmed transactions. <br><br>  <i>Protocols must be completely formal</i> .  There should be no additional human involvement and no additional data is required.  All honest nodes must come to the same solution, fully following the algorithm that is performed by the computer. <br><br>  In addition, <i>there are certain assumptions under which the protocol ensures correct operation</i> .  Honest nodes should make up the majority of all participants: more than ¬Ω or ‚Öî of their total number.  However, the decision time is not limited.  The limit may concern the number of steps to make a decision, but not the time. <br><br><h2>  Application areas for consensus protocols </h2><br><h3>  Digital currencies </h3><br>  First of all, this applies to cryptocurrencies: Bitcoin uses the Nakamoto algorithm, Ethereum uses a simplified version of GHOST, Bitshares implements the Delegated PoS, and so on. <br><br>  It should be noted that a community that supports a certain digital currency is not always numerous and decentralized.  There are a number of other digital currencies that are centralized.  However, this does not mean that a mechanism for achieving consensus is not needed.  For example, Ripple uses the BFT protocol in a centralized environment. <br><br><h3>  Highly reliable and critical systems </h3><br>  Consensus protocols are used in highly reliable computing systems.  They can be used to access distributed databases when building clusters, and also necessarily used in critical technical systems: these can be control systems for aviation equipment, control systems for nuclear reactors, as well as in space technologies. <br><br>  In 2018, February 6, the Falcon Heavy was launched.  It was interesting to watch him and read technical reviews.  But it was equally interesting to read about which algorithms for reaching agreement the team uses.  Engineers were forced to use simple electronics, which are sold in regular stores and do not work reliably in difficult space conditions.  Therefore, they use multiple redundancy in their work and consensus in this case is necessary. <br><br><h2>  Cryptocurrencies </h2><br>  Cryptocurrencies work in peer-to-peer networks.  In this case, messages or transactions are transmitted between network participants at arbitrary points in time.  Suppose there are members in the US and members in Australia.  Payments that are sent from the United States will be seen by participants from America before payments sent from Australia.  This is due to the presence of serious, by computer standards, delays in the delivery of messages from one continent to another.  The situation will be similar for Australians, because they will see payments from Australia earlier than payments from the United States. <br><br>  The situation described above means that different participants in the network will see at one point in time they will see a different final state of the transaction database.  Since transactions come from users to validators at different times, a protocol is needed that will allow each node, regardless of its location, to receive all transactions in the same order. <br><br>  Basically, two approaches are used for the operation of accounting systems cryptocurrency: PoW, which is the most common, and PoS, which has been actively developing lately. <br><br>  In PoW, an extra amount of work is being done, which is now in the search for a hash function.  In fact, there is an artificial slowdown of the network to ensure security.  To accomplish a malicious action, an attacker will have to perform the required amount of work.  This requires huge energy costs and makes the implementation of attacks not very effective.  Through this approach, network reliability is ensured.  However, the need to perform such a resource-demanding task limits the bandwidth of the network that operates under this protocol.  But over the PoW approach, scientists continue to work and propose alternative schemes, as well as other resource-intensive tasks, in addition to finding the prototype of the hash function.  Recently, an algorithm based on <a href="https://cyber.stanford.edu/sites/default/files/bramcohen.pdf">proof-of-space-and-time</a> has been proposed. <br><br>  PoS allows you to provide higher network bandwidth and does not require excessive energy costs, like PoW.  However, PoS requires more serious analysis in the development and implementation of cryptocurrency. <br><br>  In accounting systems based on PoS, it is assumed that users who own a large number of coins, it is unprofitable to make attacks.  If an entrepreneur invests money in equipment and pays electricity in accounting systems based on the PoW system, and then makes a successful attack on the system, he will lose his investment in mining.  PoS uses a different approach: if it is assumed that an attacker has invested in specific coins, in whose values ‚Äã‚Äãhe is interested, then in the event of a successful attack on the system, he will lose his investments, as coins will depreciate.  Therefore, honest adherence to the protocol is considered to be the most profitable strategy. <br><br><h2>  Short glossary </h2><br>  <i>Safety</i> - the ability of the accounting system to maintain the basic principles of operation and the interests of honest participants in any malicious influences. <br>  <i>Finality</i> is a property that indicates the irrevocability of a decision made or confirmed data. <br>  <i>Liveness</i> is a property that ensures that if all honest participants want to add an entry to the common database, then it will eventually be added there. <br>  <i>Persistence</i> - the ability of the accounting system to maintain the immutability of the final state of its database even after all its validators have failed. <br>  <i>Permissioned</i> - indicates a restriction, that is, the need to obtain permission to participate in some process. <br>  <i>Permissionless</i> - means free access to taking part in a process. <br><br><h2>  Protocol to achieve consensus Ouroboros </h2><br>  Ouroboros is a PoS-based protocol that achieves a consensus between the validators of Cardano‚Äôs digital currency transactions.  Moreover, the algorithm itself is the first provably persistent among all PoS-alternatives. <br><br>  First, we consider a simpler option, oriented at the static stake, when it is assumed that the existing distribution of coins does not change. <br><img src="https://habrastorage.org/getpro/habr/post_images/2a6/d74/618/2a6d746180413c7cef60102d6e8c236d.png" alt="image"><br>  There is some genesis block and users form new transactions, but they do not significantly affect distribution. <br><br>  Genesis block contains data with some random value, with the help of which validators are selected.  They allow you to release a block at a certain point in time.  A validator who has received such a right collects transactions, receiving them from another validator, checks the correctness and releases the block into the network.  If he sees several chains, he chooses the longest of them and attaches a block to it. <br><br>  In the context of a situation with a static stake, we can use this approach for a certain period of time, but then the distribution of the stake (stake distribution) among different users may change.  In other words, some of the money goes from one user to another, and you need to adjust the probability of obtaining the right to choose a unit. <br><br>  <i>Note</i> : a static stake implies that a validator's stake time period is considered unchanged.  A validator may at this time participate in making decisions and make payments, but the number of coins in his stake, and hence the weight of his vote, will remain unchanged until the next time period. <br><br>  In the case of dynamic stake, time is divided into slots, and slots are divided into epochs.  The duration of one epoch is approximately equal to the duration of one day.  This ratio is determined from the fact that during this period of time the distribution of coins cannot change significantly. <br><br>  At the end of an era, the current distribution of coins for each of the users is recorded.  In addition, a new randomness value is generated to ensure that in the next epoch, users who are given the right to generate blocks will indeed be randomly selected according to the number of coins they have. <br><br>  Similarly, protection against so-called grinding attacks occurs when a particular user can iterate through various block options, various random variants, to form the chain in which he can maximize his profit.  Such attacks are potentially vulnerable cryptocurrency based on the first-generation PoS-protocols, such as Peercoin and NXT. <br><br>  The creators of this algorithm solved the above problems.  Validators launch a special protocol between themselves, called MPC (multi-party computation), which makes it possible to generate randomness together.  This protocol is also provably persistent, it is based on the already well-known approaches. <br><br>  The Ouroboros protocol provides persistence under the majority of honest validators in the system.  If honest participants who work on the release of blocks control more than 50% of the coins in the system, the protocol can be considered protected. <br><br>  A mechanism of incentives (motivation) to honest behavior has been developed.  With the help of game theory, it is proved that the validator receives the maximum benefit when he follows the rules of the protocol.  Any participation in the commission of attacks not only does not increase the participant's profit, but in some cases may reduce it.  Therefore, the most profitable strategy for a validator is to honestly follow the rules of the protocol. <br><br>  The capacity of the accounting system will be limited only by delays during network synchronization.  This protocol provides high energy efficiency compared to proof-of-work, since mining farms are not needed here.  Now for the collection of transactions and the release of blocks rather ordinary personal computer.  In the future, these calculations can be performed even on a regular smartphone. <br><br>  The limitations of the Ouroboros protocol include the fact that the first version of the protocol is synchronous.  This means that messages between participants must be delivered in a limited period of time.  If the network will appear longer delays than laid down in the rules, it can reduce security.  Nevertheless, the use of the next version of the protocol, Ouroboros Praos, is already planned.  In it, even with increasing network delays, full security is guaranteed. <br><br><h2>  Problems with PoW in Bitcoin </h2><br>  Consider a way to achieve the consensus that underlies bitcoin.  Some of the blocks that are generated by honest users are still discarded - these are the so-called orphan blocks.  These blocks are generated in parallel with the main chain, but most of the network decided that this chain should not be continued, and the blocks are discarded. <br><br>  When there are few such blocks, there is nothing scary about it.  However, if there are many of them, the network does not have time to synchronize and it turns out that some of the computing power of honest users of the network is wasted.  This means that now the attacker needs to fight not for 51% of the computing power of the network, but in fact for a smaller percentage.  If this value is 20%, then an attacker with a 20% computing power and a large delay in the delivery of network messages can realize a double-spending attack. <br><br>  Therefore, in Bitcoin, the time interval between mined blocks lasting 10 minutes is set.  Due to this, the network manages to synchronize clearly and the probability of the appearance of such blocks decreases.  If you need to increase network bandwidth by increasing the frequency of block formation, you will need another solution. <br><br><h2>  Ghost </h2><br>  The first such solution was the GHOST PoW protocol.  Its simplified version is used in the Ethereum platform. <br><img src="https://habrastorage.org/getpro/habr/post_images/61b/2ba/ff2/61b2baff2b3749a33a35ac59ab6d5008.png" alt="image"><br>  In this case, the attacker can pull his chain (indicated in red in the figure) and make it the longest, but it will not be advantageous.  Honest users will follow the chain that they built before. <br><br>  In this case, honest users may have two chains.  The longest (1B-2D-3F-4C-5B), but it will be shorter than the attacker's chain.  The peculiarity of GHOST is that the algorithm does not focus on the longest chain, but on the number of blocks in the tree formed by the current chain.  It takes into account not only the length of the chain itself, but also the blocks at its various heights.  Thus, it turns out not a linear chain, but a tree.  It takes into account the number of blocks that it contains. <br><br>  If you look at the chain 1B-2C-3D-4B, you can see the accompanying blocks 3E and 3C.  By the number of blocks and the work expended, this chain has the greatest complexity and it will be taken as the main one.  Honest users will continue to consider it the main one, despite attempts by the attacker to attack the network.  In the traditional Nakamoto consensus, such an attack would have been successful, but for GHOST it does not pose a threat. <br><br>  Nevertheless, the disadvantage of GHOST is the fact that some blocks are still lost.  In this case, the 2D-3F-4C-5B chain will still be discarded.  Therefore, the question of dropping blocks of honest users remains open. <br><br><h2>  SPECTER and PHANTOM </h2><br>  In order to increase the frequency of block formation and solve the problem of dropping blocks of honest users, two more PoW protocols were proposed: SPECTER and PHANTOM. <br><img src="https://habrastorage.org/getpro/habr/post_images/e8c/66d/ac6/e8c66dac6444a12fb3bd833d22384336.png" alt="image"><br>  They use not even the tree structure, but the so-called directed acyclic graph (directed acyclic graph, DAG).  In this case, the validator includes in the header of its block pointers to blocks that other validators do not refer to, at least in the network state that it sees at the current time, and sends the block further. <br><br>  Therefore, it turns out such a structure, which generally includes all the blocks that validators see at the current time.  Here, the mining powers of honest users are not lost at all.  Moreover, it provides high network bandwidth and high security.  The advantage of this approach is the fact that the system is truly decentralized. <br><br>  Let's compare the features of the Bitcoin network and the network that works using the SPECTER and PHANTOM protocols.  If we talk about the current situation in the Bitcoin network, then great importance should be given to mining pools.  In modern Bitcoin 144 blocks are released per day.  This figure is obtained if the number of minutes in a day is divided by 10. It may be quite possible that the validator bought the equipment, paid for electricity for a long time, but it did not work out to generate the unit, but during this time the equipment is outdated and use it more it makes no sense.  To avoid this situation, enterprising validators are combined into mining pools.  In most mining pools there is a leading (company / organization) that inclines modern Bitcoin to centralize the process of validating new transactions. <br><br>  In the case of SPECTER and PHANTOM, mining pools are not needed at all.  If we draw a parallel with the modern Bitcoin network, then each user of the network that uses the SPECTER and PHANTOM protocols has a chance to release one block per day.  Thus, in the mining pools there is no need at all and we come to a truly decentralized network. <br><br>  So, SPECTER and PHANTOM protocols provide a high level of decentralization and high network bandwidth, but a large amount of information is required to be stored. <br><br><h2>  BFT protocols </h2><br>  The next type of protocol that is applied is the BFT protocols (Byzantine Fault Tolerance). <br><img src="https://habrastorage.org/getpro/habr/post_images/2e8/cc8/390/2e8cc83900502c78dcdd91dbbc164f8b.png" alt="image"><br>  The name has its origin in the comic description of the problem that was made in the 80s of the 20th century when developing a protocol for highly reliable systems.  An example was given about the Byzantine generals who are organizing an attack on a city.  The task of the generals was to come to a single solution.  But it was necessary to take into account that among them there are several traitors.  Traitors could behave in an arbitrary manner and, moreover, they could influence the transfer of messages between honest generals, for whom it is important to either simultaneously attack the city or retreat at the same time.  If one of the honest generals retreats, the enemy will defeat the army piece by piece.  Therefore, they needed to come to an agreed decision.  The formulation of the problem in this way was done in the work, from which came the name of the algorithm for achieving consensus. <br><br>  For BFT protocols, peer-to-peer communication is assumed.  It is assumed that there are a certain number of intruders who can act in a coordinated manner.  They are unknown to honest participants.  The network may have failures and delays, that is, some messages may disappear, and some may come with a long delay.  However, a limit is imposed on the number of steps during which all honest validators must come to a common decision.  In the example task there are two options: attack or retreat. <br><br>  It is assumed that honest nodes are more than ‚Öî participants.  BFT protocols are guaranteed to come to a common solution, which cannot be canceled in the future.  For non-BFT protocols, the probability of reversal is exponentially decreasing, but not zero. <br><br>  At the heart of Bitcoin and other modern widespread cryptocurrencies are not BFT protocols.  For Bitcoin, there is a non-zero probability, which is negligible, that there is an alternative chain, stretching, for example, from the previous month, year, or even from the Genesis block.  The probability of cancellation of the current chain is exponentially decreasing, but it exists.  In the case of a BFT protocol, the decision cannot be canceled. <br><br><h2>  Examples of BFT protocols </h2><br><h3>  Practical bft </h3><br>  The first protocol that was put into practice was called Practical BFT.  It was proposed in 1999.  He has a fairly simple functioning.  The client accesses the server that he chooses the leader.  The leader sends these messages to other servers.  After this, the servers inform each other that certain messages have arrived and they need to be entered into a joint database.  Each validator must confirm that he received confirmation from ‚Öî other participants. <br><br>  When the validator received confirmation from ‚Öî other participants about the inclusion of the message in its copy of the database, it is entered into the local copy of this validator. <br><img src="https://habrastorage.org/getpro/habr/post_images/3df/d12/e72/3dfd12e72841067603f9d76466de6847.png" alt="image"><br>  The protocol is energy efficient, provides high bandwidth and fast transaction confirmation, but unfortunately works for a small number of validators.  If we design a cluster, file system or cloud on the basis of this protocol, then it works efficiently, but if we start using a large number of nodes, we get a rapid increase in the number of messages and a very large increase in network load.  In the latter case, the protocol does not work efficiently, especially when the network works with delays, skips messages, and so on. <br><br>  In addition, the base case assumes the presence of a leader, which could be a DoS attack point for stopping the work of the accounting system by an attacker. <br><br><h3>  HoneyBadger BFT </h3><br>  HoneyBadger BFT is well established and has been designed as an improved version of one of the existing algorithms.  It uses a number of features, including cryptographic protection of all messages that are transmitted over the network.  Transactions are decrypted only after reaching a certain agreement on them.  HoneyBadger consists of two protocols: RBC (Reliable broadcast) and BA (Byzantine Agreement). <br><img src="https://habrastorage.org/getpro/habr/post_images/87b/3a4/28f/87b3a428fad9f3266abcc85518787f5b.png" alt="image"><br>  Using the RBC protocol, messages are delivered over the network.  This protocol completes its work only after it receives confirmation that at least ‚Öî honest validators received the required set of messages.  After that, the validators go to the BA-protocol and the coordination of the transactions themselves, which are then sent to the network. <br><br>  This protocol provides strong cryptographic protection.  It works well in networks with poor data transmission quality, where there are gaps in transmitted messages and delays in their delivery, as well as in networks with serious malicious interference with work.  There is no leader here.  The protocol suffers when trying to scale up significantly: with hundreds of validator nodes, it still works fine, but with several thousand it already puts too much load on the network and the transaction confirmation time increases greatly.  In a fully decentralized network of the accounting system, where thousands of validators work, the protocol becomes ineffective. <br><br>  The result of further development are the Algorand and Hashgraph protocols. <br><br><h3>  Algorand </h3><br>  Algorand protocol was proposed in 2017.  He uses the same BFT approach, but he focuses on the fact that among all the participants a certain subcommittee is selected at random, which performs the confirmation of transactions.  Moreover, this confirmation occurs in several stages, at each of which its own subcommittee is selected. <br><img src="https://habrastorage.org/getpro/habr/post_images/b41/2e4/66e/b412e466e304f0244cdf836ec02ffe4c.png" alt="image"><br>  The protocol guarantees with a high probability, close to one, that the subcommittee is honest, if more than ‚Öî of the network members are honest, that is, each of the subcommittees will also have ‚Öî honest members.  There is no leader here, so there is no point for denial of service attacks (DoS attacks).  This protocol provides a high bandwidth accounting system, fast transaction confirmation, and protection against adaptive corruption. <br><br>  It is assumed that an attacker can choose an arbitrary validator and declare that it is he who works in his interests.  An attacker can choose the nodes that will work for him (mandatory for correct operation is the condition that there are more than  honest participants).  And even in such conditions, the protocol provides durability. <br><br>  Since this is a BFT protocol, in any case, it provides safety and persistence properties.  And the rest of its properties will depend on delays in the transmission of data via communication channels. <br><br>  If this protocol works in a problem network, then there is a threat of liveness, due to the fact that new transactions may not receive confirmation.  If there are too long delays on the network or the attacker gets the opportunity to throw out the messages that he needs to throw out to achieve the goal, then this will not affect the old (already confirmed) transactions.  He will not be able to cancel them.  The bottom line is that he will be able to reject the acceptance of new transactions. <br><br><h3>  Hashgraph </h3><br>  The Hashgraph protocol is a fresh solution with very good properties.  Each validator collects its transactions, selects a different participant in an arbitrary manner, and sends it data about its transactions, as well as information that other nodes have informed it when they connected to it. <br><img src="https://habrastorage.org/getpro/habr/post_images/f51/877/2cf/f518772cfe5c5933570e08bf6a556b20.png" alt="image"><br>  So, the operation is very simple: the validator "listens", accepts all the messages that come to him, and then arbitrarily chooses another participant and sends him all the transactions with his. <br><br>  Hashgraph ensures that in a finite number of steps, that is, rounds of the protocol, all nodes come to a single solution.  The protocol works quickly and scales well.  It requires more traffic than Algorand, but at the same time is very efficient.  Hashgraph provides the properties of safety and liveness, that is, adding new transactions and coming to a single solution.  It even works in a fully asynchronous network, when messages can be delayed for a very long period of time or thrown out altogether. <br><br>  In addition, there is no leader in the network, which allows an attacker to disable those nodes that are interesting to him, which may force them to work according to their intentions.  However, while ‚Öî honest users remain, the protocol provides a high level of security. <br><br><h2>  BFT totals </h2><br>  Let's summarize the BFT protocols.  They provide very high throughput and allow validators to agree on the status of transactions for a fixed number of steps.  These properties allow them to be successfully used in cryptocurrencies.  The protocol ensures reliable operation even in unreliable networks, provided that more than ‚Öî of the validators of the accounting system are honest.  Protocols such as Algorand and Hashgraph support high bandwidth and they can have a really large number of validators. <br><br>  At the same time, they have a very serious drawback: in the current state of development, protocols have been developed for the so-called permissioned accounting systems.  In other words, they are designed without considering the incentive for validators to work honestly in the network itself.  It is assumed that such incentives are outside the scope of this protocol.  Rewards for the formation of the block, various strategies of user behavior are not considered. <br><br>  To deploy such protocols to work in permissionless accounting systems, researchers will need to carry out serious work.  In this regard, they have a wide area for research in terms of game theory and in terms of developing a reward system for validators, etc. <br><br>  <i>Distributed Lab prepared this article based on the material of the <a href="https://www.youtube.com/watch%3Fv%3DhE2JtzgywDo%26index%3D19%26list%3DPLhZQuknA7yUBt82ow8rEfw_G8tNZjt3qB">video lecture of</a> Roman Oleinikov.</i> <br><br><h2>  Frequently asked Questions </h2><br>  <i>- Is it possible in the near future to introduce a radically new consensus protocol and is there any development?</i> <br><br>  Now, indeed, consensus protocols are being actively developed.  Some of them we discussed today: Algorand and Hashgraph from the BFT protocols, as well as the protocol based on the Ouroboros PoS consensus.  At the beginning of 2018, the PHANTOM protocol was presented.  These are new protocols with new principles. <br><br>  <i>- How does Ouroboros ensure that the list of nodes that have the right to form a block at specific time intervals is the same for all nodes?</i> <br><br>  The issue is related to the grinding attacks mentioned above.  Ouroboros provides persistence and liveness properties: if a transaction hit at a certain point in time and received confirmation, then it can no longer be canceled or deleted, since the probability of replacing this block tends to zero.  In other words, the developers believe that the transaction cannot disappear from the shared database, since it is available to anyone. <br><br>  Due to the persistence property, all network nodes form the same set of transactions in their local copy of the database.  Potential validators send transactions with their own randomness, which is initially hidden, and at the time when the MPC protocol ends, everyone can calculate the resulting randomness.  All users have a consistent transaction history, so that all nodes get the same list of actual validators.  It is impossible to manipulate randomness here, because the MPC protocol provides properties related to the fact that none of the participants can receive this randomness until all have entered it into the blockchain.  Only after this accident is revealed.  Even if someone does not want to open his chance, the protocol itself ensures that this data will be opened.  Everyone has the same vision of history and chance.  Even if at least one potential validator "forwarded" a truly random value in the blockchain (one is enough), the resulting randomness will be unpredictable. <br><br>  <i>- In which book can you read about the consensus-building algorithms discussed in this chapter?</i> <br><br>  Unfortunately, there are no such books yet.  There are only selected scientific papers and articles.  You can see articles on PHANTOM, SPECTER and Ouroboros.  You can see the <a href="https://eprint.iacr.org/">site</a> where these articles can be found by title. <br><br>  <i>- Why so many blocks to issue in PHANTOM and SPECTER, if there is not such a large number of transactions?</i>  <i>Most blocks will be empty or contain few transactions.</i> <br><br>  PHANTOM and SPECTER are focused on scaling.       ,             . PHANTOM  SPECTRE ,             .         ,     .  ,          .   ,  , ,   . <br><br> <i>‚Äì     BFT  -?</i> <br><br>     .     PBFT,         -,     .     Algorand  Hashgraph,    . <br><br> <i>‚Äì     PBFT      ?</i> <br><br>     ( )     .      ,    ,       ,              . <br><br> <i>‚Äì   ,  Algorand ‚Äì    DPoS (Delegated Proof-of-stake)</i> <br><br> ,    . Delegated Proof-of-stake ,          .        .            Algorand,        ,        . <br><br> <i>‚Äì       ,     ?</i> <br><br> SPECTRE  PHANTOM ‚Äì   .   SPECTRE   ,     . </div><p>Source: <a href="https://habr.com/ru/post/419185/">https://habr.com/ru/post/419185/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419173/index.html">Clean architecture in the context of cross-platform development</a></li>
<li><a href="../419177/index.html">Amazing Amazon Patterns</a></li>
<li><a href="../419179/index.html">Pure pragmatic architecture. Brainstorm</a></li>
<li><a href="../419181/index.html">Programming the mouse: how we run away from the routine with CRM</a></li>
<li><a href="../419183/index.html">Demopati in Helsinki "Assembly 2018" photo report, the first day</a></li>
<li><a href="../419193/index.html">Understanding JavaScript Objects</a></li>
<li><a href="../419199/index.html">Report of the Club of Rome 2018, Chapter 3.5: ‚ÄúSome Success Stories in Agriculture‚Äù</a></li>
<li><a href="../419201/index.html">What startups are looking for Y Combinator in 2018</a></li>
<li><a href="../419203/index.html">The broadcast of the second day of Slurm: Intensive on Kuburnethes</a></li>
<li><a href="../419205/index.html">New Mikrotik vulnerability? No, but it's worth checking your devices.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>