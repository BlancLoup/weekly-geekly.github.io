<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tracing and Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ever ran your app runtime? Do you know how many requests do that gray endpoint that? And how long are those cross-references for a similar type of res...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tracing and Javascript</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ns/ix/mt/nsixmt8c-lpfagcdsi6mebh7gcy.png"><br><br>  Ever ran your app runtime?  Do you know how many requests do that gray endpoint that?  And how long are those cross-references for a similar type of resources from each entity page that need to be returned to the request?  Have you tried to measure how long the user has to wait due to optional query fields, which he adds from time to time?  Have you ever wondered what will happen if you parallel these six queries to those two databases? <br><br>  If anything above sounds interesting, or at least familiar, welcome to cat. <br><a name="habracut"></a><br><h4>  chrome: // tracing </h4><br>  If you enter <a href="http://chrome//tracing">chrome: // tracing</a> in the Chrome address bar, you will be taken to this page: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/pc/k4/57/pck457e8s_pydgluddwkf058-3i.png"><br><br>  The tool itself is very close to the V8 (and chrome) trace data itself.  And more recently, node also <a href="https://nodejs.org/api/tracing.html">allows</a> natively to trace runtime with chrome support: // tracing as a frontend.  To trace, simply click the cherished ‚ÄúRecord‚Äù and make several passes over the adjacent tab, after which you can observe in detail what exactly the browser did when you diligently chatted the cursor inside the window, randomly turning the mouse wheel.  For our convenience, kind people even wrote a very <a href="https://www.chromium.org/developers/how-tos/trace-event-profiling-tool/using-frameviewer">detailed article</a> on how to interpret the results. <br><br>  The format of the data consumed by this visualizer is <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview">well documented</a> , and is great even for tracing things that are distant from rendering, calculating garbage markup and trapping.  Due to its openness and ability to download external files, this tracer is fairly easy to integrate with any environment capable of any I / O.  In addition to the visualization itself, there are some built-in capabilities for analyzing groups of events.  In general, a useful and flexible tool that can be useful and great help, where in the traditional case it would be necessary to parse tons of logs in search of certainty. <br><br>  The entire frontend tracer, by the way, is written in vanilla JS and lies on <a href="https://github.com/catapult-project/catapult/tree/master/tracing">GitHub</a> .  The chrome: // tracing itself is a regular web page and can be inspected through DevTools like any other.  That is, if the tool can not satisfy you ... completely, then it can be safely mashed under the necessary scenario. <br><br>  In the author's experience, the need for such an instrument appeared while working on a serverless system for the interethn of things.  In certain scenarios, the number of launches of lambda functions reached tens and hundreds to perform a single operation.  Analyzing all the insides of these launches by just the logs was not fun at all.  I wanted something that would help to look at the picture with one look at the whole.  The samopisny tracer, who could instruct the insides of our functions and all the queries they did, helped.  On the mountain, the author then did not even suspect the existence of chrome: // tracing, so the frontend was written from scratch on d3, to which a separate post can be dedicated (tldr; do not render anything complicated via DOM, only canvas and WebGL).  Let's now look at a few examples where tracing helped with optimization: <br><br><div class="spoiler">  <b class="spoiler_title">Warming up the cache</b> <div class="spoiler_text">  <b>Given:</b> an asynchronous memory service and several sub-services that call it. <br><br>  Problem: with several calls to the caching service in a row, the result does not have time to get into the cache, respectively, instead of one request, the service makes n. <br><br>  <b>Solution:</b> warming up the cache (prefetch, works if the series of calls needs the same dependency), or lazy blocking memoization (the name is improvised) <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachingService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } doAction() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.process(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherService() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = result) .then(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.process); } } } <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([ cachingService.doAction(), cachingService.doAction(), cachingService.doAction() ]); <span class="hljs-comment"><span class="hljs-comment">// Prefetch: anotherService() .then(result =&gt; cachingService.cache = result) .then( () =&gt; Promise.all([ cachingService.doAction(), cachingService.doAction(), cachingService.doAction() ]) ) // Lazy blocking memoization: class FixedService { constructor() { this.pendingRequest = null; } doAction() { const pendingRequest = this.pendingRequest ? this.pendingRequest : this.pendingRequest = anotherService(); return pendingRequest .then(this.process); } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Undocumented requests</b> <div class="spoiler_text">  <b>It is given:</b> one of the SDKs with each initialization did additional blocking requests (and let the whole world wait) about which we did not suspect, they were not logged in any way and were not documented. <br><br>  <b>Solution:</b> SDK instrumentation to disable this ‚Äúharmful‚Äù request. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Abnormally long execution of custom scripts</b> <div class="spoiler_text">  <b>Given:</b> tracing showed that user scripts for several lines are executed two orders of magnitude longer than expected.  Debug showed that the problem is excessive use of variables from the global skoupa. <br><br>  <b>Solution:</b> simulation of global scopes for user code through function arguments <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vm = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'vm'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> scope = { <span class="hljs-attr"><span class="hljs-attr">property</span></span>: <span class="hljs-string"><span class="hljs-string">'value'</span></span>, <span class="hljs-comment"><span class="hljs-comment">// ... propertyN: 'valueN' }; const script = ` property = '0.6911'; propertyN = '42'; `; // Overusing global scope vm.runInNewContext( script, scope ); // Argument based scoping vm.runInNewContext( ` ( // Turn scope keys into arguments of wrapper function ({ ${Object.keys(scope).join(',') } }) =&gt; { ${script} } )(this.scope); `, { scope } );</span></span></code> </pre><br>  The code above simulates the global variables for the script through the arguments of a virtual function (hello, CommonJS). <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Premature data normalization</b> <div class="spoiler_text">  <b>Given:</b> Some entities are quite large (2.5-3Mb) <br>  Problem: suspicion that such entities are long and expensive to download over the network. <br><br>  <b>Solution:</b> tracing showed that loading such entities is one of the cheapest operations and there are much deeper problems that need to be solved.  The data helped to concentrate refactoring on parts of the system, which gave a multiple increase in performance after improvement. <br></div></div><br>  In addition to these examples, there were a lot of cases when the tracer helped to quickly and accurately assess the effects of changes, made it possible to look at the whole picture, avoiding the ‚Äúline-by-line‚Äù information absorption, generally manifesting itself as a tool that simplifies life. <br><br><h3>  The device is a simple tracer </h3><br>  Turning to the practical implementation of the simplest tracer, they can be divided into two large groups, according to the method of code instrumentation: <br><br><ul><li>  <i>Centralized</i> - all capture points are set from a single point in the code.  The tracer calls the necessary application modules and overloads the entry points to them. </li><li>  <i>Distributed</i> - all capture points are determined at the place of need, directly calling the tracer code.  Directly determine the beginning of the event and its end. </li></ul><br>  The centralized approach is good because the instrumented code remains clean and almost independent of the tracer.  But, at the same time, there are implicit dependencies that need to be explicitly supported.  In this case, for example, special annotations, or a separate integration test for the tracer, which confirms that all necessary modules are in their places along with capture points, can help. <br><br>  The distributed approach is good because it can be very situational to determine the duration and content of events, including in them whole blocks of useful code.  Also, it is simpler for the initial implementation, because the tracer is free from the need to abstract potential errors in an abstract way and to ensure a constant flow of execution. <br><br>  The most trivial example of the second type tracer might look like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tracer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.events = {}; } start(meta) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random().toString(<span class="hljs-number"><span class="hljs-number">16</span></span>).substr(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.events[id] = { start, id, meta }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id; } stop(id) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.events[id].stop = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); } }</code> </pre><br>  Everything is pretty trite and the tracer should not worry about any third-party effects of the code being programmed.  Also, never use anything like `Math.random (). ToString (16) .substr (2);`, this example is purely for illustration, there are much more <a href="https://www.npmjs.com/package/random">correct</a> <a href="https://www.npmjs.com/package/uuid">ways</a> . <br><br>  As soon as we want to move to a centralized approach, we will need an abstract interface for setting capture points: <br><br><pre> <code class="javascript hljs">addHook(path, method) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(path); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> originalMethod = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method]; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> event = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.start(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = originalMethod.apply(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.end(event); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br>  This method can be called in the only place that will be the heart of the configuration.  Normal monkey-patching, even nothing to add.  It is easy to see that the method has several drawbacks: <br><br><ul><li>  Module location relative to the tracer </li><li>  No input checks </li><li>  No support for asynchronous functions. </li></ul><br>  The first drawback is caused by poor forethought of the interface of this function.  Making the tracer allow file paths for instrumentation is a dubious idea, since  For the end user, this adds an extra layer of implicit processing, which leads to doubts about the tracer interface.  ‚ÄúShould I pass that path?‚Äù, ‚ÄúShould the path be relative to my file or the tracer file?‚Äù, ‚ÄúShould I write a standard footprint with __dirname and path.resolve?‚Äù - this can be avoided by simply passing the module itself, which need to tool: <br><br><pre> <code class="javascript hljs">addHook(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, method) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> originalMethod = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method]; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> event = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.start(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = originalMethod.apply(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.end(event); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br>  In addition to more explicit behavior for the user, this allows you to simplify the validation for existence: <br><br><pre> <code class="javascript hljs">isInstrumentable(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, method) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method] === <span class="hljs-string"><span class="hljs-string">'function'</span></span>); } addHook(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, method) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isInstrumentable(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, method)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> originalMethod = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method]; <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>[method] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> event = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.start(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = originalMethod.apply(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.end(event); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } } }</code> </pre><br>  Behavior with an invalid configuration can be hard (throw an error) or soft (ignore the module, continue operation).  Theoretically, a good tracer should allow to follow any of the paths using the configuration, since both options can be justified in different cases. <br><br>  Processing asynchronous functions is a slightly more interesting task.  First, you need to determine if the instrumented method is asynchronous, and change the behavior of the tracer to determine the end of the event.  To do this, you can modify our overloaded method as follows: <br><br><pre> <code class="javascript hljs">addHook(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, method) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isInstumentable(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>, method)) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tracer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> originalMethod = service[method]; service[method] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> eventId = tracer.start(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { result = originalMethod.apply(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { tracer.stop(eventId, { <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">error</span></span>: errorToString(error) }); <span class="hljs-comment"><span class="hljs-comment">// rethrow to keep the flow as it would // be without having tracker at all throw error; } if (result instanceof Promise) { // Handle services returning promises return result .then( tracer.handleResolved(eventId), tracer.handleRejected(eventId) ); } else { // Handle synchronous services tracer.stop(eventId); return result; } }; } } handleResolved(event) { return res =&gt; { this.stop(event); return res; }; } handleRejected(event) { return err =&gt; { this.stop(event); return Promise.reject(err); } }</span></span></code> </pre><br>  From the interesting, the tracer must guarantee the absence of third-party effects at run time.  Therefore, it must forward any word errors back into the application flow. <br><br>  That's all, such a primitive tracer can already be used for something useful.  Of the additional features that can be puzzled: <br><br><ul><li>  Support of before and after capture points for the code being instructed, with passing arguments and return result for any other additional actions </li><li>  Support of events of various types by name, it is just convenient </li><li>  Support for saving metadata about the success of each event </li><li>  Support for saving results from an instrumented method </li><li>  A library of standard capture points for node.js public interfaces and popular libraries </li><li>  Support for export in other formats, for example: Open Tracing </li><li>  The ability to remotely start tracing sessions with sending the result to the client </li><li>  Protection against unintentionally long sessions (in our memory there were cases when the included tracer generated several gigabytes of data and dropped the parent application). </li></ul><br>  After the events are recorded, all that remains is to save them in a format suitable for chrome: // tracing.  To do this, you can use the following function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toChromeTracingEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parsed = url.parse(event.meta.url); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> base = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: event.id, <span class="hljs-attr"><span class="hljs-attr">pid</span></span>: process.pid, <span class="hljs-attr"><span class="hljs-attr">tid</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">cat</span></span>: event.type, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: event.meta.method, <span class="hljs-attr"><span class="hljs-attr">args</span></span>: event.meta }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, base, { <span class="hljs-attr"><span class="hljs-attr">ph</span></span>: <span class="hljs-string"><span class="hljs-string">'b'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ts</span></span>: event.start * <span class="hljs-number"><span class="hljs-number">1000</span></span> }), <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.assign({}, base, { <span class="hljs-attr"><span class="hljs-attr">ph</span></span>: <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-attr"><span class="hljs-attr">ts</span></span>: event.stop * <span class="hljs-number"><span class="hljs-number">1000</span></span> }) ]; }</code> </pre><br>  The bottom line is that each event of the tracer is expanded into two objects representing the beginning and end of an asynchronous chrome: // tracing event.  In addition to asynchronous events, you can create and ‚Äúcompleted‚Äù (Completed) events.  But they overlap each other when rendering in chrome: // tracing, which is why it is not so easy to analyze them: 3 <br><br>  After all the events have been converted, it‚Äôs just left to carefully stack them with an array in the field of the `traceEvents` object and save it somewhere, from where it will not be painfully long to search through the file explorer. <br><br>  The final step is to add instrumentation to the part of your application where something implicit happens, run it and load the resulting file into chrome: // tracing. <br><br>  <a href="https://github.com/av/tohu">Tracer that inspired this article</a> . <br><br>  Let the work be interesting! </div><p>Source: <a href="https://habr.com/ru/post/354716/">https://habr.com/ru/post/354716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354706/index.html">Twirp vs. gRPC. Is it worth it?</a></li>
<li><a href="../354708/index.html">Transparent HTTPS proxy to bypass Roskomnadzor‚Äôs locks</a></li>
<li><a href="../354710/index.html">MikroTik & OpenWRT & DNSCrypt</a></li>
<li><a href="../354712/index.html">Hosting VPS: Windows or Linux?</a></li>
<li><a href="../354714/index.html">Bioyino - a distributed, scalable metric aggregator</a></li>
<li><a href="../354718/index.html">Clang. Part 1: introduction</a></li>
<li><a href="../354720/index.html">Mikrotik - collecting and analyzing NetFlow traffic</a></li>
<li><a href="../354722/index.html">Failover VoIP Cluster 3CX</a></li>
<li><a href="../354724/index.html">Marvin Minsky "The Emotion Machine": Chapter 3 "The Pain"</a></li>
<li><a href="../354726/index.html">Who scans the Internet and does Australia exist</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>