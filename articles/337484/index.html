<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does the video processor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Approx. Lane: The original article is called GPU Performance for Game Artists, but as it seems to me, it will be useful for anyone who wants to have ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does the video processor</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a01/c61/f77/a01c61f77556fef085d9a17238e1601a.png" alt="image"><br><br>  <i>[Approx.</i>  <i>Lane: The original article is called GPU Performance for Game Artists, but as it seems to me, it will be useful for anyone who wants to have a general understanding of the video processor's work]</i> <i><br></i> <br>  For the speed of the game are responsible for all team members, regardless of position.  We, 3D programmers, have ample opportunities to control the performance of the video processor: we can optimize shaders, sacrifice picture quality for speed, use more cunning rendering techniques ... However, there is an aspect that we cannot fully control, and this is the graphic resources of the game. <br><br>  We hope that artists will create resources that not only look good, but will also be effective in rendering.  If artists know a little more about what is happening inside the video processor, this can have a big impact on the frame rate of the game.  If you're an artist and want to understand why aspects such as draw calls, levels of detail (LOD) and MIP textures are important for performance, then read this article.  To take into account the impact that your graphics resources have on game performance, you need to know how polygonal meshes come from the 3D editor on the game screen.  This means that you need to understand the work of the video processor, the chip, the graphics card manager and the person responsible for the three-dimensional rendering in real time.  Armed with this knowledge, we will look at the most frequent performance problems, analyze why they are a problem, and explain how to deal with them. <br><a name="habracut"></a><br>  Before we begin, I would like to emphasize that I will intentionally simplify a lot for the sake of brevity and clarity.  In many cases, I summarize, describe only the most typical case, or simply drop some concepts.  In particular, for the sake of simplicity, the ideal version of the video processor described in the article is most similar to the previous generation (DX9 era).  However, when it comes to performance, all the arguments below are fully applicable to modern PC hardware and consoles (but perhaps not to all mobile video processors).  If you understand everything written in the article, it will be much easier for you to cope with variations and difficulties that you will encounter in the future if you want to understand more deeply. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Part 1: bird flight rendering pipeline </h1><br>  To display a polygonal mesh on the screen, it must pass through a video processor for processing and rendering.  Conceptually, this path is very simple: the grid is loaded, the vertices are grouped into triangles, the triangles are converted into pixels, each pixel is assigned a color, and the final image is ready.  Let's take a closer look at what happens at each stage. <br><br>  After exporting the grid from the 3D editor (Maya, Max, etc.), the geometry is usually loaded into the game engine in two parts: a vertex buffer (Vertex Buffer, VB) containing a list of grid vertices with their associated properties (position, UV coordinates , normal, color, etc.), and an index buffer (Index Buffer, IB), which lists the vertices from VB, connected in triangles. <br><br>  Together with these geometry buffers, the mesh is also assigned a material that determines its appearance and behavior in various lighting conditions.  For a video processor, this material takes the form of specially written <b><i>shaders</i></b> ‚Äî programs that define the way vertices are processed and the color of the final pixels.  When choosing a material for the mesh, you need to adjust various parameters of the material (for example, the value of the base color or the choice of texture for different maps: albedo, roughness, normal maps, etc.).  All of them are passed to shader programs as input. <br><br>  The mesh and material data is processed by various stages of the video processor pipeline to create the pixels of the final <b><i>target render</i></b> (the image into which the video processor is writing).  This target render can later be used as a texture in subsequent shaders and / or displayed on the screen as the final image of the frame. <br><br>  For the purposes of this article, the important parts of the video processor pipeline are the following, from top to bottom: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/535/06b/be7/53506bbe7e74de7787a15d7f021ee7ac.png" alt="image"></div><br><ul><li>  <b>Input Assembly.</b>  The video processor reads the vertex and index buffers from memory, determines how the triangle-forming vertices are connected, and transfers the rest to the pipeline. </li><li>  <b>Vertex Shading (Vertex Shading).</b>  The vertex shader is executed for each of the grid vertices, processing on a separate vertex at a time.  Its main task is to <b><i>transform the</i></b> vertex, get its position and use the current camera settings and the viewing area to calculate its location on the screen. </li><li>  <b>Rasterization (Rasterization).</b>  After the vertex shader is executed for each vertex of the triangle and the video processor knows where it appears on the screen, the triangle is <b><i>rasterized</i></b> - converted to a set of individual pixels.  The values ‚Äã‚Äãof each vertex are UV coordinates, vertex color, normal, etc.  - interpolated by the pixels of the triangle.  Therefore, if one vertex of the triangle is black and the other is white, then the pixel rasterized in the middle between them will receive the interpolated gray color of the vertices. </li><li>  <b>Pixel Shading.</b>  Then, for each rasterized pixel, a pixel shader is executed (although technically at this stage it is not a pixel, but a ‚Äúfragment‚Äù, therefore sometimes a pixel shader is called fragmentary).  This shader programmatically imparts a pixel color, combining material properties, textures, light sources, and other parameters to get a specific look.  There are a lot of pixels (the target render with a resolution of 1080p contains more than two million), and each of them needs to be shaded at least once, so usually the video processor spends a lot of time on the pixel shader. </li><li>  <b>Output target render (Render Target Output).</b>  Finally, the pixel is written to the target render, but before that it passes some checks to make sure it is correct.  The depth test discards pixels that are deeper than the pixel already present in the target renderer.  But if a pixel passes all checks (depth, alpha channel, stencil, etc.), it is recorded in the target render stored in memory. </li></ul><br>  There is much more action, but this is the main process: a vertex shader is executed for each vertex in the grid, each triangle vertex is rasterized into pixels, a pixel shader is executed for each rasterized pixel, and then the resulting colors are written into the target render. <br><br>  Shader programs that specify the type of material are written in the shader programming language, for example, <i>HLSL</i> .  These shaders are executed in the video processor in much the same way as normal programs are executed in the central processor ‚Äî they receive data, execute a set of simple instructions for changing data, and output the result.  But if CPU programs can work with any type of data, then shader programs are specifically designed to work with vertices and pixels.  These programs are written in order to give the rendered object the appearance of the desired material - plastic, metal, velvet, leather, etc. <br><br>  Let me give you a concrete example: here is a simple pixel shader that performs the calculation of the Lambert illumination (i.e., only simple diffusion, without reflections) for the color of the material and texture.  This is one of the simplest shaders, but you do not need to understand it, just see what the shaders look like in general. <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> MaterialColor; <span class="hljs-attribute"><span class="hljs-attribute">Texture2D</span></span> MaterialTexture; <span class="hljs-attribute"><span class="hljs-attribute">SamplerState</span></span> TexSampler; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> LightDirection; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> LightColor; <span class="hljs-attribute"><span class="hljs-attribute">float4</span></span> MyPixelShader( float2 vUV : TEXCOORD0, float3 vNorm : NORMAL0 ) : SV_Target { <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> vertexNormal = normalize(vNorm); <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> lighting = LightColor * dot( vertexNormal, LightDirection ); <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> material = MaterialColor * MaterialTexture.Sample( TexSampler, vUV ).rgb; <span class="hljs-attribute"><span class="hljs-attribute">float3</span></span> color = material * lighting; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> float4(color, alpha); }</code> </pre> <br>  <i>A simple pixel shader that performs basic lighting calculations.</i>  <i>Input data, such as MaterialTexture and LightColor, are transmitted by the central processor, and vUV and vNorm are vertex properties that are interpolated by a triangle during rasterization.</i> <br><br>  Here are the generated shader instructions: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">dp3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">v1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">v1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rsq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xxxx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">v1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dp3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">cb0</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xxxx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">cb0</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[2]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sample_indexable</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">texture2d</span></span>)(<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">v0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyxx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">t0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzw</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">s0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">cb0</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">o0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyz</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.xyzx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">o0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.w</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">l</span></span>(1<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre> <br>  <i>The shader compiler gets the program shown above and generates such instructions that are executed in the video processor.</i>  <i>The longer the program, the more instructions, that is, more work for the video processor.</i> <br><br>  Along the way, I‚Äôll notice - you can see how the shader stages are isolated - each shader works with a separate vertex or pixel and does not need to know anything about the surrounding vertices / pixels.  This is done intentionally, because it allows the video processor to process in parallel huge numbers of independent vertices and pixels, and this is one of the reasons why video processors process graphics so much faster than central processors. <br><br>  Soon we will return to the pipeline to see why the work may slow down, but first we need to take a step back and see how the net and material get into the video processor.  Here we will also meet the first performance barrier - the draw call. <br><br><h2>  CPU and draw calls </h2><br>  The video processor cannot work alone: ‚Äã‚Äãit depends on the code of the game running in the main processor of the computer, the CPU, which tells it what to render and how.  The central processing unit and the video processor are (usually) separate microcircuits operating independently and in parallel.  To get the required frame rate - usually 30 frames per second - both the CPU and the video processor must do all the work of creating one frame in the allowed time (at 30fps it is only 33 milliseconds per frame). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b4/4a8/0e0/4b44a80e05dfcbc97152d96c4b2fbf48.png" alt="image"></div><br><br>  To achieve this, the frames are often <b><i>lined up</i></b> : the CPU takes the entire frame for its work (processes AI, physics, user input, animation, etc.), and then sends instructions to the video processor at the end of the frame so that it can start working in next frame.  This gives each of the processors a full 33 milliseconds to do the job, but the price is the addition of <b><i>latency</i></b> (delay) of a frame length.  This can be a problem for very time-sensitive games, say, for first-person shooters ‚Äî the Call of Duty series, for example, runs at 60fps to reduce the delay between player input and rendering ‚Äî but usually the player doesn‚Äôt notice an extra frame. <br><br>  Every 33 ms the final target render is copied and displayed on the screen in <b><i>VSync</i></b> - the interval during which it searches for a new frame to be displayed.  But if the video processor is required to render a frame longer than 33 ms, then it skips this window of opportunity and the monitor does not get a new frame to display.  This leads to flickering or pauses on the screen and a reduction in the frame rate, which must be avoided.  The same result is obtained if the work of the CPU takes too much time - this leads to the skip effect, because the video processor does not receive commands quickly enough to perform its work in the allowed time.  In short, a stable frame rate depends on the good performance of both processors: the central processor and the video processor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/58b/acd/d9b/58bacdd9beea5633ed345edf013faa80.png" alt="image"></div><br>  <i>Here, creating rendering commands for the CPU took too much time for the second frame, so the video processor starts rendering later and skips VSync.</i> <br><br>  To display the grid, the CPU creates <b><i>a draw call</i></b> , which is a simple sequence of commands telling the video processor what to draw.  In the process of passing the draw call through the video processor pipeline, it uses various configurable settings specified in the draw call (mainly specified by the material and the mesh parameters) to determine how the mesh is rendered.  These settings, called the <b><i>state of the video processor (GPU state)</i></b> , affect all aspects of rendering and consist of everything that a video processor needs to know to render an object.  Most important for us is that the video processor contains the current vertex / index buffers, the current vertex / pixel shader programs, and all shader input data (for example, <i>MaterialTexture</i> or <i>LightColor</i> from the shader code sample above). <br><br>  This means that to change the state element of the video processor (for example, to replace the texture or switch shaders), you need to create a new draw call.  This is important because these rendering calls are expensive for a video processor.  It takes time to set the desired state changes of the video processor, and then to create a draw call.  In addition to the work that the game engine needs to perform at each draw call, there are also costs for additional error checking and storing intermediate results.  added by the graphics <b><i>driver</i></b> .  This is an intermediate code layer.  written by the manufacturer of the video processor (NVIDIA, AMD, etc.), which converts the draw call to low-level hardware instructions.  Too many draw calls place a heavy burden on the CPU and lead to serious performance problems. <br><br>  Because of this load, it is usually necessary to set the upper limit of the allowed number of draw calls per frame.  If during the testing of gameplay this limit is exceeded, then it is necessary to take steps to reduce the number of objects, reduce the depth of rendering, etc.  In games for consoles, the number of draw calls is usually limited to an interval of 2000-3000 (for example, for Far Cry Primal we aimed to have no more than 2500 frames per frame).  This seems like a large number, but it also includes special rendering techniques ‚Äî <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf" rel="external nofollow">cascading shadows</a> , for example, can easily double the number of draw calls in a frame. <br><br>  As mentioned above, the state of the video processor can only be changed by creating a new draw call.  This means that even if you created a single grid in the 3D editor, but in one half of the grid, one texture is used for the albedo map, and in the other half - the other texture, the grid will be rendered as two separate draw calls.  The same is true when the grid consists of several materials: it is necessary to use different shaders, that is, to create several draw calls. <br><br>  In practice, a very frequent source of state change, that is, additional draw calls, is the switching of texture maps.  Usually the same material is used for the entire grid (and therefore the same shaders), but different parts of the grid have different sets of albedo / normal / roughness maps.  In a scene with hundreds or even thousands of objects, it takes a lot of CPU time to use multiple draw calls for each object, and this greatly affects the frame rate in the game. <br><br>  To avoid this, the following solution is often used ‚Äî they combine all the texture maps used by the grid into one large texture, often called an <b><i>atlas</i></b> .  Then the UV coordinates of the grid are adjusted in such a way that they search for the desired parts of the atlas, while the entire grid (or even several grids) can be rendered in one draw call.  When creating an atlas, you need to be careful so that at low MIP levels the adjacent textures do not overlap, but these problems are less serious than the advantages of this approach for ensuring speed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/77c/9c2/08a77c9c2e234aa4170dd8c9ec894ce9.jpg" alt="image"></div><br>  <i>Texture Atlas from the Unreal Engine Infiltrator demo</i> <br><br>  Many engines support <b><i>instancing</i></b> , also known as batching or clustering.  This is the ability to use a single draw call to render several objects that are almost the same in terms of shaders and states, and the differences in which are limited (usually their position and rotation in the world).  Usually, the engine understands when you can render several identical objects using cloning, so if possible you should always try to use one object several times in the scene, rather than several different objects that you have to render in separate draw calls. <br><br>  Another popular technique for reducing the number of draw calls is manual <b><i>merging of</i></b> several different objects with the same material in the same grid.  It can be effective, but over-combining should be avoided, which can degrade performance by increasing the amount of work for the video processor.  Even before creating draw calls, the engine's visibility system can determine if the object is on the screen at all.  If not, then it is much less expensive just to skip it at this initial stage and not to spend on it drawing calls and video processor time (this technique is also known as <b><i>visibility culling</i></b> ).  This method is usually implemented by checking the visibility of the object bounding the object from the point of view of the camera and checking whether it is blocked completely ( <b><i>occluded</i></b> ) in the field of visibility by other objects. <br><br>  However, when several grids are combined into one object, their individual bounding volumes are joined into one large volume, which is large enough to hold each of the grids.  This increases the likelihood that the visibility system will be able to see part of the volume, and therefore, consider the entire set of grids visible.  This means that a draw call will be created, and therefore a vertex shader must be executed for each vertex of the object, even if only a few vertices are visible on the screen.  This can lead to a waste of a large part of the video processor time, because most of the vertices as a result do not affect the final image. For these reasons, grid integration is most effective for groups of small objects that are close to each other, because, most likely, they are anyway will be visible on one screen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a01/c61/f77/a01c61f77556fef085d9a17238e1601a.png" alt="image"></div><br>  <i>Frame from XCOM 2 made in RenderDoc.</i>  <i>The skeleton view (below) shows in gray all the excess geometry transmitted to the video processor and located outside the scope of the game camera.</i> <br><br>  As a good example, let's take a frame from XCOM 2, one of my favorite games for the last couple of years.  In the frame view, the entire scene is shown, transmitted by the engine to the video processor, and the black area in the middle is the geometry seen from the game camera.  All surrounding geometry (gray) is invisible and will be clipped after the vertex shader is executed, that is, it will waste time on the video processor.  In particular, look at the highlighted red geometry.  These are several bushes grids connected and rendered in just a few render calls.  The system of visibility has determined that at least some of the bushes are visible on the screen, so all of them are rendered and their vertex shader is executed, after which they are recognized that can be cut off (it turns out that most of them). <br><br>  Understand correctly, I am not blaming XCOM 2 for this, I just played a lot of it while writing this article!  In all games there is this problem, and there is always a struggle for a balance between the time spent by the video processor on more accurate checks of visibility, the cost of cutting off invisible geometry and the cost of a greater number of draw calls. <br><br>  However, everything changes when it comes to the costs of drawing calls.  As stated above, an important reason for these costs is the additional load created by the driver during conversion and error checking.  This has been a problem for a very long time, but with most modern graphics APIs (for example, Direct3D 12 and Vulkan), the structure has been modified so as to avoid unnecessary work.  Although this adds complexity to the game's rendering engine, it leads to less expensive rendering calls, which allows us to render far more objects than was possible before.  Some engines (the most notable of them - the latest version of the Assassin's Creed engine) even went in a completely different direction and use the capabilities of modern video processors to control the rendering and effectively get rid of draw calls. <br><br>  A large number of draw calls basically reduces the performance of the CPU.  And almost all performance issues related to graphics are related to the video processor.  Now we will find out what the ‚Äúbottlenecks‚Äù are, where they arise and how to cope with them. <br><br><h1>  Part 2: the usual "bottlenecks" video processor </h1><br>  The first step in optimization is to search for an existing <b><i>bottleneck</i></b> , so that you can then reduce its impact or completely get rid of it.  "Bottle neck" is the part of the conveyor that slows down all the work.  In the example above, where there were too many expensive draw calls, the bottleneck was the central processing unit.  Even if we performed optimizations that speed up the video processor, it would not affect the frame rate, because the CPU would still work too slowly and would not have time to create a frame in the required time. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78a/3a9/92a/78a3a992a6514215db34be11506d50de.png" alt="image"></div><br>  <i>The pipeline passes four draw calls, each of which renders the entire grid containing many triangles.</i>  <i>The stages overlap, because as soon as one part of the work ends, it can be immediately transferred to the next stage (for example, when three vertices are processed by the vertex shader, then the triangle can be passed for rasterization).</i> <br><br>  As an analogy of the video processor conveyor, an assembly line can be made.  As soon as each stage finishes with its data, it transfers the results to the next stage and starts to perform the next part of the work.  Ideally, each stage is busy working all the time, and the equipment is used fully and efficiently, as shown in the figure above ‚Äî the vertex shader constantly processes the vertices, the rasterizer constantly rasterizes the pixels, and so on.  But imagine if one stage takes much longer than the others: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/990/4fc/dfc9904fc4b5237c0b76b0b6c04d2206.png" alt="image"></div><br><br>  Here, a costly vertex shader cannot transfer data to the next stages quickly enough, and therefore becomes a bottleneck.  If you have such a draw call, the acceleration of the pixel shader does not greatly change the total render time of the whole draw call.  The only way to speed up the work is to reduce the time spent in the vertex shader.  The solution depends on the fact that at the vertex shader stage it creates a ‚Äúmash‚Äù. <br><br>  Do not forget that some ‚Äúbottlenecks‚Äù will almost always exist - if you get rid of one, its place will just take another.  The trick is to understand when you can deal with it, and when you just have to accept it, because this is the price of the render work.  When optimizing, we strive to get rid of the optional "bottlenecks".  But how to determine what is the "bottleneck"? <br><br><h2>  Profiling </h2><br>  To determine what is spent all the time video processor, profiling tools are absolutely necessary.  The best of them can even point out what needs to be changed to speed things up.  They do it differently - some just explicitly show the list of ‚Äúbottlenecks‚Äù, others allow you to ‚Äúexperiment‚Äù and observe the consequences (for example, ‚Äúhow the rendering time changes if you make all the textures small‚Äù, which helps you to understand whether bandwidth memory or cache usage). <br><br>  Unfortunately, everything becomes more complicated here, because some of the best profiling tools are available only for consoles, and therefore fall under the NDA.  If you are developing an Xbox or Playstation game, contact a graphics programmer to show you these tools.  We, programmers, love when artists want to influence performance, and are happy to answer questions or even write instructions for the effective use of tools. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2d/731/8d6/a2d7318d652990763df1f0ae77c52314.png" alt="image"></div><br>  <i>Basic embedded video profiler of Unity engine</i> <br><br>  For the PC, there are pretty good (albeit hardware-specific) profiling tools that can be obtained from video processor manufacturers, such as <a href="http://www.nvidia.com/object/nsight.html" rel="external nofollow">Nsight</a> from NVIDIA, <a href="http://gpuopen.com/archive/gpu-perfstudio/" rel="external nofollow">GPU PerfStudio</a> from AMD and <a href="https://software.intel.com/en-us/gpa" rel="external nofollow">GPA from</a> Intel.  In addition, there is <a href="https://renderdoc.org/" rel="external nofollow">RenderDoc</a> - the best tool for debugging graphics on a PC, but it does not have advanced profiling features.  Microsoft is launching its awesome profiling tool for Xbox <a href="https://blogs.msdn.microsoft.com/pix/" rel="external nofollow">PIX</a> and for Windows, at least for D3D12 applications.  If we assume that the company wants to create the same analysis tools for bottlenecks as in the Xbox version (and this is difficult, given the huge variety of equipment), then this will be an excellent resource for PC developers. <br><br>  These tools can give you all the information about the speed of your graphics.  Also, they will give a lot of tips on how to make a frame in your engine and allow you to perform debugging. <br><br>  It is important to master the work with them, because artists should be responsible for the speed of their graphics.    ,        ‚Äî           ,      ,   ,        .       ,  ,      ,    .  ,      ‚Äî    ,    ! <br><br> ,   ,       bottleneck,      .           ¬´ ¬ª,     , ,         . <br><br><h2>   </h2><br>       ,      ¬´ ¬ª.  ¬´ ¬ª    ‚Äî   ,         ,        . <br><br>         ,          .   ,    ,       ,  -        .           ,       . <br><br> ,     ¬´ ¬ª    ‚Äî    !     ,          ,    ,   .     ,         ,    <b><i>LOD</i></b> (Level Of Detail,   ‚Äî   , ,          ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, sometimes ‚Äújams‚Äù in shader instructions simply indicate problems in another area. Problems like too much redrawing, poor LOD performance, and many others can force the video processor to do much more work than necessary. These problems can arise from both the engine and the content side. Careful profiling, careful study and experience will help figure out what is happening. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the most common problems is </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redrawing (overdraw).</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The same pixel on the screen has to be shaded several times, because it affects many draw calls. Redrawing is a problem because it reduces the total time that a video processor can spend on rendering. If each pixel of the screen needs to be shaded twice, the video processor can spend only half the time for each pixel to save the same frame rate. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/af4/a35/5fd/af4a355fd2a89cd2d0399da8650e894a.jpg" alt="image"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIX game frame with redraw visualization mode</font></font></i> <br><br>   , ,    ,     :         ,    .        ,   ,       ,  ,   .           . <br><br>        . <b><i>   (early depth test)</i></b> (     ‚Äî .     )   ,  ,      .        <b><i>  (depth buffer)</i></b> ‚Äî  ,       ,       .       ,       ,     .  ,      . <br><br>         (..      ),     ,       ,    .        ,            .       ,           ,   ¬´¬ª     .       ,      ,   ,      . <br><br>     ,     <b><i>   (depth prepass)</i></b> .   ,     ,      ( , ,    ..),   ,       ,   ,             .  ¬´¬ª        ,       .     ,      (     ,     )    ,     ,        ,  ,       .     ,        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/68f/f66/b6f68ff66f43888e587c21749ba0dd9c.png"><br> <i>     Prototype 2</i> <br><br>     <b><i> </i></b> ,  ,         .            .            ,        .       ,            .        ,    ,  FumeFX  Houdini          ,        . <br><br>              .   ,       ‚Äî    ,     <b><i>  (particle trimming)</i></b> :       ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/27e/0e0/824/27e0e08242be17b838dc95051eddd563.jpg"><br> <i> ¬´¬ª   Unreal Engine 4</i> <br><br>           , ,  .   ,       ,        ,       <b><i>- (alpha testing)</i></b> .    -          ,    .    ,   -   ,       (   ,     ),          .         (       )     ,       . <br><br>        <b><i>  (overshading)</i></b> ,       .      ,      .   ‚Äî   ,       :     ,  <b><i>¬´¬ª (quads)</i></b> .     ,   2x2.   ,       ,   UV       MIP-. <br><br>  ,         (      ),            ,   75% .           (..  ) ,           .        LOD;      ,        ,          . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b7/a39/a0f/3b7a39a0f7e63ac60625006640756fa2.png"><br> <i>  10x8   5x4.      ‚Äî   ,   . 10  ,   ,    ,            12  .   70%    .</i> <br><br> ( :        ,       ,              .     ,    ,    ,   ,      .) <br><br>   ,       :        ,          ,        .     ,       ,      ,      ,    . <br><br>          -  :       ,    .     ,               ,      ¬´ ¬ª   .         ,       .      ,       . <br><br><h2>      </h2><br>       ,      ,     .  ,        -  , ,    ,        . <br><br>        .     - ,   <b><i>  (bandwidth)</i></b> - ‚Äî ,     .        ‚Äî         6/,       3/ . <br><br>       :      /    ,       . ,    ,   - ‚Äî     PS4  176/ ‚Äî     . ,    ,     ,        . <br><br>         . ,      ,      ,    ,     (,  ), ,           ,      ,    .      - ,        ,      (     ),   ,      .   <b><i>¬´ ¬ª   </i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: no matter how fast the shader works, if it has to stop and wait for data from the memory to be received. The only way to optimize is to reduce the memory bandwidth used or the amount of data transferred, or both. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory bandwidth even has to be shared with a central processor or asynchronous computational work that the video processor performs at the same time. This is a very valuable resource. Most of the memory bandwidth usually takes the transfer of textures, because they contain a lot of data. Therefore, there are different mechanisms for reducing the amount of texture data to be transferred. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first and most important is the </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache.</font></font></i></b> .     ,       .         ,     .     -,   ‚Äî    ,             . <br><br>     , ,     ,            .           ,                 .         ‚Äî        ,  ,               .   ,      ,    ,          .           ¬´ ¬ª.      <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filtering (</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bilinear, trilinear and anisotropic filtering with each search requires several pixels, additionally loading the bandwidth. High bandwidth anisotropic filtering uses bandwidth especially well.</font></font><br><br>  ,    ,       (, 2048x2048)  ,           .         ,        ,      ,      .           ,      (  ¬´ ¬ª (cache miss)),      ,    :         .   ,   .      ,   ( )     ,      ,    ,     .      ,         ‚Äî         ,       . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is where </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MIPmapping comes to the rescue.</font></font></i></b> .          ,    ,  ,          .  ¬´ ¬ª         MIP-,   .     ,             ¬´ ¬ª.  MIP-        ,       .  ,  MIP-   ,       .  MIP-     ‚Äî        . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/114/642/6fa/1146426fac6295639f7357231183bdd8.png"><br> <i>   ,      ,    </i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b5/e7e/50e/7b5e7e50e64b0550c8d95f7e79877b9d.jpg"><br> <i>      MIP-,        </i> <br><br>   ‚Äî          ‚Äî  <b><i> (compression)</i></b>  (   , ,          ).   BC (Block Compression,    DXT-)                  .       ,         ,              . <br><br>        -       ¬´¬ª         .  ,    MIP    .    ¬´¬ª   8x  16x,   2x,   / .   ,       MIP-  .      ,    .  ,         ‚Äî     RGBA,         ,       ,   75%    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Textures are the main, but not the only "users" of memory bandwidth. Data grids (index and vertex buffers) also need to be loaded from memory. In the first scheme of the video processor pipeline, you can see that the output of the final target render is written to memory. All of these transmissions usually occupy one common memory bandwidth. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With standard rendering, all these costs are usually invisible, because compared to the texture data, this amount of data is relatively small, but this is not always the case. Unlike conventional draw calls, the behavior of </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shadow passes is</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quite different, and they are much more likely to limit the bandwidth. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/55a/911/a14/55a911a142601a82e52a8b9e405cfe58.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame from GTA V with shadow maps, illustration taken from </font></font><a href="https://habrahabr.ru/company/ua-hosting/blog/271931/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">excellent frame analysis.</font></font></a>   ( <a href="http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/" rel="external nofollow"> </a> )</i> <br><br>   ,    ‚Äî    ,        ,                 :   /,      ,        .        ,           .        /    ,         . <br><br> ,          ‚Äî    ‚Äî Xbox.   Xbox 360,   Xbox One    ,    ,   360 <b><i>EDRAM</i></b> ,   XB1 <b><i>ESRAM</i></b> .      (10   360  32   XB1),    ,     ,       .       ,      (DRAM).    ,   ,       ,       DRAM.    ,             .       ,    EDRAM/ESRAM,     ,     .            3D-. <br><br><h1>  And much more... </h1><br>     ,  ‚Äî   .                 .   ,          ,       . <br><br>         ,          . ,   ,    ,     ,     ‚Ä¶             . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can learn a lot from the article, but do not forget that your team‚Äôs 3D programmers are always ready to meet with you and discuss everything that requires a deep explanation. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Other technical articles </font></font></h2><br><ul><li> <a href="https://simonschreibt.de/gat/renderhell/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Hell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Simon Trumpler</font></font></li><li> <a href="https://blogs.msdn.microsoft.com/shawnhar/2009/09/14/texture-filtering-mipmaps/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Texture filtering: mipmaps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Shawn Hargreaves</font></font></li><li> <a href="http://www.humus.name/index.php%3Fpage%3DArticles%26amp%3BID%3D5" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics Gems for Games - Findings from Avalanche Studios</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Emil Persson</font></font></li><li> <a href="http://www.humus.name/index.php%3Fpage%3DNews%26amp%3BID%3D228" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triangulation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Emil Persson</font></font></li><li> <a href="http://www.g-truc.net/post-0662.html" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How bad are small triangles on GPU and why? </font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Christophe Riccio</font></font></li><li> <a href="https://simonschreibt.de/game-art-tricks/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game Art Tricks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Simon Trumpler</font></font></li><li> <a href="http://realtimecollisiondetection.net/blog/%3Fp%3D91" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizing the particle system</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Christer Ericson</font></font><br></li><li> <a href="http://www.gamasutra.com/view/feature/130940/practical_texture_atlases.php" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Practical Texture Atlases</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Ivan-Assen Ivanov</font></font><br></li><li> <a href="http://www.cs.virginia.edu/~gfx/papers/paper.php%3Fpaper_id%3D59" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How GPUs Work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - David Luebke &amp; Greg Humphreys</font></font><br></li><li> <a href="http://stephaniehurlburt.com/blog/2016/10/28/casual-introduction-to-low-level-graphics-programming" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Casual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Stepsie Hurlburt</font></font><br></li><li> <a href="http://blog.selfshadow.com/2012/11/12/counting-quads/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Counting Quads</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Stephen Hill</font></font><br></li><li> <a href="http://blog.selfshadow.com/publications/overdraw-in-overdrive/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overdraw in Overdrive</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Stephen Hill</font></font><br></li><li> <a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Life of a triangle - NVIDIA's logical pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - NVIDIA</font></font><br></li><li> <a href="http://s09.idav.ucdavis.edu/talks/02_kayvonf_gpuArchTalk09.pdf" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From Shader Code to Teraflop: How Shader Cores Work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Kayvon Fatahalian</font></font><br></li><li> <a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Trip Through the Graphics Pipeline (2011)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Fabian Giesen</font></font><br></li></ul><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This article was originally published </font></font><a href="http://www.fragmentbuffer.com/gpu-performance-for-game-artists/" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on fragmentbuffer.com by</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> its author Keith O'Conor. </font><font style="vertical-align: inherit;">Keith's other notes can be read on his </font></font><a href="https://twitter.com/keithoconor" rel="external nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">twitter (@keithoconor)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/337484/">https://habr.com/ru/post/337484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337472/index.html">Bug hunters: ASCON testers pass the test with tricky questions</a></li>
<li><a href="../337474/index.html">How do you call a virus?</a></li>
<li><a href="../337476/index.html">Overview of one Russian RTOS, part 4. Useful theory</a></li>
<li><a href="../337480/index.html">MBLTdev 2017: first speakers, latest tickets at a bargain price</a></li>
<li><a href="../337482/index.html">Monetization of applications in iOS 11: we target embedded purchases in the new App Store</a></li>
<li><a href="../337488/index.html">Hibernate Inheritance: Choosing a Strategy</a></li>
<li><a href="../337490/index.html">On the culture of development in groups of programmers</a></li>
<li><a href="../337492/index.html">We teach webworkers good manners</a></li>
<li><a href="../337494/index.html">Using Python to process real-time information from sensors that work with Arduino</a></li>
<li><a href="../337496/index.html">How chat bots give reason for Sberbank's IT projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>