<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerating Angular Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many people know Minko Gechev (rhyme.com) from the book ‚ÄúSwitching to Angular‚Äù and the text ‚ÄúAngular Performance-Checklist‚Äù, which helps Angular devel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerating Angular Applications</h1><div class="post__text post__text-html js-mediator-article">  Many people know <b>Minko Gechev</b> (rhyme.com) from the book ‚ÄúSwitching to Angular‚Äù and the <a href="https://github.com/mgechev/angular-performance-checklist">text</a> ‚ÄúAngular Performance-Checklist‚Äù, which helps Angular developers to optimize their projects.  At our December conference of HolyJS 2017 Moscow, he also developed the topic of Angular-performance, making a presentation on ‚ÄúFaster Angular applications‚Äù.  And now, on the basis of this speech, we have prepared a habrapos, translating everything into Russian.  Welcome under the cut!  And if you prefer an English-language videotape of the speech, we also enclose it: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/WP-d5CCuS60" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  Today we will talk about performance during execution.  In the case of single-page applications, it is usually either network performance or performance in runtime. <br><br>  In the first case, they usually try to reduce the number of HTTP requests or data transmitted over the network.  In this direction there is a lot of research.  For example, the Google Closure Compiler team is beating on this, achieving the goal of more efficiently removing unused code and minifying code.  We also have various compression algorithms, and the webpack team also sets similar goals.  Finally, in Angular CLI they try to combine the best of different approaches and provide very well encapsulated assemblies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, with regard to performance during execution, the development is a bit.  Here everything is in our own hands, there is no third-party "magic wand", by the wave of which our application will work faster.  There are several possible approaches to the problem, today I will talk about more general solutions, often applicable not only to Angular. <br><br>  To illustrate these solutions, I wrote a ‚Äúsimple business application.‚Äù  In it, I tried to reproduce as many performance problems as possible that I have encountered over the past months.  The result was a completely creepy product, which we will try to somehow improve. <br><br><img src="https://habrastorage.org/webt/s8/ei/od/s8eiodxbaund8ph2d5iwktexsli.jpeg"><br><br>  In our most simplified application, you can add new employees, present them in the list and calculate some value for them.  We will have two lists of employees: for the sales department and for the R &amp; D department.  In both, you can add new items.  Already existing elements are presented in the list, where you can see the name and some numerical value (suppose, this is an assessment of the employee‚Äôs work).  There is also a field to enter the name of the new employee.  When adding an employee, we can simply take a number from somewhere, calculate something and display everything on the screen. <br><br>  The application structure consists of an AppComponent (covering the entire application) and two EmployeeListComponent (one for each list). <br><br>  Here is the EmployeeListComponent template: <br><br><img src="https://habrastorage.org/webt/w6/hm/fn/w6hmfnmuficbyld2ajysdbmooow.jpeg"><br><br>  Here pay attention to the input element.  It uses the banana box syntax (square brackets first, then round brackets) to establish a two-way data binding between the label property declared in the EmployeeListComponent controller and the text field. <br><br>  In addition, the EmployeeListComponent iterates through the list of employees in the dataset, and a list item is created for each employee.  For each item, we display the name of the employee and calculate the numeric value using the calculate () method defined in the EmployeeListComponent class. <br><br>  Now take a look at this class itself: <br><br><img src="https://habrastorage.org/webt/c9/5h/bw/c95hbwg7012cb84g6hptuvauasy.jpeg"><br><br>  There are several important things.  To begin with, the state is not stored in it, it receives all the necessary data (Employee [Data] array] on input from the parent component.  Thus, this parent component, AppComponent, acts as a Container Component in Redux. <br><br>  In addition, in the EmployeeListComponent class there is a calculate () method, the only task of which is to transfer the execution of a function that calculates Fibonacci numbers.  At first glance, Fibonacci numbers are inconvenient to use here, but they have a number of important advantages.  First, the method of calculating them is known to everyone; there is no need to explain the complicated work to a suitable function example.  It could be replaced with standard deviation or something else like that. <br><br><img src="https://habrastorage.org/webt/h8/ng/l5/h8ngl5sdlsrpsqvruv3pqmdfzeq.jpeg"><br><br>  Secondly, this function can be implemented in an extremely inefficient way, as we see it on the screen.  We have two recursive calls, and for each Fibonacci number we will have to recalculate all the previous ones again.  Thus, here I artificially slowed down the operation of the application so that the effect of the subsequent optimization could be better seen. <br><br>  So, we have an application with a component of the application itself, and with two components of lists.  Each of the items in the list requires a lot of processing power. <br><br>  Let's try to use some real data in this application.  We will have two lists containing a total of 140 items.  In this case, when entering new names, typing is extremely slow.  It is unlikely that users might like this application work.  But why so slow?  Profiling this problem is pretty easy with Chrome DevTools.  Having done this, we find out that our function of calculating Fibonacci numbers is called very often.  We can find out the exact number of calls by adding logging to this function. <br><br><img src="https://habrastorage.org/webt/uw/jq/ab/uwjqabrgetzkp9bufnbixeir7l4.jpeg"><br><br>  It turns out that each time a user presses a key, the entire component tree is recalculated at least twice (once when pressed and once when the key is released).  So we recalculate all the previously received values ‚Äã‚Äãwith each press. <br><br>  This is what this situation looks like in terms of the component tree.  Each time you press a key, a change occurs first in the AppComponent.  Because change detection in Angular works like a deep search, it also triggers a change detection in the EmployeeListComponent, and then on each of the employee items.  For each of these elements, their numerical value will be recalculated.  Then the same bypass of the second EmployeeListComponent will occur. <br><br>  All this is extremely inefficient.  As a rule, we do not want to recalculate the numerical values ‚Äã‚Äãfor each element in the array, we would like this only when a new array appears.  Now, if a new array is transferred from the AppComponent to the EmployeeListComponent, then you can calculate.  Any thoughts on how best to do this? <br><br>  For example, you can use the OnPush strategy.  Thanks to it, change detection will be launched only when new input data appear on the component.  When Angular, when checking references, detects the appearance of new inputs, the components will detect changes.  That is, if we have a component tree, when the root component receives new data, we update the entire branch, starting with this component.  We'll see how it looks later. <br><br>  Let us turn to functional programming for help and try to imagine that EmployeeListComponent is a function.  The input to the component is the input arguments to the function, and the image on the screen is the result of the function.  I will demonstrate my idea with the help of pseudocode. <br><br><img src="https://habrastorage.org/webt/az/8u/q7/az8uq7caupxkdnokalgxxi1wtfo.jpeg"><br><br>  In the f constant, we save the reference to the EmployeeListComponent (now this is a function), in the data constant, the input arguments (data of one employee). <br><br><img src="https://habrastorage.org/webt/um/ww/ah/umwwahsoy4rcbrxop-8bwbqxijg.jpeg"><br><br>  To begin with, we call the function with its initial input, and here Angular will perform the change detection.  Since before this the value was undefined, by comparing data and undefined, Angular will see the change in the value of the input data. <br><br><img src="https://habrastorage.org/webt/ct/d7/fv/ctd7fv0vvbq0al5onlkmkjymwuk.jpeg"><br><br>  But adding a new element to the list will already call a function with the same argument as before: we will modify the data structure pointed to by the same data constant.  Therefore, Angular will not start detecting changes. <br><br><img src="https://habrastorage.org/webt/lr/35/eo/lr35eonl4djkbqtphcjqxooe6sc.jpeg"><br><br>  However, the detection of changes will occur if we send a copy of the array in the input argument of the function: the link will change there. <br><br>  Does this mean that every time we need to detect changes, we need to copy the entire array?  For several reasons, this would be extremely inefficient.  First, it would be extremely non-optimal memory usage.  For each change detection, we need to first allocate memory for the entire new array, and then the garbage collector will need to free it.  Secondly, it is inefficient in terms of computing.  The time complexity of this algorithm is at least O (n). <br><br><h2>  Immutable </h2><br><br>  Regarding both of these things, it would be wiser to use something like Immutable.js.  This is a set of various immutable data structures with two very important properties. <br><br>  First, we cannot modify any existing data structure.  Instead, calls that would change such a data structure receive a new reference to it with the changes already applied. <br><br>  Secondly, we do not copy the entire data structure: a new instance of this structure will, if possible, use elements of the old one. <br><br><img src="https://habrastorage.org/webt/ep/4f/gx/ep4fgxuyirk9cj-rrmovsqv30r0.jpeg"><br><br>  This is the kind of refactoring we need to do.  First, we changed the contents of the add () and remove () methods.  In add (), when executing the unshift () procedure, in which the element is moved to the top of the list, we get a new list.  The same thing in the remove () method, the splice () call returns us a new list. <br><br>  In addition to these two methods, we need to change the link to the list.  Otherwise, we could not notify the EmployeeListComponent that the input data has changed.  Thus, the output values ‚Äã‚Äãadd () and remove () must be assigned to the list property in the AppComponent. <br><br>  Run the application and see how much faster everything is now.  We optimized here, it should have been better ... Hmm, the application is still very slow.  It may have become faster than before, but still the user‚Äôs impressions are unlikely to be good. <br><br>  To measure how much faster the application began to work, I wrote several end-to-end tests and ran them on Angular Benchpress. <br><br><img src="https://habrastorage.org/webt/iu/6t/mo/iu6tmomwjiympqqusslp-qumpm8.jpeg"><br><br>  Thanks to them, we see that the application has accelerated the work at least twice.  This, however, is not enough.  The reason for the unsatisfactory work is that when you enter text, change detection is still triggered.  The good news is that now it is launched only in one of the two lists, but even in it it is not needed, since none of the numerical values ‚Äã‚Äãhas changed. <br><br>  Let's see how the work of the application now looks from the point of view of the component tree.  Each time we press a key, we trigger change detection several times in the AppComponent, EmployeeListComponent, and in each of the individual components.  However, we do not make calls to the second list.  But why change detection occurs at all, because there were no calls to any of the calls that change the data structure of the list? <br><br>  The reason lies in the specific characteristics of detecting OnPush changes, which are not well documented. <br><br><img src="https://habrastorage.org/webt/kk/q7/l6/kkq7l64ehdwmaf3vr1qcydnfgss.jpeg"><br><br>  The bottom line is that the detection of OnPush changes is triggered not only when the input data changes, but also when the event is triggered in the corresponding component. <br><br>  Knowing this feature, we can now refactor the code.  This has its positive side, because at the same time we will be able to improve the division of responsibility in our application and make the component tree slimmer.  Let's make two child components in the EmployeeListComponent: NameInputComponent and ListComponent. <br><br>  The first of them will be responsible only for storing the current value of the input line and for triggering the event.  In the second, the function will be evaluated, and OnPush change detection will be used there. <br><br>  After these changes in the code, the application began to work much faster.  How exactly does the application work now?  Unfortunately, when a user presses a key, change detection is still invoked in the AppComponent, and then in both instances of the EmployeeListComponent.  But this time, in the child components of the EmployeeListComponent, change detection is no longer triggered.  The fact is that ListComponent uses OnPush change detection, and the event occurs in the EmployeeListComponent area, that is, in the parent component EmployeeList.  Print speed increases by several orders of magnitude. <br><br><img src="https://habrastorage.org/webt/lo/0q/hi/lo0qhihtnks0vqcvenkgiplvqgi.jpeg"><br><br>  However, this is not enough for us.  Another possible optimization concerns the addition of elements.  When creating a new item, we call the add operation to the immutable list, so a new list is created and passed to the EmployeeListComponent entry.  This causes change detection.  That is, when you enter text, everything is now fast, but when you add an element, there is still an unnecessary re-calculation of the numerical value in all these components. <br><br>  To solve this problem, you need to refer to our function calculating Fibonacci numbers.  We have already mentioned pure functions today, and this is one of them.  The good news is that pure functions are also found among the things that are really useful in our applications, such as calculating the standard deviation. <br><br>  Pure functions have two very important properties.  First, they have no side effects, that is, no calls are made through the network, no logging occurs, and so on.  Secondly, a repeated function call with the same arguments gives an identical result.  In the world of functional programming, this is called ‚Äúpure function‚Äù. <br><br>  And this is a very important concept.  In Angular, there are ‚Äúpure pipes‚Äù and ‚Äúdirty pipes‚Äù (impure pipes, i.e., internal state pipes).  They are usually used for data processing.  Pure pipes usually format the data, an example of ‚Äúpure‚Äù is DatePipe. <br><br>  Dirty pipes store a certain state inside, such as AsyncPipe.  The difference between these two cases is that Angular performs a clean pipe only when it detects that its argument has changed.  As a rule, expressions with a clean pipe are considered by Angular as having no side effects, referentially transparent.  This is a concept from functional programming to better understand it, take a look at the code created by the Angular compiler for a template with clean and dirty pipes. <br><br><img src="https://habrastorage.org/webt/_0/dw/ba/_0dwba_8ssnlm2qmpwzl9cjfalc.png"><br><br>  We apply a clean date date to the birthday variable, and then a dirty impureDate.  The screen shows two different results.  At first it is difficult to understand.  Mysterious characters at the beginning of the expression do not interest us, they are only needed so that developers do not use these imports. <br><br>  The important part for us is following them.  _ck () is a check, in it the current value of date will be compared with the previous one, and if the value is different, the date.transform () method will be called.  If there are no changes, the previous result stored in the cache will be returned.  In the case of impureDate, the impureDate.transform () method will simply be called. <br><br>  Thus, referential transparency means that the semantics of an expression will not change at all, if we substitute its output value instead of this expression.  Side effects will be minor. <br><br><img src="https://habrastorage.org/webt/fe/mu/li/femulit_txgcjd7xcvafdk96eoc.png"><br><br>  Based on this principle, I encapsulated our Fibonacci function in the CalculatePipe class I wrote, simply delegating the computation of the function fibonacci.  In addition, we will need to change the pattern.  Instead of the calculate method, we will use the pipe in it. <br><br>  Now let's try to test the application: in Benchpress, a new user will be added and deleted repeatedly.  It can be seen that the application is already fast enough.  Productivity increased by several orders of magnitude. <br><br><img src="https://habrastorage.org/webt/8r/dd/yj/8rddyjry7kfczqkiihu_0jjhfce.jpeg"><br><br><h2>  Rendering optimization </h2><br>  I want to talk about two more optimizations.  The first concerns the rendering efficiency.  Let's try to display 1000 elements in our application at the same time.  Of course, we will not do this in a real application - for such situations there is a virtual scrolling or pagination.  But here we will try to optimize the work otherwise. <br><br>  Suppose our application is already optimized in many ways.  Removed unused code, the package weighs 50 kilobytes, we download it in 100 milliseconds.  But drawing an image takes at least 8 seconds.  Despite the fact that our network performance is excellent, the user will still be dissatisfied. <br><br>  Take a look at our data.  In them we see duplicate values.  There are several copies of the Fibonacci function with arguments 27, 28 and 29. <br><br><img src="https://habrastorage.org/webt/xj/l7/k6/xjl7k6hdn2iammsjlpgywi1rpps.jpeg"><br><br>  Thanks to clean pipes, we have some caching, but these values ‚Äã‚Äãare still calculated many times.  Fortunately, all our examples are in a small gap.  You can try to make the system global caching.  Net pipes create cache only for a single expression.  We will see the difference between this approach and real caching using memoization. <br><br>  Memoisation, which we will use, is possible only for pure functions.  Its use is quite simple: <br><br><img src="https://habrastorage.org/webt/tu/uq/mf/tuuqmfnsdvq7m7iigh6kfsxiyfe.jpeg"><br><br>  Through require ('lodash.memoize') we get the function memoize, and then call it.  It will create the necessary Fibonacci function.  Each time this created function is called, its input argument and result will be recorded in the correspondence table.  We don't need anything else.  We see that the application is now displayed in 6.7 seconds, before these operations took 9.5 seconds.  For such a small optimization, this is not bad. <br><br>  Let's compare clean pipes and memosize.  In the first case, when Angular discovers that we are trying to call 27 |  calculate, execution is delegated to the function fibonacci (27).  Upon further traversal of the list, each time a call is made 27 |  calculate, the same operation will be performed, since only local caching occurs. <br><br>  However, when the next change is detected, Angular will not recalculate the result if the calculate arguments have not changed.  Thus, for each subsequent execution of change detection, our optimization will work. <br><br><img src="https://habrastorage.org/webt/ib/or/ht/iborhtkjc6hkaj2y2nsh4skt0ck.jpeg"><br><br>  In the case of memoization, everything will look different.  First we call 27 |  calculate, the Fibonacci number will be calculated, and the number 27 and the output value of the Fibonacci function will be written to the cache.  With all the following calls 27 |  calculate the result will be taken from the cache.  Saving time is obvious. <br><br><img src="https://habrastorage.org/webt/fi/c8/4w/fic84wq1ej0eeslk5v-eeiof9cg.jpeg"><br><br>  So, some general trends are beginning to emerge.  From a conceptual point of view, OnPush change detection and memoization are similar.  Both there and there we have referential transparency.  If you present a tree of components as an expression, as an abstract syntactic tree, you can also apply to it optimizations that use referential transparency.  However, in both cases it will only work with the latest input data. <br><br>  Let's try to conduct some more advanced optimization.  To do this, we need to refer to some Angular internal APIs.  If you are not familiar with them, do not worry, I will try to tell about them in as much detail as possible. <br><br>  About 90% of software development comes down to the requirement to present a list of items to the user.  Angular uses the NgForOf directive for this purpose.  We will try to optimize it in accordance with our needs.  Here is how it works: <br><br><img src="https://habrastorage.org/webt/i9/cs/n1/i9csn17lbnjxmdkhqip8hzgconu.jpeg"><br><br>  It has a constructor that takes an object of type IterableDiffers as input.  And here‚Äôs the class IterableDiffers itself: <br><br><img src="https://habrastorage.org/webt/zy/wa/bi/zywabinpm2wngr5c51lzauuw9hk.png"><br><br>  In the class of this object, only the constructor and the find () method.  The constructor accepts the collection of IterableDifferFactory [] as input, and the find () method accepts any collection as input (list, binary search tree, or something else). <br><br>  Then in this method there is a search among all available factories, one that supports the data structure received as input.  If the desired factory is located, the method returns it.  Nothing else happens here. <br><br>  Let's look at 3 more interfaces: <br><br><img src="https://habrastorage.org/webt/wr/kc/mj/wrkcmjecglbtkqimyh16gqgg6-g.png"><br><br>  The IterableDifferFactory supports () method I just described, and it also has a create method that accepts the trackByFunction function as input.  With the latter, you may be familiar with the NgFor directive, there it is also there.  The create method returns an instance of the IterableDiffer interface. <br><br>  IterableDiffer is an abstraction that takes as input a data structure and stores some state.  Its purpose is to compare two instances of the same data structure.  The diff () method returns the number of differences between two instances (let's call them A and B), that is, the number of elements that need to be added to A to get B, the number of elements that need to be taken from A, and the number of elements that change places. <br><br>  Finally, the TrackByFunction function.  I will talk about it in detail later.  First, let's consider the relationship between the structures described. <br><br><img src="https://habrastorage.org/webt/ba/s0/kw/bas0kwr--6g125wg64s_taq9jzc.png"><br><br>  In the NgForOf directive, IterableDiffers is injected as an argument to the constructor.  IterableDiffer is used in it to detect discrepancies between the current object that is being iterated and its previous value.  IterableDiffers use a collection of factories that, in turn, create IterableDiffer.  This latter uses TrackByFn to determine by which characteristics we will compare the elements in the collection with each other. <br><br>  Take a look at how NgForOf uses differ. <br><br><img src="https://habrastorage.org/webt/lm/i9/rb/lmi9rbhrfbrkotqgaikqrbc9oc0.png"><br><br>  It calls the diff () method with the current value of the collection that is being iterated, and compares it with the previous version of the collection.  If changes are detected, they are applied to the DOM. <br><br>  Let's see how all this will work with IterableDiffers and the specific trackBy function: <br><br><img src="https://habrastorage.org/webt/nt/ox/xh/ntoxxhszv5ddlef0veh8luobktq.png"><br><br>  We have a trackBy function that returns the id of the item provided.  And we have two collections, a and b.  Both are lists, and there are only elements in them. <br><br>  IterableDiffer will first compare the first element of a with the first element of b, and since they have the same identifier, IterableDiffer will conclude that the elements are identical.  The same will happen with the second elements.  Please note that here the names of the workers are different.  For IterableDiffer, it doesn't matter.  For him, only identifiers are important.  However, identifiers are different, as is the case with the third items in each list, IterableDiffer concludes that the items are different.  Therefore, it will produce a result in which it will appear that the last element from a has been deleted, and is replaced by the last element from b. <br><br><img src="https://habrastorage.org/webt/hr/w3/3d/hrw33d8jenvhn3qn_0obopitdk4.png"><br><br>  IterableDiffer checks externally whether the data structure has changed.  He uses it as a consumer.  But the data structure knows better whether it has changed or not.  Let's try to implement our own DifferableList data structure, inspired by another concept from functional programming.  It will keep records of changes occurring with it. <br><br><img src="https://habrastorage.org/webt/pg/bw/2c/pgbw2cd-guyospoch7y0b7uwkdg.jpeg"><br><br>  To do this, we will use LinkedList (stored in the changes variable), because it gives slightly better performance than Array, and we do not need random access to the elements. <br><br>  We will store the data in an immutable Immutable.js list.  If necessary, we will modify the list of changes. <br><br>  We essentially apply the decorator pattern to the immutable list.  In addition, we implement an ‚Äúiterator‚Äù template so Angular can bypass this data structure. <br><br>  Thus, we have created a data structure optimized for Angular.  However, differ by default will not provide us with better performance. <br><br><img src="https://habrastorage.org/webt/su/f9/dx/suf9dxo7fx8kpzkkc_x7r7rubbc.jpeg"><br><br>  We can use the special differ, where there will be a constant check for changes in the data structure.  Therefore, it is not necessary to bypass it every time.  Instead, you can simply work with the changes property. <br><br>  These changes will require a little refactoring.  We just need to extend the existing set of IterableDiffers. <br><br><img src="https://habrastorage.org/webt/k2/9o/5g/k29o5ge4jyjb_gle_c8ljx9odja.jpeg"><br><br>  The described data structure is made according to the general principle of immutable data structures - this is again a concept from functional programming.  They allow you to do very unusual things: travel through time, create new universes as branches of existing ones.  I recommend to take a look. <br><br><img src="https://habrastorage.org/webt/dw/55/nf/dw55nffrj1d-jyrb0jjm0cg0ujs.jpeg"><br><br>  After the last refactoring, our performance increased by about 30%. <br><br><h2>  Repeat the traversed </h2><br>  Detecting changes OnPush does not always behave as we expect.  Change detection is invoked for the subtree of this component, not only when the input data of this component changes, but also when an event occurs in this component. <br><br>  In addition, we learned the difference between clean pipes and memoization, and the difference between corresponding caching mechanisms.  Understood the concepts of purity and referential transparency, taken from functional programming. <br><br>  Finally, we looked at how the Differ objects and the TrackByFn function work.  And they remembered that using other TrackByFn, which are different from this one by default, can only decrease performance. <br><br>  As a conclusion, we can say that there is no magic bullet for optimizing performance.  You need to understand very well how the component tree and the data with which we work are arranged, and, based on this, apply optimizations that are specific to our application.  And, of course, it is necessary to apply the solutions proposed to us by Computer Science. <br><br>  Here are some useful links: <br><br><ul><li>  <a href="http://blog.mgechev.com/2017/11/11/faster-angular-applications-onpush-change-detection-immutable-part-1/">mgv.io/ng-cd</a> - Angular's OnPush Change Detection Strategy </li><li>  <a href="http://blog.mgechev.com/2017/11/12/faster-angular-applications-pure-pipes-memoization-pure-functions-part-2/">mgv.io/ng-pure</a> - Pure Pipes and Referential Transparency </li><li>  <a href="http://blog.mgechev.com/2017/11/14/angular-iterablediffer-keyvaluediffer-custom-differ-track-by-fn-performance/">mgv.io/ng-diff</a> - Understanding Angular Differs </li><li>  <a href="https://github.com/mgechev/angular-performance-checklist">mgv.io/ng-perf-checklist</a> - Angular Performance Checklist </li><li>  <a href="https://www.youtube.com/watch%3Fv%3Dp9vT0W31ym8">mgv.io/ng-checklist-video</a> - Angular Performance Checklist </li></ul><br><br>  On them it is possible to get acquainted with the described topics in more detail.  The first article describes the detection of OnPush changes in Angular, the second deals with clean pipes and referential transparency, and the third about Angular Differs.  In addition, there is a slightly more detailed version of the Angular performance checklist.  It describes how to customize the detection of changes. <br><br><blockquote>  Minute advertising.  If you liked this report from the previous HolyJS, please note: on May 19-20, <a href="https://holyjs-piter.ru/"><b>HolyJS 2018 Piter</b></a> will pass.  And also pay attention to the fact that from May 1 the ticket price will increase, so now is the time to decide! </blockquote></div><p>Source: <a href="https://habr.com/ru/post/354552/">https://habr.com/ru/post/354552/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354542/index.html">How to make sure my site is not blocked by RKN</a></li>
<li><a href="../354544/index.html">Great content with small forces</a></li>
<li><a href="../354546/index.html">DevConf: from shawarma to symfony or legacy migration</a></li>
<li><a href="../354548/index.html">Introduction to complex numbers</a></li>
<li><a href="../354550/index.html">Animations in the world of states</a></li>
<li><a href="../354554/index.html">2nd generation Infortrend EonStor DS2024 storage system review and testing</a></li>
<li><a href="../354558/index.html">Can I trust my Chrome and Firefox synchronization passwords?</a></li>
<li><a href="../354560/index.html">Conference BLACK HAT USA. ‚ÄúHow the feds caught the Russian mega-carder Roman Seleznev‚Äù</a></li>
<li><a href="../354562/index.html">Forms should be simple and declarative.</a></li>
<li><a href="../354564/index.html">Matching problems and how to deal with them</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>