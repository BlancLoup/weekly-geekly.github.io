<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing an application to solve Philippine C Crosswords in the Marmalade SDK</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Marmalade SDK and Cross Platform 
 Marmalade SDK as an environment for developing cross-platform mobile (and not only) applications provides the C ++ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing an application to solve Philippine C Crosswords in the Marmalade SDK</h1><div class="post__text post__text-html js-mediator-article"><h3>  Marmalade SDK and Cross Platform </h3><br>  Marmalade SDK as an environment for developing cross-platform mobile (and not only) applications provides the C ++ API to the developer.  In fact, this is a set of extensions (Extensions), each of which contains within itself a specific implementation of the functional (work with graphics, file system, network, UI, in-game purchases, work with audio-video, etc.) for each individual platform ( Android, iOS, WinPhone and many other platforms). <br><br>  Therefore, the developer in the process of writing is practically no need to be tied to the features of a particular platform, except for some cases (perhaps the list is incomplete) <br>  - some functionality may not be supported in a particular OS; <br>  - the developer himself decided to implement the application logic in different ways depending on the OS. <br><br>  But in the event that a developer needs functionality that is missing from the standard Marmalade SDK distribution kit, he may need to build his Extension himself with his implementation for each platform, and therefore write platform-specific code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Personally, for the implementation of this application, I had enough of a standard set of extensions, so I do not have platform-specific code.  Most of the testing and debugging (about 90%) was done on the Windows simulator (the remaining 10% is debugging scaling on the device, since this requires zoom gestures with two fingers).  Android and iOS builds are also built on Windows (to do this, you need to install the appropriate tools described in the marmalade dock).  Mac is needed only for uploading ipa-file to iTunesConnect console via Apple ApplicationLoader. <br><a name="habracut"></a><br><br><h3>  A few words about what is the Philippine crossword </h3><br>  Philippine Crossword is a kind of graphic puzzle, in which a picture is encrypted using a set of pairs of numbers.  All crosswords should have the only solution.  It is necessary to choose and connect pairs of identical numbers with lines so that the result satisfies the following conditions (to which I will repeatedly refer to in the further presentation of the article): <br><br><ul><li>  the length of each line must correspond to the numbers located at its ends; </li><li>  lines should not intersect with each other and pass through the same cells; </li><li>  lines can go in the vertical and horizontal directions, can be refracted, but can not pass diagonally. </li></ul><br>  Since the unit has no pair, it is shaded by default.  As a result of solving a crossword puzzle, when all pairs of numbers (except for units) are connected by lines, a certain pattern is obtained.  Familiarizing yourself with the gif below will shed light on the process of solving the Philippine crossword puzzle: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/6cf/8bb/a0e6cf8bbaf93c4d2358b678cee9cf0f.gif" alt="image"><br><br>  This problem was solved in the Marmalade SDK environment using the C ++ programming language, as a result of which versions of the application for iOS and Android were assembled. <br><br><h3>  Presentation of the state of the crossword puzzle in RAM </h3><br>  The crossword puzzle grid consists of cells, each of which can be painted over or not painted over (at a different point in time), as well as having or not having a number in it (this property of the cell does not change). <br><br>  The minimum number used in my crossword puzzles is 1, the maximum is 9. Depending on how the line passes through the cell, it can be painted in several ways (i.e., have several different states). <br><br>  We list them: <br><br><ul><li>  1 - the cell is not painted over, i.e. the line does not pass through it; </li><li>  2 - the cell is painted over, but the line does not pass through it either.  All cells with the number 1 are in this state. </li><li>  3 - the line passes through the cell vertically; </li><li>  4 - the line passes horizontally through the cell; </li><li>  5 - the line passes through the top and left side of the square of the cell; </li><li>  6 - the line passes through the lower and left side of the square of the cell; </li><li>  7 - the line passes through the top and right side of the square of the cell; </li><li>  8 - the line passes through the bottom and right side of the square of the cell; </li><li>  9 - the cell is an extreme cell line and the line passes through the left side of the square of the cell; </li><li>  10 - the cell is the extreme cell line and the line passes through the right side of the square of the cell; </li><li>  11 - the cell is the extreme cell line and the line passes through the upper side of the square of the cell; </li><li>  12 - the cell is the extreme cell line and the line passes through the bottom side of the square of the cell. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Examples of such states are shown in the figure below.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/8bf/0a4/620/8bf0a462022b4ca092a4fae051393c9e.png"><br><br>  As a result of solving a crossword puzzle, the user receives the following image: <br><br><img src="https://habrastorage.org/files/84f/114/457/84f114457f18415aa045869a404162a5.png"><br></div></div><br>  The first thing that comes to mind as a way to represent the state of a crossword puzzle is a two-dimensional array, that is, a matrix of char elements.  The type char has a dimension of 1 byte, that is, it allows you to store one of 2 ^ 8 = 256 states. <br><br>  We divide the 8-bit byte into two groups: the low and high bits.  We get 4 bits in each group, each group makes it possible to store 2 ^ 4 = 16 states. <br><br><img src="https://habrastorage.org/files/55f/81f/82e/55f81f82efa0438cb61703ae31a84828.png" alt="image"><br><br>  Thus, we allocate 4 high-order bits for storing information about the method of filling the cell, and 4 low-order bits for storing information about the number indicated in the cell. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BYTE_NUMBER_PART 15 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    00001111 #define BYTE_FLAG_PART 240 //    11110000</span></span></span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Description of the structure of the crossword</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JCStruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Resolved; <span class="hljs-comment"><span class="hljs-comment">//    char FileName[255]; //    char W; //   char H; //   char M[MAX_PUZZLE_HW][MAX_PUZZLE_ HW]; //    char Vector[CHANGE_VECTOR_SIZE][3]; //       [i, j, old_value] int Vector_s; // vector start pointer (     ) int Vector_e; // vector end pointer (     ) int DigitsCnt; // -    (     ) };</span></span></code> </pre><br></div></div><br>  We declare functions that allow using the bitwise multiplication to get the value of the highest (fill flag) and low (number in a cell) group of bits. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNumberFromByte</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//   ,   .   ,    0 { return c &amp; BYTE_NUMBER_PART; } char GetFlagFromByte (char c) //     .  0,     { return c &amp; BYTE_FLAG_PART; }</span></span></span></span></code> </pre><br>  We encode the possible flags for painting the cells of the crossword puzzle: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LN_ONE 16 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// 00010000  ,   /   .     1 #define LN_VERTICAL 32 // 00100000   /  ; #define LN_HORIZONTAL 48 // 00110000   /  ; #define LN_LEFT_TOP 64 // 01000000   /      ; #define LN_LEFT_BOTTOM 80 // 01010000   /      ; #define LN_RIGHT_TOP 96 // 01100000   /      ; #define LN_RIGHT_BOTTOM 112 // 01110000   /      ; #define LN_RIGHT 128 // 10000000         /   ; #define LN_LEFT 144 // 10010000         /   ; #define LN_TOP 160 // 10100000         /   ; #define LN_BOTTOM 176 // 10110000         /   .</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Usage example</b> <div class="spoiler_text"><pre> <code class="cpp hljs">JCStruct* jc; ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetFlagFromByte(jc-&gt;M[i][j]) == LN_HORIZONTAL) <span class="hljs-comment"><span class="hljs-comment">//           { }</span></span></code> </pre><br></div></div><br>  Further, all the functionality for drawing and changing the crossword puzzle is implemented using the above constants and functions. <br><br><h3>  The scenario of connecting two numbers with lines </h3><br>  The user taps his finger on any cell with a number and leads from it to another cell with the same number.  When you press a finger, if the line complies with the three rules described at the beginning of the article, the line is fixed, resulting in a fixation of the state of the cells of the matrix through which it passes. <br><br>  The current line, which the user leads with a finger, is reflected in the CurrentLineStackStruct structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PointStruct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-comment"><span class="hljs-comment">//       int y; //       }; struct CurrentLineStackStruct // ,      { char num; // ,     PointStruct stack[9]; // ,    ,      char len; //   }; CurrentLineStackStruct LineStack;</span></span></code> </pre><br>  During initialization, as well as with each ‚Äúrelease‚Äù of a finger from the screen, this stack is initialized to its original state by calling the following function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearCurrentStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LineStack.len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LineStack.num = 0; // ,      }</span></span></code> </pre><br>  Finger / stylus handling on the crossword grid is handled by the Redraw function, which returns true if the crossword is to be redrawn after processing, and false otherwise. <br><br><div class="spoiler">  <b class="spoiler_title">Redraw</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* jc -    JCStruct DrawContext - -,      ,  : jc_screen_x -  x      jc_screen_y -  y      cell_wh -      jc_screen_w -     jc_screen_h -     */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Redraw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// x,y --  - { if (!jc-&gt;Resolved) //    ,     if ((DrawContext.jc_screen_x &lt;= x) &amp;&amp; (x &lt; DrawContext.jc_screen_x + DrawContext.jc_screen_w)) if ((DrawContext.jc_screen_y &lt;= y) &amp;&amp; (y &lt; DrawContext.jc_screen_y + DrawContext.jc_screen_h)) { //    int i = (x - DrawContext.jc_screen_x) / DrawContext.cell_wh; int j = (y - DrawContext.jc_screen_y) / DrawContext.cell_wh; //     ,     ,   char n = GetNumberFromByte(jc-&gt;M[i][j]); if ((LineStack.len == 0) &amp;&amp; (n == 0)) return false; //    ,   if (GetFlagFromByte(jc-&gt;M[i][j]) &gt; 0) return false; // ,           for (int s = 0; s &lt; LineStack.len; s++) if ((LineStack.stack[s].x == i) &amp;&amp; (LineStack.stack[s].y == j)) { //   LineStack.len = s + 1; return true; } //     ,      ,    (       ) if (LineStack.len == 0) { //   LineStack.len++; LineStack.num = n; //  ,    //      LineStack.stack[LineStack.len - 1].x = i; LineStack.stack[LineStack.len - 1].y = j; return true; } else //    ,      { // ,     //       (      num) if (LineStack.len &lt; LineStack.num) { // ,     ,      if ((abs(LineStack.stack[LineStack.len - 1].x - i) == 1 &amp;&amp; LineStack.stack[LineStack.len - 1].y == j) || (LineStack.stack[LineStack.len - 1].x == i &amp;&amp; abs(LineStack.stack[LineStack.len - 1].y - j) == 1) ) { //      ,    ,   , //   ,            if (n == 0 || LineStack.num == n &amp;&amp; LineStack.len == n - 1) { LineStack.len++; LineStack.stack[LineStack.len - 1].x = i; LineStack.stack[LineStack.len - 1].y = j; return true; } return false; } //     ,        if ((LineStack.stack[LineStack.len - 1].x != i) &amp;&amp; (LineStack.stack[LineStack.len - 1].y == j)) { int len = abs(i - LineStack.stack[LineStack.len - 1].x); //    int d = (i - LineStack.stack[LineStack.len - 1].x) / len; //   ( ) for (int s = 0; s &lt; len; s++) { if (LineStack.len &lt; LineStack.num) { //      if (GetFlagFromByte(jc-&gt;M[LineStack.stack[LineStack.len - 1].x + d][j]) &gt; 0) { if (s &gt; 0) return true; //     - ,    else return false; //     ,     } n = GetNumberFromByte(jc-&gt;M[LineStack.stack[LineStack.len - 1].x + d][j]); if (n &gt; 0) //      { if (n != LineStack.num) //      ,    { if (s &gt; 0) return true; //     - ,    else return false; //     ,     } else //      ,   , .. n == LineStack.num { if (LineStack.num != LineStack.len + 1) //         { if (s &gt; 0) return true; //     - ,    else return false; //     ,     } } } LineStack.len++; LineStack.stack[LineStack.len - 1].x = LineStack.stack[LineStack.len - 2].x + d; LineStack.stack[LineStack.len - 1].y = j; } } return true; } //     ,        if ((LineStack.stack[LineStack.len - 1].x == i) &amp;&amp; (LineStack.stack[LineStack.len - 1].y != j)) { int len = abs(j - LineStack.stack[LineStack.len - 1].y); //    int d = (j - LineStack.stack[LineStack.len - 1].y) / len; //   ( ) for (int s = 0; s &lt; len; s++) { if (LineStack.len &lt; LineStack.num) { //      if (GetFlagFromByte(jc-&gt;M[i][LineStack.stack[LineStack.len - 1].y + d]) &gt; 0) { if (s &gt; 0) return true; //     - ,    else return false; //     ,     } n = GetNumberFromByte(jc-&gt;M[i][LineStack.stack[LineStack.len - 1].y + d]); if (n &gt; 0) //      { if (n != LineStack.num) //      ,    { if (s &gt; 0) return true; //     - ,    else return false; //     ,     } else //      ,   , .. n == LineStack.num { if (LineStack.num != LineStack.len + 1) //         { if (s &gt; 0) return true; //     - ,    else return false; //     ,     } } } LineStack.len++; LineStack.stack[LineStack.len - 1].x = i; LineStack.stack[LineStack.len - 1].y = LineStack.stack[LineStack.len - 2].y + d; } } return true; } return false; } else //  ,   { return false; } } } return false; }</span></span></span></span></code> </pre><br></div></div><br>  When the finger / stylus is ‚Äúsqueezed out‚Äù, it processes the stack of the current line.  It is necessary to understand whether the line is drawn correctly, i.e., to check it for correctness, and, if correct, to update the corresponding cells of the matrix. <br><br><div class="spoiler">  <b class="spoiler_title">CheckCurrentLineStack</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*       ,       -       ,   */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckCurrentLineStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,      , //  ,   ,     ,     if ((LineStack.len &gt; 0) &amp;&amp; (LineStack.len == LineStack.num) &amp;&amp; (LineStack.num == GetNumberFromByte(jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y])) ) { //      SetMatrixElement(jc, LineStack.stack[0].x, LineStack.stack[0].y/*, 1*/); //       //  ,   /  [0 - , 1 - , 2 - , 3 - ] char l_prev, l_next; //    ,      for (int i = 1; i &lt; LineStack.len - 1; i++) { //     if (LineStack.stack[i - 1].x + 1 == LineStack.stack[i].x) l_prev = 0; if (LineStack.stack[i - 1].x - 1 == LineStack.stack[i].x) l_prev = 1; if (LineStack.stack[i - 1].y + 1 == LineStack.stack[i].y) l_prev = 2; if (LineStack.stack[i - 1].y - 1 == LineStack.stack[i].y) l_prev = 3; //   .  if (LineStack.stack[i + 1].x + 1 == LineStack.stack[i].x) l_next = 0; if (LineStack.stack[i + 1].x - 1 == LineStack.stack[i].x) l_next = 1; if (LineStack.stack[i + 1].y + 1 == LineStack.stack[i].y) l_next = 2; if (LineStack.stack[i + 1].y - 1 == LineStack.stack[i].y) l_next = 3; l_prev = MAX(l_prev, l_next) * 10 + MIN(l_prev, l_next); switch (l_prev) { case 32: jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] = jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] + LN_VERTICAL; break; case 31: jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] = jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] + LN_LEFT_TOP; break; case 30: jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] = jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] + LN_RIGHT_TOP; break; case 21: jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] = jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] + LN_LEFT_BOTTOM; break; case 20: jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] = jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] + LN_RIGHT_BOTTOM; break; case 10: jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] = jc-&gt;M[LineStack.stack[i].x][LineStack.stack[i].y] + LN_HORIZONTAL; break; } } //     if (LineStack.stack[1].x + 1 == LineStack.stack[0].x) jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] = jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] + LN_RIGHT; if (LineStack.stack[1].x - 1 == LineStack.stack[0].x) jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] = jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] + LN_LEFT; if (LineStack.stack[1].y + 1 == LineStack.stack[0].y) jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] = jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] + LN_BOTTOM; if (LineStack.stack[1].y - 1 == LineStack.stack[0].y) jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] = jc-&gt;M[LineStack.stack[0].x][LineStack.stack[0].y] + LN_TOP; //     if (LineStack.stack[LineStack.len - 2].x + 1 == LineStack.stack[LineStack.len - 1].x) jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] = jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] + LN_RIGHT; if (LineStack.stack[LineStack.len - 2].x - 1 == LineStack.stack[LineStack.len - 1].x) jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] = jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] + LN_LEFT; if (LineStack.stack[LineStack.len - 2].y + 1 == LineStack.stack[LineStack.len - 1].y) jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] = jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] + LN_BOTTOM; if (LineStack.stack[LineStack.len - 2].y - 1 == LineStack.stack[LineStack.len - 1].y) jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] = jc-&gt;M[LineStack.stack[LineStack.len - 1].x][LineStack.stack[LineStack.len - 1].y] + LN_TOP; DrawContext.need_save = true; } }</span></span></code> </pre><br></div></div><br><h3>  Drawing a crossword and the current line </h3><br>  Drawing a crossword puzzle is divided into the following steps: <br><br><ul><li>  Drawing shaded matrix cells; </li><li>  Drawing current line stack cells; </li><li>  Drawing lines on the filled cells of the matrix; </li><li>  Drawing lines on the stack cells of the current line; </li><li>  Drawing numbers on the cells. </li></ul><br>  In order not to unnecessarily overload the article with code, we will only list the listing itself from the interesting of the above points. <br><br><div class="spoiler">  <b class="spoiler_title">Drawing lines on shaded cells</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jc-&gt;Resolved == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//     { //     Iw2DSetColour(ColorSchema.JCCellLineColor); for (int i = 0; i &lt; jc-&gt;W; i++) for (int j = 0; j &lt; jc-&gt;H; j++) { n1 = jc-&gt;M[i][j] &amp; BYTE_FLAG_PART; switch (n1) { case LN_HORIZONTAL: Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + 0, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1 ), CIwFVec2(DrawContext.cell_wh - 0, 3) ); break; case LN_VERTICAL: Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + 0), CIwFVec2(3, DrawContext.cell_wh - 0) ); break; case LN_RIGHT: Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + 0, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(4, 3) ); break; case LN_LEFT: Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i + 1)* DrawContext.cell_wh - 4, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(4, 3) ); break; case LN_BOTTOM: Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + 0), CIwFVec2(3, 4) ); break; case LN_TOP: Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j + 1)* DrawContext.cell_wh + 0 - 4), CIwFVec2(3, 4) ); break; case LN_RIGHT_BOTTOM: //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + 0, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(DrawContext.cell_wh / 2 - 1 + 3, 3) ); //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + 0), CIwFVec2(3, DrawContext.cell_wh / 2 - 1 + 3) ); break; case LN_RIGHT_TOP: //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + 0, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(DrawContext.cell_wh / 2 - 1 + 3, 3) ); //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(3, DrawContext.cell_wh / 2 - 1 + 3) ); break; case LN_LEFT_BOTTOM: //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(DrawContext.cell_wh / 2 - 1 + 3, 3) ); //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + 0), CIwFVec2(3, DrawContext.cell_wh / 2 - 1 + 3) ); break; case LN_LEFT_TOP: //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(DrawContext.cell_wh / 2 - 1 + 3, 3) ); //   Iw2DFillRect(CIwFVec2(DrawContext.jc_screen_x + (i)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1, DrawContext.jc_screen_y + (j)* DrawContext.cell_wh + DrawContext.cell_wh / 2 - 1), CIwFVec2(3, DrawContext.cell_wh / 2 - 1 + 3) ); break; } } }</span></span></code> </pre><br></div></div><br><h3>  Checking the resolution of a crossword puzzle </h3><br>  Due to the fact that the correctness of each drawn line is checked at the time of its drawing, all existing lines comply with the three rules given at the beginning of the article.  And this in turn means that to verify the resolution of a crossword puzzle, we just need to make sure that all the cells with numbers are painted over. <br><br><div class="spoiler">  <b class="spoiler_title">CheckJC</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   0,   ,      ,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckJC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JCStruct * p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; p-&gt;W; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; p-&gt;H; j++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GetNumberFromByte(p-&gt;M[i][j]) &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,   1    ,      if(GetFlagFromByte(p-&gt;M[i][j]) == 0) //     return 100 * (i + 1) + (j + 1); return 0; }</span></span></code> </pre><br></div></div><br><br>  You can play the application at the links below: <br>  Black and white: <a href="https://play.google.com/store/apps/details%3Fid%3Dorg.popapp.fcross">Android</a> , <a href="https://itunes.apple.com/ru/app/id1091290034">iOS</a> <br>  Colored: <a href="https://play.google.com/store/apps/details%3Fid%3Dorg.popapp.color_fcross">Android</a> </div><p>Source: <a href="https://habr.com/ru/post/301184/">https://habr.com/ru/post/301184/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../301176/index.html">R in Microsoft Azure to win the hackathon. Instructions for use</a></li>
<li><a href="../301178/index.html">Exploration and engineering: 3D-models of buildings, junctions and quarries by photo</a></li>
<li><a href="../30118/index.html">CSS in Plurk</a></li>
<li><a href="../301180/index.html">Digest of recent advances in cryptography. Zero release</a></li>
<li><a href="../301182/index.html">[St. Petersburg, Announcement] Meeting with Andrey Pangin - Everything you wanted to know about stack-traces and hip dumps</a></li>
<li><a href="../301186/index.html">Magento 2: cookies, registry, session</a></li>
<li><a href="../301188/index.html">10 types of insane customers</a></li>
<li><a href="../301190/index.html">We control the computer from an Android device</a></li>
<li><a href="../301192/index.html">[Terraform + SaltStack] Cooking PrestoDB Cluster in a Pressure Cooker (Part # 1)</a></li>
<li><a href="../301194/index.html">How to create eye-catching images if you are not a designer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>