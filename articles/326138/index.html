<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pthreads: POSIX Threads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern operating systems and microprocessors have long supported multitasking, and at the same time, each of these tasks can be performed in several t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pthreads: POSIX Threads</h1><div class="post__text post__text-html js-mediator-article"><p>  Modern operating systems and microprocessors have long supported multitasking, and at the same time, each of these tasks can be performed in several threads.  This gives a tangible increase in computing performance and allows for better scaling of user applications and the server, but the price has to be paid for this - the development of the program and its debugging are complicated. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1cd/c90/892/1cdc90892b6e4c8cb0fd536ab9cce466.png"></div><br><p>  In this article, we will introduce POSIX Threads in order to learn how it all works in Linux.  Without going into the wilds of synchronization and signals, consider the main elements of Pthreads.  So, under the hood flows. </p><a name="habracut"></a><br><h3 id="obschie-svedeniya">  General information </h3><br><p> Multiple execution threads in a single process are called <em>threads,</em> and this is the basic unit of CPU utilization, consisting of a thread identifier, a counter, registers, and a stack.  Threads within one process divide sections of code, data, and various resources: open file descriptors, process credentials, signals, <code>umask</code> , <code>nice</code> values, timers, and so on. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f2a/6ae/55c/f2a6ae55c1f840fda9fb95c69c24df76.png"></div><br><p>  All executable processes have at least one execution thread.  Some processes are limited to this in those cases where additional execution threads do not give a performance boost, but only complicate the program.  However, such programs every day becomes relatively less. </p><br><p>  What is the use of multiple execution threads?  Let's take some loaded web server, for example habrahabr.ru.  If the server created a separate process to service each <code>http</code> request, we would wait forever for our page to load.  Creating a new process is an expensive pleasure for the OS.  Even taking into account the optimization by <em>copying while writing</em> , the <code>fork</code> and <code>exec</code> system calls create new copies of the memory pages and the list of file descriptors.  In general, the OS kernel can create a new thread an order of magnitude faster than a new process. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/38d/d97/b63/38dd97b638b945fc9d9cf965e7d27654.png"></div><br><p>  The kernel uses <strong>copy-on-write</strong> for data pages, memory segments of the parent process containing a stack and a heap.  Due to the fact that processes often call <code>fork</code> and immediately after <code>exec</code> , copying their pages during the execution of a <code>fork</code> call becomes unnecessary waste - they still have to be discarded after <code>exec</code> .  First, the page table entries point to the same pages of the physical memory of the parent process, the pages themselves are marked <em>read-only</em> .  Page copying occurs exactly at the moment <em>when you want to change it</em> . </p><br><p>  <em>Page tables before and after changing the total memory page during copying while recording.</em> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1c4/0c1/b7c/1c40c1b7ca234d988d878119b333e379.png"></div><br><p>  There is a pattern between the number of parallel threads of the process execution, the program's algorithm and the increase in productivity.  This dependence is called <em>Amdahl's Law</em> . </p><br><p>  <em>Amdahl's law for parallelization of processes.</em> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a19/9ba/cc6/a199bacc6845421f8c5045cc894e9ae9.png"></div><br><p>  Using the equation shown in the figure, you can calculate the maximum performance improvement of a system using N processors and the factor F, which indicates how much of the system <strong>can</strong> not be parallelized.  For example, 75% of the code runs in parallel, and 25% - in series.  In this case, a 1.6-fold program acceleration will be achieved on a dual-core processor, 2.28571 multiples on a quad-core processor, and the limit value of acceleration with N tending to infinity is 4. </p><br><h4 id="otobrazhenie-potokov-v-rezhim-yadra">  Mapping threads to kernel mode </h4><br><p>  Virtually all modern operating systems ‚Äî including Windows, Linux, Mac OS X, and Solaris ‚Äî support kernel-mode threading.  However, threads can be created not only in kernel mode, but also in user mode.  When using this level, the kernel does not know about the existence of threads - all thread management is implemented by the application using special libraries.  User threads are displayed differently on threads in kernel mode.  In total there are three models, of which 1: 1 is the most frequently used. </p><br><h5 id="otobrazhenie-n1">  Display N: 1 </h5><br><p>  In this model, several user threads are mapped to one OS kernel thread.  All thread management is performed by a special user library, and this is the advantage of this approach.  The disadvantage is that if a single thread performs a blocking call, then the whole process is inhibited.  Previous versions of Solaris OS used such a model, but then had to abandon it. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/327/7da/424/3277da4241014d7ea69eaed337ffeb17.png"></div><br><h5 id="otobrazhenie-11">  Display 1: 1 </h5><br><p>  This is the simplest model in which each thread created in a process is directly controlled by the OS kernel scheduler and mapped to one single thread in kernel mode.  So that the application does not produce uncontrolled flows, overloading the OS, impose a limit on the maximum number of threads supported in the OS.  This way of displaying threads is supported by Linux and Windows. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/843/662/6d7/8436626d7bae45169cf67e4715e78856.png"></div><br><h5 id="otobrazhenie-mn">  M Display: N </h5><br><p>  With this approach, M user streams are multiplexed into the same or smaller N number of kernel threads.  The negative effects of the two other models are overcome: the threads are really executed in parallel and there is no need for the OS to impose restrictions on their total number.  However, this model is quite difficult to implement in terms of programming. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/817/4a4/54c/8174a454c6ae48999bce74bdd6e9507e.png"></div><br><h3 id="potoki-posix">  POSIX threads </h3><br><p>  In the late 1980s and early 1990s there were several different APIs, but in 1995 <em>POSIX.1c</em> standardized POSIX threads, later it became part of the <em>SUSv3 specifications</em> .  Nowadays, multi-core processors have even penetrated desktops and smartphones, so most machines have low-level hardware support, allowing them to simultaneously run multiple threads.  In the old days, the simultaneous execution of streams on single-core CPUs was only an impressively inventive, but very effective illusion. </p><br><p>  <em>Pthreads</em> defines a set of types and functions in C. </p><br><ul><li>  <code>pthread_t</code> is a thread identifier; </li><li>  <code>pthread_mutex_t</code> - mutex; </li><li>  <code>pthread_mutexattr_t</code> - mutex attribute object </li><li>  <code>pthread_cond_t</code> - conditional variable </li><li>  <code>pthread_condattr_t</code> - conditional attribute object; </li><li>  <code>pthread_key_t</code> - data specific to the thread; </li><li>  <code>pthread_once_t</code> - context control of dynamic initialization; </li><li>  <code>pthread_attr_t</code> - list of stream attributes. </li></ul><br><p>  In the traditional Unix API, the <code>errno</code> last error code is a global <code>int</code> variable.  This is however not suitable for programs with multiple threads of execution.  In a situation where a function call in one of the executable threads ended in an error in the global variable <code>errno</code> , a race condition may occur due to the fact that other threads can check the error code at the moment and get embarrassed.  In Unix and Linux, this problem was circumvented by the fact that <code>errno</code> is defined as a macro that sets its own variable <code>lvalue</code> for each thread. </p><br><blockquote>  From <strong>man errno</strong> <br>  <em>The variable errno is defined in the ISO C standard as changeable lvalue int and not explicitly declared;</em>  <em>errno may be a macro.</em>  <em>The variable errno is the local value of the thread;</em>  <em>changing it in one thread does not affect its value in another thread.</em> </blockquote><br><h4 id="sozdanie-potoka">  Stream creation </h4><br><p>  First, a stream function is created.  Then a new thread is created by the <code>pthread_create()</code> function declared in the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html">pthread.h</a> header file.  Further, the caller continues to perform some of its actions in parallel to the stream function. </p><br><pre> <code class="hljs delphi">#include &lt;pthread.h&gt; int pthread_create(pthread_t *thread, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pthread_attr_t *attr, void *<span class="hljs-comment"><span class="hljs-comment">(*start)(void *)</span></span>, void *arg);</code> </pre> <br><p>  Upon successful completion, <code>pthread_create()</code> returns 0, a non-zero value signals an error. </p><br><ul><li>  The first parameter of the <code>pthread_create()</code> call is the address for storing the identifier of the <code>pthread_t</code> stream being created. </li><li>  The <code>start</code> argument is a pointer to a thread <code>void *</code> function, which accepts a typeless pointer as the only variable. </li><li>  The <code>arg</code> argument is a typeless pointer containing stream arguments.  Most often, <code>arg</code> points to a global or dynamic variable, but if the called function does not require arguments, then you can specify <code>NULL</code> as <code>arg</code> . </li><li>  The <code>attr</code> argument is also a typeless pointer to the <code>pthread_attr_t</code> stream attribute.  If this argument is <code>NULL</code> , then the stream is created with default attributes. </li></ul><br><p>  Consider now an example of a multithreaded program. </p><br><pre> <code class="hljs go">#include &lt;pthread.h&gt; #include &lt;stdio.h&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> atoi(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> char *nptr); void *potok(void *param); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char *argv[]) { pthread_t tid; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> pthread_attr_t attr; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc != <span class="hljs-number"><span class="hljs-number">2</span></span>) { fprintf(stderr,<span class="hljs-string"><span class="hljs-string">"usage: progtest &lt;integer value&gt;\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (atoi(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { fprintf(stderr,<span class="hljs-string"><span class="hljs-string">" %d     \n"</span></span>,atoi(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>])); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> pthread_attr_init(&amp;attr); <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> pthread_create(&amp;tid,&amp;attr,potok,argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> pthread_join(tid,NULL); printf(<span class="hljs-string"><span class="hljs-string">"count = %d\n"</span></span>,count); } <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> void *potok(void *param) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, upper = atoi(param); count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (upper &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= upper; i++) count += i; } pthread_exit(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><p>  To connect the Pthread library to a program, you need to pass the <code>-lpthread</code> option to the <code>-lpthread</code> . </p><br><pre> <code class="hljs swift">gcc -o progtest -std=c99 -lpthread progtest.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span></code> </pre> <br><p>  I‚Äôll talk about the accession of the <code>pthread_join</code> stream a bit later.  The string <code>pthread_t tid</code> specifies the thread id.  The function attributes are given by <code>pthread_attr_init(&amp;attr)</code> .  Since we did not specify them explicitly, the default values ‚Äã‚Äãwill be used. </p><br><h4 id="zavershenie-potoka">  End flow </h4><br><p>  The thread completes the task when: </p><br><ul><li>  the stream function executes <code>return</code> and returns the result of the performed calculations; </li><li>  as a result of the call to end the execution of the <code>pthread_exit()</code> thread; </li><li>  as a result of calling the thread cancel <code>pthread_cancel()</code> ; </li><li>  one of the threads makes an <code>exit()</code> call </li><li>  the main thread in the <code>main()</code> function performs a <code>return</code> , in which case all the threads of the process are abruptly collapsed. </li></ul><br><p>  Syntax is simpler than creating a stream. </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; void pthread_exit(void *retval);</span></span></span></span></code> </pre> <br><p>  If in the latter version the <code>main()</code> thread from the function <code>main()</code> executes <code>pthread_exit()</code> instead of just <code>exit()</code> or <code>return</code> , then the remaining threads will continue to be executed, as if nothing had happened. </p><br><h4 id="ozhidanie-potoka">  Waiting for flow </h4><br><p>  The <code>pthread_join()</code> function waits for the end of the thread denoted by <code>THREAD_ID</code> .  If this thread was already completed by that time, then the function immediately returns a value.  The meaning of the function is to synchronize threads.  It is declared in <code>pthread.h</code> as follows: </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; int pthread_join (pthread_t THREAD_ID, void ** DATA);</span></span></span></span></code> </pre> <br><p>  Upon successful completion, <code>pthread_join()</code> returns a code of 0, a non-zero value signals an error. </p><br><p>  If the <code>DATA</code> pointer is different from <code>NULL</code> , then the data returned by the stream through the <code>pthread_exit()</code> function or via the <code>return</code> instruction of the stream function is placed there.  Multiple threads cannot wait for one to complete.  If they attempt to do this, one thread will succeed, and all others will fail with an ESRCH error.  After <code>pthread_join()</code> , the stack space associated with the thread can be used by the application. </p><br><p>  In a sense, <code>pthread_joini()</code> is similar to the <code>waitpid()</code> call, waiting to complete the execution of the process, but with some differences.  <strong>First</strong> , all peer-to-peer flows, among them there is no hierarchical order, while the processes form a tree and are subject to parent-child hierarchy.  Therefore, a situation is possible when thread A spawned thread B, which in turn sealed B, but then after calling the function <code>pthread_join()</code> A will wait for C to complete or vice versa.  <strong>Secondly</strong> , you cannot instruct one to <em>wait for the completion of any thread</em> , as is possible with a call to <code>waitpid(-1, &amp;status, options)</code> .  It is also impossible to make a non-blocking call to <code>pthread_join()</code> . </p><br><h4 id="dosrochnoe-zavershenie-potoka">  Early termination of the stream </h4><br><p>  Just as with process management, it is sometimes necessary to complete the process ahead of time, a multithreaded program may need to complete one of the threads ahead of time.  To terminate the thread ahead of time, you can use the <code>pthread_cancel</code> function. </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pthread_cancel</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">pthread_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> THREAD_ID)</span></span></span></span>;</code> </pre> <br><p>  Upon successful completion, <code>pthread_cancel()</code> returns code 0, a nonzero value signals an error. </p><br><p>  It is important to understand that despite the fact that <code>pthread_cancel()</code> returns immediately and can terminate a thread ahead of time, it cannot be called a means of forcing a thread to terminate.  The fact is that the thread can not only choose the moment of completion in response to the <code>pthread_cancel()</code> call, but also completely ignore it.  A call to the <code>pthread_cancel()</code> function should be viewed as a request to perform early termination of a thread.  Therefore, if it is important for you that the thread be deleted, you need to wait for it to end with the <code>pthread_join()</code> function. </p><br><p>  A small illustration of creating and canceling a thread. </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> tid; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> pthread_create(&amp;tid, <span class="hljs-number"><span class="hljs-number">0</span></span>, worker, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> pthread_cancel(tid);</code> </pre> <br><p>  In order not to give the impression that arbitrariness and unpredictability of the results of this call prevail, consider the table of parameters that determine the behavior of the stream after receiving a call for early termination. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f7b/28b/f5c/f7b28bf5ca62470fa76474b84000bb3d.png"></div><br><p>  As we see, there are completely non-cancellable threads, and the default behavior is <em>deferred termination</em> , which occurs at the <strong>moment of termination</strong> .  And how do we know that this very moment has come?  For this there is an auxiliary function <code>pthread_testcancel</code> . </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* --- */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  - ? */</span></span> pthread_testcancel(); }</code> </pre> <br><h4 id="otsoedinenie-potoka">  Disconnect thread </h4><br><p>  Any default thread can be joined by calling <code>pthread_join()</code> and waiting for it to complete.  However, in some cases, the status of the end of the stream and the return value are not interesting to us.  All we need is to complete the flow and automatically unload the resources back to the OS.  In such cases, we denote the thread as <em>disconnected</em> and use the <code>pthread_detach()</code> call. </p><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;pthread.h&gt; int pthread_detach(pthread_t thread);</span></span></span></span></code> </pre> <br><p>  Upon successful completion, <code>pthread_detach()</code> returns code 0, a non-zero value signals an error. </p><br><p>  Disconnected stream is a sentence.  It can no longer be intercepted by calling <code>pthread_join()</code> to get the status of completion and other buns.  It is also impossible to cancel its disconnected state.  Tricky question.  What happens if the completion of the thread is not intercepted by calling <code>pthread_join()</code> and how is this different from the scenario in which the disconnected thread ended?  In the first case, we get a zombie stream, and in the second - everything will be normal. </p><br><h3 id="potoki-versus-processy">  Threads versus processes </h3><br><p>  Finally, I propose to consider several considerations on the topic: should the application be designed to be multi-threaded or run it in several processes with one thread?  First, the benefits of parallel multiple threads. </p><br><p>  In the initial part of the article, we have already indicated these advantages, therefore, in brief, we simply list them. </p><br><ul><li>  Threads are fairly easy to exchange data compared to processes. </li><li>  Creating threads for an OS is easier and faster than creating processes. </li></ul><br><p>  Now a little about the shortcomings. </p><br><ul><li>  When programming applications with multiple threads, it is necessary to ensure the streaming security of the functions - so-called.  <em>thread safety</em> .  Applications running through multiple processes do not have such requirements. </li><li>  One major stream can damage the rest, since the threads share the common address space.  Processes are more isolated from each other. </li><li>  Streams compete with each other in the address space.  The stack and local storage of a thread, capturing part of the process‚Äôs virtual address space, thereby making it inaccessible to other threads.  For embedded devices, this restriction can be significant. </li></ul><br><p>  The topic of threads is almost bottomless, even the basics of working with threads can pull on a couple of lectures, but we already know enough to study the structure of multi-threaded applications in Linux. </p><br><h4 id="ispolzovannye-materialy-i-dopolnitelnaya-informaciya">  Used materials and additional information </h4><br><ol><li>  Michael Kerrisk <em>The Linux Programming Interface.</em> </li><li>  Abraham Silberschatz, Peter B. Galvin Greg Gagne, <em>Operating System Concepts 9-th ed.</em> </li><li>  Nikolai Ivanov <em>Self-Programming Programming Guide for Linux 2nd Edition.</em> </li><li>  Andrew Tanenbaum <em>Computer Architecture</em> . </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/326138/">https://habr.com/ru/post/326138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326128/index.html">Protection of confidential data: the main features of IBM Security Guardium</a></li>
<li><a href="../326130/index.html">Agile everyone has his own: how to go with the flow, manage projects and not to suffer</a></li>
<li><a href="../326132/index.html">Subproject allocation in a separate repository on github</a></li>
<li><a href="../326134/index.html">Spring semester online courses from Academic University and CS Center</a></li>
<li><a href="../326136/index.html">PostCSS Hamster Framework - a tool that will make your life easier with the imposition. Typography. Vertical rhythm</a></li>
<li><a href="../326142/index.html">JPoint 2017: remember everything</a></li>
<li><a href="../326146/index.html">How it works in the java world. Thread pool</a></li>
<li><a href="../326148/index.html">Advanced tunneling: attack the internal nodes of the corporate network</a></li>
<li><a href="../326150/index.html">We trace element resizing without setTimeout and frames</a></li>
<li><a href="../326152/index.html">How to make friends with Realm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>