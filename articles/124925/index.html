<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to OpenCL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article focuses on the basics of programming with OpenCl. OpenCl is a programming language on the GPU / CPU, its structure is close to the c99 st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to OpenCL</h1><div class="post__text post__text-html js-mediator-article">  This article focuses on the basics of programming with OpenCl.  OpenCl is a programming language on the GPU / CPU, its structure is close to the <a href="http://ru.wikipedia.org/wiki/C99">c99</a> standard.  <a href="http://www.khronos.org/opencl/">Khronos Group</a> is engaged in its development, where full <a href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/">documentation</a> is available on their website.  In order to avoid controversy on the topic ‚Äúwell, this is all trivial, it‚Äôs enough to dig in the internet‚Äù at once I‚Äôll make a reservation: there is almost no information on this topic in runet, and in the western Internet it is available in a rather fragmented state on a dozen sites.  There will be some compilation of the basic principles, which will maximally simplify a novice programmer‚Äôs life, as well as allow using the computing power of a video card from the very first project.  People who have written 2-3 serious programs on OpenCl will no longer be interested.  The article is in a sense a continuation of my previous <a href="http://habrahabr.ru/blogs/hi/124873/">article</a> . <br><a name="habracut"></a><br><h4>  Compiler </h4><br>  First of all, the question: where to write the code itself.  As far as I know under .NET, there is not yet any whistle that allows you to process kernel code directly in the studio.  Therefore, we have to use third-party editors.  AMD, nVidia and Intel add them to their SDKs.  For some reason I like Intelovsky more.  Just as an option, there are several editors written by fans.  Of these, I like the editor that <a href="">came</a> with the <a href="">OpenCLTemplate the most</a> .  It is worth noting that this is the editors.  Compilation of the code occurs immediately before running on the GPU / CPU. <br><br><h4>  Device memory model </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/e09/d4d/ef7e09d4d31f0f482d0dc93f21540a80.jpg" alt="image"><br>  Before describing the language itself, I will give a brief description of the physical model of the device with which it interacts.  The execution of language commands goes on objects called ‚Äúwork-item‚Äù.  Each work-item is independent of the other and can execute code in parallel with the others.  If a process from one work-item wants to get data used or already processed by any other work-item, it can do this through shared memory.  Total memory is very slow, but it has a large volume.  To speed up the calculations there is a local memory.  If you are familiar with CUDA, then there it is called ‚Äúshared memory‚Äù.  It is much faster than the total, but not any process can access it.  Only the work-item of one group can access local memory.  These groups are called ‚ÄúCompute Unit‚Äù or ‚ÄúWorkgroup‚Äù (the first name refers to the physical partitioning at the hardware level, and the second to the logical partitioning at the program level).  Depending on the device in each of these groups, a different number of work-item (for example, 240 for the NVIDIA GT200 or 256 for the Radeon 5700 Series).  The number of these units is limited to a fairly small number (30 for the NVIDIA GT200 or 9-10 for the Radeon 5700 Series).  There is also an ultra-fast ‚Äúprivate memory‚Äù to which the work-item can access individually. <br>  OpenCL device drivers automate the start and operation of the work-item and workgroup.  For example, if we need to perform a million processes, and we have only a thousand work-item, then the drivers will automatically start each process with the next task after it is completed.  Understanding the physical layer is only required in order to have an idea about the possibilities of interaction between processes and the access of processes to memory. <br><br><h4>  Basic features </h4><br>  Since the basis of the language is practically standard with ++, I will consider only those features that distinguish OpenCL from it.  Consider the code of the simplest kernel program, which I cited in the last article.  This code adds two vectors, v1 and v2, putting the result in the first one. <br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">__kernel <font color="#0000ff">void</font> <br> floatVectorSum(__global <font color="#0000ff">float</font> * v1, <br> __global <font color="#0000ff">float</font> * v2) <br> { <br> <font color="#0000ff">int</font> i = get_global_id(0); <br> v1[i] = v1[i] + v2[i]; <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Procedure announcement </h5><br>  First of all, the mysterious "__kernel" catches the eye.  This directive should be marked with any procedure that we want to call from the outside.  If the procedure is not needed when working from the outside, it is possible not to mark it. <br><br><h5>  Types of memory </h5><br>  The data type "__global" denotes the memory that is allocated from the global address space of the operating device.  It is slow enough, but roomy.  For modern video cards measured by gigabytes.  If you are working on a processor, global is RAM. <br>  Besides global, there is a "__local".  Only the workgroup can access it.  About 8 kilobytes are allocated for each such group. <br>  Just a quick memory is "__privat".  This is a memory to which only a separate thread has access (work-item).  In total, 32 registers of this memory are allocated to the stream. <br>  The remaining types of memory that can be declared during kernel creation are based on the type "__global".  First, it is "__constant", which can only be used for reading.  Secondly, these are "__read_only", "__write_only" and "__read_write" - structures, the use of which is allowed only for images. <br><br><h5>  Process identifiers </h5><br>  After running on a video card, all processes are equivalent and execute an equivalent code.  But, obviously, we do not need multiple repetitions of the same action - each process must do its own piece of the task.  To understand their place in the world around them are process identifiers.  The simplest identifier is "get_global_id (0)".  In the case of the given example, it indicates the i number of the vector that should add this process.  If we process not a one-dimensional vector, but a two-dimensional image - we need to know the position of the process along two axes.  Of course, this value can be calculated.  But these are unnecessary operations.  Therefore, for convenience at startup, you can specify that we need a space of two-dimensional dimension.  Then in the process you can get both position identifiers: ‚Äúget_global_id (0)‚Äù, ‚Äúget_global_id (1)‚Äù.  The same can be done for three-dimensional space.  Often it may be necessary and the dimension of the space in which we work.  For example, for an image with virtually any treatment, we need its width and height.  To get the dimension of the space, the identifier ‚Äúget_global_size (i)‚Äù is used.  In addition, there are process identifiers within the working group - ‚Äúget_local_id (i)‚Äù, ‚Äúget_local_size (i)‚Äù and the identifier of the group itself - ‚Äúget_group_id (i)‚Äù, ‚Äúget_num_groups (i)‚Äù.  Most of these relationships are related to each other: num_groups * local_size = global_size, local_id + group_id * local_size = global_id, global_size% local_size = 0. <br><br><h4>  Optimization of calculations </h4><br>  The developers of OpenCL and video cards understood that the main purpose of their offspring is to speed up complex calculations.  To this end, a number of specialized features have been added to the language, which make it possible to obtain an increase in speed on mathematical problems when using them. <br><br><h5>  Embedded vectors </h5><br>  The very first feature are vectors and vector math.  In OpenCl, you can declare 2, 4, 8, and 16-dimensional vectors as variables.  This is done accordingly: int2, int4, int8, int16.  You can also declare double, byte and all other types.  The vectors of the corresponding dimension can be added / subtracted / divided / multiplied, and also any vector can be divided / multiplied by a number: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">uint4 sumall = (uint4)(1,1,1,1); <br> small += (uint4)(1,1,1,1); <br> sumall = sumall/2; <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  In addition, there are a number of functions optimized for vectors and allowing working directly with them.  These functions include the functions of calculating the distance, the function of the vector product.  For example: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">float4 dir1 = (float4)(1, 1, 1, 0); <br> float4 dir2 = (float4)(1, 2, 3, 0); <br> float4 normal = cross(dir1, dir2); <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  You can also merge vectors by taking parts from one and the other, as well as glue them into larger ones: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">int4 vi0 = (int4) -7 ; <br> int4 vi1 = (int4) ( 0, 1, 2, 3 ) ; <br> vi0.lo = vi1.hi; <font color="#008000">// </font> <br> int8 v8 = (int8)(vi0.s0123, vi1.s0123); <font color="#008000">//</font> <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h5>  Simple functions </h5><br>  The next feature of OpenClI is the built-in library of functions.  In addition to the standard set math.lib in OpenCl there are so-called native functions.  These are functions that are based directly on the use of certain functions of video cards and on rough mathematics.  It is not advisable to apply them for ultra-accurate calculations, but in the case of filtering images the difference cannot be noticed.  Such functions, for example, include: ‚Äúnative_sin‚Äù, ‚Äúnative_cos‚Äù, ‚Äúnative_powr‚Äù.  I will not give a more detailed explanation of these functions, there are a lot of them, and the principles are different.  If you need them - see the documentation. <br><br><h5>  Common Functions </h5><br>  In addition to "simple functions", developers have created a number called common function.  These are functions that are often found in image processing.  For example: mad (a, b, c) = a * b + c, mix (a, b, c) = a + (ba) * c.  These functions are performed faster than the corresponding mathematical operations. <br><br><h5>  Example </h5><br>  The site <a href="http://www.cmsoft.com.br/">www.cmsoft.com.br</a> has a wonderful example showing the possibilities for optimizing code with native and common functions: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">kernel <font color="#0000ff">void</font> regularFuncs() <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;5000; i++) <br> { <br> <font color="#0000ff">float</font> a=1, b=2, c=3, d=4; <br> <font color="#0000ff">float</font> e = a*b+c; <br> e = a*b+c*d; <br> e = sin(a); <br> e = cos(b); <br> e = a*b+c*d; <br> e = sin(a); <br> e = cos(b); <br> e = a*b+c*d; <br> e = sin(a); <br> e = cos(b); <br> float4 vec1 = (float4)(1, 2, 3, 0); <br> float4 vec2 = (float4)(-1, 3, 1, 0); <br> float4 vec = distance(vec1, vec2); <br> <font color="#0000ff">double</font> x=1, y=2, z=3; <br> <font color="#0000ff">double</font> resp = x*y+z; <br> } <br> } <br> kernel <font color="#0000ff">void</font> nativeFuncs() <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=0; i&lt;5000; i++) <br> { <br> <font color="#0000ff">float</font> a=1, b=2, c=3, d=4; <br> <font color="#0000ff">float</font> e = mad(a,b,c); <br> e = mad(a,b,c*d); <br> e = native_sin(a); <br> e = native_cos(b); <br> e = mad(a,b,c*d); <br> e = native_sin(a); <br> e = native_cos(b); <br> e = mad(a,b,c*d); <br> e = native_sin(a); <br> e = native_cos(b); <br> float4 vec1 = (float4)(1, 2, 3, 0); <br> float4 vec2 = (float4)(-1, 3, 1, 0); <br> float4 vec = fast_distance(vec1, vec2); <br> <font color="#0000ff">double</font> x=1, y=2, z=3; <br> <font color="#0000ff">double</font> resp = mad(x,y,z); <br> } <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  The second procedure (using optimization) is performed 35 times faster. <br><br><h4>  Permissions </h4><br>  It is worth noting that in OpenCl there are a number of directives allowing to include various additional functionals.  There are two reasons for this.  First, historically, not all of these functionals were supported.  The second is that these functionals can affect performance.  Usually the functionality is enabled by the following command: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#pragma</font> OPENCL EXTENSION extension name : behavior</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  For example.  The following commands include: the possibility of using the type of byte, double precision calculations and all mathematical functions <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_byte_addressable_store : enable <br> <font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_fp64 : enable <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Synchronization </h4><br><br><h5>  Barriers </h5><br>  Often synchronization is needed in calculations.  This is achieved in several ways.  The first is barriers.  A barrier is a team that will stop the process until all other processes or processes of its working group have been reached.  Here are two examples: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">kernel <font color="#0000ff">void</font> localVarExample() <br> { <br> <font color="#0000ff">int</font> i = get_global_id(0); <br> __local <font color="#0000ff">int</font> x[10]; <br> x[i] = i; <br> barrier(CLK_LOCAL_MEM_FENCE); <br> <font color="#0000ff">if</font> (i&gt;0) <font color="#0000ff">int</font> y = x[i-1]; <br> } <br> kernel <font color="#0000ff">void</font> globalVarExample() <br> { <br> <font color="#0000ff">int</font> i = get_global_id(0); <br> __global <font color="#0000ff">int</font> x[10]; <br> x[i] = i; <br> barrier(CLK_GLOBAL_MEM_FENCE); <br> <font color="#0000ff">if</font> (i&gt;0) <font color="#0000ff">int</font> y = x[i-1]; <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  In the first example, all the workgroup processes are expected on the barrier command, in the second, all OpenCL device processes are waiting. <br>  It is worth noting a feature of this example, the command "__local int x [10];"  and "__ global int x [10];".  They allow you to select a global variable in a group of processes and in all processes already during their execution. <br><br><h5>  Unit operations </h5><br>  The second synchronization option between threads is atomic.  These are functions that prevent simultaneous access to memory.  Before using them, you need to include the following directives: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable <br> <font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable <br> <font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable <br> <font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable <br> <font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_int64_base_atomics : enable <br> <font color="#0000ff">#pragma</font> OPENCL EXTENSION cl_khr_int64_base_atomics : enable <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  The simplest example of how this function works: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">__kernel <font color="#0000ff">void</font> test(global <font color="#0000ff">int</font> * num) <br> { <br> atom_inc(&amp;num[0]); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  If instead of ‚Äúatom_inc (&amp; num [0]);‚Äù, num ++ was written, the result of the program execution was unpredictable, since all processes would simultaneously access the memory and read the same value there.  In total there are 11 functions of unit operations: ‚Äúadd, sub, xchg, inc, dec, cmp_xchg, min, max, and, or, xor‚Äù. <br>  Using these functions is not difficult to create a semaphore. <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black"><font color="#0000ff">void</font> GetSemaphor(__global <font color="#0000ff">int</font> * semaphor) { <br> <font color="#0000ff">int</font> occupied = atom_xchg(semaphor, 1); <br> <font color="#0000ff">while</font> (occupied &gt; 0) <br> { <br> occupied = atom_xchg(semaphor, 1); <br> } <br> } <br> <br> <font color="#0000ff">void</font> ReleaseSemaphor(__global <font color="#0000ff">int</font> * semaphor) <br> { <br> <font color="#0000ff">int</font> prevVal = atom_xchg(semaphor, 0); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Work with images </h4><br><br>  The last thing I want to include in this guide is working with images via OpenCL.  The creators tried to make the work with images require a minimum of the user's brain.  It is very nice.  Image uploading is possible in the image2d_t and image3d_t types.  The first ones are ordinary images, the second ones are three-dimensional.  Also, the loaded image must be in one of the formats: "__ read_only", "__write_only", "__read_write".  Reading and writing data from an image is possible only by special procedures: value = read_imageui (image, sampler, position), write_imageui (image, position, value). <br>  In my opinion, everything is clear here except the notion of ‚Äúsampler‚Äù.  The sampler is the thing that will optimize your work with the image.  It has three parameters: ‚Äúnormalized coords‚Äù, ‚Äúaddress mode‚Äù, ‚Äúfilter mode‚Äù.  The first has two meanings: "CLK_NORMALIZED_COORDS_TRUE, CLK_NORMALIZED_COORDS_FALSE".  According to the name, it should indicate whether the input coordinates are normalized or not.  The second shows what to do in case you try to read coordinates from outside the borders of the image.  Possible options: mirror the image (CLK_ADDRESS_MIRRORED_REPEAT), take the nearest boundary value (CLK_ADDRESS_CLAMP_TO_EDGE), take the base color (CLK_ADDRESS_CLAMP), do nothing (the user guarantees that this will not happen CLK_ADDRESS_NONE).  The third shows what to do if the input is not integer coordinates.  Possible options: approximate the nearest value (CLK_FILTER_NEAREST), linearly interpolate (CLK_FILTER_LINEAR). <br>  A brief example.  We are overrun the image by the average value in the area: <br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">__kernel <font color="#0000ff">void</font> ImageDiff(__read_only image2d_t bmp1, __write_only image2d_t bmpOut) <br> <br> { <br> <font color="#0000ff">const</font> sampler_t smp = CLK_NORMALIZED_COORDS_FALSE | <br> CLK_ADDRESS_CLAMP_TO_EDGE | <br> CLK_FILTER_NEAREST; <br> int2 coords = (int2)(get_global_id(0), get_global_id(1)); <br> uint4 sumall = (uint4)(0,0,0,0); <br> <font color="#0000ff">int</font> sum = 0; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i=-10;i&lt;11;i++) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j=-10;j&lt;11;j++) <br> { <br> int2 newpol = (int2)(i,j)+coords; <br> sumall+= read_imageui(bmp1, smp, newpol); <br> sum++; <br> } <br> sumall = sumall/sum; <br> write_imageui(bmpOut, coords, sumall); <br> } <br></font> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br><h4>  Utility </h4><br>  Well, I think I coped with the short description.  Now a few links for more detailed study, if anyone needs. <br>  <a href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/">Official website with documentation.</a> <br>  <a href="http://www.cmsoft.com.br/">Site with examples and clear descriptions.</a> <br>  <a href="http://www.prace-project.eu/hpc-training/prace-stream-computing-workshop/opencl-20training.pdf">Good pdf files, there the structure of OpenCl devices is nicely drawn.</a> <br>  There are also 2 presentations about OpenCL in Russian.  They have quite a bit of information and there is no link text.  True, there are good examples.  <a href="http://edu.mmcs.sfedu.ru/~dubrov/files/sl_parallel_06_opencl.pdf">The first</a> .  <a href="http://www.compression.ru/video/seminar/slides/2009_OpenCLOverview.pdf">The second</a> . </div><p>Source: <a href="https://habr.com/ru/post/124925/">https://habr.com/ru/post/124925/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124913/index.html">MLAA morphological smoothing algorithm for CPU</a></li>
<li><a href="../124915/index.html">Runkit + PHPUnit = 100% test coverage</a></li>
<li><a href="../124916/index.html">GarageBand - What an almost amateur can ‚Äúwrite‚Äù in 8 minutes</a></li>
<li><a href="../124921/index.html">Psychological mistakes startups</a></li>
<li><a href="../124924/index.html">There are personal messages on Google+, but not everyone knows about it.</a></li>
<li><a href="../124926/index.html">Mozilla announced its intention to create its own mobile web OS</a></li>
<li><a href="../124927/index.html">Video infographics and typography</a></li>
<li><a href="../124928/index.html">Network security experts find Macbook battery firmware vulnerable to cracking</a></li>
<li><a href="../124929/index.html">How much do online stores earn us by selling us a product for $ 1000?</a></li>
<li><a href="../124931/index.html">KnockoutJS: Filtering listings on the fly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>