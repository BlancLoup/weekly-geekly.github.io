<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to algorithm complexity analysis (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: this text is given with insignificant abbreviations due to places of excessive ‚Äúrazvezhnannosti‚Äù material. The author absolutely ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to algorithm complexity analysis (part 2)</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: this text is given with insignificant abbreviations due to places of excessive ‚Äúrazvezhnannosti‚Äù material.</i>  <i>The author absolutely rightly warns that certain topics may seem too simple or well-known to the reader.</i>  <i>Nevertheless, personally this text helped me to streamline the existing knowledge on the analysis of the complexity of algorithms.</i>  <i>I hope that it will be useful to someone else.</i> <i><br></i>  <i>Due to the large volume of the original article, I broke it into pieces, which in total will be four.</i> <i><br></i>  <i>I (as always) would be extremely grateful for any comments in PM about improving the quality of the translation.</i> <br><br>  Published previously: <br>  <a href="http://habrahabr.ru/post/196560/">Part 1</a> <br><br><h4>  Complexity </h4><br>  From the previous part, we can conclude that if we can discard all these decorative constants, then it will be very easy to talk about the asymptotic behavior of the program instruction counting function.  In fact, any program that does not contain cycles has <code>f( n ) = 1</code> , because in this case a constant number of instructions is required (of course, in the absence of recursion - see below).  A single cycle from <code>1</code> to <code>n</code> gives the asymptotics <code>f( n ) = n</code> , since before and after the cycle it performs a constant number of commands, and the constant number of instructions within the cycle is executed <code>n</code> times. <br><a name="habracut"></a><br>  Guided by such considerations is less tedious than reading instructions each time, so let's look at a few examples of how to consolidate this material.  The following <a href="http://php.net/">PHP</a> program checks whether the array <code>A</code> size <code>n</code> contains the specified value: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $exists = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( $i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; n; ++$i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( $A[ $i ] == $value ) { $exists = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br>  This method of searching for values ‚Äã‚Äãinside an array is called a <i>linear search</i> .  This is a valid name, since the program has <code>f( n ) = n</code> (which means ‚Äúlinear‚Äù more precisely, we will look at the next section).  The <code>break</code> allows the program to complete earlier, even after a single iteration.  However, I remind you that we are interested in the most unfavorable scenario, in which the array <code>A</code> does not contain the specified value at all.  Therefore, <code>f( n ) = n</code> is still. <br><br><div class="spoiler">  <b class="spoiler_title">Exercise 2</b> <div class="spoiler_text">  Systematically analyze how many instructions are necessary for the above PHP program in the most unfavorable case, in order to derive its asymptotics (in the same way as in the first part we analyzed the Javascript program).  It should turn out <code>f( n ) = n</code> . <br></div></div><br><br>  Let's look at a Python program that adds two values ‚Äã‚Äãfrom an array and writes the result to a new variable: <br><br><pre> <code class="python hljs">v = a[ <span class="hljs-number"><span class="hljs-number">0</span></span> ] + a[ <span class="hljs-number"><span class="hljs-number">1</span></span> ]</code> </pre><br>  Here we have a constant number of instructions, therefore, <code>f( n ) = 1</code> . <br><br>  The following C ++ program checks whether a vector (a kind of array) contains <code>A</code> size <code>n</code> two identical values: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> duplicate = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; n; ++j ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( i != j &amp;&amp; A[ i ] == A[ j ] ) { duplicate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( duplicate ) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br><br>  Two nested cycles will give us the asymptotics of the form <code>f( n ) = n</code> <sup>2</sup> . <br><hr><br>  <b>Practical recommendation</b> : simple programs can be analyzed by counting the number of nested loops.  A single loop in <code>n</code> iterations gives <code>f( n ) = n</code> .  The loop inside the loop is <code>f( n ) = n</code> <sup>2</sup> .  The loop inside the loop inside the loop is <code>f( n ) = n</code> <sup>3</sup> .  And so on. <br><hr><br>  If in our program a function is called in the loop body, and we know the number of instructions executed in it, then it is easy to determine the total number of instructions for the program as a whole.  Consider the following C code as an example: <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i ) { f( n ); }</code> </pre><br>  If we know that <code>f( n )</code> executes exactly <code>n</code> instructions, then we can say that the number of instructions in the entire program asymptotically approaches <code>n</code> <sup>2</sup> , since <code>f( n )</code> is called <code>n</code> times. <br><hr><br>  <b>Practical recommendation</b> : if we have a series of consecutive for-cycles, then the asymptotic behavior of the program determines the slowest of them.  Two nested loops that follow a single loop are asymptotically the same as nested loops themselves.  Nested loops are said to <i>dominate</i> single ones. <br><hr><br>  Now let's switch to an interesting notation used by theorists.  When we figure out the exact asymptotic behavior of <code>f</code> , we say that our program is <code>Œò( f( n ) )</code> .  For example, in the examples above, the programs <code>Œò( 1 )</code> , <code>Œò( n</code> <sup>2</sup> <code>)</code> and <code>Œò( n</code> <sup>2</sup> <code>)</code> , respectively.  <code>Œò( n )</code> pronounced ‚Äútheta by n‚Äù.  Sometimes we say that <code>f( n )</code> (the original function of counting instructions, including constants) is <code>Œò( - )</code> .  For example, we can say that <code>f( n ) = 2n</code> is a function that is <code>Œò( n )</code> .  In general, nothing new.  You can also write that <code>2n ‚àà Œò( n )</code> , which is pronounced: ‚Äútwo n belongs to theta from n‚Äù.  Do not be confused by this notation: it simply says that if we count the number of commands required by the program, and it will be equal to <code>2n</code> , then the asymptotics of this algorithm is described as <code>n</code> (which we find by discarding the constant).  Having this notation, we present several true mathematical statements: <br><ol><li>  n <sup>6</sup> + 3n ‚àà Œò (n <sup>6</sup> ) </li><li>  2 <sup>n</sup> + 12 ‚àà Œò (2 <sup>n</sup> ) </li><li>  3 <sup>n</sup> + 2 <sup>n</sup> ‚àà Œò (3 <sup>n</sup> ) </li><li>  n <sup>n</sup> + n ‚àà Œò (n <sup>n</sup> ) </li></ol><br>  By the way, if you decide exercise 1 from the first part, then this is his correct answer. <br><br>  <b>We call this function (that is, what we write <code>Œò(  )</code> ) the <i>time complexity</i> , or simply the <i>complexity of</i> our algorithm.</b>  Thus, the algorithm with <code>Œò( n )</code> has complexity <code>n</code> .  There are also special names for <code>Œò( 1 )</code> , <code>Œò( n )</code> , <code>Œò( n</code> <sup>2</sup> <code>)</code> and <code>Œò( log( n ) )</code> , because they are very common.  They say that <code>Œò( 1 )</code> is an algorithm with <i>constant time</i> , <code>Œò( n )</code> is <i>linear</i> , <code>Œò( n</code> <sup>2</sup> <code>)</code> is <i>quadratic</i> , and <code>Œò( log( n ) )</code> is <i>logarithmic</i> (do not worry if you still do not know what logarithm - we'll talk about it soon). <br><hr><br>  <b>Practical recommendation</b> : programs with a large <code>Œò</code> run slower than with a smaller one. <br><hr><br><br><h4>  Notation "big o" </h4><br>  In real life, it is sometimes problematic to find out the exact behavior of an algorithm in the way we considered above.  Especially for more complex examples.  However, we can say that the behavior of our algorithm will never cross a certain boundary.  This makes life easier, as a clear indication of how fast our algorithm is, we may not appear, even if the constants are ignored (as before).  All we need is to find this boundary, and how to do it is easier to explain with an example. <br><br>  The most famous task that is used in teaching algorithms is sorting.  An array <code>A</code> size <code>n</code> (sounds familiar, isn't it?), And we are asked to write a program that sorts it.  Interest here is that such a need often arises in real systems.  For example, a file browser needs to sort files by name in order to make it easier for users to navigate through them.  Or another example: in a video game, there may be a problem of sorting 3D objects displayed on the screen according to their distance from the player‚Äôs point of view in the virtual world.  Purpose: to determine which of them will be visible to him, and which - no (this is called the <a href="http://en.wikipedia.org/wiki/Hidden_surface_determination">Visibility Problem</a> ).  Sorting is also interesting because for it there are many algorithms, some of which are worse than others.  Also this task is simple for definition and explanation.  So let's write a piece of code that will sort the array. <br><br><pre> <code class="ruby hljs">b = [] n.times <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m = a[ <span class="hljs-number"><span class="hljs-number">0</span></span> ] mi = <span class="hljs-number"><span class="hljs-number">0</span></span> a.each_with_index <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|element, i|</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> element &lt; m m = element mi = i <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> a.delete_at( mi ) b &lt;&lt; m <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  This is a completely inefficient way to implement array sorting in Ruby.  (Of course, Ruby supports sorting arrays using built-in functions, which should be used. They are undoubtedly faster than the code above, presented for illustrative purposes only.) <br><br>  This method is called <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D0%25B2%25D1%258B%25D0%25B1%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BC">sorting by choice</a> .  First is the minimum element of the array ( <code>a</code> in the code above. The minimum is designated as <code>m</code> , and its index is <code>mi</code> ), which is placed at the end of the new array ( <code>b</code> in our case) and removed from the original.  Then, among the remaining values, the minimum is again, added to the new array (which now contains two values) and removed from the old one.  The process is repeated until all elements are transferred from the original to the new array, which means the end of sorting.  In our example, we have two nested loops.  The outer loop ‚Äúruns through‚Äù <code>n</code> times, and the inner loop once for each element of the array <code>a</code> .  Since initially <code>a</code> has <code>n</code> elements and at each iteration we delete one of them, first the internal cycle ‚Äúscrolls‚Äù <code>n</code> times, then <code>n - 1</code> , <code>n - 2</code> and so on, until at the last iteration the internal cycle passes only once. <br><br>  If we consider the sum of <code>1 + 2 + ... + (n - 1) + n</code> , then finding the complexity of this code will be somewhat problematic.  But we can find an ‚Äúupper limit‚Äù for it.  To do this, we change the program (you can mentally, without touching the code) to make it <b>worse</b> than it is, and then we derive the complexity for what happened.  Then you can confidently say that the original program works either as badly or (most likely) better. <br><br>  Let's now think about how we change the program to simplify the conclusion of complexity for it.  Do not forget: we can only worsen it (for example, adding new instructions to the code) so that our assessment makes sense for the original program.  Obviously, we can change the internal program loop, forcing it to be calculated <code>n</code> times at each iteration.  Some of these repetitions will be useless, but it will help us analyze the complexity of the resulting algorithm.  If we make this small change, then our new algorithm will have <code>Œò( n</code> <sup>2</sup> <code>)</code> , because we get two nested loops, each of which is executed exactly <code>n</code> times.  And if so, then the original algorithm has <code>O( n</code> <sup>2</sup> <code>)</code> .  <code>O( n</code> <sup>2</sup> <code>)</code> pronounced "big O from <code>n</code> squared."  This suggests that our program is asymptotically no worse than <code>n</code> <sup>2</sup> .  It will work either better or also.  By the way, if the code really has <code>Œò( n</code> <sup>2</sup> <code>)</code> , then we still say that it is <code>O( n</code> <sup>2</sup> <code>)</code> .  To better understand this, imagine that changing the original program does not change it much, making it only slightly worse.  Something like adding useless instructions to the beginning of a program.  This will only change the constant in the instruction calculation function, which we ignore in the asymptotics.  Thus, <code>Œò( n</code> <sup>2</sup> <code>)</code> for the program is <code>O( n</code> <sup>2</sup> <code>)</code> too. <br><br>  But the opposite is not always true.  For example, any code with <code>Œò( n )</code> also <code>O( n</code> <sup>2</sup> <code>)</code> in addition to <code>O( n )</code> .  If we imagine that the <code>Œò( n )</code> program is just a <code>for</code> loop that runs <code>n</code> times, we can make it worse by adding another <code>for</code> inside, also repeating <code>n</code> times.  This will give a program with <code>f( n ) = n</code> <sup>2</sup> .  To summarize: any program with <code>Œò( a )</code> is <code>O( b )</code> with <code>b</code> worse than <code>a</code> .  Notice also that the change does not have to make sense or create code similar to the original one.  All that is required of him is to increase the number of instructions in relation to the given <code>n</code> .  We use the result to count instructions, not to solve a problem. <br><br>  So, saying that the program has <code>O( n</code> <sup>2</sup> <code>)</code> , we are safe: the analysis of the algorithm has shown that it will never work worse than <code>n</code> <sup>2</sup> .  This gives us a good assessment of how fast our program is.  Let's solve a few examples so that you get a better idea of ‚Äã‚Äãthe new notation. <br><br><div class="spoiler">  <b class="spoiler_title">Exercise 3</b> <div class="spoiler_text">  Which of the following is true? <br><ol><li>  The algorithm with <code>Œò( n )</code> has <code>O( n )</code> </li><li>  The algorithm with <code>Œò( n )</code> has <code>O( n</code> <sup>2</sup> <code>)</code> </li><li>  The algorithm with <code>Œò( n</code> <sup>2</sup> <code>)</code> has <code>O( n</code> <sup>3</sup> <code>)</code> </li><li>  The algorithm with <code>Œò( n )</code> has <code>O( 1 )</code> </li><li>  The algorithm with <code>O( 1 )</code> has <code>Œò( 1 )</code> </li><li>  The algorithm with <code>O( n )</code> has <code>Œò( 1 )</code> </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text"><ol><li>  True, since the original program has <code>Œò( n )</code> .  Therefore, <code>O( n )</code> can be achieved without changing the program. </li><li>  Since <code>n</code> <sup>2 is</sup> worse than <code>n</code> , this is true. </li><li>  Since <code>n</code> <sup>3 is</sup> worse than <code>n</code> <sup>2</sup> , this is true </li><li>  Since <code>1</code> not worse than <code>n</code> , it is a lie.  If a program asymptotically uses <code>n</code> instructions (a linear number), then we cannot make it worse so that asymptotically it needs only <code>1</code> (constant number) instructions. </li><li>  Truth, since both difficulties are the same. </li><li>  It may or may not be true, it depends on the algorithm.  In general, this is a lie.  If the algorithm is <code>Œò( 1 )</code> , then it is, of course, <code>O( n )</code> .  But if it is <code>O( n )</code> , then there may not be <code>Œò( 1 )</code> .  For example, <code>Œò( n )</code> algorithm is <code>O( n )</code> , and <code>Œò( 1 )</code> is not. </li></ol><br></div></div><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Exercise 4</b> <div class="spoiler_text">  Using the summation of the members of an arithmetic progression, prove that the program is higher not only <code>O( n</code> <sup>2</sup> <code>)</code> , but also <code>Œò( n</code> <sup>2</sup> <code>)</code> .  If you do not know what an arithmetic progression is, then look at <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2580%25D0%25B8%25D1%2584%25D0%25BC%25D0%25B5%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B5%25D1%2581%25D1%2581%25D0%25B8%25D1%258F">Wikipedia</a> - this is not difficult. <br></div></div><br><br>  Since <code></code> complexity of the algorithm represents the <i>upper limit of</i> its present complexity, which, in turn, reflects <code>Œò</code> , sometimes we say that <code>Œò</code> gives us <i>an accurate estimate</i> .  If we know that the boundary we found is not exact, we can use a lower-case <code></code> to denote it.  For example, if the algorithm is <code>Œò( n )</code> , then its exact complexity is <code>n</code> .  Therefore, this algorithm is <code>O( n )</code> and <code>O( n</code> <sup>2</sup> <code>)</code> at the same time.  Since the algorithm is <code>Œò( n )</code> , then <code>O( n )</code> defines the boundary more precisely.  And we can write <code>O( n</code> <sup>2</sup> <code>)</code> as <code>( n</code> <sup>2</sup> <code>)</code> (pronounced "small o from n squared") to show what we know about the lack of strictness of the border.  Of course, it is better when we can find the exact boundaries for our algorithm in order to have more information about its behavior, but, unfortunately, this is not always easy to do. <br><br><div class="spoiler">  <b class="spoiler_title">Exercise 5</b> <div class="spoiler_text">  Determine which of the following boundaries are strict and which are not. <br><ol><li>  <code>Œò( n )</code> algorithm for which we found <code>O( n )</code> as the upper bound </li><li>  <code>Œò( n</code> <sup>2</sup> <code>)</code> algorithm for which we found <code>O( n</code> <sup>3</sup> <code>)</code> as the upper bound </li><li>  <code>Œò( 1 )</code> algorithm for which we found <code>O( n )</code> as the upper bound </li><li>  <code>Œò( n )</code> algorithm for which we found <code>O( 1 )</code> as the upper bound </li><li>  <code>Œò( n )</code> algorithm for which we found <code>O( 2n )</code> as the upper bound </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text"><ol><li>  In this case, the <code>Œò</code> complexity and <code>O</code> complexity are the same, so the boundary is strict </li><li>  Here <code>O</code> complexity of a larger scale than <code>Œò</code> , therefore this boundary is not strong.  In fact, the strict boundary here is <code>O( n</code> <sup>2</sup> <code>)</code> .  So we can write that the algorithm is <code>o( n</code> <sup>3</sup> <code>)</code> </li><li>  Again, <code>O</code> complexity of a larger scale than <code>Œò</code> , from which we conclude that the boundary is not strict.  <code>O( 1 )</code> strict, and <code>O( n )</code> can be rewritten as <code>o( n )</code> </li><li>  We had to make a mistake in drawing this boundary, because it is wrong.  <code>Œò( n )</code> algorithm cannot have an upper bound <code>O( 1 )</code> , since <code>n</code> is more complex than <code>1</code> .  Do not forget, <code>O</code> denotes the upper limit </li><li>  It may seem that there is a lax border, but, in general, it is not.  In fact, the border is strict.  I recall that the asymptotics of <code>2n</code> and <code>n</code> are the same, and <code>O</code> and <code>Œò</code> are associated only with asymptotics.  So we have <code>O( 2n ) = O( n )</code> , therefore, the boundary is strict, since the complexity is <code>Œò</code> </li></ol><br></div></div><br></div></div><br><hr><br>  <b>Practical recommendation</b> : to find out the <code>O</code> complexity of the algorithm is simpler than its <code>Œò</code> complexity. <br><hr><br>  By now, you might already have gotten confused in all these new notations, but let's get acquainted with two more symbols before proceeding to the further examples.  Above, we changed our program to make it worse (we increased the number of instructions and, thus, the execution time), than we created the O-notation.  <code></code> tells us that our code will never run slower than a certain limit.  From this we get a basis for evaluation: is our program good enough?  If we act in the opposite way, having made the existing code <b>better</b> , and we find the complexity of what happens, then we will use the Œ©-notation.  Thus, <code>Œ©</code> gives us complexity, beyond which our program cannot be.  It is useful if we want to prove that the program is slow or the algorithm is bad.  It can also be used when we say that the algorithm is too slow to use in this particular case.  For example, the statement that the algorithm is <code>Œ©( n</code> <sup>3</sup> <code>)</code> means that the algorithm is no better than <code>n</code> <sup>3</sup> .  It may be <code>Œò( n</code> <sup>3</sup> <code>)</code> , or <code>Œò( n</code> <sup>4</sup> <code>)</code> , or even worse, but we will know the limit of its ‚Äúgoodness‚Äù.  Thus, <code>Œ©</code> gives us the <i>lower limit of the</i> complexity of our algorithm.  Similarly to <code>Œø</code> , we can write <code>œâ</code> if we know that this limit is not strict.  For example, <code>Œò( n</code> <sup>3</sup> <code>)</code> algorithm is <code>Œø( n</code> <sup>4</sup> <code>)</code> and <code>œâ( n</code> <sup>2</sup> <code>)</code> .  <code>Œ©( n )</code> pronounced ‚Äúomega large from n‚Äù, while <code>œâ( n )</code> pronounced ‚Äúomega small from n‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">Exercise 6</b> <div class="spoiler_text">  For the following Œò-difficulties, write strict and non-strict O-limits and, if desired, strict and non-strict Œ©-limits (provided that they exist). <br><ol><li>  Œò (1) </li><li>  Œò (‚àön) </li><li>  Œò (n) </li><li>  Œò (n <sup>2</sup> ) </li><li>  Œò (n <sup>3</sup> ) </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Decision</b> <div class="spoiler_text">  This exercise is a direct use of the definition above. <br><ol><li>  The strict boundaries will be <code>O( 1 )</code> and <code>Œ©( 1 )</code> .  The non-strict O-boundary is <code>O( n )</code> .  I remind you that Oh gives us an upper limit.  Since <code>n</code> lies on a scale higher than <code>1</code> , this is a weak limit, and we can also write it as <code>o( n )</code> .  But we cannot find a non-strict limit for <code>Œ©</code> , because there is no function lower than <code>1</code> .  So you have to deal with a strict boundary. </li><li>  The strict limits will be the same as the Œò-complexity, i.e.  O (‚àön) and Œ© (‚àön), respectively.  For non-strict limits, we will have <code>O( n )</code> , since <code>n</code> greater than ‚àön.  And since this boundary is weak, we can write <code>o( n )</code> .  As a lower non-strict boundary, we simply use <code>Œ©( 1 )</code> (or <code>œâ( 1 )</code> ) </li><li>  The strict limits are <code>O( n )</code> and <code>Œ©( n )</code> .  <code>œâ( 1 )</code> and <code>o( n</code> <sup>3</sup> <code>)</code> can be nonstrict.  Not the best boundaries, since both are far from the original complexity, but they fit our definition </li><li>  The strict boundaries are <code>O( n</code> <sup>2</sup> <code>)</code> and <code>Œ©( n</code> <sup>2</sup> <code>)</code> .  As non-strict boundaries, we use <code>œâ( 1 )</code> and <code>o( n</code> <sup>3</sup> <code>)</code> , as in the previous example </li><li>  The strict boundaries are <code>O( n</code> <sup>3</sup> <code>)</code> and <code>Œ©( n</code> <sup>3</sup> <code>)</code> , respectively.  The two non-strict boundaries can be œâ (‚àönn <sup>2</sup> ) and o (‚àönn <sup>3</sup> ).  Although these limits are still lax, they are better than the ones we derived above </li></ol><br></div></div><br></div></div><br><br>  The reason why we use <code>O</code> and <code>Œ©</code> instead of <code>Œò</code> that we may not be sure of the accuracy of the bounds we found or simply do not want to dig the algorithm deeper. <br><br>  If you do not fully remember all this variety of symbols, do not worry.  You can always come back and refresh information on them.  The most important characters are <code>O</code> and <code>Œò</code> . <br><br>  Notice also that although <code>Œ©</code> gives us a lower limit for the behavior of our function (i.e., we improve the program so that it calculates fewer instructions), we still refer to the worst case analysis.  This is because we feed the program's worst data set and analyze its behavior. <br><br>  The following table contains the symbols that we have presented above, and their connection with ordinary mathematical icons for comparing numbers.  The reason why we use Greek letters instead of the usual mathematical notation is to show that we are dealing with a comparison of asymptotic estimates, and not with the usual one. <br><br><table><tbody><tr><th>  Comparison operator for asymptotic estimates </th><th>  Number comparison operator </th></tr><tr><td>  The algorithm is <b>o</b> (something) </td><td>  Number <b>&lt;</b> something </td></tr><tr><td>   <b>O</b> ( - ) </td><td>  <b>‚â§</b> - </td></tr><tr><td>   <b>Œò</b> ( - ) </td><td>  <b>=</b> - </td></tr><tr><td>   <b>Œ©</b> ( - ) </td><td>  <b>‚â•</b> - </td></tr><tr><td>   <b>œâ</b> ( - ) </td><td>  <b>&gt;</b> - </td></tr></tbody></table><br><br><hr><br> <b> </b> :   ,    <code>O</code> , <code>o</code> , <code>Œ©</code> , <code>œâ</code>  <code>Œò</code>    , <code>O</code>   ,    ,  <code>Œò</code> ,      ,  <code>Œ©</code> . <br><hr></div><p>Source: <a href="https://habr.com/ru/post/195482/">https://habr.com/ru/post/195482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195472/index.html">Young shoots, or Find me a computer circle</a></li>
<li><a href="../195474/index.html">Intel Perceptual Computing Challenge Competition - Inside View</a></li>
<li><a href="../195476/index.html">Team Larry Ellison Oracle Team USA won the America's Cup</a></li>
<li><a href="../195478/index.html">30 years of the GNU project</a></li>
<li><a href="../195480/index.html">RailsClub'Moscow 2013. Tomorrow Conference!</a></li>
<li><a href="../195484/index.html">Java Update Coffee Shop in GTA V</a></li>
<li><a href="../195486/index.html">Meet SQL Server 14</a></li>
<li><a href="../195488/index.html">Read this before sending your next business letter.</a></li>
<li><a href="../195490/index.html">15 years of google</a></li>
<li><a href="../195494/index.html">We hunt for memory leaks in Node.js (1st of 12 articles on Node.js from the Mozilla Identity team)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>