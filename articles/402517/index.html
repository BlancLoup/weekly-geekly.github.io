<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Winstar Graphic and Text Display Mode</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Graphic displays, including the type of OLED, most represented in our market by Winstar, have far less demand in relation to lowercase and publication...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Winstar Graphic and Text Display Mode</h1><div class="post__text post__text-html js-mediator-article">  Graphic displays, including the type of OLED, most represented in our market by Winstar, have far less demand in relation to lowercase and publications on their use are also much smaller.  Meanwhile, graphic OLED displays, due to the lack of reference to the font tables of a predefined pattern, provide the best way to get ergonomic indicator devices for a wide variety of needs.  And it turned out that the graphics mode in the WS0010 controller is initiated easier and more stable than the text one. <br><br>  Before proceeding to the consideration of the actual graphic displays, consider the evergreen problem with the problems of turning on the text mode of the WS0010 controller, which received an unexpected and obvious solution (oh, where were my eyes!). <br><a name="habracut"></a><br><h3>  Problem solving text mode WS0010 </h3><br>  It is well known that Winstar line displays have stability problems during initiation.  It turned out, by the way, that this is not only characteristic of the ‚Äúdamned Chinese‚Äù: the samples of Newhaven Display 16x2 I found with great difficulty, located on the other side of the globe, are externally a complete copy of Winstar, except for the location of some of the inscriptions and the name of the company on same form and same font): <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5c4/0e4/db8/5c40e4db8577cfcdacad5ecdf2652606.jpg" width="600" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Containing, as it is written in datasheets, a certain ‚ÄúLCD comparable‚Äù controller, these displays behave completely identical to Chinese and have the same drawbacks.  Obviously, there is no time to spend on checking other companies, like Midas, judging by this <a href="http://runawaybrainz.blogspot.com/2014/01/midas-2004-oled-character-display.html">publication</a> , and there was no international cooperation.  Globalized economy rulez! <br><br>  The difficulties of the text mode are expressed in the fact that at startup (for example, when rebooting or manually resetting the program of the controlling controller), garbage may appear on the displays, and lines 0 and 1 randomly change places.  Experiments have shown that it does not depend on the inclusion method (8-bit or 4-bit).  This issue is especially acute when a periodic software reboot is necessary, for example, using a Watchdog timer. <br><br>  Part of the problem is solved by a careful attitude to power (from a separate source, and in no case from USB Arduino), and a separate reboot through turning off and on the power of the display after launching the control program (see the <a href="https://geektimes.ru/post/284712/">previous publication of the</a> author).  As it turned out, the author of these lines is not the only one who offered a similar solution to the problem: the author of the add-on over LuquidCrystal called <a href="https://github.com/lukecyca/WinstarOLED">WinstarOLED</a> also included a special pw_pin, with which the display power is distorted when the program starts. <br><br>  But this is all, of course, initiative and half measures.  Someone SeregaB ran into a radical way (see <a href="http://we.easyelectronics.ru/lcd_gfx/rabota-s-indikatorami-weg005016-kontroller-ws0010.html">his publication</a> on easyelectronics.com - thank <a href="https://geektimes.ru/users/Tomasina/">Tomasina</a> for the tip).  He actually set a completely different task: to learn how to work just with the graphic, rather than the text mode.  Trying to switch between the modes, he quickly discovered that ‚Äú <i>switching to the graphic mode was normal, and from graphic to‚Äú text ‚Äùit was very clumsy</i> .‚Äù  Then he recalled that " <i>sometime, long ago, when the LH was still printed on paper, I read in some of the LH on the HD44780 that mode switching should be done only when the screen is off</i> ."  And it all worked. <br><br>  From the cited publication, I will simply reproduce here two switching procedures, adapting them somewhat for use in conjunction with LuquidCrystal (an instance of the class is called OLED1 here). <br><br>  Switch to graphic mode: <br><pre><code class="hljs cmake">OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x1F);//   OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08|<span class="hljs-number"><span class="hljs-number">0</span></span>x04);// </code> </pre> <br>  Switch to text mode: <br><pre> <code class="hljs cmake"> OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x08);//  OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x17);//    OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x01);//    (..  clear()) OLED1.<span class="hljs-keyword"><span class="hljs-keyword">command</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>x04 | <span class="hljs-number"><span class="hljs-number">0</span></span>x08);// </code> </pre> <br>  As we will see later, the first procedure is not very necessary: ‚Äã‚ÄãWS0010 switches to graphic mode from a half-ping; it is enough to send the command 0x1F to it.  But the second sequence of teams was very business.  For the sample, it was included directly into the sketch using LuquidCrystal in this form: <br><pre> <code class="hljs ruby">void reset_textmode() /<span class="hljs-regexp"><span class="hljs-regexp">/     { OLED1.command(0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  OLED1.command(0x17);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x01);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    OLED1.command(0x04 | 0x08);/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  }</span></span></code> </pre> <br>  Then this function was called in setup immediately after the library was initiated: <br><br><pre> <code class="hljs ruby"> . . . . . OLED1.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-number"><span class="hljs-number">2</span></span>  reset_textmode(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  clear() . . . . .</code> </pre> <br>  If you add some delay (500) before this, the demonstration turns out to be very visual: after pressing the reset button of the Arduino board on the screen, as usual, garbage appears, but only for a moment: after the function is triggered, the screen is cleared and all lines appear in their places . <br><br>  The function works the same way, but for convenience, I replaced this sequence of commands with the contents of the LiquidCrystalRus :: clear () function in the file of the updated LiquidCrystalRus_OLED.cpp library, which was discussed earlier (recall that <a href="">you can download it</a> from the author‚Äôs site).  Expectations of the command in the library is not provided, because for reliability after each command there in the general style of the library inserted delays of 100 Œºs.  In the sketches that use this version of LiquidCrystalRus_OLED, at the beginning of the setup, you must call the clear () function, and it will also clean the screen at the same time. <br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  There is one misunderstanding with clearing the screen: in the command table in the datasheet it is noted that the 0x01 command can last as much as 6.2 ms ‚Äúwhen fsp or fosc = 250KHz‚Äù.  What kind of ‚Äúfsp or fosc‚Äù is actually in specific controllers, they are too lazy to write, but in any case, even if they are megahertz, the delay for this command should be significant (and the author of this article mentions).  However, in practice it turns out that the cleaning team works quite well and if there is no delay at all.  So I did not understand, and acted according to the well-known programmer rule: ‚Äúit works - do not touch!‚Äù. <br></div></div><br>  Now let's do, finally, the graphics mode. <br><br><h3>  Graphic mode in text displays WEH001602 </h3><br>  To begin with, I tried to switch the text display WEH001602BG I had to the graphic mode.  Note that the graphic 100x16 and the text (configuration 20x2, the 16x2 is just less than the horizontal dots) of the displays are identical to the matrix, only the text one is separated by spaces on familiarity.  This greatly limits the use of graphics mode in text displays, and even more text mode in graphics.  But to test how it works, you can use any of them. <br><br>  The display along with the DS1307 clock connected to the Arduino Nano as follows: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/606/8e2/216/6068e2216b082857a72cd76f322628e3.png" width="600" alt="image"><br><br>  According to the same scheme, we will connect further graphic displays.  The gray color in the diagram shows the connection of the second display, if necessary. <br><br>  You can use the improved procedure from the previous section to switch to the graphics mode, but a simple function from one command works quite well: <br><pre> <code class="hljs cs">. . . . . <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LCD_SETGRAPHICMODE 0x1f LiquidCrystal lcd(9, 4, 8, 7, 6, 5); void setGraphicMode(){ lcd.command(LCD_SETGRAPHICMODE); } . . . . .</span></span></code> </pre> <br>  We don‚Äôt need any Russian table here, so the standard (unaligned) LiquidCrystal is used, which works flawlessly in graphics mode.  In order not to bother with debugging all library options, in the case when textual and graphical versions of displays are included in parallel, I use my own library for everyone (for textual upgraded Rus_OLED, for graphic ones).  Connection can still be done to the same legs of the controller, except for the conclusions of the resolution E, according to the above scheme. <br><br>  Further, I partially used the author's workings of the mentioned WinstarOLED library (in itself, this add-on above LuquidCrystal is unfinished, and it is not advisable to use it as is).  He introduced the convenient function of setting the graphic cursor (the error of the original is corrected here in the part of the maximum <i>x</i> value): <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | x); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | y); } }</code> </pre> <br>  The constant LCD_SETDDRAMADDR is defined in the LiquidCrystal library.  Display 100x16, like text, is divided into two lines 0 and 1, because <i>y</i> here can take only two values.  And the horizontal <i>x</i> coordinate varies from 0 to 99. By the set coordinate, the lcd.write () command sends a byte, the individual bits of which determine the luminous positions of the vertical line with a length of 8 points.  The leftmost position in the top row has coordinates of 0.0, the rightmost one in the bottom position is 99.1.  And the top point will correspond to the low bit, and the bottom point will correspond to the high bit. <br><br>  For the convenience of coding images, I wrote out a label in which you can quickly create the necessary code manually.  For full font tables, of course, it is advisable to use special editors (of which there are at least a million different degrees of independent activity), but 10 digits with the required bit order are faster processed manually, especially since automatically created fonts often still have to be finished.  In accordance with the above, the glyph, for example, the numbers 2 in 10x16 will be encoded as follows: <br><br><img src="http://revich.lib.ru/AVR/TableCod2.png" width="400" alt="image"><br><br>  All this is written in a two-dimensional array of the form: <br><pre> <code class="hljs markdown">const byte Data2[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">10</span></span>]={{0x06,0x07,0x03,0x03,0x03,0x83,0xc3,0x63,0x3f,0x1e}, {0xf0,0xf8,0xcc,0xc6,0xc3,0xc1,0xc0,0xc0,0xc0,0xc0}};</code> </pre> <br>  For each digit 0-9, a separate such array Data0, Data1, Data2 and so on is created.  For hours, except numbers, you will need a double point.  It can be made shorter: <br><pre> <code class="hljs markdown">const byte DataDP[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x70,0x70}, {0x1c,0x1c}};// </code> </pre> <br>  Since in the graphic mode the controller does not know how to "blink", it is necessary to blink with a colon programmatically.  You can also extinguish a double point by simply outputting zeros to the corresponding positions, but for uniformity I made a separate array <br><pre> <code class="hljs markdown">const byte DataDPclr[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">2</span></span>]={{0x00,0x00}, {0x00,0x00}};// . </code> </pre> <br>  For the output of each digit and separately for a double point, a separate function is written: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> draw2 (byte x<span class="hljs-comment"><span class="hljs-comment">/* */</span></span>) // ‚Äú<span class="hljs-number"><span class="hljs-number">2</span></span>‚Äù { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (byte i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(Data2[<span class="hljs-number"><span class="hljs-number">0</span></span>][ix]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(Data2[<span class="hljs-number"><span class="hljs-number">1</span></span>][ix]);} }</code> </pre> <br>  All functions are the same, but use different arrays, and for a double point and other limits of the cycle.  It turned out not too economically in terms of the amount of code (see more on this later), but it is clear and easy to correct errors.  Gaps between characters are taken into account at the output stage, indicating the corresponding position (the <a href="https://github.com/adafruit/RTClib">RTClib library</a> is used to read the clock): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { DateTime clock = RTC.now(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()!=old_second) { uint8_t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.hour()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()/<span class="hljs-number"><span class="hljs-number">10</span></span>; //  drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">28</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>=clock.minute()%<span class="hljs-number"><span class="hljs-number">10</span></span>; //<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>   drawValPos(<span class="hljs-keyword"><span class="hljs-keyword">values</span></span>,<span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clock.second()%<span class="hljs-number"><span class="hljs-number">2</span></span>) drawDP(<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> drawDPclr(<span class="hljs-number"><span class="hljs-number">24</span></span>); old_second=clock.second(); }//<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> clocksecond }</code> </pre> <br>  Ten digits of 20 bytes each will occupy 200 bytes in memory ‚Äî about 10% of its volume (and the 16x16 wide font, as in the example below, and all 16%).  Full monolingual font of this size, along with numbers, without taking into account all punctuation marks and specials.  characters, contains from 62 (English) to 74 (Russian without E) characters, the value will take up almost half of the ATmega328 RAM.  Because tricks with arrays and output functions separately for each character will have to be canceled, and do as expected.  That is, the fonts should be left in the program memory and loaded through PROGMEM, and all glyph drawings should be designed as a single font array, and loaded for display by character number in a single table.  Otherwise, the memory is not enough and the program code will swell up to unmanaged volume.  We will not dwell on this here, because in our simple examples all this is not required - we will be limited each time to a small strictly necessary number of characters. <br><br>  Due to the large size of the full text of the GraphicOLED_DC1307 sketch, I don‚Äôt cite it, you can download it <a href="">here</a> .  The text contains the resetOLED function, which distorts the power of the display when the controller is rebooted (via pwrPin D2), but it was never needed, so you can safely remove it.  The result of the program is shown in the photo: <br><br><img src="http://revich.lib.ru/AVR/WEH1602_clock.jpg" width="600" alt="image"><br><br>  Unfortunately, simultaneous stay in text and graphic mode is excluded, because if you want to use the remaining space, you will have to draw your own fonts (there is space for about 7 characters of the 5x7 font on each line). <br><br><h3>  Graphic display WEG010016A </h3><br>  When, finally, the ordered graphic displays of the WEG010016AL arrived, I began by trying to enter them into text mode in order to see what would come of it. <br><br>  To test the text mode, a program for simulating a clock-calendar display with an external temperature sensor, described <a href="https://geektimes.ru/post/284712/">in a previous publication,</a> was downloaded.  The result made me remember that different Winstar displays can be differently oriented with respect to the connector (in this case, the WEG010016A connector is at the top, the text WEH001602B, which we used above, at the bottom, at type C, generally at the side): <br><br><img src="http://revich.lib.ru/AVR/WEG10016_test.jpg" width="600" alt="image"><br><br>  With the orientation of the display we will understand further, but for now let's see what happened.  But it turned out nothing good: the text mode (of course, equipped with a crutch, which was discussed at the beginning of the article) works flawlessly, but in practice it is useless to use it due to the absence of gaps between the characters.  Therefore, we will not linger on it, but proceed to consider the graphics mode. <br><br>  The procedures for installing the graphics mode are the same as those discussed above for the text version.  It remains to deal with the flip of the display, if it has a connector at the top relative to the screen.  Of course, you can just flip the display, but the position with the connector facing down seems more natural and comfortable to me.  In addition, when using a type with a connector on the side, it may be necessary to orient the connector to the right and not to the left.  For the upside-down orientation, you need to convert the image ‚Äî that is, swap the first and last positions horizontally, the rows, and reverse the order of the bits in the bytes that make up the array (with the lower bit corresponding to the bottom point). <br><br>  Since I had already painted ten digits for the previous case, for the last task it was necessary to introduce the procedure of program reversion: <br><pre> <code class="hljs matlab">byte reverse(byte x) { byte result=<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>)) { result |= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">7</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br>  You can change the order of the horizontal coordinates and vertical lines by making changes to the setGraphicCursor function: <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGraphicCursor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; x &lt;= <span class="hljs-number"><span class="hljs-number">99</span></span> ){ lcd.command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">99</span></span>-x)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span> ){ lcd.command(LCD_SETCGRAMADDR | (<span class="hljs-number"><span class="hljs-number">1</span></span>-y)); } }</code> </pre> <br>  The output functions of the array of each digit remain the same, only the reversion of bits is added: <br><pre> <code class="hljs lua">void draw2 (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> x/* */) // <span class="hljs-number"><span class="hljs-number">2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">10</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> b=<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(Data2[<span class="hljs-number"><span class="hljs-number">0</span></span>][ix]); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(Data2[<span class="hljs-number"><span class="hljs-number">1</span></span>][ix]); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(b);} }</code> </pre> <br>  The full sketch of the GraphicOLED_DC1307_100x16 watch can be downloaded <a href="">from here</a> , and the result for the WEG010016AL display is shown in the photo: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_clock.jpg" width="600" alt="image"><br><br>  But on this photo a different type of font (16x16) on the display WEG010016CG (the display is also upside down): <br><br><img src="http://revich.lib.ru/AVR/WEG10016CG_clock.jpg" width="600" alt="image"><br><br>  If you create the font again, changing the order of the bits manually, then you do not need reversion and the program will run faster (although there are no noticeable delays to the eye).  But the above procedure is a bit of a coup useful in any case - to display various pictures.  For example, from one arrow pointing up and right, programmatically, you can get four directions at once. <br><div class="spoiler">  <b class="spoiler_title">Drawing arrows</b> <div class="spoiler_text">  The picture and the arrow code (coordinates and bits in the table are inverted in accordance with the lower position of the connector for the WEG010016AL display, see above): <br><br><img src="http://revich.lib.ru/AVR/TableCodArray.png" alt="image"><br><pre> <code class="hljs markdown">const byte DataATR[<span class="hljs-string"><span class="hljs-string">2</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">8</span></span>]={{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, {0x01,0x02,0x04,0x28,0x30,0x78,0x60,0x80}};</code> </pre> <br>  Output functions of multidirectional arrows: <br><pre> <code class="hljs lua">. . . . . void drawSW (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> x) //   (  ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][ix]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][ix]);} } void drawNW (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> x) //   (  ) {//   : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> b=<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][ix]); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][ix]); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(b);} } void drawNE (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> x) //   (  ) {//  ,    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> b=<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(ix)]); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(b); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); b=<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(ix)]); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(b);} } void drawSE (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> x) //   (  ) {//   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">byte</span></span> i = x; i&lt;x+<span class="hljs-number"><span class="hljs-number">8</span></span>; i++){ setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">0</span></span>); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(ix)]); setGraphicCursor(i, <span class="hljs-number"><span class="hljs-number">1</span></span>); lcd.<span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(DataATR[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">7</span></span>-(ix)]);} } . . . . .</code> </pre> </div></div><br>  The photo below shows the result of the procurement program of the display of the wind speed and wind direction sensor.  As you can see, it turned out to be very easy to implement in one line fonts of different sizes together with pictures: <br><br><img src="http://revich.lib.ru/AVR/WEG10016_wind.jpg" width="600" alt="image"><br><br>  In conclusion, I will add that <a href="https://github.com/iwi1/iwi_SPI_RS0010">here</a> is a very interesting library for working with WS0010 in graphic and text modes for SPI.  In text, it mostly copies Liquid Crystal (and what else can you think of?), And in graphic it has functions for drawing graphic primitives, embedded fonts (thick, like mine, and the usual 5x7) and much more. </div><p>Source: <a href="https://habr.com/ru/post/402517/">https://habr.com/ru/post/402517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../402505/index.html">Augmented reality began to be massively applied in American industry.</a></li>
<li><a href="../402507/index.html">Personal wealth management as a fundamental human right</a></li>
<li><a href="../402509/index.html">Satellite navigation disables the brain areas responsible for building routes.</a></li>
<li><a href="../402511/index.html">How life began</a></li>
<li><a href="../402515/index.html">Braun Oral-B Genius 9000: when a brush gives advice through a smartphone</a></li>
<li><a href="../402519/index.html">The heirs-owners returned the work of the Strugatsky brothers to free access</a></li>
<li><a href="../402521/index.html">Infrared WiFi is 17 times faster than usual, but one-sided</a></li>
<li><a href="../402523/index.html">"Thin World". Chapter 9</a></li>
<li><a href="../402525/index.html">Why OneDrive slowed under Linux</a></li>
<li><a href="../402527/index.html">From four to thirty two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>