<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows 7 Sensor and Location platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the components of Windows 7 is the Sensor and Location platform . Sensor and Location is part of Windows 7, which allows you to organize work w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows 7 Sensor and Location platform</h1><div class="post__text post__text-html js-mediator-article">  One of the components of Windows 7 is the <a href="http://www.microsoft.com/whdc/device/sensors/default.mspx">Sensor and Location platform</a> .  Sensor and Location is part of Windows 7, which allows you to organize work with various sensors and additional devices to measure something. <br><br>  Why do you need it?  Sensors are needed in order to simplify some trivial actions and save us from unnecessary worries in work.  This is especially true for laptop owners whose life is very dynamic.  Imagine that a lighting sensor is built into your computer, which is accessible to all applications and enables these applications to adjust their picture depending on the lighting.  Another example would be a GPS position sensor.  In this case, applications can adapt to the area where you are currently located.  For example, applications can display weather information specifically for the city where you are.  In fact, examples can be given a large number, it all depends on fantasy and specific cases.  Applications that change their behavior depending on external conditions are allocated in a separate class of applications and are called <a href="http://blogs.msdn.com/semantics/">context-sensitive applications</a> . <a name="habracut"></a><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/geektimes/post_images/dc7/556/f5f/dc7556f5ff98b58d02a110a57365ae85.jpg"></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The question may arise - ‚Äúand what, in fact, has changed?‚Äù, ‚ÄúWhy it could not have been done before?‚Äù.  The answer is simple - previously these scenarios could also be implemented.  However, this was not so easy.  In fact, working with external sensors was reduced to the exchange of information through the COM port, and each sensor had its own specific API.  For this reason, it was very difficult to organize some kind of universal software interface with which you could work simultaneously from several applications and this process would be transparent. <br><br>  This is exactly the problem that the Sensor and Location library solves.  It can be used to access various sensors and receive information from them in the same for all styles.  It is important that this problem is solved at the level of the operating system.  Such a move could give a new impetus to the development of context-sensitive applications.  The following is a diagram showing the structure of objects for working with sensors.  Next we look at this in more detail. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform13_6F6/image_905ccecb-198e-48a1-9cbf-7d3585d169c5.png"></div><br><br>  To connect a sensor to the Sensor and Location platform in Windows 7, you need to implement a driver and simple wrapper classes on .NET for working with this sensor. <br><br>  Of course, in the near future, end users are unlikely to be able to fully experience the power of this entire platform.  This will take some time for the hardware developers to develop and integrate their sensors into the hardware platforms.  However, we, the developers, can begin to prepare for this today.  Therefore, I plan to talk about how to work with the Sensor and Location platform in the context of our business applications. <br><br>  In order to conduct experiments not with virtual sensors, but with something more or less close to reality, we will use a device from Freescale semiconductor, built on the basis of the JMBADGE2008-B microcontroller.  This device is a small board that also has several sensors ‚Äî an accelerometer, a light sensor, and buttons. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/image_0c504230-9849-4439-8331-2227bfe6d97e.png"></div><br><br>  This <a href="http://www.freescale.com/webapp/sps/site/prod_summary.jsp%3Fcode%3DJMBADGE2008-B">device is</a> designed specifically to demonstrate the capabilities of the Sensor and Location platform in Windows 7. In fact, anyone can <a href="http://www.freescale.com/webapp/sps/site/prod_summary.jsp%3Fcode%3DJMBADGE%26tab%3DBuy_Parametric_Tab%26fromSearch%3Dfalse">buy</a> it.  Thus, this device is well suited to demonstrate this feature of Windows 7. <br><br>  Before we look at specific applications, let's take a look at how the Sensor and Location platform works.  Before the advent of Windows 7 and the Sensor &amp; Location platform, connecting various sensors came down to implementing a driver and software for it. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/image_b004663e-a565-4014-ac07-e5a12313db54.png"></div><br><br>  With such an organization, the task of interacting with external sensors is possible, but difficult.  To do this, each application must interact with the API that the developer of the sensor and the software that serves the sensor offer.  The problem is particularly acute if the application must use a variety of sensors of the same type from different manufacturers.  How does the Sensor &amp; Location platform offer to solve this problem? <br><br>  At the level of the operating system there are mechanisms for working with sensors.  There is a standard unified software interface for working with sensors - Sensor API.  In this case, all interactions with the sensor occur exactly through the Sensor API.  It is important that the interaction with all sensors occurs in the same style.  Now you do not need to integrate with the native API via p / invoke. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/image_e1481710-b11d-404e-a686-6d14d00e5b1d.png"></div><br><br>  In order to work with the Sensor and Location API, you need to download the appropriate .NET Interop Sample Library.  There are .NET wrappers for working with the Sensor API.  In it there are several classes with which you can work with sensors. <br><br>  The SensorManager class is the entry point.  Through it you can get information about the sensors, as well as work with them.  For example, using the GetSensorBySensorId &lt;&gt; method, you can access the sensor that interests us.  Each sensor must have a wrapper class that inherits from the base Sensor class.  There are already three such implementations in the .NET Interop Sample Library - AmbientLightSensor, Accelerometer3D, UnknownSensor. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/image_6942825f-8cc2-44f8-a36b-18d292aa4f35.png"></div><br><br>  The main idea when working with sensors is as follows.  When the sensor state changes (connected / disconnected / active / etc), a StateChanged event is generated.  This event is necessary to start or stop working with sensors.  After communication with the sensor has been established, a DataReportChanged event is generated when new data is received.  How often this event will be generated depends on the implementation of the sensor and the driver to it.  When processing this event, you can read the status of the sensors and somehow change the operation of the application.  For these purposes, the GetProperty method is used.  In the parameters of this method, the property identifier is transmitted, which must be read from the sensor.  As a rule, the details of calls to this method are hidden in the classes that are implemented for a specific sensor. <br><br>  In addition, each sensor has its own identifier (GUID), which can be used to identify the device.  When implementing a wrapper class for a sensor, this ID is indicated by an attribute.  Thus, access to the sensor can be obtained either by explicitly specifying the identifier of this sensor, or by referring to this wrapper class. <br><br><blockquote>  /// /// Represents a generic ambient light sensor <br>  /// <br>  [SensorDescription ("97F115C8-599A-4153-8894-D2D12899918A")] <br>  public class AmbientLightSensor: Sensor <br>  { <br>  // ... <br>  // ... <br>  // ... <br>  var sensors = SensorManager.GetSensorsByTypeId &lt;AmbientLightSensor&gt; (); <br></blockquote><br><br>  Let's try to implement a few examples of working with sensors that are available in the device from Freescale.  We will work with two types of sensors - an accelerometer (allows you to measure the angle of the device) and a light sensor (measures the level of illumination in the room). <br><br>  The first application that we implement will display the level of illumination in the form of a burning light bulb on a form.  First, let's subscribe to a state change event in the Sensor API.  This is necessary in order for the application to start working if the sensor is connected on the go.  In the event handler for this event, we get a list of all the sensors of the desired type and subscribe to the DataReportChanged event.  In the event handler for this event, we will read the value from the light sensor and write it in the TextBox on the form.  Because  the event is generated in the additional thread, you will also need to make a call to the Dispatcher.Invoke method, so that processing goes in the main thread and we can interact with elements on the form.  Thus we will receive the following code. <br><br><blockquote>  private void Window_Loaded (object sender, RoutedEventArgs e) <br>  { <br>  SensorManager.SensorsChanged + = SensorManagerSensorsChanged; <br>  } <br>  void SensorManagerSensorsChanged (SensorsChangedEventArgs change) <br>  { <br>  Dispatcher.Invoke ((System.Threading.ThreadStart) (UpdateSensorsList)); <br>  } <br>  private void UpdateSensorsList () <br>  { <br>  var sensors = SensorManager.GetSensorsByTypeId &lt;AmbientLightSensor&gt; (); <br>  foreach (var sensor in sensors) <br>  sensor.DataReportChanged + = delegate (Sensor sender, EventArgs e) <br>  { <br>  Dispatcher.Invoke ((System.Threading.ThreadStart) (delegate <br>  { <br>  if (ActiveSensorsListBox.SelectedItem == sender) <br>  { <br>  CurrentValue.Text = <br>  ((AmbientLightSensor) sender). CurrentLuminousIntensity.Intensity.ToString (); <br>  } <br>  })); <br>  }; <br>  } </blockquote><br><br>  Now in TextBox on the form displays the current value of light.  Now it is not difficult to implement some kind of visualization for this.  With the help of bindings in WPF we will display the degree of illumination in the form of light bulbs.  As a result, we get the following application. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo1_1_thumb.jpg"></div><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo1_2_thumb.jpg"></div><br><br>  Since the photo is very difficult to judge the operation of the application, I recorded a short video in which you can clearly see how the sensor responds to the degree of illumination. <br><br>  <a href="http://www.youtube.com/watch%3Fv%3DyEwyIoDZS_Y">Demonstration &gt;&gt;</a> <br><br>  Another sensor is more interesting - it allows you to determine the degree of inclination of the device along different axes.  To demonstrate the degree of inclination, we will take a three-dimensional model of the aircraft for a WPF application and will rotate it in space depending on the sensor parameters.  The principle of this application is similar to the previous one - we find the necessary sensors, subscribe to events and write down coordinates in the input fields on the form when processing them.  After that, we tie the coordinates of the model to the values ‚Äã‚Äãof these input fields. <br><br><blockquote>  private void UpdateSensorsList () <br>  { <br>  foreach (var sensor in SensorManager.GetSensorsByTypeId &lt;Accelerometer3D&gt; ()) <br>  { <br>  sensor.DataReportChanged + = delegate (Sensor sender, EventArgs e) <br>  { <br>  Dispatcher.Invoke ((System.Threading.ThreadStart) (delegate <br>  { <br>  if (UseXCoordinate.IsChecked == true) <br>  CurrentXValue.Text = ((Accelerometer3D) sender) .CurrentAcceleration [Accelerometer3D.AccelerationAxis.X] .ToString (); <br>  if (UseYCoordinate.IsChecked == true) CurrentYValue.Text = ((Accelerometer3D) sender) .CurrentAcceleration [Accelerometer3D.AccelerationAxis.Y] .ToString (); <br>  if (UseZCoordinate.IsChecked == true) CurrentZValue.Text = ((Accelerometer3D) sender) .CurrentAcceleration [Accelerometer3D.AccelerationAxis.Z] .ToString (); <br>  })); <br>  }; <br>  } <br>  } </blockquote><br><br>  As can be seen from this example, the code for working with sensors has not changed very much.  In fact, only the code for receiving data from the sensors changed, and the rest remained unchanged. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo2_1_thumb.jpg"></div><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo2_2_thumb.jpg"></div><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo2_3_thumb.jpg"></div><br><br>  As can be seen from the photo when tilting the device, the sensor transmits information to the application and the coordinates of the model change.  Thus, we can see the effect of the tilt of the three-dimensional model. <br><br>  <a href="http://www.youtube.com/watch%3Fv%3D0sQkBF2c0VU">Demonstration &gt;&gt;</a> <br><br>  Interestingly, these sensors can use multiple applications at the same time.  Also in the same application you can use multiple sensors.  Let's combine the application with the rotation of the three-dimensional model with a light sensor.  In this case, in addition to turning the model, we will show the sun.  If the illumination in the room decreases, then the sun will disappear.  The more lighting in the room, the more intense the sun will shine.  Accordingly, this application uses the code from the two previous examples.  Therefore, I will not give the code, but immediately show the result. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo3_1_thumb.jpg"></div><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo3_2_thumb.jpg"></div><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform23_E91F/Demo3_3_thumb.jpg"></div><br><br>  You can also see this application in dynamics. <br><br>  <a href="http://www.youtube.com/watch%3Fv%3DC61ATAQoY6E">Demonstration &gt;&gt;</a> <br><br>  These examples clearly show that working with sensors in Windows 7 is very simple.  However, for this you need to have a driver for Windows 7 and a wrapper class for the Sensor &amp; Location platform.  As a rule, drivers are supplied by the manufacturer of the hardware platform, but the wrapper class can be implemented independently. <br><br>  As I said before, the entry point is the SensorManager class.  Using this class, you can access the necessary sensors and work with them.  This class has such methods as getting a list of all sensors, getting a sensor by ID or by type, a request to use a sensor, as well as an event for changing the number of sensors in the system. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform33_13569/image_e4e60119-f4d4-4eeb-860d-ff846a8ea6e6.png"></div><br><br>  Each sensor has two main types of identifiers - SensorId and TypeId.  TypeId identifies a particular device class.  For example, it is possible to get all the light sensors in the system, or some other types of devices.  SensorId is assigned uniquely to each device.  For example, if there are three motion sensors of the same type in the system, each will have a unique identifier.  There is also CategoryId, which combines sensors into categories. <br><br>  Each identifier is a GUID.  They are set by manufacturers when developing a device and drivers.  Thus, you can get a specific sensor only by knowing its ID.  Each sensor is represented by a Sensor class.  It has general information about the sensor and methods that allow obtaining data from generalized collections in untyped form.  It is clear that such a presentation of data is not very convenient for our applications.  Therefore, it is common for each sensor to implement a wrapper class within the framework of the Sensor API.  It is implemented by inheriting from the general class Sensor.  In the demo examples there are already two such implementations - for the accelerometer and for the light sensor.  However, in the device that we considered earlier there are also touch buttons that can also be used.  So let's implement such a class for this sensor. <br><br>  We will define a new class that will be derived from the Sensor class.  In order for it to be recognized in the Sensor API, it must be marked with the SensorDescription attribute, in which you specify the TypeId for this type of sensor.  In the base Sensor class, there are two important things for us ‚Äî the DataReport property and the DataReportChanged event.  This property contains data from the sensor, and the event is triggered when they change.  The task of our class is to use this data and deliver it to the user of our class in a convenient way.  To do this, create another small class that will be engaged in the analysis of information from DataReport. <br><br>  Experimentally, we find out that pressing button 1 generates code 1, pressing 2 generates code 2, pressing 3 generates code 4, and pressing 4 generates code 8. It can be seen that binary bits are used here.  A code 0 is also generated if all the buttons are released.  So we can write the following code. <br><br><blockquote>  [SensorDescription ("545C8BA5-B143-4545-868F-CA7FD986B4F6")] <br>  public class SwitchArraySensor: Sensor <br>  { <br>  public class SwitchArraySensorData <br>  { <br>  private static Guid KeyStateProperyId = new Guid (@ "38564a7c-f2f2-49bb-9b2b-ba60f66a58df"); <br><br>  public SwitchArraySensorData (SensorReport report) <br>  { <br>  uint state = (uint) report.Values ‚Äã‚Äã[KeyStateProperyId] [0]; <br>  Button1Pressed = (state &amp; 0x01)! = 0; <br>  Button2Pressed = (state &amp; 0x02)! = 0; <br>  Button3Pressed = (state &amp; 0x04)! = 0; <br>  Button4Pressed = (state &amp; 0x08)! = 0; <br>  } <br>  public bool Button1Pressed {get;  private set;  } <br>  public bool Button2Pressed {get;  private set;  } <br>  public bool Button3Pressed {get;  private set;  } <br>  public bool Button4Pressed {get;  private set;  } <br>  } <br>  public SwitchArraySensorData Current <br>  { <br>  get {return new SwitchArraySensorData (DataReport);  } <br>  } <br><br>  public event EventHandler StateChanged; <br><br>  public SwitchArraySensor () <br>  { <br>  DataReportChanged + = SwitchArraySensor_DataReportChanged; <br>  } <br>  void SwitchArraySensor_DataReportChanged (Sensor sender, EventArgs e) <br>  { <br>  if (StateChanged! = null) <br>  { <br>  StateChanged.Invoke (sender, e); <br>  } <br>  } <br>  } </blockquote><br><br>  In fact, this class is a wrapper in the Sensor API for the sensor we need.  To use it, I have to subscribe to the StateChanged event and get information through the Current property. <br><br>  To get a list of available sensors of a given type, you can use the GetSensorsByTypeId method of the SensorManager class.  At the same time, the TypeId of these sensors will be determined on the basis of the specified SensorDescription attribute.  Now, using these sensors, we can subscribe to the necessary event and receive data in a convenient form for the application.  For example, we can display a button click status on a form. <br><br><blockquote>  private void Window_Loaded (object sender, RoutedEventArgs e) <br>  { <br>  var sensors = SensorManager.GetSensorsByTypeId &lt;SwitchArraySensor&gt; (); <br>  foreach (SwitchArraySensor sensor in sensors) <br>  { <br>  switch (sensor.FriendlyName) <br>  { <br>  case "Left Switch Array Sensor": sensor.StateChanged + = delegate (object leftSensor, EventArgs arg) <br>  { <br>  var buttons = ((SwitchArraySensor) leftSensor) .Current; <br>  SwitchState (LeftButton1, buttons.Button1Pressed); <br>  SwitchState (LeftButton2, buttons.Button2Pressed); <br>  SwitchState (LeftButton3, buttons.Button3Pressed); <br>  SwitchState (LeftButton4, buttons.Button4Pressed); <br>  }; <br>  break; <br>  case "Right Switch Array Sensor": <br>  sensor.StateChanged + = delegate (object rightSensor, EventArgs arg) <br>  { <br>  var buttons = ((SwitchArraySensor) rightSensor) .Current; <br>  SwitchState (RightButton1, buttons.Button1Pressed); <br>  SwitchState (RightButton2, buttons.Button2Pressed); <br>  SwitchState (RightButton3, buttons.Button3Pressed); <br>  SwitchState (RightButton4, buttons.Button4Pressed); <br>  }; <br>  break; <br>  } <br>  } <br>  } </blockquote><br><br>  As a result, we get an application that looks like this. <br><br><div style="text-align:center;"><img src="http://blogs.gotdotnet.ru/personal/sergun/content/binary/WindowsLiveWriter/Windows7SensorandLocationplatform33_13569/image_9ce5849d-1452-4e86-ba02-0ae250f9a869.png"></div><br><br>  Of course, the example with the implementation of such a sensor is quite synthetic.  However, it clearly demonstrates the process of connecting the sensor to the Sensor API. <br><br>  Also, if you need to implement your own driver for the device in order to connect to the Windows 7 Sensor and Location platform, I recommend that you contact the <a href="http://www.microsoft.com/whdc/DevTools/WDK/WDKpkg.mspx">official</a> resource. <br><br>  Good luck to you in creating your context-sensitive applications! <br><br>  Demo applications: <br>  <a href="http%253A%252F%252Fblogs.gotdotnet.ru%252Fpersonal%252Fsergun%252Fcontent%252Fbinary%252FWindowsLiveWriter%252FWindows7SensorandLocationplatform23_E91F%252FAmbient.zip">Ambient.zip</a> <br>  <a href="http%253A%252F%252Fblogs.gotdotnet.ru%252Fpersonal%252Fsergun%252Fcontent%252Fbinary%252FWindowsLiveWriter%252FWindows7SensorandLocationplatform23_E91F%252FAccelerometer3D.zip">Accelerometer3D.zip</a> <br>  <a href="http%253A%252F%252Fblogs.gotdotnet.ru%252Fpersonal%252Fsergun%252Fcontent%252Fbinary%252FWindowsLiveWriter%252FWindows7SensorandLocationplatform23_E91F%252FCombined.zip">Combined.zip</a> <br>  <a href="http%253A%252F%252Fblogs.gotdotnet.ru%252Fpersonal%252Fsergun%252Fcontent%252Fbinary%252FWindowsLiveWriter%252FWindows7SensorandLocationplatform33_13569%252FButtonSensor.zip">ButtonSensor.zip</a> </div><p>Source: <a href="https://habr.com/ru/post/63401/">https://habr.com/ru/post/63401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../63391/index.html">Why mono is good</a></li>
<li><a href="../63393/index.html">A bit of visual criticism of javascript</a></li>
<li><a href="../63394/index.html">Hot MySQL BackUp Creation Tools</a></li>
<li><a href="../63395/index.html">IE8 and standards support - transparent PNG + opacity, as well as data: URI + AlphaImageLoader</a></li>
<li><a href="../63398/index.html">Ideas for Microsoft</a></li>
<li><a href="../63402/index.html">President of the Russian Federation Dmitry Medvedev signed a decree on the All-Russian compulsory publicly accessible television and radio channels</a></li>
<li><a href="../63405/index.html">EverMap ‚Üí NeverMap</a></li>
<li><a href="../63406/index.html">Habr and Microsoft Imagine Cup 2009 final</a></li>
<li><a href="../63407/index.html">Budget online media. How is it done by Westerners</a></li>
<li><a href="../63409/index.html">Javascript performance? What about page repainting performance?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>