<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another way to automatically invoke unit tests in the C language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Habr√© already there are several articles on how to develop unit tests in the C language. I am not going to criticize the described approaches, but ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another way to automatically invoke unit tests in the C language</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ec6/584/f50/ec6584f5014b4e4d901e14c70090a604.png" align="right">  On Habr√© already <a href="http://habrahabr.ru/post/240565/">there are</a> several <a href="http://habrahabr.ru/post/252439/">articles</a> on how to develop <a href="http://habrahabr.ru/post/123344/">unit tests</a> in the C language.  I am not going to criticize the described approaches, but only offer another one - the one that we use in the <a href="http://embox.github.io/">Embox</a> project.  A couple of times we already referred to it on <a href="http://habrahabr.ru/company/embox/blog/239387/">Habr√©</a> . <br><br>  Who cares, please roll!  But I warn you: there are a lot of spoilers from macros and linker magic. <br><a name="habracut"></a><br><h3>  Variable Length Static Arrays </h3><br>  A little dive into the issue.  The reason for the complexity of developing unit tests in the C language is the lack of static constructors in the syntax.  This means that you need to explicitly describe the calls of all functions with tests that you want to perform, and this, you see, is extremely inconvenient. <br>  On the other hand, when it comes to calling a large number of functions, I immediately have thoughts about an array of pointers.  That is, to call all the required functions, it is necessary to take an array of pointers to these functions, refer to each of its elements and call the corresponding function.  Thus, there is a design like this: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func_1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func_2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*all_tests[])(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) = {test_func_1, test_func_2}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(all_tests)/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(all_tests[<span class="hljs-number"><span class="hljs-number">0</span></span>]); i ++) { all_tests[i](); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  It immediately catches the eye that the array is initialized manually, and this is not convenient.  Reflecting on how to avoid this, we can formulate this Wishlist: <br><blockquote>  When defining a variable, we should be able to indicate that it belongs to an array. </blockquote><br>  Such a mechanism in the C language does not exist, but let's fantasize about the syntax.  It might look like this: <br><pre> <code class="hljs scala">&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arr</span></span></span><span class="hljs-class">[]</span></span>; &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">array(arr</span></span></span><span class="hljs-class">))</span></span>; &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">array(arr</span></span></span><span class="hljs-class">))</span></span>;</code> </pre><br>  Or, if you use the extension mechanism in gcc, which is expressed using __attribute__ <br><pre> <code class="hljs scala">&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arr</span></span></span><span class="hljs-class">[]</span></span>; &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__attribute__</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">array_member(arr</span></span></span><span class="hljs-class">)))</span></span>; &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__attribute__</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">array_member(arr</span></span></span><span class="hljs-class">)))</span></span>;</code> </pre><br>  It now remains to recall that the array in the C language is a constant pointer to the first element in this array, and the elements are arranged in series and have the same size.  So, if we can tell the compiler to put certain variables in memory in sequence, we will be able to organize our own array.  At the very least, we can handle these variables in the same way as we can with the elements of a real array. <br><br>  It is not the compiler that is responsible for the placement of the variables, but the linker, and in the linker scripts it is specified exactly how it should do this.  From the syntax of these scripts, it is clear that the linker groups data into sections, and if there are only one type of variables in a certain section, this will be an array in essence, and it will only be necessary to somehow determine the array label. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When we define an array, we specify the type of its elements.  So, you can define the first element and you can use the reference to it as an array.  And even better to enter an empty array of the specified type, since it is still needed for the correct syntax. <br>  It turns out something like this: <br><pre> <code class="hljs haskell">&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">&gt; arr[] __attribute__((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section</span></span></span><span class="hljs-class">(‚Äú</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_spread</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arr</span></span></span><span class="hljs-class">‚Äù))) = {};</span></span></code> </pre><br>  In order for the label to point to the beginning of the section, you can use scripts from the linker.  By default, the linker places data in an arbitrary order, but if you use the SORT (‚Äúsection_name‚Äù) function, the linker will sort the characters in the section in lexicographical order.  Thus, in order for the array symbol to point to the beginning of a section, we need the name of the subsection to lexicographically go before the rest of the array.  To do this, it is enough to assign ‚Äú0_head‚Äù to the beginning of the array, and for all variables - ‚Äú1_body‚Äù.  Of course, it would be enough just ‚Äú0‚Äù and ‚Äú1‚Äù, but then the program text would become less readable. <br><br>  Thus, the array declaration will look like this: <br><pre> <code class="hljs haskell">&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">&gt; arr[] __attribute__((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section</span></span></span><span class="hljs-class">(‚Äú</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_spread</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arr_0_head</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rodata</span></span></span><span class="hljs-class">‚Äù))) = {};</span></span></code> </pre><br>  The linker script itself looks like this: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">SECTIONS</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">.rodata.array_spread </span></span>: { *(<span class="hljs-built_in"><span class="hljs-built_in">SORT</span></span>(.array_spread.*.rodata)) } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">INSERT</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">AFTER</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.rodata</span></span>;</code> </pre><br>  You can connect it using the gcc -T key <br><br>  In order to indicate that some variable should be placed in one section or another, you need to add the corresponding attribute: <br><pre> <code class="hljs lisp">&lt;type&gt; a __attribute__((<span class="hljs-name"><span class="hljs-name">section</span></span>(‚Äúarray_spread.arr_1_body.rodata‚Äù)))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  Thus, we will form an array, but one more problem remains: how to get the size of this array?  If with regular arrays, we simply took its size in bytes and divided it by the size of the first element, then in this situation the compiler knows nothing about the size of the section.  To solve this problem, let us, as with the beginning of the array, add the same label to the end, again remembering the alphabetic sorting. <br>  So, we get the following: <br><pre> <code class="hljs haskell">&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">&gt; arr_tail[] __attribute__((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">section</span></span></span><span class="hljs-class">(‚Äú</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">array_spread</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">arr_9_tail</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rodata</span></span></span><span class="hljs-class">‚Äù))) = {};</span></span></code> </pre><br>  Now that we have all the necessary information on how to create an array, let's try to rewrite the previous example: <br><pre> <code class="hljs mel">#include &lt;stddef.h&gt; #include &lt;stdio.h&gt; void test_func_1(void) { printf(<span class="hljs-string"><span class="hljs-string">"test 1\n"</span></span>); } void test_func_2(void) { printf(<span class="hljs-string"><span class="hljs-string">"test 2\n"</span></span>); } void (*all_tests_item_1)(void) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".array_spread.all_tests_1_body.rodata"</span></span>))) = test_func_1; void (*all_tests_item_2)(void) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".array_spread.all_tests_1_body.rodata"</span></span>))) = test_func_2; void (*all_tests[])(void) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".array_spread.all_tests_0_head.rodata"</span></span>))) = {}; void (*all_tests__tail[])(void) __attribute__((section(<span class="hljs-string"><span class="hljs-string">".array_spread.all_tests_9_tail.rodata"</span></span>))) = {}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(void){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; printf(<span class="hljs-string"><span class="hljs-string">"%zu tests start\n"</span></span>, (size_t)(all_tests__tail - all_tests)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; (size_t)(all_tests__tail - all_tests); i ++) { all_tests[i](); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  If you run this program by specifying the above linker script, we get the same result as with regular arrays.  But you can not only create a static array of variable length in one file, but also an array distributed across different files, since the linker works at the last stage of the assembly, collecting all the object files into one, and this is sometimes very useful. <br><br>  Of course, the linker does not check the type and size of the objects that you placed in the section, and if you place objects of different types in the same section, you will be angry with Buratino yourself.  But if you do everything carefully, you will get a rather interesting mechanism for creating static arrays of variable length in the C language. <br><br>  Of course, this approach is not very convenient in terms of syntax, so it is worth hiding all the magic in macros. <br><br>  To begin with, simplify your life and introduce a couple of auxiliary macros that introduce the names of arrays, sections and variables. <br>  The first simplifies the section name: <br><pre> <code class="hljs smalltalk"><span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> __ARRAY_SPREAD_SECTION(array_nm, order_tag) \ <span class="hljs-comment"><span class="hljs-comment">".array_spread."</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#array_nm</span></span> order_tag <span class="hljs-comment"><span class="hljs-comment">".rodata,\"</span></span>a\<span class="hljs-comment"><span class="hljs-comment">",%progbits;#"</span></span></code> </pre><br>  The second defines an internal variable (the end-of-array label described above) <br><pre> <code class="hljs css"><span class="hljs-selector-id"><span class="hljs-selector-id">#define</span></span> __<span class="hljs-selector-tag"><span class="hljs-selector-tag">ARRAY_SPREAD_PRIVATE</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">array_nm</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">private_nm</span></span>) \ __<span class="hljs-selector-tag"><span class="hljs-selector-tag">array_spread__</span></span>#<span class="hljs-selector-id"><span class="hljs-selector-id">#array_nm</span></span>#<span class="hljs-selector-id"><span class="hljs-selector-id">#__</span></span>#<span class="hljs-selector-id"><span class="hljs-selector-id">#private_nm</span></span></code> </pre><br>  Now we define a macro that gets the array. <br><pre> <code class="hljs kotlin">#define ARRAY_SPREAD_DEF(element_type, name) \ element_type <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name[] __attribute__ ((used, \ <span class="hljs-comment"><span class="hljs-comment">/* Some versions of GCC do not take into an account section \ * attribute if it appears after the definition. */</span></span> \ section(__ARRAY_SPREAD_SECTION(name, <span class="hljs-string"><span class="hljs-string">"0_head"</span></span>)))) = \ { <span class="hljs-comment"><span class="hljs-comment">/* Empty anchor to the array head. */</span></span> }; \ element_type <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __ARRAY_SPREAD_PRIVATE(name,tail)[] \ __attribute__ ((used, \ <span class="hljs-comment"><span class="hljs-comment">/* Some versions of GCC do not take into an account section \ * attribute if it appears after the definition. */</span></span> \ section(__ARRAY_SPREAD_SECTION(name, <span class="hljs-string"><span class="hljs-string">"9_tail"</span></span>)))) = \ { <span class="hljs-comment"><span class="hljs-comment">/* Empty anchor at the very end of the array. */</span></span> }</code> </pre><br>  Actually, this is the previously used code wrapped in a macro. <br>  First we enter the label of the beginning of the array - an empty array, and put it in the ‚Äú0_head‚Äù section.  Then we enter another empty array and put it in the ‚Äú9_tail‚Äù section, this is the end of the array.  For the end of the array label, it is worthwhile to invent some tricky unused name, for which the macro __ARRAY_SPREAD_PRIVATE has already been entered.  Actually, everything!  Now we can put elements in the right section and access them as elements of an array. <br><br>  Let's introduce a macro for this purpose: <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARRAY_SPREAD_ADD(name, item) \ static typeof(name[0]) name ## __element[] \ __attribute__ ((used, \ section(__ARRAY_SPREAD_SECTION(name, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1_body"</span></span></span><span class="hljs-meta">)))) = { item }</span></span></code> </pre><br>  In the same way as with labels, we declare an array and place it into a section.  The difference is the name of the subsection ‚Äú1_body‚Äù and the fact that it is not an empty array, but an array with a single element passed as an argument.  By the way, with the help of a light modification, you can add an arbitrary number of elements to the array, but in order not to load the article, I will not give it here.  An updated version can be found in <a href="https://github.com/embox/embox">our repository</a> . <br><br>  This macro has a small problem: if with its help we add two elements to the array in one file, there will be a problem with the intersection of characters.  Of course, you can use the macro described above and add all the elements in the file at the same time, but, you see, this is not very convenient.  Therefore, we simply use the macro __LINE__ and get unique symbols for the variables. <br><br>  So, we introduce a couple of auxiliary macros. <br>  The macro concatenates two lines: <br><pre> <code class="hljs lisp">#define MACRO_CONCAT(<span class="hljs-name"><span class="hljs-name">m1</span></span>, m2) __MACRO_CONCAT(<span class="hljs-name"><span class="hljs-name">m1</span></span>, m2) #define __MACRO_CONCAT(<span class="hljs-name"><span class="hljs-name">m1</span></span>, m2) m1 ## m2</code> </pre><br>  The macro that adds to the _at_line_ character and the line number: <br><pre> <code class="hljs lisp">#define MACRO_GUARD(<span class="hljs-name"><span class="hljs-name">symbol</span></span>) __MACRO_GUARD(<span class="hljs-name"><span class="hljs-name">symbol</span></span>) #define __MACRO_GUARD(<span class="hljs-name"><span class="hljs-name">symbol</span></span>) MACRO_CONCAT(<span class="hljs-name"><span class="hljs-name">symbol</span></span> ## _at_line_, __LINE__)</code> </pre><br>  And finally, the macro that adds us a unique name for this file, or rather, is not unique, but it is sooooo rare :) <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __ARRAY_SPREAD_GUARD(array_nm) \ MACRO_GUARD(__ARRAY_SPREAD_PRIVATE(array_nm, element))</span></span></code> </pre><br>  Rewrite the macro to add an item: <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARRAY_SPREAD_ADD(name, item) \ static typeof(name[0]) __ARRAY_SPREAD_GUARD(name)[] \ __attribute__ ((used, \ section(__ARRAY_SPREAD_SECTION(name, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1_body"</span></span></span><span class="hljs-meta">)))) = { item }</span></span></code> </pre><br>  To get the size of the array, you need to take the address marker of the last element and subtract from it the marker of the beginning of the array; <br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARRAY_SPREAD_SIZE(array_name) \ ((size_t) (__ARRAY_SPREAD_PRIVATE(array_name, tail) - array_name))</span></span></code> </pre><br>  For beauty, add syntactic sugar in the form of a macro foreach <br><pre> <code class="hljs vbscript">#define array_spread_foreach(element, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) \ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (typeof(element) volatile <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *_ptr = (<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>), \ _end = _ptr + (ARRAY_SPREAD_SIZE(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>)); \ (_ptr &lt; _end) &amp;&amp; (((element) = *_ptr) || <span class="hljs-number"><span class="hljs-number">1</span></span>); ++_ptr)</code> </pre><br><br><h3>  Unit test syntax </h3><br>  Let's return to unit tests.  In our project, the standard syntax for unit tests is the <a href="https://ru.wikipedia.org/wiki/Google_C%252B%252B_Testing_Framework">googletest</a> syntax.  What is important in it: <br><ul><li>  Present test suite ad </li><li>  Present advertisements for individual tests. </li><li>  There are pre- and post-call functions for both individual tests and test suites. </li><li>  There are all sorts of checks to ensure that the test passes. </li></ul><br>  Let's try to formulate the syntax in C, taking into account the variable-length arrays described in the previous section.  A test suite declaration is an array declaration. <br><pre> <code class="hljs cpp">ARRAY_SPREAD_DEF(<span class="hljs-keyword"><span class="hljs-keyword">test_routine_t</span></span>,all_tests); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } ARRAY_SPREAD_ADD(all_tests, test_func_1); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_func_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } ARRAY_SPREAD_ADD(all_tests, test_func_2);</code> </pre><br>  Accordingly, the test call can be written as: <br><pre> <code class="hljs bash">array_spread_foreach(<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>, all_tests) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>()) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"error in test 0x%zu\n"</span></span>, (uintptr_t)<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"OK\n"</span></span>);</code> </pre><br>  Naturally, the example is greatly simplified, but it is already clear that if an error occurs in the test, the address of the function is displayed, which is not very informative.  You can, of course, ponder with the symbol table, since we use a linker in a hard way, but it will be even more pleasant if the syntax of the test declaration is: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">TEST_CASE</span></span>(‚Äú<span class="hljs-selector-tag"><span class="hljs-selector-tag">test1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">description</span></span>‚Äù) { };</code> </pre><br>  It is easier to read a detailed comment than the name of the function.  To support this, we introduce a test description structure.  In addition to the call function, it must contain a description field: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_case_desc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test_routine_t</span></span> routine; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> desc[]; };</code> </pre><br>  Then the call of all tests will look as follows: <br><pre> <code class="hljs bash"> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%zu tests start"</span></span>, ARRAY_SPREAD_SIZE(all_tests)); array_spread_foreach(<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>, all_tests) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-&gt;routine()) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"error in test 0x%s\n"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-&gt;desc); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0; } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"OK\n"</span></span>);</code> </pre><br>  And in order to introduce a separate test, we will use the __LINE__ macro again. <br>  Then the test declared on this line will declare the test function as test _ ## __LINE__, and the whole macro can be written like this: <br><pre> <code class="hljs tex">#define TEST_CASE(desc) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__TEST_CASE_NM("" desc, MACRO_GUARD(__test_case_struct), <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MACRO_GUARD(__test_case)) #define __TEST_CASE_NM(_desc, test_struct, test_func) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>static int test_func(void); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>static struct test_case_desc test_struct = { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.routine = test_func, <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.desc = _desc, <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ARRAY_SPREAD_ADD(all_tests, &amp;test_struct); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>static int test_func(void)</code> </pre><br>  It turns out quite beautiful.  The internal macro is introduced solely to improve the readability of the code. <br><br>  Now we will try to introduce the concept of a test suite - TEST_SUITE. <br><br>  Let's go on a proven path.  For each set of tests, we will declare a variable length array in which the structures with the description of the tests will be stored. <br><br>  Now we will run not a separate test, but a test suite, which, in turn, will trigger individual tests.  Here we are faced with another problem: it is necessary to declare all arrays of compiled tests, since we need to know the length of each array.  You can find the length of an array without its declaration, for example, if you use the end of an array marker, as it does for strings. <br><br><h3>  Variable-length static arrays with terminating element </h3><br>  Let's return to arrays of variable length.  What should be added in order for us to have a version with a terminating element?  Let's do what we have done more than once, and add a termination element to a special subsection that we place after the array elements, but before the end of the array marker - ‚Äú8_term‚Äù. <br>  That is, let's rewrite our previous array declaration macro: <br><pre> <code class="hljs kotlin">#define ARRAY_SPREAD_DEF(element_type, name) \ ARRAY_SPREAD_TERM_DEF(element_type, name, <span class="hljs-comment"><span class="hljs-comment">/* empty */</span></span>) #define ARRAY_SPREAD_TERM_DEF(element_type, name, _term) \ element_type <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name[] __attribute__ ((used, \ <span class="hljs-comment"><span class="hljs-comment">/* Some versions of GCC do not take into an account section \ * attribute if it appears after the definition. */</span></span> \ section(__ARRAY_SPREAD_SECTION(name, <span class="hljs-string"><span class="hljs-string">"0_head"</span></span>)))) = \ { <span class="hljs-comment"><span class="hljs-comment">/* Empty anchor to the array head. */</span></span> }; \ element_type <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __ARRAY_SPREAD_PRIVATE(name,term)[] \ __attribute__ ((used, \ <span class="hljs-comment"><span class="hljs-comment">/* Some versions of GCC do not take into an account section \ * attribute if it appears after the definition. */</span></span> \ section(__ARRAY_SPREAD_SECTION(name, <span class="hljs-string"><span class="hljs-string">"8_term"</span></span>)))) = \ { _term }; \ element_type <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> __ARRAY_SPREAD_PRIVATE(name,tail)[] \ __attribute__ ((used, \ <span class="hljs-comment"><span class="hljs-comment">/* Some versions of GCC do not take into an account section \ * attribute if it appears after the definition. */</span></span> \ section(__ARRAY_SPREAD_SECTION(name, <span class="hljs-string"><span class="hljs-string">"9_tail"</span></span>)))) = \ { <span class="hljs-comment"><span class="hljs-comment">/* Empty anchor at the very end of the array. */</span></span> }</code> </pre><br>  Add a foreach () macro for zero-terminated arrays <br><pre> <code class="hljs vbscript">#define array_spread_nullterm_foreach(element, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>) \ __array_spread_nullterm_foreach_nm(element, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, \ MACRO_GUARD(__ptr)) #define __array_spread_nullterm_foreach_nm(element, <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>, _ptr) \ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (typeof(element) volatile <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *_ptr = (<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>); \ ((element) = *_ptr); ++_ptr)</code> </pre><br><h3>  Test suites </h3><br>  Now you can go back to the test sets. <br>  They are also very simple.  Let's enter the structure for the test suite: <br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_suite_desc</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_case_desc</span></span></span></span> *volatile <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *test_cases; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> desc[]; };</code> </pre><br>  As a matter of fact, we need only a text descriptor and a pointer to an array of tests. <br>  Let's enter a macro to declare a test suite. <br><pre> <code class="hljs rust">#define TEST_SUITE(_desc) \ ARRAY_SPREAD_TERM_DEF(<span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_case_desc</span></span></span></span> *, \ __TEST_CASES_ARRAY, NULL <span class="hljs-comment"><span class="hljs-comment">/* */</span></span>); \ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_suite_desc</span></span></span></span> test_suite = { \ .test_cases = __TEST_CASES_ARRAY, \ .desc = <span class="hljs-string"><span class="hljs-string">""</span></span>_desc, \ }; \ ARRAY_SPREAD_ADD(all_tests, &amp;test_suite)</code> </pre><br>  It defines a variable length array for individual tests.  There was a problem with this array - the name of the array should be unique, because it cannot be static, even though we were thinking about adding the possibility of a static array declaration.  In our project we use <a href="http://habrahabr.ru/company/embox/blog/144935/">our own build system</a> , and for each module we generate a unique identifier with its full name.  The problem could not be solved right away, and therefore, to declare a test suite, you must specify the unique name of its test array. <br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __TEST_CASES_ARRAY test_case_array_1 TEST_SUITE(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"first test suite"</span></span></span><span class="hljs-meta">);</span></span></code> </pre><br>  As for the rest, the typing ad looks decent. <br>  In addition to an array, the structure of this set is determined and initialized, and a pointer to this structure is placed in the global array of test sets. <br><br>  Let's slightly change the mask for the announcement of the test case: <br><pre> <code class="hljs tex">#define TEST_CASE(desc) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>__TEST_CASE_NM("" desc, MACRO_GUARD(__test_case_struct), <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>MACRO_GUARD(__test_case)) #define __TEST_CASE_NM(_desc, test_struct, test_func) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>static int test_func(void); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>static struct test_case_desc test_struct = { <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.routine = test_func, <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>.desc = _desc, <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ARRAY_SPREAD_ADD(__TEST_CASES_ARRAY, &amp;test_struct); <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>static int test_func(void)</code> </pre><br>  In fact, only the array in which our test is entered changes. <br><br>  It remains to replace the test call: <br><pre> <code class="hljs perl"> array_spread_foreach(test_suite, all_tests) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%s"</span></span>, test_suite-&gt;desc); array_spread_nullterm_foreach(test_case, test_suite-&gt;test_cases) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (test_case-&gt;routine()) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"error in test 0x%s\n"</span></span>, test_case-&gt;desc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"."</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"OK\n"</span></span>); }</code> </pre><br><br>  We have a lot of unexamined aspects left, but I want to complete the article at this point, since the main idea has been considered.  If readers will be interested continue in the next article. <br>  In conclusion, I will give a screenshot of what happened: <br><img src="https://habrastorage.org/files/735/49a/4b2/73549a4b2c554171bcc336e54ca12cba.png"><br>  The code given in the article lies in our <a href="https://github.com/embox/emtest">separate repository</a> .  We thought that the decision turned out to be interesting and it can be in demand as a separate framework not only in <a href="http://embox.github.io/">our project</a> , and therefore we began to endure it.  Well, at the same time wrote an article, I hope interesting. <br><br>  PS The author of the original idea is <a href="http://habrahabr.ru/users/abusalimov/" class="user_link">abusalimov</a> . </div><p>Source: <a href="https://habr.com/ru/post/265461/">https://habr.com/ru/post/265461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265451/index.html">CSS3 hover effects. Step by step tutorial</a></li>
<li><a href="../265453/index.html">We write voice IVR menu in TCL language using Cisco IVR API</a></li>
<li><a href="../265455/index.html">Reversible Cyrillic transliteration</a></li>
<li><a href="../265457/index.html">Protection of negotiations. Anti-bugs and field indicators</a></li>
<li><a href="../265459/index.html">Depla: Nginx, Puma and Mina</a></li>
<li><a href="../265463/index.html">"I came to eat, and stayed to study at the Technopark." Student stories from our educational projects</a></li>
<li><a href="../265465/index.html">Big Data - the first experience of ED IB</a></li>
<li><a href="../265469/index.html">Publication of iFrame / HTML5 games on VKontakte. The basics</a></li>
<li><a href="../265471/index.html">Intel Parallel Studio XE 2016 - more free products</a></li>
<li><a href="../265473/index.html">A bit about the underground data center Netflix</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>