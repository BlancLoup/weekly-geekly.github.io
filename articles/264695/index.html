<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Talking to FPConf speakers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 The FPConf conference is already this Saturday, we are already 160 and it is not too late to drop into the last car. Registration is here . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Talking to FPConf speakers</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  The <a href="http://fpconf.ru/">FPConf</a> conference <a href="http://fpconf.ru/">is</a> already this Saturday, we are already 160 and it is not too late to drop into the last car.  Registration is <a href="http://fpconf.ru/">here</a> . <br><br>  And the day before we decided to ask our speakers one rather ambiguous question.  We publish the answers, your options are welcome in the comments! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/b9b/b0f/0ff/b9bb0f0ffe8c47b637a470dd809b267e.jpg" alt="image"><br><br>  <i>In object-oriented languages, there is a well-known list of design patterns from Gang of Four.</i>  <i>There is no such list in the functional languages.</i>  <i>From your point of view, why so?</i> <i><br></i>  <i>Such patterns are not needed when programming in functional languages ‚Äã‚Äãor just their canonical list has not yet developed?</i> <br><br><a name="habracut"></a><br><br>  <b>Anton Kholomiev, Haskell</b> <br>  For Haskell, there is such a list, but it is called differently and there are other patterns, <br>  in the style of OP.  <a href="https://wiki.haskell.org/Typeclassopedia">Here</a> <br><br><br>  <b>Sergey Lobin, Scala</b> <br>  In my opinion, patterns are the principles of FP, which can be used as cubes, collecting beautiful programs :) <br><br><br>  <b>Sergey Tikhon, F #</b> <br>  In the issue of patterns for a programming language, I agree with Peter Norvig who said that "Design patterns."  Most of the problems that solved the classical patterns from Gang of Four have already been solved in functional languages ‚Äã‚Äãin one form or another.  ‚ÄúFunctional patterns \ abstractions‚Äù are and will appear (for example, Monads), as a set of common approaches for managing the complexity of developed applications.  Perhaps over time, there will be one general list that we all recognize as canonical, but this will be caused by a noticeable increase in the complexity of the tasks that will allow solving functional languages. <br><br><br>  <b>Alexander Granin, Haskell</b> <br>  The question is very correlated with the topic of my report.  And I raised it several times at our meetings LambdaNsk. <br><br>  Design patterns in OOP are artificial constructs that solve a particular technical problem that cannot be solved in a natural way ‚Äî by the syntax of the language, top-level idioms or concepts.  A significant part of the patterns (if not all) operate on OOP concepts such as "inheritance", "polymorphism", "abstraction", while neither these concepts, nor any other specific syntactic construction of OOP language, solve the problem directly.  At the same time, in functional languages, these patterns either degenerate (Visitor), or simply become unnecessary (Command) - in view of the fact that there are concepts in the FI itself that can directly solve the problem: FVP, lambda, pattern matching, first-class functions, immunity, composition, laziness and much more.  For example, Visitor is easily replaced by pattern matching and FVP, while Command is simply replaced by first-class features.  In OOP, patterns are complex constructs that are not inherent in the OOP language itself.  That is, to solve a problem, OOP-language and its elements are not enough: you need to make one or another mechanism out of these elements.  And many similar mechanisms in the end and are summarized in OOP-patterns.  On the contrary, in order to solve a problem in FP, only language constructs are sufficient, and it is often enough just to compose the type of function.  If there is a type, the implementation of the function will be simple. <br><br>  At the same time, the FP has its own ‚Äúpatterns‚Äù, although I prefer to call them ‚Äúidioms‚Äù.  You heard about them: different monads, comonads, functors, arrows, applicative functors, combinators, transducers.  In addition, in the OP there are such patterns as FRP, STM, lenses.  What, in my opinion, is the difference between OOP patterns and FP idioms? <br><br>  The OOP pattern is a solution to the problem ‚Äúfrom the outside‚Äù with an imperative approach.  The OOP pattern addresses entities and their mutable interaction.  The OOP pattern describes how the system works.  There are OOP patterns that are needed to only realize the functional idiom missing in the language (Visitor is a comparison with a sample and FIB). <br><br>  OP-idiom is a solution to the problem ‚Äúfrom the inside‚Äù by a functional-declarative approach.  OP-idiom addresses to properties and their un-mutable transformation;  The OP-idiom describes ‚Äúwhat is‚Äù the essence, what are its inseparable properties. <br><br>  What properties are we talking about?  For example, if you have a functional list, then it is initially, even without your knowledge of it, a monad.  And if you have the game "Life", then its cellular field is already a komonad.  From this it follows, by the way, that the FP programmer does not simply construct a solution to the problem, he searches for hidden characteristics and properties in the subject area, and already proceeding from this knowledge, he solves the problem by applying this or that FP idiom.  Such code ‚Äî built on properties and transformation ‚Äî will be idiomatic functional code. <br><br>  But the topic of design of large applications in functional languages, of course, is still poorly understood - in view of the low prevalence of these very languages.  Accordingly, there is little literature.  I am going to raise this important issue in my report. <br><br>  Related Links <br>  * <a href="http://stackoverflow.com/questions/327955/does-functional-programming-replace-gof-design-patterns">Does OP replace GOF patterns?</a> <br>  * <a href="http://blog.ezyang.com/2010/05/design-patterns-in-haskel/">Design Patterns in Haskell</a> <br>  * <a href="https://skillsmatter.com/skillscasts/6120-functional-programming-design-patterns-with-scott-wlaschin">Design patterns in OP</a> <br>  * <a href="http://www.slideshare.net/alexandrgranin/ss-46227384">Idiomatic functional code (presentation from my performance on LambdaNsk)</a> <br>  * Idioms in Haskell and OP: <a href="https://wiki.haskell.org/Category:Idioms">1</a> and <a href="https://wiki.haskell.org/Typeclassopedia">2</a> <br><br>  <b>Denis Redozubov, Haskell</b> <br>  +1 to the previous answer. <br><br><br>  <b>Nikolay Ryzhikov, Clojure</b> <br>  Not all GOF patterns are the same.  Some are too low-level - for example, Iterator.  The FP has its own (more expressive) arsenal for similar tasks: map, reduce / fold, walker.  As well as a number of highly functional low-level patterns: monads, zippers, transducers. <br><br>  However, a significant part of the templates are high-level constructions that are useful and understandable to experienced programmers, allowing you to structure and describe the program in the large.  And they may well be used in the OP, sometimes with a slightly different implementation from the original. <br><br>  For example, Chain of Responsibility can be expressed through HOF as the decoration of functions (use js for accessibility :): <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">next_handler</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp){ <span class="hljs-comment"><span class="hljs-comment">// some logic next_handler(args); //pipe to next handler } else { return some_responce; //intercept } } } var stack = handler1(handler2(handler3)) // build chain (stack) stack(args); // process chain</span></span></code> </pre> <br><br>  Therefore, I think you just need to re-release Design Patterns for AF.  Perhaps you are the one who will write this book :) <br><br><br>  <b>Nikita Prokopov, Clojure</b> <br>  There are patterns both there and there.  OOP language tells you: there are objects, do what you want.  Freedom, but unconstructive.  The pattern is ‚Äúif you construct an object according to such a scheme, it can be used for such and such purposes‚Äù.  Concretization <br><br>  Therefore, I would not go so far as to attribute some special properties to the FP languages ‚Äã‚Äãthat invalidate the patterns.  A pattern is simply a classifier of frequently encountered "code forms."  Specific OOP patterns from GoF are not needed because there are no objects.  But FP patterns are needed.  Somehow, after all, the OP code is written, and it is not that each person is unique. <br><br>  Well, there is no well-known list, because no one has compiled it yet.  Informally, it is, just transmitted implicitly.  Plus, it will most likely be very different for different languages, at least for typed FP and for untyped. <br><br>  I would suggest that for typed need for patterns is higher, because  they need recipes for how to "wrap" types in order to get around a particular problem.  Such recipes very quickly become non-trivial, and it is more and more difficult to reach them with your mind.  So from an educational point of view, ‚Äúpatterns of typed FP‚Äù are very much in demand. <br><br><br>  <b>Mikhail Limansky, Scala</b> <br>  Functionals do not need patterns, because we are creative people, not artisans. <br><br>  But seriously, in OOP, patterns are generated by the complexity of the object model itself.  All you have is encapsulation, inheritance and polymorphism, but there is no sense in the language of how to use it.  Those.  knowledge of the language and the basic principles of the PLO is not enough to avoid shooting off one's leg, and not to turn the code into an insane mess.  This is what patterns are needed for (well, when patterns did not help, treatises on refactoring come to the rescue). <br><br>  In the OP, on the contrary, we go from behavior - from type classes that are already part of the language.  It turns out a certain Unix way for programming - a small class performs one small task and does it well. <br><br><br>  <b>Arseny Zhizhelev, Scala</b> <br>  The gang of four "staked out" the list of patterns that existed at the time, and seemed universal and widely applicable.  Over time, new patterns appeared, and flaws in the old ones (for example, dependency injection replaced the factory). <br><br>  As already mentioned above, functional languages ‚Äã‚Äãalso have sets of good practices, only none of the sets have yet become well-known and popular.  This opens up the possibility of including in such a list new approaches and libraries implementing them.  One of the interesting ways to use functional languages ‚Äã‚Äãwill be discussed in my talk about the SynapseGrid library, which implements the Functional Reactive Programming approach on Scala. <br><br>  <b>UPD.</b>  <b>In the morning we received a response from Edward and decided to publish it in a <a href="http://habrahabr.ru/company/railsclub/blog/264737/">separate post.</a></b> <br><br>  Updates from the rest of the participants and speakers of the conference - in the comments.  See you at <a href="http://fpconf.ru/">FPConf!</a> </div><p>Source: <a href="https://habr.com/ru/post/264695/">https://habr.com/ru/post/264695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264683/index.html">Manage dependencies in iOS applications correctly: Typhoon Tips & Tricks</a></li>
<li><a href="../264685/index.html">Fast mail server on t2.micro with EC2 running CentOS 7</a></li>
<li><a href="../264687/index.html">How to increase the speed of 1C 100 times by direct access to MSSQL</a></li>
<li><a href="../264691/index.html">Combining offices in 3CX (Part 3. Use Raspberry PI)</a></li>
<li><a href="../264693/index.html">DxGetText - GNU Gettext for Delphi and C ++ Builder</a></li>
<li><a href="../264697/index.html">Using Pester for testing when developing PowerShell scripts</a></li>
<li><a href="../264699/index.html">Yandex added shortcuts for managing search results</a></li>
<li><a href="../264701/index.html">Work with Zip and 7z archives</a></li>
<li><a href="../264705/index.html">Glitches when drawing border-radius in Windows 10</a></li>
<li><a href="../264707/index.html">Writing a Telegram bot in Ruby in 10 lines</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>