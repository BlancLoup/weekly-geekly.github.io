<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The whole truth about the RTOS. Article # 17. Event flag groups: introduction and basic services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Groups of event flags have already been mentioned earlier in a previous article (# 5). In Nucleus SE, they look like signals, but are more flexible. T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The whole truth about the RTOS. Article # 17. Event flag groups: introduction and basic services</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/y6/hx/yw/y6hxyww0r_cp5m_lr0uspctzgqk.jpeg"><br><br>  Groups of event flags have already been mentioned earlier in a previous article (# 5).  In Nucleus SE, they look like signals, but are more flexible.  They provide a low-cost and flexible way to transfer simple messages between tasks. <br><a name="habracut"></a><br><br>  Previous articles in the series: <br>  <a href="https://habr.com/post/427439/">Article # 16.</a>  <a href="https://habr.com/post/427439/">Signals</a> <br>  <a href="https://habr.com/post/426477/">Article # 15.</a>  <a href="https://habr.com/post/426477/">Memory sections: services and data structures</a> <br>  <a href="https://habr.com/post/426425/">Article # 14.</a>  <a href="https://habr.com/post/426425/">Memory sections: introduction and basic services</a> <br>  <a href="https://habr.com/post/425353/">Article # 13.</a>  <a href="https://habr.com/post/425353/">Task data structures and unsupported API calls</a> <br>  <a href="https://habr.com/post/424713/">Article # 12.</a>  <a href="https://habr.com/post/424713/">Task Services</a> <br>  <a href="https://habr.com/post/424481/">Article # 11.</a>  <a href="https://habr.com/post/424481/">Tasks: configuration and introduction to the API</a> <br>  <a href="https://habr.com/post/423967/">Article # 10.</a>  <a href="https://habr.com/post/423967/">Scheduler: additional features and context preservation</a> <br>  <a href="https://habr.com/post/422615/">Article # 9.</a>  <a href="https://habr.com/post/422615/">Scheduler: implementation</a> <br>  <a href="https://habr.com/post/422617/">Article # 8.</a>  <a href="https://habr.com/post/422617/">Nucleus SE: Inside and Deployment</a> <br>  <a href="https://habr.com/post/418601/">Article # 7.</a>  <a href="https://habr.com/post/418601/">Nucleus SE: introduction</a> <br>  <a href="https://habr.com/post/418677/">Article # 6.</a>  <a href="https://habr.com/post/418677/">Other RTOS services</a> <br>  <a href="https://habr.com/post/415429/">Article # 5.</a>  <a href="https://habr.com/post/415429/">Interaction between tasks and synchronization</a> <br>  <a href="https://habr.com/post/415427/">Article # 4.</a>  <a href="https://habr.com/post/415427/">Tasks, context switching and interrupts</a> <br>  <a href="https://habr.com/post/415329/">Article # 3.</a>  <a href="https://habr.com/post/415329/">Tasks and planning</a> <br>  <a href="https://habr.com/post/414093/">Article # 2.</a>  <a href="https://habr.com/post/414093/">RTOS: Structure and Real Time</a> <a href="https://habr.com/post/414093/"><br></a>  <a href="https://habr.com/post/414093/">Article # 1.</a>  <a href="https://habr.com/post/414093/">RTOS: introduction.</a> <a href="https://habr.com/post/414093/"><br></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Using event flags </h2><br>  In Nucleus SE, event flags are defined at the build stage.  The maximum number of event flag groups in the application is 16. If the event flag groups are not defined, the code related to the data structures and service calls of the event flag groups will not be included in the application. <br><br>  A group of event flags is a set of eight bit flags, access to which is regulated in such a way that several tasks can be safely used by one flag.  One task can set or clear any combination of event flags.  Another task can read a group of flags at any time, and can also wait for a specific sequence of flags (by polling or with suspension). <br><br><h2>  Setting groups of event flags </h2><br><h3>  Number of event flag groups </h3><br>  As with most Nucleus SE objects, the setting of groups of event flags is specified by the <b>#define</b> directives in <b>nuse_config.h</b> .  The main parameter is <b>NUSE_EVENT_GROUP_NUMBER</b> , which determines how many groups of event flags will be defined in the application.  By default, this parameter is set to 0 (that is, groups of event flags are not used) and can have any value up to 16. An incorrect value will result in a compilation error, which will be generated by checking in <b>nuse_config_check.h</b> (it is enabled by <b>nuse_config.c</b> , which means it is compiled together with this module), as a result, the <b>#error</b> directive will work.  The choice of a non-zero value serves as the main activator of the event flag groups.  This parameter is used when defining data structures and their size depends on its value (for more details, see the following articles).  In addition, a non-zero value activates the API settings. <br><br><h3>  Activate API calls </h3><br>  Each API function (service call) in the Nucleus SE is activated by the <b>#define</b> directive in <b>nuse_config.h</b> .  For groups of event flags, these include: <br> <code>NUSE_EVENT_GROUP_SET <br> NUSE_EVENT_GROUP_RETRIEVE <br> NUSE_EVENT_GROUP_INFORMATION <br> NUSE_EVENT_GROUP_COUNT <br></code> <br>  By default, they are assigned the value <b>FALSE</b> , thus disabling each service call and blocking the inclusion of the code implementing them.  To configure groups of event flags, select the necessary API calls and set the corresponding directives to <b>TRUE</b> . <br><br>  The following is an excerpt from the default nuse_config.h file. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_NUMBER 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of event groups in the system - 0-16 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_SET FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_RETRIEVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_INFORMATION FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_COUNT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  An activated API function if there are no event flag groups in the application will result in a compilation error (except <b>NUSE_Event_Group_Count ()</b> , which is always allowed).  If your code uses an API call that has not been activated, a build error will occur because the implementation code was not included in the application. <br><br><h2>  Service Calls for Event Flags </h2><br>  Nucleus RTOS supports seven service calls that provide the following functionality: <br><br><ul><li>  Setting event flags.  The Nucleus SE is implemented in the <b>NUSE_Event_Group_Set ()</b> function. </li><li>  Read event flags.  In Nucleus SE, <b>NUSE_Event_Group_Retrieve () is</b> implemented. </li><li>  Providing information on a specific group of event flags.  In Nucleus SE is implemented in <b>NUSE_Event_Group_Information ()</b> . </li><li>  Return the number of currently configured event flag groups in the application.  In Nucleus SE is implemented in <b>NUSE_Event_Group_Count ()</b> . </li><li>  Adding a new group of event flags to the application.  Nucleus SE is not implemented. </li><li>  Remove a group of event flags from an application.  Nucleus SE is not implemented. </li><li>  Returning pointers to all groups of event flags in the application.  Nucleus SE is not implemented. </li></ul><br>  The implementation of each of these service calls is detailed below. <br><br>  It is worth noting that there is no reset function in either the Nucleus RTOS or the Nucleus SE.  This is intentional.  The reset function implies the predominance of a special state of flags.  For groups of event flags, the only ‚Äúspecial‚Äù state is the zeroing of all flags, which can be performed using <b>NUSE_Event_Group_Set ()</b> . <br><br><h2>  Service calls for setting and reading event flag groups </h2><br>  The fundamental operations that can be performed on a group of event flags are setting the value of one or more flags, as well as reading the current values ‚Äã‚Äãof the flags.  Nucleus RTOS and Nucleus SE provide four basic API calls for these operations. <br><br>  Since event flags are bits, they are best rendered as binary numbers.  Since standard C does not historically support the representation of binary constants (octal and hexadecimal only), Nucleus SE has a useful header file <b>nuse_binary.h</b> , which contains <b>#define</b> characters of the form <b>b01010101</b> for all 256 8-bit values. <br><br><h3>  Setting event flags </h3><br>  The Nucleus RTOS API service call for setting flags is very flexible and allows you to set and clear flag values ‚Äã‚Äãusing <b>AND</b> and <b>OR</b> operations.  Nucleus SE provides similar functionality, but task suspension is optional. <br><br>  <b><i>Call to set flags in the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br><br>  <b>STATUS NU_Set_Events (NU_EVENT_GROUP * group, UNSIGNED event_flags, OPTION operation);</b> <br><br>  Options: <br><br>  <b>group</b> ‚Äî pointer to the user-provided control unit for the group of event flags; <br>  <b>event_flags</b> - the bitmask value of the group of flags; <br>  <b>operation</b> - the <b>operation to</b> be performed, <b>NU_OR</b> (to set flags) or <b>NU_AND</b> (to clear flags). <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_INVALID_GROUP</b> - incorrect pointer to the group of event flags; <br>  <b>NU_INVALID_OPERATION</b> - the specified operation is different from <b>NU_OR</b> and <b>NU_AND</b> . <br><br>  <b><i>Call to set flags in the Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Event_Group_Set (NUSE_EVENT_GROUP group, U8 event_flags, OPTION operation);</b> <br><br>  Options: <br><br>  <b>group</b> - the index (ID) of the group of events whose flags are set / cleared; <br>  <b>event_flags</b> - bit maxi flag group value; <br>  <b>operation</b> - the <b>operation to</b> be performed, <b>NUSE_OR</b> (for setting flags) or <b>NUSE_AND</b> (for cleaning flags). <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_INVALID_GROUP</b> - incorrect index of the group of event flags; <br>  <b>NUSE_INVALID_OPERATION</b> - the specified operation is different from <b>NUSE_OR</b> and <b>NUSE_AND</b> . <br><br>  <b><i>Implementing the setting of event flags in the Nucleus SE</i></b> <br>  The initial code of the <b>NUSE_Event_Group_Set ()</b> API function is common (after checking parameters), regardless of whether support for blocking calls (task suspension) is activated or not.  The logic is pretty simple: <br><br><pre> <code class="hljs cs">NUSE_CS_Enter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { NUSE_Event_Group_Data[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] |= event_flags; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* NUSE_AND */</span></span> { NUSE_Event_Group_Data[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] &amp;= event_flags; }</code> </pre> <br>  The <b>event_flags bitmask is</b> superimposed (using an <b>AND</b> or <b>OR</b> operation) on the value of the selected group of event flags. <br><br>  The remaining code is enabled only when the task lock is activated: <br><br><pre> <code class="hljs mel">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 index; <span class="hljs-comment"><span class="hljs-comment">/* check whether any tasks are blocked */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* on this event group */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index=<span class="hljs-number"><span class="hljs-number">0</span></span>; index&lt;NUSE_TASK_NUMBER; index++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[index]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Task_Status[index] = NUSE_READY; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]--; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif #endif NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br>  If any tasks are suspended (for reading) from this group of flags, they are resumed.  When they are given the opportunity to continue execution (it depends on the scheduler), they can determine whether the conditions for their resumption are satisfied or not (see reading the event flags). <br><br><h3>  Reading event flags </h3><br>  Nucleus RTOS API read calls are very flexible and allow you to suspend tasks indefinitely or with a specific timeout if the operation cannot be performed immediately (for example, if you try to read a certain sequence of event flags that do not represent the current state).  Nucleus SE provides the same functions, only task suspension is optional, and timeout is not implemented. <br><br>  <b><i>Call to read flags in the Nucleus RTOS</i></b> <br>  Service Call Prototype: <br><br>  <b>STATUS NU_Retrieve_Events (NU_EVENT_GROUP * group, UNSIGNED requested_events, OPTION operation, UNSIGNED * retrieved_events, UNSIGNED suspend);</b> <br><br>  Options: <br><br>  <b>group</b> ‚Äî pointer to the user-provided control unit for the group of event flags; <br>  <b>requested_events</b> - bitmask defining readable flags; <br>  <b>operation</b> - four <b>operations</b> are available: <b>NU_AND</b> , <b>NU_AND_CONSUME</b> , <b>NU_OR</b> and <b>NU_OR_CONSUME</b> .  The <b>NU_AND</b> and <b>NU_AND_CONSUME operations</b> indicate that all requested flags are required.  The <b>NU_OR</b> and <b>NU_OR_CONSUME operations</b> indicate that one or more of the requested flags are sufficient.  The <b>CONSUME</b> parameter automatically clears existing flags after a successful request; <br>  <b>retrieved_events</b> - pointer to the repository for the values ‚Äã‚Äãof readable event flags; <br>  <b>suspend</b> - specification for suspending tasks;  can be <b>NU_NO_SUSPEND</b> or <b>NU_SUSPEND</b> , or the timeout value in system timer <b>ticks</b> (from 1 to 4,294,967,293). <br><br>  Return value: <br><br>  <b>NU_SUCCESS</b> - the call was successfully completed; <br>  <b>NU_NOT_PRESENT</b> - the specified operation did not return an event (not a single event in the case of NU_OR and not all events in the case of NU_AND); <br>  <b>NU_INVALID_GROUP</b> - incorrect pointer to the group of event flags; <br>  <b>NU_INVALID_OPERATION</b> - the specified operation was incorrect; <br>  <b>NU_INVALID_POINTER</b> ‚Äî null pointer to the event flags storage (NULL); <br>  <b>NU_INVALID_SUSPEND</b> - an attempt to suspend a non-task-related stream; <br>  <b>NU_TIMEOUT</b> - the required combination of event flags was not set even after the specified timeout; <br>  <b>NU_GROUP_DELETED</b> - the group of event flags was deleted, while the task was suspended. <br><br>  <b><i>A call to read flags in the Nucleus SE</i></b> <br>  This API call supports the core Nucleus RTOS API. <br><br>  Service Call Prototype: <br><br>  <b>STATUS NUSE_Event_Group_Retrieve (NUSE_EVENT_GROUP group, U8 requested_events, OPTION operation, U8 * retrieved_events, U8 suspend);</b> <br><br>  Options: <br><br>  <b>group</b> - index of the readout group of event flags; <br>  <b>requested_events</b> - bitmask defining readable flags; <br>  <b>operation</b> - specification indicating the number of flags required: <b>NUSE OR</b> (some flags) or <b>NUSE AND</b> (all flags); <br>  <b>retrieved_events</b> - pointer to the repository for the actual values ‚Äã‚Äãof the read event flags (for the <b>NUSE_AND</b> operation <b>,</b> this will be the same as that passed in the <b>requested_events</b> parameter); <br>  <b>suspend</b> - specification for pausing the task, can be <b>NUSE_NO_SUSPEND</b> or <b>NUSE_SUSPEND</b> . <br><br>  Return value: <br><br>  <b>NUSE_SUCCESS</b> - the call was successfully completed; <br>  <b>NUSE_NOT_PRESENT</b> - the specified operation did not return an event (not a single event in the case of <b>NUSE_OR</b> and not all events in the case of <b>NUSE_AND</b> ); <br>  <b>NUSE_INVALID_GROUP</b> - incorrect index of the group of event flags; <br>  <b>NUSE_INVALID_OPERATION</b> - the specified operation is different from <b>NUSE_OR</b> or <b>NUSE_AND</b> ; <br>  <b>NUSE_INVALID_POINTER</b> - null pointer to the storage of read event flags ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - an attempt to pause from a <b>thread that</b> is not associated with a task or when support for blocking API calls is disabled. <br><br>  <b><i>Implementing the reading of event flags in the Nucleus SE</i></b> <br>  The code variant of the <b>NUSE_Event_Group_Retrieve ()</b> API function (after checking the parameters) is selected during conditional compilation depending on whether support for call blocking (suspension) of API calls is activated or not.  Consider these two options separately. <br><br>  If the lock is disabled, the full code for this API call will look like this: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">temp_events</span></span> = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (operation == NUSE_OR) { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> /* operation == NUSE_AND */ { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events == requested_events) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } }</code> </pre><br>  The required event flags are selected from the specified group of event flags.  The value is compared with the required events, taking into account the <b>AND / OR</b> operation, as well as the return result and the immediate values ‚Äã‚Äãof the requested flags. <br><br>  If task lock is activated, the code becomes more complex: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { temp_events = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* operation == NUSE_AND */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events == requested_events) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value == NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND) <span class="hljs-comment"><span class="hljs-comment">/* block task */</span></span> { NUSE_Event_Group_Blocking_Count[group]++; NUSE_Suspend_Task(NUSE_Task_Active, (group &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | NUSE_EVENT_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value != NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND);</code> </pre><br>  The code is placed in a <b>do ... while loop</b> , which works while the <b>suspend</b> parameter is <b>NUSE_SUSPEND</b> . <br><br>  The requested event flags are read the same way as when calling without blocking.  If the read is not successful and the <b>suspend</b> parameter is <b>NUSE_NO_SUSPEND</b> , the API call is assigned the value <b>NUSE_NOT_PRESENT</b> .  If the <b>suspend</b> parameter was set to <b>NUSE_SUSPEND</b> , the task is suspended.  On return (when the task is resumed), if the return value is <b>NUSE_SUCCESS</b> , indicating that the task has been resumed because the event flags in this group have been set or cleared, the cycle starts from the beginning, the flags are read and checked.  Since there is no API function for resetting groups of event flags, this is the only reason for resuming the task, but the <b>NUSE_Task_Blocking_Return []</b> checkout process was left on the system for lock control compatibility with other types of objects. <br><br>  The next article will describe additional API calls related to groups of event flags, as well as their data structures. <br><br>  <b>About the author:</b> Colin Walls has been working in the electronics industry for more than thirty years, spending a significant amount of time on embedded software.  He is now an embedded software engineer in Mentor Embedded (a division of Mentor Graphics).  Colin Walls often speaks at conferences and seminars, author of numerous technical articles and two books on embedded software.  Lives in the UK.  <a href="http://blogs.mentor.com/colinwalls">Colin's</a> professional <a href="http://blogs.mentor.com/colinwalls">blog</a> , e-mail: colin_walls@mentor.com. </div><p>Source: <a href="https://habr.com/ru/post/428131/">https://habr.com/ru/post/428131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428121/index.html">Stan Drapkin. High-level cryptography hooks in .NET</a></li>
<li><a href="../428123/index.html">Security Week 41: Good News</a></li>
<li><a href="../428125/index.html">Who are the product analysts and why are they needed in the team?</a></li>
<li><a href="../428127/index.html">Nginx cache: all new - well forgotten old</a></li>
<li><a href="../428129/index.html">Simple fuzzy logic blinded "from what it was" for a gas turbine engine</a></li>
<li><a href="../428133/index.html">Hasura. High-Performance GraphQL to SQL Server Architecture</a></li>
<li><a href="../428135/index.html">How to configure or disable lint in the built-in code editor</a></li>
<li><a href="../428137/index.html">Olympiad, idea competition, lectures on IT project management and film screenings: 10 upcoming events at ITMO University</a></li>
<li><a href="../428141/index.html">Backend for the frontend, or How in Yandex.Market create an API without crutches</a></li>
<li><a href="../428143/index.html">Approach to RBAC implementation in ReactJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>