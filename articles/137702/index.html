<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Translation of the article ‚ÄúPimp my Pimpl‚Äù, part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, translated by the respected skb7 , the Pimpl idiom (pointer to implementation, pointer to implementation), its purpo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Translation of the article ‚ÄúPimp my Pimpl‚Äù, part 2</h1><div class="post__text post__text-html js-mediator-article">  In the first part of the article, translated by the respected <a href="https://habrahabr.ru/users/skb7/" class="user_link">skb7</a> , the <a href="https://habrahabr.ru/users/skb7/" class="user_link">Pimpl</a> idiom (pointer to implementation, pointer to implementation), its purpose and advantages were considered.  In the second part, problems arising from the use of this idiom will be discussed, and some solutions will be proposed. <br><a name="habracut"></a><br><h4>  Links to the original </h4><br>  This is a translation of the second part of an article published on the <a href="http://www.heise.de/developer/">Heise Developer</a> website.  Translation of the first part can be found <a href="http://habrahabr.ru/blogs/cpp/118010/">here</a> .  The originals of both parts (in German) are <a href="http://www.heise.de/developer/artikel/C-Vor-und-Nachteile-des-d-Zeiger-Idioms-Teil-1-1097781.html">here</a> and <a href="http://www.heise.de/developer/artikel/C-Vor-und-Nachteile-des-d-Zeiger-Idioms-Teil-2-1136104.html">here</a> . <br><br>  The translation was made from an <a href="http://marcmutz.wordpress.com/translated-articles/pimp-my-pimpl-%25E2%2580%2594-reloaded/">English translation</a> . <br><br><h4>  annotation </h4><br>  Much has been written about this funny-sounding idiom, also known as d-pointer, compiler firewall or Cheshire Cat.  The first article in Heise Developer, which presented the classic implementation of the Pimpl idiom and its advantages, is followed by this, the second and final, article about solving some problems that inevitably arise when using the Pimpl idiom. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Part 2 </h4><br><h5>  Violation of const-correctness </h5><br>  The first nuance, which is far from obvious, is related to the interpretation of the constantness of the object fields.  When using the Pimpl idiom, methods gain access to the fields of the implementation object via the <code>d</code> pointer: <br><pre> <code class="cpp hljs">SomeThing &amp; Class::someThing() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d-&gt;someThing; }</code> </pre> <br>  Having carefully considered this example, you can see that this code bypasses the protection mechanism for constant objects in C ++: since the method is declared as <code>const</code> , the <code>this</code> pointer inside the <code>someThing()</code> method is of type <code>const Class *</code> , and the pointer <code>d</code> , respectively, of type <code>Class::Private * const</code> .  This, however, is not enough to prohibit modifying access to the fields class <code>Class::Private</code> , because <code>d</code> is constant, but <code>*d</code> is not. <br><br>  Remember: in C ++, the position of the <code>const</code> modifier is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * pci; <span class="hljs-comment"><span class="hljs-comment">//    int int * const cpi; //    int const int * const cpci; //     int *pci = 1; // : *pci  *cpi = 1; // : *cpi   *cpci = 1; // : *cpci  int i; pci = &amp;i; //  cpi = &amp;i; // : cpi  cpci = &amp;i; // : cpci </span></span></code> </pre> <br>  Thus, using the Pimpl idiom, all methods (and those that are declared as <code>const</code> ) can modify the fields of the implementation object.  If we didn‚Äôt use Pimpl, the compiler would manage to catch such errors. <br><br>  This flaw in the type system is usually undesirable and must therefore be eliminated.  To do this, you can use two methods: a wrapper class <code>deep_const_ptr</code> or a pair of <code>d_func()</code> methods.  The first method is to implement a ‚Äúsmart‚Äù pointer that imposes constancy on the selected pointer.  The definition of such a class is as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deep_const_ptr</span></span></span><span class="hljs-class"> {</span></span> T * p; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deep_const_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T * t )</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( t )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *p; } T &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *p; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } T * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } };</code> </pre> <br>  Using the trick of overloading constant and regular versions of the <code>operator*()</code> and <code>operator-&gt;()</code> methods, it is possible to impose the constant <code>d</code> object <code>*d</code> .  Replacing <code>Private *d</code> with <code>deep_const_ptr&lt;Private&gt; d</code> completely eliminates the problem in question.  But this solution may be redundant: in this situation, the trick with overloading dereference operators can be applied directly to the <code>Class</code> class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... private: const Private * d_func() const { return _d; } Private * d_func() { return _d; } private: Private * _d; };</span></span></code> </pre> <br>  Now, instead of using <code>_d</code> in method implementations, you should call <code>d_func()</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Class::f() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Private * d = f_func(); <span class="hljs-comment"><span class="hljs-comment">//  'd' ... }</span></span></code> </pre> <br>  Of course, nothing forbids direct access to <code>_d</code> in methods, which will not be the case when using the smart pointer <code>deep_const_ptr</code> .  Therefore, the method of overloading Class methods requires more discipline from the developer.  In addition, the implementation of the <code>deep_const_ptr</code> class can be modified to automatically delete the created <code>Private</code> object when a <code>Class</code> object is destroyed.  In turn, overloading class methods is useful in creating a hierarchy of polymorphic classes, which will be demonstrated later. <br><br><h5>  Access to container class </h5><br>  The following obstacle arises when the developer places all <code>private</code> methods of the <code>Class</code> class into the <code>Private</code> class: now these methods cannot call other (non- <code>static</code> ) methods of the <code>Class</code> class, since the <code>Class -&gt; Private</code> association <code>Class -&gt; Private</code> unidirectional: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class">:</span></span>:Private { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Private() : ... {} <span class="hljs-comment"><span class="hljs-comment">// ... void callPublicFunc() { /*???*/Class::publicFunc(); } }; Class::Class() : d( new Private ) {}</span></span></code> </pre> <br>  This problem can be solved by introducing a reciprocal link (the name of the <code>q</code> field is mentioned in the Qt code): <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class">:</span></span>:Private { Class * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> q; <span class="hljs-comment"><span class="hljs-comment">//   public: explicit Private( Class * qq ) : q( qq ), ... {} // ... void callPublicFunc() { q-&gt;publicFunc(); } }; Class::Class() : d( new Private( this ) ) {}</span></span></code> </pre> <br>  When using a backward link, it is important to remember that the initialization <code>d</code> not performed until the <code>Private</code> constructor worked.  The developer should not call the <code>Class</code> methods that refer to the <code>d</code> field in the body of the <code>Private</code> constructor, otherwise he will get undefined behavior. <br><br>  For reinsurance, the developer should initialize the reciprocal link with a null pointer, and set the correct link value only after practicing the <code>Private</code> constructor, in the body of the <code>Class</code> constructor: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Class</span></span></span><span class="hljs-class">:</span></span>:Private { Class * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> q; <span class="hljs-comment"><span class="hljs-comment">// back-link public: explicit Private( /*Class * qq*/ ) : q( 0 ), ... {} // ... }; Class::Class() : d( new Private/*( this )*/ ) { //   : d-&gt;q = this; }</span></span></code> </pre> <br>  Despite the above limitations, usually a substantial part of the class initialization code can be transferred to the <code>Private</code> constructor, which is important for classes with several constructors.  It is also worth mentioning that with the <code>q</code> pointer (inverse reference), the already considered problem of constancy violation arises, which can be solved in the same way. <br><br><h5>  Subtotals </h5><br>  Now that we have been able to restore the functionality lost with the introduction of the private implementation class Pimpl idiom, the rest of the article will be devoted to some ‚Äúmagic‚Äù that will level out the additional memory costs that arise when using the Pimpl idiom. <br><br><h5>  Increase efficiency with reuse of objects </h5><br>  Being a good C ++ developer, the reader is probably skeptical after reading the annotation for an article describing the classic Pimpl idiom.  In particular, additional memory allocations can be extremely disadvantageous, especially with regard to classes that by themselves almost do not require memory. <br><br>  First of all, such considerations should be verified by profiling the code, but this cannot be the reason for refusing to look for a solution to a potential performance problem.  In the first part of the article, the inclusion of class fields in the object of realization was already mentioned, which reduced the number of requests for memory allocation.  Next, we consider another, much more advanced technique: reuse of the implementation pointer. <br><br>  In the hierarchy of polymorphic classes, the problem of additional memory costs is aggravated by the depth of the hierarchy: each hierarchy class has its own hidden implementation, even if it does not carry new fields (for example, inheritance in order to redefine virtual methods without introducing new class members). <br><br>  A developer can deal with the proliferation of the number of <code>d</code> pointers (and the associated memory allocations) by reusing the base-class <code>d</code> pointer in the inheriting classes: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// base.h: class Base { // ... public: Base(); protected: class Private; explicit Base( Private * d ); Private * d_func() { return _d; } const Private * d_func() const { return _d; } private: Private * _d; }; // base.cpp: Base::Base() : _d( new Private ) { // ... } Base::Base( Private * d ) : _d( d ) { // ... }</span></span></code> </pre> <br>  The presence of a public constructor in addition to public constructors allows the inheriting classes to embed their <code>d</code> pointer into the base class.  The code also uses the fixed <code>const</code> correctness using the <code>d_func()</code> methods (which are now also <code>protected</code> ) for (non-modifying) access of the inheriting classes to <code>_d</code> . <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// derived.h: class Derived : public Base { public: Derived(); // ... protected: class Private; Private * d_func(); //    const Private * d_func() const; //  }; // derived.cpp: Derived::Private * Derived::d_func() { return static_cast&lt;Private*&gt;( Base::d_func() ); } const Derived::Private * Derived::d_func() const { return static_cast&lt;const Private*&gt;( Base::d_func() ); } Derived::Derived() : Base( new Private ) {}</span></span></code> </pre> <br>  Now the author of <code>Derived</code> uses the new <code>Base</code> constructor to pass <code>Derided::Private</code> instead of <code>Base::Private</code> to <code>Base::_d</code> (note the use of the same <code>Private</code> name in different contexts).  The author also implements his <code>d_func()</code> methods in terms of <code>Base</code> methods with forced type conversion. <br><br>  In order for the <code>Base</code> constructor to work properly, <code>Base::Private</code> must be an ancestor of <code>Derived::Private</code> : <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">:</span></span>:Private : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base::Private { <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br>  In order to really inherit a class from <code>Base::Private</code> , three conditions must be met. <br><br>  First, the developer must make <code>Base::Private</code> destructor virtual.  Otherwise, there will be undefined behavior when the <code>Base</code> destructor is triggered, which will try to delete the object of the implementation of <code>Derived::Private</code> via a pointer to <code>Base::Private</code> . <br><br>  Secondly, the developer must implement both classes in the same library, since <code>Private</code> usually do not fall into the export table - they are not listed in the <code>declspec(dllexport)</code> on Windows, and are not listed as <code>visibility=hidden</code> in the ELF binaries.  However, export is inevitable if <code>Base</code> and <code>Derived</code> implemented in different libraries.  In exceptional cases, <code>Private</code> classes of the main classes of the library are exported: for example, Nokia developers exported the <code>QObjectPrivate</code> (from QtCore) and <code>QWidgetPrivate</code> (from QtGui) classes, which are very much in demand, since so many classes from other modules inherit from <code>QObject</code> and <code>QWidget</code> .  However, by doing so, developers add dependencies between libraries not only at the interface level, but also at the level of "internals", thus violating the compatibility of libraries of different versions: in general, <code>libQtGui.so.4.5.0</code> will not work if the dynamic the linker connects <code>libQtCore.so.4.6.0</code> to it. <br><br>  And finally, thirdly, the definition of <code>Base::Private</code> can no longer be hidden in the base class implementation file ( <code>base.cpp</code> ), since it is required by the definition of <code>Derived::Private</code> .  So where to place the definition of <code>Base::Private</code> ?  You can simply include it in <code>base.h</code> , but then what's the point of using Pimpl if the internal implementation is still visible from the outside?  The answer to these questions is to create a special, private header file.  For this purpose, Qt and KDE have established a naming scheme for the name of the <code>_p.h</code> (the suffixes <code>_priv</code> , <code>_i</code> and <code>_impl</code> also <code>_impl</code> ).  In addition to the definition of <code>Base::Private</code> , this private file can contain <code>inline</code> implementations of <code>Base</code> methods, for example, a constructor: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Base::Base( Private * d ) : _d( d ) {}</code> </pre> <br>  And in <code>derived_p.h</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Derived::Derived( Private * d ) : Base( d ) {} <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Derived::Private * Derived::d_func() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Private*&gt;( Base::d_func() ); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Derived::Private * Derived::d_func() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Private*&gt;( Base::d_func() ); }</code> </pre> <br>  Strictly speaking, the above code is contrary to the One Definition Rule rule, since <code>d_func()</code> implementations are inline in files that include <code>derived_p.h</code> and are not inline in other files. <br><br>  In practice, this is not a problem, since everyone who will call <code>d_func()</code> will have to include the file <code>derived_p.h</code> .  For reinsurance, you can declare the problematic methods <code>inline</code> in the definition of <code>Derived</code> in the file <code>derived.h</code> - modern compilers allow the presence of the <code>inline</code> in methods without implementation. <br><br>  Often, developers hide the redundant code that arises with this technique under macros.  For example, Qt defines the <code>Q_DECLARE_PRIVATE</code> macro for use in a class definition, and the <code>Q_D</code> macro, which declares a pointer <code>d</code> in the method implementation and initializes it with a call to <code>d_func()</code> . <br><br>  One drawback still remains: if the developer wants to combine the reuse of the pointer to the implementation and the backlink mechanism, there are some difficulties.  In particular, care must be taken not to dereference (even implicitly!) The pointer to <code>Derived</code> , which is passed to the <code>Private</code> constructor until the constructors in the inheritance hierarchy have been worked out. <br><pre> <code class="cpp hljs">Derived::Private( Derived * qq ) : Base( qq ) <span class="hljs-comment"><span class="hljs-comment">// ,   { q-&gt;setFoo( ... ); // ,     }</span></span></code> </pre> <br>  At the time of dereferencing, not only <code>Derived</code> not created, but also - and this is the difference from the non-polyform case described earlier - <code>Base</code> , since its <code>Private</code> field is still created. <br><br>  In this case, just as before, you should initialize the reverse link with a <code>null</code> pointer.  The task of setting the reciprocal reference to the correct value falls on the shoulders of the class lying at the end of the hierarchical chain, that is, the class that injects its <code>Private</code> class into the hierarchy.  In the case of <code>Derived</code> , the code will look like this: <br><pre> <code class="cpp hljs">Derived::Derived() : Base( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Private<span class="hljs-comment"><span class="hljs-comment">/*( this )*/</span></span> ) { d_func()-&gt;_q = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br>  If desired, the developer can put the initialization code, which requires access by the reverse link, to a separate method <code>Private::init()</code> (which means the <code>Private</code> construction in two stages).  This method is called (only) in the class constructor, which itself creates an instance of <code>Derived</code> . <br><pre> <code class="cpp hljs">Derived::Derived( Private * d ) : Base( d ) { <span class="hljs-comment"><span class="hljs-comment">// __  d-&gt;init()! } Derived::Derived() : Base( new Private ) { d_func()-&gt;init( this ); } Derived::Private::init( Derived * qq ) { Base::Private::init( qq ); //  _q //    }</span></span></code> </pre> <br>  In addition, each <code>Private</code> class must have its own back reference to the container class, or define <code>q_func()</code> methods that will be responsible for casting the type for the back reference of the <code>Base::Private</code> class.  The corresponding code is not given here - its writing remains as an exercise for a respected reader.  The solution to this exercise can be found on the <a href="">Heise FTP server</a> in the form of a ‚Äúpumped‚Äù <sup>1</sup> <code>Shape</code> hierarchy. <br><br><h4>  findings </h4><br>  Being a well-known C ++ idiom, Pimpl allows developers to separate the interface and implementation to the extent that C ++ built-in tools cannot achieve.  As a positive side effect, developers gain compilation acceleration, the ability to implement transaction semantics and, through the active use of composition, the overall code acceleration in perspective. <br><br>  Not everything is so smooth when using <code>d</code> pointers: an additional class <code>Private</code> , memory allocations associated with it, violation of <code>const</code> correctness and potential errors in the order of initialization can spoil a lot of blood for the developer.  For all the problems listed in this article, solutions were proposed, which, however, require writing a large amount of code.  Due to the increased complexity, a fully ‚Äúpumped up‚Äù Pimpl (with reuse and backlinks) can only be recommended for a small number of classes or projects. <br><br>  However, projects that are not afraid of possible difficulties will be rewarded with remarkable interface stability, allowing you to overhaul the implementation. <br><br><h4>  Sources </h4><br><ul><li>  John Lakos;  Large-Scale C ++ Software Design;  Addison-Wesley Longman 1996 </li><li>  Herb Sutter;  Exceptional C ++: 47 Engineering Puzzles, Programming Problems, and Solutions;  Addison-Wesley Longman, 2000 </li><li>  Herb Sutter, Andrei Alexandrescu: C ++ Coding Standards: 101 Rules, Guidelines and Best Practices;  Addison-Wesley Longman, 2004 </li><li>  Marc Mutz;  Pimp my Pimpl;  C ++: Vor- und Nachteile des d-Zeiger-Idioms, Teil 1;  <a href="http://www.heise.de/developer/artikel/C-Vor-und-Nachteile-des-d-Zeiger-Idioms-Teil-2-1136104.html">Artikel</a> auf heise Developer ( <a href="http://marcmutz.wordpress.com/translated-articles/pimp-my-pimpl/">English translation available</a> ) </li></ul><br><br><h4>  Translator's notes </h4><br>  <sup>1</sup> Here and hereafter: a play on words - Pimpl is consonant with the verb to pimp, which is a reference to the TV show ‚ÄúPimp My Ride‚Äù (English ‚ÄúPimp my Ride‚Äù). </div><p>Source: <a href="https://habr.com/ru/post/137702/">https://habr.com/ru/post/137702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137696/index.html">Russian Roulette with Kinect</a></li>
<li><a href="../137698/index.html">Second wave of coworking centers: Area of ‚Äã‚Äãoperation, Flacon Coworking, Dial</a></li>
<li><a href="../137699/index.html">Free click-2-call widget for your site</a></li>
<li><a href="../137700/index.html">An elderly woman replaced her own jaw with a prosthesis made on a 3D printer</a></li>
<li><a href="../137701/index.html">Data centers: who is in that much</a></li>
<li><a href="../137704/index.html">Pitfalls in Project Voldemort</a></li>
<li><a href="../137705/index.html">CSS3. Work with multiple backgrounds</a></li>
<li><a href="../137707/index.html">Improving pictures in Skype chat (updated)</a></li>
<li><a href="../137708/index.html">Streaming audio</a></li>
<li><a href="../137710/index.html">Profiling module "ProfilerToolbar"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>