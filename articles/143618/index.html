<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nikodemus' Common Lisp FAQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nikodemus' Common Lisp FAQ 

 Last updated 2012-04-13 

 This is a very unofficial Common Lisp FAQ, reflecting Nikodemus Siivola‚Äôs subjective opinion....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nikodemus' Common Lisp FAQ</h1><div class="post__text post__text-html js-mediator-article">  Nikodemus' Common Lisp FAQ <br><hr><br>  Last updated 2012-04-13 <br><br>  This is a very unofficial Common Lisp FAQ, reflecting Nikodemus Siivola‚Äôs subjective opinion.  This text is based in part on other FAQs found on the Internet and comp.lang.lisp. <br>  If you think that I used your text, I will be glad to admit it, so write to nikodemus@random-state.net. <br>  The current version of this FAQ is available at the following addresses: <br>  <a href="http://random-state.net/files/nikodemus-cl-faq.txt">http://random-state.net/files/nikodemus-cl-faq.txt</a> <br>  <a href="http://random-state.net/files/nikodemus-cl-faq.html">http://random-state.net/files/nikodemus-cl-faq.html</a> <br>  FAQs are also periodically published in comp.lang.lisp. <br><a name="habracut"></a><br><h4>  The very beginning </h4><br><h5>  Common Lisp?  CL?  Clisp?  Lisp? </h5><br>  Common Lisp is the name of the ANSI standardized language. <br>  ‚ÄúCL‚Äù is the most preferred abbreviation of the previous name. <br>  ‚ÄúClisp‚Äù is not a proper abbreviation, because it is the name of one of the implementations of Common Lisp. <br>  "Lisp" is the category of languages ‚Äã‚Äãto which CL belongs. <br>  ‚ÄúLISP‚Äù is no longer written for 20 years, Common Lisp is often shortened to Lisp if <br>  it is clear from the context exactly what is at stake. <br><br><h5>  So what? </h5><br>  You can read about the language here: <br>  <a href="http://random-state.net/features-of-common-lisp.html">http://random-state.net/features-of-common-lisp.html</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  How to learn Common Lisp? </h5><br><ol><li>  Read a good book on Common Lisp. </li><li>  Start using it. </li></ol><br>  Many people often try to go through the first path, but forget about the second one. <br>  Well, really, you can't learn how to program in the language without starting to use it.  And then, without working on a fairly large program, many things are impossible to understand correctly. <br><br><h5>  What pitfalls to bypass? </h5><br>  Any good book will tell you about the features and tricks of the language, but there are a couple of psychological and social issues that many stumble upon: <br><br><ol><li>  <i>Learning about Lisp macros is crazy.</i> <br>  Lisp macros are great stuff, but the power they give to newbies is often confusing. <br>  Often a symptom of a problem is an attempt to do something without a clear understanding of why it is being done.  Remember, all that can be done with macros can be done without them.  Of course, it may turn out not so practical, but the memory of this lowers from heaven to earth. <br>  Before you learn to run, learn to walk.  It is worth it, especially since then you can fly. </li><li>  <i>Lisp is not perfect, and this is not news.</i> <br>  Some come to Lisp with high expectations and are disappointed.  Others compare Lisp with X and discover that the former is losing in some ways. <br>  Both may reason correctly and have valid claims, but problems begin when these people begin to voice their claims somewhere, for example, on #lisp. <br>  If the reasoning is correct, most likely the question has already been discussed a hundred times and no one has enough strength or desire for a second discussion. <br>  If the reasoning is wrong or they are more theoretical than practical, then despite the fact that every year disaffected beginners constantly raise such questions, no one has enough strength or desire to re-discuss. <br>  This does not mean that talking bad about Lisp on the Internet is forbidden, but ... If you are a beginner, come and say that everything is bad, do not expect that people will come to you with open arms.  Even if you are a hundred times right. <br>  Complaints from oldies, who also made a lot for the community, have much more weight. </li><li>  <i>Experienced public lispers see a lot of trolls.</i> <br>  MANY TROLLS!  A confused newbie sometimes looks like a troll, largely because most trolls most often disguise themselves as Lisp beginners. <br>  Therefore, people may think that you are a troll and respond accordingly. <br>  The best way to avoid this is to be polite.  If someone tells you that you are mistaken or mistaken, suppose for a moment that he is either right, or it looks like you are mistaken or mistaken. </li></ol><br><br><h5>  What book to start with? </h5><br>  Start with Practical Common Lisp (also known as PCL) by Peter Seibel.  This is a good starting point if you already have some programming language.  The book is available in electronic and printed form: <br><br>  <a href="http://www.gigamonkeys.com/book/">http://www.gigamonkeys.com/book/</a> <br><br>  Another good book is Common Lisp: A Gentle Introduction to Symbolic Computation by David Touretzky.  Newbies in programming, or those who find PCL too complicated, should read this book.  If you start with it, then read PCL.  Although if you have already read PCL and understood everything, you can safely skip this one.  The book is available in electronic and printed form: <br><br>  <a href="http://www.cs.cmu.edu/~dst/LispBook/index.html">http://www.cs.cmu.edu/~dst/LispBook/index.html</a> <br><br>  There are a lot of good books, but these two are the best for beginners.  Land of Lisp is not bad, but in my humble experience it can form a misconception.  If you start with it, read PCL anyway. <br><br>  Be sure to check out Hyperspec or CLHS, the electronic version of the language standard.  This is just the most valuable reference: <br><br>  <a href="http://www.lispworks.com/documentation/HyperSpec/index.html">http://www.lispworks.com/documentation/HyperSpec/index.html</a> <br><br>  Do not immediately rush to read the directory.  Just know where it is, it contains the official answers to all possible questions about the CL.  This is the perfect place to find out what an operator is doing.  In addition, it is worth looking into it to find out if the functionality you need is implemented in the language. <br><br>  Do not neglect the documentation that came with your implementation.  In the case of SBCL, the guide is located at: <br><br>  <a href="http://www.sbcl.org/manual">http://www.sbcl.org/manual</a> <br><br><h5>  What should I get the implementation? </h5><br>  It depends on what you need, although if you are just starting, it does not matter.  However, if you are waiting for help from some group of people, take the realization that this group uses. <br><br>  As you learn, you will be able to make an informed choice.  The transition between implementations is not very difficult, so this is not a reason for doubts. <br><br>  I am very partial to SBCL: <br><br>  <a href="http://www.sbcl.org/">http://www.sbcl.org/</a> <br><br>  SBCL is good because it comes with open source, runs on many platforms (including Windows), includes a compiler, is very serious about compatibility with the ANSI standard and generally brings joy and peace in the world ... and here I must to mention that I am one of the developers of SBCL and my company <a href="http://sb-studio.net/">Steel Bank Studio Ltd</a> provides commercial support for it. <br><br>  If for some reason SBCL does not suit you, I can suggest to go through the following lists: <br><br>  Open: <br><ul><li>  Clozure cl </li><li>  CMUCL </li><li>  Clisp </li><li>  ABCL </li><li>  Ecl </li></ul><br><br>  Commercial: <br><ul><li>  Lispworks </li><li>  Allegro CL </li><li>  Scieneer </li></ul><br><br><h5>  Where are the libraries?  Is there an analogue of CPAN or RubyGems? </h5><br>  QuickLisp is very similar to RubyGems: <br><br>  <a href="http://www.quicklisp.org/">http://www.quicklisp.org/</a> <br><br>  It provides lots of libraries and manages dependencies between them.  This is a very, very necessary tool. <br><br>  The closest to CPAN are Cliki and common-lisp.net: <br><br>  <a href="http://www.cliki.net/">http://www.cliki.net/</a> <br>  <a href="http://www.common-lisp.net/">http://www.common-lisp.net/</a> <br><br>  ... but nothing is better, really. <br><br><h5>  How to use IDE? </h5><br>  If you are working with SBCL, then use Emacs and Slime: <br><br>  <a href="http://www.common-lisp.net/project/slime/">http://www.common-lisp.net/project/slime/</a> <br><br>  Even if you didn‚Äôt use Emacs before, make an effort on yourself and use Slime - the learning curve is not very steep and all commands are available through the menu. <br><br>  You can configure Slime using Quicklisp, see below the section ‚ÄúHow to set up the environment?‚Äù.  You can start learning with <code>Mx slime-cheat-sheet</code> , however, this is only a small part of the Slime features. <br><br>  When using another implementation, use the IDE that the developer recommends (although Slime works with almost all implementations). <br><br>  For practical work with Lisp, the editor should at least: <br><br><ul><li>  correctly set up the Lisp code; </li><li>  understand pair brackets; </li><li>  be able to execute the commands Edit Definition, Compile Defun, Eval Expression, Describe Symbol, Disassemble Function, Trace Function, Inspect expression and other commands to interact with your Lisp; </li><li>  interact with the debugger; </li><li>  interact with the inspector. </li></ul><br><br>  Slime can do all of the above and much more. <br><br>  If you like Vi (m), take a look at Slimv, which links Vim to the part of Slime written in Common Lisp: <br><br>  <a href="http://www.vim.org/scripts/script.php%3Fscript_id%3D2531">http://www.vim.org/scripts/script.php?script_id=2531</a> <br>  <a href="https://bitbucket.org/kovisoft/slimv/">https://bitbucket.org/kovisoft/slimv/</a> <br>  <a href="http://kovisoft.bitbucket.org/tutorial.html">http://kovisoft.bitbucket.org/tutorial.html</a> <br><br>  ... but I can not vouch for this, because I do not use Vim / Slimv. <br><br><h5>  How to set up the environment? </h5><br><br>  A good guide (at the time of writing) on ‚Äã‚Äãgetting SBCL, Slime and setting up Quicklisp is located here: <br><br>  <a href="http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-linux/">http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-linux/</a> <br>  <a href="http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-osx/">http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-osx/</a> <br><br>  Guidelines for configuring Clisp on Windows.  However, it is impossible to grasp the immense: <br><br>  <a href="http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-windows/">http://mohiji.nfshost.com/2011/01/modern-common-lisp-on-windows/</a> <br><br><h5>  Is there a GUI? </h5><br>  Yes and no.  One GUI that everyone would use is not. <br><br>  Commercial Lisp's are mostly shipped with GUI libraries, and it seems that supporters of these implementations like the supplied libraries.  However, the code for such libraries is not transferred between Lisp'ami.  If you are using a commercial implementation and the portability of the code is not interesting for you, then choose the tools offered by the developer.  Depending on how the library is made, the code may be transferred to different operating systems, perhaps this is exactly what you need. <br><br>  In the camp of the open code, too, there are several solutions. <br><br>  CommonQt is a binding of Common Lisp to the Qt smoke library: <br><br>  <a href="http://common-lisp.net/project/commonqt/">http://common-lisp.net/project/commonqt/</a> <br><br>  LTK is built on top of Tk: <br><br>  <a href="http://www.peter-herth.de/ltk/">http://www.peter-herth.de/ltk/</a> <br><br>  CL-GTK2 and CLG are GTK + bindings, but I can't say anything about the current state of these developments.  It is also worth looking at GTK Server. <br><br>  <a href="http://common-lisp.net/project/cl-gtk2/">http://common-lisp.net/project/cl-gtk2/</a> <br>  <a href="http://sourceforge.net/projects/clg/">http://sourceforge.net/projects/clg/</a> <a href="http://www.gtk-server.org/">http://www.gtk-server.org/</a> <br><br>  CLIM (Common Lisp Interface Manager) is an almost standardized GUI API specification that is quite different from the GUIs listed above.  Do not expect that everything will be familiar and clear. <br><br>  <a href="http://random-state.net/files/how-is-clim-different.html">http://random-state.net/files/how-is-clim-different.html</a> <br><br>  Many swear that this is the best thing to build a GUI, others argue that this is not the case.  Be that as it may, most commercial Lisp implement CLIM, and there is still a portable open library called McCLIM, which is quite convenient, although not very advanced lately. <br><br>  <a href="http://common-lisp.net/project/mcclim/">http://common-lisp.net/project/mcclim/</a> <br><br>  CLX is a portable low-level Lisp interface to X11, providing an abstraction layer comparable to Xlib. <br><br>  <a href="http://www.cliki.net/CLX">http://www.cliki.net/CLX</a> <br>  <a href="https://github.com/sharplispers/clx">https://github.com/sharplispers/clx</a> <br><br>  Unless strictly limited to GUI issues, I‚Äôll be wrong if I don‚Äôt mention CL-OPENGL, a portable binding to the OpenGL API, GLU and GLUT: <br><br>  <a href="http://common-lisp.net/project/cl-opengl/">http://common-lisp.net/project/cl-opengl/</a> <br><br><h5>  What are the forums? </h5><br>  Not a forum of course, but there is a Planet Lisp - Common Lisp blog aggregator.  A lot of interesting information, without excess. <br><br>  <a href="http://planet.lisp.org/">http://planet.lisp.org/</a> <br><br>  LispForum is just a good forum: <br><br>  <a href="http://www.lispforum.com/">http://www.lispforum.com/</a> <br><br>  but I don‚Äôt vouch for it, as I‚Äôm not often there. <br><br>  There are also comp.lang.lisp groups on Usenet / Google Groups, but they are densely populated by trolls.  The authors who write there are quite literate, and the speculations of the profane are an ordinary phenomenon.  Reading these groups can be tough, but you don't need to read them to use Lisp. <br><br>  <a href="">http://groups.google.com/group/comp.lang.lisp</a> <br><br>  Specialized mailing lists have a much better signal-to-noise ratio.  All implementations try to create their own user and reference mailing lists, most libraries also create their own mailing lists.  For SBCL there is, for example, this: <br><br>  <a href="https://lists.sourceforge.net/lists/listinfo/sbcl-help">https://lists.sourceforge.net/lists/listinfo/sbcl-help</a> <br><br>  Among open-source developers and users, the #lisp channel on freenode.org is popular.  Keep in mind, however, that on #lisp they stick to the theme rather rigidly, and this is Common Lisp, not ‚ÄúLisp at all‚Äù.  For this, there is the #lispcafe channel with much softer rules. <br><br>  The game development community is pretty active, but I‚Äôm not familiar with it.  Google to help you. <br><br>  Common Lisp Professionals chat on the pro list.  Discussion of other Lisp dialects is oftopikom, novice questions are NOT accepted. <br><br>  <a href="http://lists.common-lisp.net/mailman/listinfo/pro">http://lists.common-lisp.net/mailman/listinfo/pro</a> <br><br><h4>  Language properties </h4><br><h5>  How to compile a file? </h5><br>  <b>The short answer is:</b> start Lisp and type: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">compile-file</span></span> <span class="hljs-string"><span class="hljs-string">"/path/to/myfile.lisp"</span></span>)</code> </pre> <br><br>  Then, most likely, you will need to load (load ...) the compiled file. <br><br>  <b>Detailed answer:</b> most compiled languages ‚Äã‚Äãare non-interactive ‚Äî you compile a file from the command line or an IDE, then run the compiled file.  In Lisp, it's not like that. <br><br>  While in the general case you can turn your project into an executable file, a typical working session is not like the edit-compile-execute cycle, as one would expect. <br><br>  Usually, the interaction occurs with a running Lisp process that contains a work session to which you interactively add code. <br><br>  For example: <br><br><ol><li>  open Emacs, use Slime and Lisp with <code>Mx slime</code> ; </li><li>  using, for example, ASDF, load the existing code; </li><li>  open the desired file, edit the function and press <code>Cc Cc</code> , which will recompile it; </li><li>  go to the Slime REPL and test the changes; </li><li>  repeat from step 3. </li></ol><br><br>  The above abbreviation ASDF stands for ‚ÄúAnother System Definition Facility‚Äù.  This system allows you to specify a way to collect multiple files into a single system for downloading or compiling one command.  Something like Make. <br><br><h5>  How to make an executable file? </h5><br>  The answer depends on the implementation you are using.  See the documentation.  If we talk about SBCL: <br><br><pre> <code class="lisp hljs"><span class="hljs-comment"><span class="hljs-comment">;;    SBCL,    save-lisp-and-die. ;;     - MY-FUNCTION. (save-lisp-and-die "my.exe" :executable t :toplevel 'my-function)</span></span></code> </pre> <br><br><h5>  FUNCALL and APPLY - what's the difference, what to use? </h5><br>  <b>The short answer is:</b> wherever you can use <code>FUNCALL</code> , in other cases use <code>APPLY</code> . <br><br>  Detailed answer: when calling <code>FUNCALL</code> number of arguments must be known.  <code>APPLY</code> (and <code>MULTIPLE-VALUE-CALL</code> ) does not require information on the number of arguments. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> map-list-with-1 (<span class="hljs-name"><span class="hljs-name">function</span></span> list arg) (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span>) (<span class="hljs-name"><span class="hljs-name">funcall</span></span> function elt arg)) list)) (<span class="hljs-name"><span class="hljs-name">defun</span></span> map-list-with-n (<span class="hljs-name"><span class="hljs-name">function</span></span> list <span class="hljs-symbol"><span class="hljs-symbol">&amp;rest</span></span> args) (<span class="hljs-name"><span class="hljs-name">mapcar</span></span> (<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">elt</span></span>) (<span class="hljs-name"><span class="hljs-name">apply</span></span> function elt args)) list))</code> </pre> <br><br>  There is no need to write <code>MAP-LIST-WITH-1</code> using <code>APPLY</code> , the <code>FUNCALL</code> call <code>FUNCALL</code> almost certainly be more efficient. <br><br>  In contrast, <code>MAP-LIST-WITH-N</code> cannot be written using <code>FUNCALL</code> , since the number of arguments to the caller is unknown.  Should use <code>APPLY</code> . <br><br><h5>  SET, SETQ and SETF - what's the difference, what to use? </h5><br>  <b>The short answer is:</b> always use <code>SETF</code> . <br><br>  <b>Detailed answer:</b> Long ago, when there was no Common Lisp, there were no lexical variables, there were only dynamic ones.  And then there was neither <code>SETQ</code> , nor <code>SETF</code> , only <code>SET</code> . <br><br>  What is spelled today as <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">symbol-value</span></span> '*foo*) <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><br>  recorded like that <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">set</span></span> (<span class="hljs-name"><span class="hljs-name">quote</span></span> *foo*) <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><br>  which eventually decreased to <code>SETQ</code> (SET Quoted) <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">setq</span></span> *foo* <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><br>  Then lexical variables appeared and <code>SETQ</code> began to be used for their assignment, so <code>SETQ</code> no longer just a wrapper around <code>SET</code> . <br><br>  Later, someone invented <code>SETF</code> (SET Field) as a generalized way of assigning values ‚Äã‚Äãin data structures, mirroring L-values ‚Äã‚Äãin other languages: <br><br><pre> <code class="delphi hljs">x.car := <span class="hljs-number"><span class="hljs-number">42</span></span>;</code> </pre> <br><br>  recorded as <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">setf</span></span> (<span class="hljs-name"><span class="hljs-name">car</span></span> x) <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><br>  For symmetry and generality, the <code>SETF</code> also includes the <code>SETQ</code> functionality.  It can be said that <code>SETQ</code> was a low-level primitive, and <code>SETF</code> was a high-level operation. <br><br>  Then came the symbolic macros.  Since the character macros are transparent, it was done so that the <code>SETQ</code> behaves as a <code>SETF</code> in the case when the assigned ‚Äúvariable‚Äù is actually a character macro: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> *hidden* (<span class="hljs-name"><span class="hljs-name">cons</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>)) (<span class="hljs-name"><span class="hljs-name">define-symbol-macro</span></span> foo (<span class="hljs-name"><span class="hljs-name">car</span></span> *hidden*)) foo =&gt; <span class="hljs-number"><span class="hljs-number">42</span></span> (<span class="hljs-name"><span class="hljs-name">setq</span></span> foo <span class="hljs-number"><span class="hljs-number">13</span></span>) foo =&gt; <span class="hljs-number"><span class="hljs-number">13</span></span> *hidden* =&gt; (<span class="hljs-number"><span class="hljs-number">13</span></span> . <span class="hljs-number"><span class="hljs-number">42</span></span>)</code> </pre> <br><br>  And here we are in our days: <code>SET</code> and <code>SETQ</code> are essentially an atavism, left over from the old dialects, and may be thrown out of what will be the next Common Lisp. <br><br>  Always use <code>SETF</code> . <br><br><h5>  '(1 2 3) or (list 1 2 3)? </h5><br>  <b>The short answer is:</b> write <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">list</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><br>  until you understand the difference.  If you write <br><br><pre> <code class="lisp hljs">'(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><br>  do not modify it destructively (i.e. using <code>SORT</code> or <code>NREVERSE</code> ). <br><br>  <b>Detailed answer:</b> First, the single quote is a macro that converts <br><br><pre> <code class="lisp hljs">'anything</code> </pre> <br><br>  at <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">quote</span></span> anything)</code> </pre> <br><br>  while reading so <br><br><pre> <code class="lisp hljs">'(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) === (<span class="hljs-name"><span class="hljs-name">quote</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br><br>  Secondly, <code>QUOTE</code> is a special operator that returns its arguments not computed.  So <br><br><pre> <code class="lisp hljs">'(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre> <br><br>  returns a literal list.  As with most languages, modifying literal data leads to undefined consequences.  For example, the compiler can connect constants containing literals: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">a</span></span> '(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)) (<span class="hljs-name"><span class="hljs-name">b</span></span> '(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>))) (<span class="hljs-name"><span class="hljs-name">eq</span></span> ab)) <span class="hljs-comment"><span class="hljs-comment">; =&gt; T  NIL</span></span></code> </pre> <br><br>  The consequence is the fact that changing A can also change and B. Then what is <code>QUOTE</code> good for?  If, for example, you have large immutable lists that the compiler can put together, then marking them as literal gives the compiler the right to do so. <br><br><h5>  What the * Ears *? </h5><br>  Whatever you use to declare variables, <code>DEFVAR</code> or <code>DEFPARAMETER</code> , always do * SUCH-NAME *.  And do not do this for local variables. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defvar</span></span> *-* ...) (<span class="hljs-name"><span class="hljs-name">defvar</span></span> -- ...)</code> </pre> <br><br>  What for?  If you still do not know what special variables are, continue to read the book you are reading and come back as you finish, but for now use the ears. <br><br>  Ears protect against two simple mistakes that are very easy to make. <br><br><h6>  Error 1: random binding of a special variable. </h6><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defparameter</span></span> foo <span class="hljs-string"><span class="hljs-string">"foo!"</span></span>) (<span class="hljs-name"><span class="hljs-name">defun</span></span> say-it () (<span class="hljs-name"><span class="hljs-name">write-line</span></span> foo)) (<span class="hljs-name"><span class="hljs-name">defun</span></span> say-more (<span class="hljs-name"><span class="hljs-name">foo</span></span>) (<span class="hljs-name"><span class="hljs-name">say-it</span></span>) (<span class="hljs-name"><span class="hljs-name">format</span></span> <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-string"><span class="hljs-string">"now say ~A~%"</span></span> foo))</code> </pre> <br><br>  Now <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">say-more</span></span> <span class="hljs-string"><span class="hljs-string">"bar!"</span></span>)</code> </pre> <br><br>  will print <br><br><pre> <code class="lisp hljs">say bar! now say bar!</code> </pre> <br><br>  instead of the expected <br><br><pre> <code class="lisp hljs">say foo! now say bar!</code> </pre> <br><br>  ... oops! <br><br><h6>  Error 2: due to a typo, reading is made from a special instead of a local variable; no warning is issued. </h6><br>  Usually you will receive a compile-time warning and a run-time error in case <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> foo (<span class="hljs-name"><span class="hljs-name">bar</span></span>) bat)</code> </pre> <br><br>  but if you write before <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defparameter</span></span> bat <span class="hljs-string"><span class="hljs-string">"baseball"</span></span>)</code> </pre> <br><br>  then there will be no error and you will spend a lot of time debugging, trying to figure out what is wrong. <br><br>  If you are writing code for yourself, it doesn‚Äôt matter whether you put your ears or not, but when you publish a code, the absence of * ears * means a waste of other people's time.  Do not do this, please! <br><br>  The absence of ears creates a sense of error: when I see <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defparameter</span></span> - ...)</code> </pre> <br><br>  I understand that it is necessary to read the code with particular caution, because there is no guarantee that the code that looks quite harmless from the first sight will not have non-local side effects or dependencies. <br><br>  Always put * ears *.  They say that there are exceptions to all the rules, but in this case it is very difficult to find a real exception to this rule. <br><br>  Good code <br>  - Nikodemus </div><p>Source: <a href="https://habr.com/ru/post/143618/">https://habr.com/ru/post/143618/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143611/index.html">Promotion iOS applications on the English-speaking space</a></li>
<li><a href="../143612/index.html">The Pirate Bay should be blocked, the Hague court said after introducing Net Neutrality ...</a></li>
<li><a href="../143614/index.html">The difference between bin, sbin, usr / bin, usr / sbin</a></li>
<li><a href="../143615/index.html">Blocking Twitter in Russia</a></li>
<li><a href="../143616/index.html">TSA style testing</a></li>
<li><a href="../143619/index.html">Facebook tests paid post assignment</a></li>
<li><a href="../143620/index.html">Life without objects</a></li>
<li><a href="../143621/index.html">What do we need to build a movie?</a></li>
<li><a href="../143622/index.html">I don't understand how they do it, part 2</a></li>
<li><a href="../143624/index.html">IPmatika at "Master class in Moscow by MyAsterisk"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>