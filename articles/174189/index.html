<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GamePlay 3D Framework - easy start to cross-platform development of 3D games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good time of day, dear habrazhiteli! 

 After taking a course on computer graphics at the university and having played enough with OpenGL, I decided t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GamePlay 3D Framework - easy start to cross-platform development of 3D games</h1><div class="post__text post__text-html js-mediator-article">  Good time of day, dear habrazhiteli! <br><br>  After taking a course on computer graphics at the university and having played enough with OpenGL, I decided that it was time to move on and try myself in game development.  Frankly speaking, I didn‚Äôt really want to write my own engine from scratch.  The main goal was to see how it was done, to learn lessons and maybe create something based on the selected engine.  A quick search revealed that the open cross-platform engines are a bit tight.  One has a problem with Linux, Windows or Mac OS, another with fresh versions of mobile OS, the third is almost abandoned ... But I did come across one very attractive copy, which I want to tell about in this article. <br><br><img src="http://dl.dropbox.com/u/64710641/logo.png" alt="gameplay">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The name of this framework is GamePlay 3D.  Information about it on the Internet is not very much, what can we say about Runet.  This is an open source framework written in C ++ for programming games in C ++ with all the advantages and disadvantages that follow from it.  The authors of the project position it as a universal tool, a kind of analog cocos2d for 3D games.  To start writing on GamePlay 3D you do not need to have a deep knowledge of OpenGL, GLSL or 3D graphics math, but we all understand that to achieve a good result you cannot get away from it.  Details and a small example to start under the cut. <br><br><a name="habracut"></a>  I‚Äôll start with a brief list of the main features of the engine: <br><ul><li>  support for Linux, Windows, Mac OS X, Android, iOS and Blackberry OS </li><li>  C ++ API, Lua game scripts </li><li>  OpenGL 3.2+ and OpenGL ES 2.0 </li><li>  build a project for different OS in one click * </li><li>  simple and convenient configuration of scenes (objects, materials, physics, animation) </li><li>  physics engine bullet (well, this is kind of standard) </li><li>  A ready tool for converting 3D scenes and fonts into your own binary format. </li><li>  support for input from the keyboard, mouse, joystick, screen joystick and sensors </li><li>  comfortable work with sound (wav, ogg) in 3D </li><li>  your own GUI with buttons, checkboxes, sliders, etc. </li><li>  and much more. </li></ul><br>  <i>* Well, almost one ...</i> <br><br><div class="spoiler">  <b class="spoiler_title">A more complete list of features from the project site</b> <div class="spoiler_text"><ul><li>  Full-featured OpenGL 3.2+ (desktop) and OpenGL ES 2.0 (mobile) based rendering system </li><li>  Shader-based material system with built-in common shader library </li><li>  Node-based scene graph and noise collision objects </li><li>  Heightmap based terrains with multiple surface layers and LOD </li><li>  Declarative scene bindings (materials) and node attachments (particle emitters, physics collision objects, 3D audio sources) </li><li>  Declarative particle system </li><li>  Easy-to-use text and sprite rendering </li><li>  Physics system (using Bullet physics) <br><ul><li>  vehicle physics </li><li>  character physics </li><li>  rigid body dynamics </li><li>  constraints </li><li>  ghost objects </li></ul></li><li>  Declarative UI system with support for themeable 2D and 3D forms.  Includes the following built-in core controls and layouts: <br><ul><li>  button </li><li>  label </li><li>  text box </li><li>  slider </li><li>  check box </li><li>  radio button </li><li>  absolute layout </li><li>  vertical layout </li><li>  flow layout </li></ul></li><li>  Fully extensible animation system with skeletal character animation support </li><li>  Complete 3D audio system with WAV and OGG support </li><li>  Full vector math library with 2D / 3D math and 3D object culling support </li><li>  Mouse, keyboard, touch, gestures and gamepad support </li><li>  Lua script bindings and binding generator tool </li><li>  AI state machine </li></ul></div></div><br>  We now understand how to quickly and easily create a small demo with a tiny scene, several objects, physics and basic lighting, using exclusively open source tools.  References to the materials used and the archive with the finished project are scattered throughout the text and brought together at the end of the article. <br><br>  We will create our first demo in Linux.  We will need: <br><ul><li>  favorite IDE or text editor </li><li>  cmake, make, gcc </li><li>  Blender with support for export to COLLADA </li></ul><br>  Building the engine consists of downloading the source from Github, installing dependencies and running <i>cmake ... &amp;&amp; make</i> in the <i>build</i> directory (Windows and Mac OS X users open an existing Visual Studio project or XCode, respectively, and compile with one click).  After the compilation is successfully completed, we will start creating our project by executing the <i>gameplay-newproject. Script (sh | bat)</i> in the framework root directory.  The script will ask a few questions, by answering which we will get the finished fish of the project in the directory indicated by us.  Let's call Promo Demo and specify the current directory (the root directory of the engine) as the path. <br><br><h4>  Project </h4><br>  The created project already contains all the necessary files for compiling and running the game, as well as project files for Visual Studio and Xcode.  Linux users have to take care of setting up the project for their IDE.  The entire setting consists in specifying the directory with the source of the game, adding engine libraries to the project, etc.  Now we will not dwell on this, but simply use the usual vim, the utilities cmake and make.  We will compile the project, launch and see what we have, and then we will figure out what it consists of and add some drama. <br><pre><code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> Demo/build cmake .. make</code> </pre> <br>  Run the resulting binary: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../bin/linux ./Demo</code> </pre><br>  If everything is ok, then you should see something like this: <br><img src="http://dl.dropbox.com/u/64710641/box1.png" alt="image"><br><br>  So, what do we see in the game folder with the exception of the VS, Xcode and cmake project files? <br>  <i>game.config</i> - base configuration such as resolution, full screen or window, etc. <br>  <i>res /</i> - directory with game resources <br>  <i>res / box.gpb</i> - game scene (just a cube with a camera and a light source), encoded in the native format <br>  box.dae - the game scene in its raw form, in this case in the format COLLADA <br>  colored. (frag | vert) - shaders used in cube material <br>  <i>res / box.material</i> - cube material description <br>  <i>src /</i> - source <br>  <i>src / Demo. (cpp | h)</i> - base class <br>  <i>android /</i> - project to build games for Android <br>  <i>bin /</i> - compiled binaries <br><br>  But the ready-made example with a rotating cube is too simple and boring, besides, we want to dig a little deeper engine: add more cubes and even balls, determine their physical properties and materials. <br><br>  Here is what we get in the end: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/PCqMkaeuLmc&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhiDA9yVzz0GjNOAD-C3oAXKAOBHxA" frameborder="0" allowfullscreen=""></iframe><br><br>  To begin with, let's create a scene in Blender: cubes hang over a certain surface, just above a couple of balls for complete happiness.  It is important to note that in the game, height is determined by the <i>y</i> axis, not <i>z</i> , unlike Blender (in fact, it doesn‚Äôt matter, but there‚Äôs some kind of problem if the height is not defined on the GamePlay 3D axis, that for the purity of the experiment we will use <i>y</i> ).  We need to somehow name all the objects so that we can access them from the code of the game and distinguish them from each other.  We proceed simply - all cubes will be called <i>boxX</i> , balls <i>ballX</i> , where <i>X</i> is any number.  The surface over which they soar, we name floor.  Call the camera camera and rotate it so that the lens gets what you need.  The scene is ready and it can be exported in a format understood by the utility gameplay-encoder.  There are two options to choose from: FBX and COLLADA.  We choose COLLADA, because at this stage it is easier (details at the end of the article). <br><br>  The result looks something like this: <br><img src="http://dl.dropbox.com/u/64710641/blender.png" alt="Blender"><br><br><div class="spoiler">  <b class="spoiler_title">For the lazy and for those who do not have a blender at hand</b> <div class="spoiler_text">  Scene for Blender: <a href="http://dl.dropbox.com/u/64710641/boxes.blend">dl.dropbox.com/u/64710641/boxes.blend</a> <br>  Scene in COLLADA: <a href="">dl.dropbox.com/u/64710641/boxes.dae</a> <br>  Scene converted to GamePlayBundle: <a href="">dl.dropbox.com/u/64710641/boxes.gpb</a> </div></div><br><br>  Here comes the gameplay-encoder.  This utility converts various incompatible file formats into the native binary format of the framework.  We don‚Äôt want to waste time and memory on a scene parser from XML or render a vector font in 3D?  It is better to parse such objects in advance and save them in an optimized binary form, so that later you can simply load them into memory.  So, with a slight hand movement, we convert the scene.dae file exported from Blender to scene.gpb and put this file in the res / subdirectory of our project: <br><pre> <code class="bash hljs">path/to/GamePlay/bin/linux/gameplay-encoder scene.dae</code> </pre><br>  Unlike the starting example with a rotating cube, we will not manually search for objects in the scene and determine their properties.  We will simply create a file describing the scene, and then the framework will do everything on its own.  So, the scene description file game.scene: <br><pre> <code class="bash hljs">scene boxes { //     path = res/boxes.gpb //    activeCamera = camera //     floor node floor { //  ,     material = res/game.material<span class="hljs-comment"><span class="hljs-comment">#floor //   ,   collisionObject res/game.physics#floor } //   node boxes { //  url,          boxX url = box* //  material = res/game.material#box //  collisionObject = res/game.physics#box } //    node ball { url = ball* material = res/game.material#ball collisionObject = res/game.physics#ball } //      physics { //     y gravity = 0.0, -9.8, 0.0 } }</span></span></code> </pre> <br>  These materials and physical properties are not taken from the ceiling, but from the corresponding game.material and game.physics files. <br><br>  game.material: <br><pre> <code class="bash hljs">//       material colored { technique { //      pass 0 { //     ,  //      u_worldViewProjectionMatrix = WORLD_VIEW_PROJECTION_MATRIX u_inverseTransposeWorldViewMatrix = INVERSE_TRANSPOSE_WORLD_VIEW_MATRIX //         ... //      renderState { cullFace = <span class="hljs-literal"><span class="hljs-literal">true</span></span> depthTest = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } //        vertexShader = res/shaders/colored.vert fragmentShader = res/shaders/colored.frag } } } //   .     colored material box : colored { //       u_diffuseColor = 0.8, 0.2, 0.2, 1.0 } //    material ball : colored { u_diffuseColor = 0.2, 0.2, 0.8, 1.0 } //   material floor : colored { u_diffuseColor = 0.2, 0.8, 0.2, 1.0 }</code> </pre> <br>  It is worth noting that the variables in the shaders do not appear by themselves from nowhere.  It is necessary to pay attention to what is written in the shader code and determine the corresponding variables in the materials, if necessary.  The framework comes with a small library of ready-made shaders that implement different types of lighting, texturing, and more.  We used a simple variant of coloring objects in one color.  To make this case work, simply copy the entire library of shaders from <i>path / to / GamePlay / gameplay / res / shaders</i> to our project in <i>res / shaders</i> . <br><br>  game.physics: <br><pre> <code class="bash hljs">//     collisionObject box { //   -   <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = RIGID_BODY //  bounding box -  shape = BOX //   mass = 2.0 } //     collisionObject ball { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = RIGID_BODY //  bounding box -  shape = SPHERE mass = 1.0 } //    ,     collisionObject floor { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = RIGID_BODY shape = BOX mass = 0 }</code> </pre> <br>  The values ‚Äã‚Äãof possible physical parameters are described in detail in the documentation. <br><br>  The point is soapy - load scene.gpb in the game code. <br>  We have the base class Demo, which inherits the class Game.  The life cycle of the game is as follows: <br><ol><li>  game initialization in the <i>initialize ()</i> method <i>;</i> </li><li>  update the state of the world before each frame in the <i>update</i> method <i>(float elapsedTime);</i> </li><li>  rendering a scene in the <i>render</i> method <i>(float elapsedTime);</i> </li><li>  finalizing the application in the <i>finalize ()</i> method <i>;</i> </li></ol><br>  We only change the <i>initialize ()</i> method and empty the <i>update (float elapsedTime)</i> method <i>.</i> <br><br>  Usually in the <i>initialize ()</i> method we load scene files, scripts, and set the initial state of the game.  So do: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Demo::initialize() { <span class="hljs-comment"><span class="hljs-comment">//        game.scene, //         _scene = Scene::load("res/game.scene"); //  - .         Blender, //            _lightNode = Node::create("directionalLight1"); //      ,    Light* light = Light::createDirectional(_scene-&gt;getActiveCamera()-&gt;getNode()-&gt;getForwardVector()); //    light-&gt;setColor(1.0, 1.0, 1.0); //        _lightNode-&gt;setLight(light); //         _scene-&gt;getActiveCamera()-&gt;setAspectRatio((float)getWidth() / (float)getHeight()); //     ,     _scene-&gt;visit(this, &amp;Demo::initializeScene); }</span></span></code> </pre> <br>  Add the <i>initializeScene ()</i> method, which will assign lighting parameters for each scene object using the light source we created.  I think comments are unnecessary here: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Demo::initializeScene(Node* node) { Model* model = node-&gt;getModel(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (model) { Material* material = model-&gt;getMaterial(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (material &amp;&amp; material-&gt;getTechnique()-&gt;getPassByIndex(<span class="hljs-number"><span class="hljs-number">0</span></span>)-&gt;getEffect()-&gt;getUniform(<span class="hljs-string"><span class="hljs-string">"u_lightDirection"</span></span>)) { material-&gt;getParameter(<span class="hljs-string"><span class="hljs-string">"u_ambientColor"</span></span>)-&gt;setValue(_scene-&gt;getAmbientColor()); material-&gt;getParameter(<span class="hljs-string"><span class="hljs-string">"u_lightColor"</span></span>)-&gt;setValue(_lightNode-&gt;getLight()-&gt;getColor()); material-&gt;getParameter(<span class="hljs-string"><span class="hljs-string">"u_lightDirection"</span></span>)-&gt;setValue(_lightNode-&gt;getForwardVectorView()); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Do not forget to add the signature of the <i>initializeScene ()</i> method and the private variable <i>Node * _lightNode</i> in Demo.h. <br>  The <i>update (float elapsedTime) method</i> will be left empty, because  we will not change the state of the world in this example, physics will do everything for us. <br><br><div class="spoiler">  <b class="spoiler_title">Full listing of Demo.h and Demo.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> TEMPLATEGAME_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TEMPLATEGAME_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"gameplay.h"</span></span></span><span class="hljs-meta"> using namespace gameplay; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * Main game class. */</span></span></span><span class="hljs-meta"> class Demo: public Game { public: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * Constructor. */</span></span></span><span class="hljs-meta"> Demo(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @see Game::keyEvent */</span></span></span><span class="hljs-meta"> void keyEvent(Keyboard::KeyEvent evt, int key); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @see Game::touchEvent */</span></span></span><span class="hljs-meta"> void touchEvent(Touch::TouchEvent evt, int x, int y, unsigned int contactIndex); protected: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @see Game::initialize */</span></span></span><span class="hljs-meta"> void initialize(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @see Game::finalize */</span></span></span><span class="hljs-meta"> void finalize(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @see Game::update */</span></span></span><span class="hljs-meta"> void update(float elapsedTime); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * @see Game::render */</span></span></span><span class="hljs-meta"> void render(float elapsedTime); private: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** * Draws the scene each frame. */</span></span></span><span class="hljs-meta"> bool drawScene(Node* node); bool initializeScene(Node* node); Scene* _scene; Node* _lightNode; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Demo.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Declare our game instance Demo game; Demo::Demo() : _scene(NULL), _lightNode(NULL) { } void Demo::initialize() { _scene = Scene::load("res/game.scene"); _lightNode = Node::create("directionalLight1"); Light* light = Light::createDirectional(_scene-&gt;getActiveCamera()-&gt;getNode()-&gt;getForwardVector()); light-&gt;setColor(1.0, 1.0, 1.0); _lightNode-&gt;setLight(light); // Set the aspect ratio for the scene's camera to match the current resolution _scene-&gt;getActiveCamera()-&gt;setAspectRatio((float)getWidth() / (float)getHeight()); _scene-&gt;visit(this, &amp;Demo::initializeScene); } void Demo::finalize() { SAFE_RELEASE(_lightNode); SAFE_RELEASE(_scene); } void Demo::update(float elapsedTime) { } void Demo::render(float elapsedTime) { // Clear the color and depth buffers clear(CLEAR_COLOR_DEPTH, Vector4::zero(), 1.0f, 0); // Visit all the nodes in the scene for drawing _scene-&gt;visit(this, &amp;Demo::drawScene); } bool Demo::initializeScene(Node* node) { Model* model = node-&gt;getModel(); if (model) { Material* material = model-&gt;getMaterial(); if (material &amp;&amp; material-&gt;getTechnique()-&gt;getPassByIndex(0)-&gt;getEffect()-&gt;getUniform("u_lightDirection")) { material-&gt;getParameter("u_ambientColor")-&gt;setValue(_scene-&gt;getAmbientColor()); material-&gt;getParameter("u_lightColor")-&gt;setValue(_lightNode-&gt;getLight()-&gt;getColor()); material-&gt;getParameter("u_lightDirection")-&gt;setValue(_lightNode-&gt;getForwardVectorView()); } } return true; } bool Demo::drawScene(Node* node) { // If the node visited contains a model, draw it Model* model = node-&gt;getModel(); if (model) { model-&gt;draw(); } return true; } void Demo::keyEvent(Keyboard::KeyEvent evt, int key) { if (evt == Keyboard::KEY_PRESS) { switch (key) { case Keyboard::KEY_ESCAPE: exit(); break; } } } void Demo::touchEvent(Touch::TouchEvent evt, int x, int y, unsigned int contactIndex) { switch (evt) { case Touch::TOUCH_PRESS: break; case Touch::TOUCH_RELEASE: break; case Touch::TOUCH_MOVE: break; }; }</span></span></span></span></code> </pre> </div></div><br>  Do not forget to also run cmake before compiling to include new files in the assembly.  We compile, run the finished binary and observe how the cubes and balls have the color we specified, fall to the surface under the influence of the laws of physics we specified and are illuminated in accordance with the parameters of the light source we created.  Hooray! <br><br><h4>  Cross platform </h4><br>  A small excursion into the assembly of the game for other platforms. <br><br>  <b>Android:</b> you need to download the Android SDK and NDK, and install Apache Ant.  Paths to the SDK and NDK must be in the PATH.  Go to the android directory of our project, run the <i>update project -t 1 -p.</i>  <i>-s &amp;&amp; ndk-build</i> and get the finished apk. <br>  <b>Mac OS X / iOS:</b> open the project file in XCode, build, run. <br>  <b>Windows:</b> Open the Visual Studio project file, build, run. <br>  <b>Blackberry Playbook:</b> see the description on the site.  Unfortunately, I am not the owner of the Playbook and can not comment on the situation.  But since  The authors of the framework initially wrote it under the Playbook, I think there should be no problems with it. <br><br><h5>  disadvantages </h5><br>  Where do without them? <br><br>  The biggest problem I have encountered at the moment is blender &amp; gameplay-encoder.  The first one does not know how to export normal maps to COLLADA, so you can forget about bump-mapping.  There is a patch written by one of the users of the framework, but this patch is not yet included in the blender code and its inclusion is not planned yet.  Rebuilding blender with this patch is not an easy task, I haven't succeeded yet.  Of course, you can use FBX instead of COLLADA.  But there is another problem - it is not so easy to rebuild the gameplay-encoder.  It comes in the form of a ready-made binary and works fine without FBX support, because  FBX is proprietary.  The FBX SDK can be downloaded free of charge from the Autodesk site, but the gameplay-encoder assembly with FBX support is also a big headache.  Somewhere there is an old version of opencollada that refuses to link with new versions of libpcrecpp, somewhere the FBX SDK is naughty, etc.  And if on Ubuntu 12.04 it is still possible, then on more recent Linux - sadness.  The solution is to use Maya or 3DsMax where you need bump-mapping or use other methods.  Or spend time assembling Blender or gameplay-encoder. <br><br>  Documentation - it is beautiful.  All classes and methods are well documented, in the gameplay-api directory there is generated HTML generated by doxygen.  But the tutorial is sparse.  The framework comes with several examples of games in the gameplay-samples directory.  The creation of some of them is analyzed in the documentation on the site, but it is far from complete.  It may take time to figure out what is happening in these examples and why. <br><br>  Small bugs.  The project is obviously quite young.  Sometimes there are small bugs, which, however, quickly corrected.  Authors actively accept pool requests and patches and are generally community friendly. <br><br><h4>  Results </h4><br>  In this example, we touched on only a small part of what GamePlay 3D offers us.  There are many more goodies and joys, starting from the same simple simulation of vehicles and characters with a physics engine, simple programming of animation and sound, elementary input control from various devices and ending with convenient configuration sharing for different platforms.  Recently, an article on Habr√© skipped about how hard it is to write games for Android, because, among other things, different phones use different hardware texture compression chips.  To solve this problem, you can, for example, create different configuration files with paths to the corresponding textures for different chips: game.atc.config for devices with atc chips, game.dxt.config for dxt, game.pvr.config for pvr, game. png.conf for PC, and the engine will pick up the config for the specific device without any questions. <br><br>  I hope you liked the article and someone decides to join the development of this wonderful framework or write your next (or first) project on it.  The post turned out to be quite voluminous, so let's take a closer look at the materials, add interactivity to the demo and fasten the sounds another time. <br><br>  Project website: <a href="http://gameplay3d.org/">gameplay3d.org</a> <br><br>  Archive with the project and scene source for Blender: <a href="">dl.dropbox.com/u/64710641/Demo_complete.zip</a> <br>  Scene for Blender: <a href="http://dl.dropbox.com/u/64710641/boxes.blend">dl.dropbox.com/u/64710641/boxes.blend</a> <br>  Scene in COLLADA: <a href="">dl.dropbox.com/u/64710641/boxes.dae</a> <br>  Scene converted to GamePlayBundle: <a href="">dl.dropbox.com/u/64710641/boxes.gpb</a> <br><br>  In conclusion, a couple of examples from users who have published their development on the project forum. <br><div class="spoiler">  <b class="spoiler_title">Fluid dynamics experiments</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Ipa3vwnqa0o%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhjT-h2a5jLqwVyIw8H3A8GfCijUiA" frameborder="0" allowfullscreen=""></iframe></div></div><br><div class="spoiler">  <b class="spoiler_title">Conduct's Feather Duster BB10 app</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/jof8zJ0isjI%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhhxFxp6z-fhUJbfr_tzEjl81hlVGQ" frameborder="0" allowfullscreen=""></iframe></div></div><br>  GamePlay 3D + Kinect <br><div class="spoiler">  <b class="spoiler_title">AR body suit using BBGamePlay + OpenNI</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/9l6aSrFxlnk%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhgADXUPFEuyqmv9AfJcZGalrvzyhg" frameborder="0" allowfullscreen=""></iframe></div></div><br><div class="spoiler">  <b class="spoiler_title">Unnamed Kinect game</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/pN3o5CCPNRQ%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700190,15700253&amp;usg=ALkJrhiI2qmlxz5bg6rL6zim8LpdU4SBaw" frameborder="0" allowfullscreen=""></iframe></div></div></div><p>Source: <a href="https://habr.com/ru/post/174189/">https://habr.com/ru/post/174189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../174175/index.html">New stage in the race speeds JavaScript. OdinMonkey module speeds up low-level code 10 times</a></li>
<li><a href="../174177/index.html">2 Russian finalists for the Windows Phone Next App Star contest went to the second round!</a></li>
<li><a href="../174181/index.html">How to save money in Amazon Web Services - choosing an efficient architecture</a></li>
<li><a href="../174183/index.html">5% of computers protected by antivirus are still infected</a></li>
<li><a href="../174187/index.html">The digest of interesting news and materials from the world of PHP over the past two weeks, number 13 (03/12/2013 - 03/25/2013)</a></li>
<li><a href="../174195/index.html">Programming ARM Controllers in Eclipse on Ubuntu: how to do it</a></li>
<li><a href="../174197/index.html">Create a convenient viewer for vk.com using Fluid.app with notification of new messages in the dock Mac OS X</a></li>
<li><a href="../174201/index.html">Sony SmartWatch, 7 dream apps</a></li>
<li><a href="../174205/index.html">Easy setup of replication in PostgreSQL</a></li>
<li><a href="../174207/index.html">Swig - JavaScript Template Engine with Django Template Syntax</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>