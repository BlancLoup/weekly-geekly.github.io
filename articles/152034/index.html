<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IR remote for PC and sockets. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Yesterday I explained how to build an Arduino USB-IRPC. What for? To show how to quickly assemble the layout and the complexity of the partic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IR remote for PC and sockets. Part 2</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/151998">Part 1</a> <br>  Yesterday I explained how to build an Arduino USB-IRPC.  What for?  To show how to quickly assemble the layout and the complexity of the particular is not here. <br>  Today we will do everything as it should be.  From the very beginning - from the circuit diagram, PCB, LUT.  A piece of foiled fiberglass converts with a handful of parts into a finished device.  Of course with the case, we want it neatly, right? <br>  Here is our goal: <br> <a href="http://fotki.yandex.ru/users/masterraven/view/412028/"><img src="https://habrastorage.org/getpro/geektimes/post_images/78d/924/115/78d92411583c1979309eae00e058c24a.jpg" width="500" height="338" title="USB-IRPC Bare Front" alt="USB-IRPC Bare Front"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/412028/">USB-IRPC Bare Front</a> " <br> <a href="http://fotki.yandex.ru/users/masterraven/view/412029/"><img src="https://habrastorage.org/getpro/geektimes/post_images/add/96a/7a0/add96a7a04ae32ec8f7e6f5f88ce22cb.jpg" width="500" height="339" title="USB-IRPC Finished" alt="USB-IRPC Finished"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/412029/">USB-IRPC Finished</a> " <br><a name="habracut"></a><br>  So, we start with the concept.  The diagram will only have USB-IRPC itself, since the module of sockets with a relay and the IR receiver with LED is ‚Äúperipherals‚Äù and we will use it without changes. <br>  I used DipTrace to draw a circuit and a circuit board for the following reasons: <br><ul><li>  It is free up to 1000 conclusions, which is enough for my amateur purposes. </li><li>  He is good at making one-sided boards without problems. </li><li>  It is easier and more convenient to use it than the Eagle, which, in my opinion, has a very specific interface. </li></ul><br>  It has a significant drawback - not a very rich library of elements, and also not the most convenient search through it.  But editing the elements is not too difficult.  In general, for now this is the least awkward program for me :) <br>  Here is the scheme itself (see the full-size version better by clicking on the link and opening it in its original size): <br> <a href="http://fotki.yandex.ru/users/masterraven/view/415530/"><img src="https://habrastorage.org/getpro/geektimes/post_images/5db/989/f98/5db989f9897582033867058052ff1cd9.png" width="800" height="531" title="USB-IRPC Scheme" alt="USB-IRPC Scheme"></a> <br>  <a href="http://fotki.yandex.ru/users/masterraven/view/415530/">USB-IRPC Scheme</a> <br>  In the center we have U1 - I used the Atmega168PA-AU, but Atmega88 and Atmega328P will do.  The size of the firmware is just slightly over 4 kb. <br>  The operation of the microcontroller (MK) at a frequency of 16 MHz provide capacitors C4 and C5 with quartz X1. <br>  C2 - just a blocking capacitor, slightly smoothes the pulsations in the power circuit. <br>  A block of R3 and U2 is used to "push" the power button of the PC. <br>  J1 - connector for connecting to the motherboard parallel to the power button. <br>  S1 - Reset button.  May be useful when debugging. <br>  J5 and J6 - ISP6 connector for in-circuit programming (firmware). <br>  J2 - connector for connecting the socket module with a relay. <br>  J3 - connector for IR receiver module with LED. <br>  D1 - the LED connected via the current limiting resistor R1 duplicates the remote LED on the board.  It is useful for debugging, after assembly it is not visible inside the box, so it is not necessary to solder it.  R4 - Resistor for remote LED on the receiver module. <br>  J4 - USB Mini-B connector. <br>  D2 and D3 - 3.6V zener diodes. <br>  R5, R6, R7 - resistors to ensure the operation of V-USB. <br>  That's the whole scheme. <br>  At the end of the article links to download it in the format .sch (DipTrace) <br>  It was more difficult to dissolve the PCB.  I have this first experience and so it was not possible to dissolve one of the conductors in one layer, I had to leave the jumper.  In addition, I forgot that the plugs on the board will be installed on the other side, and then I had to make a separate plug for the programmer.  I, too, mistakenly placed the opto-couple on the wrong side, but this did not stop soldering it.  I corrected all this in the version of the PCB that I posted for download.  So your board will be slightly different from the one on my photos.  For the better :) <br>  In the course of sealing elements, I found that pouring copper too close to the tracks adds inconvenience and changed the fill, getting rid of the islands and making indents from the tracks wider. <br>  Here's what happened: <br><img src="https://habrastorage.org/storage2/7b1/cf0/c64/7b1cf0c64a80e13c2693b690f5765b96.png"><br>  The red carpet is a jumper that could not be diluted. <br>  A nice bonus DipTrace - the ability to see how the PCB will look.  Unfortunately, the library has far from all the elements, but the overall result is still much more visual than in a flat form: <br><img src="https://habrastorage.org/storage2/af5/259/3d3/af52593d3251ef444fb1b153e73de720.png"><br>  It can be seen that on the board I added connector J7 - just another pair of pins, connected in parallel with J1, in order to connect the power button connector from the PC case. <br>  Ok, the circuit and the sample of the printed circuit board are ready, we buy the parts and produce them. <br><br><h4>  Parts List: </h4><br>  U1 - Atmega168PA-AU - in the TQFP-32 package - from 64 rubles (in icdarom, the minimum order is 1500r, delivery is 200), you can buy each piece for 130 rubles free.  Atmega88PA-AU or Atmega328P-AU will do. <br><br>  <b>Lead Elements:</b> <br>  U2 - PC817, PDIP4 package <br>  S1 - DTS-61 Clock button 6x6x4.3. <br>  D2, D3 - 3.6V zener diodes <br>  J2, J3 - PBS-4 <br>  J5, J6 - PBS-3 <br>  J1, J7 - PBS-2 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>SMD elements of size 0805</b> <br>  R1, R4 - 390 Ohm <br>  R5, R6 - 68 Ohm <br>  R7 - 2.2 kŒ© <br>  D1 - LED (any color, I have orange) <br>  J4 - USB miniB connector <br>  C1, C2 - 0.1 ŒºF ceramic capacitors. <br>  C4, C5 - 22 pF ceramic capacitors <br>  X1- 16 MHz quartz <br>  R3 is 100 ohms. <br>  R2 - 10 kŒ© <br><br>  Lead-outs are bought on the radio market - approximately 50 rubles. <br>  I bought the SMD elements at once for $ 9.85 - there are 40 pieces of each resistor and 30 capacitors each. <br><br>  I took the box in icdarom for 40p, but it is also found in other stores of <a href="https://www.google.ru/search%3Fclient%3Dopera%26rls%3Den%26q%3DBOX-KA08%26sourceid%3Dopera%26ie%3Dutf-8%26oe%3Dutf-8">BOX-KA08 of</a> different colors, around 65 rubles. <br>  It even happens transparent: <br><img src="https://habrastorage.org/getpro/geektimes/post_images/b4f/d6b/000/b4fd6b000ddf28586c55194c42510016.jpg" alt="image"><br><br>  I will not teach you how to make boards with LUT - DiHALT described everything <a href="http://easyelectronics.ru/izgotovlenie-pechatnoj-platy-ot-i-do-video-urok.html">simply and clearly</a> .  By the way, congratulate him on the day of jam.  :) <br>  I‚Äôll dwell only on points specific to DipTrace.  When printing, do not forget to mirror and turn off the printing of the contours of the components: <br><img src="https://habrastorage.org/storage2/b4d/fd8/b5d/b4dfd8b5dd5af9f63149d2e4ef100b73.png"><br>  You can do without DipTrace.  I exported to a PNG file, take <a href="">FastStone Viewer</a> and print it like this: <br><img src="https://habrastorage.org/storage2/c3f/887/c66/c3f887c667e58aefae7e9780898cd74d.png"><br>  Print quality to maximum, savings off, resolution to maximum. <br>  PNG prepared in 600 ppi. <br>  Then everything is as usual: we translate, we poison, we wash the toner, we cut it out, we tinker, we drill: <br> <a href="http://fotki.yandex.ru/users/masterraven/view/404810/"><img src="https://habrastorage.org/getpro/geektimes/post_images/eeb/bd1/629/eebbd162975218537a0631644933bf01.jpg" width="500" height="326" title="USB-IRPC" alt="USB-IRPC"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/404810/">USB-IRPC</a> " <br>  My paper was dull and the toner rolled a little around the edges - it might not have been ironed properly, but there was nothing important there, only aesthetics suffered and that lightly. <br>  Seal the components and label: <br> <a href="http://fotki.yandex.ru/users/masterraven/view/412028/"><img src="https://habrastorage.org/getpro/geektimes/post_images/78d/924/115/78d92411583c1979309eae00e058c24a.jpg" width="500" height="338" title="USB-IRPC Bare Front" alt="USB-IRPC Bare Front"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/412028/">USB-IRPC Bare Front</a> " <br> <a href="http://fotki.yandex.ru/users/masterraven/view/412027/"><img src="https://habrastorage.org/getpro/geektimes/post_images/c22/eac/365/c22eac3659d89b965b9686d39c272de6.jpg" width="500" height="342" title="USB-IRPC Bare Back" alt="USB-IRPC Bare Back"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/412027/">USB-IRPC Bare Back</a> " <br>  Please note that I have the PC817 on the wrong side and the rows of the ISP comb are in reverse order - this is my mistake, everything on your board will be correct. <br>  Due to the fact that the mask in its version did not very well, when sealing elements, solder flows appeared, which are very difficult to remove at all.  This moment I also took into account and corrected in the final version of the PCB layout.  But I didn‚Äôt redo the board - it works well, it just doesn't look very good, unfortunately.  The first pancake is always lumpy.  But this time it was possible to make a more accurate trial. <br><br><h5>  Assembly and design </h5><br>  I advise you to print a color image with inscriptions of elements on a 1: 1 scale (USB-IRPC_pcb.jpg) and use it as a cheat sheet when sealing elements and drilling holes. <br>  Needle file carefully cut out the holes in the box.  The outlines of the holes are marked on the body with a marker or pencil, cutting them with a stationery knife in the paper template and putting the template on the body.  From the side, we saw through the slot for the miniUSB connector.  We insert the board and try on: <br> <a href="http://fotki.yandex.ru/users/masterraven/view/411821/"><img src="https://habrastorage.org/getpro/geektimes/post_images/fb9/ba4/4ff/fb9ba44ff9111ead5cb1aca66b1ca00f.jpg" width="500" height="475" title="USB-IRPC" alt="USB-IRPC"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/411821/">USB-IRPC</a> " <br>  If you do not plan on modifying the firmware, then it is not necessary to cut the holes for the ISP - the pins do not rest on the cover. <br>  Then we print and paste the label.  In the archive you will find the version of the sticker with and without ISP.  depending on whether you cut holes under them or not.  (I drilled the hole for Reset, but I didn‚Äôt cut through the sticker, it can be punctured with a toothpick if necessary, but it‚Äôs not useful yet). <br><img src="https://habrastorage.org/storage2/1a4/7a1/fac/1a47a1facc2f3372a5373afe26e2d497.png"><br>  Everything, the hardware is ready. <br> <a href="http://fotki.yandex.ru/users/masterraven/view/412030/"><img src="https://habrastorage.org/getpro/geektimes/post_images/ff3/196/c91/ff3196c9135e35a9ea9673a0436b0629.jpg" width="500" height="451" title="USB-IRPC Size" alt="USB-IRPC Size"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/412030/">USB-IRPC Size</a> " <br>  I simply poured the infrared module with hot melt and attached it to the monitor leg with double sided tape. <br> <a href="http://fotki.yandex.ru/users/masterraven/view/415536/"><img src="https://habrastorage.org/getpro/geektimes/post_images/c32/0c4/364/c320c4364f087edaeffc2fc802e759b4.jpg" width="500" height="341" title="USB-IRPC IR-Led module" alt="USB-IRPC IR-Led module"></a> <br>  " <a href="http://fotki.yandex.ru/users/masterraven/view/415536/">USB-IRPC IR-Led module</a> " <br>  I do not like bright light at home, and under normal lighting it is almost imperceptible - the size of 1x3 cm. <br><br><h4>  We program a device </h4><br>  The firmware is written in C in Code :: Blocks IDE.  Compiler - AVR GCC from <a href="http://www.atmel.com/tools/atmelavrtoolchainforwindows.aspx">AVR Toolchain kit</a> <br>  I will explain the main points here so that you can understand the project code.  Sources are on the project page, links at the end of the article. <br>  I wrote a simulation of the functions DigitalRead and DigitalWrite, because  I take some of the libraries from Arduino and, in order not to rewrite, just slip them into my version of the Wiring functions they call. <br>  <b>ir.h</b> is an interface with an IR receiver.  Shamelessly adapted example that came with a Chinese set of experiments with IR remote control.  Almost unchanged. <br>  <b>usb_comm.h</b> - defines command codes for exchange with a PC and the data structure in which they are transmitted. <br><pre><code class="hljs smalltalk">//<span class="hljs-type"><span class="hljs-type">USB</span></span> <span class="hljs-type"><span class="hljs-type">Commands</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdGetIRPCState <span class="hljs-number"><span class="hljs-number">1</span></span> //   <span class="hljs-type"><span class="hljs-type">IRPC</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdSetDigitalPinStates <span class="hljs-number"><span class="hljs-number">2</span></span> //       -   <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdDisableIR <span class="hljs-number"><span class="hljs-number">3</span></span> //       <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdEnableIR <span class="hljs-number"><span class="hljs-number">4</span></span> //       <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdGetIRBtnMapping <span class="hljs-number"><span class="hljs-number">5</span></span> //         <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdSetIRBtnMapping <span class="hljs-number"><span class="hljs-number">6</span></span> //         <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdGetIRBtn <span class="hljs-number"><span class="hljs-number">7</span></span> //       (     ) <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdSetLedState <span class="hljs-number"><span class="hljs-number">8</span></span> // /  <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdDoInternalFunc <span class="hljs-number"><span class="hljs-number">9</span></span> //    <span class="hljs-type"><span class="hljs-type">IRPC</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdSaveToEEPROM <span class="hljs-number"><span class="hljs-number">10</span></span> //       <span class="hljs-type"><span class="hljs-type">EEPROM</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> cmdLoadFromEEPROM <span class="hljs-number"><span class="hljs-number">11</span></span> //       <span class="hljs-type"><span class="hljs-type">EEPROM</span></span> //<span class="hljs-type"><span class="hljs-type">USB</span></span> pinstate bits <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">PWRRelay1Bit</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> <span class="hljs-type"><span class="hljs-type">PWRRelay2Bit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> ledBit <span class="hljs-number"><span class="hljs-number">7</span></span> //<span class="hljs-type"><span class="hljs-type">Internal</span></span> functions <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> fRelay1Switch <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> fRelay2Switch <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> fPCPwrSwitch <span class="hljs-number"><span class="hljs-number">3</span></span> struct irpcdata_t //      { uint8_t cmd; // <span class="hljs-type"><span class="hljs-type">Switches</span></span> state uint8_t data[<span class="hljs-number"><span class="hljs-number">4</span></span>]; // data };</code> </pre> <br><br>  USB pinstate bits - numbers of control bits of the relay and the LED in the package. <br>  IRPC internal functions: <br>  fRelay1Switch - toggle relay 1 <br>  fRelay2Switch - switch relay 2 <br>  fPCPwrSwitch - press the PC power button <br><br>  irpcdata_t is the package structure that the device and the PC exchange. <br>  Exchange takes place at the request of the PC. <br>  <b>cmd</b> - command code (for example, cmdGetIRPCState) <br>  <b>data []</b> is an array of data of 4 bytes.  Each team interprets it in its own way. <br><br>  <b>irrc.h</b> - matching button codes with names, just for convenience.  I recorded for my remotes.  Like that: <br><pre> <code class="hljs smalltalk">//<span class="hljs-type"><span class="hljs-type">AverMedia</span></span> <span class="hljs-type"><span class="hljs-type">RM</span></span>-<span class="hljs-type"><span class="hljs-type">FR</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> amTVFM <span class="hljs-number"><span class="hljs-number">0xFE01</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> amPWR <span class="hljs-number"><span class="hljs-number">0xFF00</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> amB1 <span class="hljs-number"><span class="hljs-number">0xFA05</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> amB2 <span class="hljs-number"><span class="hljs-number">0xF906</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> amB3 <span class="hljs-number"><span class="hljs-number">0xF807</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#define</span></span> amB4 <span class="hljs-number"><span class="hljs-number">0xF609</span></span></code> </pre><br>  In the usbconfig.h file, the V-USB library settings.  I scooped information from <a href="http://we.easyelectronics.ru/electro-and-pc/usb-dlya-avr-chast-2-hid-class-na-v-usb.html">this article</a> . <br>  If you do not understand the USB protocol, then you can not touch anything there. <br>  Based program <b>main.c</b> <br><br>  We define the SetPinState macro, which installs the outputs to the desired position and sets the corresponding state of the bits of this output in the pinStates variable. <br>  We also determine the pins to which the peripherals are connected and the number of button correspondences to internal functions that we can store (MaxBtnMapings). <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/Usefull macroses #define SetPinState(Pin, State, bit) digitalWrite(Pin, State); if (State&gt;0) pinStates |=_BV(bit); else pinStates &amp;= ~_BV(bit); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/PORTB #define PWRPin 16 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ PC2 #define ledPin 9 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ PB1 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/PORTD #define PWRRelay1 6 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ PD6 #define PWRRelay2 5 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ PD5 #define MaxBtnMapings 15</span></span></code> </pre><br><br>  Variables (comments in the source did for myself, so they are mostly in clumsy English in the file :) <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ uint8_t ledState = 0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   uint8_t PWRRelay1State = 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   1 uint8_t PWRRelay2State = 1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  2 uint8_t PWRPinState=0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     uint8_t IRBtnL, IRBtnH; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,        uint8_t IREnabled=1; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     struct btn_mapping btn_mappings[MaxBtnMapings]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/-- uint8_t cmd; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    uint8_t pinStates=0x00; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    (0-PWRRelay1State, 1-PWRRelay2State) uint8_t cmdReceived=0; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  PC  () /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/IR variables uint16_t btn; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    uint16_t LastBtn=0x00; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/----------------- USB Section--------------------------- struct irpcdata_t pdata, pcdata; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/pdata - output buffer, pcdata - input buffer</span></span></code> </pre><br>  Received commands from the PC are stored in pcdata, sent - in pdata. <br><br>  Main loop <br><pre> <code class="hljs ruby">int main(void) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>Initialize ports DDRB = 0b0000001<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> PB1 -  DDRC = 0b0000010<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> PC2 -  DDRD = 0b0110000<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> PD5, PD6 -  /<span class="hljs-regexp"><span class="hljs-regexp">/clear btn mappings for (i=0; i&lt;MaxBtnMapings;i++){ btn_mappings[i].func=0; btn_mappings[i].btn_code=0; } loadStateFromEEPROM(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/USB Init &amp; connect cli(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Clear interrupts while perfoorming time-critical operations usbInit(); usbDeviceDisconnect(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,       ! uchar i = 0; while(--i){ /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  &gt; 250 ms _delay_ms(1); } usbDeviceConnect(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  sei(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/Timer1 Init for IR timer1_init(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ init IR timer loop(); return 0; }</span></span></code> </pre><br>  We adjust pins to which relays and an LED are connected as exits. <br>  We clear the correspondences of the buttons to the internal functions - is there any garbage in the memory when it is turned on? <br>  Load the byte of the relay states and the LED - pinStates and set them to the appropriate state in the loadStateFromEEPROM () function. <br>  Disable interrupts, disconnect from the PC, pause and let us detect.  Then enable interrupts. <br>  Prepare a timer to work with the IR receiver. <br>  We start the data processing cycle from the IR receiver and PC: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>() { // Main <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){ //    usbPoll(); //        ,     - <span class="hljs-number"><span class="hljs-number">50</span></span> ms <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cmdReceived) {processUSBcmd();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IREnabled) { remote_decode(); process_IR(); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre><br>  Everything is simple: <br><ul><li>  We are interested in the PC, if there was something for us. </li><li>  If the command was accepted, we process it in processUSBcmd () </li><li>  Further, if it is allowed to process IR control codes, we call the receive and decode function - this is the longest function in terms of execution. </li><li>  We process the code of the pressed button and write it down to transfer the PC when it asks. </li></ul><br>  When the PC wants to send us a packet, the usbFunctionWrite function is called when it requests a data packet ‚Äî the usbFunctionRead function. <br><br>  Let's sort them out: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">uchar</span></span> usbFunctionRead(uchar *<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, uchar len) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bytesRemaining</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bytesRemaining</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uchar</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">buffer</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uchar</span></span></span><span class="hljs-class">*)&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdata</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class">(!</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">currentAddress</span></span></span><span class="hljs-class">) //       . { //     </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">=</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">; //</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">last</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">received</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">switch</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmd</span></span></span><span class="hljs-class">){ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cmdGetIRPCState</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0]=</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pinStates</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[1]=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnH</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[2]=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnL</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">if</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IREnabled</span></span></span><span class="hljs-class">){ //</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clear</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IR</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">button</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">code</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnL</span></span></span><span class="hljs-class">=0; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnH</span></span></span><span class="hljs-class">=0; } break; case cmdGetIRBtnMapping: pdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[0]=pcdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[0]; pdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[1]=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn_mappings</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0]].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn_code</span></span></span><span class="hljs-class">&gt;&gt;8); pdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[2]=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn_mappings</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0]].</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">btn_code</span></span></span><span class="hljs-class"> &amp; 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xFF</span></span></span><span class="hljs-class">); pdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[3]=btn_mappings[pcdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[0]].func; break; } } uchar j; for(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">=0; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">len</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">j</span></span></span><span class="hljs-class">++) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[j] = buffer[j+currentAddress]; currentAddress += len; bytesRemaining -= len; return len; }</span></span></code> </pre><br>  First we fill in the pdata structure - if we were asked for the state of the device (cmdGetIRPCState), write the pinStates and the code of the pressed console button <br>  If you have requested one of the corresponding buttons for internal functions, we give it by taking the function number from the first byte of the packet sent by the PC (pcdata.data [0]) <br>  If the command is not recognized, we simply give the pdata structure - when processing commands, the results are written into it. <br>  Then we write our packet byte-wise by the pointer given in the <b>data</b> parameter. <br><br><pre> <code class="hljs vala"><span class="hljs-keyword"><span class="hljs-keyword">uchar</span></span> usbFunctionWrite(<span class="hljs-keyword"><span class="hljs-keyword">uchar</span></span> *data, <span class="hljs-keyword"><span class="hljs-keyword">uchar</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">uchar</span></span> *buffer = (<span class="hljs-keyword"><span class="hljs-keyword">uchar</span></span>*)&amp;pcdata; <span class="hljs-keyword"><span class="hljs-keyword">uchar</span></span> j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;len; j++) buffer[j]=data[j]; cmdReceived=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     return 1; }</span></span></code> </pre><br>  It is even simpler here - we simply rewrite the packet with data in pcdata, without understanding what's what, processUSBcmd () processing will be performed, and we need to return control as quickly as possible - the function causes an interrupt. <br><br>  And here, actually, it is: <br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">void</span></span> processUSBcmd(){ cmd=pcdata.cmd; switch(cmd) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cmdSetDigitalPinStates: //<span class="hljs-type"><span class="hljs-type">Get</span></span> pin states from <span class="hljs-type"><span class="hljs-type">USB</span></span> cmd <span class="hljs-type"><span class="hljs-type">PWRRelay1State</span></span>=(pcdata.<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[0] &amp; _BV(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1Bit</span></span></span><span class="hljs-class">)); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2State</span></span></span><span class="hljs-class">=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0] &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_BV</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2Bit</span></span></span><span class="hljs-class">)); ledState=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0] &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_BV</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledBit</span></span></span><span class="hljs-class">)); //</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Execute</span></span></span><span class="hljs-class"> cmd </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SetPinState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1Bit</span></span></span><span class="hljs-class">); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SetPinState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2Bit</span></span></span><span class="hljs-class">); break; case cmdGetIRPCState: if (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1State</span></span></span><span class="hljs-class">&gt;0) pinStates |=_BV(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1Bit</span></span></span><span class="hljs-class">); else pinStates &amp;= ~_BV(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1Bit</span></span></span><span class="hljs-class">); if (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2State</span></span></span><span class="hljs-class">&gt;0) pinStates |=_BV(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2Bit</span></span></span><span class="hljs-class">); else pinStates &amp;= ~_BV(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2Bit</span></span></span><span class="hljs-class">); if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledState</span></span></span><span class="hljs-class">&gt;0) pinStates |=_BV(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledBit</span></span></span><span class="hljs-class">); else pinStates &amp;= ~_BV(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledBit</span></span></span><span class="hljs-class">); break; case cmdGetIRBtn: pdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[1]=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnH</span></span></span><span class="hljs-class">; pdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[2]=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnL</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnL</span></span></span><span class="hljs-class">=0; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnH</span></span></span><span class="hljs-class">=0; break; case cmdSetLedState: ledState=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0] &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_BV</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledBit</span></span></span><span class="hljs-class">)); </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SetPinState</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledPin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledState</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ledBit</span></span></span><span class="hljs-class">); break; case cmdEnableIR: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IREnabled</span></span></span><span class="hljs-class">=1; break; case cmdDisableIR: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IREnabled</span></span></span><span class="hljs-class">=0; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnL</span></span></span><span class="hljs-class">=0xFF; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IRBtnH</span></span></span><span class="hljs-class">=0xFF; break; case cmdSetIRBtnMapping: btn_mappings[pcdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[0]].btn_code=(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint16_t</span></span></span><span class="hljs-class">)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[1]&lt;&lt;8)+pcdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[2]; btn_mappings[pcdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[0]].func=pcdata.</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">[3]; break; case cmdDoInternalFunc: switch (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pcdata</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">[0]){ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fRelay1Switch</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1State</span></span></span><span class="hljs-class">=!</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1State</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SetPinState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay1Bit</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">break</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fRelay2Switch</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2State</span></span></span><span class="hljs-class">=!</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2State</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SetPinState</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRRelay2Bit</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">break</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fPCPwrSwitch</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">digitalWrite</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRPin</span></span></span><span class="hljs-class">, 1); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_delay_ms</span></span></span><span class="hljs-class">(100); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">digitalWrite</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PWRPin</span></span></span><span class="hljs-class">, 0); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">break</span></span></span><span class="hljs-class">; } break; case cmdLoadFromEEPROM: loadStateFromEEPROM(); break; case cmdSaveToEEPROM: saveStatetoEEPROM(); break; } _delay_ms(5); cmdReceived=0; }</span></span></code> </pre><br>  Depending on the command received (its code in the pcdata.cmd field) we parse the pcdata.data package <br>  everything is pretty transparent here, I think. <br>  Having executed the command, we reset the cmdReceived flag. <br><br>  In the process_IR () function we collect the 16-bit code of the button: <br><pre> <code class="hljs pgsql"> // button code <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-type"><span class="hljs-type">bit</span></span> btn=(adrH_code &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) + adrL_code;</code> </pre><br>  If the code is not equal to 0, then something was pressed, save for transferring the PC and set the flag to light the LED - show that we saw the button pressed. <br><pre> <code class="hljs objectivec"> <span class="hljs-comment"><span class="hljs-comment">//Button pressed if (btn&gt;0x00) { LastBtn=btn; IRBtnL=adrL_code; IRBtnH=adrH_code; ledState=1; }</span></span></code> </pre><br>  Then I process the codes for the buttons on my remote control: <br><pre> <code class="hljs bash"> //Button is <span class="hljs-string"><span class="hljs-string">"Power"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((btn==ykPWR) || (btn==amPWR)) { PWRPinState=1; } switch (LastBtn){ // <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ykB1: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> amSNAPSHOT: PWRRelay1State=!PWRRelay1State; SetPinState(PWRRelay1, PWRRelay1State, PWRRelay1Bit); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ykB2: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> am16CH: PWRRelay2State=!PWRRelay2State; SetPinState(PWRRelay2, PWRRelay2State, PWRRelay2Bit); <span class="hljs-built_in"><span class="hljs-built_in">break</span></span>; }</code> </pre><br>  On the "Power" button, I press the PC power button until the remote control button is released. <br>  Two other buttons switch the status of the relay. <br><br>  Then we check the array of assigned correspondences of button codes to internal functions ‚Äî this is for use with other consoles, correspondences are set with the PC by cmdSetIRBtnMapping commands ‚Äî one command per button.  We have seen the processing of this command above in processUSBcmd () <br><pre> <code class="hljs matlab"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>&lt;MaxBtnMapings;<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (btn==btn_mappings[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>].btn_code) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (btn_mappings[<span class="hljs-number"><span class="hljs-number">1</span></span>].func){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> fRelay1Switch: PWRRelay1State=!PWRRelay1State; SetPinState(PWRRelay1, PWRRelay1State, PWRRelay1Bit); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> fRelay2Switch: PWRRelay2State=!PWRRelay2State; SetPinState(PWRRelay2, PWRRelay2State, PWRRelay2Bit); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> fPCPwrSwitch: digitalWrite(PWRPin, <span class="hljs-number"><span class="hljs-number">1</span></span>); _delay_ms(<span class="hljs-number"><span class="hljs-number">100</span></span>); digitalWrite(PWRPin, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><br>  In general, the main thing is to have time to quickly process interruptions and periodically poll the IR receiver and call usbPoll, otherwise the PC will lose us - ‚ÄúUSB device not recognized‚Äù. <br>  The version is designated as alpha for good reason - there are several pieces, as you have noticed, where the binding to a specific console has not been commented out yet, because the setting of the mapping of buttons and functions from the PC has not yet been written, it did not.  Well, sometimes it happens that the device stops receiving commands from the PC, although it is visible in the system and responds to the buttons on the remote.  I suspect that this is due to the long duration of the survey of the IR receiver, this should be optimized.  However, it happens rarely and does not cause any inconvenience. <br><br>  Now go to the program for the PC. <br>  I will focus on the key points so that you can understand the source code. <br>  Let me show you with an example plugin for MKey - it's easier to figure it out. <br>  The plugin is written in Delphi7 because it turned out that MKey does not support unicode, and in Delphi 2010 with ANSI you need to mess around further. <br>  From additional libraries only JVCL is used. <br><br>  The main work is done in the uHID.pas module <br>  It defines the same command constants as in the device, I will not duplicate them. <br>  The same record describing the package, with one addition - the reportID - we do not support it and there is always 0 there, but in general there may not be only one device.  We just lack one. <br>  Additional constants only id devices - Vendor ID (Vid), Product ID (Pid) and DeviceName.  By Vid and Pid, ‚Äã‚Äãwe will search our connected HID devices. <br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-comment"><span class="hljs-comment">//USB-IRPC IDs Vid=$16C0; Pid=$05DF; DeviceName='USB-IRPC'; //PC&lt;-&gt;IRPC TIRPCReport= packed record reportID:byte; //not used, shoud be 0 cmd:byte; data: array [0..3] of byte; end;</span></span></code> </pre><br><br>  All functions of communication with the device are collected in the classroom. <br><pre> <code class="delphi hljs"> TIRPC=<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dev:TJvHidDevice; HID:TJvHidDeviceController; fIRButtons:TStringList; fIRName:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; fIRLoaded:boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsConnected</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connect</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Disconnect</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadIRPCState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Report:TIRPCReport)</span></span></span><span class="hljs-function">:</span></span>boolean; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteIRPCcmd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmd:TIRPCReport)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadIRcodes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(irFile:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BtnName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(btnCode:word)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BtnName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(btnCode:</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Connected:boolean <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> IsConnected; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Device:TJvHidDevice <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> Dev; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> IRButtons:TStringList <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> fIRButtons; <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> IRName:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> fIRName; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  The Dev field is a pointer to the device class, we get it when it is successfully connected to the device (Connect). <br>  when disconnected (Disconnect) it is set to nil. <br><br>  The methods are very simple, so I‚Äôll show one for an example, the rest are about the same order of complexity: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIRPC</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Connect</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(dev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; HID.CheckOutByID(Dev,VID,Pid); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  The connection status (the Connected property) is determined by the Dev pointer ‚Äî if it is not empty, then the connection was successful. <br><br>  The WriteIRPCcmd method (cmd: TIRPCReport) sends a packet with a command that you pre-fill to the device. <br>  Method ReadIRPCState (var Report: TIRPCReport): boolean parses the package from the device.  If the packet was successfully received, returns true, and the packet itself will be written into the Report parameter. <br><br>  procedure LoadIRcodes (irFile: string);  - loads the correspondence file of the names of the buttons of the remote control to their codes.  The file has a simple format: each line contains a comma separated button name and code <br>  TVFM, $ FE01 <br>  In the plugin, this method is not claimed - the button code is transferred to Mkey, you yourself call it what you want, because the program does not show what you sent to it.  But in your program, you can display normal human button names. <br>  BtnName functions return the name of a button by a code transmitted in the form of a 16-bit value or a string with a hex. <br>  function BtnName (btnCode: word): string; overload; <br>  function BtnName (btnCode: string): string; overload; <br>  IRButtons property contains a list of buttons and their codes. <br>  property IRButtons: TStringList read fIRButtons; <br>  IRname property is the name of the console loaded by the LoadIRcodes method (the file name without the .ir extension). <br>  property IRName: string read fIRName; <br><br>  How to get the package from the device? <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIRPC</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadIRPCState</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result:=false; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> Assigned(dev) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; Result:=dev.GetFeature(report,sizeof(TIRPCReport)<span class="hljs-comment"><span class="hljs-comment">{Dev.Caps.FeatureReportByteLength}</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  Using the GetFeature method, we pass the buffer for the packet, we get the packet into it.  If there is no connection, the method returns False. <br>  The package is transferred to the device in the same way: <br><pre> <code class="delphi hljs"> dev.SetFeature(cmd,SizeOf(cmd));</code> </pre><br><br>  Actually the plugin itself is designed as a dll. <br>  The required functions are implemented: <br>  Enable, Disable, GetName, GetInfo, GetVer, GetAuthor, IsInteractive, IsHaveSettings; <br>  Accordingly, in Enable we connect to the device using the Connect method, start the timer, which will poll the device every 500 ms with ReadState and, if it received the button code, give it to MKey: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Enable</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> IRPCPlugin:=TIrPCPlugin.Create; IRPCPlugin.IRPC.Connect; tmrReadState:=TTimer.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); tmrReadState.Interval:=<span class="hljs-number"><span class="hljs-number">500</span></span>; tmrReadState.OnTimer:=IRPCPlugin.ReadState; tmrReadState.Enabled:=true; result:=true; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TIRPCPlugin</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mainWnd:hWnd; pluginact:<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; Btn:Word; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> IRPCPlugin.IRPC.Connect; <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> IRPCPlugin.IRPC.Connected <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> MessageBox(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">'IRPC device not connected'</span></span>, <span class="hljs-string"><span class="hljs-string">'IRPC'</span></span>, MB_ICONEXCLAMATION); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rep.cmd&lt;&gt;cmdGetIRPCState <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> rep.cmd:=cmdGetIRPCState; IRPCPlugin.IRPC.WriteIRPCcmd(rep); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; IRPCPlugin.IRPC.ReadIRPCState(rep); Btn:=rep.data[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>+rep.data[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">If</span></span> btn&lt;&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pluginact:=Format(<span class="hljs-string"><span class="hljs-string">'%x'</span></span>,[Btn]); mainwnd:=Findwindow(<span class="hljs-string"><span class="hljs-string">'TMainForm'</span></span>, <span class="hljs-string"><span class="hljs-string">'MKey'</span></span>); SendMessage(mainwnd, WM_PLUGIN, plugin_interface_version, DWORD(PChar(pluginact))); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br>  In the Disable procedure, we disconnect from the device: <br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Disable</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">stdcall</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> IRPCPlugin.IRPC.Disconnect; FreeAndNil(IRPCPlugin); FreeAndNil(tmrReadState); result:=true; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre><br><br>  The uHID module of the plugin and the full control program are identical. <br>  I have laid out the main program so far in compiled form, I don‚Äôt upload the source code, because there is a work on the functionality, there is a mess there :) As a more or less decent option, I'll put it in <a href="http://code.google.com/p/r-usb-irpc/downloads/list">Downloads</a> . <br>  So far it looks like this: <br><img src="http://habrastorage.org/storage2/312/248/09d/31224809d376c65b6fc966823820e260.png" alt="image"><br><ul><li>  Minimizes to the notification area. </li><li>  At the click unfolds. </li><li>  The polling period is configured in Settings </li><li>  S - state saving in EEPROM </li><li>  L - load status from EEPROM </li><li>  Power Btn - performs the function fPCPwrSwitch (that is, presses the power button on the PC) </li><li>  Show log will show a list of events - sleep / wake up PC.  (I have the power button sends to Sleep). </li><li>  The rest is test buttons. </li><li>  Clicking on one of the three light bulbs, switch accordingly - the LED, Relay1, Relay2 (tooltips will help you figure it out) </li></ul><br><br>  It seems all important told.  If you have any questions, ask in the comments, I will try to answer. <br><br><h4>  Sources </h4><br><ul><li>  <a href="http://code.google.com/p/r-usb-irpc/downloads/detail%3Fname%3DUSB-IRPC%2520firmware%2520v2.0a.rar">USB-IRPC firmware sources</a> </li><li>  <a href="http://code.google.com/p/r-usb-irpc/downloads/detail%3Fname%3DUSB-IRPC%2520HW%2520Distrib.rar">Schematic diagram, printed circuit board, sticker, picture-crib for assembly</a> in DipTrace and png formats. </li><li>  <a href="http://code.google.com/p/r-usb-irpc/downloads/detail%3Fname%3DR%2520MKey%2520IRPC.rar%26can%3D2%26q%3D">MKey plugin sources</a> </li><li>  <a href="http://code.google.com/p/r-usb-irpc/downloads/detail%3Fname%3DUSB-IRPC.rar%26can%3D2%26q%3D">Management program - alpha version</a> on Delphi 2010. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/152034/">https://habr.com/ru/post/152034/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152024/index.html">Centralized logging from network equipment consoles via ssh</a></li>
<li><a href="../152025/index.html">My "paradigm" of working with threads</a></li>
<li><a href="../152028/index.html">7,100 employees work on the Google Maps project.</a></li>
<li><a href="../152030/index.html">IPhone 5 Review - Habrahabr Edition</a></li>
<li><a href="../152031/index.html">A small review of the large computer Acer Predator</a></li>
<li><a href="../152035/index.html">Programmers playing economics</a></li>
<li><a href="../152036/index.html">Simulation of the will in artificial intelligence</a></li>
<li><a href="../152038/index.html">InterSystems Grant Program</a></li>
<li><a href="../152039/index.html">Publishing the application in the Windows Store</a></li>
<li><a href="../152040/index.html">Raspberry Pi + Motorola LapDock + Hacks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>