<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of MMO RPG - a practical guide. Server (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Implementing AI: how to make it as simple as possible? 
- RPC client-server: json or binary "self-patch"? 
- Asynchronous sockets or multi-threaded ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of MMO RPG - a practical guide. Server (Part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/22d/e05/6ce/22de056ce0de4e719c0d70c70896562b.PNG" alt="Rorurs Lithium" align="left"><ul><li>  Implementing AI: how to make it as simple as possible? </li><li>  RPC client-server: json or binary "self-patch"? </li><li>  Asynchronous sockets or multi-threaded architecture? </li><li>  Caching objects at the application level or more memory for the DBMS? </li><li>  Working with a database without Reflection API: Is it really that difficult? </li></ul><br>  Today we will continue to look at the architecture and features of the implementation of the game backend in C ++ for online games on the example of MMO RPG <a href="http://starghosts.com/index.php%3Ftrsrc%3D108%26trclcl%3D1%26tringame%3D1"><b>"Star Ghosts"</b></a> .  This is the second part of the article about the server, the beginning can be read <a href="http://habrahabr.ru/company/starnigames/blog/257985/">here</a> . <br><a name="habracut"></a><br><h3>  <b>AI module.</b> </h3><br>  An AI implementation is usually a rather complicated process.  But we managed to do it with ‚Äúlittle blood‚Äù primarily due to the use of Actions.  In fact, AI represents a finite state machine that can fly somewhere, collect resources, attack other spacecraft and move between systems.  At the time AI was created, the implementation of all these actions was already in Actions to control the player‚Äôs ship.  That is, all TBaseAI writing is the creation of loading data from a database for a finite state machine and this automaton from several actions, which is quite simple to implement. <br>  Some difficulties appeared only after the introduction of monsters such as "Boss", "Golden Boss" and "Queen Roy".  They have specific skills that are available only to them.  The implementation of these skills is entirely in their AI classes (TBossBaseAI, TGoldenBossAI, and TMotherOfNomadAI). <br>  Also for AI, I had to create a TAISpaceShip class, a descendant from TSpaceShip, which contains an instance of TBaseAI and calls TBaseAI :: Update from its Update. <br>  AI should receive messages about what is happening, for example, that he was attacked.  To do this, we made it a descendant of ISpaceShipNotifyReciver and TSpaceShip sends it the necessary data.  In other words, the right architectural solution allowed us to completely unify the communication of the Space module with the ship owner, be it a player or an AI. <br>  In conclusion, I cite the class diagram in Figure 4 (for greater clarity, the diagram is somewhat simplified). <br><br><img src="https://habrastorage.org/files/0e0/fb9/382/0e0fb9382d4d435e8ddffc643ff7a347.png" alt="AI module class diagram"><br><br><h3>  <b>Quest module.</b> </h3><br>  At the stage of choosing the implementation of the quest system, the first thought was to use some kind of scripting language like LUA, which would allow ‚Äúto write anything.‚Äù  But to work with LUA, it is still necessary to export methods and callbacks to the LUA machine itself, which is very inconvenient and leads to writing a lot of additional code that does nothing except as a mediator.  Considering that the quest system is very simple (as a result, we have only 25 teams), there can be no more than one quest at the same time, there are no branches in the quests, we decided to do our own parser of quests.  Here is an example from the quest prolog file tutor.xmq: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">show</span></span> reel <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> flyto <span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-number"><span class="hljs-number">-1900</span></span> insys StartSystem <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> reel <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> flyto <span class="hljs-number"><span class="hljs-number">950</span></span> <span class="hljs-number"><span class="hljs-number">-1450</span></span> insys StartSystem <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">show</span></span> reel <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> spawn_oku ship <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">000</span></span>_nrds near_user <span class="hljs-number"><span class="hljs-number">-400</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> insys StartSystem</code> </pre> <br>  Offhand, everything is clear: show movie 1, fly to a point with coordinates 1000; -1900 in the launch system, then show movie 2, etc.  The file is so simple that we even managed a game designer to teach him to edit and complete quests and balance the parameters he needs. <br>  Architecturally it looks like this.  There is a TQuestParser class that actually parses the quest files and contains a factory for the descendant classes of TQuestCondition.  For each team there is a descendant from TQuestCondition, which implements the necessary functionality.  At the same time, the quest command classes themselves do not contain any data (except for those loaded directly from the quest file), all their methods are declared as const.  The data is contained in the TQuest class.  This allows you to contain only one copy of the quest teams, "slipping" their necessary data specific to a particular user (for example, how many he has killed nomads of a given type).  It also simplifies saving quest data in the database - they are all collected in one place. <br>  The TQuest object owner object must implement the IQuestUser interface (which contains commands such as AddQuestMoney, for example) and must report events to TQuest (for example, when any ship is destroyed, a message with its signature is sent to TQuest so that the quest team can compare Is this the ship that needed to be destroyed).  TQuest, however, forwards this event directly to the quest team, and if the quest team has ended, it proceeds to the next team. <br>  In general, this module is as simple as it even makes no sense to give it a class diagram :). <br><br><h3>  <b>RPC client &lt;-&gt; server (and Packets module).</b> </h3><br>  When designing a network subsystem, the first desire was to use json or AMF (because the client is on a flash, and this is the native binary flash format).  Almost immediately both of these ideas were discarded: the game is in real time and a TCP connection is used, so it is necessary to minimize the size of the packet so that the chance of packet loss (and its retransmission, TCP is after all :) minimal.  Packet loss in TCP and its retransmission is a rather long process that can lead to lags.  Of course, this wanted to be avoided.  The second, equally important point is the limited bandwidth capacity of the network card.  This may seem ridiculous, but I had to do an audit of one game, in which, because of the use of json and the polling-based system, rather than event-based, the developers rested precisely on the bandwidth of the network card.  And after that, all the readable and beautifully named fields in json had to be called in the style of A, B, etc.  in order to minimize the size of the package.  As for AMF, this is a closed format from Adobe, so we decided not to get involved with it - you never know what they decide to change, and then look for the problem. <br>  As a result, we have implemented a very simple package format.  It consists of a header containing the full length of the packet and the type of packet.  But you still need the code that will package / unpack the data structures themselves to / from the binary type, as well as signal incoming packets.  And do it the same way on the server and on the client.  Writing the whole bunch of code with your hands in two languages ‚Äã‚Äã(client and server), and then maintaining it is too troublesome.  Therefore, we wrote a script on PHP that takes XML describing all the packages and generates the necessary classes for the client and server.  In addition to generating the actual classes of the packages themselves and serializing them, another special additional class TStdUserProcessor is generated for the server.  This class contains callbacks for each type of packet (which allows you to centrally manage the types of packets received at this stage of work), and each callback creates an instance of the package class and loads binary data into it, after which the handler calls it.  In code, it looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClientLoginPacket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TClientLoginPacket&amp; val)</span></span></span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnClientLoginPacketRecived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TByteOStream&amp; ba)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> TStdUserProcessor::OnClientLoginPacketRecived(TByteOStream&amp; ba) { TClientLoginPacket p; ba&gt;&gt;p; OnClientLoginPacket(p); }</code> </pre><br>  That is, for the descendant class from TStdUserProcessor, a transparent ‚Äúclient &lt;-&gt; server‚Äù bridge is implemented, where sending a packet from a client is a simple method call to TUserProcessor. <br>  And who causes these callbacks?  TStdUserProcessor is a descendant from the TBaseUserProcessor class, which executes m_xSocket.Recv, as well as splits the binary stream into packets, finds the packet type in the header and finds the necessary callback for this type.  It looks like this: <br><br><pre> <code class="hljs coffeescript">void TStdUserProcessor::AddCallbacks() { AddCallback( NNNetworkPackets::ClientLogin, &amp;TStdUserProcessor::OnClientLoginPacketRecived ); } void TBaseUserProcessor::RecvData() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !m_xSocket || m_xSocket-&gt;State()!=NNSocketState::Connected ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !m_xSocket-&gt;AvailData() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; m_xReciver.RecvData(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !m_xReciver.IsPacketRecived() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         ,  <span class="hljs-string"><span class="hljs-string">""</span></span>    int type = m_xReciver.Data()-&gt;Type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( type&gt;=int(m_vCallbacks.size()) ) _ERROR(<span class="hljs-string"><span class="hljs-string">"NoCallback for class "</span></span>&lt;&lt;type); SLocalCallbackType cb = m_vCallbacks[type]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cb==NULL) _ERROR(<span class="hljs-string"><span class="hljs-string">"NoCallback for class "</span></span>&lt;&lt;type); TStdUserProcessor* c_ptr = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TStdUserProcessor*)</span></span></span><span class="hljs-function">this; const uint8* data_ptr = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(const uint8*)</span></span></span><span class="hljs-function">m_xReciver.Data</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; data_ptr += sizeof</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TNetworkPacket)</span></span></span><span class="hljs-function">; TByteOStream byte_os</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( data_ptr, m_xReciver.Data()-&gt;Size-sizeof(TNetworkPacket) )</span></span></span><span class="hljs-function">; if</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( m_xIgnoreAllPackets==</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*c_ptr.*cb)( byte_os )</span></span></span><span class="hljs-function">; } m_xReciver.ClearPacket</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; }</span></span></code> </pre><br><br><h3>  <b>Socket model</b> </h3><br>  Now we will talk, perhaps, about the most interesting - about the used socket model.  There are two "classic" approaches to working with sockets: asynchronous and multi-threaded.  The first one is generally faster than multi-threaded (because there is no context switch for the stream) and there are fewer problems with it: everything is in one stream and no problems with data out-of-sync or dead locks.  The second gives a faster response to a user action (if not all resources are eaten by a large number of threads), but carries a lot of problems with multi-threaded data access.  None of these approaches did not suit us, so we chose a mixed model - asynchronous-multi-threaded.  I will explain in more detail. <br>  <a href="http://starghosts.com/index.php%3Ftrsrc%3D108%26trclcl%3D1%26tringame%3D1"><b>"Star Ghosts"</b></a> - a game about space, so the game world is divided into locations initially.  Each solar system is a separate location, moving between systems takes place with the help of hyper-gates.  This division of the game world and we suggested an architectural solution - a separate stream is allocated to each solar system, work with sockets in this stream is performed asynchronously.  Also, several threads are created for servicing the planets and transition states (hyperspace, data loading / unloading, etc.).  In fact, hyper-jump is the movement of a user object from one thread to another.  Such an architectural solution makes it possible not only to scale the system easily (up to the separation of a separate server for each solar system), but also greatly simplifies the interaction of users within the same solar system.  But it is flying and fighting in space for the game are critically important.  The bonus is the automatic use of multi-core architecture and the almost complete absence of synchronization objects - players from different systems practically do not interact with each other, and, being in the same system, they are in the same thread. <br><br><h3>  <b>Work with the database.</b> </h3><br>  In <a href="http://starghosts.com/index.php%3Ftrsrc%3D108%26trclcl%3D1%26tringame%3D1"><b>"Star Ghosts"</b></a> all player data (and indeed all data) are stored in memory until the end of the session.  And saving to the database takes place only at the moment when the session ends (for example, when a player leaves the game).  This can significantly reduce the load on the database.  Also, the TSQLObject object checks the change of fields and makes UPDATE only to actually changed fields.  It is implemented as follows.  When loading from the database, a copy of all the loaded data in the object is created.  When you call SaveToDB (), it checks which fields are not equal to the values ‚Äã‚Äãoriginally loaded, and only they are added to the query.  After performing UPDATE in the database, copies of the fields are also updated with new values. <br>  MySQL runs the INSERT command longer than the UPDATE command, so we sought to reduce the number of INSERTs.  In the first implementation of storing user data in the database, data on all items in the database was erased and re-entered.  Very quickly, players accumulated hundreds (and some thousands) of items, and such an operation became very expensive and long.  Then the algorithm had to be changed - do not touch unchanged objects.  In addition, new objects that need to do INSERT, immediately try to find a place in the subscribed to delete, in order not to call the INSERT / DELETE pair, but to execute an UPDATE. <br>  Separately, you need to say about writing the value "NULL" in the database.  Due to the implementation features of our TSQLObject, we cannot write and read "NULL" to / from the database.  If a field in the class is of type ‚Äúint‚Äù, then ‚ÄúNULL‚Äù will be written into it as ‚Äú0‚Äù and, accordingly, exactly ‚Äú0‚Äù will appear in the UPDATE query in the database (and not ‚ÄúNULL‚Äù, as it should be).  And this can lead to problems - either the data will be wrong, or, if this is a foreign key database field, the request will be generally erroneous.  To solve this problem, we had to add BEFORE UPDATE TRIGGERs to the required tables, which would make ‚Äú0‚Äù NULL. <br><br><h3>  <b>Saving / loading objects to / from the database.</b> </h3><br>  One of the problems with C ++ is the inability to find out at runtime the string names of the fields and refer to them by the string name.  For example, in ActionScript, you can easily find out the names of all the fields of an object, call any method, or access any field.  This mechanism allows you to significantly simplify work with the database - you do not need to write a separate code for each class, the maximum is to list the list of fields that you need to save / load to / from the database, and in which table to do it.  Fortunately, C ++ has such a powerful mechanism as a template, which, together with &lt;cxxabi&gt;, allows us to solve the problem of the lack of Reflection API applied to the task of working with the database. <br><br>  Using our Reflection library (we will analyze it below) looks like this: <br><ol><li>  It is necessary to inherit from the class TSQLObject. </li><li>  It is necessary in the descendant class itself to write in the public section DECL_SQL_DISPATCH_TABLE ();  (this is a macro). </li><li>  In the .cpp file of the descendant class, list which fields of the class to which fields of the table are displayed, as well as the name of the class itself and the name of the table in the database.  Using the example of the TDevice class, it looks like this: <br><br><pre> <code class="hljs lisp">BEGIN_SQL_DISPATCH_TABLE(<span class="hljs-name"><span class="hljs-name">TDevice</span></span>, device) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">PrototypeID</span></span>, m_iPrototypeID) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">SharpeningCount</span></span>, m_iSharpeningCount) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">RepairCount</span></span>, m_iRepairCount) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">CurrentStructure</span></span>, m_iCurrentStructure) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">DispData</span></span>, m_sSQLDispData) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">MicromoduleData</span></span>, m_sMicromodule) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">AuthorSign</span></span>, m_sAuthorSign) ADD_SQL_FIELD(<span class="hljs-name"><span class="hljs-name">Flags</span></span>, m_iFlags) END_SQL_DISPATCH_TABLE()</code> </pre><br></li><li>  Now, at run time, you can call the methods void LoadFromDB (int id), void SaveToDB () and void DeleteFromDB ().  During the call, the corresponding SQL queries will be generated for the database device table and the data from the fields specified in subclause 3 will be loaded / saved. </li></ol><br><br>  All Reflection work is not based on the following ideas: <br><ol><li>  Using the pointer to the field, using &lt;cxxabi&gt;, you can get a string name for the type of this field.  As well as for the class - a list of its ancestors. </li><li>  If we create a pointer to an object, equate it to 0 and take a pointer to the field from this pointer, we get the offset of this field relative to the pointer to the object.  Of course, this may not work if you use virtual inheritance, so you should apply Reflection to such classes with caution. </li><li>  Using the same template class, for any type that has the new, delete, =, and == operators defined, create a factory that can create, delete, assign, and compare objects of this type.  Add an ancestor to this factory with virtual methods that take a pointer to an object, but not typed, but of type void *, and static_cast in the template itself, which will lead the transferred void * to a pointer to the type with which the factory operates.  And we will get the opportunity to operate with objects without knowing their type. </li></ol><br><br>  Now look inside the macro. <br><br>  The macro DECL_SQL_DISPATCH_TABLE () does the following: <br><ul><li>  virtual const string &amp; SQLTableName ();  - overload of the corresponding method from TSQLObject </li><li>  static void InitDispatchTable ();  - the method of initializing the data needed by Reflection to work with this object </li></ul><br><br>  Macro BEGIN_SQL_DISPATCH_TABLE (ClassType, TableName);  does the following: <br><ul><li>  Implements the SQLTableName () method; </li><li>  Declares the static class TCallFunctionBeforMain, which in the constructor calls InitDispatchTable.  The task of such a construction is to initialize the data necessary for Reflection before entering int main (), and also to get rid of the need to manually register in the int main () call of all InitDispatchTable from all classes. </li><li>  Creates an object factory </li><li>  Declares the variable ClassType * class_ptr = 0;  (used in ADD_SQL_FIELD macros). </li></ul><br><br>  Macro ADD_SQL_FIELD (VisibleName, InternalName);  does the following: <br><ul><li>  Calculates the offset field from the beginning of the object. </li><li>  Adds to the list of fields of this object the offset of the field, the visible (external) name for it and the string name of the field type. </li></ul><br><br>  Behind the scenes, the creation of the actual type factory and the creation of converters string &lt;-&gt; object, as well as the storage location of all the Reflection data.  For storage there is a class singleton TGlobalDispatch.  The same class in its constructor initializes factories and string converters for most simple types. <br>  The work of TSQLObject is based on the idea that using &lt;cxxabi&gt; you can get the actual string name of the object at run time.  By this name, request from TGlobalDispatch a list of all published fields of this class and its ancestors.  The table name can be obtained by calling SQLTableName ().  String converters for fields will also provide TGlobalDispatch.  Now it is not difficult to create the necessary SQL query and load / unload the object. <br><br><h3>  <b>DB and ID items.</b> </h3><br>  All items in the game have a unique ID that allows you to identify the item.  But saving data to the database occurs only at the end of the session, and the item can be created at any time.  How to deal with the item ID?  You can remove the data integrity check at the database level (disable AUTO_INCREMENT and PRIMARY KEY) and generate unique keys at the C ++ level.  But this is a bad way.  First, you will not be able to add / pick up / view player items through the PHP admin panel; you will need to write some additional code in C ++ to do this.  And, secondly, the probability of an error in your server is significantly higher than in a DBMS.  As a result, data errors may lose integrity (after all, integrity is now not controlled by the database).  And then this integrity will have to be restored manually, under the general howl of the players, ‚ÄúI have lost a super-gear, which I knocked out today‚Äù.  In general, the ID of the saved object in the database must be equal to the unique ID of the item in the game.  And back to the question: where to get this ID from the newly created item?  You can, of course, immediately save the item in the database, but this is contrary to the idea of ‚Äã‚Äã‚Äúeverything in memory, saving at the end of the session‚Äù and, most importantly, will cause the flow to stop, in which more than one user can be, before the end of the save.  And the stop can exceed the very maximum response time of the server to the player's actions (50ms), which is specified in the statement of work.  Asynchronous saving pulls other problems behind itself: for some time we will have an object without an ID. <br>  The idea of ‚Äã‚Äãsolving the problem with the ID appeared fairly quickly.  ID is set to type "int".  All items stored in the database have an ID greater than zero, and all newly created items have less.  Of course, this means that at some point in time the object ID will change and this could lead to problems.  Could, if the subject lived on.  But the preservation occurs at the moment when the session ends, when the objects are already in the queue for destruction and nothing can be done with them. <br><br><h3>  <b>The game "about the elves."</b> </h3><br>  Suppose we need to make a game in which the player has a character that he can dress, have skills, have magic, you can brew potions, a character can run around locations and kill other characters, get levels and trade with other characters.  What needs to be done with the current <a href="http://starghosts.com/index.php%3Ftrsrc%3D108%26trclcl%3D1%26tringame%3D1"><b>Star Ghost</b></a> server to create the required? <br><br>  Rename TShip to TBody and this will be any bird with HP that can be attacked, be it a PC or NPC.  TDevice and leave - it will be a subject that can be put on the carcass (ring, cloak, dagger, etc.).  We will rename micromodules into runes, and they will be able to enhance the clothing they wear.  TAmmoPack, too, so we leave - after all, an elf can have a bow, and the bow needs arrows.  TGoodsPack is also unchanged - these are any resources, and after all, the witches need all sorts of flowers and roots of mandrake for cooking potions.  It remains only to resolve the issue with magic.  Add one dynamic parameter Mana to the carcass (TBody), create a TSpellProto and TSpell class, as well as a TSpellBook class, descendant from TCargoBay.  Only TSpell can be put into TSpellBook, and TSpellBook itself can be added to TBody.  The ability to cast spells is a method similar to TShip :: FireSlot.  Now we can create an elf or dragon (or a boar or whoever we need), dress him up and ‚Äúwrite‚Äù spells in his spell book.  In fact, all changes in this module are reduced to renaming classes and a small revision to add magic. <br><br>  Rename the Space module to World, and the TSystem class to TLocation.  Moving between locations will do with teleports.  Teleport, you guessed it, is a former TStarGate.  Next, rename TSpaceObject to TWorldObject, and TSpaceShip to TWorldBody.  Now our elf (or dragon) has current coordinates and can be given a command to move.  True, he does not check the obstacles, but when turning, he cuts circles and tries to make a ‚Äúbarrel‚Äù.  The logic of the behavior of TSystem and movement teams will have to be completely redone, and this will be the most costly and difficult part of the work of adapting the server to the game about elves. <br><br>  If the Space module has been reworked including the Actions, the AI ‚Äã‚Äãmodule will work almost immediately, but without using magic.  If NPCs must use magic, then they will have to add a code similar to the use of special weapons at the TBaseAI level. <br><br>  Quest module will be slightly modified, provided that the quest system is not changed.  Maximum - you have to change something in the spawn of objects in space (or rather, already in the location). <br><br>  Module Main and Packets will remain virtually unchanged.  There will be added some packages for the use of magic, the hangar will be removed and that‚Äôs all.  Replacing crafting recipes, buff types, etc.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is all game design work, performed through the admin panel and has no relation to programming. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all, the server for the game about elves is ready. </font><font style="vertical-align: inherit;">It remains only to wait six months, until they draw the graphics and make the client :).</font></font></div><p>Source: <a href="https://habr.com/ru/post/260911/">https://habr.com/ru/post/260911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260895/index.html">How I painted the design of the application for the contest Mail.Ru Group</a></li>
<li><a href="../260897/index.html">Small joys of structured metadata</a></li>
<li><a href="../260899/index.html">Introduction to the magic of patterns</a></li>
<li><a href="../260903/index.html">Snowden: NSA is spying on foreign antivirus companies</a></li>
<li><a href="../260907/index.html">Google implements proprietary code in free (?) Chromium</a></li>
<li><a href="../260913/index.html">PentestBox - portable assembly of popular security utilities</a></li>
<li><a href="../260917/index.html">Ansible and ChatOps or how to manage 100+ servers from the chat</a></li>
<li><a href="../260919/index.html">The results of the distribution boards. Upgrade stock good</a></li>
<li><a href="../260923/index.html">Access rights - the owner can do anything</a></li>
<li><a href="../260927/index.html">What is Master Data and why is it needed?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>