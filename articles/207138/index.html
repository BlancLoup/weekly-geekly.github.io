<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>School bell on Raspberry Pi with remote control</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear habrovchane. It is no secret that single-board Linux computers based on SoC today are widespread among both amateurs and more or less p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>School bell on Raspberry Pi with remote control</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/161/392/522/161392522a8c76409f763323d0383784.png" align="left">  Good day, dear habrovchane.  It is no secret that single-board Linux computers based on SoC today are widespread among both amateurs and more or less professional users.  More and more tasks can be solved with the help of microcomputers, and even those tasks that were previously solved solely with the help of microcontrollers.  It would seem that the use of a full-fledged, albeit small, computer for solving simple tasks is one more overkill, but let's see, is this so bad?  This article is the answer to our small <a href="http://habrahabr.ru/post/206782/">dispute</a> with devzona <a href="https://habrahabr.ru/users/devzona/" class="user_link">habrovchanin</a> about this. <br><a name="habracut"></a><br><h4>  Prehistory </h4><br>  It would seem that there could be a more obvious niche for the use of microcontrollers than the automation of the school bell?  This is exactly what an unknown developer thought about 5-7 years ago when he assembled such a wonderful device. <br><img src="https://habrastorage.org/getpro/habr/post_images/cfa/de7/363/cfade7363a149cc51af7ce89d4493a67.jpg" align="right"><br>  Apparently, collected on the MK Series 8050, has on board a real-time watch, can show this time on a self-made LED matrix, and most importantly, it can pull the rail from time to time, including the school bell.  The device has been working successfully for many years, there were no complaints about it.  However, everything is flowing and changing, and once a simple Kharkov school with an in-depth study of something there decided to undergo re-certification in the lyceum with an even more in-depth study of the very same.  Such re-certification, among other things, requires a transition from 45-minute lessons to couples, consisting of two academic hours of 40 minutes.  This is where the trouble came.  The developer of the watch on the MK safely <s>drank himself</s> went abroad, did not leave the source code, did not provide for the possibility of reconfiguration.  It was with this problem that my friend Kostya knocked me on Skype one autumn day. <br><br>  After examining the patient, it became clear that in less than a couple of weeks he would not be able to alter it to the requirements of the customer.  In fact, you need to rewrite the code from scratch.  And, suddenly, in the evening of the same day, a courier from DHL brought me another Raspberry.  Here the idea came to make your watch, and not just watch, but with magic.  After all, we have a whole microcomputer with full-fledged Linux not onboard, our hands are untied, the possibilities are endless! <br><br><h4>  Formulation of the problem </h4><br>  In the morning, after negotiations with the customer, the task was set as follows: the device must be configured using any PC, without additional software (expensive), be able to pull up the exact time from the Internet (by calling you can synchronize the clock, all calls are strictly accurate to the second), be able to work autonomously, and, as an additional option for the future, should be able to receive call configuration from a remote server.  For example, a district can independently lay out a configuration of calls for educational institutions of a certain type.  Task set, proceed to implementation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To implement the project we need the following: <br><br><ul><li>  A demon who can pull the right GPIO leg at the right time. </li><li>  Web interface for configuring call time </li><li>  Real time clock </li><li>  Power electronics for school call management </li></ul><br><br>  I deliberately miss the initial configuration of the Raspberry Pi, the Internet is full of materials on installing the distribution, setting up the network, time zone, etc. <br><br>  So let's get started. <br><br><h4>  Real time clock </h4><br>  As a real-time clock for the device, I took a small scarf on the DS1302, simply because it was found in my handful of trash ordered from China.  A wonderful <a href="http://www.hobbytronics.co.uk/raspberry-pi-real-time-clock">article appeared on the</a> net describing the connection of this particular watch to the raspberry.  Connection is pretty simple. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f78/edb/7ab/f78edb7ab46a5f405825529952604c39.jpg"></div><br><br>  On the same page is available for download software that can receive and record data in these RTC.  I rewrote the software a bit for myself in order to visualize the RTC readings before synchronizing with the system time. <br><br>  Properly, the watch should be updated if the Malinki time is successfully synchronized with the NTP server, and if there is no access to the NTP server, then the Malinki system clock should be synchronized with the real time clock.  This algorithm is necessary, since the DS1302 has a habit of crawling away for a couple of seconds a day, which is unpleasant.  However, I did not find how to make ntpd run the script after successful synchronization.  Therefore, such a crutch was born: <br><br><div class="spoiler">  <b class="spoiler_title">/ usr / local / bin / update_rtc</b> <div class="spoiler_text"><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash LOG="/var/log/rtc-sync.log" DATE=`date` sleep 30 echo "*** $DATE" &gt;&gt;$LOG until ping -nq -c3 8.8.8.8; do echo "No network, updating system clock from RTC." &gt;&gt;$LOG rtc-pi 2&gt;&amp;1 exit done echo "Network detected. Updating RTC." &gt;&gt;$LOG date +%Y%m%d%H%M%S |xargs ./rtc-pi 2&gt;&amp;1</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/init.d/rtc</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh # /etc/init.d/rtc ### BEGIN INIT INFO # Provides: RTC controll # Required-Start: $remote_fs $syslog # Required-Stop: $remote_fs $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Simple script to start RTC sync # Description: A simple script from prostosergik &lt;serge.liskovsky@gmail.com&gt; which will run script that synchronizes RTC module clock with system clock at startup. ### END INIT INFO case "$1" in start) echo "RTC sync..." /usr/local/bin/update_rtc&amp; 2&gt;&amp;1 ;; stop) echo "Stopping RTC Sync..." # kill application you want to stop killall update_rtc ;; *) echo "Usage: /etc/init.d/rtc {start|stop}" exit 1 ;; esac exit 0</span></span></code> </pre><br></div></div><br>  ... and activate autoload: <br><pre> <code class="bash hljs">sudo update-rc.d rtc defaults</code> </pre> <br><br>  These two files allow you to synchronize Malinka's system clock with the RTC in the event that no network is detected after the download, or to update the time in the RTC if the network is found.  After 30 seconds after loading ntpd should have time to update the system clock.  In the worst case, the RTC will be recorded recently when Raspberry was turned on.  I know that this solution is far from ideal, but I could not think of a better one.  The only thing that comes to mind is to add a line to kroons to update the RTC once every 2-3 hours in order to be sure that there are more or less accurate data in the real-time clock.  If a highly respected community prompts the best solution, I will be only too happy. <br><br><h4>  Web server </h4><br>  It did not take long to think.  The main task of the server is to show two pages and process one POST request.  The textbook implementation of the Python web server simply suggests itself. <br><br><div class="spoiler">  <b class="spoiler_title">webserver.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python # -*- coding: utf-8 -*- import cgi, re, json from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer import collections from config import * class MainRequestHandler(BaseHTTPRequestHandler): def do_GET(self): if self.path == '/': lessons = readSchedule() schedule = '' for lesson in lessons: schedule += u"&lt;b&gt; "+lesson+"&lt;/b&gt;: "+lessons[lesson].get('start', '--:--') + " - " + lessons[lesson].get('end', '--:--') + "&lt;br /&gt;" data = { 'schedule': schedule.encode('utf-8') } TemplateOut(self, 'index.html', data) return elif self.path == '/form.html': lessons = readSchedule() form = '' for lesson in lessons: form += u"&lt;div class='form_block'&gt;&lt;label&gt; "+lesson+"&lt;/label&gt; &lt;input type='text' name='lesson_"+lesson+"_start' value='"+lessons[lesson].get('start', '--:--') + "'&gt; - &lt;input type='text' name='lesson_"+lesson+"_end' value='"+lessons[lesson].get('end', '--:--') + "'&gt; &lt;/div&gt; """ data = { 'form': form.encode('utf-8') } TemplateOut(self, 'form.html', data) return elif self.path == '/remote.html': lessons = readScheduleRemote() form = '' for lesson in lessons: form += u"&lt;div class='form_block'&gt;&lt;label&gt; "+lesson+"&lt;/label&gt; &lt;input type='text' name='lesson_"+lesson+"_start' value='"+lessons[lesson].get('start', '--:--') + "'&gt; - &lt;input type='text' name='lesson_"+lesson+"_end' value='"+lessons[lesson].get('end', '--:--') + "'&gt; &lt;/div&gt; """ data = { 'form': form.encode('utf-8') } TemplateOut(self, 'form.html', data) return else: try: TemplateOut(self, self.path) except IOError: self.send_error(404, 'File Not Found: %s' % self.path) def do_POST(self): # Parse the form data posted form = cgi.FieldStorage( fp=self.rfile, headers=self.headers, environ={ 'REQUEST_METHOD':'POST', 'CONTENT_TYPE':self.headers['Content-Type'], } ) lessons = {} if self.path.endswith('save'): # Echo back information about what was posted in the form for field in form.keys(): field_item = form[field] if type(field_item) == type([]): pass # no arrays processing now else: if field_item.filename: pass #no files now. else: if re.match('lesson_([\d]+)_(start|end)', field): (lesson, state) = re.findall('lesson_([\d]+)_(start|end)', field)[0] try: lessons[lesson] except Exception: lessons[lesson] = {} lessons[lesson][state] = field_item.value # printlessons json_s = json.dumps(lessons) if json_s: try: f = open(JSON_FILE, 'w+') f.write(json_s) f.close() HTMLOut(self, 'Saved OK.' + JS_REDIRECT) except IOError, e: # raise e HTMLOut(self, 'Error saving. IO error. '+e.message) else: HTMLOut(self, 'Json Error.') else: self.send_error(404, 'Wrong POST url: %s' % self.path) return def Redirect(request, location): request.send_response(301) request.send_header('Location', location) request.end_headers() return def Headers200(request): request.send_response(200) request.send_header('Content-type', 'text/html') request.end_headers() return def TemplateOut(request, out_file, data = {}): f = open(SCRIPT_DIR + out_file) out = f.read() f.close() #tiny template engine for key, var in data.items(): out = out.replace("{{"+key+"}}", var) HTMLOut(request, out) def HTMLOut(request, html): Headers200(request) f = open(SCRIPT_DIR + 'base.html') out = f.read() f.close() out = out.replace("{{content}}", html) request.wfile.write(out) def readSchedule(): try: f = open(JSON_FILE, 'r') json_s = f.read() f.close() except IOError: return [] try: lessons = json.loads(json_s) except Exception: return [] lessons = collections.OrderedDict(sorted(lessons.items())) return lessons def readScheduleRemote(): import urllib2 try: response = urllib2.urlopen(REMOTE_URL) json_s = response.read() except Exception: return [] try: lessons = json.loads(json_s) except Exception: return [] lessons = collections.OrderedDict(sorted(lessons.items())) return lessons def main(): try: server = HTTPServer(('', 8088), MainRequestHandler) print 'Started httpserver...' server.serve_forever() except KeyboardInterrupt: print '^C received, shutting down server.' server.socket.close() if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br>  Out of boredom and for better extensibility, even a simple template engine was added.  Please note that the interpreter is registered at the beginning of the script, so after installing the permissions for execution, the script can be run directly from the command line. <br><br>  What makes this script, I think, is clear and without comment.  The GET request handler simply gives the client two forms and the main page, filling the variable with data about the current schedule.  The POST request handler saves the data from the form to a JSON file, which is the base of calls. <br><br><h4>  Actually, the manager of the school bell </h4><br>  Thanks to the wonderful GPIO library for Python, blinking a school bell with a raspberry is very simple.  This script deals with: <br><br><div class="spoiler">  <b class="spoiler_title">daemon.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python # -*- coding: utf-8 -*- import time import threading import json import RPi.GPIO as GPIO from config import * GPIO.setmode(GPIO.BCM) GPIO.setwarnings(False) GPIO.setup(25, GPIO.OUT) GPIO.output(25, False) def read_schedule(): schedule = [] try: f = open(JSON_FILE, 'r') json_s = f.read() f.close() try: json_data = json.loads(json_s) except Exception, e: json_data = [] for lesson in json_data.values(): start = lesson.get('start', False) end = lesson.get('end', False) if start is not False: # print start.split(":") (s_h, s_m) = start.split(":") schedule.append({'h': int(s_h), 'm':int(s_m)}) del s_h del s_m if end is not False: (e_h, e_m) = end.split(":") schedule.append({'h': int(e_h), 'm':int(e_m)}) del e_h del e_m return schedule # schedule except IOError, e: return [] except Exception, e: return [] class Alarm(threading.Thread): def __init__(self): super(Alarm, self).__init__() self.schedule = read_schedule() self.keep_running = True def run(self): try: while self.keep_running: now = time.localtime() for schedule_item in self.schedule: if now.tm_hour == schedule_item['h'] and now.tm_min == schedule_item['m']: print "Ring start..." GPIO.output(25, True) time.sleep(5) print "Ring end..." GPIO.output(25, False) self.schedule = read_schedule() #reload schedule if it was changed time.sleep(55) # more than 1 minute #print "Check at "+str(now.tm_hour)+':'+str(now.tm_min)+':'+str(now.tm_sec) time.sleep(1) except Exception, e: raise e # return def die(self): self.keep_running = False alarm = Alarm() def main(): try: alarm.start() print 'Started daemon...' while True: continue except KeyboardInterrupt: print '^C received, shutting down daemon.' alarm.die() if __name__ == '__main__': main()</span></span></code> </pre><br></div></div><br>  The script creates a new thread, which checks the time every second.  If the time is found in the schedule file, then for 5 seconds we include the call (we submit a high level to the 25 GPIO pin).  After each call, we reread the schedule, in case it was changed from the web interface.  Everything is transparent and simple. <br><br><h4>  Demonizing and training the observation dog </h4><br>  Acting by analogy with the autorun RTC synchronization, we create the following files: <br><br><div class="spoiler">  <b class="spoiler_title">/etc/init.d/schedule_daemon</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ### BEGIN INIT INFO # Provides: schedule_daemon # Required-Start: $remote_fs $syslog # Required-Stop: $remote_fs $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # description: School Ring Schedule daemon # processname: School Ring Schedule daemon ### END INIT INFO export SCHEDULE_ROOT=/home/pi/ring_app export PATH=$PATH:$SCHEDULE_ROOT SERVICE_PID=`ps -ef | grep daemon.py | grep -v grep | awk 'END{print $2}'` usage() { echo "service schedule_daemon {start|stop|status}" exit 0 } case $1 in start) if [ $SERVICE_PID ];then echo "Service is already running. PID: $SERVICE_PID" else $SCHEDULE_ROOT/daemon.py&amp; 2&gt;&amp;1 fi ;; stop) if [ $SERVICE_PID ];then kill -9 $SERVICE_PID else echo "Service is not running" fi ;; status) if [ $SERVICE_PID ];then echo "Running. PID: $SERVICE_PID" else echo "Not running" fi ;; *) usage ;; esac</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/init.d/schedule_webserver</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ### BEGIN INIT INFO # Provides: schedule_webserver # Required-Start: $remote_fs $syslog # Required-Stop: $remote_fs $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # description: School Ring Schedule web-server # processname: School Ring Schedule web-server ### END INIT INFO export SCHEDULE_ROOT=/home/pi/ring_app export PATH=$PATH:$SCHEDULE_ROOT SERVICE_PID=`ps -ef | grep webserver.py | grep -v grep | awk 'END{print $2}'` usage() { echo "service schedule_webserver {start|stop|status}" exit 0 } case $1 in start) if [ $SERVICE_PID ];then echo "Service is already running. PID: $SERVICE_PID" else $SCHEDULE_ROOT/webserver.py&amp; 2&gt;&amp;1 fi ;; stop) if [ $SERVICE_PID ];then kill -9 $SERVICE_PID else echo "Service is not running" fi ;; status) if [ $SERVICE_PID ];then echo "Running. PID: $SERVICE_PID" else echo "Not running" fi ;; *) usage ;; esac</span></span></code> </pre><br></div></div><br><br>  And scripts "watchdogs" for them.  These scripts check if the service is running and, if necessary, run it. <br><br><div class="spoiler">  <b class="spoiler_title">/etc/init.d/schedule_daemon_wd</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ### BEGIN INIT INFO # Provides: schedule_daemon_wd # Required-Start: $remote_fs $syslog # Required-Stop: $remote_fs $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # description: School Ring Schedule daemon watchdog # processname: School Ring Schedule daemon watchdog ### END INIT INFO export SCHEDULE_ROOT=/home/pi/ring_app export PATH=$PATH:$SCHEDULE_ROOT SERVICE_PID=`ps -ef | grep daemon.py | grep -v grep | awk '{print $2}'` check_service() { if [ -z $SERVICE_PID ];then service schedule_daemon start fi } check_service usage() { echo "schedule_daemon_wd {start|stop|status}" exit 0 } case $1 in start ) if [ $SERVICE_PID ];then echo "schedule_daemon is already running. PID: $SERVICE_PID" else service schedule_daemon start fi ;; stop ) if [ $SERVICE_PID ];then service schedule_daemon stop else echo "schedule_daemon is already stopped" fi ;; status) if [ $SERVICE_PID ];then echo "schedule_daemon is running. PID: $SERVICE_PID" else echo "schedule_daemon is not running" fi ;; *) usage ;; esac</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/init.d/schedule_webserver_wd</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh ### BEGIN INIT INFO # Provides: schedule_webserver_wd # Required-Start: $remote_fs $syslog # Required-Stop: $remote_fs $syslog # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # description: School Ring Schedule web-server watchdog # processname: School Ring Schedule web-server watchdog ### END INIT INFO export SCHEDULE_ROOT=/home/pi/ring_app export PATH=$PATH:$SCHEDULE_ROOT SERVICE_PID=`ps -ef | grep webserver.py | grep -v grep | awk '{print $2}'` check_service() { if [ -z $SERVICE_PID ];then service schedule_webserver start fi } check_service usage() { echo "schedule_webserver_wd {start|stop|status}" exit 0 } case $1 in start ) if [ $SERVICE_PID ];then echo "schedule_webserver is already running. PID: $SERVICE_PID" else service schedule_webserver start fi ;; stop ) if [ $SERVICE_PID ];then service schedule_webserver stop else echo "schedule_webserver is already stopped" fi ;; status) if [ $SERVICE_PID ];then echo "schedule_webserver is running. PID: $SERVICE_PID" else echo "schedule_webserver is not running" fi ;; *) usage ;; esac</span></span></code> </pre><br></div></div><br>  Similarly, we make these scripts automatically loadable at system startup: <br><br><pre> <code class="bash hljs">sudo update-rc.d schedule_daemon_wd defaults sudo update-rc.d schedule_webserver_wd defaults</code> </pre><br>  And we add to the crown new tasks: <br><br><div class="spoiler">  <b class="spoiler_title">/etc/cron.d/wd.cron</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#Watchdog tasks * * * * * /etc/init.d/schedule_daemon_wd * * * * * /etc/init.d/schedule_webserver_wd</span></span></code> </pre><br></div></div><br>  Now we can be sure that both daemons have started and will work stably.  Do not forget to add a new line at the end of wd.cron, otherwise crond will ignore it! <br><br><h4>  A little about power electronics </h4><br>  The entire power unit is assembled completely standard.  The total power of calls in the school is about 0.5 kW, so that the BC137X triac paired with the MOC3061 optocoupler is quite enough to switch this farm.  As practice has shown, 3.3 volts of a logical unit is sufficient for the confident inclusion of an optocoupler. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1eb/fca/b9e/1ebfcab9e00baf9a6a9dfdf4a7e70abb.png"></div><br><br>  It would be possible to apply here and relays, but somehow I do not trust contacts when there are such wonderful semiconductors.  I deliberately do not post a photograph of the layout, because  before the beautiful installation never came. <br><br><h4>  What is missing </h4><br>  Of course, having a full-fledged Linux-computer at your disposal, you can "turn on" the functionality to infinity, and the development time will be relatively short.  This circumstance speaks in favor of the use of microcomputers for solving problems that the microcontroller would seem to cope with.  However, all the same I will list what, in my opinion, the current implementation lacks: <br><br>  <i>First</i> , safety.  It would be worth confusing at least HTTP-Auth at least, or, having added a little script, make a password database for entering the system‚Äôs ‚Äúadmin panel‚Äù.  And it‚Äôs worthwhile to work on data filtering both before and after submitting the form. <br>  <i>Secondly</i> , add / remove academy should be added.  hours in shape.  The attentive reader noted that this can be done simply by adding the necessary fields to the form on the client side using, for example, simple JavaScript code. <br>  <i>Thirdly</i> , I so wanted to make a ‚Äúpanic button‚Äù on the main one, which would launch a call in 5-10 seconds.  Let it be a small task for the inquisitive minds of readers, good, everything necessary for this is in the article. <br>  <i>Fourth</i> , there is a shortage of uninterruptible power supply.  Due to the failure of the customer to develop, we have not reached it. <br><br><h4>  How it all ended </h4><br>  Unfortunately, the Kharkov gymnasium with in-depth study of something there decided that it was very, very difficult to collect 3 hryvnias from each parent, and we were eventually turned around, so the implementation stopped on the current prototype, which does not contain some important for finite element system.  But the time spent on development was not in vain.  I hope that experience in developing applications for working with iron in Python will come in handy more than once in life, especially in the suburban area where the construction of a house ends, which provides for the possibility of managing everything from a single think tank.  If I could manage the call, then I can turn on the lights on a schedule. <br><br><h4>  Afterword </h4><br>  I hope, dear readers, I managed to convey to you the main idea.  The use of microcomputers for seemingly trivial tasks can raise their implementation to a fundamentally new level, and instead of the simplest implementations, proprietary protocols and complex support, we get a flexible system with almost infinite extensibility, which in future will result not only in usability, but also in substantial cost savings. <br><br>  A little more than three hours were spent on the implementation of all of the above.  Bringing to mind that there is another need.  Traditionally, I will ask you not to kick the code and possible errors for the crooked places.  This is my first article on Habr√©, and the first implemented project in Python.  Always happy to amend, suggestions and suggestions.  Screenshots and video work lay on demand. <br><br>  I look forward to the implementation of similar functionality by Komrad <a href="https://habrahabr.ru/users/devzona/" class="user_link">devzona</a> , but only on the basis of Arduino.  I'm sure I have something to learn from him in terms of developing devices on microcontrollers.  The article promises to be truly exciting. </div><p>Source: <a href="https://habr.com/ru/post/207138/">https://habr.com/ru/post/207138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207126/index.html">Zoo of Algebraic Data Types</a></li>
<li><a href="../207130/index.html">LEDs in the snow</a></li>
<li><a href="../207132/index.html">10 new commercials from Trailer Studio</a></li>
<li><a href="../207134/index.html">Who, when and how is going to fly to Mars</a></li>
<li><a href="../207136/index.html">Holiday geeky: with ARM and TFT LCD</a></li>
<li><a href="../207140/index.html">Capturing and shooting a demo video of an iOS application with improvised and not so much means - ways and solutions</a></li>
<li><a href="../207144/index.html">Silent Domain Authorization at GlassFish</a></li>
<li><a href="../207146/index.html">10,000,000 repositories</a></li>
<li><a href="../207148/index.html">PostgreSQL New Year Check</a></li>
<li><a href="../207152/index.html">Holiday greetings!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>