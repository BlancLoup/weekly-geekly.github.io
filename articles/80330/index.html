<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Doctrine, extending the capabilities of your favorite ORM framework! Part 1.b (I18n, modification of quick access to translatable attributes)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article, I looked at one of the ways to quickly access translatable attributes. In order to understand what is being discussed at all, it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Doctrine, extending the capabilities of your favorite ORM framework! Part 1.b (I18n, modification of quick access to translatable attributes)</h1><div class="post__text post__text-html js-mediator-article">  In the last <a href="http://habrahabr.ru/blogs/doctrine/79878/">article,</a> I looked at one of the ways to quickly access translatable attributes.  In order to understand what is being discussed at all, it is strongly recommended to read the above article before this one) For those who have already read, let me remind you that the main cymes consisted in artificial heteras and seters via hasAccessorMutator (), which in turn were overriden through __call ( ) -function template.  The obvious disadvantage of this approach is the impossibility of using __call () in other templates, which is not good.  There is a more beautiful and effective way to implement such access, and it was originally provided for in Doctrine almost from the very first versions - these are attribute filters.  And again under the cut a lot of code and text. <a name="habracut"></a><br><br><h3>  Quick access to translatable attributes through filters </h3><br>  How are the filters used in Doctrine_Record?  Without going into details, the approximate scheme looks like this: <br><ul><li>  $ record-&gt; attribute - the script requests some attribute </li><li>  the Doctrine :: __ get ('attribute') method is called, which calls Doctrine_Record :: get ('attribute'), and it, in turn, is the Doctrine :: _ get ('attribute') method. </li><li>  in the course of this queue, checks are made for the availability of accessors and mutators (the same queue corresponds to setters), the presence of associations, etc., and at the very end a most interesting construction is called ... </li></ul><br><blockquote><code><font color="black"><font color="#008000">//   Doctrine_Record::_get()    </font> <br> <font color="#0000ff">foreach</font> ($ <font color="#0000ff">this</font> -&gt;_table-&gt;getFilters() <font color="#0000ff">as</font> $filter) { <br> <font color="#0000ff">try</font> { <br> $ <font color="#0000ff">value</font> = $filter-&gt;filterGet($ <font color="#0000ff">this</font> , $fieldName); <br> $success = <font color="#0000ff">true</font> ; <br> } <font color="#0000ff">catch</font> (Doctrine_Exception $e) {} <br> } <br> <font color="#0000ff">if</font> ($success) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">value</font> ; <br> } <font color="#0000ff">else</font> { <br> <font color="#0000ff">throw</font> $e; <br> }</font></code> </blockquote> <br>  As you can see, for any attribute (including the one that does not exist), a call is made to filterGet () for each filter instance assigned to write! <br><br>  What does this mean to us?  And the fact that we can use the native attribute access method through an external filter class.  By default, only 1 filter is installed in Doctrine_Record - Doctrine_Record_Filter_Compound, which tracks the presence of a given attribute, and if it does not exist, throws an exception.  This exception is caught in Doctrine_Record and either proceeds to the next filter, or re-calls it if the filters have run out.  Everything is quite simple and our task is to implement our filter, which will intercept the call of attributes that we specify in initialization and return the values ‚Äã‚Äãof the corresponding fields of the Translation association for our record, and for others to throw an exception.  As can be seen from the insertion of the code (see above), the record calls up the filters in order and catches their exception or the result in order to go to the next filter.  Let's try to implement such a filter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Filter </h3><br>  First, to create a filter, you need to create a class inherited from Doctrine_Record_Filter and implement 2 abstract methods Doctrine_Record_Filter :: filterGet () and Doctrine_Record_Filter :: filterSet ().  As can be seen from the approximate scheme of the work of getters and setters (see above), the record causes filters in order, and in case of some errors we have to throw an exception. <br><br>  This time I will not go into the chain of reasoning how to write classes, but I‚Äôll give you a ready-made filter code, and then let's analyze what and why. <br><blockquote> <code><a href="http://www.opensource.org/licenses/lgpl-license.php"></a> <font color="black"><font color="#008000">/**</font> <br> <font color="#008000">* EasyAccess package filter. Implements access to record's properties as for translated in I18n.</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* Can be used as a part of Of_ExtDoctrine_I18n_Helper system, or as stand-alone filter both.</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @author     OmeZ</font> <br> <font color="#008000">* @version   1.0</font> <br> <font color="#008000">* @license   www.opensource.org/licenses/lgpl-license.php LGPL</font> <br> <font color="#008000">* @package   Of_ExtDoctrine_I18n_EasyAccess</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">class</font> Of_ExtDoctrine_I18n_EasyAccess_Filter extends Doctrine_Record_Filter { <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Fields</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @var array</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">protected</font> $_fields = array(); <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Language</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @var string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">protected</font> $_language; <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* @var Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">protected</font> $_owner; <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Constructs new filter with options</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param array $options</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function __construct(array $options) { <br> <font color="#0000ff">if</font> (isset($options[ <font color="#A31515">'fields'</font> ])) $ <font color="#0000ff">this</font> -&gt;setFields($options[ <font color="#A31515">'fields'</font> ]); <br> <font color="#0000ff">if</font> (isset($options[ <font color="#A31515">'language'</font> ])) $ <font color="#0000ff">this</font> -&gt;setLanguage($options[ <font color="#A31515">'language'</font> ]); <br> <font color="#0000ff">if</font> (isset($options[ <font color="#A31515">'owner'</font> ])) $ <font color="#0000ff">this</font> -&gt;setOwner($options[ <font color="#A31515">'owner'</font> ]); <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns owner of filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getOwner() { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;_owner; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets owner for filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface $owner</font> <br> <font color="#008000">* @return Of_ExtDoctrine_I18n_EasyAccess_Filter</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function setOwner(Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface $owner) { <br> $ <font color="#0000ff">this</font> -&gt;_owner = $owner; <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> ; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns fields aliases for filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return array</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getFields() { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;_fields; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets fields aliases for filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param $fields</font> <br> <font color="#008000">* @return Of_ExtDoctrine_I18n_EasyAccess_Filter</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function setFields($fields) { <br> $ <font color="#0000ff">this</font> -&gt;_fields = (array)$fields; <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> ; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns default language for filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getLanguage() { <br> <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt;_language !== <font color="#0000ff">null</font> ) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;_language; <br> } elseif ($ <font color="#0000ff">this</font> -&gt;_owner) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;_owner-&gt;getLanguage(); <br> } <font color="#0000ff">else</font> { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/Exception.php'</font> ; <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_Exception( <font color="#A31515">'Impossible to detect language'</font> ); <br> } <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets language to filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return Of_ExtDoctrine_I18n_EasyAccess_Filter</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function setLanguage($language) { <br> $ <font color="#0000ff">this</font> -&gt;_language = $language; <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> ; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns value of translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @return mixed</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function filterGet(Doctrine_Record $record, $name) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;getTranslation($record, $name, $ <font color="#0000ff">this</font> -&gt;getLanguage()); <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets value to translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @param mixed $value</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function filterSet(Doctrine_Record $record, $name, $ <font color="#0000ff">value</font> ) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;setTranslation($record, $name, $ <font color="#0000ff">value</font> , $ <font color="#0000ff">this</font> -&gt;getLanguage()); <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Language dependent getter to translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @param string $language</font> <br> <font color="#008000">* @param boolean $return_first_found</font> <br> <font color="#008000">* @return mixed</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getTranslation(Doctrine_Record $record, $name, $language = <font color="#0000ff">null</font> , $return_first_found = <font color="#0000ff">true</font> ) { <br> <font color="#0000ff">if</font> (in_array($name, $ <font color="#0000ff">this</font> -&gt;_fields)) { <br> $language = empty($language)?( <font color="#0000ff">string</font> )$ <font color="#0000ff">this</font> -&gt;getLanguage():( <font color="#0000ff">string</font> )$language; <br> <font color="#0000ff">if</font> ($record-&gt;hasRelation( <font color="#A31515">'Translation'</font> )) { <br> <font color="#0000ff">if</font> ($record-&gt;Translation-&gt;contains($language)) { <br> <font color="#0000ff">return</font> $record-&gt;Translation[$language][$name]; <br> } elseif ($return_first_found &amp;&amp; $record-&gt;Translation-&gt;count()) { <br> <font color="#0000ff">foreach</font> ($record-&gt;Translation <font color="#0000ff">as</font> $translation) <br> <font color="#0000ff">if</font> (!empty($translation[$name])) <br> <font color="#0000ff">return</font> $translation[$name]; <br> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <font color="#0000ff">else</font> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <font color="#0000ff">else</font> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <font color="#0000ff">else</font> { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/NotTranslatableException.php'</font> ; <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_NotTranslatableException( <font color="#A31515">"Field {$name} is not marked as easy getter to tranlsatable attribute in "</font> .get_class($record)); <br> } <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Language dependent setter to translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @param mixed $value</font> <br> <font color="#008000">* @param string $language</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function setTranslation(Doctrine_Record $record, $name, $ <font color="#0000ff">value</font> , $language = <font color="#0000ff">null</font> ) { <br> <font color="#0000ff">if</font> (in_array($name, $ <font color="#0000ff">this</font> -&gt;_fields)) { <br> $language = empty($language)?( <font color="#0000ff">string</font> )$ <font color="#0000ff">this</font> -&gt;getLanguage():( <font color="#0000ff">string</font> )$language; <br> <font color="#0000ff">if</font> ($record-&gt;hasRelation( <font color="#A31515">'Translation'</font> )) { <br> $record-&gt;Translation[$language][$name] = $ <font color="#0000ff">value</font> ; <br> } <br> } <font color="#0000ff">else</font> { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/NotTranslatableException.php'</font> ; <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_NotTranslatableException( <font color="#A31515">"Field {$name} is not marked as easy setter to tranlsatable attribute in "</font> .get_class($record)); <br> } <br> } <br> <br> } <br></font></code> </blockquote><br><br><h4>  Analysis time! </h4><br><h5>  Constructor </h5><br><blockquote> <code><font color="black"><font color="#008000">/**</font> <br> <font color="#008000">* Constructs new filter with options</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param array $options</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function __construct(array $options) { <br> <font color="#0000ff">if</font> (isset($options[ <font color="#A31515">'fields'</font> ])) $ <font color="#0000ff">this</font> -&gt;setFields($options[ <font color="#A31515">'fields'</font> ]); <br> <font color="#0000ff">if</font> (isset($options[ <font color="#A31515">'language'</font> ])) $ <font color="#0000ff">this</font> -&gt;setLanguage($options[ <font color="#A31515">'language'</font> ]); <br> <font color="#0000ff">if</font> (isset($options[ <font color="#A31515">'owner'</font> ])) $ <font color="#0000ff">this</font> -&gt;setOwner($options[ <font color="#A31515">'owner'</font> ]); <br> }</font></code> </blockquote> <br>  Here we initialize our filter, and give it a list of options that contain information about the fields, language, and the mysterious owner of the filter.  Let's take a closer look at the options (interface similar to the one in the previous <a href="http://habrahabr.ru/blogs/doctrine/79878/">article</a> ): <br><ul><li>  <i>'fields'</i> - a list of attributes that we will track.  Looking ahead, I‚Äôll say that if we specify a non-existent attribute and access it, the filter will throw an exception </li><li>  <i>'language'</i> is the default language that we will use to access attributes </li><li>  <i>'owner'</i> - the mysterious owner of the filter.  This option is used to specify an object (Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface interface) that the filter will apply to in order to get the language if it has not been specified before.  But more about that later </li></ul><br><br><h5>  Installation Methods and Options </h5><br>  This is a set of methods (get / set) Fields (), (get / set) Language (), (get / set) Owner ().  In principle, there is nothing nontrivial, then I will not consider everything in detail.  I will stop only getLanguage (), since  the mysterious owner reappears in it: <br><blockquote> <code><font color="black"><font color="#008000">/**</font> <br> <font color="#008000">* Returns default language for filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getLanguage() { <br> <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt;_language !== <font color="#0000ff">null</font> ) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;_language; <br> } elseif ($ <font color="#0000ff">this</font> -&gt;_owner) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;_owner-&gt;getLanguage(); <br> } <font color="#0000ff">else</font> { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/Exception.php'</font> ; <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_Exception( <font color="#A31515">'Impossible to detect language'</font> ); <br> } <br> }</font></code> </blockquote> <br>  As you can see, we need the owner only to request a language if its own value is not specified.  This is done to allow this filter to integrate into another structure.  In my case, this is a modified template Of_ExtDoctrine_I18n_EasyAccess_Helper, an analogue of which I discussed in a previous <a href="http://habrahabr.ru/blogs/doctrine/79878/">article</a> .  Owner must follow the <i>Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface</i> interface, which contains only one public method getLanguage () <br><blockquote> <code><font color="black"><font color="#0000ff">interface</font> Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface { <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns language for inherited components</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getLanguage(); <br> <br> }</font></code> </blockquote> <br><br><h5>  Filter methods </h5><br>  In the end, we got to the methods themselves, which implement the necessary filter functionality. <br><blockquote> <code><font color="black"><font color="#008000">/**</font> <br> <font color="#008000">* Returns value of translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @return mixed</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function filterGet(Doctrine_Record $record, $name) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;getTranslation($record, $name, $ <font color="#0000ff">this</font> -&gt;getLanguage()); <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets value to translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @param mixed $value</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function filterSet(Doctrine_Record $record, $name, $ <font color="#0000ff">value</font> ) { <br> <font color="#0000ff">return</font> $ <font color="#0000ff">this</font> -&gt;setTranslation($record, $name, $ <font color="#0000ff">value</font> , $ <font color="#0000ff">this</font> -&gt;getLanguage()); <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Language dependent getter to translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @param string $language</font> <br> <font color="#008000">* @param boolean $return_first_found</font> <br> <font color="#008000">* @return mixed</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getTranslation(Doctrine_Record $record, $name, $language = <font color="#0000ff">null</font> , $return_first_found = <font color="#0000ff">true</font> ) { <br> <font color="#0000ff">if</font> (in_array($name, $ <font color="#0000ff">this</font> -&gt;_fields)) { <br> $language = empty($language)?( <font color="#0000ff">string</font> )$ <font color="#0000ff">this</font> -&gt;getLanguage():( <font color="#0000ff">string</font> )$language; <br> <font color="#0000ff">if</font> ($record-&gt;hasRelation( <font color="#A31515">'Translation'</font> )) { <br> <font color="#0000ff">if</font> ($record-&gt;Translation-&gt;contains($language)) { <br> <font color="#0000ff">return</font> $record-&gt;Translation[$language][$name]; <br> } elseif ($return_first_found &amp;&amp; $record-&gt;Translation-&gt;count()) { <br> <font color="#0000ff">foreach</font> ($record-&gt;Translation <font color="#0000ff">as</font> $translation) <br> <font color="#0000ff">if</font> (!empty($translation[$name])) <br> <font color="#0000ff">return</font> $translation[$name]; <br> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <font color="#0000ff">else</font> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <font color="#0000ff">else</font> <font color="#0000ff">return</font> <font color="#0000ff">null</font> ; <br> } <font color="#0000ff">else</font> { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/NotTranslatableException.php'</font> ; <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_NotTranslatableException( <font color="#A31515">"Field {$name} is not marked as easy getter to tranlsatable attribute in "</font> .get_class($record)); <br> } <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Language dependent setter to translatable attribute</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param Doctrine_Record $record</font> <br> <font color="#008000">* @param string $name</font> <br> <font color="#008000">* @param mixed $value</font> <br> <font color="#008000">* @param string $language</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function setTranslation(Doctrine_Record $record, $name, $ <font color="#0000ff">value</font> , $language = <font color="#0000ff">null</font> ) { <br> <font color="#0000ff">if</font> (in_array($name, $ <font color="#0000ff">this</font> -&gt;_fields)) { <br> $language = empty($language)?( <font color="#0000ff">string</font> )$ <font color="#0000ff">this</font> -&gt;getLanguage():( <font color="#0000ff">string</font> )$language; <br> <font color="#0000ff">if</font> ($record-&gt;hasRelation( <font color="#A31515">'Translation'</font> )) { <br> $record-&gt;Translation[$language][$name] = $ <font color="#0000ff">value</font> ; <br> } <br> } <font color="#0000ff">else</font> { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/NotTranslatableException.php'</font> ; <br> <font color="#0000ff">throw</font> <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_NotTranslatableException( <font color="#A31515">"Field {$name} is not marked as easy setter to tranlsatable attribute in "</font> .get_class($record)); <br> } <br> }</font></code> </blockquote> <br>  It can be seen that they practically do not differ from accessors and mutators from the previous part and consist of 2 filtering methods and 2 artificial getters and setters.  I made them because I would like to leave the opportunity to get the value of the translation for an arbitrary language on occasion. <br><br>  Also in the getter, it is possible to disable or enable the ability to search for the first translated value in the case when the translation for the current language is empty.  By default, it is enabled, but it will be necessary to somehow bring it into an additional option. <br><br><h4>  Filter connection </h4><br>  Create a record similar to the one in the first part and connect the filter. <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> Product extends Doctrine_Record { <br> <br> <font color="#0000ff">public</font> function setTableDefinition() { <br> <font color="#008000">//....</font> <br> $ <font color="#0000ff">this</font> -&gt;hasColumn( <font color="#A31515">'name'</font> , <font color="#A31515">'string'</font> , 255); <br> $ <font color="#0000ff">this</font> -&gt;hasColumn( <font color="#A31515">'description'</font> , <font color="#A31515">'string'</font> ); <br> <font color="#008000">//....</font> <br> } <br> <br> <font color="#0000ff">public</font> function setUp() { <br> <br> $ <font color="#0000ff">this</font> -&gt;actAs( <font color="#A31515">'I18n'</font> , array( <br> <font color="#A31515">'fields'</font> =&gt;array( <font color="#A31515">'name'</font> , <font color="#A31515">'description'</font> ) <br> )); <br> <br> $i18nFilter = <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_Filter(array( <br> <font color="#A31515">'language'</font> =&gt; <font color="#A31515">'en'</font> , <br> <font color="#A31515">'fields'</font> =&gt;array( <font color="#A31515">'name'</font> , <font color="#A31515">'description'</font> ) <font color="#008000">//      </font> <br> )); <br> $ <font color="#0000ff">this</font> -&gt;getTable()-&gt;unshiftFilter($i18nFilter); <br> } <br> <br> }</font></code> </blockquote> <br><blockquote> <code><font color="black">$record = <font color="#0000ff">new</font> Product(); <br> $record-&gt;description = <font color="#A31515">'my description'</font> ; <font color="#008000">//  $record-&gt;Translation['en']-&gt;description</font> <br> <br> echo $record-&gt;description; //   echo $record-&gt;Translation[ <font color="#A31515">'en'</font> ]-&gt;description</font></code> </blockquote> <br>  When accessing the ‚Äúdescription‚Äù attribute, the filter will work and the value for the English language will return, but if you access the unspecified attribute, the filter will throw an exception, and the Doctrine_Record_Filter_Compound filter that follows will tell us that there is no such attribute. <br><blockquote> <code><font color="black"><font color="#0000ff">try</font> { <br> echo $record-&gt;lol; <font color="#008000">//  </font> <br> } <font color="#0000ff">catch</font> (Of_ExtDoctrine_I18n_EasyAccess_NotTranslatableException $e) { <br> <font color="#008000">//...</font> <br> }</font></code> </blockquote> <br>  It will be the same for writing to an attribute; I will not consider it. <br><br><h3>  Template Integration </h3><br>  I used to view access to attributes through the Of_ExtDoctrine_I18n_Template template.  Let's try to change it in such a way that instead of hasAccessorMutator our filter is used.  Along the way, I‚Äôll change the name to form our system in one package Of_ExtDoctrine_I18n_EasyAccess.  Immediately quote the source code of the class. <br><blockquote> <code><a href="http://www.opensource.org/licenses/lgpl-license.php"></a> <font color="black"><font color="#008000">/**</font> <br> <font color="#008000">* Temlate implements extrabehavior for standard Doctrine I18n template.</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @author     OmeZ</font> <br> <font color="#008000">* @version   1.7</font> <br> <font color="#008000">* @license   www.opensource.org/licenses/lgpl-license.php LGPL</font> <br> <font color="#008000">* @package   Of_ExtDoctrine_I18n_EasyAccess</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">class</font> Of_ExtDoctrine_I18n_EasyAccess_Helper extends Doctrine_Template implements Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface { <br> <br> <font color="#0000ff">protected</font> $_options = array( <br> <font color="#A31515">'language'</font> =&gt; <font color="#0000ff">null</font> , <br> <font color="#A31515">'fields'</font> =&gt; <font color="#0000ff">null</font> , <br> <font color="#A31515">'disableFilter'</font> =&gt; <font color="#0000ff">false</font> , <br> ); <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Holds default language for all behaviors</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @var string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">protected</font> $_defaultLanguage; <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Holds language for current model behavior</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @var string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">protected</font> $_language; <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* EasyAccess filter</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @var Of_ExtDoctrine_I18n_EasyAccess_Filter</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">protected</font> $_easyaccess_filter; <br> <br> <font color="#0000ff">public</font> function setUp() { <br> <br> $language = $ <font color="#0000ff">this</font> -&gt;getOption( <font color="#A31515">'language'</font> ); <br> <font color="#0000ff">if</font> ($language) $ <font color="#0000ff">this</font> -&gt;setLanguage($language); <br> <br> <font color="#008000">// Adds filter for access to properties, this can be used as stand-alone plugin</font> <br> <font color="#0000ff">if</font> (!$ <font color="#0000ff">this</font> -&gt;getOption( <font color="#A31515">'disableFilter'</font> )) { <br> require_once <font color="#A31515">'Of/ExtDoctrine/I18n/EasyAccess/Filter.php'</font> ; <br> $ <font color="#0000ff">this</font> -&gt;_easyaccess_filter = <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_Filter(array( <br> <font color="#A31515">'owner'</font> =&gt;$ <font color="#0000ff">this</font> , <br> <font color="#A31515">'language'</font> =&gt; <font color="#0000ff">null</font> , <font color="#008000">// this value will make filter access to template getLanguage() method</font> <br> <font color="#A31515">'fields'</font> =&gt;$ <font color="#0000ff">this</font> -&gt;getOption( <font color="#A31515">'fields'</font> , array()) <br> )); <br> $ <font color="#0000ff">this</font> -&gt;_table-&gt;unshiftFilter($ <font color="#0000ff">this</font> -&gt;_easyaccess_filter); <br> } <br> <br> <font color="#008000">// adds listener to manage Doctrine_Query hydrations. Will add translatable props as keys in</font> <br> <font color="#008000">// array when HYDRATE_ARRAY, or mapped values in records. This can be used as stand-alone plugin</font> <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns default language for all behaviors</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">public</font> function getDefaultLanguage() { <br> <font color="#0000ff">return</font> ( <font color="#0000ff">string</font> )self::$_defaultLanguage; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets default language for all behaviors</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param string $language</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">public</font> function setDefaultLanguage($language) { <br> self::$_defaultLanguage = $language; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Returns current language behavior</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @return void</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function getLanguage($without_static = <font color="#0000ff">false</font> ) { <br> <font color="#0000ff">if</font> ($ <font color="#0000ff">this</font> -&gt;_language === <font color="#0000ff">null</font> &amp;&amp; !$without_static) <font color="#0000ff">return</font> self::getDefaultLanguage(); <br> <font color="#0000ff">else</font> <font color="#0000ff">return</font> ( <font color="#0000ff">string</font> )$ <font color="#0000ff">this</font> -&gt;_language; <br> } <br> <br> <font color="#008000">/**</font> <br> <font color="#008000">* Sets current behavior language</font> <br> <font color="#008000">*</font> <br> <font color="#008000">* @param $language</font> <br> <font color="#008000">* @return string</font> <br> <font color="#008000">*/</font> <br> <font color="#0000ff">public</font> function setLanguage($language) { <br> $ <font color="#0000ff">this</font> -&gt;_language = $language; <br> } <br> }</font></code> </blockquote> <br>  Almost nothing has changed in the template, we just got rid of the read / write methods in Translation, because  they are transferred to the filter, as well as the __call () method, because it is no longer needed for the same reasons. <br><br>  Setting the filter to the table takes place in the setUp () method as before, added the option disableFilter if for some reason we need to disable the filter.  As the owner of the filter, we set our template and pass an empty language value, which allows the template to control the current value of the filter language, Of_ExtDoctrine_I18n_EasyAccess_OwnerInterface :: getLanguage () method has already been implemented.  All that remains is to connect the template in our demo and test it. <br><blockquote> <code><font color="black"><font color="#0000ff">class</font> Product extends Doctrine_Record { <br> <br> <font color="#0000ff">public</font> function setTableDefinition() { <br> <font color="#008000">//....</font> <br> $ <font color="#0000ff">this</font> -&gt;hasColumn( <font color="#A31515">'name'</font> , <font color="#A31515">'string'</font> , 255); <br> $ <font color="#0000ff">this</font> -&gt;hasColumn( <font color="#A31515">'description'</font> , <font color="#A31515">'string'</font> ); <br> <font color="#008000">//....</font> <br> } <br> <br> <font color="#0000ff">public</font> function setUp() { <br> <br> $ <font color="#0000ff">this</font> -&gt;actAs( <font color="#A31515">'I18n'</font> , array( <br> <font color="#A31515">'fields'</font> =&gt;array( <font color="#A31515">'name'</font> , <font color="#A31515">'description'</font> ) <br> )); <br> <br> $ <font color="#0000ff">this</font> -&gt;actAs( <font color="#0000ff">new</font> Of_ExtDoctrine_I18n_EasyAccess_Helper(array( <br> <font color="#A31515">'fields'</font> =&gt;array( <font color="#A31515">'name'</font> , <font color="#A31515">'description'</font> ) <font color="#008000">//      </font> <br> ))); <br> <br> } <br> <br> }</font></code> </blockquote> <br><blockquote> <code><font color="black">$record = <font color="#0000ff">new</font> Product(); <br> <br> $record-&gt;description = <font color="#A31515">'my description'</font> ; <font color="#008000">//  $record-&gt;Translation['en']-&gt;description</font> <br> echo $record-&gt;description; <font color="#008000">//   echo $record-&gt;Translation['en']-&gt;description</font> <br> <br> $record-&gt;setLanguage( <font color="#A31515">'ru'</font> ); <font color="#008000">//     </font> <br> <br> echo $record-&gt;description; <font color="#008000">//  'my description', ..          </font> <br></font></code> </blockquote><br><br><h3>  Conclusion </h3><br>  Such an implementation of access is much more convenient, and, as it turned out, much faster than the method described earlier.  The next step is to be able to access the attributes with different methods of hydration, for example, in Doctrine :: HYDRATE_ARRAY, since  there are no objects created and we will still be forced to use the translation association (in this case, the nested array). <br><br>  All classes in one archive can be found <a href="">here.</a> <br><br>  Ps.  An attentive reader might have noticed that the binding for the fields and language described in the template is repeated in the filter.  This was used to enable the filter to be used as a stand-alone component without resorting to a template, which I consider to be a good tone for such systems. <br><br>  <font color="gray">In this article, the code was highlighted using <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"><font color="gray">Source Code Highlighter</font></a> .</font> </div><p>Source: <a href="https://habr.com/ru/post/80330/">https://habr.com/ru/post/80330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../80323/index.html">Adaptive boosting</a></li>
<li><a href="../80324/index.html">PHP implementation of noSQL</a></li>
<li><a href="../80327/index.html">Literary hashtag # lit140</a></li>
<li><a href="../80328/index.html">Perl Mini-FAQ (Frequently Asked Questions, FAQ)</a></li>
<li><a href="../80329/index.html">Progress has reached!</a></li>
<li><a href="../80331/index.html">Dan Pink on the amazing science of motivation</a></li>
<li><a href="../80332/index.html">Are you afraid of flying planes?</a></li>
<li><a href="../80333/index.html">The shortest record by IE is broken</a></li>
<li><a href="../80334/index.html">Babbage analytical machine. Part one - who is Babbage and why do we need counting machines?</a></li>
<li><a href="../80335/index.html">Plastic Logic Introduces Que E-Reader New Ebook</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>