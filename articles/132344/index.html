<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The first working attack on the SSL / TLS protocol</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Data transmitted over an SSL connection can be decrypted! To do this, Julian Rizzo and Tai Duong managed to use flaws in the SSL protocol itself. And ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The first working attack on the SSL / TLS protocol</h1><div class="post__text post__text-html js-mediator-article">  Data transmitted over an SSL connection can be decrypted!  To do this, Julian Rizzo and Tai Duong managed to use flaws in the SSL protocol itself.  And let it not yet be a matter of completely decrypting the traffic, the BEAST utility developed by them can extract from the encrypted stream what is of the greatest interest - secret cookies with the user session ID. <br><br><img src="https://habrastorage.org/storage1/8ad87fcc/bebd133c/472b182b/46025019.png"><br><a name="habracut"></a><br><h3>  What is BEAST? </h3><br>  It took only 103 seconds for the BEAST utility (Browser Exploit Against SSL / TLS) to decrypt the secret cookie to log into your PayPal account.  You can watch the videocast on <a href="http://bit.ly/omqAsQ">Youtube</a> .  This is not a fake.  A live demonstration of the utility took place at the Ekoparty conference in Buenos Airos, where researchers gave a presentation and showed a working proof-of-concept.  The used vulnerability really allows to intercept imperceptibly the data transmitted between the web server and the user's browser.  Ironically, the attack does not exploit any new flaw found in the protocol, but the SSL / TLS vulnerability of a decade ago, which for a long time was considered purely theoretical.  But, as they say, once a year and a stick shoots, so for ten years, the vulnerability can definitely pass from the theoretical level to a completely practical one. <br><br>  Researchers do not publish the utility yet, but they share whitepaper <a href="http://bit.ly/oBLWHX">about the work done</a> .  The program consists of two elements: a sniffer, which analyzes HTTPS traffic, and a special agent written in JavaScript and Java, which must be loaded in the victim's browser (for this, for example, you must force the user to open a page with the necessary code).  The agent is needed in order to specifically embed data into the same secure communication channel that is used to transfer secret cookies.  How does this allow to decrypt data?  This is where the long-known SSL 3.0 / TLS 1.0 vulnerability comes in, which we will focus on in more detail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage1/0512246c/91e82141/bb9d79ad/6c587c53.png"><br><h4>  Simple replacement mode issue </h4><br><br><h3>  SSL Encryption Features 1.0 </h3><br>  The SSL 1.0 / TLS 3.0 protocol allows the use of encryption with a symmetric key, using either block or stream ciphers.  In practice, however, block ciphers are commonly used, and the attack we are describing is applicable to them.  To grasp the essence, you need to be well aware of basic concepts. <br><br>  The principle of a block cipher is to display plaintext blocks in encrypted blocks of the same size.  The easiest way is to present a block cipher as a giant table containing 2 ^ 128 entries, each of which contains a block of text M and its corresponding encrypted block C. Accordingly, for each encryption key there will be a separate such table.  Further we will denote encryption as a function: <br><br>  C = E (Key, M), where M is the original data, Key is the encryption key, and C is the encrypted data received. <br><br>  The blocks are small (usually 16 bytes).  Therefore, the question arises: how to encrypt a long message?  You can break the message into blocks of the same length (the same 16 bytes) and encrypt each block separately.  This approach is called simple replacement mode (ECB, Electronic codebook), but is rarely used.  There is a reason for this: if we encrypt two blocks of the same content, then as a result and at the output we will get two identical encrypted blocks.  This entails the problem of maintaining the statistical characteristics of the source text, which is well demonstrated in the illustration.  To avoid such an effect, a cipher-block chaining linkage mode was developed, in which every next XOR plaintext block with the previous encryption result: <br><br> <code>Ci = E(Key, Mi xor Ci-1)</code> <br> <br>  During the encryption of the first block, the source text XOR'is some initialization vector (Initialization Vector, IV), which replaces the result of the previous encryption, which for obvious reasons is not.  As you can see, everything is quite simple.  However, this theory describes the situation for a single large object, such as, for example, a file that is easily broken into blocks.  In turn, SSL / TLS is a cryptographic protocol ‚Äî it needs to encrypt not a single file, but a series of packets.  An SSL / TLS connection can be used to send a series of HTTPS requests, each of which can be broken into one or more packets, which, in turn, can be sent within a few seconds or a few minutes.  In this situation, there are two ways to use CBC mode: <br><br><ol><li>  process each message as a separate object, generate a new initialization vector and encrypt according to the described scheme. </li><li>  to process all messages as if they were combined into one large object, keeping the CBC mode between them.  This can be achieved by using the last cipher of the previous message (n-1) as the initialization vector for the message n. </li></ol><br>  Attention, an important point.  The SSL 3.0 / TLS 1.0 protocol uses the second option, and this is where the opportunity for an attack lies. <br><br><img src="https://habrastorage.org/storage1/73d9b7a8/48031722/617e1979/94597142.png"><br><h4>  The principle of the CBC-cipher </h4><br><br><h3>  Predictable initialization vector </h3><br>  The attack is based on several assumptions, but the experience of the creators of BEAST has shown that they can be fully realized in real life.  The first assumption: the attacker must be able to sniff the traffic that the browser transmits.  Second assumption: the bad guy must somehow force the victim to transfer data over the same secure channel of communication.  Why do you need it?  Consider the case when a secure connection is established between the Bob and Alice computers.  We receive a message, the i-block of which, as we assume, contains the password of Alice (or the secret cookie ‚Äî it does not matter).  Denote the encrypted block as Ci, respectively, Mi is its password.  Recall that Ci = E (Key, Mi xor Ci-1).  Now suppose her password is R. The main idea is that we can verify the correctness of our assumption! <br><br>  So, we know (because we were able to intercept) the initialization vector, which will be used to encrypt the first block of the next message.  This is, accordingly, the last block of the previous message (in encrypted form) - we denote it IV.  We also intercepted and know the value of the block coming in front of Ci - we denote it by Ci-1.  We need this data very much.  With their help, we in a special way form a message so that the first block is equal to the following: <br><br> <code>M1 = Ci-1 xor IV xor P</code> <br> <br>  If the message could be transmitted via the same secure communication channel, the first block of the new message after encryption will look like this: <br><br> <code>C1 = E(Key, M1 xor IV) = <br> = E(Key, (Ci-1 xor IV xor P) xor IV) <br> = E(Key, (Ci-1 xor P)) <br> = i</code> <br> <br>  All I did was use the full form of the M1 record, after which I simplified the formula using the fact that (IV xor IV) is destroyed (a remarkable feature of XOR).  It turns out that if our assumption about the Alice password is correct (that is, M really equals P), then the first encrypted block of the new message C1 will be equal to the previously intercepted Ci!  And vice versa: if the assumption is wrong, there will be no equality.  So we can test our assumptions. <br><br><img src="https://habrastorage.org/storage1/91b927df/1c5657af/22788929/ccd6f5cc.jpg"><br><h4>  Sending a request to the server to implement an SSL attack </h4><br><br><h3>  Features brute force </h3><br>  If we assume that we have a lot of time and many attempts, we can repeat this technique again and again until we find the correct value of M. However, in practice, the M block is 16 bytes in length.  Even if we know the meaning of all but two bytes, we will need 2 ^ 15 (32,768) attempts to guess the remaining bytes.  And if we do not know anything at all?  In short, the technique can work only in one case - if you have some limited number of assumptions about the value of M. More precisely: we need to know most of the contents of this block - this is the only way to exploit the described vulnerability.  There is one trick here. <br>  Suppose that an attacker can control how the data will be located in the block to be encrypted.  Let's go back to the Alice example.  Suppose we know that the length of her password is 8 characters.  If an attacker can arrange the password so that only one character gets into the first block, and the remaining seven hit the next.  The idea is to transfer known data in the first 15 bytes of the first block - then it will be possible to select only the last byte, which is the first character of the password.  For example, suppose you need to send a line of the form: ‚Äúuser: alice password: ********‚Äù, where ‚Äú********‚Äù is the password itself.  If the attacker manages to transfer the string so that it is split into the following blocks "[lice password: *] [******* .........]", then selecting the first character of the password does not seem impracticable challenge  On the contrary, in the worst case, we will need a miserable 256 attempts.  And in the case of special luck, and at all alone :)!  Having picked up the first byte, you can shift the partitioning boundary by one character: that is, to transfer 14 known bytes in the first message.  The block will now end with the first two bytes of the password, the first of which we have already picked up.  And again: we get 256 necessary attempts to guess its second byte.  The process can be repeated until the password is selected.  This principle is also used in BEAST for the selection of secret cookies, and modified request headers are used as known data.  Selection is accelerated by narrowing possible characters (not all can be used in the request), as well as by the assumptions of the name cookies. <br><br><img src="https://habrastorage.org/storage1/8ad87fcc/bebd133c/472b182b/46025019.png"><br><h4>  Only 103 seconds were required to decrypt the secret PayPal cookies. </h4><br><br><h3>  Attack implementation </h3><br>  However, the vulnerability itself and the optimized way to perform decryption have been described for a long time.  What the BEAST developers really did was to implement all the necessary conditions for the execution of the attack: <br><ol><li>  the attacker must be able to listen on network connections initiated by the victim‚Äôs browser; </li><li>  the attacker must be able to embed the agent in the victim's browser; </li><li>  the agent must be able to send arbitrary (more or less) HTTPS requests; </li></ol>  At the very beginning of the material, I already said that an important part of BEAST is the so-called agent, which can transmit requests to the server necessary for an attacker (via a secure protocol).  Researchers have compiled a list of various technologies and browser plug-ins that can fulfill this condition.  As it turned out, there are quite a few of them: Javascript XMLHttpRequest API, HTML5 WebSocket API, Flash URLRequest API, Java Applet URLConnection API, and Silverlight WebClient API.  However, in the first approximation, some of them turned out to be unsuitable due to the presence of restrictions that prevent the implementation of attacks.  As a result, only the HTML5 WebSocket API, the Java URLConnection API, and the Silverlight WebClient API are left.  At the time when researchers reported their bug to vendors, they had a working HTML5 WebSockets agent in their hands.  But this technology is constantly evolving, and the protocol itself is constantly changing.  As a result, a working agent tritely stopped working.  The current version of BEAST, which the guys presented to the public, consists of an agent written in Javascript / Java, and a network sniffer. <br>  Silently injecting an applet or JavaScript to the user is not really that difficult.  But there remains a small nuance - in order for the script or applet to send data over the connection established by the victim, it is necessary to bypass the SOP restrictions (same-origin policy, domain restriction rule).  This is an important security concept for some client-side programming languages, such as JavaScript.  The policy allows scripts on the pages of one site to access methods and properties of each other without restrictions, but prevents access to most methods and properties for pages on different sites.  Simply put, a client running on the same page will not be able to make requests to the desired site (say, Paypal.com).  To circumvent the SOP policy, the authors found a 0day vulnerability in the Java virtual machine and wrote a working float for it.  Just do not think that this allows you to read existing cookies.  If this were true, then why was all this fuss stuffed with encrypted traffic necessary?  Using a flop to bypass the SOP, you can send requests and read server responses (including responses with new cookies), but you cannot read existing cookies that are stored in the browser.  Developers share a story about creating an agent in <a href="http://bit.ly/q6AebB">their blog</a> . <br><br><h3>  Respect </h3><br>  In conclusion, I would like to note the tremendous work of researchers, who not only managed to exploit the vulnerability forgotten by everyone ten years ago, but also put a lot of work to make their utility work.  Within the framework of this material, we have quite strongly simplified the descriptions of the techniques used, trying to convey the basic idea.  But we really enjoyed reading the detailed document from the researchers, in which they tell in detail about the implemented attack.  Good job! <br><br><hr><h4>  Extent of the problem </h4><br>  So what is the scale of the disaster?  Or in other words - who is vulnerable?  Virtually any site that uses TLS1.0, which is the most common security protocol.  It's funny that after all this hype with BEAST, many began to show interest in newer versions of the protocol - TLS 1.1 and higher.  But how many sites now support these protocols?  Yes, almost no one!  Look at the illustration.  Even though TLS 1.1 is already five years old, it has been used by units! <br><br><img src="https://habrastorage.org/storage1/5906823c/c5b130ce/c8daac09/9a311672.png"><br><br>  Another question: how to protect yourself?  In fact, it makes no sense to panic - the vulnerability has already been fixed in most browsers.  But if paranoia prevails, you can try disabling insecure protocols in the browser (TLS 1.0 and SSL 3.0), and at the same time Java.  True, it is not necessary in this case to be very surprised that many sites will stop working. <hr><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eec/3f4/ac1/eec3f4ac15509cde0644e6504ae18e06.jpg" alt="image"><br>  <i>Journal Hacker, <a href="http://www.xakep.ru/articles/magazine/default.asp">November (11) 154</a></i> <i><br></i>  <i>Collective intelligence</i> . <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="http://bit.ly/habr_subscribe_paper">1 999 .</a>  <a href="http://bit.ly/habr_subscribe_paper">for 12 numbers of paper version</a> </li><li>  <a href="http://bit.ly/digital_xakep">1249r.</a>  <a href="http://bit.ly/digital_xakep">for an annual subscription to iOS / iPad (Android'a release soon!)</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/132344/">https://habr.com/ru/post/132344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132337/index.html">Create a picture counter</a></li>
<li><a href="../132338/index.html">Opera 11.60 beta</a></li>
<li><a href="../132339/index.html">Introduced modular game controller for professional gamers.</a></li>
<li><a href="../132340/index.html">Javascript impurity for dummies</a></li>
<li><a href="../132343/index.html">Marketing Planning Module: A Strategic Approach</a></li>
<li><a href="../132345/index.html">Autosave, or Preserve time and nerve cells</a></li>
<li><a href="../132346/index.html">Personal data from the FIU got into the Internet</a></li>
<li><a href="../132347/index.html">Mielophone - a month later</a></li>
<li><a href="../132349/index.html">Your task switch logging in one day</a></li>
<li><a href="../132350/index.html">European Internet market and promotion of startups abroad</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>