<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Investigating the performance issues of calling ClassLoader.getResourceAsStream</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you're wondering how a call to the ClassLoader.getResourceAsStream () method in an Android application can take 1432ms and how dangerous some libra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Investigating the performance issues of calling ClassLoader.getResourceAsStream</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f17/6ea/a03/f176eaa03305493d871870040b054a84.png" alt="image"><br><br>  If you're wondering how a call to the ClassLoader.getResourceAsStream () method in an Android application can take 1432ms and how dangerous some libraries can be - please under cat. <br><br><a name="habracut"></a><br><h3>  Description of the problem </h3><br>  Exploring performance problems in android applications, I noticed this method.  The problem manifested itself only at the very first call, all subsequent took a few milliseconds.  An interesting feature was that the problem is in a very large number of applications, ranging from <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.amazon.kindle">Amazon's Kindle</a> with more than 100,000,000 downloads to small ones with a couple of hundreds of downloads. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Another feature is that in different applications, this method took a completely different time.  Here, for example, is the time for the most popular selfie application: <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.linecorp.b612.android">B612 - Selfie from the heart</a> <br><br><img src="https://habrastorage.org/files/e06/3e4/f4a/e063e4f4a7444fa89be59f27d0250907.png" alt="image"><br><br>  As we see, here the method takes 771ms, which is also not small, but much less than 1432ms. <br><br>  Some more very popular apps to highlight how big the problem is. <br>  (For profiling applications, the <a href="https://nimbledroid.com/">https://nimbledroid.com</a> service was used) <br><table><thead><tr><th>  application </th><th>  Runtime getResourceAsStream () </th></tr></thead><tbody><tr><td>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.yahoo.mobile.client.android.fantasyfootball">Yahoo Fantasy Sports</a> </td><td>  <a href="https://nimbledroid.com/play/com.yahoo.mobile.client.android.fantasyfootball%3Fp%3D2DH2RIaB5laac7">2166ms</a> </td></tr><tr><td>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.timehop">Timehop</a> </td><td>  <a href="https://nimbledroid.com/play/com.timehop%3Fp%3D2DGvNGHPt4RT7M">1538ms</a> </td></tr><tr><td>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.audible.application">Audiobooks from Audible</a> </td><td>  <a href="https://nimbledroid.com/play/com.audible.application%3Fp%3D2ykMPeQdcgf9C6">1527ms</a> </td></tr><tr><td>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.nike.plusgps">Nike + Running</a> </td><td>  <a href="https://nimbledroid.com/play/com.nike.plusgps%3Fp%3D2L8gQfE5v08CUl">1432ms</a> </td></tr><tr><td>  <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.booking">Booking.com Hotel Reservations</a> </td><td>  <a href="https://nimbledroid.com/play/com.booking%3Fp%3D2LAevyLAo1Ej3X">497ms</a> </td></tr></tbody></table><br>  And many more others. <br><br>  Let's take a closer look at the call stack of some applications. <br><br>  <a href="https://nimbledroid.com/play/jp.naver.line.android%3Fp%3D2ym4cYt4JpnU17">LINE: Free Calls &amp; Messages</a> : <br><img src="https://habrastorage.org/files/1c8/e58/9bc/1c8e589bcb694810870c1d3089f9c35e.png" alt="image"><br>  As we can see, the call to getResourceAsStream is NOT in the main stream.  This means that Line developers know how slow it is. <br><br>  <a href="https://nimbledroid.com/play/com.yahoo.mobile.client.android.fantasyfootball%3Fp%3D2DH2RIaB5laac7">Yahoo Fantasy Sports</a> : <br><img src="https://habrastorage.org/files/dea/d64/b7a/dead64b7a5d44acfa46b01cb364a7dc5.png" alt="image"><br>  The call does not occur in the application code, but inside the <a href="http://www.joda.org/joda-time/">JodaTime</a> library <br><br>  <a href="https://nimbledroid.com/play/com.audible.application%3Fp%3D2ykMPeQdcgf9C6">Audiobooks from Audible</a> <br><img src="https://habrastorage.org/files/18c/565/ffc/18c565ffcaed4845b95b64d555d03592.png" alt="image"><br>  The call takes place in the library Logging <a href="http://logback.qos.ch/">Logback</a> <br><br>  After analyzing applications with this problem, it becomes clear that this call is mainly used in various libraries and SDKs that are distributed as jar files.  This is logical, because in this way we can access resources, moreover, this code will work on Android, and in the world of great Java.  Many come to Android development with Java experience and, of course, begin to use familiar libraries, not knowing how slow their applications are.  I think now it is clear why so many applications are affected. <br><br>  In fact, they know about the problem, for example, there were such questions on stackoverflow: <a href="http://stackoverflow.com/questions/5059663/android-java-joda-date-is-slow">Android Java - Joda Date is slow</a> <br>  Back in 2013, this post was written: <a href="http://blog.danlew.net/2013/08/20/joda_time_s_memory_issue_in_android/">http://blog.danlew.net/2013/08/20/joda_time_s_memory_issue_in_android/</a> and this library appeared <a href="https://github.com/dlew/joda-time-android">https://github.com/dlew/joda-time-android</a> . <br><br>  <strong>BUT</strong> <br><ol><li>  There are still many applications that use the regular version of JodaTime. </li><li>  There are many other libraries and SDKs with the same problem. </li></ol><br>  Now that the problem is clear, let's try to figure out what causes it. <br><br><br><h3>  Research problem </h3><br>  To do this, we will understand the source code of Android. <br>  I will not dwell on where to find the sources, how to build AOSPs, etc., but get right down to business, for those who still want to try to figure it out on their own and repeat my path, start here: <a href="https://source.android.com/">https: // source.android.com/</a> <br><br>  I will use the <strong>android-6.0.1_r11 branch</strong> <br><br>  Let's open the <a href="">libcore / libart / src / main / java / java / lang / ClassLoader.java file</a> and look at the getResourceAsStream code: <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResourceAsStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String resName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { URL url = getResource(resName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url.openStream(); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ex) { <span class="hljs-comment"><span class="hljs-comment">// Don't want to see the exception. } return null; }</span></span></code> </pre> <br>  Everything looks quite simple, first we find the path to the resource, and if it is not null, then open it with the openStream () method, which is in java.net.URL <br><br>  Let's look at the implementation of getResource (): <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String resName)</span></span></span><span class="hljs-function"> </span></span>{ URL resource = parent.getResource(resName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resource == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { resource = findResource(resName); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resource; }</code> </pre> <br>  Still nothing interesting, findResource (): <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String resName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Ok, so findResource () is not implemented.  ClassLoader is an abstract class, which means we need to find which class is used in real applications.  If we open the documentation: <a href="http://developer.android.com/reference/java/lang/ClassLoader.html">http://developer.android.com/reference/java/lang/ClassLoader.html</a> , then we will see: <strong>Android provides you with some concrete implementations of the class, with PathClassLoader being one one used.</strong>  . <br><br>  I want to make sure of this, so I collected the AOSP by modifying getResourceAsStream () in the same way: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResourceAsStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String resName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"RESEARCH"</span></span>).info(<span class="hljs-string"><span class="hljs-string">"this: "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); URL url = getResource(resName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url.openStream(); } ...</code> </pre> <br>  I got what was expected - <strong>dalvik.system.PathClassLoader</strong> , but if we check the source <strong>PathClassLoader</strong> , we will not find the implementation of <strong>findResource ()</strong> .  In fact, <strong>findResource () is</strong> implemented in the parent class <strong>BaseDexClassLoader</strong> . <br>  <a href="">/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java</a> : <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pathList.findResource(name); }</code> </pre> <br>  Let's find the <strong>pathList</strong> (I do not specifically delete the comments of the developers to make it easier to understand what is what): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseDexClassLoader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassLoader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DexPathList pathList; <span class="hljs-comment"><span class="hljs-comment">/** * Constructs an instance. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> dexPath the list of jar/apk files containing classes and * resources, delimited by {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> File.pathSeparator}, which * defaults to {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> ":"} on Android * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> optimizedDirectory directory where optimized dex files * should be written; may be {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> null} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> libraryPath the list of directories containing native * libraries, delimited by {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> File.pathSeparator}; may be * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> null} * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> parent the parent class loader */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseDexClassLoader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(parent); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathList = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DexPathList(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, dexPath, libraryPath, optimizedDirectory); }</code> </pre> <br>  Let's go to this <strong>DexPathList</strong> . <br>  <a href="">libcore / dalvik / src / main / java / dalvik / system / DexPathList.java</a> : <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * A pair of lists of entries, associated with a {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> ClassLoader}. * One of the lists is a dex/resource path &amp;mdash; typically referred * to as a "class path" &amp;mdash; list, and the other names directories * containing native code libraries. Class path entries may be any of: * a {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> .jar} or {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> .zip} file containing an optional * top-level {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> classes.dex} file as well as arbitrary resources, * or a plain {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> .dex} file (with no possibility of associated * resources). * * &lt;p&gt;This class also contains methods to use these lists to look up * classes and resources.&lt;/p&gt; */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*package*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DexPathList</span></span></span><span class="hljs-class"> </span></span>{</code> </pre> <br>  It seems we have found a place where a resource search is actually performed. <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Finds the named resource in one of the zip/jar files pointed at * by this instance. This will find the one in the earliest listed * path element. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> a URL to the named resource or {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> null} if the * resource is not found in any of the zip/jar files */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element element : dexElements) { URL url = element.findResource(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  <strong>Element</strong> is just a static inner class in <strong>DexPathList</strong> .  And inside it there is a much more interesting code: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> URL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ maybeInit(); <span class="hljs-comment"><span class="hljs-comment">// We support directories so we can run tests and/or legacy code // that uses Class.getResource. if (isDirectory) { File resourceFile = new File(dir, name); if (resourceFile.exists()) { try { return resourceFile.toURI().toURL(); } catch (MalformedURLException ex) { throw new RuntimeException(ex); } } } if (zipFile == null || zipFile.getEntry(name) == null) { /* * Either this element has no zip/jar file (first * clause), or the zip/jar file doesn't have an entry * for the given name (second clause). */ return null; } try { /* * File.toURL() is compliant with RFC 1738 in * always creating absolute path names. If we * construct the URL by concatenating strings, we * might end up with illegal URLs for relative * names. */ return new URL("jar:" + zip.toURL() + "!/" + name); } catch (MalformedURLException ex) { throw new RuntimeException(ex); } }</span></span></code> </pre> <br>  Let's stop at this a little bit.  As we know, APK is just a zip file.  As we see: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zipFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || zipFile.getEntry(name) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) {</code> </pre> <br>  we are trying to find the ZipEntry by name, and if we find it, we return java.net.URL.  This may be a rather slow operation, but if we check the <strong>getEntry</strong> implementation, we will see that this is just an iteration on LinkedHashMap: <br><br>  <a href="">/libcore/luni/src/main/java/java/util/zip/ZipFile.java</a> : <br><pre> <code class="java hljs">... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LinkedHashMap&lt;String, ZipEntry&gt; entries = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinkedHashMap&lt;String, ZipEntry&gt;(); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ZipEntry </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String entryName)</span></span></span><span class="hljs-function"> </span></span>{ checkNotClosed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entryName == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NullPointerException(<span class="hljs-string"><span class="hljs-string">"entryName == null"</span></span>); } ZipEntry ze = entries.get(entryName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ze == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { ze = entries.get(entryName + <span class="hljs-string"><span class="hljs-string">"/"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ze; }</code> </pre> <br>  This is not a super fast operation, but it can not take a lot of time. <br><br>  We missed one thing: before working with Zip files, we have to open them.  If we again look at the implementation of the <strong>DexPathList.Element.findResource ()</strong> method, we will see a call to <strong>maybeInit ();</strong>  . <br>  Let's check it out: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maybeInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (initialized) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } initialized = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isDirectory || zip == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { zipFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZipFile(zip); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException ioe) { <span class="hljs-comment"><span class="hljs-comment">/* * Note: ZipException (a subclass of IOException) * might get thrown by the ZipFile constructor * (eg if the file isn't actually a zip/jar * file). */</span></span> System.logE(<span class="hljs-string"><span class="hljs-string">"Unable to open zip file: "</span></span> + zip, ioe); zipFile = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre> <br>  Here it is!  This line is: <br><pre> <code class="java hljs">zipFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ZipFile(zip);</code> </pre> <br>  open zip file for reading. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ZipFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ZipException, IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(file, OPEN_READ); }</code> </pre> <br>  This is a very slow operation, here we initialize the <strong>entries</strong> LinkedHashMap.  Obviously, the larger the zip file, the longer it will take to open it.  Because of the <strong>initialized</strong> flag, we only open the zip file once, which explains why subsequent calls happen quickly. <br><br>  To understand more about the internal structure of a Zip file, look at the sources: <br>  <a href="">https://android.googlesource.com/platform/libcore/+/android-6.0.1_r21/luni/src/main/java/java/util/zip/ZipFile.java</a> <br><br>  I hope it was interesting!  Because it is only the beginning. <br>  In fact, while we dealt only with the challenge: <br><pre> <code class="java hljs">URL url = getResource(resName);</code> </pre> <br>  But if we change the getResourceAsStream code like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResourceAsStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String resName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end; start = System.currentTimeMillis(); URL url = getResource(resName); end = System.currentTimeMillis(); Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"RESEARCH"</span></span>).info(<span class="hljs-string"><span class="hljs-string">"getResource: "</span></span> + (end - start)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { start = System.currentTimeMillis(); InputStream inputStream = url.openStream(); end = System.currentTimeMillis(); Logger.getLogger(<span class="hljs-string"><span class="hljs-string">"RESEARCH"</span></span>).info(<span class="hljs-string"><span class="hljs-string">"url.openStream: "</span></span> + (end - start)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inputStream; } ...</code> </pre> <br>  If we <strong>compile</strong> AOSP and test a couple of applications, we will see that <strong>url.openStream () takes much more time than getResource ()</strong> . <br><br><br><h3>  url.openStream () </h3><br>  In this part I will omit some not very interesting moments.  If we move along the call chain from <strong>url.openStream ()</strong> , then we will go to <a href="">/libcore/luni/src/main/java/libcore/net/url/JarURLConnectionImpl.java</a> : <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> InputStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInputStream</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closed) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalStateException(<span class="hljs-string"><span class="hljs-string">"JarURLConnection InputStream has been closed"</span></span>); } connect(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jarInput != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jarInput; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jarEntry == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Jar entry not specified"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jarInput = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JarURLConnectionInputStream(jarFile .getInputStream(jarEntry), jarFile); }</code> </pre> <br>  Let's check the <strong>connect ()</strong> method: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!connected) { findJarFile(); <span class="hljs-comment"><span class="hljs-comment">// ensure the file can be found findJarEntry(); // ensure the entry, if any, can be found connected = true; } }</span></span></code> </pre> <br>  Nothing interesting, we need to go deeper :) <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findJarFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (getUseCaches()) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (jarCache) { jarFile = jarCache.get(jarFileURL); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jarFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { JarFile jar = openJarFile(); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (jarCache) { jarFile = jarCache.get(jarFileURL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jarFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { jarCache.put(jarFileURL, jar); jarFile = jar; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { jar.close(); } } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { jarFile = openJarFile(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jarFile == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(); } }</code> </pre> <br>  This is an interesting method and here we will stop.  <strong>getUseCaches ()</strong> through a call chain will lead us to <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLConnection</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> defaultUseCaches = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; ...</code> </pre> <br>  This value is not overridden, so we will see the use of cache: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HashMap&lt;URL, JarFile&gt; jarCache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;URL, JarFile&gt;();</code> </pre> <br>  <strong>In the findJarFile () method we see the second performance problem!</strong>  Zip file opens again!  Naturally this will not work quickly, especially for applications that are 40mb in size :) <br><br>  There is another interesting point, let's check the <strong>openJarFile ()</strong> method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> JarFile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openJarFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jarFileURL.getProtocol().equals(<span class="hljs-string"><span class="hljs-string">"file"</span></span>)) { String decodedFile = UriCodec.decode(jarFileURL.getFile()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JarFile(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(decodedFile), <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, ZipFile.OPEN_READ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ...</code> </pre> <br>  As you can see, we are creating NOT <strong>ZipFile</strong> , but <strong>JarFile</strong> .  JarFile is the heir of ZipFile, let's check what it adds: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Create a new {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@code</span></span></span><span class="hljs-comment"> JarFile} using the contents of file. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> file * the JAR file as {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> File}. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> verify * if this JAR filed is signed whether it must be verified. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> mode * the mode to use, either {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> ZipFile#OPEN_READ OPEN_READ} or * {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> ZipFile#OPEN_DELETE OPEN_DELETE}. * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> IOException * If the file cannot be read. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">JarFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> verify, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mode)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(file, mode); <span class="hljs-comment"><span class="hljs-comment">// Step 1: Scan the central directory for meta entries (MANIFEST.mf // &amp; possibly the signature files) and read them fully. HashMap&lt;String, byte[]&gt; metaEntries = readMetaEntries(this, verify); // Step 2: Construct a verifier with the information we have. // Verification is possible *only* if the JAR file contains a manifest // *AND* it contains signing related information (signature block // files and the signature files). // // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Is this really the behaviour we want if verify == true ? // We silently skip verification for files that have no manifest or // no signatures. if (verify &amp;&amp; metaEntries.containsKey(MANIFEST_NAME) &amp;&amp; metaEntries.size() &gt; 1) { // We create the manifest straight away, so that we can create // the jar verifier as well. manifest = new Manifest(metaEntries.get(MANIFEST_NAME), true); verifier = new JarVerifier(getName(), manifest, metaEntries); } else { verifier = null; manifestBytes = metaEntries.get(MANIFEST_NAME); } }</span></span></code> </pre> <br>  Yeah, that's the difference!  As we know, the APK file must be signed, and the <strong>JarFile</strong> class will verify this. <br><br>  I will not go further if you want to understand how verification works, see here: <a href="https://android.googlesource.com/platform/libcore/%2B/android-6.0.1_r21/luni/src/main/java/java/util/jar/">https://android.googlesource.com/platform/libcore/+/android-6.0.1_r21/luni/src/main/java/java/util / jar /</a> . <br><br>  <strong>But what needs to be said is that this is a very very slow process.</strong> <br><br><br><h3>  Conclusion </h3><br>  When ClassLoader.getResourceAsStream () is called for the first time, the APK file opens as a zip file to find the resource.  After that, it opens a second time, but with verification to open the InputStream.  It also explains why there is such a big difference in call speed for different applications, it all depends on the size of the APK file and how many files are inside! <br><br><br><h3>  One more thing </h3><br>  If in nimbledroid in the <strong><a href="https://nimbledroid.com/play/com.yahoo.mobile.client.android.fantasyfootball%3Fp%3D2DH2RIaB5laac7">Full Stack Trace</a></strong> section in the upper right corner you click on the <strong>Expand Android Framework</strong> , you will see all the methods we went through: <br><img src="https://habrastorage.org/files/688/e4c/869/688e4c8698d9410f9dd0ede550b911e6.png" alt="image"><br><h3>  Q &amp; A </h3><br>  <strong>Q: Is there any difference between the Dalvik and ART runtime and the work of the getResourceAsStream () call</strong> <br><br>  A: Actually, no, I checked several AOSP branches <strong>android-6.0.1_r11</strong> with ART and <strong>android-4.4.4_r2</strong> with Dalvik.  The problem is in both! <br>  The difference between them is slightly different, but much has been written about this :) <br><br>  <strong>Q: Why is there no such problem when calling ClassLoader.findClass ()</strong> <br><br>  A: If we move to the class <strong>DexPathList</strong> , which is already familiar to us, we will see: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, List&lt;Throwable&gt; suppressed)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Element element : dexElements) { DexFile dex = element.dexFile; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dex != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (clazz != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clazz; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dexElementsSuppressedExceptions != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre> <br>  Following the call chain we will come to the method: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> Class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">defineClassNative</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, ClassLoader loader, Object cookie)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> ClassNotFoundException, NoClassDefFoundError</span></span>;</code> </pre> <br>  And then how it will work will depend on the runtime (ART or Dalvik), but as we see, no work with <strong>ZipFile</strong> . <br><br>  <strong>Q: Why calls to Resources.get ... (resId) do not have this problem</strong> <br><br>  A: For the same reason as ClassLoader.findClass (). <br>  All these calls will lead us to <a href="">/frameworks/base/core/java/android/content/res/AssetManager.java</a> <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Returns true if the resource was found, filling in mRetStringBlock and * mRetData. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadResourceValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ident, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> density, TypedValue outValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> resolve)</span></span></span></span>;</code> </pre> <br><br><br><br>  Thanks for attention!  <strong>Happy coding!</strong> <br></div><p>Source: <a href="https://habr.com/ru/post/280340/">https://habr.com/ru/post/280340/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280330/index.html">Belgian security forces used WhatsApp because of the attacks</a></li>
<li><a href="../280332/index.html">Device Guard in Windows 10. Code Integrity Policy</a></li>
<li><a href="../280334/index.html">As one programmer Jocly shoe</a></li>
<li><a href="../280336/index.html">IBM has released a new generation of storage - Storwize v5000 Gen2</a></li>
<li><a href="../280338/index.html">Juniper Networks Routing, Switching and Security Solutions and Updates</a></li>
<li><a href="../280344/index.html">Rules for working with Tasks API. Part 2</a></li>
<li><a href="../280346/index.html">Dive into Centrifugo</a></li>
<li><a href="../280348/index.html">Police against the mafia or entertaining statistics online stage NeoQUEST-2016</a></li>
<li><a href="../280354/index.html">The book "Computer Networks. Principles, technologies, protocols "</a></li>
<li><a href="../280356/index.html">aBeing One: at the center of the Internet of Things</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>