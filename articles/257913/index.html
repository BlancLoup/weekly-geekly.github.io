<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote a Docker container launch audit on Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Universal containerization captures the world. This epidemic has not bypassed me either, and now, for the last six months, I have been doing what is n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote a Docker container launch audit on Go</h1><div class="post__text post__text-html js-mediator-article">  Universal containerization captures the world.  This epidemic has not bypassed me either, and now, for the last six months, I have been doing what is now called the buzzword DevOps.  We decided to use <a href="https://www.docker.com/">Docker</a> in projects that I do, because it makes the process of deploying applications obscenely simple, and literally forces you to follow another trend that is no less fashionable today - microservice architecture, which promotes the rapid reproduction of these containers based on it.  At some point, you realize that it would be nice to collect statistics on their life and death in an unsafe environment.  And as a bonus, explore the tools that you use in your work, write something not in the main programming language, and just do something optional, but useful. <br><br>  In the article I will tell you how for three evenings and a piece of night a project was developed for auditing and collecting statistics on the life cycle of containers. <br><a name="habracut"></a><br><h1>  First half </h1><br>  A quick search in Google did not lead to finding a ready-made solution, so we will do it ourselves. <br>  What do you need: <br><ul><li>  monitoring the start and stop of an individual container taken </li><li>  sending event messages to some storage </li><li>  convenient tool for viewing events and their subsequent analysis </li></ul><br>  The first task is solved by the <a href="https://github.com/gliderlabs/registrator">registrator</a> .  This is a solution from the guys from GliderLabs, which allows you to automatically register containers in configuration storage systems, such as onsul or Netflix Eurika.  Unfortunately, the latter are sharpened for a completely different task: to say what services are now available, and where are the containers that implement them. <br><br>  If we consider each event (the launch or death of the container) as a record of a certain log, with which we can do everything we need, then to store these records you can take ElasticSearch, and for viewing and analysis in real time - Kibana. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It remains for us to decide the second point, namely, to make a link between the registrar and the elastic. <br><br><h1>  How is the recorder </h1><br>  Any entertainment begins with a fork, so feel free to click a button on the GitHub for the repository (https://github.com/gliderlabs/registrator).  We clone to our local machine and look at the contents: <br><br><pre><code class="bash hljs">registrator.go //     modules.go //    (consul, etcd  ..) Dockerfile //   docker- Dockerfile.dev //    dev-  /bridge //     /consul //     consul</code> </pre> <br>  The scheme is simple.  In registrator.go, a Docker client is created that listens to the socket, and, if any event occurs (start, stop or death of the container), sends the container identifier and the event associated with it to bridge.  Inside the bridge, an adapter (module) is created, which was specified when the application was started, to which detailed information about the container is already being transmitted for further processing.  Thus, it is enough to add a new module that will send data to ElasticSearch. <br><br><h1>  make dev </h1><br>  Before writing the code, let's try building and running a project.  In the Makefile there is a task, in which a new Docker image is created and launched: <br><br><pre> <code class="bash hljs">dev: docker build -f Dockerfile.dev -t $(NAME):dev . docker run --rm --net host \ -v /var/run/docker.sock:/tmp/docker.sock \ $(NAME):dev /bin/registrator consul:</code> </pre><br>  The consul hints to us that this is the default master system, without which the application will not work.  Put it in the Docker container in standalone mode: <br><br><pre> <code class="bash hljs">$ docker run -p 8400:8400 -p 8500:8500 -p 53:53/udp \ -h node1 progrium/consul -server -bootstrap</code> </pre><br>  Then run the registrar assembly: <br><br><pre> <code class="bash hljs">make dev</code> </pre><br>  If everything went well (unfortunately, luck is such a thing), then we will see something like this: <br><br><pre> <code class="bash hljs">2015/04/04 19:55:48 Starting registrator dev ... 2015/04/04 19:55:48 Using elastic adapter: consul:// 2015/04/04 19:55:48 Listening <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Docker events ... 2015/04/04 19:55:48 Syncing services on 4 containers 2015/04/04 19:55:48 ignored: cedfd1ae9f68 no published ports 2015/04/04 19:55:48 added: b4455d0f7d50 ubuntu:kibana:80 2015/04/04 19:55:48 added: 3d598d184eb6 ubuntu:nginx:80 2015/04/04 19:55:48 ignored: 3d598d184eb6 port 443 not published on host 2015/04/04 19:55:48 added: bcad15ac5759 ubuntu:determined_goldstine:9200 2015/04/04 19:55:48 added: bcad15ac5759 ubuntu:determined_goldstine:9300</code> </pre><br>  As you can see, we had 4 containers.  One of them had no ports, the other had no port 443 published, and so on.  To check that the services have actually been added, you can use the dig utility. <br><br><pre> <code class="bash hljs">dig @localhost nginx-80.service.consul</code> </pre><br>  It is necessary to add -80 to the name of the container, since nginx exposes several ports to the outside, and from the point of view of Consul, these are different services. <br><br>  So, we launched the recorder, which means that it's time to start writing code. <br><br><h1>  Go go go </h1><br>  Adapters in the project for different backends are implemented as separate modules.  In general, Go module is a very interesting thing.  This can be either a local folder or a project on GitHub, there is almost no difference in the connection. <br><br>  Add a new folder to the project root: / elastic and place the file with our future implementation in it: elastic.go. <br><br>  Give the default name for our module <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> elastic</code> </pre><br>  We import the third-party packages we need: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net/url"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gliderlabs/registrator/bridge"</span></span> elasticapi <span class="hljs-string"><span class="hljs-string">"github.com/olivere/elastic"</span></span> )</code> </pre><br>  To handle events, you need to implement an interface <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> RegistryAdapter <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Ping() error <span class="hljs-comment"><span class="hljs-comment">//     Register(service *Service) error Deregister(service *Service) error Refresh(service *Service) error //    :) }</span></span></code> </pre><br>  The adapter is registered through the init () method, which is executed when the module is loaded: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bridge.Register(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Factory), <span class="hljs-string"><span class="hljs-string">"elastic"</span></span>) }</code> </pre><br>  When creating an adapter, you must create an instance of the client to ElasticSearch: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Factory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uri *url.URL)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bridge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegistryAdapter</span></span></span></span> { urls := <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:9200"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> uri.Host != <span class="hljs-string"><span class="hljs-string">""</span></span> { urls = <span class="hljs-string"><span class="hljs-string">"http://"</span></span>+uri.Host } client, err := elasticapi.NewClient(elasticapi.SetURL(urls)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(<span class="hljs-string"><span class="hljs-string">"elastic: "</span></span>, uri.Scheme) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ElasticAdapter{client: client} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ElasticAdapter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { client *elasticapi.Client }</code> </pre><br>  Use the isRunning () method to verify that the instance is still alive. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *ElasticAdapter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { status := r.client.IsRunning() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !status { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"client is not Running"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Let the container record have the following structure: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Container <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"container_name"`</span></span> Action <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"action"`</span></span> <span class="hljs-comment"><span class="hljs-comment">//start and stop Message string `json:"message"` Timestamp string `json:"@timestamp"` }</span></span></code> </pre><br>  Implement container registration method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *ElasticAdapter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service *bridge.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span></code> </pre><br>  We dump all the service information in json. <br><br><pre> <code class="go hljs">serviceAsJson, err := json.Marshal(service) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre><br>  We get the current time.  Go uses funny notation to determine the date format. <br><br><pre> <code class="go hljs">timestamp := time.Now().Local().Format(<span class="hljs-string"><span class="hljs-string">"2006-01-02T15:04:05.000Z07:00"</span></span>)</code> </pre><br>  Create a new entry for the log: <br><br><pre> <code class="go hljs">container := Container { Name: service.Name, Action: <span class="hljs-string"><span class="hljs-string">"start"</span></span>, Message: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(serviceAsJson), Timestamp: timestamp }</code> </pre><br>  And send it to a specially created index <br><br><pre> <code class="go hljs">_, err = r.client.Index(). Index(<span class="hljs-string"><span class="hljs-string">"containers"</span></span>). Type(<span class="hljs-string"><span class="hljs-string">"audit"</span></span>). BodyJson(container). Timestamp(timestamp). Do() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre><br>  The Deregister function completely repeats the previous one, only with a different action. <br><br>  All that remains is to change the consul on elastic to the Makefile, and set the module in modules.go. <br><br><h1>  All together now </h1><br>  Launch ElasticSearch <br><br><pre> <code class="bash hljs">docker run -d --name elastic -p 9200:9200 \ -p 9300:9300 dockerfile/elasticsearch</code> </pre><br>  In order for Kibana to work correctly with the index, you need to add a slightly redesigned template from logstash: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"template"</span></span> : <span class="hljs-string"><span class="hljs-string">"containers*"</span></span>, <span class="hljs-string"><span class="hljs-string">"settings"</span></span> : { <span class="hljs-string"><span class="hljs-string">"index.refresh_interval"</span></span> : <span class="hljs-string"><span class="hljs-string">"5s"</span></span> }, <span class="hljs-string"><span class="hljs-string">"mappings"</span></span> : { <span class="hljs-string"><span class="hljs-string">"_default_"</span></span> : { <span class="hljs-string"><span class="hljs-string">"_all"</span></span> : {<span class="hljs-string"><span class="hljs-string">"enabled"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, <span class="hljs-string"><span class="hljs-string">"dynamic_templates"</span></span> : [ { <span class="hljs-string"><span class="hljs-string">"string_fields"</span></span> : { <span class="hljs-string"><span class="hljs-string">"match"</span></span> : <span class="hljs-string"><span class="hljs-string">"*"</span></span>, <span class="hljs-string"><span class="hljs-string">"match_mapping_type"</span></span> : <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"mapping"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"index"</span></span> : <span class="hljs-string"><span class="hljs-string">"analyzed"</span></span>, <span class="hljs-string"><span class="hljs-string">"omit_norms"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"fields"</span></span> : { <span class="hljs-string"><span class="hljs-string">"raw"</span></span> : {<span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"index"</span></span> : <span class="hljs-string"><span class="hljs-string">"not_analyzed"</span></span>, <span class="hljs-string"><span class="hljs-string">"ignore_above"</span></span> : 256} } } } } ], <span class="hljs-string"><span class="hljs-string">"_ttl"</span></span>: { <span class="hljs-string"><span class="hljs-string">"enabled"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"1d"</span></span> }, <span class="hljs-string"><span class="hljs-string">"properties"</span></span> : { <span class="hljs-string"><span class="hljs-string">"@version"</span></span>: { <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-string"><span class="hljs-string">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"not_analyzed"</span></span> }, <span class="hljs-string"><span class="hljs-string">"geoip"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-string"><span class="hljs-string">"dynamic"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"full"</span></span>, <span class="hljs-string"><span class="hljs-string">"properties"</span></span> : { <span class="hljs-string"><span class="hljs-string">"location"</span></span> : { <span class="hljs-string"><span class="hljs-string">"type"</span></span> : <span class="hljs-string"><span class="hljs-string">"geo_point"</span></span> } } } } } } }</code> </pre><br>  Launch Kibana <br><br><pre> <code class="bash hljs">docker run -d -p 8080:80 -e KIBANA_SECURE=<span class="hljs-literal"><span class="hljs-literal">false</span></span> \ --name kibana --link elastic:es \ balsamiq/docker-kibana</code> </pre><br>  We start the recorder: <br><br><pre> <code class="bash hljs">make dev</code> </pre><br>  We start the container with nginx for testing the solution <br><br><pre> <code class="bash hljs">docker run -d --name nginx -p 80:80 nginx</code> </pre><br>  In Kibana, you need to configure a new index of containers, after which you can see a record of running nginx. <br><br>  The final implementation file is <a href="">here</a> . <br><br><h1>  Logstash bursts into bar </h1><br>  Everyone is good at our solution, but for his work we need to keep a separate self-written index, and still remember to roll the correct template with mapping.  So that people do not bother with such questions, there are log aggregators, who not only know how to collect information from a huge number of sources, but also do all the dirty work for us in terms of bringing logs to a single format.  We will take logstash for our experiments. <br><br>  By tradition, we want to run logstash in a container.  The official Docker image for logstash comes without source files, which in my opinion is somewhat strange ( <i>as the careful reader <a href="https://habrahabr.ru/users/grossws/" class="user_link">noted grossws</a> , the link to the <a href="https://github.com/docker-library/logstash/blob/74708b040ec13a17b49d93a5db0ae11e70e0c1cb/Dockerfile">Dockerfile</a> is still present</i> ).  The second most popular and the only, by the way, <a href="https://github.com/pblittle/docker-logstash">image</a> found on github-e for some reason launches within itself ElasticSearch and Kibana, which contradicts the idea of ‚Äã‚Äã‚Äúone container - one process‚Äù.  There, of course, there is an opportunity to send in a magic combination of flags, but he still climbed at me to take some keys from the author‚Äôs site.  On DockerHub, there were a dozen more containers from unknown persons, so it‚Äôs best to assemble the container ourselves for our needs.  All we need is such a Dockerfile: <br><br><pre> <code class="bash hljs">FROM dockerfile/java:oracle-java8 MAINTAINER aatarasoff@gmail.com RUN <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'deb http://packages.elasticsearch.org/logstash/1.5/debian stable main'</span></span> | sudo tee /etc/apt/sources.list.d/logstash.list &amp;&amp; \ apt-get -y update &amp;&amp; \ apt-get -y --force-yes install logstash EXPOSE 5959 VOLUME [<span class="hljs-string"><span class="hljs-string">"/opt/conf"</span></span>, <span class="hljs-string"><span class="hljs-string">"/opt/certs"</span></span>, <span class="hljs-string"><span class="hljs-string">"/opt/logs"</span></span>] ENTRYPOINT <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> /opt/logstash/bin/logstash agent -f /opt/conf/logstash.conf</code> </pre><br>  The image will be very simple and will start only if there is an external configuration file, which is quite normal for our entertainment tasks.  Collect the image and fill it with the Docker Hub: <br><br><pre> <code class="bash hljs">docker build -t aatarasoff/logstash . docker push aatarasoff/logstash</code> </pre><br><br>  Create the configuration file /mnt/logstash/conf/logstash.conf with the following contents: <br><br><pre> <code class="bash hljs">input { tcp { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"audit"</span></span> port =&gt; 5959 codec =&gt; json } } output { elasticsearch { embedded =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> host =&gt; <span class="hljs-string"><span class="hljs-string">"10.211.55.8"</span></span> port =&gt; <span class="hljs-string"><span class="hljs-string">"9200"</span></span> protocol =&gt; <span class="hljs-string"><span class="hljs-string">"http"</span></span> } }</code> </pre><br>  type =&gt; ‚Äúaudit‚Äù will make all our logs have a common value in the type field, which will allow us to distinguish them from other logs by this discriminator.  The remaining settings are pretty obvious.  Run the newly baked container: <br><br><pre> <code class="bash hljs">docker run -d -p 5959:5959 -v /mnt/logstash/conf:/opt/conf \ --name logstash aatarasoff/logstash</code> </pre><br>  and check that the logs will be written if we send json via tcp. <br><br><h1>  Implementation number 2 </h1><br>  We are already doing the second module, so it is worth putting the implementation into a separate project, which we call <a href="https://github.com/aatarasoff/auditor">auditor</a> .  First of all, we need to wind the already existing "meat" from the registrar.  Therefore, we take our fork and brazenly copy the code into our project. <br><br>  We check that everything is still going on by running the command: make dev. <br><br>  We note that in the regitrator.go file, the bridge module is connected as an external dependency, so you can safely delete this folder.  Check again that everything works. <br><br>  Modify Dockerfile.dev: <br><br><pre> <code class="bash hljs">FROM gliderlabs/alpine:3.1 CMD [<span class="hljs-string"><span class="hljs-string">"/bin/auditor"</span></span>] ENV GOPATH /go RUN apk-install go git mercurial COPY . /go/src/github.com/aatarasoff/auditor RUN <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /go/src/github.com/aatarasoff/auditor \ &amp;&amp; go get -v &amp;&amp; go build -ldflags <span class="hljs-string"><span class="hljs-string">"-X main.Version dev"</span></span> -o /bin/auditor</code> </pre><br>  Similarly, we are changing the release Dockefile.  We remove the extra task and change the name of the container in the Makefile: <br><br><pre> <code class="bash hljs">NAME=auditor VERSION=$(shell cat VERSION) dev: docker build -f Dockerfile.dev -t $(NAME):dev . docker run --rm --net host \ -v /var/run/docker.sock:/tmp/docker.sock \ $(NAME):dev /bin/auditor elastic: build: mkdir -p build docker build -t $(NAME):$(VERSION) . docker save $(NAME):$(VERSION) | gzip -9 &gt; build/$(NAME)_$(VERSION).tgz</code> </pre><br><br>  Add a new module / logstash and a file logstash.go to our project.  Take a ready-made client for logstash, which is dumb as a cork, and in fact is just a wrapper over the standard net library: <a href="https://github.com/heatxsink/go-logstash">github.com/heatxsink/go-logstash</a> . <br><br>  This time the structure of the container will differ slightly from the previous version: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Container <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"container_name"`</span></span> Action <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"action"`</span></span> Service *bridge.Service <span class="hljs-string"><span class="hljs-string">`json:"info"`</span></span> }</code> </pre><br>  This is due to the fact that now we just need to serialize the object in json and send it as a string in logstash, which itself will deal with all the fields in the message. <br><br>  Just like last time we register our factory: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bridge.Register(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(Factory), <span class="hljs-string"><span class="hljs-string">"logstash"</span></span>) }</code> </pre><br>  And create a new instance of the adapter: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *Factory)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uri *url.URL)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bridge</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegistryAdapter</span></span></span></span> { urls := <span class="hljs-string"><span class="hljs-string">"127.0.0.1:5959"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> uri.Host != <span class="hljs-string"><span class="hljs-string">""</span></span> { urls = uri.Host } host, port, err := net.SplitHostPort(urls) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(<span class="hljs-string"><span class="hljs-string">"logstash: "</span></span>, <span class="hljs-string"><span class="hljs-string">"split error"</span></span>) } intPort, _ := strconv.Atoi(port) client := logstashapi.New(host, intPort, <span class="hljs-number"><span class="hljs-number">5000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;LogstashAdapter{client: client} } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> LogstashAdapter <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { client *logstashapi.Logstash }</code> </pre><br>  Here we had to use the net.SplitHostPort (urls) utilization method, which can isolate the host and port from the string, because the client accepts them separately, and they come together at uri.Host. <br><br>  The numeric representation of the port can be obtained using the method of converting a string to a number: intPort, _: = strconv.Atoi (port).  The underscore is needed because the function returns two parameters, the second of which is an error, which we can not handle. <br><br>  The implementation of the Ping method is pretty simple: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *LogstashAdapter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Ping</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { _, err := r.client.Connect() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  In fact, we check that we can connect via tcp to logstash.  In the Connect function, reconnection will occur only if the current one can no longer be used. <br><br>  It remains to implement the registration method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *LogstashAdapter)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(service *bridge.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { container := Container{Name: service.Name, Action: <span class="hljs-string"><span class="hljs-string">"start"</span></span>, Service: service} asJson, err := json.Marshal(container) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } _, err = r.client.Connect() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } err = r.client.Writeln(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(asJson)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  I think that the code is clear enough and does not require comments, except for one.  Calling Connect before Writeln ensures that a working connection is received. <br><br>  The Deregister Method is a complete copy of the method above. <br><br>  We change the dockerfile.dev in the elastic launch line to logstash, run and check for the presence of records in ElasticSearch: <br><br><pre> <code class="bash hljs">curl <span class="hljs-string"><span class="hljs-string">'http://localhost:9200/_search?pretty'</span></span></code> </pre><br><br><h1>  ... share your happiness with others </h1><br>  Let's commit our changes to GitHub and go to build an image for DockerHub.  On <a href="https://hub.docker.com/">hub.docker.com</a> , go to your page and click the button + Add Repository.  When I was going to create an image for logstash, I chose the Repository sub-item, which allows you to manually upload your images, but there is another way - Automated Build.  By clicking on it, Docker Hub will offer to connect your account to it on GitHub or BitBucket.  After that, it remains only to choose your repository, the desired branch, and change the image names, if it is very necessary.  Everything else, including the transfer of the description from README.MD will take over the Docker Hub. <br><br>  After a short wait, here it is - the finished <a href="https://registry.hub.docker.com/u/aatarasoff/auditor/">image</a> . <br><br>  Now you can test it by executing a simple command: <br><br><pre> <code class="bash hljs">docker run -d --net=host \ -v /var/run/docker.sock:/tmp/docker.sock \ --name auditor aatarasoff/auditor logstash://</code> </pre><br><br>  <b>Ps.</b>  The project is not used in production, and from my critical point of view it requires finishing, but everyone who reads an article can try it and, if desired, improve it. </div><p>Source: <a href="https://habr.com/ru/post/257913/">https://habr.com/ru/post/257913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257899/index.html">Revelations metaprogrammer. We program the code at compile time, use C ++ templates for non-template solutions.</a></li>
<li><a href="../257903/index.html">Introduction to functional programming in Python</a></li>
<li><a href="../257905/index.html">Travel SIM + cloud PBX and new approaches to the IP-PBX interface</a></li>
<li><a href="../257909/index.html">Sergey Borisyuk: ‚ÄúThe most important thing in startups is the focus‚Äù</a></li>
<li><a href="../257911/index.html">Determining network topology at OSI levels 2/3</a></li>
<li><a href="../257915/index.html">How to use progressive improvement for the layout of letters</a></li>
<li><a href="../257917/index.html">What gives the translation of the description and keywords for the mobile application. The results of a big experiment</a></li>
<li><a href="../257919/index.html">Need for speed: Optimization of the trading terminal performance</a></li>
<li><a href="../257921/index.html">Open Document Document Generator (ODF) on Go</a></li>
<li><a href="../257923/index.html">JavaScript frameworks How to study them quickly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>