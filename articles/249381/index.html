<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>STM32 and FreeRTOS. 3. We stand in line</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before: about threads and about semaphores 

 ‚ÄúThere are many of you, but I am alone!‚Äù Is the classic phrase of the saleswoman, who was terrorized by ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>STM32 and FreeRTOS. 3. We stand in line</h1><div class="post__text post__text-html js-mediator-article">  Before: <a href="http://habrahabr.ru/post/249273/">about threads</a> and <a href="http://habrahabr.ru/post/249283/">about semaphores</a> <br><br>  ‚ÄúThere are many of you, but I am alone!‚Äù Is the classic phrase of the saleswoman, who was terrorized by the buyers with the questions ‚ÄúIs there ...?‚Äù.  Here and in microcontrollers completely similar situations occur, when several threads require attention from some slow thing, which is simply not physically able to serve everyone at once. <br><br>  Let us take the most vivid and problem-rich example in which most inexperienced programmers ‚Äúfall down‚Äù.  There is a powerful and fairly fast microcontroller.  On one side, the com-port adapter is connected to it, through which the user issues commands and receives results, and on the other side, a stepping motor that rotates at some angle according to these commands.  And of course, a cool button, which also means something for the user.  Where can I catch problems? <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's go by the user.  Com-port, or USART (universal synchronous / asynchronous receiver / transmitter) is a very delicate and capricious thing.  The main whim is that it can not be left without attention.  For one simple reason - to save conclusions, in 99% of cases, only transmit and receive signals are output, leaving transmit and receive permission signals (rtr / rts, dtr, cts, etc.) overboard.  And it is worth the microprocessor to hesitate just a little, as the character will be lost.  Judge for yourself: the magic numbers 9600 / 8N1 tell us that 9600 baud flies per second, and one character is encoded with 10 (1 starting, 8 data and 1 stop) pulses.  As a result, the maximum transmission rate is 9600/10 = 960 bytes per second.  Or just over one millisecond per byte.  And if on TZ the transmission rate is 115200?  But the microcontroller must also process this data.  It seems that everything is bad, but in reality, a lot of devices work and do not cause problems.  What solutions apply? <br><br>  The most common (and correct) solution is to relocate all the work on receiving or transmitting characters on the shoulders of the microcontroller.  Now everyone has learned to make a hardware usart port, so a typical solution in most cases looks like this: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">URARTInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ a=GetCharFromUSART(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(a!=<span class="hljs-number"><span class="hljs-number">0x13</span></span>) buffer[count++]=a; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startProcessing(); }</code> </pre> <br><br>  Where is the problem?  First, the problem is in calling startProcessing.  It is worth this function at least a little delay in the work, as the next character will be lost.  We take STM32L1 (which at the minimum frequency manages to process only 84 commands in 1 ms) and with more or less razysyushchem logic the resulting construction will lose characters. <br><br>  After a friendly pat on the head in our studio, the programmer rewrites the code so that instead of calling startProcessing, the semaphore rises, which would start the processing of the received data.  And then he got the following problem in full growth: while startProcessing is grinding something out of the buffer, the processor of the new symbol starts to overwrite the buffer that has not yet been processed.  After the next torn sweater and faded book on the buffers, the programmer implements a ring buffer with pointers, than he digs into the problem even deeper. <br><br>  Usually somewhere in this place I notice the surprised eyes of the people and the indignant cries in the spirit of "well, such algorithms work in a bunch of projects and nothing, no problems."  Yes, they work.  But in what projects?  Only in those where all communication with the controller can be transferred to half-duplex mode, as in radios.  Here is an example of user (P) and controller (K) dialog. <br><br>  <i>P: ATZ (Controller, are you alive?)</i> <i><br></i>  <i>K: OK (Yeah, I'm here)</i> <i><br></i>  <i>P: M340.1 (Do something).</i> <i><br></i>  <i>(there may be a pause, sometimes very large)</i> <i><br></i>  <i>K: ok (made type)</i> <br><br>  Where are the problems?  First, you cannot send multiple teams in a row.  This means either it will be necessary to change the logic or make complex commands with several parameters.  Secondly, there can be no other requests and responses between the request and the response.  But what if the user presses a button while moving?  What to do?  There is only one way out - to use the native nature of the port, namely, its asynchrony.  As a result, the dialogue between the user and the controller looks like this. <br><br>  <i>P: ATZ (alive?)</i> <i><br></i>  <i>K: OK (aha)</i> <i><br></i>  <i>P: M340.1</i> <i><br></i>  <i>K: K1 = 1 (button pressed)</i> <i><br></i>  <i>: 333,25,2</i> <i><br></i>  <i>(silence)</i> <i><br></i>  <i>K: E = 1 (task E completed)</i> <i><br></i>  <i>K: M = 1 (task M completed)</i> <br><br>  Of course, the logic of processing such a stream becomes a bit more complicated, but thanks to such asynchrony we immediately get many advantages over the ‚Äúclassical school‚Äù. <br><br>  First, the responsiveness of the user interface dramatically increases.  Well, a motor works there somewhere or something is considered, but this is not a reason to ‚Äúfreeze‚Äù or ‚Äúslow down‚Äù.  And when the customer realizes that the size of the brakes practically does not depend on the power of the controller, he has reasonable questions ... <br>  Secondly, this behavior is closer to the behavior of a small boss in real life.  And copying this behavior is very easy - everyone saw it, everyone participated. <br>  Finally, we divide the flow of control into ‚Äúcommand‚Äù and ‚Äústatus‚Äù.  As a result, the implementation of any indicators of the volume of the task or turn angles in real time is not difficult. <br><br>  And now with all these ideas take a look at the opposite side - on the side of the performer.  It is slow enough to simply not have time to process the commands in order.  And the start-stop time of the motor is very large, so it would be good to do a primitive optimization in the spirit of "if two teams arrived on a turn in one direction, then turn it at a time." <br><br>  What does a regular programmer do?  Since he read the previous articles and a handful of books, he draws logic, setting the semaphores as necessary, and uses mutexes to block simultaneous access to the little motor.  All is well, but the code is cumbersome and hard to read.  What to do?  At studiovsemoe.com we use Sharikov‚Äôs recipe: ‚ÄúIn line, you sons of bitches!  In queue!".  Again, the concept of the queue is absorbed almost with mother's milk, so there are no problems with understanding. <br><br>  In this example, you can simply create three queues.  The first is the commands received from the user.  Everything is thrust into it (well, or after a minimal check), which is accepted from all input ports.  The second is the data that must be given to the user.  The state of the buttons, the results of calculations and so on.  And finally, the third stage is used for tasks for a motor / reader / someone else.  And between these queues there are threads for converting data from the user into tasks for the reader.  Since FreeRTOS has official functions for ‚Äúpeeping‚Äù inside the queue, it is easy to make optimization for cases when the next action continues / repeats the current one. <br><br>  So, only three turns, and a wild bunch of problems solved.  First, there is not even the potential problem of losing or rewriting the buffer of received characters.  True, the result will be a little more memory consumption, but this is an acceptable price.  Secondly, there are no problems with the conclusion.  All processes are simply written in one queue, but how to deduce, in what format, etc., is no longer their concern.  It is necessary to arrange the output in a frame - we rewrite one function, but not all that can output something.  Again, there are no problems with simultaneous / overlapping output (when one thread prints 12345 and the other qwerty, but the user gets something like 1qw234er5ty).  Finally, thanks to this approach, it is very easy to divide the tasks into smaller ones and scatter them into threads / cores of the microprocessor.  And all this means faster development and lower support costs.  Everyone is happy, everyone is happy. <br><br>  In order not to depart from the practice of flashing LEDs, we will make the following demonstration: we will create a queue from which an element will be picked up once a second (imitation calculation).  At the press of a button, an item will be placed in the queue twice a second (control commands).  Well, the LED will show the queue load.  Again, I warn you that the code to improve readability is written without error handling, so be careful. <br><br>  Somewhere in the beginning of the code define the queue <br><br><pre> <code class="cpp hljs">xQueueHandle q;</code> </pre><br><br>  The ignition code of the LEDs will change according to the principle ‚Äúthere are more N elements in the queue?  we light, if not, then no <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(uxQueueMessagesWaiting(q)&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) HAL_GPIO_WritePin(GPIOE,GPIO_PIN_9,GPIO_PIN_SET); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> AL_GPIO_WritePin(GPIOE,GPIO_PIN_9,GPIO_PIN_RESET); osDelay(<span class="hljs-number"><span class="hljs-number">100</span></span>);</code> </pre><br><br>  Before launching the scheduler, we initialize the queue so that it can ‚Äústand‚Äù 8 elements the size of a byte. <br><br><pre> <code class="cpp hljs">q = xQueueCreate( <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ) );</code> </pre><br><br>  Well, the button code for placing characters in the queue <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_0)==GPIO_PIN_SET) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> toSend; xQueueSend( q, ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * ) &amp;toSend, portMAX_DELAY ); } osDelay(<span class="hljs-number"><span class="hljs-number">500</span></span>);</code> </pre><br><br>  What is missing?  Worker, who picks up the job from the queue.  We write. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WorkThread</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> rec; xQueueReceive( q, &amp;( rec ), portMAX_DELAY ); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } }</code> </pre><br><br>  As you can see, all the parameters are similar to those used in semaphores, so I will not repeat.  And as usual, the result is easier to show. <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Fi-NzYOHjZk%3Ffeature%3Doembed&amp;xid=17259,15700002,15700019,15700186,15700190,15700253&amp;usg=ALkJrhjtVOWpnDwNfJbOHHJO21n3m_LOyA" frameborder="0" allowfullscreen=""></iframe><br><br>  The code with all the offal is available at <a href="">kaloshin.ru/stm32/freertos/stage3.rar</a> <br><br>  <a href="http://habrahabr.ru/post/249395/">Next part</a> </div><p>Source: <a href="https://habr.com/ru/post/249381/">https://habr.com/ru/post/249381/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249371/index.html">Making the game 2048 on AngularJS</a></li>
<li><a href="../249373/index.html">How to untangle noodles without falling into depression</a></li>
<li><a href="../249375/index.html">We decipher the formula of the Habr-rating or the restoration of functional dependencies according to the empirical data</a></li>
<li><a href="../249377/index.html">An open letter to Jon von Tachner</a></li>
<li><a href="../249379/index.html">Published official Node.JS driver for Oracle database</a></li>
<li><a href="../249383/index.html">How to make QML friends with someone else's OpenGL context. Part III: Processing User Input</a></li>
<li><a href="../249389/index.html">Music as big data. Why, instead of sound quality, you need to think about convenience</a></li>
<li><a href="../249391/index.html">Mod USB-COM adapter, which will save your nerves when flashing the Arduino Pro Mini and not only</a></li>
<li><a href="../249393/index.html">React Native Announcement</a></li>
<li><a href="../249395/index.html">STM32 and FreeRTOS. 4. Step toward HAL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>