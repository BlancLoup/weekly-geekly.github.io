<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to prove the importance of tests for each project participant</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine you have fully implemented a new feature in two days. The code is written, it works and everything is cool. Your manager says that you can imm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to prove the importance of tests for each project participant</h1><div class="post__text post__text-html js-mediator-article">  Imagine you have fully implemented a new feature in two days.  The code is written, it works and everything is cool.  Your manager says that you can immediately release.  "But what about the tests?" Exclaim some meticulous colleague.  "Why?" - You will answer in one voice with the manager.  Why do we need to write tests?  How to explain their need to others?  Why involve testers, analysts and other participants?  In this post I will tell you how to explain the benefits of tests to any project participant, and also why it is worth automating tests.  And we will support all this with serious research. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/957/f8a/b84/957f8ab84be306d36d8360e072ed247d.png"><br><a name="habracut"></a><br>  Do you need automation?  Let's start the argument from the reverse. <br><br><h2>  Why don't I need to write tests? </h2><br><h3>  1. It is expensive </h3><br>  The programmer is one of the most expensive project participants, and his work greatly influences the budget.  And in general, writing tests is not a lordly affair.  You can simply hire students for a penny to give them both writing these tests and testing programs.  Let them poke into displays, press keys - everything will be fine. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/ce4/dc4/2b4/ce4dc42b435be7a96760f00081de8098.png"><br><br><h3>  2. It is tedious </h3><br>  Autotest development is a very tedious job.  It can be entrusted to anyone.  I spent 5 years learning to program in the university, and another two years in graduate school.  I want to design a cool architecture, apply cool patterns and launch rockets to Mars.  And tests are not a task of my level. <br><br><h3>  3. It is useless </h3><br>  Why bother writing tests if my code works?  Each line of it went through my inner genius.  How can it even create problems in the application?  This is ruled out, I see through every single baytik. <br><br><h3>  4. This is ‚Äúnot my problem‚Äù </h3><br>  Today I wrote a feature on one team, tomorrow I‚Äôll go to another team to make a new feature.  What will be further here will be dealt with without me, even if there is any mistake. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f84/8d0/6ac/f848d06ac8be708a75d7ce970e31623d.png"><br><br><h2>  Why is this whole list wrong? </h2><br>  Now go through all the points and disprove each.  At the same time we will cite some more interesting facts from studies of well-known companies like Microsoft ( <a href="https://ieeexplore.ieee.org/document/5362086/">On the Effectiveness of Unit Test Automation at Microsoft</a> by Laurie Williams, Gunnar Kudrjavets, Nachiappan Nagappan), and also a less well-known company from South America. <br><br><h3>  1. On a project scale, it is inexpensive. </h3><br>  Referring to Steve McConnell's ‚ÄúPerfect Code‚Äù.  If we estimate how the labor costs change over time, then we can see that gradually the proportion of testing performed by developers decreases from 25% to 8-10%.  More resources are starting to steal other activities. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/7e4/0e7/2f97e40e7e3936d4fb86e8238e4024fb.png"><br><br>  There is another study where Microsoft studied about 30 internal teams of various sizes - 28-35 developers and 14-20 testers each. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8a6/3bf/e5f/8a63bfe5fbd91e1bb09224e17cf5b6ae.png"><br><br>  This study shows roughly the same numbers.  With the introduction of automated testing practices, development time increased by an average of 26%.  But development is not the whole project activity, there is also design, integration, implementation, and so on.  Therefore, a quarter growth in just one of many processes is a small loss to the budget, especially in light of the fall in manual testing costs. <br><br><h3>  2. This is much more fun than production problems. </h3><br>  Perhaps writing tests is somewhat boring - the test code is trivial and rarely carries interesting tasks.  But your client definitely does not need an eternal fire, which you will put out, finding defects during implementation or beta testing. <br><br><h3>  3. It is useful for everyone. </h3><br>  The less you believe in the reference of your code, the better it will be in the end both for the team and for the product.  And first of all to you - learn from your mistakes and without unpleasant consequences. <br><br><h3>  4. This will be your problem. </h3><br>  If you write the code, and then abandon its support, then after a month or two, you can easily fly past the release.  As part of the overall testing of the product, a lot of defects will be found - in the end, your feature and several other features of your colleagues will not reach production. <br><br><h2>  Testing in terms of team roles </h2><br>  Go on the offensive.  Let's look at the tests through the eyes of all participants in the development process: the client, the product owner, the tester and the developer. <br><br><h3>  Customer </h3><br>  What happens when they do not write tests?  For example, you lose a satellite that is insured for 2.6 billion rubles. <br><br><img src="https://habrastorage.org/webt/gy/sc/pk/gyscpkj1s7mehds5a-7bfxq5bxo.png"><br><br>  On November 28, Roskosmos launched the satellite Meteor-M No. 2-1 using the Soyuz-2.1b rocket.  He did not fly - slightly deviated from the course and fell into the ocean.  Software developers, who were responsible for adjusting the route, forgot to specify the actual data.  It was planned that the satellite would be launched into orbit from the Baikonur cosmodrome, and the launch took place several tens of thousands of kilometers from it - from the Vostochny cosmodrome.  One small test to verify the input data - and 2.6 billion rubles would have been saved. <br><br>  On the Internet, you can find many stories about how one small error in software can lead to billions of dollars in expenses.  Most are connected with medicine and space, there are many examples in the banking industry.  For example, in 2012, the same update was rolled into all the servers of one large Western bank.  After that, the servers with the old code began to generate additional reports, because the necessary locks disappeared on the pre-emptive front.  As a result, wasted generated reports for 440 million dollars. <br><br>  On the other hand, what happens if the product code is completely closed by tests?  With him you can safely do what no one did to you.  And this is very cool. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f3/a6d/3b5/8f3a6d3b5813d4a63a674c20cd3ab895.png"><br><br><h3>  Product Owner </h3><br>  An important characteristic of a product with a future is the possibility of its expansion and long-term support.  In English, this is called the beautiful word <b>Maintainability</b> . <br><br>  This means that a product that has been developing for several years (or even several decades) constantly provides some minimum level of quality, and the number of defects in it does not exceed a certain maximum.  We should not do worse than user experience.  We should not significantly degrade the quality of our features.  This can be guaranteed through tests, manual and automated. <br><br>  In another study, Microsoft, you can peep another interesting figure.  As part of a team of 32 developers, the number of defects that reached the user decreased by <b>20.9%</b> - after the second version of the product, development teams began to apply test automation and write unit tests.  At the same time, the second version acquired additional features, increased in code volume by about 20%, and another 20% was rewritten.  Yes, and testers themselves began to notice that the quality of their software has become higher - it has become more interesting to work. <br><br>  IBM also conducted similar studies and eventually found out that the <b>cost of removing the bug detected after the release is 4-5 times</b> higher than when detected during design or implementation.  Self-tests, if they are run regularly, help in time to signal that there are any problems.  They help cut these extra cost in the budget.  As a result, the cost of software support will be lower - and the quality of user experience will increase. <br><br><h3>  Tester </h3><br>  Here the question is a little different: why do we need test automation?  Microsoft research comes to the rescue again.  According to him, after automating testing, testers have become much harder to find bugs.  But with the same time costs, they now find much more complex bugs that were more likely to leak into production.  At the same time, there are much less trivial errors, since they are removed even before testers. <br><br>  Here is a bug report for one internal Microsoft project: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebe/fe1/76e/ebefe176ed2996200a97a9982ee6ec6c.png"><br><br>  The first version is before the introduction of automatic testing, the second is after.  Errors are divided into four categories.  The higher the category, the more difficult the errors.  In total, in the second version, the number of bugs decreased by 21%.  The number of bugs from simple categories (3 and 4) decreased significantly.  The share of more complex bugs remained the same or slightly increased due to the fact that the total number of bugs decreased. <br><br>  Now testers can write more complex test cases that are as close as possible to the user experience.  The programmer will most likely eliminate the simplest errors himself if he systematically supplements his code with some kind of test code. <br><br>  Why do testers get fewer bugs?  There is a pyramid known to many that divides various types of testing into layers.  This pyramid says that the most primitive unit tests that affect only a small part of the software should be the most in the project.  A complex end-to-end or manual tests should be the minimum number, but at the same time they should look for the most complex bugs - these are the so-called flashing, floating or gray tests.  If this pyramid is turned over, a so-called testing funnel appears, into which various bugs are poured. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/958/c8d/ac2/958c8dac294e2fa693e39c8cb9dcd262.png"><br>  <i>Source: <a href="https://twitter.com/noahsussman">https://twitter.com/noahsussman</a></i> <br><br>  At each level of this funnel, the bugs are filtered out.  The more complex and interesting the bug, the lower it falls in this funnel.  A large number of unit tests eliminates most of the bugs before the manual testing phase.  Therefore, the time of the manual testing itself is reduced, and only bugs related to some specific functionality can penetrate to the user.  90-95% will never face them in their lives. <br><br><h3>  Developer </h3><br>  For the developer, I singled out as many as five advantages that tests give him: <br><br><ul><li>  Understanding the requirements <br></li></ul><br>  When writing a test, the developer begins to better understand the requirements through communication with non-technical experts.  Suppose you need to implement some input field.  When you write tests to your code, you start asking questions: what if I substitute an empty value here?  What if I enter 150 characters instead of the 10 allowed?  Clarifying these points, you make your code more stable and eliminate the most simple errors. <br><br><ul><li>  Stability when refactoring <br></li></ul><br>  Tests allow us to guarantee the stability of our application when refactoring, especially when bold refactoring.  Suppose you have some old module - a huge Legacy code, which many are afraid to touch, because it is not clear what is happening there.  If this thing is closed with tests, they will qualitatively verify that the main cases work for us.  It will not be so scary to go in and refactor it all under the hood, change it to some new implementations.  We will simply confirm that the changes that appeared in our application did not break anything. <br><br><ul><li>  Formation of documentation <br></li></ul><br>  Tests serve as excellent documentation for your code.  It is much easier to understand someone else's code when there is some consumer of this code.  And tests are the very first consumer.  Do not go to Jira, do not study lengthy comments in Confluence - you can simply open a test class, a set of some test methods for your code, and understand what this code does just by reading the names of test methods and understanding what data is being transmitted there. <br><br><ul><li>  API enhancement <br></li></ul><br>  If we use iterative practice of writing tests, such as TDD, or we plan in advance how we will cover some specific entity in our program with tests, this will make its interface better.  We begin to think over what data we will push into this entity, what data it will return to us.  This will allow you to immediately write a high-quality interface instead of constantly adding new contexts and parameters. <br><br><ul><li>  Error reduction <br></li></ul><br>  It is clear that tests reduce the number of errors in the code.  Less mistakes - more free time.  Here is what the developers themselves say about writing tests (in this case modular) in a Microsoft study: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/698/c32/000/698c3200027923d176c540fb63ced945.png"><br><br><h2>  Let's sum up </h2><br>  Writing tests should be supported by the management.  If you decide that you are going to write tests, while the others do not write, the initiative will most likely stall in a couple of months.  Management must support writing tests and understand why they appear at all in a project. <br><br>  Of course, development takes longer with tests - an average of 26%.  Depending on the complexity of the programming language, the features and experience of the programmer, this proportion can be reduced to 8% or jump to 40-50% of the time.  If time to market is as critical as possible for you - put off writing tests, release MVP and return to tests later. <br><br>  In my opinion, not only developers, but also testers should write tests within the team.  All team members should have access to the code, and all of them should be able to influence code changes.  Testers can offer more exceptional situations and a variety of edge-cases than average developers.  Accordingly, test quality and coverage will improve. <br><br>  I hope all the above arguments will help you explain within the teams, and at the same time to yourself, why we need tests, why we should write them every day and how they make the code better. </div><p>Source: <a href="https://habr.com/ru/post/354096/">https://habr.com/ru/post/354096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354082/index.html">We introduce a system of achievements on the Toaster</a></li>
<li><a href="../354084/index.html">Data Requirements - Should a business analyst care?</a></li>
<li><a href="../354086/index.html">Hall Effect Sensors for a Brushless Motor: Returning Quadrature Encoders</a></li>
<li><a href="../354090/index.html">Overview of the new line of home antivirus Panda Dome</a></li>
<li><a href="../354092/index.html">Another article about the recognition of workers without helmets neural networks</a></li>
<li><a href="../354098/index.html">How data sharing affects the quality of recommendations</a></li>
<li><a href="../354104/index.html">React HoC in TypeScript. Typing without pain</a></li>
<li><a href="../354106/index.html">How to get rid of the difficulty in managing a state in React - report on the results of a trip to React Amsterdam</a></li>
<li><a href="../354108/index.html">How to create a neural network with just 30 lines of JavaScript code</a></li>
<li><a href="../354110/index.html">Urgent Relocation from Amazon Web Services - Two Customer Stories</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>