<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multicellular processor is what?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have heard about multicellular architecture, processors and even the first devices on them. Especially advanced users tried their algorithms. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multicellular processor is what?</h1><div class="post__text post__text-html js-mediator-article">  Many have heard about multicellular architecture, processors and even the first devices on them.  Especially advanced users tried their algorithms.  The first simple performance tests were conducted, as well as the user <a href="http://habrahabr.ru/users/barsmonster/" class="user_link">Barsmonster</a> , etched the P1 processor chip.  The first R1 processor is already undergoing tests and will soon be available to everyone.  But the answer to the question of how multicellular architecture works and what is its difference, not everyone knows.  Let us now try to bring up to date. <br><a name="habracut"></a><br>  <b>1. Multicellularity</b> <br>  <b>A multicellular nucleus</b> is a group of identical processor units (2 or more) united by a fully connected unidirectional switching medium.  The interaction features of the processor units between themselves follow from the presentation of the algorithm (see below).  The processor unit in a multicellular architecture is called a cell.  The set of commands that it can perform is determined by the specific implementation and does not depend on the architecture. <br><br>  <b>Algorithms "eyes" multicellular nucleus</b> <b><br></b>  <b>First of all.</b> <br>  Any formula can be presented in the form of a parallel-layered form (JFM).  Will consider <br>  A simple example: g = e * (a + b) + (ac) * f, in YPF it might look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/60c/ac2/ed1/60cac2ed1e80d0ed5ad72413fab8ea9c.jpg"></div><br>  Figure 1. Example of JFM 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In general, to perform operations, nodes located on the i-th tier can use the results obtained on tiers from 1 to (i-1) -th.  From this it follows that teams that are on one tier are independent. <br>  Any algorithm is a set of formulas, which is divided into subsets - linear sections connected by control transfer operators.  The linear section (LU) is understood as such a subset of formulas that is calculated if and only when control is transferred to the given linear section.  Inside the linear region, informationally unrelated formulas can be executed in any order. <br><br>  As you know, the result of the execution by the processor of any command is expressed in the change of the processor state.  The use of this new state by subsequent teams forms an information link between the result source team and the receiving teams of this result.  Such a relationship can be both indirect (indirect) and direct (direct). <br><br>  In the case of indirect communication, the result is available only after its alienation: recordings in public registers or memory or other devices.  The source command must place the result in these devices, and the receiving command will have to take data from there.  The device name is specified as an operand.  Such a connection between the teams is the basis of absolutely all modern processors, except multicellular ones. <br><br>  In the case of a direct informational link, the commands are named and the names must identify the command itself, not its location or other implementation features.  Access to the results can be done by the names of both source commands and receiving commands.  In the first case, a broadcast is used, followed by a list-by-name selection, in which the name of the source command is set in the operand field of the receiving command.  In the second, a list-by-name distribution is performed, in which the name of the command-receiver of the result is specified in the source command. <br><br>  Theoretically, we can name nodes of the JFM in any way.  The only requirement is unambiguity.  To do this, in a multicellular processor, when fetching from memory, a tag (tag) is obtained - thus they and their results are given a local name - and then the interaction between the teams is organized through tags.  Data can be obtained from any team with a tag less than its own.  The tag number of the desired result is determined by the difference in the values ‚Äã‚Äãof the command tag and the tag of the desired result.  For example, if the operand contains @ 5, and the command tag is 7, then the result of the command with tag 2 is used as the operand. All command execution results are sent to the switching environment, from which the required ones are selected by the tag.  Thus, in a multicellular processor, a broadcast of the results is used with their subsequent selection by name. <br><br>  <i>It is worth noting that, due to physical limitations, there is the concept of ‚Äúvisibility window‚Äù, which determines the maximum distance of the source command from the receiver's command.</i>  <i>The tag in the process of selecting commands changes cyclically.</i>  <i>Its maximum value is determined by the size of the command buffer.</i>  <i>In fact, the size of the tag determines the number of teams that can simultaneously be at different stages of execution.</i>  <i>Tag value cannot be used if the command to which it was previously assigned has not yet been executed.</i> <br><br>  <b>Secondly.</b> <br>  A multicellular processor operates with structures that we call paragraphs. <br>  <b>A paragraph</b> is an informationally closed sequence of commands.  A paragraph is an analogue of a command, after the execution of which, the state of the processor and / or systems within it (registers, buses, memory cells, input / output channels, etc.) changes.  Those.  for a multicellular nucleus, a paragraph is a command. <br>  <b>The main feature of the multicellular architecture</b> is that it directly implements the YPF representation of the algorithm.  From this understanding of the algorithm, many properties of the multicellular architecture follow. <br><br>  <b>2. Properties of multicellular architecture</b> <br><ul><li>  independence from the count of cells; </li><li>  dynamic distribution of computing resources; </li><li>  all commands ready for execution are executed simultaneously; </li><li>  energy consumption reduction.  Works when there is work; </li><li>  scalability, no limit on the number of cells. </li></ul><br><br>  Let us consider in more detail how the paragraph will look for the algorithm described in Section 2. <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f79/3fb/39f/f793fb39fbac03cd676da9fe4fbf879c.png"></div><br><br>  For a multicellular nucleus, the following scheme for constructing a paragraph is characteristic (it is not mandatory, in the given example there are also digressions): <br><ul><li>  data acquisition for work (commands with tag 0-2,4,6 in the example); </li><li>  data processing (commands with a tag 3,5,7-9 in the example); </li><li>  saving the results (command with tag 10 in the example). </li></ul><br>  It should be recalled that the change in the state of the machine in the multicellular processor occurs at the end of the paragraph. <br><br>  <b>The algorithm does not depend on the number of cells.</b> <br>  Informational links between teams are clearly indicated and there is no need to know about the number of processor units when a program is written.  The teams just wait for the readiness of their operands and after that they leave for execution and it doesn‚Äôt matter who and when they prepare the operands.  Imagine a watering can - you do not think about how many holes in its nozzle when watering.  The cells are identical and there is no difference in which cell this or that team will be executed. <br>  Commands are distributed into cells in the order they are followed, 1 team is in 0 cell, 2 team is in 1 cell, etc., when the team is transferred to the last available cell, we begin to redistribute it from 0 cell.  Consider the work of the 4-cell nucleus.  The paragraph above will be executed as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf1/e1d/1ad/bf1e1d1ad694ca6586e10c4f418e63b1.jpg"></div><br>  Figure 2. The distribution of teams in cells <br><br>  <i>The number of simultaneously executed commands depends on the number of cells.</i>  <i>Choosing the optimal number of cells for each task is a task that requires analysis.</i>  <i>It‚Äôs still impossible to create a universal system, so you can rely on the following data: 4 cells do a good job on common tasks, and 16 cells on signal processing tasks, and for video processing, their number can be on the order of hundreds.</i> <i><br></i>  <i>You can analyze your code and imagine what would be the optimal number of cells for them.</i>  <i>To do this, you need to submit your algorithm to YPF and count the number of teams in tiers.</i>  <i>The average number of teams in them will hint at the optimal number of cells in your particular case.</i> <br><br>  <b>All commands ready for execution are executed simultaneously.</b> <br>  <i>As mentioned above, the multicellular nucleus implements the YPF representation of the algorithm, independent commands are located on the tiers.</i>  Everything that can be done at the moment - will be done without any special instructions from the programmer, the main condition - the team must receive all the data for execution. <br><br>  It is necessary to take into account technological limitations: the number of cells is limited, therefore, there will be as many commands simultaneously as there are cells in the core. <br><br>  <b>"Similarity collapse" or dynamic distribution of computing resources</b> <br>  Since  the code does not depend on the number of cells with which it will be executed, the ability of the multicellular nucleus to distribute its computational resources during operation appears, and the control is programmed. <br>  The ability of the multicellular architecture to redistribute its resources we call <b>reconfiguration</b> .  For example, cells of the multicellular nucleus can be arbitrarily distributed to execute any algorithm or part of it.  A group (better names have not yet been invented) is a part of the cells of the multicellular nucleus, which are interconnected to carry out an algorithm or part of an algorithm.  A group may contain 1 or more cells.  When the multicellular nucleus divides a group into parts, this is called <b>decomposition</b> .  The process of grouping is <b>composition</b> .  Figure 3 below shows how the 4-cell nucleus is reconfigured over time (example).  Cells that perform the same task have the same color fill. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/930/af0/af2930af084b67525620d2531c41f0e5.jpg"></div><br>  Figure 3. Cell Reconfiguration Example <br><br>  <b>Reduced power consumption.</b>  <b>Works when there is work.</b> <br>  The principal basis of the multicellular architecture is broadcasting.  To date, this is still the only architecture that uses direct informational communication to transfer data between teams in the program. <br><br>  If you pay attention to Figure 1, which shows an example of how to execute a code with a 4-cell processor, you can see that the cells execute commands located on tiers when they are ready to be executed.  The result is placed in the switching environment and is waiting for its consumer. <br><br>  The multicellular nucleus does not commit unnecessary actions, it works when there is work.  If any of the components of the processor is not ready to execute the command, then work with it is suspended until the release. <br><br>  <b>Scalability, no restrictions on the number of cells.</b> <br>  The architecture does not limit the number of cells.  The case is behind the technology. <br>  There are several options for organizing a large number of cells, but this is a topic for a separate article, which we will prepare later. <br><br>  <b>3. Implementation</b> <br>  <b>Multicellular processor "in the flesh"</b> <br>  A multicellular processor consists of N identical cells with numbers from 0 to n-1, connected by a switching medium.  Each cell contains a program memory block (PM), a control unit (CU), a buffer device (BUF), and also each cell has a switching device (SU), which together form a switching medium (SB).  The processor also contains data memory (DM), a block of general-purpose registers (GPR) and an executive device (EU) consisting of an arithmetic logic unit for floating-point numbers (ALU_FLOAT), ALU for integer numbers (ALU_INTEGER) and a memory access block data (DMS). <br><br>  The program for multicellular assembler consists of paragraphs.  For example: <br><br><pre><code class="java hljs">Paragraph: ;  jmp paragraph_next ;     complete</code> </pre> <br><br>  In fact, the transition team to the next paragraph can stand anywhere in the current paragraph, but so far we do not focus on this.  In this example, a paragraph is all commands from the ‚ÄúParagragh‚Äù label to the end of the command section - ‚Äúcomplete‚Äù. <br><br>  In a paragraph, commands can be arranged in an arbitrary order, commands can refer to the result of previous commands using the ‚Äú@‚Äù operator, but note that you cannot refer to the result of a command that is 64 commands higher than the current one.  Those.  The window of visibility of the result for each command is 64, while the size of the paragraph is not limited, i.e.  it may consist of at least several thousand teams.  Consider an example: <br><br><pre> <code class="java hljs">Paragraph: getl <span class="hljs-number"><span class="hljs-number">2</span></span> ;    getl <span class="hljs-number"><span class="hljs-number">3</span></span> ;    addl @<span class="hljs-number"><span class="hljs-number">1</span></span>, @<span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> addl @<span class="hljs-number"><span class="hljs-number">1</span></span>, @<span class="hljs-number"><span class="hljs-number">3</span></span> ; <span class="hljs-number"><span class="hljs-number">5</span></span> +<span class="hljs-number"><span class="hljs-number">2</span></span> jmp paragraph2 complete</code> </pre><br>  In this example, the addl @ 1, @ 2 command performs the addition of the two previous commands, and the addl @ 1, @ 3 command performs the addition of the result of the previous command and the result of the command that is 3 lines higher. <br><br>  The state of the processor changes when moving from one paragraph to another.  Write to memory, registers occur at the end of the paragraph in case the read write control is enabled or direct read and write commands are not used.  But it is possible to disable read and write controls, i.e.  writing to memory will take place in the paragraph itself, without waiting for its completion (in cases where it is possible to disable read and write control, working with memory can bring a noticeable increase in performance).  In fact, it is easy to get the most out of the multicellular processor, but this is a topic for a separate article. <br><br>  For the execution of a context-sensitive program, the commands of each paragraph sequentially, starting with the same address, which is the address of this paragraph, are placed in the PM cells.  The location address of the first executable paragraph is equal to the address from which the cells select the commands.  As a result, in the PM of the i ‚Äì th cell, starting from the address of a paragraph, its commands with the numbers i, N + i, 2 * N + i, ..., are sequentially placed. <br><br>  Each cell provides, starting from the address given to it, a sequential selection of commands and placing them on the command register for subsequent decoding.  Commands cells are selected synchronously. <br><br>  When decoding, each next selected group of N commands is assigned the next tag value (t), and the number from the group and, accordingly, its result is assigned a number.  Sampling and decoding of commands continues until a command is selected that is marked with the control attribute ‚Äúend of paragraph‚Äù (Complete).  The address of a new paragraph can be received either at any moment of the selection of commands of the current paragraph, or after the completion of the selection of commands.  It enters all cells simultaneously.  If the address of the next paragraph is not calculated by the time the last paragraph command is selected, the sample is suspended until the address is received.  If the address is received, the sample continues from this address.  The selected command enters the buffer device, which consists of a buffer of the first operand, a buffer of the second operand, and a buffer of commands (operation codes, tags, etc.). The buffer devices form commands and transfer them to the corresponding execution unit. <br><br>  The operating part (command buffer), in addition to the command code, includes all the necessary service information for sending and receiving results, namely, the command number and signs of readiness of the first (second) operand to execute the command. <br><br>  The storage buffer operands is associative addressing.  Associative <br>  the address is the tag of the requested result.  As operands when performing operations can be used: <br><ul><li>  the requested results of source commands from the switch; </li><li>  values ‚Äã‚Äãcalculated during decoding of the control word, as well as those directly present in the control word or taken from general registers. </li></ul><br>  In the first case, the readiness flag of this operand is set to ‚Äúnot ready‚Äù when writing a command, and in the second, to the ‚Äúready‚Äù state.  After receiving the requested result from the switching device, the sign, in the first case, is also set to the ‚Äúready‚Äù state.  The command that received all the operands passes priority selection among other ready-made commands in the buffer device, after which it is issued for execution under the condition that the executive device is empty. <br><br>  In the P1 processor, each cell was allocated its own section of memory, i.e.  program memory and data memory do not overlap.  In processor R1, the program memory and data memory are in the same address space, i.e.  cells have channels of access to program memory and data memory.  Figure 4 shows the general structure of the processor P1.  Figure 5 shows the structure of the cell and its description for the processor R1. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/680/e0d/85e/680e0d85eb310ebd1c88ac37d2d2c68e.gif"></div><br>  Fig 4. General structure of the multicellular processor <br><br>  Arithmetic logic units (ALUs), along with the DMS unit, are part of the set of actuators available in each cell (CELL). <br><br>  The cell consists of the following devices: <br>  1. Device selection commands IDU (Instruction Distribution Unit). <br>  2. Control device. <br>  3. Switching device SU (Switch Unit). <br>  4. Buffer device. <br>  5. Integer ALU. <br>  6. ALU with a floating point. <br>  7. Block of access to the data memory DMS (Data Memory Service). <br>  8. Multiplexer results. <br>  9. A set of registers GPR (General-Purpose Registers). <br>  10. Interrupt Controller IC (Interrupt Controller). <br>  11. JTAG-GPR debugging unit. <br><br>  The detailed structure of the cell is shown in Figure 5: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/deb/160/b4edeb1608428540e57d5171f255a3ba.png"></div><br>  Figure 5. Cell structure. <br><br>  The result of the execution of commands the actuators transmit to the switching device. <br>  If the results of executing the instructions of the integer ALU, floating-point ALU and DMS are ready at the same time, the switching device receives the result of executing the floating-point ALU command.  According to the priority of reading the result, the actuators are distributed as follows: <br><br>  1. ALU with a floating point; <br>  2.DMS; <br>  3. Integer ALU. <br><br>  Executive devices, the result of which the current clock can not be issued in the switching device, write the result of the command in the output register and wait for their turn to issue the result. <br>  The situation described above has the effect that the number of ticks needed to execute a command is non-deterministic. <br>  In each cell, there are two ALUs: an integer ALU and an ALU floating point processing. <br>  Integer ALU is designed to execute instructions on integer operands, and operands can be presented in the following formats (depending on the instruction): <br><ul><li>  64-bit; </li><li>  32-bit; </li><li>  16-bit; </li><li>  8-bit; </li><li>  packed 32-bit; </li><li>  packed 16-bit. </li></ul><br><br>  The floating-point ALU is designed to execute instructions on operands represented in the format of floating-point single (32 bits) or double precision (64 bits) in accordance with the requirements of IEEE-754. <br>  Structurally, the floating-point ALU consists of three parts: <br><ul><li>  Single precision divider (division, square root) </li><li>  Double precision divider </li><li>  Calculator (execution of other commands) </li></ul><br><br>  <b>What is the difference between multicellular processors and multicore processors?</b> <br>  In conventional processors consisting of one or several cores, the elementary unit of execution is the command that is executed in a certain order.  In a multicellular processor, an elementary unit of execution is a paragraph, i.e.  a linear section consisting of an unlimited number of commands, after which a transition to another linear section with a given label occurs.  Commands from this section will be executed in parallel where possible.  Parallelization occurs hardware, i.e.  the programmer does not need to take care of which cell the command will fall into.  This is what we call ‚Äúnatural parallelism‚Äù.  As a result, the same code can be executed on any number of cells.  Another difference in the multicellular processor is the transmission of the results of the work of the teams via broadcasting, whereas in multi-core and single-core systems the results are transmitted through memory and registers.  Of course, in multicellular processors there is a memory and registers for transferring data between linear sections, but inside the linear section basic operations can be carried out without the use of registers and memory.  This fact gives the multicellular architecture simplicity of implementation and reduction of memory accesses, as a result, reduction of energy consumption.  In addition, the execution of the same program on one, two, ..., two hundred and fifty-six cells provides opportunities for reconfiguring (combining cells into task groups) of cells, creating a fault-tolerant processor, and scalability. <br><br>  We will return to the issues of parallelism and reconfiguration later in this article. <br><br>  <b>4. Examples</b> <br>  A multicellular processor consists of 4 cells (maybe 256 or more), the cells are completely equal and are connected by a switching environment (switch).  The result of the execution of commands cells are stored in the switch. <br>  The program in assembler is divided into sections and paragraphs that contain commands. <br>  For the exchange of information between cells serves as a switch, and for the exchange between paragraphs, there are RONs, index registers, data memory.  There are peripheral registers for working with peripherals. <br>  To weed out statements like: <br><ul><li>  Even if this is a ‚Äúpage‚Äù of memory, but who ‚Äústeers‚Äù all of memory?  Where is the senior (top) control unit that controls the cells?  Who loads cell memory? </li><li>  Parallel programmer, not processor </li></ul><br>  Consider a simple program: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/21e/ca6/77d21eca655dc20b049c0d8a0693f635.gif"></div><br>  Figure 2. The distribution of teams in cells <br><br>  As shown in Figure 2, the commands from the paragraph will be divided into cells.  Commands in each cells are executed in parallel (‚Äúnatural parallelism‚Äù).  Execution of commands occurs upon readiness of arguments.  In this case, the program is executed by a group of 4 cells.  The program will be successfully executed both on 4, and on any other number of cells.  The basic principle of the multicellular architecture is that the cells are independent from each other and from anyone and the same.  This principle applies to processors with reconfiguration. <br><br>  <u>Reconfiguration</u> is the ability of the processor cells to composition (collection) and decomposition (analysis) into groups, i.e.  the ability of cells to unite in groups from one cell to N (for the N cell processor) and execute their own part of the code.  By default, when starting any program, all cells are in the same group.  It should be noted that each group has its own set of RONS, index, control registers, you can assign your own interrupt handler. <br>  In the <a href="http://www.osp.ru/os/2008/06/5340894/">article about the von Neumann architecture,</a> Leonid Chernyak identifies the following three types of reconfigurable processors: <br>  1) specialized processors <br>  2) configurable processors <br>  3) dynamically reconfigurable processors (as an example, the only class of this type that exists at the time of publication of L. Chernyak's article - FPGA) is given. <br>  The first two types acquire their own specifics in the manufacturing process, and the third can be programmed. <br><br>  The multicellular processor R1, according to this classification, is dynamically reconfigurable, but it is a processor on a chip and, due to the independence of the machine code, the redistribution of resources (cells), unlike FPGA, occurs without stopping or rebooting the processor and without losing information.  Thus, MultiClet R1 is a new class of the third type (along with the first one - FPGA). <br>  Nobody has ever made such processors in the world today. <br>  The classification proposed by L. Chernyak, adjusted for future development, can be developed by the fourth type, which we formulate as <br>  4) <b>self-adapting processors</b> , <br>  able to independently ensure the operation of all systems, automatically redistributing resources.  In case of damage, failures or when additional tasks appear, the processor or system from the processors must be able to adapt to the new conditions. <br>  The first step to the creation of such systems may be the processor Multiclet L1 or SVK based on it. <br><br>  Consider an example of decomposition (division into groups) of cells: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db5/ea1/e68/db5ea1e68cdc568ff007cceed3df03a5.gif"></div><br><br>  In this example, we see a division into 3 groups: cells with numbers 0 and 1 perform calculations, cell 2 collects information from sensors, and cell 3 compiles reports on work and interacts with the external environment.  If it happened that cells 0 and 1 do not have time to process the data, then cell 3 can come to their aid and two groups will turn out.  It is important to note that a processor reset is not required to reconfigure cells.  Cell 3 will speak the same language with cells 0 and 1, i.e.  will acquire their set of RONS, index registers and control registers. <br>  A simple example of an ordinary assembler program (you can write in standard C): <br><br><pre> <code class="java hljs">.text habr: getl <span class="hljs-number"><span class="hljs-number">4</span></span> ;    getl <span class="hljs-number"><span class="hljs-number">5</span></span> ;     addl @<span class="hljs-number"><span class="hljs-number">1</span></span>, @<span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">5</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span> mull @<span class="hljs-number"><span class="hljs-number">3</span></span>, @<span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-number"><span class="hljs-number">4</span></span> * <span class="hljs-number"><span class="hljs-number">5</span></span> = <span class="hljs-number"><span class="hljs-number">20</span></span> subl @<span class="hljs-number"><span class="hljs-number">1</span></span>, @<span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-number"><span class="hljs-number">20</span></span> ‚Äì <span class="hljs-number"><span class="hljs-number">9</span></span> = <span class="hljs-number"><span class="hljs-number">11</span></span> slrl @<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-number"><span class="hljs-number">11</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> = <span class="hljs-number"><span class="hljs-number">44</span></span> subl @<span class="hljs-number"><span class="hljs-number">1</span></span>, @<span class="hljs-number"><span class="hljs-number">2</span></span> ; <span class="hljs-number"><span class="hljs-number">44</span></span> ‚Äì <span class="hljs-number"><span class="hljs-number">11</span></span> = <span class="hljs-number"><span class="hljs-number">33</span></span> mull @<span class="hljs-number"><span class="hljs-number">4</span></span>, @<span class="hljs-number"><span class="hljs-number">5</span></span> ; <span class="hljs-number"><span class="hljs-number">20</span></span> * <span class="hljs-number"><span class="hljs-number">9</span></span> = <span class="hljs-number"><span class="hljs-number">180</span></span> jmp habrahabr ;    complete habrahabr: getl <span class="hljs-number"><span class="hljs-number">5</span></span> ;    addl @<span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">10</span></span>] ;        <span class="hljs-number"><span class="hljs-number">10</span></span> setl #<span class="hljs-number"><span class="hljs-number">32</span></span>, @<span class="hljs-number"><span class="hljs-number">1</span></span> ;     <span class="hljs-number"><span class="hljs-number">32</span></span> complete</code> </pre><br><br>  Paragraphs are in the section marked up as ‚Äú.text‚Äù.  A paragraph can contain an unlimited number of commands (as long as the program memory allows), but each command can refer to a result only for a command that is not more than 63 lines higher. <br><br>  For convenience, the assembler can set a label for each command, for example: <br><br><pre> <code class="java hljs">habr: arg1 := getl <span class="hljs-number"><span class="hljs-number">5</span></span> ;    sum1 := addl <span class="hljs-meta"><span class="hljs-meta">@arg</span></span>1, [<span class="hljs-number"><span class="hljs-number">10</span></span>] ;        <span class="hljs-number"><span class="hljs-number">10</span></span> setl #<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-meta"><span class="hljs-meta">@sum</span></span>1 ;     <span class="hljs-number"><span class="hljs-number">32</span></span> complete</code> </pre><br>  In a multicellular processor, there is no hardware to detect information links between the selected operations (commands) and their distribution among functional devices, i.e.  dynamic paralleling is missing.  There is no static parallelization, since  The program, although it describes informational links, has a linear form and does not contain any indication of what can be done in parallel and how.  This is a fundamental difference from other processors.  Due to this feature, the survivability of the multicellular processor is potentially ensured, i.e.  the possibility of continuous execution of the program without recompiling or reloading if its individual cells fail (processor degradation). <br><br>  Due to the property of the multicellular processor, we can dynamically allocate our resources, we can create systems capable of performing the task even if part of the cells fail. <br><br>  Degradation is associated with loss of productivity and, consequently, an increase in the time to solve problems.  But, for a number of embedded applications, the survivability of a multicellular processor allows a controlled object to perform basic functions, either by reducing their quality or by abandoning the solution of secondary tasks. <br>  Asynchronous and decentralized organization of a multicellular processor, both at the system level - between cells (when implementing parallelism) and at the intracellular level - between cell blocks (when implementing commands), additionally provides: <br><br><ul><li>  minimization of the nomenclature of design objects and their reduction <br>  difficulties; </li><li>  reduction of the processor chip area (the amount of equipment at <br>  decentralized control is less than with centralized); </li><li>  increased productivity and reduced energy consumption due to <br>  implement a more efficient computational process; </li><li>  use of an individual synchronization system for each cell <br>  when implemented on a single crystal tens and hundreds of cells. </li></ul><br><br>  As a result, a well-structured and modular system is obtained, which makes it possible to drastically reduce the complexity of the processor and, consequently, reduce costs and improve the quality of design.  In this case, compared with the von Neumann model, the quantitative characteristics of the processor are also improved. <br><br>  At the moment, tests of simple algorithms, such as POCNT and encryption algorithms, have been conducted.  For the popcnt test, an assembler program was written and we compared the result with a simple program for the Pentium Dual Core 5700 C. <br>  The test results can be summarized in the following table (the number of clock cycles per 32-bit calculation cycle): <br><br><img src="//habrastorage.org/files/66c/839/e7e/66c839e7eb024e3ca71197b52b4244e1.png"><br><br>  Those.  we can conclude that the Multiklet R1 processor on the ‚Äútable‚Äù test is 15% faster than the Intel processor, and on the BitHacks test, the Multiklet R1 processor is faster than Intel by more than 2 times.  The popcnt test for a multicellular processor was simply converted for parallel computing.  Of course, in the new Intel processors there is a popcnt hardware implementation, but in this test we showed the capabilities of our processors. <br><br>  <b>5.What we have now</b> <br>  A Multiclet P1 processor is currently released and is available for ordering, as well as two debug boards. <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/b07/6fb/d69/b076fbd6918f4035b908b107eb0f8253.png"></div><br><br>  In addition, the first multicellular processor developed a device for protecting information Multiclet Key_P1, the first production batch is scheduled for September 2014. <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/8da/ec8/f24/8daec8f24dcc427aaeb2017e8fe7530d.png"></div><br><br>  In addition, based on the P1 processor, a foil stamping printer from Virshke LLC was developed and supplied as standard. <br><br><div style="text-align:center;"><img src="//habrastorage.org/files/edc/3ae/439/edc3ae4397114e98b91e32f209952870.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Users actively master multicellular processors and complement libraries, as well as create new useful examples. </font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/600/5ab/607/6005ab607eb14a46be88aa9913ad1451.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first batch of R1 processors has been received, testing of new processors has begun. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first revision of the processor is called R1-1. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, the new processor is a topic for a separate article, the characteristics of the first revision processor will be published a little later.</font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/909/075/e5d/909075e5db4d4cf1bcb6319f2fbaa826.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this processor, LDM-Systems has released a debug board, consisting of a base one and a processor one. </font><font style="vertical-align: inherit;">In the photo version with a block. </font><font style="vertical-align: inherit;">Custom version will be slightly different. </font><font style="vertical-align: inherit;">It will be possible to choose the configuration of the baseboard for your tasks, in the maximum configuration the base + processor board will have an acceptable cost.</font></font><br><br><div style="text-align:center;"><img src="//habrastorage.org/files/e88/dec/866/e88dec8666b142d0975ec0555f40256f.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The software bundle includes: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Assembler </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ C compiler </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Functional model </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Libraries </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Debugger for IDE Geany </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ FreeRTOS OS </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Program examples </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Plotter </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS If you liked this article despite the large volume, then I can write a continuation of processor programming, an overview of the R1 processor and principles of building high-performance systems on multicellular processors. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program for checking the operation time of the popcnt algorithm is taken from </font></font><a href="http://www.strchr.com/crc32_popcnt"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.strchr.com/crc32_popcnt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As already noted in the article, for Intel processors, there are other faster algorithms for implementing the popcnt test, which require certain commands implemented at the hardware level. </font><font style="vertical-align: inherit;">To evaluate the capabilities of the multicellular architecture, Table and Bit hacks algorithms were taken. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Figure 2 was updated. The add @ 3, @ 2 command should be stretched to two lines, and the mpy @ 4, @ 3 command was reduced in duration, since </font><font style="vertical-align: inherit;">the arguments for it were ready earlier, which reduced the total duration of the paragraph. </font><font style="vertical-align: inherit;">Also the mpy command is replaced with mul. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD3:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Each cell contains a buffer of 64 commands. </font><font style="vertical-align: inherit;">The selection of paragraph commands by cells continues in parallel with execution, the selection of the next paragraph can be started, only if the address of the transition to it is known.</font></font></div><p>Source: <a href="https://habr.com/ru/post/226773/">https://habr.com/ru/post/226773/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226755/index.html">Hybrid Cloud FAQ: Good old virtualization in a new financial wrapper</a></li>
<li><a href="../226759/index.html">How to use Routing in Ext JS 5</a></li>
<li><a href="../226763/index.html">Zero Downtime Upgrade for an application in Microsoft Azure. Part 2: IaaS</a></li>
<li><a href="../226765/index.html">Interview. Where to find an investor for your Internet project?</a></li>
<li><a href="../226769/index.html">How to find an idea for a startup in robotics?</a></li>
<li><a href="../226775/index.html">Key parameters and certification of optical SFP modules</a></li>
<li><a href="../226777/index.html">The first development experience for Windows Phone: In-App Purchasing</a></li>
<li><a href="../226779/index.html">Quaternion Encryption Scheme (QES) on FPGA, XeonPhi, GPU</a></li>
<li><a href="../226783/index.html">The Ministry of Industry and Trade orders the development of a domestic processor</a></li>
<li><a href="../226787/index.html">Grid Tiling: Mixing Multiple Tiles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>