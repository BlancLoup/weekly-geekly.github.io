<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Admin tales: chasing the fragmentation of tunnels in the overlay network</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lyrical introduction 
 When administrators encounter an unexpected problem (it used to work, and, suddenly, after the update, it stopped), they have t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Admin tales: chasing the fragmentation of tunnels in the overlay network</h1><div class="post__text post__text-html js-mediator-article"><h1>  Lyrical introduction </h1><br>  When administrators encounter an unexpected problem (it used to work, and, suddenly, after the update, it stopped), they have two possible behavior algorithms: fight or flight.  That is, either understand the problem to the bitter end, or run away from the problem without delving into its essence.  In the context of software updates - roll back. <br><br>  Rolling back after an unsuccessful upgrade is, one might say, a sad best practice.  There are whole guides how to prepare for a rollback, how to carry them out, and what to do if you failed to roll back.  The whole industry of cowardly behavior. <br><br>  An alternative way - to understand to the last.  This is a very difficult path, in which no one promises success, the amount of effort spent will be incomparable with the result, and the output will be only a little more understanding of what happened. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Plot drama </h1><br>  Cloud "Instant Servers" Webzilla.  Routine update of nova-compute host.  New live image (we use PXE-loading), the spent chef.  All is well.  Suddenly, a complaint from a client: ‚Äúone of the virtual loops works strange, it seems to work, but as the real load begins, everything stops.‚Äù  Client instances are transferred to another node, client problem is solved.  Our problem begins.  Run the instance on this node.  Picture: Cirros ssh login is successful, on Ubuntu it hangs.  ssh -v shows that everything stops at the ‚Äúdebug1: SSH2_MSG_KEXINIT sent‚Äù stage. <br><br>  All possible external debugging methods work - the metadata is obtained, the DHCP lease is updated by the instance.  There is a suspicion that the instance does not receive the DHCP option from the MTU.  Tcpdump indicates that the option is being sent, but it is not known whether the instance accepts it. <br><br>  We really want to go to the instance, but on the Cirros, where we can go, the MTU is correct, and on Ubuntu, for which there is a suspicion about the problem of MTU, we just can not get.  But really want. <br><br>  If this is a problem with MTU, then we have a sudden assistant.  This is IPv6.  With the fact that we don‚Äôt select white IPv6 (sorry, it‚Äôs not yet production-ready in openstack), link-local IPv6 is working. <br><a name="habracut"></a><br>  Open two consoles.  One to the network node.  We penetrate the network namespace: <br><br><pre> sudo stdbuf -o0 -e0 ip net exec qrouter-271cf1ec-7f94-4d0a-b4cd-048ab80b53dc / bin / bash
</pre><br>  (stdbuf allows you to disable buffering from ip net, so the output to the screen appears in real time, and not with a delay, ip net exec executes the code in the specified network namespace, bash gives us a shell). <br><br>  On the second console, open the compute-node, cling to tcpdump to tap our ubuntu tap: <code>tcpdump -ni tap87fd85b5-65</code> . <br><br>  From inside the namespace, we make a request for an all-nodes link-local multicast (this article is not about ipv6, but briefly what is happening: each node has an automatically generated ipv6 address starting with FE80 ::, besides, each node listens on multicast addresses and responds to requests for them. Depending on the role of the node, the multicast list is different, but each node, at least, responds to all-nodes, that is, to the address FF02 :: 1).  So, do a multicast ping: <br><br><pre> ping6 -I qr-bda2b276-72 ff02 :: 1
 PING ff02 :: 1 (ff02 :: 1) from fe80 :: f816: 3eff: fe0a: c6a8 qr-bda2b276-72: 56 data bytes
 64 bytes from fe80 :: f816: 3eff: fe0a: c6a8: icmp_seq = 1 ttl = 64 time = 0.040 ms
 64 bytes from fe80 :: f816: 3eff: fe10: 35e7: icmp_seq = 1 ttl = 64 time = 0.923 ms (DUP!)
 64 bytes from fe80 :: f816: 3eff: fe4a: 8bca: icmp_seq = 1 ttl = 64 time = 1.23 ms (DUP!)
 64 bytes from fe80 :: 54e3: 5eff: fe87: 8637: icmp_seq = 1 ttl = 64 time = 1.29 ms (DUP!)
 64 bytes from fe80 :: f816: 3eff: feec: 3eb: icmp_seq = 1 ttl = 255 time = 1.43 ms (DUP!)
 64 bytes from fe80 :: f816: 3eff: fe42: 8927: icmp_seq = 1 ttl = 64 time = 1.90 ms (DUP!)
 64 bytes from fe80 :: f816: 3eff: fe62: e6b9: icmp_seq = 1 ttl = 64 time = 2.01 ms (DUP!)
 64 bytes from fe80 :: f816: 3eff: fe4d: 53af: icmp_seq = 1 ttl = 64 time = 3.66 ms (DUP!)
</pre><br>  The question arises - who is who?  Take turns trying to go uncomfortable and long. <br><br>  Next to us in the next window is tcpdump, listening to the interface of the instance we are interested in.  And we see in it the answer only from one IP - the IP we are interested in.  This turns out to be fe80 :: f816: 3eff: feec: 3eb. <br><br>  Now we want to connect via ssh to this node.  But anyone who has tried the <code>ssh fe80::f816:3eff:feec:3eb</code> is in for a surprise - "Invalid argument". <br><br>  The reason is that link-local addresses cannot be used ‚Äújust like that,‚Äù they only make sense within a link (interface).  But ssh does not have the option ‚Äúuse such outgoing IP / interface such and such‚Äù!  Fortunately, there is an option to specify the interface name in the IP address. <br><br>  We do <code>ssh fe80::f816:3eff:feec:3eb% qr-bda2b276-72</code> - and find <code>ssh fe80::f816:3eff:feec:3eb% qr-bda2b276-72</code> .  Yes, yes, I understand your indignation and bewilderment (if you do not have it, you are not a real geek, or you have many years of working with IPv6).  ‚ÄúFe80 :: f816: 3eff: feec: 3eb% qr-bda2b276-72‚Äù is such an ‚ÄúIP address‚Äù.  I do not have enough language to convey the degree of sarcasm in these quotes.  IP address with percent and interface name.  I wonder what will happen if someone uploads his avatar something like http: // [fe80 :: f816: 3eff: feec: 3eb% eth1] /secret.file from a server in a web server on a site ... <br><br>  ... And we find ourselves on the virtual.  Why?  Because IPv6 is better than IPv4 is able to handle bad MTU situations, thanks to the obligatory <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">PMTUD</a> .  So, we on a virtualka. <br><br>  I expect to see the wrong MTU value, go to cloud-init logs and figure out why.  But here is a surprise - MTU is correct.  Oops. <br><br><h1>  In the wilds of debugging </h1><br>  Suddenly, the problem of the local and understandable becomes completely incomprehensible.  The MTU is correct, and the packets are dropped. ... But if you think carefully, then from the very beginning the problem was not so simple - the instance migration should not have changed the MTU. <br><br>  A painful debugging begins.  Armed with tcpdump, ping and two instances (plus the network namespace on the network node), we understand: <br><br><ul><li>  Locally, two instances on the same compute each other ping with a maximum size ping. </li><li>  The instance from the network node does not ping (here and below - with a ping of the maximum size) </li><li>  Network node instances on other computers pings. </li><li>  Close attention to the tcpdump inside the instance shows that when the network node pings the instance, it sees and responds with the ping. </li></ul><br>  Oops.  A large package comes, but is lost on the way back.  I would say asymmetric routing, but what the hell is the routing when they are in the neighboring ports of the switch? <br><br>  Close attention to the answer: the answer is visible on the instance.  The answer is visible on tap'e.  But the answer is not visible in the network namespace.  And how are things going with mtu and packages between a network node and a computer?  (internally, I already triumph, they say, I found the problem).  Rraz - and (big) pings go. <br><br>  What  (and a long bewildered pause). <br><br>  What next to do is not clear.  Returning to the original problem.  MTU is bad.  And which MTU is good?  Begin to experiment.  Bisection: minus 14 bytes from the previous value.  Minus fourteen bytes.  Why on earth?  After software upgrade?  I do vimdiff on the list of packages, I find a pleasant perspective to deal with about 80 updated packages, including the kernel, ovs, libc, and a lot of libs.  So, two ways of retreat: lower the MTU by 14 bytes, or roll back and tremble over any update. <br><br>  Let me remind you that the problem was reported by the client, not by monitoring.  Since MTU is a client setting, the ‚Äúfailure of large packets with the DF flag‚Äù is not really an infrastructure issue.  That is not a problem of infrastructure at all.  That is, if it is caused not by an upgrade, but by an upcoming solar eclipse and yesterday's rain, then we will not even know about the return of the problem until someone complains.  Tremble over the update and fear the unknown about what you do not know in advance?  Thank you, the prospect I have dreamed of all my professional life.  And even if we lower the MTU, then why fourteen bytes?  And if tomorrow will be twenty?  Or oil will be cheaper up to 45?  How to live with it? <br><br>  However, we check.  Indeed, the MTU is slightly lower in the DHCP options, and the instance that rebooted works fine.  But this is not an option.  WHY? <br><br>  We start everything from the beginning.  We return the old MTU, trace the tcpdump packet again: the answer is visible on the instance interface, on the tap'e ... We look at the tcpdump on the node's network interface.  A bunch of small annoying flood, but with the help of grep we see that requests come (inside GRE), but the answers do not go back. <br><br>  Aha! <br><br>  At least it can be seen that it is lost somewhere in the process.  But where?  I decide to compare behavior with live node.  But the trouble is, on the "live" node tcpdump shows us the packets.  Thousands of them.  In millisecond.  Welcome to the tengigabitethernet era.  Grep allows you to catch something from this flood, but you will not be able to get a normal dump, and the performance of such a design raises questions. <br><br>  Focusing on the problem: I do not know how to filter traffic using tcpdump.  I know how to filter by source, dest, port, proto, etc., but I don‚Äôt know how to filter a packet by IP address inside GRE.  Moreover, it is pretty bad for Google. <br><br>  Until a certain point, I ignored this question, believing that repairing is more important, but the lack of knowledge began to bite very painfully.  A colleague ( <a href="https://habrahabr.ru/users/kevit/" class="user_link">kevit</a> , whom I drew to the question, dealt with him. Sent the link <code>tcpdump -i eth1 'proto gre and ( ip[58:4] = 0x0a050505 or ip[62:4] = 0x0a050505 )'</code> . <br><br>  Wow  Hardcore 0xhex in my web-binary cloud singularities.  Well.  You can live. <br><br>  Unfortunately, the rule did not work properly or did not work.  Having grabbed the idea, I caught the required offsets with the brute force method: 54 and 58 for the source and dest IP addresses.  Although <a href="https://habrahabr.ru/users/kevit/" class="user_link">kevit</a> showed where he took the bias - and it looked damn convincing.  IP header, GRE, IP header. <br><br>  An important achievement: I had a tool for precision viewing of single bags in a multi-gigabyte flood.  Looking at the packages ... Anyway, nothing is clear. <br><br>  Tcpdump is our friend, but wireshark is more convenient.  (I know about tshark, but it is also uncomfortable).  We make a package dump (tcpdump -w dump, now we can do it), take it to our car and start to figure it out.  I decided for myself to deal with the displacements (of general corrosiveness).  Open in wireshark and see ... <br><br><img src="https://habrastorage.org/files/6ea/a9e/d99/6eaa9ed99b8241b9bf03c6bbdaa680e3.png"><br><br>  We look at the size of the headers and make sure that the correct offset for the start of the IP packet is 42, not 46. Having written this error to someone's inattention, I decided to continue to sort it out the next day, and went home. <br><br>  Already somewhere very close to the house it dawned on me.  If the initial assumptions about the structure of the headers are incorrect, then this means that the overhead from GRE is different when tunneling. <br><br>  Ethernet header, vlan, IP header, GRE header, encapsulated IP packet ... <br><br>  Stop.  But the picture has a completely different title.  GRE neutrons are not encapsulated by IP packets, but by ethernet frames.  In other words, the initial assumptions about what part of the MTU eats off the GRE itself are wrong.  GRE ‚Äútakes‚Äù 14 bytes more than we expected. <br><br>  The neutron builds an overlay network over IP using GRE, and this is an L2 network.  Of course, there should be encapsulated ethernet headers. <br><br>  That is, the MTU should be 14 bytes less.  From the very beginning.  When we planned the network, the assumptions about lowering the MTU due to the GRE, we made a mistake.  Pretty serious, as it caused packet fragmentation. <br><br>  Ok, with an error is understandable.  But why after the update did it stop working?  According to previous surveys, it became clear that the problem is related to MTU, incorrect accounting for the GRE header and GRE fragmentation.  Why did fragmented packets stop running? <br><br>  Attentive and careful tcpdump showed the answer: GRE began to be sent with the DNF (do not fragment) flag.  The flag appeared only on GRE packets that encapsulated IP packets with the DNF flag inside, that is, the flag was copied to the GRE from its payload. <br><br>  For greater certainty, I looked at the old nodes - they fragmented the GRE.  There was a main packet, and a tail with 14 bytes of payload.  That's a blooper ... <br><br>  It remains to find out why it started after the upgrade. <br><br><h1>  Reading documentation </h1><br>  The most suspicious regression packages were Linux and Openvswitch.  Readme / changelog / news did not clarify anything special, but the inspection of git (and that's the answer, why we need open source code ‚Äî to have access to the Documentation) revealed something extremely curious: <br><br><pre> commit bf82d5560e38403b8b33a1a846b2fbf4ab891af8
 Author: Pravin B Shelar &lt;pshelar@nicira.com&gt;
 Date: Mon Oct 13 02:02:44 2014 -0700<font></font>
<font></font>
     datapath: compat: Fix compilation 3.11<font></font>
    <font></font>
     Kernel 3.11 is only kernel where GRE APIs are available but
     not vxlan.  Add check for vxlan xmit to detect this case.
</pre><br><br>  The patch itself does not represent anything of interest and does not concern the essence of the matter, but it gives a hint: the GRE API in the kernel.  And we had an upgrade from 3.8 to 3.13.  We google in bing ... We find a patch in the openvswitch (datapath module), in the kernel: <a href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/%3Fid%3Daa310701e787087dbfbccf1409982a96e16c57a6">git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=aa310701e787087dbfbccf1409982a96e16c57a6</a> .  In other words, as soon as our kernel starts providing GRE services, the openvswitch kernel module transfers gre processing to the ip_gre kernel module.  We study the ip_gre.c code, thanks for the comments in it, yes, we all "love" tsiska. <br><br>  Here is a treasured line: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> int ipgre_fill_info(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk_buff</span></span></span></span> *skb, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_device</span></span></span></span> *dev) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ip_tunnel</span></span></span></span> *t = netdev_priv(dev); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ip_tunnel_parm</span></span></span></span> *p = &amp;t-&gt;parms; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nla_put_u32(skb, IFLA_GRE_LINK, p-&gt;link) || .... nla_put_u8(skb, IFLA_GRE_PMTUDISC, !!(p-&gt;iph.frag_off &amp; htons(IP_DF))))</code> </pre><br><br>  In other words, the kernel copies IP_DF from the header of the encapsulated packet. <br><br>  (Sudden interesting offtopic: Linux copies TTL from the original package as well, that is, the GRE tunnel "inherits" TTL from the encapsulated package) <br><br><h1>  Dry squeeze </h1><br>  <s>The plane fell, because in the direction of the flight was the Earth.</s> <br><br>  During the initial setup of the installation, we set the MTU for the virtual machines as part of an erroneous assumption.  Due to the fragmentation mechanism, we got off with a slight performance degradation.  After upgrading the kernel from 3.8 to 3.13, OVS switched to the nuclear module ip_gre.c, which copies the do not fragment flag from the original IP packet.  Large packages that were not ‚Äútrapped‚Äù in MTU after the title was written to them were no longer fragmented, but dropped.  Due to the dropping of GRE, and not the packet embedded in it, none of the parties to the TCP session (sending packets) received ICMP notifications about "obstruction", that is, could not adapt to a smaller MTU.  IPv6, in its turn, did not count on the presence of fragmentation (it is not in IPv6) and handled the loss of large packets in the right way - reducing the size of the packet. <br><br><h1>  Who is to blame and what to do? </h1><br>  Blame we - mistakenly put MTU.  The barely noticeable behavior in the software caused the error to start disrupting IPv4. <br><br>  What to do?  We corrected the MTU in the settings of dnsmasq-neutron.conf (option <code>dhcp-option-force=26,</code> ), gave the clients to "settle" (update the address lease via DHCP, along with the option), the problem is completely eliminated. <br><br>  Can this be detected proactively by monitoring?  To tell you honestly, I don‚Äôt see any reasonable options - it‚Äôs too thin and complicated diagnostics that require extreme cooperation from client instances (we cannot rely on it - all of a sudden, someone, by his own needs, will register something strange using iptables?) . <br><br><h1>  Lyric conclusion </h1><br>  Instead of a cowardly roll back to the previous version of the software and take the position ‚Äúwork - do not touch‚Äù, ‚ÄúI don‚Äôt know what will change if we update, so we‚Äôll never be updated‚Äù, approximately 2 people were spent on debugging, but not only local (visible) regression was solved, but an error was found and fixed in the existing configuration, which increased the overhead of the network.  In addition to eliminating the problem, the understanding of the technologies used has also significantly improved, a technique for debugging network problems has been developed (filtering traffic in tcpdump by fields within GRE). <br><br><h1>  Comments - power </h1><br>  Suddenly, in the comments <a href="https://habrahabr.ru/users/ildarz/" class="user_link">ildarz</a> suggested a great idea how to find one like this - look at IP statistics and react to the growth of the number of fragments (/ proc / net / snmp, netstat -s).  I have not yet studied this issue, but it looks very promising. </div><p>Source: <a href="https://habr.com/ru/post/252881/">https://habr.com/ru/post/252881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../252865/index.html">Design Books</a></li>
<li><a href="../252869/index.html">Do I need a book on the protection of mobile applications?</a></li>
<li><a href="../252871/index.html">Calculate the circumference</a></li>
<li><a href="../252875/index.html">Hello from Microsoft: KB3002657 breaks ntlmssp on Windows 2003</a></li>
<li><a href="../252877/index.html">We read the correspondence of Ubank customers with support</a></li>
<li><a href="../252883/index.html">Creating APK x86 and ARM APK packages using the Intel¬Æ and GNU gcc compiler</a></li>
<li><a href="../252885/index.html">(Without) dangerous copy elision</a></li>
<li><a href="../252889/index.html">What is WMS?</a></li>
<li><a href="../252893/index.html">Timing for amateur car racing</a></li>
<li><a href="../252895/index.html">Material Design. Was there a boy?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>