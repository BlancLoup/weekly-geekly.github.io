<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I did a "<" monoid</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago, in one cozy chamber meeting, I gave a report on my development - a script lispodobnom language Liscript. He started with the basics - t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I did a "<" monoid</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/fdb/16f/80f/fdb16f80fe46487e9001ad785e9e04ab.jpg" alt="image" align="left">  Some time ago, in one cozy chamber meeting, I gave a report on my development - a script lispodobnom language Liscript.  He started with the basics - the semantics of calculating lists, prefix notation ... Reached arbitrary arity of standard operations: <br><br><pre><code class="hljs markdown"><span class="hljs-bullet"><span class="hljs-bullet">+ </span></span>1 2 3 =&gt; 6</code> </pre> <br>  Everything is intuitive, there are no questions.  I tell about boolean values, I give an example: <br><br><pre> <code class="hljs php">&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre><br>  everything is clear too.  And here is a question from the audience: ‚Äúand if I pass 3 arguments, how will it be calculated?‚Äù I decide that this is a good reason to show off with clever terms, and I answer: ‚Äúexactly the same way as a convolution according to a monoid‚Äù :) And then straightening out - ‚Äú although the comparison operation is not a monoid, ‚ÄùI am writing an example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs php">&lt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  It is still intuitively clear, there are no questions and we continue further (prudently leaving without consideration the calculation of primitive operations on one argument and generally in the absence of them, as well as subtraction / division and other non-monoidal operations :)).  Having successfully passed through such stones in the report, after a while I thought - is it possible to somehow contrive, and still make the comparison operation a monoid (in some sense)?  And I think I succeeded.  Interested in a subject I ask under kat. <br><a name="habracut"></a><br><h3>  Intro about monoids for the smallest </h3><br>  As everyone is well aware, a <b>monoid</b> is an associative binary operation on a given set that has a neutral element.  So, to define a monoid, we need to specify 3 things: <br><br><ul><li>  the set on which our operation is defined </li><li>  associative operation itself </li><li>  neutral element (from the above defined set) </li></ul><br>  Let us recall the terms ‚Äúneutral‚Äù and ‚Äúassociative‚Äù.  We denote our binary operation <i>mappend</i> , the neutral element of <i>mempty</i> (so that later it would be easier to read a haskel cat and not to stretch latex on markaun), then the neutrality of the element is defined as: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mappend</span></span> mempty x = x mappend x mempty = x</code> </pre><br>  what can be translated into fingers as: if one of the operands of our operation is a neutral element, then the result of the operation is the second operand, in other words, the neutral element does not change the result.  Associativity is defined as: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mappend</span></span> x (mappend yz) = mappend (mappend xy) z</code> </pre><br>  That is, when calculating a composition of two (and, as a result, an arbitrary number) operations, the result does not depend on the order of calculations, or, in other words, it does not matter how to put the brackets in a long expression (therefore, they can be omitted altogether). <br><br>  Generally speaking, a monoid is a fairly general concept of abstract algebra and category theory (for it is widely known that even those monads are monoids by definition), but in this article we will not dive deep into theoretical aspects.  Let's start with a couple of simple examples: the operation of addition on the set of whole (or natural / real / complex) numbers.  Associativity is present, as a neutral element we take 0 from the given set.  The multiplication operation is also a monoid, with a neutral element 1. Another example is the concatenation operation on a set of strings, with a neutral element in the form of an empty string.  Also, all the laws of a monoid are satisfied, although the concatenation operation is not commutative - but this is not required.  Implementing monoids of addition / multiplication in Haskell is trivial: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) where mempty = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> 0 mappend (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sum</span></span></span><span class="hljs-class"> $ x + y </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) where mempty = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> 1 mappend (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Product</span></span></span><span class="hljs-class"> $ x * y</span></span></code> </pre><br>  Here we actually defined specific implementations of <i>mempty</i> and <i>mappend</i> according to the rules described above.  The <i>monoid</i> type <i>class</i> automatically provides us with the convolution operation <i>mconcat of</i> any container (list, tree ‚Äî any that has a convolution operation) for any monoid: using the list as an example, we start with a neutral <i>mempty</i> element as a result of convolution and go sequentially through the list, updating the result through our monoidal binary operation <i>mappend</i> with the current list item.  Using the example of a numeric list, convolving it by a monoid <i>Sum</i> will give us the sum of the elements of the list, and <i>Product</i> - the product.  The constructions are calculated in exactly the same way: <br><br><pre> <code class="hljs php">+ <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">22</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">120</span></span></code> </pre><br>  In Lisp (leaving aside the question of calculation without arguments).  Check for haskell implementations: <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map <span class="hljs-type"><span class="hljs-type">Sum</span></span> [] <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map <span class="hljs-type"><span class="hljs-type">Sum</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>] <span class="hljs-type"><span class="hljs-type">Sum</span></span> <span class="hljs-number"><span class="hljs-number">55</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map <span class="hljs-type"><span class="hljs-type">Product</span></span> [] <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map <span class="hljs-type"><span class="hljs-type">Product</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>] <span class="hljs-type"><span class="hljs-type">Product</span></span> <span class="hljs-number"><span class="hljs-number">3628800</span></span></code> </pre><br>  As you can see, everything works. <br><br><h3>  Operation minimum </h3><br>  Now let's take an example more interesting - the binary operation of a minimum on a number set.  Is she a monoid?  The operation is associative, the set is given.  The only problem is the definition of a neutral element.  We need such an element in our set that would be no less than any other element.  If our set has an exact upper bound (for example, the type uint8 has a maximum value of 255), then we can take this value as a neutral element of our monoid.  But if we have the type of unlimited integers?  The solution is quite simple - we expand our type with one more special value (let's call it ‚Äúplus infinity‚Äù) and define the operation so that the laws are fulfilled. <br><br>  Implement it in code and check on empty and non-empty lists. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Min</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HighInf</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    (+ ) | Min a --   deriving (Eq, Ord, Show) instance Ord a =&gt; Monoid (Min a) where mempty = HighInf mappend HighInf v = v mappend v HighInf = v mappend (Min x) (Min y) = Min $ min xy *MyMonoid&gt; mconcat $ map Min [] HighInf *MyMonoid&gt; mconcat $ map Min [5..10] Min 5</span></span></span></span></code> </pre><br>  Everything is as expected - the minimum on the empty list gives plus infinity, on a non-empty one - the minimum element. <br><br><h3>  Comparison operation </h3><br>  We now turn to the final goal - we will try to implement a monoid for the comparison operation.  And immediately we have a problem - the comparison operation, unlike the previous operations considered, is not an operation defined on the set.  That is, the type of its result is boolean, and does not belong to the type of the set of its arguments on which it is defined.  This is a binary predicate, not an operation.  But, as always, we can solve this problem by introducing an additional level of abstraction (similar to what we did in the last example with a minimum): we need to construct such a type so that the generalized comparison operation is defined on the set of this type.  We also need a rule for transforming the values ‚Äã‚Äãof the original set into this type and the values ‚Äã‚Äãof this type into a Boolean type.  Thus, a generalized comparison as a monoidal operation will look like this: we translate the list of source values ‚Äã‚Äãinto a list of values ‚Äã‚Äãof our type, perform a convolution of this list by a monoidal operation, and then translate the result into a boolean value ‚Äî as required from the comparison operation. <br><br>  Let's think about what values ‚Äã‚Äãthis new type should provide.  We need the value of a neutral element, with the implementation of the relevant laws.  We need a value that characterizes a false result of any comparison ‚Äî if we have met this value in the chain of monoidal comparison operations when convolving, we drag it to the end, ignoring other comparisons.  And we need a value that characterizes the true result of the comparison.  It should contain the value of our original type - for subsequent comparisons.  But since subsequent comparisons can use it both on the left (from the conventional sign &lt;) and on the right, one value is not enough for us - we need extreme values ‚Äã‚Äãof the processed range (minimum and maximum for the whole chain of comparisons).  Thus, the value of our type will be a pair of 2 elements that defines the collapsed range.  We write the implementation of the monoid and all service functions: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Asc</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmptyAsc</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--    | RangeAsc aa --   ( ) | FailAsc --   deriving (Eq, Ord, Show) instance Ord a =&gt; Monoid (Asc a) where mempty = EmptyAsc mappend EmptyAsc v = v mappend v EmptyAsc = v mappend FailAsc v = FailAsc mappend v FailAsc = FailAsc mappend (RangeAsc ab) (RangeAsc cd) | b &lt; c = RangeAsc ad | otherwise = FailAsc valToAsc x = RangeAsc xx ascToBool FailAsc = False ascToBool _ = True</span></span></span></span></code> </pre><br>  and check the work: <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map valToAsc [] <span class="hljs-type"><span class="hljs-type">EmptyAsc</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map valToAsc [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>] <span class="hljs-type"><span class="hljs-type">RangeAsc</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; mconcat $ map valToAsc [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-type"><span class="hljs-type">FailAsc</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; isAscList [] <span class="hljs-type"><span class="hljs-type">True</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; isAscList [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>] <span class="hljs-type"><span class="hljs-type">True</span></span> *<span class="hljs-type"><span class="hljs-type">MyMonoid</span></span>&gt; isAscList $ [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre><br>  Everything works as it is required - our monoid checks the orderliness of the list in ascending order ‚Äî that is, exactly what the similar construction does in lispahs.  It is easy to write a few more similar monoids that check the list for a non-strict increase (on the non-strict comparison operation &lt;=), a decrease (strict and non-strict), and the equality of all the elements of the list.  To do this, it suffices to replace the corresponding binary predicate in the definition of the <i>mappend</i> function. <br><br><h3>  Long awaited conclusion </h3><br>  Now I am calm - I did not deceive the listeners during the report :) The comparison operation itself is not a monoid, but you can enter a level of abstraction, in which its generalized analogue will be one. <br><br>  If anyone is interested - a <a href="https://www.youtube.com/watch%3Fv%3DH1J5xVFDns0">video report (stream on YouTube)</a> Links to my githab repository with the implementation of interpreters can be found in my previous articles on Habr√©. </div><p>Source: <a href="https://habr.com/ru/post/328110/">https://habr.com/ru/post/328110/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328100/index.html">Security Week 18: A hole in all systems with Intel Core, Apple took away a certificate from a Trojan, ran the wizard flooded the planet</a></li>
<li><a href="../328102/index.html">Phase modulation of the radio signal in the FPGA</a></li>
<li><a href="../328104/index.html">A detailed commentary by Dan Abramov on the article ‚ÄúThings that no one will tell you about React‚Äù</a></li>
<li><a href="../328106/index.html">Analysis of the report of Roman Nevolin about F #</a></li>
<li><a href="../328108/index.html">How to work with events in Flussonic</a></li>
<li><a href="../328112/index.html">How to learn 100 English words per day</a></li>
<li><a href="../328114/index.html">PHDays HackQuest 2017: RanSomWare - a small cryptor on GO</a></li>
<li><a href="../328116/index.html">The story of creating a classic RTS at home from scratch (Part 2: "Resurrection"). Continuation of the article: GUI</a></li>
<li><a href="../328118/index.html">The story of creating a classic RTS at home from scratch (Part 2: "Resurrection") End of article: Network</a></li>
<li><a href="../328120/index.html">Hachim IntegerCache in Java 9</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>