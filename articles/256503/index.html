<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Write under that, I don‚Äôt know what: development features for Apple Watch using Mail.Ru Mail as an example</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! We recently updated the Mail.Ru Mail app for iOS . Now it supports Apple Watch. Today I want to tell you what we encountered when developing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Write under that, I don‚Äôt know what: development features for Apple Watch using Mail.Ru Mail as an example</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/e99/ac1/da0/e99ac1da0b8e48129c1b96c699abdc6d.jpg"></div><br><br>  Hi, Habr!  We recently updated the <a href="https://itunes.apple.com/ru/app/pocta-mail.ru/id511310430%3Fmt%3D8">Mail.Ru Mail app for iOS</a> .  Now it supports Apple Watch.  Today I want to tell you what we encountered when developing an application for the hours that had not yet been released at that time, and talk about how to cope with the minimalism of the SDK and the inability to test the application on a ‚Äúlive‚Äù device. <br><a name="habracut"></a><br><h1>  Features of the development interface for hours </h1><br>  Writing code for the clock is not much different from writing code for iOS - after all, all the logic is performed on the phone.  However, when it comes to the development of the user interface, everything becomes more complicated: there are new classes for watches that are used only in them.  At the moment there are only 11 of these classes - but here you can remember the first version of iOS, which also had few features.  We all know how their number has grown in subsequent versions, and we can hope that the SDK for watches has a similar fate.  In the meantime, the realities of developing UI for watches are as follows: <br><br><h4>  <u>Use only components for hours</u> </h4><br>  The very first disappointment that you encounter when developing an interface for a watch is that you have to forget about all the beautiful buttons, animations, screens that you have previously developed for your phone.  They can not be applied again, because the interface uses only visual components for watches. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <u>New model layout</u> </h4><br>  Relatively recently, Apple introduced a new layout for its phones.  Previously, it was possible to set specific coordinates of various elements and the rules by which elements were stretched when the screen was stretched.  But starting with iOS 6, a new model called Auto Layout has appeared, allowing you to set all these rules more flexibly. <br><br>  One would expect that Auto Layout could also be used on the clock - however, a third, completely new layout model appeared in the clock SDK.  It resembles the one used in the Android SDK (the entire interface consists of containers that are filled with elements vertically or horizontally). <br><br><h4>  <u>Rebuilding while hiding</u> </h4><br>  An interesting feature that was not in the iOS SDK: when you hide an element, it does not just disappear from the screen - all other elements take its place, and there is no empty space on the screen.  Thanks to this, it is possible to place several on one screen at once, with the possibility of dynamic switching between them. <br><br>  In general, in the clock SDK there are several possibilities for switching between screens: the screen animatedly pops up from the bottom or leaves the side animatedly (multi-page interface).  Switching emulation when hiding elements is an unofficial, undocumented, but rather interesting alternative, which allows you to change the screen without animation. <br><br><h4>  <u>Context instead of controller interface</u> </h4><br>  If in the iOS SDK we could initialize the ViewController ourselves and assign any properties to it, then the SDK for the clock creates the interface controller (WKInterfaceController) done by the system and cannot be accessed from the code.  Instead, the developers received a new parameter called context, which can be passed to the controller when it is displayed.  Inside the controller, it will be available in the awakeWithContext method.  Through context, you can pass the same parameters that we used to pass when creating: for example, the blocks that the child controller will have to call to pass information to the parent, the message ID to open, etc. <br><br><h4>  <u>Animation</u> </h4><br>  The clock greatly reduced the possibility of creating animations.  There are no CoreAnimation and UIKit frameworks with which animations can be created programmatically.  The only possibility to animate something on the clock is to create a sequence of pictures, something like an animated gif-ki. <br><br>  On the one hand, this method loses its flexibility, because we cannot dynamically set animation parameters in the code.  On the other hand, it may be more convenient for programmers, because designers fully develop animation and provide it in a ready-made form - as a sequence of pictures that can only be reproduced (in a circle, one-time or even not completely, that is, only some frame sequence). <br><br><img src="https://habrastorage.org/files/738/1e1/cbc/7381e1cbccfd4957ba9fe91957a2e6c4.gif"><br><br><h4>  <u>Glance</u> </h4><br>  Glance (aka ‚ÄúPreview‚Äù) is a small screen that any application can create to display some information on it.  For example, we show on it the number of unread letters and the name of the sender of the last unread letter.  Creating an interface for Glance is limited to a set of layouts.  Options in this set is enough, but still have to choose from the proposed. <br><br><h4>  <u>Recommended Font Styles</u> </h4><br>  A set of recommended styles has appeared in the interface editor when defining a text font.  Previously, it was possible to select the system font, its size and style (Italic, Bold, etc.).  Now there are templates, such as Body, Title, etc.  The use of styles is optional, but the opportunity itself, we hope, will contribute to the fact that developers will use it, and the interfaces will look more uniform. <br><br><h4>  <u>Overlay elements</u> </h4><br>  Unlike iOS, watches do not allow imposing elements on each other.  The only way to get around this limitation is to set the background of the group in the form of a picture and insert an element into the contents of the group.  In the Mail.Ru Mail application, this workaround is used to display the notification screen of a new letter (sender's avatar, on top of which text is displayed ‚Äî the subject of the letter and the sender; so that the text can be seen, a gradient is under it). <br><br><img src="https://habrastorage.org/files/e49/795/8db/e497958db547432d8a77b8f4216dd47e.png"><br><br><h4>  <u>Attributed String Support</u> </h4><br>  Of the nice things that we were surprised to find in the clock interface, it is worth mentioning the support of Attributed String in labels.  Because of this, we have the opportunity to draw text in which the individual fragments will be formatted in different ways.  As an example, we can cite the same Glance: we select a part of the text with a different color, and another part with a larger font. <br><br><img src="https://habrastorage.org/files/6e0/7b1/3b2/6e07b13b2f3d48989b42913d9dfc27fd.png"><br><br><h4>  <u>Force Touch and Digital Crown</u> </h4><br>  A new gesture called Force Touch appeared in the watch, that is, a ‚Äúhard press‚Äù.  The Apple Watch also inherited the Digital Crown wheel from the usual watches.  I combined these elements into one point, because both the Digital Crown and Force Touch are interface controls with which there is no complete clarity.  It seems that Apple is not sure how they will be used.  So, the Digital Crown is used somewhere to scroll the list, somewhere to scroll, and somewhere to move between Storyboard elements. <br><br>  If the behavior of Digital Crown is beyond the control of developers and it remains to be content with ‚Äúhanging up‚Äù on it at Apple, then with Force Touch we decided to wait and did not include its support in the first version of the Mail application. <br><br><h4>  <u>Image cache</u> </h4><br>  The mechanism of caching images on the clock is rather peculiar, but it is quite logical, if we recall what exactly is the application for the clock.  In short, it consists of several parts: the main ‚Äúhost‚Äù application, WatchKit Extension ‚Äî an extension for a watch that runs on the phone ‚Äî and a watch application that runs directly on the watch. <br><br>  When you add a picture to the clock screen, the following happens.  The main logic is launched on the phone, which forms a picture - for example, downloads it from the Internet.  The picture is given via Bluetooth or Wi-Fi on the clock.  Further features of the watch begin.  In normal caching, we simply upload the image, show it to the user and put it in the file until the next time.  With the clock, we can‚Äôt just put the image into a file on the phone, because then we‚Äôll have to transfer it to the watch every time.  In this case, the clock has its own cache of 20MB. <br><br>  It is interesting that you can put an image in the clock cache, but only the standard control can get it from there.  And, as far as we know, there are only indirect signs by which we can understand whether there is a picture in the cache.  For example, using API methods that let you know the size of the cached image.  This is done as follows: we ask what are the sizes of the file with the name of the supposedly cached image.  Depending on whether the dimensions return to us or not, we can conclude whether this image is in the cache, or it will be necessary to upload it first. <br><br><h4>  <u>No applicationDidFinishLaunching and applicationDidResignActive</u> </h4><br>  An iOS application has its own life cycle.  It starts, goes to the background, unloads from memory, and so on.  When these events occur, the application receives the appropriate alerts.  There are no alerts on the clock, which somewhat complicates the creation of objects at the stage of launching the application.  In addition, there may be problems with third-party libraries whose work is tied to these alerts.  For example, we are faced with the fact that the Flurry Statistics Library does not send events to the statistics to the server precisely because it does not receive notifications. <br><br>  The problem is due to the fact that, unlike an iOS application with a single entry point, where you can initialize everything once, there are three input options in the clock application: Glance, Notification and Main App.  However, in all three cases, the launch of the clock application is associated with the display of the first controller.  This allows us to use the awakeWithContext method. <br><br><pre><code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MRWKContactsInterfaceController</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeWithContext</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeWithContext:context]; [MRWKInitialization extensionDidFinishLaunching]; ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MRWKInitialization</span></span></span><span class="hljs-class"> + (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extensionDidFinishLaunching</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">dispatch_once_t</span></span> onceToken; <span class="hljs-built_in"><span class="hljs-built_in">dispatch_once</span></span>(&amp;onceToken, ^{ [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> internalExtensionDidFinishLaunching]; }); }</code> </pre> <br>  In addition, you can use the initialize method in one of the extension classes that will be executed when you first access this class. <br><br>  You can also use "lazy" initialization, when objects are created only when accessing them.  But keep in mind that in the case of statistics this does not help - for example, Flurry needs to know when exactly the application was launched. <br><br><h1>  Interaction with the main application </h1><br>  The capabilities of the application for hours are limited, and to perform actions that are not supported in it, we can call the main application.  Consider ways to do this. <br><br><h4>  <u>OpenParentApplication</u> </h4><br>  A new API has appeared - <code>+[WKInterfaceController openParentApplication:reply:]</code> , which allows you to call the main application from the clock application, which then starts in the background, performs the requested actions and returns the result. <br><br>  Example: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WKInterfaceController</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MRWKParentApplicationActions</span></span></span><span class="hljs-class">) + (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mrwk_markMessageIdAsRead</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">messageId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accountName</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accountName</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">completionBlock</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MRWKParentApplicationActionsCompletionBlock</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">completionBlock</span></span></span><span class="hljs-class"> </span></span>{ MRWKParentApplicationAction *action = [MRWKParentApplicationAction markAsReadActionWithMessageId:messageId accountName:accountName]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> openParentApplication:action.dictionary reply:^(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *replyInfo, <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (completionBlock) { MRWKParentApplicationReplyInfo *info = [[MRWKParentApplicationReplyInfo alloc] initWithDictionary:replyInfo]; completionBlock(info.success, error ?: info.error); } }]; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br><h4>  <u>Application groups</u> </h4><br>  The second way of interaction is Application Groups.  On iOS, all applications and extensions are executed in separate sandboxes - limited parts of the file system that only they themselves have access to.  To allow applications to use shared resources or share files, there are Application Groups.  If you assign a common Application Group to the application and the extension for the clock, a folder will appear in the file system, to which both will have access.  We use this feature, in particular, so that the Mail.Ru Mail application for watches has access to the database of the main application (all emails, contacts, etc.) and to the NSUserDefaults object (various user settings). <br><br><h4>  <u>Darwin Notifications</u> </h4><br>  Darwin notifications are a way to exchange messages between processes in iOS.  This possibility has existed for a long time, but it has become relevant with the advent of extensions - in particular, the extensions for watches.  With the help of Darwin notifications, you can send a notification to your watch if something changes in the main application - for example, if the contact list is open on the watch and a new contact is added in the main application.  Darwin notifications allow you to send an event from the main application so that the clock updates the list of contacts from the database. <br><br><img src="https://habrastorage.org/files/c4f/8a2/aa9/c4f8a2aa98d342c786281a6b1b197854.png"><br><br><h4>  <u>Handoff</u> </h4><br>  The latest version of iOS has the Handoff feature, which Apple is actively promoting.  Handoff can also be considered as a way to interact with the main application.  Here, the interaction will not be direct data exchange, for example, the creation of activations from the clock, so that when you open the main application, a certain screen is immediately loaded.  Suppose if a user opened Mail.Ru Mail and started writing a letter on the clock, and then launched the application on the iPhone - Handoff allows you to automatically automatically open the letter creation screen on the phone. <br><br><h1>  Development without device </h1><br>  The most important reef of development for Apple Watch is the impossibility to understand how what we write will work on a real device.  We see only a simulator, which is only some of its approximation.  Even in official documentation there are inconsistencies with reality. <br><br><h4>  <u>Receive multiple notifications</u> </h4><br>  Some aspects in the simulator are not reflected in principle.  For example, the following case is described in the documentation: when several notifications come, a round application icon and the text ‚ÄúN new notifications‚Äù appear on the screen.  However, the simulator does not allow to see how it will look.  It would seem a trifle, but in practice this may turn out to be unexpected: the name of the application will not be the same as we expect, the icon will be displayed incorrectly - and it is almost impossible to predict.  The only thing that can be done to minimize risks is to follow the documentation in absolutely everything. <br><br><h4>  <u>Emoji</u> </h4><br>  At the presentation, Apple said that the clock will have beautiful animated emoticons that can be customized.  Our application supports them - smiles can be added through the standard screen of writing a letter.  At the same time, it is not known how they will look in the letter, in what format they will come into the program and how they should be converted in order to be inserted into the letter.  There is an assumption that these will be ordinary emoji characters, but it is also possible that they will come in the form of animated gif-ki or something else not previously known.  The format is also not specified in the documentation.  We decided in the first version of the Mail application to proceed from the assumption that smiles will come in the form of text. <br><br><h4>  <u>Voice dialing</u> </h4><br>  Another ambiguity associated with writing a letter - the work of voice dialing.  In general, everything is clear: click on the microphone, we say, we get the entered text.  But even here nuances are possible - for example, not one line of text can be returned, but several variants of what the user dictated. <br><br><h4>  <u>Unauthorized user</u> </h4><br>  The following ambiguous case: suppose a person installed the Mail.Ru Mail application on the phone, but never launched it and, as a result, did not log in.  Will there be an application available on the clock in this case, will the user be able to start it from the Apple Watch display?  We will know the unequivocal answer only after the clock is released, and yet we decided to make sure in case the launch is possible: the message ‚ÄúOpen the application on the phone to log in‚Äù will be displayed to an unlocked user. <br><br><h4>  <u>Handoff</u> </h4><br>  It was announced that the Handoff will be maintained on the clock, and the documentation shows the same thing.  However, it is not yet possible to check how this works, since the simulator does not support Handoff.  And again we have to wait for the real device. <br><br><h4>  <u>Static / dynamic notification</u> </h4><br>  When push notifications arrive, the clock first tries to display a dynamic notification, that is, a more complex interface.  If the download is delayed, a simpler interface appears - static notification.  Unfortunately, using a simulator to see how this happens is impossible. <br><br><img src="https://habrastorage.org/files/a13/551/c54/a13551c543fb47f2a01fd45130c55008.png"><br><br><h4>  <u>Notifications: "division of labor" between the phone and the clock</u> </h4><br>  Some actions are connected with notifications: we can reply to the letter, delete it, mark it as read.  Some of these actions are handled by the clock extension, others by the main application.  We can not test on the simulator actions that are processed by the main application.  You can call these actions directly from the phone, but if we try to call them from the clock, the simulator will try to process them in the extension for the clock, while in real life they will be processed by the application.  This behavior is due to the fact that the simulator does not support push-notifications in principle - neither for the phone, nor for the clock.  However, in the clock SDK, it was possible, when launching the clock application from the development environment, to ‚Äúslip‚Äù the contents of the push notification and check how it will be processed.  The problem is that there is no way to test all possible cases.  For example, it is impossible to specify whether the notifications will be processed by the main application or by the extension for the clock.  I had to restrict myself to checking those actions that are processed by the application, through the call of actions from the notification on the phone (in a real device), and hope that on the clock it will work the same way. <br><br><h1>  Xcode Development </h1><br>  Everyone who works with Xcode knows that there are errors in it - and in every new version there are fresh instances.  The release of WatchKit SDK is no exception. <br><br><h4>  <u>Certificates for distribution</u> </h4><br>  Recently, Xcode headed for automatic code signing and provisioning.  In theory, Xcode creates for you all the profiles, the necessary certificates, Bundle ID.  In practice, she does this in some cases, but not in all.  In particular, we are faced with the fact that distribution-profiles for watches are not automatically created, they have to be created independently on the Apple portal for developers. <br><br><h4>  <u>Setting individual rounding radii for 38/42 mm</u> </h4><br>  In the interface builder, it became possible to set individual properties of elements for clocks of 38 and 42 mm in size, but in some cases this does not work.  For example, if you set your own rounding radius for a group for different versions of clocks, nothing is rounded at all.  We bypassed this bug by setting the rounding through the code, and not through the graphical interface editor. <br><br><h4>  <u>RemoteInterfacePrincipalClass</u> </h4><br>  In the plist of the clock application, new properties have appeared, in particular, the RemoteInterfacePrincipalClass property of an incomprehensible purpose.  On the one hand, it seems to be set, on the other hand, judging by experience, the value of this property does not affect anything.  We entered there the correct class name in case it actually ‚Äúpops up‚Äù on a real clock. <br><br><h4>  <u>SPErrorGizmoInstallNeverFinishedErrorMessage</u> </h4><br>  There are problems in the simulator.  Sometimes, if you start one application for a clock, work with it, stop, and then try to start another, the simulator refuses to install it and gives an error with a strange name from the subtitle.  It is treated only by removing the simulator, resetting the entire contents and a full clean project. <br><br><h1>  Code separation between application and extension </h1><br>  Finally a couple of words about process optimization.  The Mail.Ru Mail application and extension for watches perform similar functions: both allow you to see a list of contacts, send a letter, etc. Therefore, it makes sense to reuse part of the code from the main application in hours.  Below is a list of actions that allow to increase the share of the total code. <br><ul><li>  Initially, writing code is modular, so that individual classes can be used in extensions, without adding a bunch of dependencies with them that may not even be necessary for work, but are needed for compilation. </li><li>  Use CocoaPods - a dependency management system for Objective-C.  CocoaPods makes it possible to add specific libraries to specific targets.  Thanks to this, we can connect a large list of dependencies to the target application of Mail.Ru Mail, and only those libraries from this large list that are needed there can be connected to the target for the clock. </li><li>  Use Dynamic Frameworks if you‚Äôve already abandoned iOS 7 support. </li><li>  Use scripts to validate the project file.  If the code is not connected via CocoaPods, but manually, you need to ensure that only those files that are used there are included in the target.  In our case, all the differences are set in the configuration file, which should be between the main target and the target for the clock, and the scripts check all this. </li><li>  Call the main application through the API in cases where it is more efficient than using classes from the main application in hours. </li></ul><br><h1>  Conclusion </h1><br>  If we summarize our experience, we can say that we have identified for ourselves the following (rather obvious) basic rules of development without a device: <br><ul><li>  study the documentation thoroughly, since it will be almost impossible to catch the problem during testing; </li><li>  in addition to the main options, implement safety - in case the device does not work as you expected; </li><li>  Use all possible sources of information about the device - from official to geek podcasts. </li></ul><br>  I think, here, on Habr√©, there are quite a few people who have already faced the need to develop a device that, for one reason or another, cannot be held in their hands.  In the comments I propose to share experiences on how to make your life easier in such cases. </div><p>Source: <a href="https://habr.com/ru/post/256503/">https://habr.com/ru/post/256503/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256491/index.html">Cloud infrastructure: 7 interesting services and technologies (and their analogues)</a></li>
<li><a href="../256493/index.html">CAN-USB adapter from stm32vldiscovery</a></li>
<li><a href="../256495/index.html">Designing a Web API in 7 steps</a></li>
<li><a href="../256497/index.html">Monitoring-as-a-service for infrastructures on the example of the Anturis service</a></li>
<li><a href="../256501/index.html">Apple Watch: how to make an application under the clock and not screw it up</a></li>
<li><a href="../256505/index.html">Webix. The first acquaintance with the JavaScript framework</a></li>
<li><a href="../256509/index.html">Subject-event approach to modeling complex systems</a></li>
<li><a href="../256513/index.html">The challenge of a hundred boxes and the rescue of prisoners - the final chord</a></li>
<li><a href="../256515/index.html">Script to backup EC2-instance to AMI</a></li>
<li><a href="../256517/index.html">Separate interfaces for unit testing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>