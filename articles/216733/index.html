<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dynamic trees</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Before reading the article, I recommend to look at posts about splay-trees ( 1 ) and trees by an implicit key ( 2 , 3 , 4 ) 

 Dynamic trees (link / c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dynamic trees</h1><div class="post__text post__text-html js-mediator-article">  <i>Before reading the article, I recommend to look at posts about splay-trees ( <a href="http://habrahabr.ru/company/spbau/blog/210296/">1</a> ) and trees by an implicit key ( <a href="http://habrahabr.ru/post/101818">2</a> , <a href="http://habrahabr.ru/post/102006">3</a> , <a href="http://habrahabr.ru/post/102364">4</a> )</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc5/15c/2cc/bc515c2ccff0c451de00a7a446d863a3.png" align="left">  Dynamic trees (link / cut trees) are poorly lit on the Russian-language Internet.  I found only a brief description on algolist.  However, this data structure is very interesting.  It is located at the junction of two areas: flows and dynamic graphs. <br><br>  In the first case, dynamic trees allow us to construct efficient algorithms for the problem of finding the maximum flow.  Improved algorithms Dynitsa and pre-flow pushes work for <img src="https://habrastorage.org/getpro/habr/post_images/e8c/0e2/88d/e8c0e288d7f15babc7a91e9bed2a443c.gif">  and <img src="https://habrastorage.org/getpro/habr/post_images/74b/2e9/dc6/74b2e9dc6cafd86699752ce073242a71.gif">  respectively.  If you do not know what a stream is and you didn‚Äôt have such a thing at lectures, hurry up to replenish your knowledge in Cormen. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second case requires a little introduction.  Dynamic graphs are an actively developing modern area of ‚Äã‚Äãalgorithms.  Imagine that you have a graph.  Changes periodically occur in it: edges appear and disappear, their weights change.  Changes need to be quickly processed, and also to be able to efficiently count different metrics, check connectivity, look for diameter.  Dynamic trees are a tool that allows you to deftly manipulate with a particular case of graphs, trees. <br><br>  Before you dive under the cat, try to solve the following problem.  Given a weighted graph as a sequence of edges.  You can only go through the sequence once.  It is required to calculate the minimum spanning tree using <img src="https://habrastorage.org/getpro/habr/post_images/af1/17d/beb/af117dbeb11fc79d2dd596c0e8633a62.gif">  memory and <img src="https://habrastorage.org/getpro/habr/post_images/1a0/445/9d0/1a04459d0e4eda785ac9398ce61f213e.gif">  of time.  After reading the article, you will understand how you can easily solve this problem using dynamic trees. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  Dynamic trees have many different modifications, sharpened for specific tasks.  We will now study the basic version, and then we will finish it on demand. <br><br>  Imagine that we have a set of trees together <img src="https://habrastorage.org/getpro/habr/post_images/c7f/092/d48/c7f092d481acb49c8a0f96178ceb3119.gif">  vertices.  Each tree is suspended by root.  We receive the next set of requests. <ul><li>  <code>make_tree(v)</code> - create a new tree with vertex <code>v</code> </li><li>  <code>link(u, v)</code> - hang the tree with the root at the vertex <code>u</code> to the vertex <code>v</code> . </li><li>  <code>cut(u, v)</code> - cut the edge ( <code>u</code> , <code>v</code> ). </li><li>  <code>find_root(v)</code> - find the root of the tree, in which lies the vertex <code>v</code> . </li><li>  <code>depth(v)</code> - find the depth of the vertex <code>v</code> . </li></ul><br><br>  I want to handle all requests for close to <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  time. <br><br>  Note that if there were no <code>cut</code> and <code>depth</code> queries, the system of disjoint sets ( <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BD%25D0%25B5%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D1%2581%25D0%25B5%25D0%25BA%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D1%2585%25D1%2581%25D1%258F_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2">5</a> , <a href="http://habrahabr.ru/company/spbau/blog/208624/">6</a> , <a href="http://habrahabr.ru/post/104772/">7</a> ) could solve this problem. <br><br>  Dynamic trees use search trees within themselves.  An interesting feature is that with arbitrary balanced trees they process all the above-described requests for depreciation <img src="https://habrastorage.org/getpro/habr/post_images/76d/6f9/380/76d6f9380c8e8506f67146bc32caafb0.gif">  .  On splay trees, the same requests are processed depreciated for <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  .  Memory used <img src="https://habrastorage.org/getpro/habr/post_images/39a/ed9/498/39aed9498a90431e37a7b32ffe2338cd.gif">  . <br><br><h4>  Internal presentation </h4><br>  High speed is achieved due to the cunning internal presentation.  Divide each tree into a set of paths.  Each vertex will lie exactly in one path, and no two paths will intersect.  Each path must connect a descendant with an ancestor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/7b9/224/6047b92240fe3ae8b2031ff9866ba055.png"><br><br>  To work with paths, we use search trees with an implicit key.  So that there is no confusion in terminology, let's call the trees that we split on the path, <i>represented</i> , and the trees in which we fold these paths, <i>supporting</i> . <br><br>  The order of the elements in the reference tree is directed so that if you write out all its nodes in order to bypass the left subtree-key-right subtree, then the specified sequence will correspond to the passage of the stored path in the represented tree from the top to the bottom. <br><br>  Note that the edges that do not participate in the partition always connect the upper vertex of the path with its parent.  At each vertex we will store the link.  If the vertex is at the top of the path, the link points to its parent.  At the root of the tree, the link points to <code>None</code> . <br><br><h4>  Implicit Key Search Trees </h4><br>  Here I will only summarize the idea, and all the details, see the <a href="http://habrahabr.ru/post/102364">post about the Cartesian trees</a> . <br><br>  Implicit key search trees look like ordinary trees, only the key is not used in them.  You can search them <img src="https://habrastorage.org/getpro/habr/post_images/803/ddd/a6c/803ddda6c20185bcf1621ae51dc30a7f.gif">  th order element.  For this, the size of its subtree is recorded in each node.  Depending on the size of the left and right subtrees, we choose where to go.  It looks something like this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, k)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> v == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> threshold = size(v.left) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k == threshold: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k &lt; threshold <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v.left != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(v.left, k) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k &gt; threshold <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> v.right != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> find(v.right, k - threshold - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br>  When balancing the order of the elements in the search trees does not change.  Therefore, trees can be considered as smart arrays.  you can find <img src="https://habrastorage.org/getpro/habr/post_images/803/ddd/a6c/803ddda6c20185bcf1621ae51dc30a7f.gif">  -th element, delete it or insert it at the desired position.  All operations are feasible for <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  . <br><br>  If we talk about Cartesian or splay-trees, then we have two additional possibilities: to cut and merge trees.  Due to this we can merge and cut the sequence of elements for <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  . <br><br>  Applied to our problem, search trees using an implicit key allow us to cut one way into two, merge two into one and refer to <img src="https://habrastorage.org/getpro/habr/post_images/803/ddd/a6c/803ddda6c20185bcf1621ae51dc30a7f.gif">  billing item for <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  . <br><br><h4>  Expose and his friends </h4><br>  The key procedure in dynamic trees is <code>expose(v)</code> .  The procedure rebuilds the paths in the represented tree.  We will support the invariant that after the vertex <code>v</code> been requested, it will lie in the same path with the root.  Moreover, <code>v</code> will be the final vertex of the path. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bea/9d1/b43/bea9d1b43e6a5693cbc90759ac2f1a67.png"><br><br>  If you have written <code>expose</code> , then everything else looks more or less obvious. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">link</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> u.link = v expose(u)</code> </pre><br>  Put a link to the parent and run <code>expose</code> to support the invariant. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> expose(v) u.link = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> expose(u)</code> </pre><br>  The first call to <code>expose</code> we put the vertices <code>u</code> and <code>v</code> in different paths.  Feel free to zero the link, and run the second <code>expose</code> to maintain the invariant. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_root</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> expose(v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> leftest(supportRoot(v))</code> </pre><br>  After calling <code>expose</code> vertex <code>v</code> and the root will lie in the same reference tree.  If the tree is balanced, it is enough to climb to the root, and then go down to the far left node.  This will be the root.  I conditionally designated the ascent to the root via <code>supportRoot</code> , and the descent to the leftmost element through <code>leftest</code> .  In the case of a splay tree, <code>supportRoot</code> is replaced by <code>splay</code> . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">depth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> expose(v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size(supportRoot(v)) - <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  <code>expose</code> again, again the vertex <code>v</code> and the root in one path.  The size of the reference tree is equal to the number of nodes in this path.  We rise to the root, find the size of the reference tree.  Subtract one to get the number of edges. <br><br>  Let's also find the nearest common ancestor (lowest common ancestor). <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lca</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> expose(u) expose(v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> leftest(supportRoot(u)).link</code> </pre>  Draw on a piece of paper what will happen, and understand that this is really lca.  By the way, did you notice that if the vertices lie in different trees, then the procedure will return None?  Isn't it very nice of her? <br><br>  The <code>expose</code> procedure <code>expose</code> boils down to the following: we find the root of the reference tree in which the current node lies;  jump to the leftmost element to get to the top of the path.  These operations are feasible for <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  .  Let's follow the link to the next support tree and merge it with the previous one.  So we will do, until we reach the root of the represented tree. <br><br>  We will use the auxiliary procedure <code>cutout</code> , which cuts off the path on the top of <code>v</code> and puts the necessary links to the children. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> cutout(v) v = leftest(supportRoot(v)) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> v.link != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: cutout(v.link) merge(supportRoot(v.link), (v - v.link), supportRoot(v)) v.link = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> v = leftest(supportRoot(v)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v</code> </pre><br><h4>  Non-root trees </h4><br>  Dynamic trees can be expanded to non-root.  It is enough to be able to re-hang the trees.  Let's look at the following procedure: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">revert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function">:</span></span> expose(v) reverse(supportRoot(v))</code> </pre><br>  The <code>revert(v)</code> procedure connects the vertex <code>v</code> with the current root.  Note that if the root was a vertex <code>v</code> , then only the order of the elements on the path between <code>v</code> and the root would change.  Since the paths are stored in trees by an implicit key, we can implement a turn through delayed operations on segments ( <a href="http://habrahabr.ru/post/102364">4</a> again). <br><br>  Adding and deleting edges is trivial. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">link_edge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> revert(u) link(u, v)</code> </pre><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cut_edge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> revert(v) cut(u, v)</code> </pre><br>  In the first case, <code>revert</code> ensures that <code>u</code> is the root of the subtree.  In the second, the vertex <code>v</code> will be the parent of <code>u</code> . <br>  You can also find the distance between the vertices of one tree. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function">:</span></span> revert(v) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> depth(u)</code> </pre><br>  Operations on the segments provide great opportunities.  For example, the maximum flow search algorithms use them to quickly find the bandwidth in the residual network, as well as push the flow along the entire path at once.  More details can be found in the book of Tarjan ‚ÄúData Structures and Network Algorithms‚Äù. <br><br>  Regarding the task in the introduction.  The main problem is what to do if a loop appears when adding the next edge.  You need to quickly search for the heaviest edge in the path between the given vertices <code>u</code> and <code>v</code> .  <code>revert</code> from <code>u</code> , <code>expose</code> from <code>v</code> , and we got a reference tree containing this path.  Trees using an implicit key allow you to quickly search for the maximum.  Therefore, to find the edge is not difficult. <br><br>  Technical feature: if the weight of the rib going to the parent is stored in the reference tree at each vertex, then when the root changes, the parents change.  The problem can be solved if we store the edge weights to the next and previous vertices along the path.  An alternative solution is to create a separate vertex for each edge and only store there the weights. <br><br><h4>  Analysis </h4><br>  Let be <img src="https://habrastorage.org/getpro/habr/post_images/516/dd4/91d/516dd491d18aee1fcaca2f4e41d0533f.gif">  .  The operating time of all the above procedures consists of one or two runs of the <code>expose</code> procedure and a constant <br>  numbers of operations on supporting trees.  Operations on reference trees are performed in <img src="https://habrastorage.org/getpro/habr/post_images/d3b/cc1/661/d3bcc16611c6a88bc8251b9ee87bde3f.gif">  . <br><br>  Evaluate the <code>expose</code> procedure.  Let it consist of <img src="https://habrastorage.org/getpro/habr/post_images/803/ddd/a6c/803ddda6c20185bcf1621ae51dc30a7f.gif">  merges and cuts of support trees.  This number is expressed by the number of edges that we add to the path under construction.  We calculate their total number to get a depreciation estimate. <br><br>  We assign a weight to each vertex equal to the size of the subtree whose root it is.  A rib going from parent to child is called heavy if the weight of the child is strictly more than half the weight of the parent.  The remaining ribs are called light. <br><br>  <b>Statement.</b>  <i>The number of light edges on the way from the root to any leaf does not exceed</i> <img src="https://habrastorage.org/getpro/habr/post_images/d13/140/082/d13140082c414e9a0f93449459914317.gif">  . <br><br>  Each time, going down from the parent to the child along a light edge, the size of the current subtree is reduced at least twice.  Since the size of the tree does not exceed <img src="https://habrastorage.org/getpro/habr/post_images/c7f/092/d48/c7f092d481acb49c8a0f96178ceb3119.gif">  , the number of light edges on the way from the root to any leaf does not exceed <img src="https://habrastorage.org/getpro/habr/post_images/d13/140/082/d13140082c414e9a0f93449459914317.gif">  . <img src="https://habrastorage.org/getpro/habr/post_images/a8e/bdf/07e/a8ebdf07e1219a23c6f51afadcf2d768.gif"><br><br>  Based on the previous statement, for all <code>expose</code> calls we will add to the path <img src="https://habrastorage.org/getpro/habr/post_images/076/63d/c3c/07663dc3c790b8c5e111597f71b68abc.gif">  light ribs.  Calculate the number of heavy ribs that we add.  When adding each heavy rib we will put a coin on it.  When the edge no longer lies in the way, we will take this coin.  We estimate how many coins we spend. <br><br>  We can pick up a coin only in two cases: a) <code>expose</code> was caused by the <code>expose</code> and we were cut off, b) a neighboring edge is now on the way.  The first case can occur no more <img src="https://habrastorage.org/getpro/habr/post_images/601/5f7/e7e/6015f7e7e19971bf1372e01171eaadcb.gif">  time.  In the second case, the adjacent selected edge will be light.  This can happen no more. <img src="https://habrastorage.org/getpro/habr/post_images/e15/64e/331/e1564e331115f78dea1c895735106b26.gif">  time.  At the end of the work in the tree can be no more <img src="https://habrastorage.org/getpro/habr/post_images/cc8/af6/3dd/cc8af63dd0683bada105f4c047e6c3db.gif">  heavy rib.  This means that there are no more total ribs. <img src="https://habrastorage.org/getpro/habr/post_images/193/3b2/260/1933b2260f9fbbb6ba78deeac2ac4ffa.gif">  .  Thus, the total processing time of all operations <img src="https://habrastorage.org/getpro/habr/post_images/210/811/567/210811567fd7b3c5736101a06049f798.gif">  . <br><br><h4>  Practical tests </h4><br>  In practice, for trees with a small diameter, it is better to use normal <code>DFS</code> .  Dynamic trees become noticeably efficient when we work with large trees and a large number of <code>link</code> and <code>cut</code> queries.  The most high performance is shown on splay-trees.  You can find out more in the <a href="http://www.cs.princeton.edu/~rwerneck/docs/TW07.pdf">review of Tarjan, Werneck ‚ÄúDynamic Trees in Practice‚Äù</a> . <br><br>  Implementation on python can be found <a href="http://pastebin.com/AgPH8yaV">here</a> . <br><br><h4>  About life... </h4><br>  If you read this far, then I congratulate you.  I would like to convey a message to two categories of my readers. <br><br>  The first ones are program students of third and fourth year undergraduate courses.  Probably, you didn‚Äôt say anything like that at lectures, and you would like to fill in the gaps in the algorithms and many other topics.  You have the opportunity to enroll in the magistracy of the Academic University on <a href="http://mit.spbau.ru/department">software development</a> .  This is a great chance to replenish your knowledge, put your hand under the supervision of experienced programmers, and for non-residents - to move to Peter.  Studying here is not easy, but worth it. <br><br>  The second are people who wander between Project Euler and Braingames, between Braingames and Topcoder.  Are you looking for math problems?  Theoretical informatics is great, and there will definitely be a place and a task for you.  Look at books about approximate ( <a href="http://www.designofapproxalgs.com/book.pdf">8</a> , <a href="http://www.amazon.com/Approximation-Algorithms-Vijay-V-Vazirani/dp/3540653678">9</a> ), exponential ( <a href="http://www.amazon.com/Exponential-Algorithms-Theoretical-Computer-Science/dp/364216532X">10</a> ), parameterized ( <a href="http://www.amazon.com/Invitation-Parameter-Algorithms-Mathematics-Applications/dp/0198566077">11</a> ) algorithms, communication complexity ( <a href="http://www.amazon.com/Communication-Complexity-Eyal-Kushilevitz/dp/052102983X">12</a> ), structural complexity ( <a href="http://www.amazon.com/Communication-Complexity-Eyal-Kushilevitz/dp/052102983X">13</a> ).  If it is interesting to you, come to study on <a href="http://mit.spbau.ru/csmaster">theoretical computer science</a> . <br><br>  Do not miss your opportunity! <br><br><h4>  Literature </h4><br><ol><li>  <a href="http://www.cs.princeton.edu/~rwerneck/papers/TW07-dyntrees-practice.pdf">Dynamic Trees in Practice Tarjan, Werneck</a> </li><li>  <a href="http://www.cs.cmu.edu/~sleator/papers/dynamic-trees.pdf">"A Data Structure for Dynamic Trees" Sleator, Tarjan</a> </li><li>  <a href="http://www.amazon.com/Structures-Algorithms-CBMS-NSF-Conference-Mathematics/dp/0898711878">"Network Algorithms and Data Structures" Tarjan</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/216733/">https://habr.com/ru/post/216733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../216715/index.html">Broccoli: first beta release</a></li>
<li><a href="../216719/index.html">As a single prosecution, Microsoft destroyed the trust of customers in the integrity of their data in the "cloud" services</a></li>
<li><a href="../216723/index.html">Mozilla changes the design of Firefox: try Firefox 29 beta</a></li>
<li><a href="../216725/index.html">Abstract Data Type Concept</a></li>
<li><a href="../216729/index.html">Machine learning in a simple project</a></li>
<li><a href="../216735/index.html">Making the server with your own hands</a></li>
<li><a href="../216737/index.html">Interface with drag-and-drop: how not to confuse the user?</a></li>
<li><a href="../216739/index.html">SQLite database encryption in Qt</a></li>
<li><a href="../216741/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ101 (March 16 - 22, 2014)</a></li>
<li><a href="../216743/index.html">Build-traffic light: the story of another introduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>