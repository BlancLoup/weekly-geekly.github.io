<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How the tiOPF framework for delphi / lazarus works. Template "Visitor"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator 
 There are two reasons why I undertook to translate several materials on the framework developed not twenty years ago for the most po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How the tiOPF framework for delphi / lazarus works. Template "Visitor"</h1><div class="post__text post__text-html js-mediator-article"><h3>  From translator </h3><br>  There are two reasons why I undertook to translate several materials on the framework developed not twenty years ago for the most popular programming environment today: <br><br>  1. A few years ago, having learned many of the charms of working with the Entity Framework as ORM for the .Net platform, I vainly looked for counterparts for the Lazarus environment and, in general, for freepascal. <br>  Surprisingly, there are no good ORMs for it.  All that then managed to find - an open-source project called <a href="http://tiopf.sourceforge.net/index.shtml">tiOPF</a> , developed in the late 90s for delphi, later ported to freepascal.  However, this framework is fundamentally different from the usual form of large and thick ORM. <br><br>  There are no visual ways of designing objects (in Entity - model first) and matching objects with fields of relational database tables (in Entity - database first) in tiOPF.  The developer himself positions this fact as one of the drawbacks of the project, but as a virtue it offers a full orientation specifically to the object business model, it‚Äôs worth only once ... <br><a name="habracut"></a><br>  It was at the level of the proposed hardcoding that I had problems.  At that time, I was not very well versed in the paradigms and methods that the framework developer used in full and mentioned in the documentation several times per paragraph (visitor, linker, observer design patterns, several levels of abstraction for DBMS independence, etc. .).  My big project working with a database at that time was completely focused on the visual components of Lazarus and the way of working with databases offered by the visual environment, as a result - tons of the same code: three tables in the database itself with almost the same structure and homogeneous data three identical forms for viewing, three identical forms for editing, three identical forms for reports and all the rest from the top heading ‚Äúhow not to design software‚Äù. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After reading a lot of literature on the principles of proper database design and information systems, including the study of templates, and also getting acquainted with the Entity Framework, I decided to do a full refactoring of both the database itself and my application.  And if I coped with the first task, then for the implementation of the second there were two roads going in different directions: either completely go to the study of .net, C # and the Entity Framework, or find a suitable ORM for the usual Lazarus system.  There was also a third inconspicuous cycling trail - to write the ORM for your own needs, but this is not the point now. <br><br>  The source code of the framework is little commented, however, the developers still prepared (apparently in the initial development period) a certain amount of documentation.  All of it, of course, is English-speaking, and experience shows that, despite the abundance of code, diagrams and patterned programmer phrases, many Russian-speaking programmers are still poorly oriented in English-language documentation.  Not always and not everyone has the desire to train the ability to understand English technical text without the need for the mind to translate it into Russian. <br><br>  In addition, re-reading the text for translation allows you to see what I missed when I first got acquainted with the documentation, did not understand completely or incorrectly.  That is, it is also an opportunity for oneself to better assimilate the studied framework. <br><br>  2. In the documentation, the author intentionally or not skips some pieces of code, probably obvious in his opinion.  In connection with the prescription of its writing, the documentation uses as examples obsolete mechanisms and objects deleted or no longer used in new versions of the framework (did I not say that it continues to evolve?).  Also, when I repeated the examples I developed myself, I found some errors that should be corrected.  Therefore, in some places I allowed myself not only to translate the text, but also to supplement or rework it so that it remains relevant, and the examples are working. <br><br>  I want to begin the translation of materials from the article by Peter Henrikson about the first ‚Äúwhale‚Äù on which the whole framework - the Visitor template stands.  <a href="http://tiopf.sourceforge.net/Doc/Concepts/2_TheVisitorFramework.shtml">The original text is posted here</a> . <br><br><h2>  Template Visitor and tiOPF </h2><br>  The purpose of this article is to introduce the Visitor template, the use of which is one of the main concepts of the tiOPF framework (TechInsite Object Persistence Framework).  We will look at the problem in detail, after analyzing alternative solutions before using the Visitor.  In the process of developing your own concept of the Visitor, we will face another task: the need to iterate all the objects in the collection.  This issue will also be studied. <br><br>  The main task is to come up with a generalized way of executing a set of related methods on some objects of the collection.  The methods performed may vary depending on the internal state of the objects.  We can not execute methods at all, but we can execute several methods on the same objects. <br><br><h3>  Required level of training </h3><br>  The reader must be familiar with object pascal and be familiar with the basic principles of object-oriented programming. <br><br><h3>  Sample business problem in this article </h3><br>  As an example, we will develop an address book that allows you to create records about people and their contact information.  With the increase in possible ways of communication between people, the application should be able to flexibly add such methods without significantly reworking the code (I remember once, once you had finished reworking the code to add a phone number, you immediately needed to rework it to add e-mail).  We need to provide two categories of addresses: real, such as home address, postal, work, and electronic: landline telephone, fax, mobile, e-mail, website. <br><br>  At the presentation level, our application should look like Explorer / Outlook, that is, it is supposed to use standard components such as TreeView and ListView.  The application should work quickly and not give the impression of bulky client-server software. <br><br>  The application might look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/fa8/773/18afa8773d4df14f7c08b3e4ae5ec204.png"><br><br>  In the context menu of the tree, you can choose to add / delete a contact of a person or company, and right-click on the list of contact data - to call the dialog to edit them, delete or add data. <br><br>  The data can be saved in various forms, and in the future we will look at how to use this Adapter template to implement this feature. <br><br><h3>  Before the start </h3><br>  We will begin work with a simple collection of objects ‚Äî a list of people who, in turn, have two properties ‚Äî a name (Name) and an address (EmailAdrs).  To begin with, the list will be populated with data in the constructor, and later - loaded from a file or database.  Of course, this is a very simplified example, but it is sufficient for the full implementation of the Visitor pattern. <br><br>  Create a new application and add two classes of the interface module section of the main module: TPersonList (inherits from TObjectList and requires connection in the uses of the contnrs module) and TPerson (inherited from TObject): <br><br><pre><code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList)  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;  <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject)  <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>    FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;    FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs;  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  In the TPersonList constructor, we will create three TPerson objects and add them to the list: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; lData := TPerson.Create; lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := <span class="hljs-string"><span class="hljs-string">'Malcolm Groves'</span></span>; lData.EMailAdrs := <span class="hljs-string"><span class="hljs-string">'malcolm@dontspamme.com'</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// (ADUG Vice President) Add(lData); lData := TPerson.Create; lData.Name := 'Don MacRae';  // (ADUG President) lData.EMailAdrs := 'don@dontspamme.com'; Add(lData); lData := TPerson.Create; lData.Name := 'Peter Hinrichsen';  // (Yours truly) lData.EMailAdrs := 'peter_hinrichsen@dontspamme.com'; Add(lData); end;</span></span></code> </pre> <br>  To begin, we will go through the list and perform two operations on each item in the list.  The operations are similar, but not identical: a simple call to ShowMessage with the output of the contents of the Name and EmailAdrs properties of TPerson objects.  Add two buttons to the form and name them like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/819/5ce/2018195cee6acbb2348e3ceb78abeaea.png"><br><br>  In the preferred field of view of your form, you should also add a property (or just a field) FersonList of type TPersonList (if the type is declared below the form, then either change the order or make a preliminary type declaration), and call the constructor in the onCreate event handler: <br><br><pre> <code class="delphi hljs">FPersonList := TPersonList.Create;</code> </pre> <br>  To properly free memory in the form's onClose event handler, this object must be destroyed: <br><br><pre> <code class="delphi hljs">FPersonList.Free.</code> </pre> <br><h3>  Step 1. Hardcoding iteration </h3><br>  To display names from TPerson objects, add the following code to the first button's onClick event handler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  For the second button, the handler code will be as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Here are the obvious jambs of this code: <br><br><ul><li>  two methods that do almost the same thing.  The only difference is in the name of the property of the object, which they show; <br></li><li>  the iteration will be tedious, especially when you have to write a similar loop in a hundred places in the code; <br></li><li>  hard type casting to TPerson is fraught with exceptional situations.  What if the list contains a copy of TAnimal without an address property?  There is no mechanism to stop the error and protect against it in this code. <br></li></ul><br>  Let's figure out how to improve the code by introducing an abstraction: pass the iterator code to the parent class. <br><br><h3>  Step 2. Abstraction iterator </h3><br>  So, we want to bring the logic of the iterator to the base class.  The list iterator itself is very simple: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">// -    ‚Ä¶</span></span></code> </pre> <br>  It sounds as if we are planning to use the <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D1%2582%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Iterator</a> pattern.  From the book about the design patterns of the gang of four ( <a href="https://ru.wikipedia.org/wiki/Design_Patterns">Gang-of-Four design patterns book</a> ) it is known that the Iterator is external and internal.  When using an external iterator, the bypass process is explicitly controlled by the client by calling the Next method (for example, the iteration of the TCollection elements is controlled by the First, Next, Last methods).  We will use an internal iterator here, since with its help it is easier to implement tree traversal, which is our goal.  To our list class, we will add an Iterate method and will pass to it a callback method that must be performed on each element of the list.  Callback in object pascal is declared as a procedural type, we will have, for example, TDoSomethingToAPerson. <br><br>  So, we declare the procedural type TDoSomethingToAPerson, which takes one parameter of type TPerson.  A procedural type allows you to use a method as a parameter of another method, that is, to implement a callback.  In this way, we will create two methods, one of which will show the Name property of the object, and the other the EmailAdrs property, and they will be passed as a parameter for the general iterator.  The final type declaration section should look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TPerson }</span></span> <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TDoSomethingToAPerson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TPersonList }</span></span> <span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   DoSomething: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pMethod(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Now, to perform the necessary actions on the elements of the list, we need to do two things.  First, determine the necessary operations using methods that have the signature specified by TDoSomethingToAPerson, and second, write calls to DoSomething with passing pointers to these methods as a parameter.  In the form description section, add two declarations: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FPersonList: TPersonList;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  In the implementation of these methods, we indicate: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The code for button handlers is changed as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowEmail); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Already better.  Now we have three levels of abstraction in the code.  A common iterator is a class method that implements a collection of objects.  Business logic (for the time being just infinite output of messages via ShowMessage) is located separately.  At the presentation level (GUI), the business logic is invoked in a single line. <br><br>  It is easy to imagine how the ShowMessage call can be replaced with code that saves our data from TPerson in a relational database using a SQL query of the TQuery object.  For example, like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavePerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lQuery: TQuery; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lQuery := TQuery.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   lQuery.SQL.Text := <span class="hljs-string"><span class="hljs-string">'insert into people values (:Name, :EMailAdrs)'</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'Name'</span></span>).AsString := pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'EMailAdrs'</span></span>).AsString := pData.EMailAdrs;   lQuery.Datababase := gAppDatabase;   lQuery.ExecSQL; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lQuery.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  By the way, this introduces a new problem of maintaining a database connection.  In our request, the connection to the database is carried out through a certain global object gAppDatabase.  But where will it be located and how to work?  In addition, at every iterator step, we will torture ourselves to create TQuery objects, set up a connection, execute a query, and not forget to free up memory.  It would be better to wrap this code in a class that encapsulates the logic of creating and executing SQL queries, as well as setting up and maintaining a connection to the database. <br><br><h3>  Step 3. Passing an object instead of passing a pointer to callback </h3><br>  Passing an object to the base class iterator method will solve the state support problem.  We will create an abstract Visitors class TPersonVisitor with a single Execute method and pass the object to this method as a parameter.  The abstract Visitor interface is shown below: <br><br><pre> <code class="delphi hljs">  <span class="hljs-title"><span class="hljs-title">TPersonVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Next, add the Iterate method to our TPersonList class: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The implementation of this method will be as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pVisitor.Execute(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The object of the implemented Visitor of the TPersonVisitor class is passed to the Iterate method, and when iterating through the list items, the specified Visitor (its execute method) is called for each of them with the TPerson instance as a parameter. <br><br>  Create two implementations of the Visitor, TShowNameVisitor and TShowEmailVistor, which will perform the required work.  Here is how the module interface section is replenished: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TShowNameVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowNameVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TShowEmailVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowEmailVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  For the sake of simplicity, the implementation of the execute methods will still be one line - ShowMessage (pPerson.Name) and ShowMessage (pPerson.EMailAdrs). <br><br>  And change the code for the button click handlers: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowNameVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowEmailVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Now, having solved one problem, we have created another.  The iterator logic is encapsulated in a separate class;  the operations performed during the iteration are wrapped in objects, which allows us to save some state information, but the code size has grown from one line (FPersonList.DoSomething (@DoShowName); up to nine lines for each button handler. What It will help us now - this is the Visitors Manager, who will take care of creating and freeing their instances.Potentially, we can provide for performing several operations with objects during their iteration, for this, the Visitors Manager will store their list and run through it at each step, you  . Olnyaya only selected operations Next will clearly demonstrate the benefits of this approach, we will use the visitors to save the data in a relational database as a simple data saving operation can be carried out by three different SQL statements: CREATE, DELETE and the UPDATE. <br><br><h3>  Step 4. Further Visitor Encapsulation </h3><br>  Before proceeding further, we must encapsulate the logic of the Visitor‚Äôs work, separating it from the business logic of the application so as not to return to it.  We have three steps to do this: create TVisited and TVisitor base classes, then base classes for a business object and a collection of business objects, then adjust our specific TPerson and TPersonList (or TPeople) classes a little so that they become the heirs of the created base classes. classes.  In general terms, the structure of classes will correspond to this diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bb/f5e/b62/8bbf5eb6201de628050d085c061fe800.png"><br><br>  The TVisitor object implements two methods: the AcceptVisitor function and the Execute procedure, into which an object of the TVisited type is passed.  The TVisited object, in turn, implements the Iterate method with a parameter of type TVisitor.  That is, TVisited.Iterate should call the Execute method on the transferred TVisitor object, sending a link to its own instance as a parameter, and if the instance is a collection, then the Execute method is called for each item contained in the collection.  The AcceptVisitor function is necessary, since we are developing a generic system.  It will be possible to pass to the Visitor, which operates only with types of TPerson, an instance of the TDog class, for example, and there must be a mechanism to prevent exceptions and access errors due to the type mismatch.  The TVisited class is a successor of the TPersistent class, since we will need to implement the functions related to the use of RTTI a little later. <br><br>  The interface part of the module will now be like this: <br><br><pre> <code class="delphi hljs">TVisited = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisited }</span></span> <span class="hljs-title"><span class="hljs-title">TVisited</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersistent) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The methods of the abstract TVisitor class will be implemented by successors, and the general implementation of the Iterate method for TVisited is given below: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisited</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pVisitor.Execute(self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  In this case, the method is declared virtual in order to be able to override it in successors. <br><br><h3>  Step 5. Creating a shared business object and collection </h3><br>  Our framework needs two more base classes: to define a business object and a collection of such objects.  Let's call them TtiObject and TtiObjectList.  The interface of the first of them: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisited) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  In the future, in the development process, we will complicate this class, but for the current task it is enough to have only one virtual constructor with the possibility of overriding it in the heirs. <br><br>  We plan to generate the TtiObjectList class from TVisited in order to use behavior in methods that has already been implemented by the ancestor (there are also other reasons for this inheritance, which will be discussed in their place).  In addition, nothing prohibits the use of <abbr title="The author does not implement the part with interfaces in the manual, since The article was written in the 90s and the fashion for their use in freepascal has not yet come.">interfaces</abbr> (interfaces) instead of abstract classes. <br><br>  The interface part of the TtiObjectList class will be as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObjectList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pData: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  As you can see, the container itself with object elements is located in a protected section and will not be accessible to clients of this class.  The most important part of the class is the implementation of the override Iterate.  If in the base class the method was simply called pVisitor.Execute (self), here the implementation is associated with enumerating the list: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiObjectList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   (FList.Items[i] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TVisited).Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  The implementation of other class methods takes up one line of code without taking into account the automatically placed inherited expressions: <br><br><pre> <code class="delphi hljs">Create: FList := TObjectList.Create; Destroy: FList.Free; Clear: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Clear; Add: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Add(pData);</code> </pre> <br>  This is an important part of the whole system.  We have two base classes of business logic: TtiObject and TtiObjectList.  Both have an Iterate method in which an instance of the TVisited class is passed.  The iterator itself calls the TVSitor class's Execute method and passes it a reference to the object itself.  This call is predefined in class behavior at the top level of inheritance.  For a container class, each object stored in the list also has its Iterate method, called with a parameter of type TVisitor, that is, it is guaranteed that each specific Visitor will bypass all objects stored in the list, as well as the list itself as a container object. <br><br><h3>  Step 6. Creating a visitor manager </h3><br>  So, back to the problem that we ourselves drew in the third step.  Since we don‚Äôt want to create and destroy instances of Visitors every time, the development of the Manager will be the solution.  It should perform two main tasks: manage the list of Visitors (which are registered as such in the initialization section of individual modules) and start their execution when receiving the appropriate command from the client. <br>  To implement the manager, we will add our module with three additional classes: The TVisClassRef, TVisMapping and TtiVisitorManager. <br><br><pre> <code class="delphi hljs">TVisClassRef = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TVisitor;</code> </pre> <br>  TVisClassRef is a reference type and indicates the name of a particular class - a descendant of TVisitor.  The meaning of using a reference type is as follows: when the base Execute method with a signature is called <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TVisited; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pVisClass: TVisClassRef)</span></span></span><span class="hljs-function">,</span></span></code> </pre> <br>  inside this method can use an expression like lVisitor: = pVisClass.Create to create an instance of a specific Visitor, not knowing initially about its type.  That is, any class - a descendant of TVisitor can be dynamically created within the same Execute method by passing the name of its class as a parameter. <br><br>  The second class TVisMapping is a simple data structure with two properties: a reference to the TVisClassRef type and a Command string property.  The class is needed to compare the operations performed by their name (command, for example, ‚Äúsave‚Äù) and the Visitor class, which these commands execute.  Add its code to the project: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisMapping</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FCommand: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FVisitorClass: TVisClassRef; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> VisitorClass: TVisClassRef <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FVisitorClass <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FVisitorClass;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Command: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCommand <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FCommand; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  And the last class is TtiVisitorManager.  When we register a Visitor using the Manager, an instance of the TVisMapping class is created and entered into the Manager list. <br>  Thus, in the Manager, a list of Visitors is created with the matching of a string command, upon receipt of which they will be executed.  The class interface is added to the module: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiVisitorManager</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Its key methods are RegisterVisitor and Execute.  The first is usually called in the initialization section of the module, which describes the Visitor class, and looks like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span>  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowNameVisitor);  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowEMailAdrsVisitor);</code> </pre> <br>  The code for the method itself will be as follows: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TVisMapping; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lData := TVisMapping.Create; lData.Command := pCommand; lData.VisitorClass := pVisitorClass; FList.Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  It is not difficult to notice that this code is very similar to the Pascal implementation of the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Factory</a> pattern. <br><br>  Another important method, Execute, takes two parameters: a command that identifies the Visitor to be executed or their group, as well as a data object, the Iterate method of which will be called with passing a reference to the instance of the desired Visitor.  The full code for the Execute method is shown below: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lVisitor: TVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SameText(pCommand, TVisMapping(FList.Items[i]).Command) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>     lVisitor := TVisMapping(FList.Items[i]).VisitorClass.Create;     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>       pData.Iterate(lVisitor);     <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>       lVisitor.Free;     <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Thus, to launch one team of two previously registered Visitors, we need only one line of code: <br><br><pre> <code class="delphi hljs">gTIOPFManager.VisitorManager.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, FPeople);</code> </pre> <br>  Next, we will complement our project so that you can call such commands: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      gTIOPFManager.VisitorManager.Execute('read', FPeople); //      gTIOPFManager.VisitorManager.Execute('save', FPeople).</span></span></code> </pre> <br><h3>  Step 7. Adjustment of business logic classes </h3><br>  Adding an ancestor of the TtiObject and TtiObjectList classes to our TPerson and TPeople business objects allows us to encapsulate the iterator logic in the base class and not touch it anymore, in addition, it becomes possible to transfer data objects to the Visitors Manager. <br><br>  The new container class declaration will look like this: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPeople</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObjectList);</code> </pre> <br>  In fact, the TPeople class does not even have to implement anything itself.  Theoretically, we could do without the TPeople declaration at all and store objects in an instance of the TtiObjectList class, but since we plan to write Visitors that process only TPeople instances, we need this class.  In the AcceptVisitor function, the following verification will be performed: <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople.</code> </pre> <br>  For the TPerson class, we add the ancestor TtiObject, and move the two existing properties to the published scope, since in the future we will need to work through RTTI with these properties.  Much later, this will significantly reduce the code mapping objects and records in a relational database: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">published</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3>  Step 8. Create a prototype view </h3><br>  <b><i>Remark</i></b>  In the original article, the GUI was based on components that the author of tiOPF made for the convenience of working with its framework in delphi.  It was similar to DB Aware components, which were standard controls such as tags, input fields, checkboxes, lists, etc., but they were associated with certain properties of tiObject objects as well as data display components were associated with fields of database tables.  Over time, the framework author marked the packages with these visual components as obsolete and undesirable to use.  Instead, he proposes creating a link between visual components and class properties using the Mediator design pattern.  This template is the second most important in the entire framework architecture.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The description of the Intermediary is taken up by the author in a separate article, comparable in size to this manual, so here I am offering my simplified version as a GUI. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rename button 1 on the project form to ‚Äúshow command‚Äù, and either leave button 2 for now without a handler, or call ‚Äúsave command‚Äù right away. </font><font style="vertical-align: inherit;">Throw a memo-component on the form and place all the elements to your taste. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add a Visitor class that will implement the "show" command: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface -</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TShowVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the implementation is </font></font><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPerson); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; Form1.Memo1.Lines.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptVisitor verifies that the object being passed is an instance of TPerson, since the Visitor has to execute a command with such objects only. If the type matches, the command is executed and a line with the properties of the object is added to the text field. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auxiliary actions for the performance of the code will be as follows. Add two properties to the description of the form itself in the private section: FPeople of type TPeople and VM of type TtiVisitorManager. In the form creation event handler, we need to initiate these properties, as well as register the Visitor with the ‚Äúshow‚Äù command:</font></font><br><br><pre> <code class="delphi hljs">FPeople := TPeople.Create; FillPeople; VM := TtiVisitorManager.Create; VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,TShowVisitor);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FilPeople is also an auxiliary procedure that fills the list with three objects, its code is taken from the previous list constructor. </font><font style="vertical-align: inherit;">Do not forget also to destroy all created objects. </font><font style="vertical-align: inherit;">In this case, in the form closing handler, we write FPeople.Free and VM.Free. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now - bams! </font><font style="vertical-align: inherit;">- handler of the first button:</font></font><br><br><pre> <code class="delphi hljs">Memo1.Clear; VM.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,FPeople);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agree, it is already much more fun. </font><font style="vertical-align: inherit;">And do not swear at the jumble of all classes in a single module. </font><font style="vertical-align: inherit;">At the very end of the manual, we will rake these debris.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 9. The base class of the Visitor, working with text files </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage we will create the base class of the Visitor, who knows how to work with text files. In object pascal, there are three ways to work with files: old procedures from the time of the first pascal (like AssignFile and ReadLn), work through streams (TStringStream or TFileStream), and using the TStringList object.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the first method is very outdated, then the second and third are a good alternative based on the PLO. </font><font style="vertical-align: inherit;">At the same time, work with threads additionally gives such advantages as the ability to compress and encrypt data, but the line-by-line reading and writing to the stream is a kind of redundancy in our example. </font><font style="vertical-align: inherit;">For simplicity, we will choose TStringList, which has two simple methods - LoadFromFile and SaveToFile. </font><font style="vertical-align: inherit;">But remember that with large files these methods will significantly slow down, so the stream will be the best choice for them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface base class TVisFile:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisFile</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   FList: TStringList;   FFileName: TFileName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the implementation of the constructor and destructor: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; FList := TStringList.Create; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(FFileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   FList.LoadFromFile(FFileName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FList.SaveToFile(FFileName); FList.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value of the FFileName property will be assigned in the constructors of the descendants of this base class (just do not use hardcoding, which we will arrange here, as the main programming style after!). </font><font style="vertical-align: inherit;">The class diagram of Visitors working with files is as follows: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/969/104/717969104d4b13d73ba1844fe0c2ddf9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In accordance with the diagram below, we create two descendants of the TVisFile base class: TVisTXTFile and TVisCSVFile. </font><font style="vertical-align: inherit;">One will work with * .csv files in which data fields are separated by a symbol (comma), the second one - with text files in which individual data fields will be of a fixed length in a line. </font><font style="vertical-align: inherit;">For these classes, we redefine only constructors as follows:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.csv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.txt'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 10. Add a Text File Visitor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we will add two specific Visitors, one will read the text file, the second will write to it. </font><font style="vertical-align: inherit;">The reader must override the AcceptVisitor and Execute base class methods. </font><font style="vertical-align: inherit;">AcceptVisitor verifies that the TPeople class object is passed to the Visitor:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The implementation of execute looks like this: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXtRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">//==&gt; TPeople(pVisited).Clear; for i := 0 to FList.Count - 1 do begin   lData := TPerson.Create;   lData.Name := Trim(Copy(FList.Strings[i], 1, 20));   lData.EMailAdrs := Trim(Copy(FList.Strings[i], 21, 80));   TPeople(pVisited).Add(lData); end; end;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The visitor first clears the list of the TPeople object passed to it by the parameter, then reads the strings from its TStringList object, into which the file contents are loaded, creates a TPerson object on each line and adds it to the list of the TPeople container. </font><font style="vertical-align: inherit;">For simplicity, the name and emailadrs properties in a text file are separated by spaces.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The record visitor implements the reverse operation. Its constructor (redefined) clears the internal TStringList (i.e., performs the FList.Clear operation; it is mandatory after inherited), AcceptVisitor checks that an object of the TPerson class is passed, which is not an error, but an important difference from the same method of the Visitor read. It would seem easier to implement a record in the same way - scan all the objects in the container, add them to the StringList and then save it to a file. All this was true, if we really talked about the final writing of data to a file, but we plan to perform data mapping in a relational database, this should be remembered. And in this case, we should execute SQL code only for those objects that have been changed (created, deleted or edited). That is why before the Visitor performs an operation on an objecthe has to check its type:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Tperson;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The execute method simply adds a string formatted with the specified rule to the internal StringList: first, the contents of the name property of the passed object, padded with spaces to 20 characters, then the contents of the emaiadrs property: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(PadRight(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)+PadRight(TPerson(pVisited).EMailAdrs,<span class="hljs-number"><span class="hljs-number">60</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 11. Add a CSV File Handler </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visitors of reading and writing are similar in almost all their colleagues from the TXT classes except for the way in which the final line of the file is formatted: in the CSV standard, property values ‚Äã‚Äãare separated by commas. </font><font style="vertical-align: inherit;">To read the lines and parse it into properties, we use the ExtractDelimited function from the strutil module, and the write is done by simple string concatenation:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; TPeople(pVisited).Clear; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>   lData := TPerson.Create;   lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">1</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   lData.EMailAdrs := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">2</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   TPeople(pVisited).Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All we have to do is register new Visitors in the Manager and check the functionality of the application. </font><font style="vertical-align: inherit;">In the form creation handler, add the following code:</font></font><br><br><pre> <code class="delphi hljs">VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, TVisTXTRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>,TVisTXTSave); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>,TVisCSVRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>,TVisCSVSave);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's do the necessary buttons on the form and assign the appropriate handlers to them: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/0c2/7c3/1120c27c31300af40162387ac222d33c.png"><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional file formats for saving data are realized by simply adding relevant Visitors and registering them in the Manager. </font><font style="vertical-align: inherit;">And pay attention to the following: we deliberately called the teams differently, that is, saveTXT and saveCSV. </font><font style="vertical-align: inherit;">If both Visitors compare one save command, then both of them will start at the same command, check it yourself.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Step 12. Final cleaning code </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For greater beauty and cleanliness of the code, as well as for the preparation of the project for the further development of interaction with the DBMS, we will distribute our classes in different modules in accordance with the logic and their purpose. </font><font style="vertical-align: inherit;">In the end, we should have the following structure of modules in the project folder, which allows you to do without circular dependencies between them (when assembling, arrange the necessary modules yourself in the uses sections):</font></font><br><br><table><tbody><tr><td>  Module <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Function </font></font><br></td><td>  Classes <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tivisitor.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Base Visitor and Manager Template Classes </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisitor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisited </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisMapping </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiVisitorManager</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiobject.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basic Business Logic Classes </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObject </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObjectList</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_BOM.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specific Business Logic Classes </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPerson </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPeople</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_SRV.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Specific Interaction Classes </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVRead </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTRead</font></font><br></td></tr></tbody></table><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, we looked at the problem of iterating a collection or a list of objects that can have different types. </font><font style="vertical-align: inherit;">We used the Visitor template proposed by GoF to optimally implement two different ways of mapping data from objects into files of different formats. </font><font style="vertical-align: inherit;">In this case, different methods can be performed on one team thanks to the creation of the Visitor Manager. </font><font style="vertical-align: inherit;">In the end, simple and illustrative examples, analyzed in the article, will help us further develop in a similar way a system of mapping objects into a relational database. </font></font><br><br> <i><b><a href="https://yadi.sk/d/q0zlT0Xo97yBmQ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code archive is here.</font></font></a></b></i> </div><p>Source: <a href="https://habr.com/ru/post/441266/">https://habr.com/ru/post/441266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441254/index.html">Seminar ‚ÄúWhy we contacted Kubernetes and what we get from this,‚Äù February 28, Moscow</a></li>
<li><a href="../441258/index.html">Fully functional dynamic tracing in Linux using eBPF and bpftrace</a></li>
<li><a href="../441260/index.html">How Neural Networks Helped Graphics</a></li>
<li><a href="../441262/index.html">Simple and long tasks filter out candidates better than short and complex ones.</a></li>
<li><a href="../441264/index.html">Kibana User Guide. Visualization. Part 2</a></li>
<li><a href="../441268/index.html">Ceedling + Eclipse or unit tests for microcontrollers</a></li>
<li><a href="../441270/index.html">First look at FoundationDB open by Apple</a></li>
<li><a href="../441272/index.html">Firmware update broke Nike sneakers</a></li>
<li><a href="../441278/index.html">How to create a beautiful color palette</a></li>
<li><a href="../441280/index.html">Configuring GAL in Zimbra Collaboration Suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>