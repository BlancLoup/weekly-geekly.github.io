<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Running in bags, blindfolded, back to front</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the fastest programming language - not always practical, but very interesting question. Site benchmarksgame is just about that. The essence of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Running in bags, blindfolded, back to front</h1><div class="post__text post__text-html js-mediator-article">  What is the fastest programming language - not always practical, but very interesting question.  Site <a href="http://benchmarksgame.alioth.debian.org/">benchmarksgame</a> is just about that.  The essence of the project is comparing the speed of programming languages ‚Äã‚Äãon a number of typical tasks.  I must say that the results are not always predictable.  What if javascript is as fast as c?  This is a scandal! <br><br><h4>  Pride and Prejudice </h4><br>  <i>The ability to do something quickly quickly is always highly valued by its owner, often regardless of the quality of performance.</i>  - Jane Austen <br><br>  <a href="http://benchmarksgame.alioth.debian.org/">Benchmarksgame is</a> often <a href="http://benchmarksgame.alioth.debian.org/">referenced</a> to prove the advantages or disadvantages of a particular programming language.  However, you need to be careful.  Those who are professionally engaged in measuring performance, know that in this case there are many <a href="https://shipilev.net/talks/codefest-Mar2014-benchmarking.pdf">pitfalls</a> , and you can easily get into trouble.  For example, a Java virtual machine takes some time to warm up.  Accordingly, on too short tests the results will be unrepresentable.  Fortunately, in terms of statistics, a very <a href="http://benchmarksgame.alioth.debian.org/for-programming-language-researchers.html">systematic approach is</a> used on the site. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But the numbers still can not be trusted, and here is why. <br><br><img src="https://habrastorage.org/webt/hm/pk/nd/hmpknd-fvgol2h4xdbhxnchldbu.jpeg"><br><a name="habracut"></a><br>  Imagine that your favorite programming language, say, C. At the same time, in one of the comparisons, C is inferior to Java, and significantly, twice.  Injustice!  You open the solution code in C and see that it is not very carefully written, and obviously a lot can be improved and optimized.  If at the same time a free evening is turned up and a pair of beer is on the table, a patch cannot be avoided.  This approach is the main problem. <br><br>  The idea of ‚Äã‚Äãthe site in comparison of standard, non-optimized solutions.  Ideally, it is required that all programs be implemented using the same typical algorithm.  It should not be used tricks, hacks, non-standard libraries and the like.  Alas, the current owner of the project Isaac Gouy, despite the obvious professionalism and thoroughness in other matters, still allows such decisions. <br><br>  For this reason, I will not give tables or graphs, but I will try to analyze in detail several tasks at the code level of various solutions. <br><br><h4>  Task: n-body </h4><br>  The king of Sweden Oscar II was an enlightened monarch.  He was worried about many important questions, for example, would the Moon fall to Earth?  In 1885, he announced a mathematical competition, at which the Three-Body Problem was presented - modeling the Earth-Moon-Sun system. <br><br>  The winning solution was presented by Henri Poincare, and although it was not accurate, it nevertheless made a significant contribution to the development of mathematics and, in particular, the theory of chaos.  In the general case, the task is called the N-body problem. <br><br>  <a href="http://benchmarksgame.alioth.debian.org/u64q/nbody.html">The n-body task</a> at the benchmarksgame is a simulation of the Sun-Jupiter-Saturn-Uranus-Neptune system using the finite increment method.  From a technical point of view, the task is a series of arithmetic operations on a small number of double type variables in a nested loop. <br><br>  It is logical that interpreted languages ‚Äã‚Äãshow mediocre results: 3 minutes for <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dhipe%26id%3D3">Erlang</a> , then <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dphp%26id%3D3">PHP</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dlua%26id%3D4">Lua</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dperl%26id%3D2">Perl</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dyarv%26id%3D2">Ruby</a> , and ends the 13-minute <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dpython3%26id%3D1">Python</a> series. <br><br>  Fair decisions on compiled programming languages ‚Äã‚Äãgo in a tight group from 20 to 22 seconds in the following order: <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dchapel%26id%3D1">Chapel</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dcsharpcore%26id%3D7">C #</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dgo%26id%3D3">Go</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Docaml%26id%3D1">OCaml</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dswift%26id%3D5">Swift</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Djava%26id%3D5">Java</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dfpascal%26id%3D1">Free Pascal</a> .  A little behind <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dnode%26id%3D1">Node.js</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dtypescript%26id%3D3">TypeScript</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dsbcl%26id%3D2">Lisp</a> and <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Ddart%26id%3D3">Dart</a> - all in the region of 27 seconds. <br><br><h4>  The leaders </h4><br>  An unexpectedly good result was shown by <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Drust%26id%3D1">Rust</a> : 13 seconds with a fair decision.  True, it is represented by a team of developers language Rust.  Perhaps the simplicity of the solution is only apparent. <br><br>  The undisputed winner is <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Difc%26id%3D6">Fortran</a> : 8 seconds, but there is a catch here too.  The best solution is the result of four iterations of code improvement by various developers.  Whether the final code is a model that any developer would write, the question is still controversial. <br><br><h4>  Cheaters </h4><br>  The solution on <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dghc%26id%3D2">Haskell</a> , although it is executed in 21 seconds, however, utilizes all 4 cores of the processor, which is not entirely fair. <br><br>  On <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dgpp%26id%3D3">C,</a> it was possible to optimize the program for up to 8 seconds, due to the use of the __m128d data type and the manual use of SSE2 instructions.  It is difficult to call it a fair decision.  With standard arithmetic, <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dnbody%26lang%3Dgpp%26id%3D3">C</a> executes in the same 20 seconds. <br><br><h4>  findings </h4><br>  Compiled programming languages ‚Äã‚Äãare almost equally fast in mathematical calculations, they also include JavaScript (V8) and adjacent languages.  So, if you suddenly want to simulate the movement of the planets in your application, do it in the browser.  It will be just as fast and much more economical in terms of utilization of server resources. <br><br><h4>  Task: binary-trees </h4><br>  Although it does not have an equally deep historical context, it is no less curious than the previous one.  The essence of the problem is in the sequential construction of a series of complete binary trees, when each parent has exactly two descendants, from 6 to 22 depth. Each constructed tree must be walked into the depth and a simple check-sum is calculated, which is the answer of the algorithm. <br><br>  <a href="http://benchmarksgame.alioth.debian.org/u64q/binarytrees.html">The</a> goal is to measure the standard memory management mechanisms, so that the condition requires explicitly allocating and freeing memory for each node using the basic language tools.  Accordingly, by condition it is clearly forbidden to allocate at the start an array of the size of 8388608 minus 1 element, and all in this spirit. <br><br><h4>  The leaders </h4><br>  It is not surprising that the best honest result is <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Djava%26id%3D2">Java</a> (a little more than 12 seconds), since the execution model fits very well with the garbage collection model in jvm.  Since memory is allocated sequentially and then freed up in a large chunk, the cost of allocating Java memory on the heap is in this case comparable to the cost of allocating memory on the stack, i.e.  practically free. <br><br>  Even faster, it would be possible to work out only by turning on the <a href="https://habrahabr.ru/post/321856/">Zero GC</a> , i.e.  completely disabling the garbage collector.  Why not, if there is enough memory.  The idea, by the way, is not new.  The first Lisp implementation, <a href="http://www-formal.stanford.edu/jmc/history/lisp/node3.html">1958</a> , used just such a garbage collector.  The memory was allocated until the system had free memory, and the implementation of the garbage collection algorithm was postponed until better times. <br><br>  By comparison, a fair <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Dgcc%26id%3D1">C</a> decision using malloc and free on each node takes as many as 37 seconds.  Well, such a task. <br><br><h4>  Cheaters </h4><br>  <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Docaml%26id%3D2">OCaml</a> , 10 seconds - allocates memory by layers: <br>  let workers = Array.init ((max_depth - d) / 2 + 1) (fun i -&gt; let d = d + i * 2 in (d, invoke worker d)) <br><br>  <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Drust%26id%3D1">Rust</a> , 6 seconds - uses the concept of Arena and multithreading: <br>  let long_lived_arena = Arena :: new ();  let long_lived_tree = bottom_up_tree (&amp; long_lived_arena, max_depth); <br>  ... <br>  thread :: spawn (move || inner (depth, iterations)) <br><br>  Once again <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Drust%26id%3D2">Rust</a> , 4 seconds - uses Arend and parallel iterator (rayon :: prelude): <br>  let arena = Arena :: new (); <br>  let depth = max_depth + 1; <br>  let tree = bottom_up_tree (&amp; arena, depth); <br>  ... <br>  let chk: i32 = (0 ... iterations) .into_par_iter (). map (| _ | { <br>  ... <br><br>  Finally, <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Dgcc%26id%3D3">C</a> , 2 and a half seconds - uses apr_pools and preprocessor optimization: <br>  apr_pool_t * thread_Memory_Pool;  apr_pool_create_unmanaged (&amp; thread_Memory_Pool); <br>  ... <br>  #pragma omp parallel for <br>  for (current_Tree_Depth = minimum_Tree_Depth; ... <br><br><h4>  findings </h4><br>  A memory management model with a garbage collector for Java / C # can be significantly more efficient than naive manual memory management in certain tasks. <br><br>  Managing garbage collection in <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Ddart%26id%3D1">Dart</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Dnode%26id%3D1">Node.js,</a> and <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dbinarytrees%26lang%3Dgo%26id%3D1">Go</a> may require improvements: the result is about 40 seconds, and they could work as fast as Java.  Although it is likely that the speed of the garbage collector in these languages ‚Äã‚Äãis deliberately sacrificed to minimize memory consumption. <br><br>  By tackling the optimization of memory management manually, you can achieve at least a 2-fold increase in performance, and it is not too difficult. <br><br><h4>  Task: thread-ring </h4><br>  You must create 503 streams connected in a ring.  Accordingly, the 1st thread refers to the 2nd, 2nd to 3rd, and so on, the 503rd refers to the 1st.  It is necessary to transfer the token between threads 50,000,000 times in order, and then print the number of the process that received the token last.  Such a potato <a href="http://benchmarksgame.alioth.debian.org/u64q/threadring.html">game</a> . <br><br><h4>  Honest decisions </h4><br>  A neat solution would be to create 503 streams, connect them into a ring with 503 channels and transmit a message through them in a circle.  For Java, it would be BlockingQueue, for Go - channel, for Erlang - embedded interprocess messages. <br><br>  For <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Drust%26id%3D1">Rust,</a> it's about 3 minutes, <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dyarv%26id%3D1">Ruby</a> - 5 minutes, for <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dcsharpcore%26id%3D1">C #</a> - 6 minutes.  Unfortunately, there are no honest solutions for other languages. <br><br><h4>  Cheaters </h4><br>  <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Djava%26id%3D7">Java</a> , using LockSupport.park () and volatile managed to achieve 3 minutes of a penny.  A similar approach (using Mutex) for <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dpython3%26id%3D2">Python 3</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Docaml%26id%3D3">OCaml</a> , <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dsbcl%26id%3D1">Lisp</a> and <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dgcc%26id%3D1">C</a> works up to 2 and a half minutes.  It is curious that in all cases four processors are loaded on average by 30%, i.e.  the overhead of semi-active waiting is about 5%. <br><br>  <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dhipe%26id%3D3">Erlang</a> solutions - 43 seconds, <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dvw%26id%3D2">Smalltalk</a> - 39 seconds, <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dchapel%26id%3D1">Chapel</a> - 27 seconds, <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dgo%26id%3D6">Go</a> - 13 seconds and Haskell - 9 seconds are not counted, because in fact they used exactly one processor core, which gives no information and real interprocess communication performance in these languages.  The decision on Go generally states: runtime.GOMAXPROCS (1), this is not serious.  With the same success, it was possible to simply turn the cycle into fifty million iterations. <br><br>  Another hack is <a href="http://benchmarksgame.alioth.debian.org/u64q/program.php%3Ftest%3Dthreadring%26lang%3Dgpp%26id%3D4">C ++</a> : 29 seconds.  The solution is built on the basis of asio.hpp, a library of asynchronous I / O, which is interesting in itself, but has nothing to do with the task to transfer the message between threads.  Apparently, the solution on F # - 18 seconds - works according to the same principle, because it uses the async primitive to define a deferred function instead of a stream. <br><br><h4>  Conclusions instead of a leader </h4><br>  The leader, alas, no, because for languages ‚Äã‚Äãlike Go or Erlang, for which an honest decision would have to show good results, such a solution is not presented. <br><br>  Multi-threaded communication is much more efficient on program threads (Erlang, Go Routines), especially if it is performed on one physical core.  Juggling with real threads at the operating system level, with preservation and restoration of the full context, as well as prioritization within the framework of a common sheduler, at the level of all processes, is much slower. <br><br>  Asynchronous I / O instead of real flows is a great thing, but we have known this since nginx and node.js. <br><br><h4>  Grand total </h4><br>  <i>I am fast, I am very fast ... In the bedroom before bed, I hit the switch and have time to go to bed until the lights go out ... I am very fast.</i>  - Mohammed Ali <br><br>  The desire to embellish reality, unfortunately, wins common sense in the souls of developers, at least on the site benchmarksgame.  As a result, instead of being able to really compare various aspects of the performance of programming languages, we have a zoo with quite sophisticated code optimization techniques.  It is, of course, curious, but a little bit wrong.  But it seems it would be easy to restore order there. <br><br>  As for the various studies based on the benchmarksgame, do not believe, see the code. </div><p>Source: <a href="https://habr.com/ru/post/346684/">https://habr.com/ru/post/346684/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346670/index.html">Web components: review and use in production</a></li>
<li><a href="../346672/index.html">Single Sign-On, or Dancing Six</a></li>
<li><a href="../346676/index.html">Testing components with Puppeteer and Jest</a></li>
<li><a href="../346680/index.html">Bobaos - access to the KNX TP / UART bus with the Raspberry Pi</a></li>
<li><a href="../346682/index.html">Digital events in Moscow from January 15 to 21</a></li>
<li><a href="../346686/index.html">Projection modeling. Abstracts for beginners</a></li>
<li><a href="../346688/index.html">Anton Arnautov - about accelerators</a></li>
<li><a href="../346692/index.html">‚ÄúThe notion that this framework is outdated is wrong‚Äù: Andrey Gritsevich (Solar Security) about Ext JS</a></li>
<li><a href="../346694/index.html">Software use culture in the company</a></li>
<li><a href="../346696/index.html">Writing a multiplayer snake on tornado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>