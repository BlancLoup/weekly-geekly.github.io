<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Back to the Future - Decapsulation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When running program modules that store a large amount of data in RAM, the way they are stored has a strong effect on memory consumption and speed. On...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Back to the Future - Decapsulation</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/eef/70a/6f3/eef70a6f36334e019405de3892057b2e.gif" alt="image"></div><br>  When running program modules that store a large amount of data in RAM, the way they are stored has a strong effect on memory consumption and speed.  One way to speed up the system and save resources may be to use more primitive data structures ‚Äî structures instead of classes and primitive types instead of structures.  Of course, this approach breaks down the OOP and returns to the use of "old" programming methods.  However, in some cases, such primitization can solve many problems.  A simple test showed the possibility of reducing memory consumption by more than three times. <br><br>  Issues covered: <br><ul><li>  The impact of software architecture on memory consumption and performance; </li><li>  Differences when working in 32 and 64 bit modes; </li><li>  Differences between pointers and array indices; </li><li>  The impact of data alignment within classes / structures; </li><li>  The effect of processor cache on performance; </li><li>  Estimate the cost of supporting the PLO in high-level languages; </li><li>  Recognition of the need to take into account the low-level features of the platform, even when developing in high-level languages. </li></ul><br><a name="habracut"></a><br><h1>  Practical task </h1><br>  For the first time, I applied this technique when developing a search for the optimal path for the portal <a href="http://www.gomap.az/">www.GoMap.Az</a> .  The new algorithm used more RAM and, when installed on the test server, the application started to jam seriously.  Updating the hardware in this case required several days, and its solution by optimizing data structures made it possible to quickly solve the problem.  To share my experience, I decided to describe in a simple way what was done and what benefits were gained. <br><br>  The organization of storage of a large number of data structures and access to them is an integral task for information systems working with cartographic data.  Similar problems are also increasingly emerging when creating other types of modern information systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider data storage and access to them on the example of roads - the edges of the graph.  In simplified form, the road can be represented by the Road class, while the road storage is represented by the RoadsContainer class.  In addition, there is the Node class of the network node.  Regarding Node, we just need to know that this is a class.  We take into account that our data structures do not contain methods and do not participate in inheritance, etc., that is, they are used only for storing and manipulating data. <br><br>  We will consider the implementation of the method in C #, although it was originally applied in C ++.  Strictly speaking, the problem and its solution is somewhat in the field of system programming.  However, this study also shows how high the cost of supporting the OOP can be in high-level programming.  C # can best show these hidden costs without being a system programming language. <br><br><pre><code class="hljs pgsql">//    ‚Äì  Road <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Road { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> Length; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> byte Lines ; // -   Node  Road  //      <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Node NodeFrom; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Node NodeTo; //    } //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RoadsContainer { //    //  ,     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Road[] getRoads(<span class="hljs-type"><span class="hljs-type">float</span></span> X1, <span class="hljs-type"><span class="hljs-type">float</span></span> Y1, <span class="hljs-type"><span class="hljs-type">float</span></span> X1, <span class="hljs-type"><span class="hljs-type">float</span></span> Y1) { //  } //    }</code> </pre> <br><h1>  Memory and performance </h1><br>  When assessing memory consumption and performance, you should consider the impact of the platform architecture features, including: <br><ul><li>  <b><i>Data alignment</i></b>  Alignment of data is performed for correct and fast access of the central processor to the memory cells.  Depending on the capacity of the system, the arrangement of classes / structures in memory can begin with addresses that are multiples of 32 or 64 bits.  Inside the classes / structures themselves, fields can also be aligned along 32, 16, or 8 bits (for example, the Lines field of the Road class may take in memory not 1 byte, but 4).  At the same time there are unused memory spaces, which increases its loss .; </li><li>  <b><i>CPU cache</i></b>  As you know, the task of the cache is to speed up access to the most frequently used memory cells.  The size of the cache is very small, since it is the most expensive memory.  When processing classes / structures, unused memory spaces resulting from data alignment also end up in the processor‚Äôs cache and clog it up because they do not carry any useful information.  As a result, a decrease in caching efficiency. </li><li>  <b><i>Size pointers</i></b> .  In 32-bit systems, a pointer to an object in memory is also usually 32-bit, which limits the ability to work with RAM more than 4GB.  64-bit systems allow addressing significantly large amounts of memory, but use 64-bit pointers.  Objects always have pointers to them (otherwise it will be lost memory or an object to be deleted by the garbage collector).  In our example, the NodeFrom and NodeTo fields in the Road class will occupy 8 bytes each in a 64-bit system and 4 bytes in a 32-bit one. </li></ul><br>  Usually compilers try to create the most efficient code, however, to achieve significant performance efficiency can only software and architectural solutions. <br><br><h1>  Object arrays </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/files/aa3/fd1/5b3/aa3fd15b30fb413ebc43a87c55f24cd1.gif" alt="image"></div><br>  Data can be stored in various containers - lists, hash tables, etc.  Storage in the form of an array is probably the easiest and most understandable way, so we will focus on the consideration of this method.  Other containers can be analyzed similarly. <br><br>  In C #, arrays of objects in reality store references to objects, while each object occupies its own address space on the heap.  In this case, it is very convenient to manipulate sets of objects, since in reality you have to work with pointers, and not with the objects as a whole.  For example, in our example, the getRoads function of the RoadsContainer class transfers a set of specific objects of the Road class ‚Äî not copies of objects, but links.  This behavior occurs because objects in C # are reference data types. <br><br>  The disadvantages of storing data in the form of arrays of objects are primarily the cost of storing the pointers themselves and aligning the objects on the heap.  On 64-bit systems, each pointer takes 8 bytes of memory and each object is aligned at a multiple of 8 bytes. <br><br><h1>  Arrays of structures </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/files/834/44f/4eb/83444f4eb7084975b1572fd82aaed32b.gif" alt="image"></div><br>  Classes of storage of roads and network nodes can be converted into structures (as mentioned in our example, there are no restrictions on the part of OOP).  Instead of pointers to them, integer indices can be used.  The code that turns out can be: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> struct Road { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> Length; byte Lines ; Int32 NodeFrom; Int32 NodeTo; //   } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RoadsContainer { //    //     ,     Road[] Roads; //  ,     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int32[] getRoads(<span class="hljs-type"><span class="hljs-type">float</span></span> X1, <span class="hljs-type"><span class="hljs-type">float</span></span> Y1, <span class="hljs-type"><span class="hljs-type">float</span></span> X1, <span class="hljs-type"><span class="hljs-type">float</span></span> Y1) { //  } //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Road getRoad(Int32 <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Roads[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>]; } //    } //      //    <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> NodesContainer { //    Node []Nodes; //     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Node getNode (Int32 <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nodes[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>]; } //    }</code> </pre><br>  What did it give us?  Consider in detail. <br><br>  Road data structures are already stored as program structures (structs in C #), and not as objects.  The Roads array in the RoadsContainer class is used to store them.  To access individual structures, use the getRoad function of the same class.  The 32-bit integer index assumes the role of a pointer to the data structure of a particular road.  In the same way, nodes are transformed and a fragment of the NodesContainer node storage class is presented. <br><br>  Using a 32-bit index instead of a 64-bit pointer facilitates both the memory it uses and the manipulation of it.  Using indexes to refer to the NodeFrom and NodeTo nodes in the Road structure reduces the size of memory it uses by 8 bytes (when aligned to 32, 16, or 8 bits). <br><br>  Memory allocation (by calling the operator new) for storing roads occurs at one time.  In this case, only an array of Road structures is reserved in which all structures are created at a time.  In the case of storing references to objects, each object must be created separately.  The creation of a separate object not only takes time, but also consumes a certain amount of service memory for leveling, registering an object on the heap and the garbage collection system. <br><br>  The lack of using structures instead of objects is strictly speaking the impossibility of using pointers to a structure (structure is a type ‚Äúby value‚Äù, and a class is type ‚Äúby reference‚Äù).  This fact leads to a restriction of the ability to manipulate sets of objects.  Because of this, the getRoads function of the RoadsContainer class now returns the indices of the corresponding structures in the array.  At the same time, the structure itself can be obtained using the getRoad function.  However, this function will cause the entire structure to be returned to be copied, which will consume memory and processor time. <br><br><h1>  Primitive data arrays </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/files/dea/eeb/c81/deaeebc81b7e43dfbade4ec786fc3958.gif" alt="image"></div><br>  Arrays of structures can be converted into separate arrays of fields of this structure.  In other words, structures can be decapsulated and abolished.  For example, after decapsulating and canceling the Road structure, we get the following code: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> RoadsContainer { //    //    Road <span class="hljs-type"><span class="hljs-type">float</span></span>[] Lengths; byte[] Lines; Int32[] NodesFrom; Int32[] NodesTo; //    //  ,     <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int32[] getRoads(<span class="hljs-type"><span class="hljs-type">float</span></span> X1, <span class="hljs-type"><span class="hljs-type">float</span></span> Y1, <span class="hljs-type"><span class="hljs-type">float</span></span> X1, <span class="hljs-type"><span class="hljs-type">float</span></span> Y1) { //  } //      <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">float</span></span> getRoadLengt(Int32 <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lengths[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>]; } //       <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> byte getRoadLines(Int32 <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Lines[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>]; } //       <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int32 getRoadNodeFrom(Int32 <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodesFrom[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>]; } //       <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Int32 getRoadNodeTo(Int32 <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NodesTo[<span class="hljs-keyword"><span class="hljs-keyword">Index</span></span>]; } //    }</code> </pre><br><br>  What did we get?  Consider in detail. <br><br>  Instead of storing program structures in a single array, the fields of this structure are stored separately in different arrays.  Access to the fields is also made separately by index. <br><br>  Empty memory consumption for alignment of fields inside the structure is eliminated, since the fields of the structure of primitive types are stored close to each other.  Memory is requested from the system not by one large piece for storing all the structures at once, but in several pieces for storing the field arrays, respectively.  In a sense, such a partition is useful, since it is often easier for a system to provide several relatively small continuous chunks of memory than one large continuous chunk. <br><br>  Accessing each field requires an index each time, while accessing the entire structure requires using the index only once.  In reality, this feature can be considered both as a disadvantage and as an advantage.  The fact is that by accessing only part of the fields, for example, only three fields Lengths, NodesFrom and NodesTo of the Road structure, if they are located in separate arrays, you can get a more optimal use of the processor cache.  Using all the advantages of the cache depends on the data access algorithm, but in any case, the gain can be noticeable. <br><br><h1>  Garbage collection and memory management </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/files/158/f6c/428/158f6c428e8c41c29ef6cd640f7de1d9.gif" alt="image"></div><br>  This issue is related to memory management technologies.  After all, the speed of access to them depends on the location of objects in the memory.  Currently, there are a huge number of ways to organize memory management, including automatic garbage collection systems.  These automatic systems not only monitor the cleaning of memory, but also carry out defragmentation (like a file system). <br><br>  Memory management systems generally work with pointers to objects located on the heap.  In the case of using arrays of structures or fields, the memory management systems will not be able to work with the elements of these arrays and all the work of creating and destroying them will fall on the programmer‚Äôs shoulders.  Thus, the use of arrays of structures or fields in a certain sense deactivates the garbage collector for them.  Depending on the task, this limitation can be considered as an advantage (if resources are required) or as a disadvantage (if a programmer‚Äôs staff and labor are required). <br><br><h1>  Measurements </h1><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d7c/eb5/bf8/d7ceb5bf843741b1a7b4433758eaefb2.gif" alt="image"></div><br>  As you can see the most wasteful for storage is an array of objects.  At the same time, on a 64-bit system, storage costs increase dramatically.  Storage in the form of arrays of structures or fields as a whole is equally expensive for 32 and 64-bit mode.  Storage in the form of fields has some gain in the amount of memory taken, but this gain is not critical.  This gain includes the costs of aligning the data within the structures. <br><br><h2>  Memory </h2><br>  Occupied memory, 32 bit mode <br><div style="text-align:center;"><img src="https://habrastorage.org/files/a47/133/c6f/a47133c6f32c4b2ba4a992aa0fef54d1.gif" alt="image"></div><br><br>  Occupied memory, 64 bit mode <br><div style="text-align:center;"><img src="https://habrastorage.org/files/505/a19/96e/505a1996e88f4638a8c0cb881c3bbe3c.gif" alt="image"></div><br><br>  As you can see the most wasteful for storage is an array of objects.  At the same time, on a 64-bit system, storage costs increase dramatically.  Storage in the form of arrays of structures or fields as a whole is equally expensive for 32 and 64-bit mode.  Storage in the form of fields has some gain in the amount of memory taken, but this gain is not critical.  This gain includes the costs of aligning the data within the structures. <br><br><h2>  Access time </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ecc/ec6/51e/eccec651e48642999e742958b4107904.gif" alt="image"></div><br>  Notes: <br>  * - the number is too small in comparison with the accuracy of the test. <br><br>  The time to access data structures when stored in an array of objects shows the highest cost of time.  Also, there is a faster access to the fields if they are located in separate arrays.  This acceleration is the result of more efficient use of the processor cache.  It should be mentioned that in the test access is carried out by sequential enumeration of the elements of the array and in this case, the use of the cache is close to optimal. <br><br><h1>  Results </h1><br>  This small review allows you to create an idea of ‚Äã‚Äãthe problem and draw the first conclusions: <br><ul><li>  Failure to use OOP in working with large amounts of data can lead to 3-fold savings in RAM on 64-bit systems and 2-fold savings on 32-bit systems.  This problem arises due to the peculiarities of the hardware architecture; therefore, to one degree or another, it is relevant for all programming languages. </li><li>  The access time in C # to data structures by means of an array index is significantly less than the access time by means of a pointer. </li><li>  Raising the level of programming technology requires resources.  Low level (system level) and work with primitive data (obtained after decapsulating classes / structures) uses the least resources, but require more lines of source code and programmer time. </li><li>  The transition to working with primitive types is the stage of code optimization.  Therefore, this architecture can be used not as an initial design, but as a measure in case of need to reduce resource consumption. </li><li>  In C ++, many of the problems described can be solved transparently, while in C #, much is hidden in the underlying implementation.  In addition, when studying C #, the influence of the platform is far from being considered at first. </li><li>  When developing in C # where possible, structures should be used, not classes. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2c2/b16/9b2/2c2b169b2688439192bae646abb50d00.gif" alt="image"></div><br><br><h1>  References: </h1><br>  <a href="https://github.com/dgakh/Studies/tree/master/CSharp/Decapsulation">Sources of tests on GitHub</a> <br>  <a href="http://www.gomap.az/">An example of successful commercial use of the technique is GoMap.Az portal</a> <br>  <a href="https://msdn.microsoft.com/en-us/library/aa664655%2528v%3Dvs.71%2529.aspx">Difference Between Structures and Objects (MSDN)</a> <br>  <a href="http://www.developerfusion.com/article/84519/mastering-structs-in-c/">Good article on Mastering C # structs</a> <br>  <a href="http://habrahabr.ru/post/257091/">An article on a similar issue ‚ÄúKeep 300 Million Objects in the CLR Process‚Äù</a> </div><p>Source: <a href="https://habr.com/ru/post/264063/">https://habr.com/ru/post/264063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264047/index.html">NGFW. Part 3 - Demonstration of DDoS Protection</a></li>
<li><a href="../264049/index.html">Third extra: how we implemented mail collection using OAuth 2.0</a></li>
<li><a href="../264051/index.html">Office as Platform issue 2: Power BI - a new approach to creating business intelligence</a></li>
<li><a href="../264057/index.html">InterSystems Ensemble 2015.1 and 2015.2 release</a></li>
<li><a href="../264059/index.html">We limit the load on the server. Cheap and angry</a></li>
<li><a href="../264067/index.html">A brief history of the evolution of proof-of-work in cryptocurrencies. Part 2</a></li>
<li><a href="../264069/index.html">Quick and dirty: excel to html</a></li>
<li><a href="../264071/index.html">Check your site for getting into the Unified Register of prohibited sites in Russia</a></li>
<li><a href="../264073/index.html">Virus protection - what does NIST tell us?</a></li>
<li><a href="../264075/index.html">We use CircleCI for testing and deploying iOS applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>