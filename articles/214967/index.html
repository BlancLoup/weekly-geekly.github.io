<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Useful Open Source and how we taught Zxing to speak another language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of our articles, we talked about how you can use incoming mail features in SharePoint 2010 to receive and process documents containing scanned ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Useful Open Source and how we taught Zxing to speak another language</h1><div class="post__text post__text-html js-mediator-article">  In <a href="http://habrahabr.ru/company/eastbanctech/blog/211669/">one of our articles,</a> we talked about how you can use incoming mail features in SharePoint 2010 to receive and process documents containing scanned coupons.  In carrying out this project, we had to solve several interesting problems.  And now we want to elaborate on one point. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/041/34c/870/04134c8704e4207f42e5c677005315f8.png"><br><br>  So, one of the tasks was to recognize the numbers on the sheet of the coupons scan.  It should be noted that there may be several coupons, and they can be placed on a sheet both vertically and horizontally. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What we saw on the coupons scans strongly resembled the <a href="http://en.wikipedia.org/wiki/Codabar">Codabar</a> barcode, which we had already encountered on other projects. <br><br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/703/cf8/f01/703cf8f01d9207e578f6ece1d07314e1.png"><br>  <i>Codabar is a linear barcode.</i>  <i>Each character is encoded by 7 elements: 4 lines and 3 spaces between them.</i>  <i>Between the characters are separated by additional space.</i>  <i>Codabar starts with a start symbol, and ends with a stop symbol.</i>  <i>Start or stop symbols are, as a rule, ABCD symbols.</i>  <i>Informative: 0-9, -, $.</i> <i><br></i>  <i>Thus, for this bar code there is an alphabet, where each symbol corresponds to a specific sequence of lines and spaces.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/364/ced/746/364ced74698dc23e7cff2a588caf119c.jpg"><br>  The picture shows an example of Codabar'a, containing the value "401". <br><br><h4>  Zxing </h4><br>  When working with barcodes in .NET, we use the <a href="http://zxingnet.codeplex.com/">ported version of the Zxing library</a> .  The library is able to generate and recognize all kinds of 1D and 2D barcodes: QR-Code, PDF 417, EAN, UPC, Aztec, Data Matrix.  And most importantly, she knows how to work with Codabar.  The use of the Zxing library usually does not cause problems, we used it on different platforms.  But our bar code Zxing outright failed to recognize.  Everything turned out to be not so simple ... On closer examination, it turned out that the customer codes, although very similar to Codabar, are still different, namely: <br><br><ul><li>  have other start and stop symbols; </li><li>  each informative symbol does not consist of the standard 7 elements (4 lines and 3 spaces), but 9 (5 lines, 4 spaces); </li><li>  start and stop symbols also consist not of 7 elements, but of 3 (2 lines, 1 space). </li></ul><br>  Perhaps this format is also ‚Äústandard‚Äù, although we did not find its detailed description and information about it.  Perhaps there are library implementations for automating the recognition of this code, but we were not lucky to find them ... As a result, it was decided to try to continue working with Zxing, and do the following: take the source code and change the recognition algorithm to fit our needs. <br><br><h4>  Algorithm </h4><br>  In Zxing, each class that implements the recognition logic of a specific code (for example, CodabarReader.cs) has its own implementation of the abstract decodeRow method declared in the OneDReader.cs class. <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decodeRow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rowNumber, BitArray row, Hashtable hints</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br>  The input is the line number of the image and the array itself, containing the pixel values ‚Äã‚Äãof the row (dark - light). <br><br>  Then, using the setCounters (BitArray row) method, an array of int [] counters is initiated using the following algorithm: starting with a dark pixel, the first element of the array begins to increment until a white pixel is found in the row array.  After that, the transition to the second element of the counters array occurs, and it is also incremented until a black pixel appears.  And so on until the end of the line.  As a result, the counters array will look like <br><br>  15 7 10 3 4 8 16 ... <br><br>  Ie: 15 black pixels, 7 white, 10 black, 3 white, etc.  (the first element in this implementation corresponds to black pixels). <br><br>  Next, we look for the sequence corresponding to the start symbol (in our case, this is the ‚ÄúA‚Äù symbol, in the original Codabar, one of the ‚ÄúA‚Äù, ‚ÄúB‚Äù, ‚ÄúC‚Äù or ‚ÄúD‚Äù symbols).  We search using the findStartPattern method (out int charOffset, int globalOffset).  Until an inconsistency is found, increase the value of globalOffset (determines the current position in the image string) and go to the next character in the array counters.  In the findStartPattern method, the method is called: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toNarrowWidePattern</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset</span></span></span><span class="hljs-function">)</span></span></code> </pre><br><br>  It takes the current element number of the counters array and the length of the symbol (3 for the start or stop character; 9 for the remaining characters).  Returns -1 if the character is not found.  If the character is found, it returns this position in the CHARACTER_ENCODINGS array. <br><br><h4>  Alphabet </h4><br>  The code alphabet is defined by the following fields: <br><ul><li>  char [] ALPHABET_STRING - contains all the characters used in the code. </li><li>  int [] CHARACTER_ENCODINGS - contains a digit that defines the code sequence characteristic of each character of the code. </li></ul><br>  A few words about the values ‚Äã‚Äãstored in the CHARACTER_ENCODINGS array and generally how Codabar is encoded.  For example, the digit "0" is encoded by the following sequence of strips and spaces: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e58/676/017/e5867601780072fe2dcef451d90a42aa.png"><br><br>  This is written as follows: 101010011 (barcode encoding).  A single 0/1 encodes a short space / strip, a double 00/11 encodes a long space / strip.  Further, this sequence is converted to code 0000011 (width encoding), or in hexadecimal form: 0x03.  Those.  single characters are written as zero, double characters as one.  In our case, each character is encoded not by 7, but by 9 characters, but the logic of creating a digital code is the same. <br><br>  We had to spend some time studying the examples of coupons.  We carefully looked at the bar codes and wrote out sequences that correspond to a particular character.  The result is our own alphabet: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> String ALPHABET_STRING = <span class="hljs-string"><span class="hljs-string">"0123456789AE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] CHARACTER_ENCODINGS = { <span class="hljs-number"><span class="hljs-number">0x014</span></span>, <span class="hljs-number"><span class="hljs-number">0x101</span></span>, <span class="hljs-number"><span class="hljs-number">0x041</span></span>, <span class="hljs-number"><span class="hljs-number">0x140</span></span>, <span class="hljs-number"><span class="hljs-number">0x011</span></span>, <span class="hljs-number"><span class="hljs-number">0x110</span></span>, <span class="hljs-number"><span class="hljs-number">0x050</span></span>, <span class="hljs-number"><span class="hljs-number">0x005</span></span>, <span class="hljs-number"><span class="hljs-number">0x104</span></span>, <span class="hljs-number"><span class="hljs-number">0x044</span></span>, <span class="hljs-comment"><span class="hljs-comment">// 0-9 0x000, 0x004, // AE};</span></span></code> </pre><br><br>  So, the process of processing the code is as follows: as soon as we find the starting symbol, we are looking for information using the same method toNarrowWidePattern.  The sequence length is fixed, i.e.  at a certain step we need to check whether the stop symbol is not.  If yes, then we form the result and go to the next element of the counters array, continuing the search for bar codes in the string. <br><br>  As a result, having scanned the string, we have (or do not have) one or more codes that we save into the global array of results.  And go to the next line of the image. <br><br>  The ability to turn the image clockwise 90 degrees was also added, if you need to check the document for the presence of codes in all four positions.  In the Zxing library, the image that needs to be processed is contained in the BinaryBitmap class, which has a rotateCounterClockwise () method.  Rotate the image is not difficult. <br><br>  Thus, having thought and worked a little, we were able to modify the library for a new code format.  Who cares, the code can be found here <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BitArray = ETR.REBT.BarcodeReader.common.BitArray; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ETR.REBT.BarcodeReader.oned</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MyCodeReader</span></span> : <span class="hljs-title"><span class="hljs-title">OneDReader</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are critical for determining how permissive the decoding // will be. All stripe sizes must be within the window these define, as // compared to the average stripe size. private static readonly int MAX_ACCEPTABLE = (int)(PATTERN_MATCH_RESULT_SCALE_FACTOR * 2.0f); private static readonly int PADDING = (int)(PATTERN_MATCH_RESULT_SCALE_FACTOR * 1.5f); private static readonly int STARTEND_LENGTH = 3; private static readonly int SYMBOL_LENGTH = 9; private static readonly int DATA_LENGTH = 15; // 15 symbols + 2 start/stop symbols private static readonly int All_LENGHT = (16 + DATA_LENGTH * SYMBOL_LENGTH + 2 * STARTEND_LENGTH); private const String ALPHABET_STRING = "0123456789AE"; internal static readonly char[] ALPHABET = ALPHABET_STRING.ToCharArray(); /** * These represent the encodings of characters, as patterns of wide and narrow bars. The 7 least-significant bits of * each int correspond to the pattern of wide and narrow, with 1s representing "wide" and 0s representing narrow. */ internal static int[] CHARACTER_ENCODINGS = { 0x014, 0x101, 0x041, 0x140, 0x011, 0x110, 0x050, 0x005, 0x104, 0x044, // 0-9 0x000, 0x004, // AE }; // minimal number of characters that should be present (inclusing start and stop characters) // under normal circumstances this should be set to 3, but can be set higher // as a last-ditch attempt to reduce false positives. private const int MIN_CHARACTER_LENGTH = 3; // Start and end patterns private static readonly char[] START_ENCODING = { 'A' }; private static readonly char[] END_ENCODING = { 'E' }; private static readonly char[] DATA_ENCODING = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' }; // some codabar generator allow the codabar string to be closed by every // character. This will cause lots of false positives! // some industries use a checksum standard but this is not part of the original codabar standard // for more information see : http://www.mecsw.com/specs/codabar.html // Keep some instance variables to avoid reallocations private readonly StringBuilder decodeRowResult; private int[] counters; private int counterLength; public MyCodeReader() { decodeRowResult = new StringBuilder(40); counters = new int[500]; counterLength = 0; } override public List&lt;Result&gt; decodeRow(int rowNumber, BitArray row, Hashtable hints) { List&lt;Result&gt; returnList = null; if (!setCounters(row)) return null; int globalOffset = 0; while (globalOffset &lt; counterLength) { int startSymbolPos = -1; int startOffset = findStartPattern(out startSymbolPos, globalOffset); if (startOffset &lt; 0) return returnList; // we can't find start char in the whole row -&gt; so, exit decodeRowResult.Length = 0; decodeRowResult.Append((char)startSymbolPos); int nextStart = startOffset; nextStart += (STARTEND_LENGTH + 1/*space between symbols*/); bool findNextStart = false; do { int charOffset = toNarrowWidePattern(nextStart, SYMBOL_LENGTH); if (charOffset == -1 || !arrayContains(DATA_ENCODING, ALPHABET[charOffset])) { findNextStart = true; break; } decodeRowResult.Append((char)charOffset); nextStart += (SYMBOL_LENGTH + 1); // Stop as soon as length of data symbols equals to corresponding number if (decodeRowResult.Length == DATA_LENGTH + 1/*start symbol*/) { int endOffset = toNarrowWidePattern(nextStart, STARTEND_LENGTH); if (endOffset == -1 || !arrayContains(END_ENCODING, ALPHABET[endOffset])) { findNextStart = true; break; } globalOffset = nextStart + STARTEND_LENGTH; decodeRowResult.Append((char)endOffset); break; } } while (nextStart &lt; counterLength); // no fixed end pattern so keep on reading while data is available if (findNextStart) { globalOffset = ++startOffset; continue; } if (!validatePattern()) { globalOffset = ++startOffset; continue; } // remove stop/start characters character decodeRowResult.Remove(decodeRowResult.Length - 1, 1); decodeRowResult.Remove(0, 1); int runningCount = 0; for (int i = 0; i &lt; startOffset; i++) { runningCount += counters[i]; } float left = (float)runningCount; for (int i = startOffset; i &lt; nextStart - 1; i++) { runningCount += counters[i]; } float right = (float)runningCount; Result result = new Result( decodeRowResult.ToString(), null, new ResultPoint[] { new ResultPoint(left, (float) rowNumber), new ResultPoint(right, (float) rowNumber) }, BarcodeFormat.CODABAR); if (returnList == null) returnList = new List&lt;Result&gt;(); returnList.Add(result); } return returnList; } private bool validatePattern() { if (decodeRowResult.Length != DATA_LENGTH + 2) { return false; } // Translate character table offsets to actual characters. for (int i = 0; i &lt; decodeRowResult.Length; i++) { decodeRowResult[i] = ALPHABET[decodeRowResult[i]]; } // Ensure a valid start character char startchar = decodeRowResult[0]; if (!arrayContains(START_ENCODING, startchar)) { return false; } // Ensure a valid end character char endchar = decodeRowResult[decodeRowResult.Length - 1]; if (!arrayContains(END_ENCODING, endchar)) { return false; } // Ensure a valid data symbols for (int i = 1; i &lt; decodeRowResult.Length - 1; i++) { if (!arrayContains(DATA_ENCODING, decodeRowResult[i])) { return false; } } return true; } /// &lt;summary&gt; /// Records the size of all runs of white and black pixels, starting with white. /// This is just like recordPattern, except it records all the counters, and /// uses our builtin "counters" member for storage. /// &lt;/summary&gt; /// &lt;param name="row"&gt;row to count from&lt;/param&gt; private bool setCounters(BitArray row) { counterLength = 0; // Start from the first white bit. int i = row.getNextUnset(0); int end = row.Size; if (i &gt;= end) { return false; } bool isWhite = true; int count = 0; for (; i &lt; end; i++) { if (row[i] ^ isWhite) { // that is, exactly one is true count++; } else { counterAppend(count); count = 1; isWhite = !isWhite; } } counterAppend(count); return true; } private void counterAppend(int e) { counters[counterLength] = e; counterLength++; if (counterLength &gt;= counters.Length) { int[] temp = new int[counterLength * 2]; Array.Copy(counters, 0, temp, 0, counterLength); counters = temp; } } private int findStartPattern(out int charOffset, int globalOffset) { charOffset = -1; // // Assume that first (i = 0) set of pixels is white, // so we start find symbols from second set (i = 1). // And next we step over white set ('i += 2'). // for (int i = 1 + globalOffset; i &lt; counterLength; i += 2) { if (counters[i - 1] &lt; counters[i] * 5) // before start char must be a long space continue; charOffset = toNarrowWidePattern(i, 3); if (charOffset != -1 &amp;&amp; arrayContains(START_ENCODING, ALPHABET[charOffset])) { return i; } } return -1; } internal static bool arrayContains(char[] array, char key) { if (array != null) { foreach (char c in array) { if (c == key) { return true; } } } return false; } // Assumes that counters[position] is a bar. private int toNarrowWidePattern(int position, int offset) { int end = position + offset; if (end &gt;= counterLength) return -1; // First element is for bars, second is for spaces. int[] maxes = { 0, 0 }; int[] mins = { Int32.MaxValue, Int32.MaxValue }; int[] thresholds = { 0, 0 }; for (int i = 0; i &lt; 2; i++) { for (int j = position + i; j &lt; end; j += 2) { if (counters[j] &lt; mins[i]) { mins[i] = counters[j]; } if (counters[j] &gt; maxes[i]) { maxes[i] = counters[j]; } } double tr = ((double)mins[i] + (double)maxes[i]) / 2; thresholds[i] = (int)Math.Ceiling(tr); } // There are no big spaces in the barcode -&gt; only small spaces thresholds[1] = Int32.MaxValue; // For start and end symbols defined empirically threshold equals to 5 if (offset == STARTEND_LENGTH) thresholds[0] = 5; int bitmask = 1 &lt;&lt; offset; int pattern = 0; for (int i = 0; i &lt; offset; i++) { int barOrSpace = i &amp; 1; bitmask &gt;&gt;= 1; if (counters[position + i] &gt;= thresholds[barOrSpace]) { pattern |= bitmask; } } for (int i = 0; i &lt; CHARACTER_ENCODINGS.Length; i++) { if (CHARACTER_ENCODINGS[i] == pattern) { return i; } } return -1; } } }</span></span></code> </pre><br></div></div><br><br><h4>  Zxing Optimization </h4><br>  So, we managed to recognize one or more codes on the page.  But our problems did not end there.  Since under the conditions we may have several codes plus it is necessary to scan 4 different positions of the sheet, the algorithm has become significantly ‚Äúslowed down‚Äù.  I had to dig more, resulting in the following feature: <br>  Zxing based on the image creates an instance of the class RGBLuminanceSource.  It has an array of bytes containing information about the brightness of each pixel of the original image.  Then, based on this information and the threshold value, a bitmap is obtained. <br><br>  Here is an example of the code part of the RGBLuminanceSource class constructor: <br><br><pre> <code class="cs hljs"> Color c; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = y * width; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; width; x++) { c = bitmap.GetPixel(x, y); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = ColorUtility.GetRValue(c); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = ColorUtility.GetGValue(c); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = ColorUtility.GetBValue(c); luminances[offset + x] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">0.3</span></span> * r + <span class="hljs-number"><span class="hljs-number">0.59</span></span> * g + <span class="hljs-number"><span class="hljs-number">0.11</span></span> * b + <span class="hljs-number"><span class="hljs-number">0.01</span></span>); } }</code> </pre><br>  That is, the cycles use a slow bitmap.GetPixel (x, y) for each pixel of the image!  For small images with a resolution of 200x300 pixels (or close to that), this approach is quite appropriate and does not cause delays (considering that usually only one code is recognized).  But in our case, the image has a high resolution (up to 3000 x 5000 pixels), which should also be multiplied by the number of orientation options, and multiplied by the processing of multiple pages.  All this leads to unacceptable delays.  For example, for one page of the above resolution, an object of class RGBLuminanceSource was created in seconds for 8. This, of course, is very long. <br><br>  I had to further modify this code, forget about GetPixel and go to work on scanlins. <br><br><pre> <code class="cs hljs"> bmp = bitmap.LockBits(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Rectangle(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height), ImageLockMode.ReadOnly, bitmap.PixelFormat); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bmp.Height; y++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> row = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)bmp.Scan0 + (y * bmp.Stride); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = y * width; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; bmp.Width; x++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = row[(x * pixelSize)]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = row[(x * pixelSize) + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = row[(x * pixelSize) + <span class="hljs-number"><span class="hljs-number">2</span></span>]; luminances[offset + x] = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(<span class="hljs-number"><span class="hljs-number">0.3</span></span> * r + <span class="hljs-number"><span class="hljs-number">0.59</span></span> * g + <span class="hljs-number"><span class="hljs-number">0.11</span></span> * b + <span class="hljs-number"><span class="hljs-number">0.01</span></span>); } }</code> </pre><br>  This step greatly accelerated the algorithm and made it possible to obtain an acceptable processing time. <br><br><h4>  Work with PDF </h4><br>  As mentioned above, coupons can be scanned in the form of image files or in a PDF document.  To turn pdf pages into images we used the <a href="http://itextpdf.com/">library itextsharp</a> . <br><br>  The main class for working with this library is PdfReader.  An instance of this class can be obtained, for example, as follows: <br><br>  Look for code snippets under the spoiler. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PdfReader(filePath)</code> </pre><br><br>  After that you can use it in the code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pageNumber = <span class="hljs-number"><span class="hljs-number">1</span></span>; pageNumber &lt;= reader.NumberOfPages; pageNumber++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> page = reader.GetPageN(pageNumber); List&lt;ImageRenderInfo&gt; images; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { images = FindImageInPDFDictionary(page); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { <span class="hljs-comment"><span class="hljs-comment">//     PDF  continue; } finally { reader.ReleasePage(pageNumber); } foreach (var img in images) { var image = RenderImage(img); var result = ImageDecoder.Decode(image, allRotations); if (result != null &amp;&amp; result.Count &gt; 0) { //  ,     } } }</span></span></code> </pre><br><br>  Using this function, we search for images on the PDF page <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;ImageRenderInfo&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindImageInPDFDictionary</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PdfDictionary pg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ImageRenderInfo&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = (PdfDictionary)PdfReader.GetPdfObject(pg.Get(PdfName.RESOURCES)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xobj = (PdfDictionary)PdfReader.GetPdfObject(res.Get(PdfName.XOBJECT)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xobj == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xobj.Keys) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = xobj.Get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!obj.IsIndirect()) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tg = (PdfDictionary)PdfReader.GetPdfObject(obj); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = (PdfName)PdfReader.GetPdfObject(tg.Get(PdfName.SUBTYPE)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PdfName.IMAGE.Equals(type)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> width = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Parse(tg.Get(PdfName.WIDTH).ToString()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> height = <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.Parse(tg.Get(PdfName.HEIGHT).ToString()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (width &gt; ImageDecoder.MinimalSideResolution || height &gt;= ImageDecoder.MinimalSideResolution) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imgRi = ImageRenderInfo.CreateForXObject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Matrix(width, height), (PRIndirectReference)obj, tg); result.Add(imgRi); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PdfName.FORM.Equals(type)) { result.AddRange(FindImageInPDFDictionary(tg)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (PdfName.GROUP.Equals(type)) { result.AddRange(FindImageInPDFDictionary(tg)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  Get an object of type Bitmap from an object of class ImageRenderInfo <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Bitmap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderImage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImageRenderInfo renderInfo</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> image = renderInfo.GetImage(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dotnetImg = image.GetDrawingImage()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dotnetImg != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream()) { dotnetImg.Save(ms, ImageFormat.Png); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bitmap(dotnetImg); } } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception) { } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre><br><br>  The ImageDecoder.Decode method implements the logic of finding the code in the picture. </div></div><br><br>  It so happened that now in the world there are many varieties of barcodes.  The recognition and generation of most of them is implemented in libraries available for developers.  However, sometimes you can stumble upon the original type of barcode, which is not immediately recognizable. <br><br>  And then scrutinizing and using a well-designed open source library helps you get results quickly. </div><p>Source: <a href="https://habr.com/ru/post/214967/">https://habr.com/ru/post/214967/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../214955/index.html">Boat for DirectX-arcade. Part number 1: make contact</a></li>
<li><a href="../214959/index.html">Photobank Getty Images has opened free access to 35 million photos</a></li>
<li><a href="../214961/index.html">Satoshi Nakamoto - "I am not Dorian Nakamoto"</a></li>
<li><a href="../214963/index.html">IML TODO</a></li>
<li><a href="../214965/index.html">Cloudwash: a washing machine with Wi-Fi from the creators of Little Printer</a></li>
<li><a href="../214977/index.html">LendWings congratulates with the spring and holds the first major action!</a></li>
<li><a href="../214979/index.html">Google Earth of the Future: Almost Real-Time HD Video Survey</a></li>
<li><a href="../214981/index.html">Refund for pre-installed Windows 8. "Game" laptop from MSI. History of success</a></li>
<li><a href="../214983/index.html">Luxoft Technology Series Fifth Webinar: Kanban - An Alternative Way to Success</a></li>
<li><a href="../214987/index.html">Mars One: One way ticket to Mars. Five volunteers talk about the reasons for choosing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>