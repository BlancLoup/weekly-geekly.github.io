<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About sorting (bubble, fast, comb ...)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article focuses primarily on novice programmers. About sorting in general and the articles mentioned in the Internet title, why do we need anothe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About sorting (bubble, fast, comb ...)</h1><div class="post__text post__text-html js-mediator-article">  This article focuses primarily on novice programmers.  About sorting in general and the articles mentioned in the Internet title, why do we need another one?  For example, there is a good article here on Habr√©: <a href="http://habrahabr.ru/post/204600/">Bubble Sort and all-all-all</a> .  First of all, there is not much good, and secondly, in this article I want to answer the questions ‚Äúwhy, what, how, why‚Äù. Why do we need sorting?  First of all, for searching and presenting data.  Some tasks with unsorted data are very difficult to solve, and some are simply impossible.  Example: spelling dictionary, the words in it are sorted alphabetically.  If this were not the case, then try to find the right word in it.  Phonebook where subscribers are sorted alphabetically.  Even if sorting is not necessary and not much needed, it is still more convenient to work with sorted data. <br><br><a name="habracut"></a>  What we sort, what type of data?  We will sort the integer data in the array using comparison and exchange.  Those.  we compare m [i] and m [j] (i &lt;j) elements of the array, and if the j-th is ‚Äúless‚Äù of the i-th, then we swap them.  As a result, the array will be sorted in ascending order. <br>  <b>Note</b> : we will compare as m [j] / 10 &lt;m [i] / 10.  This is done to see how items with the same key are sorted.  With this comparison, 30 &lt;40, but 30 = 31 = 32 ... Stable (or stable sorting) does not change the order of the elements that have the same comparison keys (in our example, the comparison key is the whole part of the value of the / 10 element) <br><br>  Here is the initial (unsorted) array: <table><tbody><tr><td>  50 </td><td>  32 </td><td>  40 </td><td>  31 </td><td>  20 </td><td>  thirty </td><td>  ten </td></tr></tbody></table>  but sorted: <table><tbody><tr><td>  ten </td><td>  20 </td><td>  32 </td><td>  thirty </td><td>  31 </td><td>  40 </td><td>  50 </td></tr></tbody></table>  Note: the order of the elements 32,31,30 has changed, i.e.  sorting is not stable (not stable). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All the sortings used in the article compare a couple of elements and change them if they are not in the right order.  How are they different?  They differ in the way they select pairs of compared items. <br>  Further examples of sorting procedures in C languages.  Everywhere the first parameter is the address of the array, the second is the number of elements in the array.  The outer loop in the procedures is called the passage, and the inner loop is simply a cycle. <h4>  Simple sorting </h4>  The pass goes through all the elements of the array and in a loop compares the current element with all subsequent ones. <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sorto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *m,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// , , ...  { int tmp; for (int i=0;i&lt;n-1;++i) { //  for (int j=i+1; j&lt;n;++j) { //  if (m[j]/10&lt;m[i]/10) { // j- ,     i- tmp=m[i]; m[i]=m[j]; m[j]=tmp; } } } }</span></span></span></span></code> </pre>  Work result <table><tbody><tr><td>  ten </td><td>  20 </td><td>  32 </td><td>  31 </td><td>  thirty </td><td>  40 </td><td>  50 </td></tr></tbody></table>  The advantages of simple sorting are simple to implement and stable. <br>  Cons - it is very slow, because  there are a lot of comparison operations.  Each of the n elements is compared with all subsequent ones, so the number of comparisons is ~ n * n / 2.  If n = 100,000, then 5 billion comparisons.  True, if n = 1000, then only 500 thousand comparisons and a modern computer can do it in less than a second, so with small quantities this sorting is good. There is one important minus - if the data is almost sorted (out of 100 thousand elements only 10 are not in their places), all the same, the work time will change little, because  comparison operations will be the same. Let's try to improve the algorithm and move on to <h4>  Bubble Sort </h4>  It is also ‚ÄúBubble‚Äù and ‚ÄúBubble.‚Äù The internal loop runs over the array again and again and compares the current element with the previous one (therefore, the mileage starts from 1) and if the current one is less, rearranges it with the previous one.  The location of the permutation is stored in the variable k, and at the end of the passage in k is the index from which the array is sorted. <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *m,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp,k; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(n&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//  ,     k=0; //   for (int i=1; i&lt;n;++i) { if(m[i]/10&lt;m[i-1]/10) { tmp=m[i-1]; m[i-1]=m[i]; m[i]=tmp; k=i; //       } } n=k; //  k   } }</span></span></code> </pre>  In the worst case (when the source array is sorted in the reverse order, the same n * n / 2 comparisons are obtained. But in the best or in the good one? ‚Äù? The best case is when the array is completely otorotirovan. Then nothing will be rearranged in the first pass, in n will be assigned to the end of the pass 0 (k = 0) and there will be no second pass. Instead of 100 thousand passes, only 1 is great, but what if the array is sorted but not completely. For example, rearrange the minimum and maximum elements in the sorted array and sort this " problematic array (remember that 30  32 have the same key): <table><tbody><tr><td>  50 </td><td>  20 </td><td>  32 </td><td>  31 </td><td>  thirty </td><td>  40 </td><td>  ten </td></tr></tbody></table>  In the first step of passage 1, ‚Äú20‚Äù is compared with ‚Äú50‚Äù and is exchanged.  At the next step, "32" is compared again with "50" (after all, he now took the place of "20." As a result, at the end of the first pass, "50" will take place at the end, and the rest will move 1 position to the beginning of the array. And what will happen from ‚Äú10", which was at the end? It will also move to position 1 to the beginning. If you imagine that the starting positions are at the top and the end ones at the bottom, "at the bottom", then as a result of the passage the heaviest will be at the bottom, and the easiest " will emerge "by one position. In one of the articles, heavy elements are called" hares "and light elements are called" turtles. "  The ode ‚Äúhare‚Äù quickly runs to the end (or drowns) until it meets a more weighty hare (which will take the baton and run further) or until it takes its place. And the lighter elements pop up one position. If the lightest takes the nth position , then you need n passes to get to its place. The heaviest (‚Äúpellet‚Äù) quickly sinks in one pass, and the easiest (‚Äúbubble‚Äù) pops up slowly. The bubble that floats the longest and determines the total number of passages.  If the easiest is at the end of the array, you need as many passes as there are elements in the array. <br><br>  What to do with the "turtles" so that they do not interfere so much.  Comes to the rescue <h4>  Shaker sorting </h4>  <b>Why do heavy elements sink quickly in bubble sorting, and light ones emerge slowly</b> ?  Because the comparison cycle advances from the beginning of the array to the end and "drags" heavy elements with it.  And if you move from the end to the beginning, then the lungs will begin to emerge quickly, and the heavy ones will slowly sink.  The easiest one pass will move from the end to the beginning.  Shaker sorting on even passages moves from the beginning to the end, and on odd sets, our problem array will also be sorted out in 3 passes.  For a nearly sorted array, shaker sorting can be much faster than a bubble, but for a randomly sorted source array, the gain is usually not very large. <br><h4>  Hairbrush sorting </h4>  Or comb.  Again, ask <b>why the bubble slowly pops up?</b>  Because for the passage it moves to 1 position.  Why does he move only 1 position?  Because the neighboring elements are compared and rearranged.  So let's compare not neighboring elements, but those located at a distance s (gradually decreasing s with each pass).  Implementing this idea in practice, we come to sorting the comb. <pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sortc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *m,</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp,k; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s=n; <span class="hljs-comment"><span class="hljs-comment">//    long long cnt=0; while(n&gt;1) { s/=1.247f; //    .      80%   , //         20% if (s&lt;1) s=1; // 0   ,  1 k=0; //   for (int i=0; i+s&lt;n;++i) { // ,    ( s  )   if(m[i]/10&gt;m[i+s]/10) { tmp=m[i]; m[i]=m[i+s]; m[i+s]=tmp; k=i; } ++cnt; } if (s==1) //  1,    .   n=k+1; } }</span></span></code> </pre>  The idea is simple and the algorithm is not complicated, but the result is impressive.  Sorting hair comb turns out to be much faster than a bubble / shaker, it can even outrun the ‚Äúfast‚Äù qsort sorting.  But there is also a minus - it is not stable (which is intuitive). <h4>  Quick sort qsort </h4>  The quick sort function of our array is very simple: <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   qsort int fcomp(const void *i, const void *j) { return (*(int *)i)/10 - (*(int *)j)/10; } void sortq(int *m,int n) { qsort(m,n,sizeof(int),&amp;fcomp); }</span></span></code> </pre>  It is simple because it uses the standard qsort quick sort.  Let's look again at the above algorithms.  In all, pairs of elements m [i] and m [j] are selected and compared.  But what is m [i]?  This is the i-th element in the array of integers m or "element located at the address Ai = m + i * &lt;sizeof (int)&gt;".  Accordingly, the j-th element is located at the address Aj = m + j * &lt;sizeof (int)&gt;.  So, we compare elements by addresses Ai and Aj and rearrange them if Aj &lt;Ai (less in the sense of some comparison operation that we use).  So, the qsort function is a kind of "sorting combine" that selects, compares and swaps elements from our array (which we pass to it by the first parameter).  Naturally, you need to know the number of elements in the array and it is passed by the second parameter.  How does qsort determine where the i-th element is?  Very simple - by adding to the address of the array i * &lt;element size in bytes&gt;.  This &lt;size in bytes&gt; is passed in the third parameter.  Good, but how does qsort compare the elements, because we have a clever way to compare?  It does not compare itself; it uses our comparison function fcomp, whose address is passed in 4 parameters.  When qsort decides by its internal algorithm that it is necessary to compare i and j-th elements, it will transmit their addresses as 1 and 2 parameters of the function fcomp, which returns the comparison result &lt;0, = 0,&gt; 0, depending on whether the first the second parameter is equal to it or more.  If qsort sees that i &lt;j but fcomp (&amp; m [i], &amp; m [j])&gt; 0, she will simply rearrange the elements in the array (she knows the size of the element, but the contents are not important to her). <h4>  Sorting time 100001 element </h4>  Let's measure the sorting time for an array containing 100001 elements on a computer with an Intel i5 processor (3.3GHz). The time is indicated in seconds, the fraction indicates the number of passes (for quick sorting it is unknown). As expected, the shaker sorting on the problem array (which is completely ordered, only the first and last elements are rearranged) the absolute leader.  She is perfectly "sharpened" for this data.  But on random data sorting comb and qsort do not leave opponents a chance.  Bubble sorting on the problem array shows a twofold increase in speed compared to a random one simply because the number of permutation operations is orders of magnitude smaller. <table><tbody><tr><th>  Sorting </th><th>  Simple </th><th>  Bubble </th><th>  Shaker </th><th>  Comb </th><th>  Fast (qsort) </th></tr><tr><td>  Stable </td><td>  + </td><td>  + </td><td>  + </td><td>  - </td><td>  - </td></tr><tr><td>  Random </td><td>  23.1 / 100000 </td><td>  29.1 / 99585 </td><td>  19.8 / 50074 </td><td>  0.020 / 49 </td><td>  0.055 </td></tr><tr><td>  Problem </td><td>  11.5 / 100000 </td><td>  12.9 / 100000 </td><td>  <b>0.002 / 3</b> </td><td>  0.015/48 </td><td>  0.035 </td></tr><tr><td>  Back </td><td>  18.3 / 100000 </td><td>  21.1 / 100000 </td><td>  21.1 / 100001 </td><td>  0.026 / 48 </td><td>  0.037 </td></tr></tbody></table><br><br>  And now we will return to the sources, to bubble sorting and take a look at the sorting process.  See how on the first pass the heavy element (50) moves to the end? <br><img src="https://habrastorage.org/files/163/216/d2a/163216d2ae714cd7b261ec3590687caa.gif"><br>  Compared elements are shown in green frames, and swapped elements are shown in red <h4>  Supplement after publication </h4>  I do not consider qsort bad or slow by any means - it is fast enough, functional and should be used with it if possible.  Yes, she has to spend time calling the comparison function and she yielded to a ‚Äúcomb‚Äù that compares ‚Äúin place.‚Äù  <b>This lag is insignificant</b> (compare with the lag of the bubble from qsort, which will increase with the growth of the array).  Let now it is necessary to compare not numbers, but some complex structure on a certain field and let this structure consist of 1000 bytes.  Put 100k elements in the array (100mb is something) and call qsort.  The fcomp function (comparator function) compares the required fields and the result is a sorted array.  In this case, when rearranging qsort elements, you will have to copy fragments of 1000 bytes 3 times.  And now ‚Äúa little trick‚Äù - we will create an array of 100 thousand references to the original elements and pass the beginning of this array of references to qsort.  Since the link is 4 bytes (64 bit 8), and not 1000, then when exchanging qsort links, you need to change these 4/8 bytes.  Of course, you will need to change fcomp, because as parameters it will now receive not element addresses, but element addresses (but this is a simple change).  But now you can make several sorting functions (each sorts structures by its field).  And even, if necessary, you can make several arrays of links.  Here are the possibilities qsort gives! <br><br>  By the way: the use of references to objects instead of the objects themselves can be useful not only when calling qsort, but also when using containers such as vector, set or map. <h4>  Number of comparisons and exchanges </h4>  The following table shows the number of comparisons / number of exchanges for each sort.  For qsort, the number of exchanges is unknown, so only the number of comparisons is shown.  It can be seen that for a random array the number of comparisons is minimal for qsort. <table><tbody><tr><th>  Sorting </th><th>  Simple </th><th>  Bubble </th><th>  Shaker </th><th>  Comb </th><th>  Fast (qsort) </th></tr><tr><td>  Random </td><td>  5'000'050'000 / 1'131'715'503 </td><td>  4'999'702'086 / 2'507'142'238 </td><td>  3'341'739'679 / 2'507'142'238 </td><td>  4'489'129 / 714'533 </td><td>  1'915'414 </td></tr><tr><td>  Problem </td><td>  5'000'050'000 / 199'999 </td><td>  5'000'050'000 / 199'999 </td><td>  299'997 / 199'999 </td><td>  4'395'305 / 91'829 </td><td>  1'588'741 </td></tr><tr><td>  Back </td><td>  5'000'050'000 / 5'000'050'000 </td><td>  5'000'050'000 / 5'000'050'000 </td><td>  5'000'050'000 / 5'000'050'000 </td><td>  4'395'305 / 233'210 </td><td>  1'588'741 </td></tr></tbody></table><br><br></div><p>Source: <a href="https://habr.com/ru/post/357640/">https://habr.com/ru/post/357640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357630/index.html">Tagsistant: semantic file system</a></li>
<li><a href="../357632/index.html">Run the application for Android (from personal experience)</a></li>
<li><a href="../357634/index.html">We launch the application for Android Part 2 - finance, promotion (from personal experience)</a></li>
<li><a href="../357636/index.html">Android Studio 2.0 development environment released (preview)</a></li>
<li><a href="../357638/index.html">Obama recognized computer science as essential for fundamental education.</a></li>
<li><a href="../357642/index.html">Portgen - bypassing port filtering</a></li>
<li><a href="../357644/index.html">Programming as visual arts</a></li>
<li><a href="../357646/index.html">OS X developers are more popular than Linux - and other statistics with Stack Overflow</a></li>
<li><a href="../357648/index.html">Introduction to writing tests and familiarity with xUnit</a></li>
<li><a href="../357650/index.html">Jennifer Zero and other bad surnames</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>