<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why programming is a good way to express incomprehensible and vaguely formulated ideas.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the preface to the first edition of the remarkable book ‚ÄúStructure and Interpretation of Computer Programs‚Äù (SICP) by Harold Abelson and Gerald J S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why programming is a good way to express incomprehensible and vaguely formulated ideas.</h1><div class="post__text post__text-html js-mediator-article">  In the preface to the first edition of the remarkable book ‚ÄúStructure and Interpretation of Computer Programs‚Äù (SICP) by Harold Abelson and Gerald J Sassman, there is a quote from Marvin Minsky‚Äôs article ‚ÄúWhy programming is a good way of expressing obscure and hazy ideas.‚Äù The quote is short and full I did not come across a publication in Russian. <br>  Below you can read the translation of this article, and although it was written for a long time, it is still interesting to get acquainted with the thoughts of such a person as Marvin Minsky, the original article can be found <a href="http://web.media.mit.edu/~minsky/papers/Why%2520programming%2520is--.html">here</a> . <br><a name="habracut"></a><br>  This article is a slightly edited version of a chapter published in Design and Planning II - Computers in Design and Communication (Martin Krampen and Peter Seitz, eds.), Visual Committee Books , Hastings House Publishers, New York, 1967.) <br><br><blockquote>  There is a generally accepted and widespread view that computers can only do what they have been programmed for.  This false proposition is based on the confusion that exists between form and content.  Strict grammar does not mean a rigorous description of the process.  The programmer must be very accurate, following the rules of computer grammar, but the content that he wants to express using these rules remains free and is not limited by anything.  And the severity of grammar is not due to the computer, but to the programmer who uses it.  A programmer doesn‚Äôt even have to be very precise in formulating his own ideas: he can have a certain range of valid computer answers in his mind, and it‚Äôs enough that computer answers do not go beyond that range.  The programmer does not need to limit the computer to specific processes.  Under the weight of doubts, he may ask the computer to generate new processes, or he may suggest certain rules of choice and ‚Äúadvise‚Äù the computer what choice to make.  Thus, computers do not need to be programmed, too clearly and clearly formulating what needs to be done and how exactly it should be done. </blockquote><br>  The reasoning here is not so much about ‚Äúdesign,‚Äù but about how computers can help us in our work.  For a variety of reasons, people usually underestimate these opportunities.  To begin with, I would like to warn about one mistake: do not, like many, who believe that he fully understands the situation, take a ‚Äúmoderate‚Äù position.  Science fiction writers, scientists of all stripes, economists, analysts, psychologists, and even logicians often repeat, trying to convince everyone that computers can never truly think.  "You should not assume that machines can think like people: they can only do what the program contains, they cannot be original and creative."  We have all heard something similar and most of us agree with this point of view. <br><br>  It is easy to understand why humanities scholars love to rant about the obscure nature of the thinking process, because from this it is easy to make a false conclusion about the connection of such ambiguity with the unique nature of human thinking.  But the conclusion itself is not important.  The whole fallacy of this discussion lies in the widespread conviction that it is impossible to write a computer program that would do something that goes beyond a very clearly stated task, a clear statement of what should be done, and how it should be done.  This belief is widely promoted by both scientists (and even ‚Äúcomputer scientists‚Äù) and the humanities. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Everything that we are told about the limitedness of computers usually takes such general forms: ‚ÄúThe computer cannot create.  He can only do what he was told.  If the process is not formulated very accurately, the computer will not be able to carry it out. ‚Äù  In a sense, this is correct, in the other - absolutely false.  Before explaining why, it is interesting to note that long before the advent of computers, the same thing was said about the Devil: he is the only one who could be a creator. <br><br>  In September 1966, the issue of Scientific American magazine I discussed three programs: Arthur Samuel's program for playing checkers at the master level;  the program of Thomas Evans ANALOGY, which allowed at a fairly good level to solve the problem of assessing intelligence using the recognition of analogies between geometric figures, and the program D. Borborwa STUDENT to solve high-grade algebraic problems expressed in informal language: <br><br> <code>  ,   ,     ,   .    24 ,   ?</code> <br> <br>  This program solves some problems, but not all.  In that article I set the task to go further, to continue work in the direction of a more diversified intellectual development.  However, for my purposes, even in their current state, these programs can serve as an excellent example: although they work with an extremely limited number of tasks, they are already doing enough to destroy this old myth that is convenient for all. <br><br>  The old point of view says that a program is ‚Äúonly‚Äù a set of strict rules that clearly indicate what to do in each specific situation.  This is a really useful point of view for convincing novices in programming or for analyzing programs written by novices.  However, for more complex processes (although in a certain sense this is ‚Äúabsolutely‚Äù true), it will also be correct to say that ‚Äúat home are just constructions made of building materials‚Äù or ‚Äúbooks are just long chains of words‚Äù.  And the truth is: a review of my article in Scientific American, made in Computer Reviews 8, 1, January 1967, states that these programs consist of ‚Äúdictionary searches, a sequence of search and comparison functions, and sorting and merging operations‚Äù . <br><br><h5>  LOGIC AND SYSTEM </h5><br>  Let's begin by discussing a single statement based on the opinions of good logicians and philosophers.  We are told that some theorems for proving sequential logical systems have the effect: "It is impossible to completely mechanize the discovery process, therefore people will always have an advantage over machines."  I am sure that almost every reader has heard about the G√∂del theorem.  Most have also heard of the proposed conclusion.  But this is not a logical conclusion, since it is based on careless technical observations.  If it is generally applicable to problem solving, G√∂del‚Äôs theorem is applicable exclusively to consistent logical systems.  People are not so consistent, so there is no reason for us to feel any embarrassment and limit ourselves to creating machines according to such principles.  Instead, we can create machines that could allow a contradiction of actual judgments, which is already being done.  To do this, add a set of rules for resolving contradictions, a scale of priorities for choosing from conflicting judgments, etc.  A simple example of such a scheme is described in Bertram Raphael‚Äôs doctoral dissertation, which he defended at the Massachusetts Institute of Technology in 1964.  Here is an example of a dialogue with such a program: <br><br><pre>  ÔÉΩ EVERY BOY - PERSON 
 (I UNDERSTAND)
 ÔÉΩ FINGER - PART OF THE HAND
 (I UNDERSTAND)
 ÔÉΩ EVERYONE HAS TWO HANDS
 (THIS PROPOSAL IS DOUBLICALLY. REFRAIN IT)
 ÔÉΩ THERE ARE TWO HANDS ON EACH HUMAN
 (I UNDERSTAND)
 ÔÉΩ HOW MANY FINGERS DOES JOHN?
 (I DON'T KNOW, IS IT A FINGER'S PART OF JOHN)
 ÔÉΩ JOHN - BOY
 (I UNDERSTAND)
 ÔÉΩ HOW MANY FINGERS DOES JOHN?
 (HOW MANY FINGERS ON HAND)
 ÔÉΩ ON EVERY HAND 5 FINGERS
 (I UNDERSTAND)
 ÔÉΩ HOW MANY FINGERS DOES JOHN?
 (ANSWER - 10)
 ÔÉΩ HOW MANY MACHINES DOES JOHN?
 (THIS PROPOSAL IS DOUBLICALLY. REFRAIN IT)
 ÔÉΩ WHO PRESIDENT USA?
 (FORM OF JUDGMENT NOT RECOGNIZED)
 ÔÉΩ BOY ONLY WHICH DID OUT FOR THE TABLE
 (G02840 - TABLE)
 (I UNDERSTAND)
 ÔÉΩ LAMP - LEFT OF TABLE
 (G02841 - LAMP)
 (THE ABOVE CONSTITUTION ARE NOT IMPOSSIBLE)
 ÔÉΩ TABLE - RIGHT FROM THE CHAIR
 (G02842 - CHAIR)
 (I UNDERSTAND)
 ÔÉΩ WHAT IS THE RELATIVE POSITION OF MAN?
 (ORDER LEFT RIGHT TO SUCH)
 (CHAIR - BOY - TABLE) </pre><br>  The system of collecting knowledge and answering questions from Raphael shows how individual facts are given top priority if they conflict with general principles.  Of course, this ‚Äúexclusion principle‚Äù is a very simplified way of resolving contradictions, which can only be used in cases where there is a clear difference between judgments in terms of the level of generality.  If they are on the same level, the program simply rejects a later judgment, as can be seen in this example: <br><br><pre>  ÔÉΩ ON EVERY HAND ON 5 FINGERS
 (I UNDERSTAND)
 ÔÉΩ MAN HAS TWO HANDS 
 (I UNDERSTAND)
 ÔÉΩ BOY - MAN 
 (I UNDERSTAND)
 ÔÉΩ TOM - BOY
 (I UNDERSTAND)
 ÔÉΩ DICK - BOY 
 (I UNDERSTAND)
 ÔÉΩ HARRY - BOY 
 (I UNDERSTAND)
 ÔÉΩ Tom Had Nine Fingers
 (THIS CONSIDERATION IS TWENTURALLY, BUT I ASSUME (HAS) MEAN (HAS AS PART))
 (I UNDERSTAND)
 ÔÉΩ DICK HAS ONE HAND
 (THIS CONSIDERATION IS TWENTURALLY, BUT I ASSUME (HAS) MEAN (HAS AS PART))
 (I UNDERSTAND)
 ÔÉΩ HOW MANY FINGERS A TOMA?
 (ANSWER - 9)
 ÔÉΩ HOW MANY FINGERS A DICK?
 (ANSWER - 5) 
 ÔÉΩ HOW MANY FINGERS HARRY?
 (ANSWER - 10) 
 ÔÉΩ HOW MANY FINGERS DO JO?
 (I DON'T KNOW IS THE FINGER A PART OF JOE) </pre><br>  Of course, Rafael could have written another priority assignment rule.  By the way, the judgment in the program ‚ÄúThis sentence is ambiguous ...‚Äù refers to the possibility that the word ‚Äúhas‚Äù can mean either ‚Äúhas as a part‚Äù or ‚Äúowns‚Äù.  The Raphael program usually makes correct assumptions about the study of objects that are already known to possess certain things or are part of certain things, etc.  Next, I will describe this in more detail.  Rafael clearly showed that such ‚Äúcontextual‚Äù solutions can be programmed by illustrating a more general idea or, rather, by showing a different and more sensible look at programs instead of the previously existing ‚Äúonly‚Äù approach.  Therefore, we will try to explain some of the best ways to talk about programs. <br><br><h5>  (1) PROGRAM AS A SEQUENCE OF INSTRUCTIONS TO BE FOLLOWED. </h5><br>  The most common and simple point of view: a computer program is a sequence of clear operations that are performed on the basis of certain data.  Take a simple example of a program: Suppose that X is a number given as input information: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">START</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> R = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> S = X/R <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> T=R+S <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> R = T/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> U = R x R <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> V = X - U <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> |V| &gt; <span class="hljs-number"><span class="hljs-number">.001</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> PRINT V</code> </pre> <br>  This program, attributed to Isaac Newton, calculates the approximate value of the square root of X. In each line of the program it is absolutely clear what the current state of affairs is and what comes next.  Of course, we need a mathematical analysis to prove that the sequence of such situations will soon lead to a valid value of R and the end of all calculations.  Therefore, there will be no harm if you consider these judgments as a sequence of steps.  The ‚ÄúGO TO‚Äù command can be considered a very short version of several copies of the ‚Äúmain loop‚Äù.  Of course, until the analysis is completed, the program can be considered an expression of a useful, but unintelligible idea. <br><br><h5>  (2) PROGRAM AS A COURT </h5><br>  In the program of Raphael, it is necessary to decide whether the word ‚Äúhas‚Äù means ‚Äúowns‚Äù or ‚Äúhas as part‚Äù if we are talking about a judgment in the form ‚Äúx has y‚Äù: <br><br><pre>  ÔÉΩ JOHN - MAN
 (I UNDERSTAND)
 ÔÉΩ DICK - MAN
 (I UNDERSTAND)
 ÔÉΩ CHAIN ‚Äã‚Äã- PART OF BIKE
 (I UNDERSTAND)
 ÔÉΩ PETROL HAS A CIRCUIT
 (THIS CONSIDERATION IS TWENTURALLY, BUT I ASSUME (HAS) MEAN (HAS AS PART))
 (I UNDERSTAND)
 ÔÉΩ JOHN HAS A CHAIN 
 (I UNDERSTAND)
 ÔÉΩ DICK HAS A CHAIR
 (THIS CONSIDERATION IS TWENTURALLY, BUT I ASSUME (HAS) MEAN (HAS AS PART))
  CUCKOO HOURS HAVE A CIRCUIT
 (THIS PROPOSAL IS DOUBLISHLY. REFORM IT) </pre><br>  The task, as soon as it is expressed, is transferred to the part of the program that can conduct a review of everything that has already happened before.  Such a subprogramme decides on the following basis: <br><ol><li>  Is it known that y is part of some other object?  Or is u a member of some group that is part of something? </li><li>  Is it known that u belongs to someone or is a member of some group that belongs to someone? </li><li>  If one of the provisions (1) or (2) is correct, make the appropriate choice.  If none of the options apply, stop and collect additional information.  If both statements are true, consider the options in clause (4).  (Thus, the program uses evidence of how previously obtained information was included in the ‚Äúmodel‚Äù of the world.) </li><li>  If you have reached this point, it means that u is already part of something and already belongs to someone.  We need a more accurate test. </li></ol><br>  Let U1 and U2 be ‚Äúsomething‚Äù or ‚Äúsome kind of system), existing respectively in the answers to questions (1) and (2).  They depend on y.  Now we ask: is x a member or subject of U1 and U2?  If none of the options fit, stop.  If one of the options is correct, select the appropriate result - ‚Äúpart‚Äù or ‚Äúbelongs‚Äù.  If both options are correct, stop and collect more information.  Rafael says: <br><br><blockquote>  ‚ÄúThese criteria are very simple, but they are enough to allow the program to make fairly reasonable decisions with a specific goal in various sentences with the ambiguous word‚Äú has. ‚Äù  Of course, the program can be made to make a mistake, for example, in the case of the sentence ‚ÄúDick has a chain‚Äù, which stands before the sentence ‚ÄúJohn has a chain‚Äù in the above dialogue.  However, when a person encounters a new world in a similar situation, he will certainly make a similar mistake.  The fact is that it is possible to solve the problem of ambiguity in a sentence with the help of the description of words in sentence-descriptions, which can be created automatically through previously given unambiguous sentences ‚Äù. </blockquote><br>  Thus, the program is designed to try to search for previously collected information and find out how x and y are related and whether they are related at all.  This "part" of the program can be perceived as a kind of small court or as the collection and analysis of evidence and testimony.  You should not take it as a straightforward procedure in the framework of a previously defined sequence of solving the problem.  It is, rather, an appellate court, which can prompt when the program has encountered inconsistency or ambiguity.  Now, when we will write a large program with a large number of similar courts, each of which, if necessary, can call others for help, it is absolutely pointless to consider the program a ‚Äúsequence‚Äù.  Even if the programmer himself formulated ‚Äúlegitimate‚Äù principles allowing such ‚Äúappeals‚Äù, he may not fully understand when and where in the course of the program such processes will require interaction with each other.  As for a single ‚Äúcourt‚Äù, he has only fragmentary ideas about certain circumstances that can lead to such an interaction.  In short, having passed the beginner level, programmers do not just write a "sequence of instructions."  They write for individual cases from small groups or processes.  But we rarely enough can fully imagine in advance all the details of their interaction.  In the end, that‚Äôs what computers are needed for. <br><br><h5>  (3) PROGRAM AS A COLLECTION OF TIPS </h5><br>  There is a misconception that is shared not only by the frightened humanities, but also by the majority of computer ‚Äúspecialists‚Äù, it says that programming is essentially an accurate and precise operating environment based on the elementary confusion between form and content.  If the poets were asked to write fourteen lines of stanzas, this would not make the process more accurate;  if the composers were to use all twelve degrees of the scale, it would not limit the form as a whole;  if designers had to use only fourth-order surfaces, no one would even notice!  Thus, it is simply ridiculous to observe such unanimity in disputes that strict grammar of (old) programming languages ‚Äã‚Äãcontributes to accuracy in the description of processes.  Indeed, one must very carefully follow the rules of computer grammar (syntax) in order for the program to work at all.  No spelling or punctuation errors are allowed!  But it is wrong to say that this will help you to clearly understand what your program will do.  In FORTRAN, if you want your program to refer to an already written process, you need to use one of the fixed commands ‚ÄúGO‚Äù (‚ÄúGO TO‚Äù).  You cannot say ‚ÄúUSE‚Äù or ‚ÄúPROCEED ON TO‚Äù, etc.  The syntax in this case is very strict.  But you can ‚ÄúGO‚Äù to almost anything, so the content remains free. <br><br>  It is even more wrong to assume that such severity is due to the computer!  It is caused by programmers who have defined the language!  In Bobrov's STUDENT program, if you like, you can enter ‚ÄúUSE (‚Äú USE ‚Äû) ALWAYS MEAN TO GO (‚Äú GO TO ‚Äù)‚Äù once and for all, and in simple situations you can use ‚ÄúUSE‚Äù instead of ‚ÄúGO‚Äù.  Of course, this is a simple example of flexibility, but most people do not accept this thought: the severity and clarity of the FORTRAN language, if it exists, is due to strict prejudice, and not the severity of facts! <br><br>  As an example of a modern and more flexible system, take the programming language PILOT, developed by Warren Teitelman (doctoral dissertation at the Michigan Institute of Technology, 1966), allows the programmer to make changes to his program and to the language itself using external operators in the language (current version ).      ¬´¬ª,   ¬´¬ª, ..                  . <b>    </b> ,            ¬´   ¬ª,       ,  ..: <br><br> <code>  ,  m ‚Äì  -1,  c ‚Äì  -2  (- m)  (- c ),  . (              .)</code> <br> <br>     ,        ,    ,     .     . ,    ,   ¬´¬ª  ¬´      ,   ,           ¬ª.   : <br><blockquote>       ¬´¬ª.     , ,       ,   ‚Äì  ,       3  0.      . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the point is not to reduce syntactic restrictions. The point is in the ‚Äúadvisory‚Äù nature of the changes made to the program. The judgment about ‚Äúmoving forward‚Äù can be expressed without knowing how this ‚Äúpromotion‚Äù is carried out and where exactly it is in the ‚Äúprogram‚Äù. The situation may change under the action of another council, and you can not even imagine when the new council will be used, and when it simply will not be paid attention. Under the influence of the councils, a completely different function may change, in some situations there will be no ‚Äúadvancement‚Äù at all and someone may be eaten anyway. If this happens, you will need to try to understand why.</font></font><br><br>     (1)       ¬´¬ª   (2)   -  ,         ,         ,   .      ,     .             ,  .   ,    ,   ,       . <br><br>       . ,                ,     .             ,             ,   .    ,       . (,       ,      ,       !)        ¬´   ,    ¬ª.      . <br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FREEDOM OF EXPRESSION AND RESTRICTION OF IDEAS </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we come to the question of what to do, when we need to write a program, but at the same time we do not fully understand what needs to be done and how. </font><font style="vertical-align: inherit;">A false conclusion that only keeps everyone away from solving a problem is very simple:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Main premise: If I write a program, it will do something private, as each program performs something specific. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Small prerequisite: My idea is unclear. </font><font style="vertical-align: inherit;">I have no definite result in my head.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusion: Therefore, the program will not do what I want. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, everyone thinks that programs cannot express fuzzy ideas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, there are two misconceptions. First, it is not enough to say that you do not have a clear result in your head. You have a set of poorly defined acceptable functional characteristics (operations). You will be happy if the machine can perform tasks in this range. The wider the range, the wider the freedom of the program‚Äôs tasks. It is not necessary to nullify everything: even if someone writes certain words or instructions, the other still has the right to consider this program a separate example. In this sense, a separate written history can be considered a special case of a concept that is still not clearly expressed in the mind of the author.</font></font><br><br>        .  -   .    ,      .            ,   ,  , ¬´¬ª  ¬´¬ª    ..  ,                             . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here you can argue for the last time: is it within this framework? Remember, I am not saying that programming is an easy way to express poorly worded ideas! To take full advantage of the amazing flexibility of this tool, huge technical, intellectual and aesthetic skills are needed. It is very difficult to drive the behavior of the program into some specific framework. Similarly, a writer needs certain skills to express a certain degree of ambiguity. A computer is like a violin. You can imagine a beginner, who first tried the player and only then - the violin. And the sound of the latter, in his opinion, is terrible. This is the argument we have heard from humanities and many specialists in the field of computer science and computer technology. They think that computer programs are good enoughbut not flexible enough. The same can be said about the violin and the typewriter, until you learned how to use them.</font></font></div><p>Source: <a href="https://habr.com/ru/post/148584/">https://habr.com/ru/post/148584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148574/index.html">Convert Zend config from ini to yaml. Underwater rocks</a></li>
<li><a href="../148576/index.html">Botiful - miniature telepresence robot</a></li>
<li><a href="../148580/index.html">How Warcraft 3 helped me learn a couple of yap</a></li>
<li><a href="../148581/index.html">Tor will pay operators exit points</a></li>
<li><a href="../148583/index.html">Happy holiday, dear sysadmins</a></li>
<li><a href="../148585/index.html">Autonomous router for 4G Megaphone</a></li>
<li><a href="../148587/index.html">Second dotcom bubble or new era?</a></li>
<li><a href="../148588/index.html">IT R & D Cream (Issue 18) - Old Mop</a></li>
<li><a href="../148590/index.html">First base station and first call</a></li>
<li><a href="../148591/index.html">Constantly falls off the Flash Plugin in Google Chrome? There is a solution!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>