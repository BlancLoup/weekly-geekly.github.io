<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We program 1C on Ruby</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The thick client 1C OLE control mechanism gives you full access to all functions and data. This makes it possible with the customization of 1C or its ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We program 1C on Ruby</h1><div class="post__text post__text-html js-mediator-article">  The thick client 1C OLE control mechanism gives you full access to all functions and data.  This makes it possible with the customization of 1C or its integration with external systems not to use the built-in programming language at all and, accordingly, not to limit itself to its syntax, capabilities and execution environment. <br><br>  Instead, you can use any modern language that has a library for working with Win32 OLE.  For example, JavaScript (Win32 OLE supports Node.JS) or Ruby (the required library is included in the set of standard language libraries). <br><br>  Below will be described some practical experience with the OLE-interface on Ruby.  The description does not pretend to be complete, only what is needed for simple automation or integration at the data level is selected and described: reading and writing of directories and documents, execution of queries. <br><a name="habracut"></a><br><h4>  What for? </h4><br>  1C uses a huge number of Russian enterprises, and most of them feel the need to change something in their 1C or integrate it with something.  At the same time, I often want it to be quick and cheap. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To do this, 1C has regular features: <br><br><ul><li>  Changing the data structure of the system by changing its configuration using the configurator. </li><li>  Changing the logic of the system through software modules as part of the configuration or external "processing". </li><li>  Interaction with the "fat client" of the system at the user's workplace through the interface of OLE or COM. </li></ul><br>  But here, as always, there are some "but". <br><br>  First of all, I really don‚Äôt want to change the configuration, because it seems that for this it will have to be removed from support and later it will be difficult to update. <br><br>  Secondly, I really do not want to learn the 1C programming language to solve a couple of particular tasks because of its uselessness and hopelessness somewhere outside 1C. <br><br>  And here OLE-access helps a lot, which, as it turned out, allows the 1C client to do almost everything that a user sitting at a computer can do (and even a bit more), and this OLE-access works fine from Ruby through the standard library win32ole. <br><br>  There are many songs about Ruby that can not be repeated.  This is a beautiful, convenient and promising developing language with a great ecosystem, low entry threshold, a huge variety of open libraries, frameworks, products, etc. <br><br>  And from it it turns out a powerful tool 1) operational small near-by-one automation on its own, 2) integration with corporate systems and external bases, 3), etc.  etc.  And given the power of the Ruby frameworks, take Rails though, the automation may not be small. <br><br><h4>  Running OLE-server and 1C client </h4><br>  To get started, you need a Windows-based computer with Ruby installed on it and a 1C thick client.  Versions of Ruby and 1C are not fundamental, everything described below has been tested on different Ruby and different 1C (8.1, 8.2, 8.3).  Understandably, the 1C client should have access to some 1C database, and you need to know the server address, the database name on this server, the username and password of the user in this database. <br><br>  Now we can start the cmd.exe console, open the irb Ruby interpreter in it, load the win32ole library and get to work.  But here comes the first subtlety: irb works in console encoding (for a standard windows console, this is encoding 866), and OLE wants the encoding of WINDOWS-1251, and errors, by the way, will produce in it.  Therefore, you should switch the console encoding with the command: <br><br><pre><code class="dos hljs"><span class="hljs-built_in"><span class="hljs-built_in">chcp</span></span> <span class="hljs-number"><span class="hljs-number">1251</span></span></code> </pre> <br>  The first step is to get the OLE server (by example 8.2).  There is a second subtlety.  "Normal" servers allow you to connect to an already open application, for example: <br><br><pre> <code class="ruby hljs">server=WIN32OLE.connect <span class="hljs-string"><span class="hljs-string">'Excel.Application'</span></span></code> </pre><br>  For some reason, it doesn't work with 1C, at least it didn't work out for me.  Therefore, we will raise the OLE server, and we will open the client 1C not through our hands, but through the OLE server: <br><br><pre> <code class="ruby hljs">server=WIN32OLE.new <span class="hljs-string"><span class="hljs-string">"V82.Application"</span></span> server.Connect(<span class="hljs-string"><span class="hljs-string">"Srvr=\‚Äùmyserver\‚Äù;Ref=\‚Äùmybase\‚Äù;Usr=\"me\";Pwd=\"mypassword\""</span></span>) server.Visible=<span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  (The server opens the 1C client in a hidden state, in the last line we made it visible.) <br><br><h4>  Work with global context </h4><br>  In the server variable, we got a certain root object of the Win32OLE class.  According to the documentation, it has the only <i>Visible</i> property and three methods: <i>Connect</i> , <i>NewObject</i> and <i>String</i> . <br><br>  However, through it, and only through it, you can get access to the methods of the global context 1C (which in 1C itself are called directly without any objects). <br><br>  Initially, these methods (and all methods) are named in Russian, and therefore they cannot be accessed directly (through a dot), but the invoke method should be used (if called with parameters) or square brackets can be used (if without parameters): <br><br><pre> <code class="ruby hljs">server.invoke(<span class="hljs-string"><span class="hljs-string">''</span></span>[, ...]) <span class="hljs-comment"><span class="hljs-comment">#  server['']</span></span></code> </pre><br>  Example - search for an item in the counterparty directory: <br><br><pre> <code class="ruby hljs">element=server[<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>].invoke(<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">'000000001'</span></span>)</code> </pre><br>  It should be noted that in 8.2 almost all methods have English synonyms, whereas in 8.1 only a few.  If there is an English synonym, call it as a normal method through a dot. <br><br>  There is another subtlety: the methods of the ‚Äúwrapped‚Äù object 1C are case-insensitive, but they can be written in capital letters, as they are described in the documentation and the 1C configurator.  And if so, then it is convenient to write them in Ruby-code in the same way - with a capital letter, so you can immediately see which methods are native Ruby methods, and which are actually wrapped in WIN32OLE 1C methods. <br><br>  Calling <i>['Directories']</i> gives the object Directories Manager, calling <i>['Contracts']</i> - object Reference <i>Manager</i> for the directory Counterparties, and <i>invoke ('FindCode')</i> - object ReferenceObject.  All these objects are wrapped in objects of the WIN32OLE class, and this creates certain inconveniences - the usual methods for working with Ruby objects do not work, for example, you cannot view the class of the wrapped object, the list of methods, etc.  You have to use specific calls, for example: <br><br><pre> <code class="ruby hljs">server.String(element) <span class="hljs-comment"><span class="hljs-comment">#      element.Metadata.Name #   element.Metadata.FullName #  ,     uuid=server.String(element.Ref.UUID) #  UUID  element=server[''][''].GetRef(server.NewObject('UUID',uuid)) #     UUID</span></span></code> </pre><br>  In addition, during the work I had to master the collections of the main applied objects (in more detail about working with them below): <br><br><ul><li>  <i>server ['Directories']</i> or <i>server.Catalogs</i> , </li><li>  <i>server ['Documents']</i> or <i>server.Documents</i> . </li></ul><br>  For more complex cases and to improve performance, it is sometimes necessary to write queries in the 1C query language.  They are created by calling query = <i>server.NewObject ('Query')</i> . <br><br>  This turned out to be enough to solve our problems of integration and expansion of functions of 1C.  In short, this is uploading / synchronizing some directories to external systems, automatic registration of packages of related documents in 1C from external systems and receiving some summary data from 1C to external systems. <br><br>  The remaining 1C funds have not yet been required, and therefore are not considered here, but they can be disassembled in the same way.  The main source of information for this is the 1C configurator, where the data structures of all applied objects are painted, and there is also the help system ‚ÄúSyntax Assistant‚Äù, where the properties and methods of 1C objects are described. <br><br>  Further detail on the application objects. <br><br><h4>  Directories </h4><br><h5>  How are they arranged? </h5><br>  The 1C Directory may (although not necessarily) be hierarchical.  Then the element has a parent, received by the call: <br><br><pre> <code class="ruby hljs">parent=element[<span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-comment"><span class="hljs-comment">#  parent=element.Parent</span></span></code> </pre><br>  If the directory is hierarchical, then there are again two options: a hierarchy of elements or a hierarchy of groups and elements.  Moreover, groups and elements by default are given out in a heap, and to sort them you must watch the call (returning true or false): <br><br><pre> <code class="ruby hljs">element[<span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-comment"><span class="hljs-comment">#  element.IsFolder</span></span></code> </pre><br>  An element-group, in contrast to an element-element, has only standard attributes (or details, in terms of 1C).  Directory may be dependent, i.e.  he may have a directory owner.  Then the element has an owner ‚Äî the owner-reference element received by the call: <br><br><pre> <code class="ruby hljs">owner=element[<span class="hljs-string"><span class="hljs-string">''</span></span>] <span class="hljs-comment"><span class="hljs-comment">#  owner=element.Owner</span></span></code> </pre><br>  Here again subtlety.  Owners-directories can be somewhat different, i.e.  the 'Owner' relationship is in some sense polymorphic.  So, getting the owner, it makes sense to find out its type, as shown above: <i>owner.Metadata.FullName</i> . <br><br>  Each element of the directory has a standard attribute Code (Code), which is the numbering of elements.  Usually the elements are self-numbered, but there are, as always, subtleties: <br><br><ul><li>  item code can be changed </li><li>  the uniqueness of the element code can be limited by the directory settings within the parent or within the owner. </li></ul><br>  So using code as a global directory identifier is not always a good idea.  To do this, it is more appropriate to use a UUID that is unique within the directory and cannot be changed. <br>  List of standard attributes: <br><br><ul><li>  <i>This is a group</i> , <i>IsFolder</i> - makes sense only for directories with a group-element hierarchy, </li><li>  <i>Code</i> , <i>Code</i> - there is always </li><li>  <i>Name</i> , <i>Description</i> - is always there, </li><li>  <i>Parent</i> , <i>Parent</i> - makes sense only for hierarchical reference books, in </li><li>  <i>Owner</i> , <i>Owner</i> - makes sense only for dependent directories, </li><li>  <i>Deletion mark</i> - is always </li><li>  <i>Reference</i> , <i>Ref</i> - there is always, returns a Reference Reference object.  You can get back from the link element using the <i>GetObject</i> method.  The item is of type ReferenceObject.  Why they were divided is not very clear, but you can always determine by scientific method what is needed in each specific case: if it does not want an object, we will try the link instead, and vice versa. </li><li>  <i>Predefined</i> , <i>Predefined</i> - not needed, not used. </li></ul><br>  If the directory has a form, then the directory element can be opened in the 1C client with the element.GetForm.Open request. <br><br><h5>  Reading list </h5><br>  You can get directory entries by calling <i>Select</i> or <i>Select</i> (for an example, the Counterparty reference book): <br><br><pre> <code class="ruby hljs">selector= server[<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>].Select(parent,owner) <span class="hljs-comment"><span class="hljs-comment">#  parent, owner -   while selector.Next do #  -    end</span></span></code> </pre><br>  In selector, we get the object DirectorySelection.  It has the <i>Next</i> method, which returns true / false.  If it returns true, it means that the selector now contains the next element of the selection, in the sense that you can ask for the attributes and methods of this element. <br>  If parent is specified, we will get a sample with this parent, if owner, is with this owner.  If we filter only by owner, we put nil instead of parent. <br><br>  If we want to get not only direct descendants, but the entire hierarchy under the given parent, then instead of <i>Select</i> we write <i>Select</i> <i>Hierarchically</i> or <i>SelectHierarchically</i> . <br><br>  These methods still have the attributes Selection and Order, but I did not understand them, and where there is a need for selection and order, I wrote <i>Query</i> queries (see below). <br><br>  In addition to the standard attributes, the element has specific ones, their list and types should be viewed in the configurator.  Types can be elementary, and can be links to 1C application objects.  If details are not needed, any type can be converted to a string using the <i>server.String</i> method. <br><br>  The attribute may be polymorphic, i.e.  several types to choose from.  If so, then we look at the type, as usual: <br><br><pre> <code class="ruby hljs">selector[<span class="hljs-string"><span class="hljs-string">''</span></span>].Metadata.FullName</code> </pre><br>  In addition to attributes, there may be so-called table parts.  The tabular part can be obtained in the same way as an attribute, by name, while some strange selector is returned, and almost Array, which has a method of each, which gives to the block the objects ‚Äúrow of the tabular part‚Äù.  (But still not Array: for example, there are no methods for collect and each_with_index.) The line has the standard attribute <i>Line Number</i> or <i>LineNumber</i> plus the attributes specified in the configurator. <br><br><h5>  Getting a single item </h5><br>  There are several methods: search by code, by name or by props.  It turned out to be enough for me first - search by code. <br><br>  Call - <i>FindCode</i> or <i>FindByCode (code, isfullcode, parent, owner)</i> .  The main argument is the first, the rest are optional and necessary if the uniqueness of the code is limited by the parent or owner.  If the second argument is true, then the code must include the codes of all parents of the element, separated by the symbol /. <br><br>  One item is returned. <br><br><h5>  Create, write and delete </h5><br>  New items are created using the <i>CreateItem</i> (or <i>CreateItem</i> ) and <i>NewGroup</i> (or <i>CreateFolder</i> ) methods, both of which have no arguments.  Example: <br><br><pre> <code class="ruby hljs">new_element= server[<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>].CreateItem</code> </pre><br>  An empty unsaved item is returned.  If the code is left blank, it will auto-fill when saved. <br>  Values ‚Äã‚Äãare assigned to attributes by calling <i>element ['Attribute Name'] = &lt;</i> attribute_value <i>&gt;</i> .  Attributes links should be assigned as values ‚Äã‚Äãof objects-references, for example: <br><br><pre> <code class="ruby hljs">new_element[<span class="hljs-string"><span class="hljs-string">''</span></span>]=element.Ref</code> </pre><br>  There is a subtlety with the date attribute attribute: the date must be assigned as the string <i>'yyyymmddhhmmss'</i> . <br><br>  There is a subtlety with the record attribute references to the listing.  It would seem that this is just a string, but it will not accept a string, you need to fully refer to the object element of the enumeration, for example: <br><br><pre> <code class="ruby hljs">element[<span class="hljs-string"><span class="hljs-string">''</span></span>]=server[<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>]</code> </pre><br>  The item is recorded by calling <i>Write</i> or <i>Write</i> , with no arguments.  It may return an error, for example, in case of violation of the code uniqueness rules.  The error can be intercepted and processed as usual, or you can simply look through the eyes in the client, it will be shown there. <br>  To remove items, it is necessary to call <i>Set</i> Delete <i>Mark</i> or <i>SetDeletionMark (deletion_mark, mark_descendants)</i> .  Both arguments are boolean, the first is the actual value of the deletion flag.  Accordingly, it is necessary to remove the deletion mark using the same method, but with the argument false.  If the second (optional) argument is true, the elements where the called element is parent or owner are also marked. <br>  You can delete an item completely by calling <i>Delete</i> or <i>Delete</i> .  Referential integrity is not checked, so there is a risk of spoiling the base. <br><br><h4>  Documents </h4><br><h5>  How are they arranged? </h5><br>  The document is characterized by a number and date.  The uniqueness of the number is checked within the period of numbering (it may be a year, or maybe a day, or it may be unique without a period, within the base for documents of this type). <br><br>  To identify the document, you can use the UUID similar to the directory elements.  The number plus date is not suitable for this, since they can be changed and, worse, they can suddenly change themselves after editing certain attributes of documents. <br><br>  The document, similar to the directory element, has standard and specific attributes, may have tabular parts.  Work with them is completely similar. <br><br>  Standard document attributes: <br><br><ul><li>  <i>Number</i> , <i>Number</i> - is always there, </li><li>  <i>Date</i> , <i>Date</i> - there is always, the type is date-time, I </li><li>  <i>DeletionMark</i> - <i>DeletionMark</i> is always there, </li><li>  <i>Link</i> , <i>Ref</i> - there is always, the meaning is completely analogous to the reference to the element of the directory, </li><li>  <i>Done</i> , <i>Posted</i> - there is always. </li></ul><br>  Similar to the directory element, you can open the document form in the client: <i>document.GetForm.Open</i> . <br>  The document can be posted and distributed; this is done when the document is saved with the following calls, respectively: <br><br><pre> <code class="ruby hljs">document.Write(server.DocumentWriteMode.Posting) document.Write(server.DocumentWriteMode.UndoPosting)</code> </pre><br><br><h5>  Reading list </h5><br>  Receiving documents of this type is similar to receiving directory elements ‚Äî by calling <i>Select</i> or <i>Select</i> (for example, Buyer's Order documents): <br><br><pre> <code class="ruby hljs">doc_selector= server[<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>].Select(from, to) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> doc_selector.Next <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">#  -    end</span></span></code> </pre><br>  Similarly, the directories after each call to Next in the doc_selector object become available the following item.  You can specify the date range of documents with optional arguments from and to in the format of the string 'yyyymmddhhmmss'. <br><br><h5>  Receive a separate document </h5><br>  You can search by number or by props.  It turned out to be enough for me first - search by number.  Call - <i>Find By Number</i> or <i>FindByNumber (number, interval_date)</i> . <br><br>  The optional argument interval_date (format - the string 'yyyymmddhhmmss') is needed to set the interval of unique numbers, write any date that falls within the desired interval. <br><br><h5>  Create, write and delete </h5><br>  Everything is very similar to directories. <br><br>  The document is created by calling <i>CreateDocument</i> or <i>CreateDocument</i> , while getting a new empty document not stored in the database.  Auto-numbering and auto-assignment of the date occurs when saving. <br><br>  Write the item by calling <i>Write</i> or <i>Write</i> with two optional arguments.  The first is the recording mode (with or without holding, see above), possible values: <br><br><pre> <code class="ruby hljs">server.DocumentWriteMode.Posting <span class="hljs-comment"><span class="hljs-comment"># (/ ) server.DocumentWriteMode.UndoPosting # (/ )</span></span></code> </pre><br>  The second - the mode of the document, the possible values: <br><br><pre> <code class="ruby hljs">server.DocumentPostingMode.Regular <span class="hljs-comment"><span class="hljs-comment"># () server.DocumentPostingMode.RealTime # ()</span></span></code> </pre><br>  Deleting documents is similar to deleting directory entries. <br><br>  Deletion <i>mark</i> - <i>Set</i> <i>Deletion mark</i> or <i>SetDeletionMark (deletion_mark)</i> .  The Boolean argument is the value of the deletion flag.  Complete deletion of a document ‚Äî by calling <i>Delete</i> or <i>Delete</i> (this does not check referential integrity). <br><br><h4>  Requests </h4><br>  Requests to the 1C database are written in its SQL-like query language, where various 1C objects appear as entities and attributes. <br>  On the one hand, it is convenient to use 1C queries in the sense that it is possible to more accurately select and aggregate the necessary data and at the same time avoid solving the subtleties of working from ruby ‚Äã‚Äãwith new (not yet mastered) object types.  And yet - examples of requests from the documentation or the Internet can be used as is one-on-one, because the request body is just a string.  And code samples must also be translated into Ruby, and this is not always trivial. <br><br>  For example, when I needed balances in warehouses that are stored in Accumulation Registers. Products in Stores, it turned out to be much easier to find a sample request than to disassemble a new type of objects. <br><br>  On the other hand, in ‚ÄúSyntax Helper‚Äù there is no description of the query language, and you need to have 1C documentation on hand. <br><br>  So, a new request is created by calling: <br><br><pre> <code class="ruby hljs">query=server.NewObject(<span class="hljs-string"><span class="hljs-string">'Query'</span></span>)</code> </pre><br>  Next, enter the text of the request, for example: <br><br><pre> <code class="ruby hljs">query.Text= <span class="hljs-string"><span class="hljs-string">' .  .    .=&amp;  .=&amp;'</span></span></code> </pre><br>  Here <i>&amp; Nomenclature</i> and <i>&amp; CH</i> - query parameters, and they need to assign values, the first - the directory element, the second - the line: <br><br><pre> <code class="ruby hljs">nom=server[<span class="hljs-string"><span class="hljs-string">''</span></span>][<span class="hljs-string"><span class="hljs-string">''</span></span>].FindByCode(<span class="hljs-string"><span class="hljs-string">'0001234567'</span></span>) query.SetParameter(<span class="hljs-string"><span class="hljs-string">''</span></span>,nom) query.SetParameter(<span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">'12345678'</span></span>)</code> </pre><br>  Next we have to <i>execute the</i> request ( <i>Execute</i> ), and the result of the request <i>Unload</i> : <br><br><pre> <code class="ruby hljs">result=query.Execute.Unload</code> </pre><br>  The result has the method <i>Number</i> or <i>Count</i> - the number of rows found.  We get separate records from the result using the <i>Get</i> or <i>Get</i> method by the line number (starting from 0), and a separate record attribute - again by the <i>Get</i> or <i>Get</i> method by the number of the attribute in the request, starting from 0. <br><br><pre> <code class="ruby hljs">sers=(<span class="hljs-number"><span class="hljs-number">0</span></span>..result.Count).collect <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|i|</span></span> record=result.Get(i) record.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Important: if in the SELECT section we requested an object, then in the corresponding attribute we will get the whole object.  In the example, we have an array of directory elements of the Directory type reference list Reference.  And if we in the SELECT indicated a Series. Name, then instead of an object we would receive the corresponding line. <br><br>  Thank you for your attention. </div><p>Source: <a href="https://habr.com/ru/post/271835/">https://habr.com/ru/post/271835/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271823/index.html">Network monitoring: how we make sure that large companies have all the nodes</a></li>
<li><a href="../271825/index.html">In 600,000 Arris modems, they found a backdoor in a backdoor</a></li>
<li><a href="../271829/index.html">How we wrote ourselves anew, or how to lose the source code and not give it to mind</a></li>
<li><a href="../271831/index.html">Extortion programs on smart TV? You can prepare, they go</a></li>
<li><a href="../271833/index.html">CyberMonday starts at BlackFriday</a></li>
<li><a href="../271837/index.html">Technopark portal: how we did it</a></li>
<li><a href="../271839/index.html">Successful clients of Inoventica Services (LOM history - details)</a></li>
<li><a href="../271841/index.html">Use code highlighting</a></li>
<li><a href="../271843/index.html">Zabbix on OpenShift Part 2 - Agent Connection</a></li>
<li><a href="../271847/index.html">Security Week 48: melancholy with Dell certificates, backdoor in modems, Truecrypt returns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>