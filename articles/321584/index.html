<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular 1.x: creeping webpack, hidden grunt</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story of how we changed the project build from grunt to webpack 
 You come to work, you open IDE, you write npm start , starting the build system,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular 1.x: creeping webpack, hidden grunt</h1><div class="post__text post__text-html js-mediator-article"><h2>  The story of how we changed the project build from grunt to webpack </h2><br>  You come to work, you open IDE, you write <code>npm start</code> , starting the build system, you start working.  It is convenient for you to navigate the structure of the project, it is convenient to debug the code and styles, obviously, exactly how and in what order the project is going. <br><br>  It takes two years.  In the development process, you periodically think about where to put the files with the new module correctly, how to deal with shared resources, and it is not always straightforward to answer the Junior's question ‚Äúhow does this file get into the bundle at all?‚Äù.  Or you answer the sacred ‚Äúso historically‚Äù and yearn for what was two years ago. <br><br>  As it turned out, this happens if you do not upgrade the assembly system with the growth of the project.  The good news is that this is successfully treated!  In the summer we confirmed this in battle and want to share our experience. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/a82/5e6/4a3/a825e64a3e0d4be897a87d56656d9bbd.jpg"><br><a name="habracut"></a><br><h3>  initial situation </h3><br>  We have been developing the office application package MoyOffice since 2013, the web version (which will be discussed later) - since 2014. <br><br>  There are several related projects (file manager, authorization and profile, web-editor of documents) with common sub-repositories, each of which is a SPA-part of a large application MyOffice.  Development is carried out on <code>angular 1.5</code> , jenkins is used for continuous integration. <br><br>  The original grunt build system, consisting of complex interdependent tasks, was created at the dawn of the project and has changed little since then.  To indicate the scale: the dev-build launched about 30 grunt-tasks, 30% of which collected modules and styles, 70% - shifted images and fonts, updating the links to them.  The order of execution was crucial, however, information about interdependence could only be obtained from colleagues. <br><br><h3>  Why migrate and why webpack </h3><br>  Collecting an angular project is actually not so difficult: you just need to combine all the source files into one, not forgetting that the module was announced before its controller.  We made it even easier: we collected all the files from the src folder (using `_` at the beginning of the file name to ensure the correct connection order), added an array of external packages, and then connected the files directly to the head (of course, only for the dev-build, for production code was concatenated into a bundle followed by obfuscation and minification. <br><br><img src="https://habrastorage.org/files/f0f/e2e/00b/f0fe2e00b457408f8553b01dceaae167.jpg"><br><br>  The assembly is obviously morally obsolete.  The latest critical changes were dated 2015, which in the conditions of the modern frontend can be equated to a web-covered corner, in which, frankly, unfashionable grunt stores its intermediate files. <br>  Plus, she had only one: the reassembly of the project was conditionally free due to the direct connection of files to the head. <br><br>  Cons are much more: <br><br><ul><li>  Collecting files by mask, we could not develop independent plug-ins. </li><li>  The number of HTTP requests in the dev mode was measured in the hundreds, and the page reload time in this mode was several seconds longer than in the compiled application. </li><li>  Because of the connection by <code>*.js</code> mask, unused modules got into the project. </li><li>  When you add a new js-file, you had to restart the entire assembly. </li><li>  To connect third-party dependencies, we stored a separate json with module names. </li><li>  Grunt forced us to create a large number of intermediate and config files, due to which our <code>.hgignore</code> contained more than 50 lines. </li></ul><br>  And the more our project expanded, the more strongly the shortcomings of the build system interfered. <br><br>  Taking a step back, looking at ourselves, at others, at the trends, recalling the experience of previous projects, we chose a webpack that effectively solves the problems described above. <br><br><h3>  Work organization </h3><br><img src="https://habrastorage.org/files/4b6/9f4/34b/4b69f434be8b46fca0e0207d56673872.jpg"><br><br>  The main secret of successful refactoring is to clearly define the steps in advance and make a plan. <br><br><ol><li>  Make a list of all requirements. </li><li>  Implement the <a href="https://en.wikipedia.org/wiki/Proof_of_concept">proof of concept</a> on a small project site.  The idea is to collect all possible rakes cheaply and in the background, without risks for the main development. </li><li>  To make a complete transition, taking into account all the fine points identified in paragraph 2. Knowing all the problems and having experience transferring part of the code to new rails, one can fairly accurately estimate the labor intensity. </li></ol><br><h3>  Reverse engineering requirements </h3><br>  The new system should not only solve the existing problems of assembly, but also support several new and long-desired features (and of course, not lose the old ones).  Compiled a list of what should be able to webpack in a finished form: <br><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Incremental_build_model">Incremental build</a> . </li><li>  Watch mode. </li><li>  Source map support (by flag). </li><li>  Minification (by flag). </li><li>  Hot module replacement. </li><li>  Babel support. </li><li>  <a href="https://en.wikipedia.org/wiki/Dead_code_elimination">Dead code elimination.</a> </li><li>  Split vendor code and our two bundle. </li><li>  Add hash to file names. </li></ul><br>  In this case, grunt cannot be excluded from the process, since it is responsible for assembling styles, working with images and fonts, and generating documentation.  For consistency, we even want to run the webpack via grunt, and not via npm-task, in order not to change the command to build the project at all and not to reconfigure anything to CI. <br><br><h3>  Proof of concept </h3><br>  At the mercy was given one of our applications - SPA, responsible for all manipulations with authentication and user profile.  At the end of the work with him could be taken for the rest. <br><br>  In a good way, all the work was divided into three parts: <br><br>  1. Create a config for webpack. <br>  2. Prepare files for such an assembly.  File Formats: <br><br><ul><li>  html </li><li>  js, </li><li>  css, </li><li>  media (pictures and fonts), </li><li>  a large number of configs stored in <code>json</code> and integrated into the assembly somewhere in the middle. </li></ul><br>  3. Rewrite unit tests. <br><br>  Css along with the media temporarily postponed, since they are not integrated into angular and can continue to live their lives. <br><br><h4>  js modules </h4><br>  For those who have not looked into angular for a long time, let us recall how it looks from the inside: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">// module.js angular.module('moduleName',[ 'dependencyOneName', 'dependencyTwoName' ]) .controller('SomeController', function(){‚Ä¶}) .directive('someDirecive', function(){}); // someService.js angular.module('moduleName') .service('SomeService', function(){‚Ä¶});</span></span></code> </pre> <br>  The main thing that disturbs us in the case of the webpack: all dependencies are indicated simply by the string-name of the required module.  To build a dependency graph in a webpack, you must explicitly specify which file to include. <br><br>  Over time, such a plan was formed: <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//module.js module.exports = angular.module('moduleName', [ require('path/to/firstDependency'), require('path/to/secondDependency') ]) .controller(...require('controller.js')) //es6 spread syntax feature yay! .name; //controller.js module.exports = ['SomeController', function(){}];</span></span></code> </pre> <br>  By using es6 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator">spread syntax,</a> we were able to elegantly avoid duplicating the name of the module when declaring a component. <br><br>  Since the dependency connection format changed critically, it was not possible to touch common sub-repositories within the POC framework in order not to hook on other projects.  Therefore, all common files had to be connected manually by a long-long list. <br><br><h4>  HTML templates </h4><br>  Templates are divided into two categories: <code>index.html</code> and all others.  Collecting <code>index.html</code> easy with the <a href="https://github.com/jantimon/html-webpack-plugin">html-webpack-plugin</a> .  Everyone else used to do <a href="https://www.npmjs.com/package/grunt-ng-template">grunt-ng-template</a> .  I had to search for webpack-plugin to work with templates.  There were only two requirements for it: <br><br><ul><li>  So that all the templates mentioned in the modules immediately fall into $ templateCache. </li><li>  So that all internal template connections (ng-include) are also processed. </li></ul><br>  The first item was <a href="https://github.com/WearyMonkey/ngtemplate-loader">easy</a> to handle, and the second one had problems.  Until now, there is no suitable solution, and although it is easy to write it, it was faster for us to connect all such templates in js.  In the future we want to develop a webpack-loader for this purpose.  If you have already written one yourself, share the github link with us in the comments. <br><br>  With an hit in <code>$templateCache</code> interesting nuance: if you do <code>require</code> within a directive or controller, then it will try to add itself to the cache only in runtime, without getting into the bundle in advance.  With the advent of <a href="https://docs.angularjs.org/guide/component">angular components,</a> this was corrected; in other places, templates had to be connected before the controllers were announced. <br><br>  In order to easily detect missed template connections, we added a <code>webpack-dev-middleware</code> in <code>webpack-dev-middleware</code> that prohibits downloading any nested <code>html</code> . <br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blockLocalTemplatesMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req, res, next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> urlPath = parseUrl(req).pathname; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (/[^\/]+\/[^\/]+\.html$/g.test(urlPath)) { res.statusCode = <span class="hljs-number"><span class="hljs-number">404</span></span>; res.end(<span class="hljs-string"><span class="hljs-string">'Request to .html template denied'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { next(); } }</code> </pre> <br><h4>  Configs </h4><br>  Each of our projects has configurations that are sewn into the project at the assembly stage.  Previously, all configs were stored in several json-files, <a href="https://github.com/werk85/grunt-ng-constant">grunt-ng-constant</a> wrapped them in an angular-module and connected to the project at the assembly stage, reducing the transparency of reading and debugging.  Using <a href="https://webpack.github.io/docs/list-of-plugins.html">DefinePlugin</a> made it much more convenient and easier. <br><br><h4>  Unit tests </h4><br><ul><li>  In order not to slow down the test build, <a href="https://www.npmjs.com/package/ignore-loader">ignore-loader</a> was used to connect everything except js. </li><li>  In unit tests I had to directly contact angular.mock because of the <a href="http://stackoverflow.com/questions/32499108/karma-jasmine-webpack-module-is-not-a-function/32584798">webpack</a> . </li><li>  Tests using <code>angular.element</code> began to fall massively.  Breaking our head notably, we remembered that <code>angular.element</code> uses jQuery, but does not pull it with us, so the library should be connected separately in <code>karma.config.js</code> . </li></ul><br><h3>  Final migration </h3><br>  Three weeks of careful POC later, we were ready for the final migration of the entire application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2f/5b5/21f/c2f5b521f6ba8911e12194d0ca70298b.jpg" alt="image"><br><br><h4>  Work with css </h4><br>  We migrated in June-July, thought about the article in August, resolutely started writing in December, and during this time we already had time to get used to the convenience of the modular structure and decided to transfer the sass-style assembly to a webpack. <br><br>  And although this article initially assumed the story only about the first stage of migration, we cannot but share the experience of giving up <code>grunt-sass</code> . <br><br>  The process of such migration is in fact quite trivial: just connect all the necessary styles in the modules where they are used.  However, without pitfalls also not done. <br><br>  How did the build work before?  Like building js modules.  According to the mask, all <code>*.scss</code> were collected and imported in one file.  Then <code>sass</code> worked on it alone, all mixins and helpers connected once were available everywhere, there were practically no cross-imports. <br><br>  To implement the modular structure, we started importing variables, mixins, <code>node-bourbon</code> , lunaparks, blackjack in each style file.  Because of this, two troubles happened: <br><br><ul><li>  Due to the lack of <code>import-once</code> (there was no special need before), our final <code>.css</code> so swollen that IE (in Chrome, Firefox, and even Safari, of course, didn‚Äôt have such problems) could not parse them.  That is, the page was loaded, the <code>.css</code> file was loaded, but to realize that it is full of styles, IE was not able to.  This issue was resolved by simply adding <code>import-once</code> . </li><li>  <code>sass-loader</code> , which does not have an incremental build, rebuilt the project every time, and because of the abundance of entry points and imports into them, spent about 5 seconds rebuilding.  Dealing with this without changing the architecture was not possible. </li></ul><br>  However, the update to the recently released <code>node-sass@4.0.0</code> accelerated the reassembly by about 1.5 times, and we decided to postpone the massive processing of styles. <br><br><h4>  Debugging and Testing </h4><br>  The main thing in development is not to write, but to debug, according to the results of debugging, we have compiled a cheat sheet for those who decide to repeat the migration path (by the way, it doesn‚Äôt matter where to get off - with gulp or grunt).  Basically, all the defects encountered on the way and their diagnostics looked like: <br><br><ul><li>  ‚ÄúNothing is going to, in the IDE console is full of letters‚Äù: we are trying to connect a dependency that does not exist (wrong path or incorrect export). </li><li>  ‚ÄúGathered, but nothing works, there are very long errors in the browser console‚Äù: the module lacks dependency.  In the old assembly, there was no such problem, because all the modules got into the assembly and you can easily not mention the necessary dependency without getting any side effects.  Now, the files that are not mentioned anywhere in the bundle are not included. </li><li>  ‚ÄúEverything was loaded, but when you click or click - it drops‚Äù: there are three options to choose from ‚Äî the previous one, the lack of a template in <code>$templateCache</code> or forgot to add webworker to the assembly. </li><li>  ‚ÄúThe application does not look like this‚Äù: due to a change in the order of styles, we still for a long time found small defects caused by the initial calculation for a certain (alphabetical) order of connecting files. </li></ul><br>  Separate manual testing from the QA-team in this task was not required, it was easy enough to run autotests.  The only thing we asked testers to check is that jenkins is successfully and correctly built with all possible flags. <br><br><h4>  Technical points </h4><br>  There are a lot of possibilities to optimize the process of working angular using a webpack.  On github, you can find dozens of loaders (curiously, from the moment we completed the migration to the day when this paragraph was started, there were already some plug-ins that we lacked then).  However, a third of them do not have documentation and contain only minified code, so it is not possible to use them, the second third works ambiguously (for example, there are three loaders for templates, they do the same thing, and we have earned correctly only one). <br><br><h4>  Inevitable difficulties </h4><br><ul><li>  In this section we will tell about the difficulties we encountered on the way of working with the selected tools. </li><li>  It is inconvenient to export the name of the module, it is not clear how to solve this problem on angular 1.x. </li><li>  You can not connect the necessary dependency and remain uncatchable if it is used in another module.  This reveals unit tests that run in isolation, but the overall trend does not seem healthy. </li><li>  Some external angular modules of dependencies do not have exports, this causes suffering and reduces transparency. </li></ul><br>  For example: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ng-file-upload'</span></span>); angular.module(<span class="hljs-string"><span class="hljs-string">'app'</span></span>, [<span class="hljs-string"><span class="hljs-string">'ngFileUpload'</span></span>])</code> </pre><br>  You can cope with this with the help of a pull-requests battery on github, we sometimes send them in spare time. <br><br><ul><li>  If you write modules in the format of the export function, you must mention <code>@ngInject</code> .  If this is not done, the minified version does not work, and this situation cannot be tracked by linders. </li><li>  Webpack, it turns out, panics, when it has two ways to otrezolvit file. </li></ul><br>  For example, the project structure is as follows: <br><br><pre> <code class="php hljs">‚îú‚îÄ‚îÄ src ‚îÇ ‚îî‚îÄ‚îÄ module.js ‚îî‚îÄ‚îÄ common ‚îî‚îÄ‚îÄ src ‚îî‚îÄ‚îÄ module.js <span class="hljs-comment"><span class="hljs-comment">// webpack.config.js resolve: { root: ['src','common/src'] } //app.js require('module.js');</span></span></code> </pre><br>  If you change the file, change detection cannot work correctly and the project is completely unpredictable, it is re-assembled, then no.  Since we had several input points with the same internal structure, we had to abandon it. <br><br><ul><li>  Not all minification methods work 100% the same.  We used to use <a href="https://github.com/gruntjs/grunt-contrib-uglify">grunt-contrib-uglify</a> , now we have switched to <a href="https://webpack.github.io/docs/list-of-plugins.html">UglifyJsPlugin</a> .  Despite the same settings, during the transition, a problem arose with the fact that one of the libraries began to consider Russian characters in HTML templates to be insecure and turned them into double-shielded HTML entities.  Such cases do not lend themselves to a logical explanation, but illustrate the benefits of frequent testing of the code compiled with the settings used for production. </li></ul><br><h4>  Unexpected Benefits </h4><br><ul><li>  We always created two bundles - the code of third-party libraries and ours.  With webpack, sharing occurs through <a href="https://webpack.github.io/docs/list-of-plugins.html">CommonsChunksPlugin</a> .  At first, we kept two entry points, on which we used ommonsChunkPlugin, but found an excellent tricky solution. </li></ul><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> webpack.optimize.CommonsChunkPlugin({ name: <span class="hljs-string"><span class="hljs-string">'vendor'</span></span>, chunks: [<span class="hljs-string"><span class="hljs-string">'app'</span></span>], filename: <span class="hljs-string"><span class="hljs-string">'vendor.[hash].js'</span></span>, minChunks: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minChunks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(module)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> module.resource &amp;&amp; module.resource.indexOf(<span class="hljs-string"><span class="hljs-string">'node_modules'</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; } })</code> </pre> <br>  Why divide the code into two parts?  To use a <a href="http://robertknight.github.io/posts/webpack-dll-plugins/">DLL</a> , speeding up rebuilding.  Plus, with fairly frequent releases (and we strive to increase their frequency) the list of dependencies does not have time to change, while maintaining the same hash.  This allows the user not to download an extra file, but simply to take it from the browser's cache. <br><br><ul><li>  Using opensource libraries, we are obliged to specify the names of their authors.  With webpack, it has become very convenient to collect this information with the help of <a href="https://www.npmjs.com/package/license-webpack-plugin">license-webpack-plugin</a> , which is oriented along the path to the plug-in. </li></ul><br><h3>  Did not go to work </h3><br><h4>  Automatic loading of modules </h4><br>  Of course, we didn‚Äôt really want to rewrite all module dependencies from strings to <code>require</code> .  It would be cool to fasten the <code>loader</code> , which would analyze the code and itself substitute the necessary <code>require</code> ! <br><br>  However, such an approach requires a strict project structure so that it is possible to unambiguously match the path to the module with its name.  In fact, the string with the module name would uniquely transform into the file path.  At the time of the migration, the project structure did not have this approach, and the reorganization of files would take no less time and threaten a large number of conflicts when merging branches. <br><br>  Now we are starting the path to strict organization of the source code and, when we are finished, we will be able to take advantage of such opportunities.  Although this, most likely, it does not want to, because going through <code>ctrl-click</code> immediately to the dependent module is extremely convenient. <br><br><h4>  Hot module replacement </h4><br>  Unfortunately, we had to refuse HMR for js-code.  There are <a href="https://github.com/yargalot/Angular-HMR">two plug-ins</a> , but both of them require not only a very strict project structure, but also an exact export format, and also work only with controllers, but not with directives.  Even with a suitable structure, using the update only for a part of the code is completely inconvenient.  However, for styles HMR works correctly. <br><br><h4>  Tips for the past </h4><br>  The migration process went quite smoothly and step by step, however, as it usually happens, having completed the work, we figured out how to facilitate it: <br><br><ul><li>  Instead of manually replacing all string dependency names with <code>require()</code> , it is easier to write a one-time nodejs script that analyzes the current code base and replaces the module names on the way to them. </li><li>  Unverified advice!  Perhaps it makes sense to first rewrite the code using <a href="http://browserify.org/">browserify</a> , and then attach the webpack to it, so as not to figure out exactly what of the tons of changes made, the problem is in the wrong paths of the included files or in the collector itself. </li></ul><br><h3>  About numbers </h3><br>  The most interesting is, of course, the numbers.  Interesting logs on tasks: <br><br><img src="https://habrastorage.org/files/f2b/bb2/798/f2bbb2798c8f46cb9d5eb11dbdf9a72d.jpg"><br><br>  Re-and underestimations take place, however, in general, we managed to predict the labor intensity rather accurately.  The key to this success, we believe a clear wording of the requirements prior to the implementation of the task.  The experience of previous and subsequent mass refactorings confirms this: if we take on the task, planning to make a list of requirements in the development process, forgetting something important is easier than easy. <br><br><h4>  Assembly time </h4><br>  On the old build, when detecting changes in js, the page started reloading right away.  If changes were made to the styles, rebuilding css took about 3.5 seconds. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After moving reassembly occurs in 5 seconds regardless of where the changes were made. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The loading time of the page in the dev-version on the old build took about 1.5 seconds due to the large number of js-files connected. </font><font style="vertical-align: inherit;">After the transition to the webpack, it was reduced to 0.8 seconds. </font><font style="vertical-align: inherit;">When you change styles, both then and now, no reload is required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, the following data is obtained. </font><font style="vertical-align: inherit;">The table shows the time from making changes to applying them on the page:</font></font><br><br><img src="https://habrastorage.org/files/f07/4ae/747/f074ae747d424a62b49820adaaba4413.jpg"><br><br><h2>  findings </h2><br><img src="https://habrastorage.org/files/cbb/156/283/cbb1562838fd47cb81932d04114a51d2.jpg"><br><br>  Minuses: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> time from change to page reload increased </font></font></li></ul><br>  Pros: <br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project scalability has grown - now add a new plugin or loader (connect babel or postcss) is much easier </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transition to a modular structure has finally become possible </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> easy to navigate by module dependencies using ctr + click </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no extra files get into the bundle </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It has become more convenient to collect information about third-party licenses and separate the opensource code from our </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when adding new files do not need to restart the entire assembly again </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> got rid of a long, tangled list of grunt-tasok, replacing it with a list of webpack-plug-ins, which are much more convenient to use </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can switch from branch to branch without restarting a working assembly </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Future plans: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> speed up the build </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> learn how to collect assets used in styles using postcss plugins, and the rest using webpacks </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> take steps to maintain the HMR for any changes </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, it became easier to navigate the project, the entry threshold for a new employee became lower, refactoring is more accessible, dependency tracking is more convenient. </font><font style="vertical-align: inherit;">Now you can develop individual modules and not be afraid that part of the code or css will fall into a common bundle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be a shame to read such a long article and not get a bonus at the end! </font><font style="vertical-align: inherit;">We put ready for you </font></font><a href="https://gist.github.com/newcloudtech/b5001f993cb2e2974725ff58962bf01b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">configs for webpack and karma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font></div><p>Source: <a href="https://habr.com/ru/post/321584/">https://habr.com/ru/post/321584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321574/index.html">How MTS ‚Äúgrinds‚Äù its geolocation services for corporate clients</a></li>
<li><a href="../321576/index.html">Ten world CRM trends to talk about</a></li>
<li><a href="../321578/index.html">ChairInput. We write the game in Unity, managed using the Android virtual keyboard. Problem with camera angle</a></li>
<li><a href="../321580/index.html">Trigger mailings: how to increase conversion</a></li>
<li><a href="../321582/index.html">PVS-Studio and GitHub-community: the beginning of friendship</a></li>
<li><a href="../321586/index.html">Artificial Intelligence Attacks You</a></li>
<li><a href="../321590/index.html">Why VIPER is a good choice for your next application.</a></li>
<li><a href="../321592/index.html">CloudFlare + nginx, or save with the help of the "coffee maker" (upd2: fast speakers dynamics!)</a></li>
<li><a href="../321594/index.html">Introduction to CDRS, Apache Cassandra driver fully written in Rust</a></li>
<li><a href="../321596/index.html">How IT professionals work. Dmitry Tsimoshko, director of information technology at Century 21</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>