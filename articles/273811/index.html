<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New Year's release of PVS-Studio 6.00: check Roslyn</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is a long-awaited event. We have released the release version of the PVS-Studio 6.00 static code analyzer, which supports the verification of C # p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New Year's release of PVS-Studio 6.00: check Roslyn</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2b4/015/69c/2b401569c34fa7c9d8ff4156eca22a66.png" alt="PVS-Studio 6.00, C, C ++, C #" align="left"><br>  It is a long-awaited event.  We have released the release version of the PVS-Studio 6.00 static code analyzer, which supports the verification of C # projects.  Now we check the code written in the following languages: C, C ++, C ++ / CLI, C ++ / CX, C #.  By the release of the sixth version of the analyzer, we timed the test of the open Roslyn project.  Thanks to Roslyn, C # support appeared in the PVS-Studio analyzer, and we are very grateful to Microsoft for the implementation and development of this project. <br><a name="habracut"></a><br><h2>  PVS-Studio 6.00 </h2><br>  <a href="http://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> is a static code analyzer focused on ease of use and searching for errors at the stage of writing code. <br><br>  We are constantly adding diagnostic rules to search for new types of errors in C / C ++ programs.  For example, we recently added a search for class members that are not initialized in the constructor, which was quite a <a href="http://www.viva64.com/ru/b/0354/">daunting task</a> .  However, the improvement of diagnostics is not a reason for changing the older version.  And we waited to add something truly new to the analyzer.  And this moment has come.  We present to the world the sixth version of the analyzer that supports the C # language. <br><br>  The trial version of PVS-Studio 6.00 is available at the link: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://www.viva64.com/ru/pvs-studio-download/">http://www.viva64.com/en/pvs-studio-download/</a> <br><br>  In the sixth version of the analyzer, we refused to support old versions of Visual Studio.  Now VS2005 and VS2008 are not supported.  If your team still uses these versions of Visual Studio, we suggest continuing to use the previous version 5.31 or its upgrades, if any. <br><br>  The demo version has the following limitation.  You can perform 50 transitions by code.  After this, the analyzer will offer the person to send information about himself.  If he agrees, he will be given another 50 transitions. <br><br>  Limiting the demo version may seem harsh.  However, he has a justification, and we came to him after many experiments. <br><br>  A small number of "clicks" will help to start <a href="http://www.viva64.com/ru/about-feedback/">communication in the mail</a> .  If someone wants to look at other messages, then we are ready to give him a registration key, say, for 1 week.  He just needs to write us a letter.  As a rule, in the process of correspondence, we help a person to quickly orient himself, as he can quickly and easily benefit from the use of the analyzer. <br><br><h2>  Roslyn </h2><br>  Programmers are not susceptible to advertising.  They cannot be carried away by the words ‚Äúmission‚Äù, ‚Äúflawlessly‚Äù and ‚Äúfocus on innovation‚Äù.  The programmer does not read advertising announcements and knows how to disable banners using Adblock Plus. <br><br>  The only thing they can carry away is to show how this or that tool can be useful to them.  We chose just such a path and show how the static analysis tool can benefit by checking open projects. <br><br>  PVS-Studio is able to find errors in such well-known projects as CoreCLR, LibreOffice, Linux Kernel, Qt, Unreal Engine 4, Chromium, and so on.  At the moment, our team checked 230 open projects and found <a href="http://www.viva64.com/ru/examples/">9355</a> errors in them.  Yes, yes, 9355 is the number of errors, not the number of diagnostic messages.  The most interesting checks can be found in the relevant <a href="http://www.viva64.com/ru/a/0084/">articles</a> . <br><br>  Now the turn has come to checking C # projects.  Not surprisingly, Roslyn was one of the first proven projects.  In the end, thanks to this project, it was possible to support the analysis of C # code in PVS-Studio. <br><br>  I want to express gratitude to Microsoft for creating this open source project.  It will have a big impact on the development of C # infrastructure.  Yes, he already has an impact!  For example, such well-known projects as ReSharper or <a href="https://www.youtube.com/watch%3Fv%3DjdWjuIYh6IQ%26amp%3Bfeature%3Dyoutu.be">CodeRush</a> are transferred to the Rolsyn base. <br><br>  Now a little about the project Roslyn. <br><br>  The .NET Compiler Platform, better known by the code name Roslyn, is a set of open source compilers and an API for analyzing source code for C # and Visual Basic .NET languages.  The platform is developed by Microsoft. <br><br>  This platform includes self-sufficient compilers for C # and VB.NET.  They are available not only as traditional command-line applications, but also as native APIs that can be accessed from .NET code.  Roslyn allows access to the modules for syntactic (lexical) code analysis, semantic analysis, dynamic compilation into CIL bytecode, and assembly generation.  The Roslyn API provided can be divided into three types: functional API (feature API), workspace API (API) and compiler API (compiler API).  Functional APIs make refactoring and debugging easier.  The workspace APIs allow plug-in developers to implement certain mechanisms specific to the IDE like Visual Studio ‚Äî for example, finding the correspondence between variables and values ‚Äã‚Äãor formatting code.  The compiler APIs provide opportunities for even more advanced source code analysis, providing information on direct calls to the syntax tree analysis modules and control flow analysis at the stage of associating identifiers with values. <br><br>  Additional links: <ol><li>  Github  <a href="https://github.com/dotnet/roslyn">Roslyn</a> . </li><li>  Wikipedia.  <a href="https://en.wikipedia.org/wiki/.NET_Compiler_Platform">.NET Compiler Platform ("Roslyn")</a> </li><li>  <a href="https://roslyn.codeplex.com/wikipage%3Ftitle%3DOverview">.NET Compiler Platform ("Roslyn") Overview</a> . </li><li>  Msdn  Forum.  <a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/home%3Fforum%3Droslyn">Microsoft "Roslyn" CTP</a> . </li><li>  Msdn  <a href="http://blogs.msdn.com/b/csharpfaq/archive/2014/04/03/taking-a-tour-of-roslyn.aspx">Taking a tour of Roslyn</a> . </li><li>  <a href="https://joshvarty.wordpress.com/learn-roslyn-now/">Learn Roslyn Now</a> . </li><li>  Miguel de Icaza.  <a href="http://tirania.org/blog/archive/2014/Apr-09.html">Mono and Roslyn</a> . </li></ol><br><h2>  Bugs found </h2><br>  The PVS-Studio analyzer found few errors in Roslyn.  This is natural for such a well-known project developed by Microsoft with its well-established quality control systems.  Finding at least something in the Roslyn code is already a big victory, and we are proud that we can do it. <br><br>  Many of the errors below refer to tests or error handlers.  It `s naturally.  Errors in frequently used code fragments are corrected due to testing and feedback from users.  But the fact that PVS-Studio can find errors is important for us.  This means that many errors that were corrected with great effort could be corrected immediately with regular use of PVS-Studio. <br><br>  Once again, in other words.  The value of the analyzer is not in one-time runs, but in its regular use.  Static code analysis can be viewed as an advanced version of the compiler warnings.  It is foolish to turn on compiler warnings once a year.  Warnings should be watched immediately after they occur.  This saves development time on finding stupid bugs with debugging.  With the static analyzer everything is the same. <br><br>  Let's see what interesting things were discovered with PVS-Studio: <br><br>  <b>Error N1 in tests.</b>  <b>Copy-Paste.</b> <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexerMemberRace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; i++) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { thread1.Start(); thread2.Start(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { thread1.Start(); thread2.Start(); } .... } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0402/">warning</a> : <a href="http://www.viva64.com/ru/d/0402/">V3004</a> The 'then' statement is equivalent to the 'else' statement.  GetSemanticInfoTests.cs 2269 <br><br>  Here is one example of an error in tests that can live in a project for years, as it does not bother anyone.  Just the test does not check everything that was planned.  In the beginning, stream 1 always starts, and then stream 2. Most likely, it was planned to write a test like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) { thread1.Start(); thread2.Start(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     thread2.Start(); thread1.Start(); }</span></span></code> </pre> <br>  <b>Error N2 in tests.</b>  <b>A typo.</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiagnosticAsyncToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( AsynchronousOperationListener listener, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, object tag, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filePath, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lineNumber)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(listener)</span></span></span><span class="hljs-function"> </span></span>{ Name = Name; Tag = tag; FilePath = filePath; LineNumber = lineNumber; StackTrace = PortableShim.StackTrace.GetString(); }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0403/">warning</a> : <a href="http://www.viva64.com/ru/d/0403/">V3005</a> The 'Name' variable is assigned to itself.  AsynchronousOperationListener.DiagnosticAsyncToken.cs 32 <br><br>  At a glance, an error here is very difficult to find.  Failed bad variable naming.  The class property names differ from the function arguments only by the first capital letter.  As a result, it's easy to make a typo, which is what happened: Name = Name. <br><br>  <b>Error N3, N4.</b>  <b>Copy-Paste.</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Task&lt;SyntaxToken&gt; GetNewTokenWithRemovedOrToggledPragmaAsync(....) { var result = isStartToken ? GetNewTokenWithPragmaUnsuppress( token, indexOfTriviaToRemoveOrToggle, _diagnostic, Fixer, isStartToken, toggle) : GetNewTokenWithPragmaUnsuppress( token, indexOfTriviaToRemoveOrToggle, _diagnostic, Fixer, isStartToken, toggle); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(result); }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0383/">warning</a> : <a href="http://www.viva64.com/ru/d/0383/">V3012</a> The '?:' Operator, regardless of the conditional expression.  AbstractSuppressionCodeFixProvider.RemoveSuppressionCodeAction_Pragma.cs 177 <br><br>  Regardless of the 'isStartToken' value, the GetNewTokenWithPragmaUnsuppress () function is called with the same set of actual arguments.  Most likely, the function call was duplicated using Copy-Paste, and then something was forgotten to be changed in the copied code. <br><br>  Here is another similar case: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplayDiagnostics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... _console.Out.WriteLine( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format((notShown == <span class="hljs-number"><span class="hljs-number">1</span></span>) ? ScriptingResources.PlusAdditionalError : ScriptingResources.PlusAdditionalError, notShown)); .... }</code> </pre> <br>  PVS-Studio warning: V3012 The '?:' Operator, regardless of its conditional expression, always returns the same value: ScriptingResources.PlusAdditionalError.  CommandLineRunner.cs 428 <br><br>  <b>Errors N5, N6.</b>  <b>Inattention.</b> <br><br>  I still have few statistics on typical errors that C # programmers allow.  But besides the standard typos, the following error pattern clearly begins to lead: often after bringing the link using the 'as' operator, the link is not obtained, but the original one.  Then use the unverified link.  Synthetic code: <br><pre> <code class="cpp hljs">var A = B as T; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (B) A.Foo();</code> </pre> <br>  And this is how this error looks in practice: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object obj)</span></span></span><span class="hljs-function"> </span></span>{ var d = obj as DiagnosticDescription; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj == null) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_code.Equals(d._code)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0388/">warning</a> : <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly an incorrect variable is compared to null after type conversion using 'as' keyword.  Check variables 'obj', 'd'.  DiagnosticDescription.cs 201 <br><br>  The following example is more verbose, but in reality everything is the same: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AreEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object other)</span></span></span><span class="hljs-function"> </span></span>{ var otherResourceString = other as LocalizableResourceString; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> other != null &amp;&amp; _nameOfLocalizableResource == otherResourceString._nameOfLocalizableResource &amp;&amp; _resourceManager == otherResourceString._resourceManager &amp;&amp; _resourceSource == otherResourceString._resourceSource &amp;&amp; .... }</code> </pre> <br>  PVS-Studio warning: V3019 Possibly an incorrect variable is compared to null after type conversion using 'as' keyword.  Check variables 'other', 'otherResourceString'.  LocalizableResourceString.cs 121 <br><br>  <b>Error N7.</b>  <b>Dual detection.</b> <br><br>  Sometimes there are 2 or even 3 warnings of the analyzer that indicate an error in the code.  Now we just consider this case. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasMatchingEndTag</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( XmlElementStartTagSyntax parentStartTag)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentStartTag == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } var parentElement = parentStartTag.Parent as XmlElementSyntax; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentStartTag == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } var endTag = parentElement.EndTag; .... }</code> </pre> <br>  PVS-Studio warnings: <ul><li>  <a href="http://www.viva64.com/ru/d/0388/">V3019</a> Possibly incorrectly variable conversion compared to null after type conversion using 'as' keyword.  Check variables 'parentStartTag', 'parentElement'.  XmlTagCompletionCommandHandler.cs 123 </li><li>  <a href="http://www.viva64.com/ru/d/0390/">V3021</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  This means that the statement is a senseless XmlTagCompletionCommandHandler.cs 117 </li></ul><br>  At the beginning of the function, it is checked that the argument 'parentStartTag' is not a null reference.  If it is zero, then the function exits. <br><br>  Then we wanted to check that the link actually points to a class like 'XmlElementSyntax'.  But at this moment there was a typo in the code.  Instead of checking the 'parentElement', the parentStartTag is re-checked. <br><br>  The analyzer notices two anomalies at once.  First anomaly: it makes no sense to re-check the value of 'parentStartTag', since if this is a zero reference, then we have already left the function.  The second anomaly: the analyzer suspects that the wrong variable is checked after the 'as' operator. <br><br>  The correct code is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentStartTag == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } var parentElement = parentStartTag.Parent as XmlElementSyntax; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parentElement == null) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  <b>Errors N8, N9.</b>  <b>Copy-Paste.</b> <br><br>  I apologize for the long code fragment, but I did not want to replace it with a synthetic example. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReportConflictWithParameter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newSymbolKind == SymbolKind.Parameter || newSymbolKind == SymbolKind.Local) { diagnostics.Add(ErrorCode.ERR_LocalSameNameAsTypeParam, newLocation, name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newSymbolKind == SymbolKind.TypeParameter) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newSymbolKind == SymbolKind.Parameter || newSymbolKind == SymbolKind.Local) { diagnostics.Add(ErrorCode.ERR_LocalSameNameAsTypeParam, newLocation, name); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0390/">warning</a> : <a href="http://www.viva64.com/ru/d/0390/">V3021</a> There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  If this statement is a senseless InMethodBinder.cs 264 <br><br>  In the code snippet given in the article, the first and third if statements are the same.  Apparently the block was copied, and then they forgot to change something in it.  Although it is possible, the repeated 'if' is just superfluous and should be removed. <br><br>  There is one more similar code section, but I will not torment the reader with a long example.  Just give a diagnostic warning: <br><br>  V3021 There are two 'if' statements with identical conditional expressions.  The first 'if' statement contains method return.  If 'statement is senseless WithLambdaParametersBinder.cs 131 <br><br>  <b>Error N10.</b>  <b>Invalid condition.</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TypeCode { .... Object = <span class="hljs-number"><span class="hljs-number">1</span></span>, .... DateTime = <span class="hljs-number"><span class="hljs-number">16</span></span>, .... } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> object GetHostObjectValue(Type lmrType, object rawValue) { var typeCode = Metadata.Type.GetTypeCode(lmrType); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (lmrType.IsPointer || lmrType.IsEnum || typeCode != TypeCode.DateTime || typeCode != TypeCode.Object) ? rawValue : null; }</code> </pre> <br>  PVS-Studio Warning: <a href="http://www.viva64.com/ru/d/0391/">V3022</a> Expression 'lmrType.IsPointer ||  lmrType.IsEnum ||  typeCode! = TypeCode.DateTime ||  typeCode! = TypeCode.Object 'is always true.  DkmClrValue.cs 136 <br><br>  The expression is quite complicated, so I will highlight the main essence: <br><pre> <code class="cpp hljs">(typeCode != <span class="hljs-number"><span class="hljs-number">1</span></span> || typeCode != <span class="hljs-number"><span class="hljs-number">16</span></span>)</code> </pre> <br>  This expression is always true, regardless of the value of the 'typeCode' variable. <br><br>  <b>Error N11.</b>  <b>Excess condition.</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EventCommand { Disable = <span class="hljs-number"><span class="hljs-number">-3</span></span>, Enable = <span class="hljs-number"><span class="hljs-number">-2</span></span>, SendManifest = <span class="hljs-number"><span class="hljs-number">-1</span></span>, Update = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> override <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OnEventCommand( EventCommandEventArgs command) { base.OnEventCommand(command); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (command.Command == EventCommand.SendManifest || command.Command != EventCommand.Disable || FunctionDefinitionRequested(command)) .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0411/">warning</a> : <a href="http://www.viva64.com/ru/d/0411/">V3023</a> Consider inspecting this expression.  The expression is misprint.  RoslynEventSource.cs 79 <br><br>  I will once again highlight the essence: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A == <span class="hljs-number"><span class="hljs-number">-1</span></span> || A != <span class="hljs-number"><span class="hljs-number">-3</span></span>)</code> </pre> <br>  This expression is either erroneous or redundant.  It can be reduced to: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A != <span class="hljs-number"><span class="hljs-number">-3</span></span>)</code> </pre> <br>  <b>Error N12 when logging.</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompilerServerLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... loggingFileName = Path.Combine(loggingFileName, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"server.{1}.{2}.log"</span></span>, loggingFileName, GetCurrentProcessId(), Environment.TickCount)); .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0392/">warning</a> : <a href="http://www.viva64.com/ru/d/0392/">V3025</a> Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 2. Present: 3. CompilerServerLogger.cs 49 <br><br>  The variable 'loggingFileName' is not used in any way when calling the Format () function.  This is suspicious. <br><br>  <b>Error N13 in the error handler.</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> WriteFileExceptionMessage = @<span class="hljs-string"><span class="hljs-string">"{1} To reload the Roslyn compiler package, close Visual Studio and any MSBuild processes, then restart Visual Studio."</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteMSBuildFiles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { VsShellUtilities.ShowMessageBox( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(WriteFileExceptionMessage, e.Message), null, OLEMSGICON.OLEMSGICON_WARNING, OLEMSGBUTTON.OLEMSGBUTTON_OK, OLEMSGDEFBUTTON.OLEMSGDEFBUTTON_FIRST); } }</code> </pre> <br>  PVS-Studio warning: V3025 Incorrect format.  A different number of formatted items is expected while calling 'Format' function.  Expected: 2. Present: 1. CompilerPackage.cs 105 <br><br>  Apparently, when you try to show the Message Box, an exception will be generated.  The point is that the Format () function will try to print the second additional argument.  And it is not. <br><br>  It seems to me that the constant string specifying formatting should start with: <br><pre> <code class="cpp hljs">@<span class="hljs-string"><span class="hljs-string">"{0}</span></span></code> </pre> <br>  <b>Error N14, N15 in the error handler.</b> <br><br>  I‚Äôm willing to bet that the DumpAttributes () function is not being used yet.  It has 2 errors at once, each of which should lead to an exception being thrown: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DumpAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Symbol s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; foreach (var sa in s.GetAttributes()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; foreach (var pa in sa.CommonConstructorArguments) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0} {1} {2}"</span></span>, pa.ToString()); j += <span class="hljs-number"><span class="hljs-number">1</span></span>; } j = <span class="hljs-number"><span class="hljs-number">0</span></span>; foreach (var na in sa.CommonNamedArguments) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"{0} {1} {2} = {3}"</span></span>, na.Key, na.Value.ToString()); j += <span class="hljs-number"><span class="hljs-number">1</span></span>; } i += <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br>  PVS-Studio warnings: <ul><li>  V3025 Incorrect format.  A different number of items is expected while calling the 'WriteLine' function.  Expected: 3. Present: 1. LoadingAttributes.cs 551 </li><li>  V3025 Incorrect format.  A different number of items is expected while calling the 'WriteLine' function.  Expected: 4. Present: 2. LoadingAttributes.cs 558 </li></ul><br>  In both cases, the call to the WriteLine () function is passed to it with fewer actual arguments than required.  As a result, FormatException exceptions should occur. <br><br>  <b>Error N16.</b>  <b>Dangerous expression.</b> <br><br>  I am sure that now you look at the following code fragment and do not want to understand it.  This well shows how tireless code analyzers are useful. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SymbolsAreCompatibleCore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var type = methodSymbol.ContainingType; var newType = newMethodSymbol.ContainingType; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((type != null &amp;&amp; type.IsEnumType() &amp;&amp; type.EnumUnderlyingType != null &amp;&amp; type.EnumUnderlyingType.SpecialType == newType.SpecialType) || (newType != null &amp;&amp; newType.IsEnumType() &amp;&amp; newType.EnumUnderlyingType != null &amp;&amp; newType.EnumUnderlyingType.SpecialType == type.SpecialType)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  PVS-Studio Warning: <a href="http://www.viva64.com/ru/d/0414/">V3027</a> The variable "newType" was used for the same logical expression.  AbstractSpeculationAnalyzer.cs 383 <br><br>  To clarify the danger of the code, I will create on its basis a simple synthetic example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((A != null &amp;&amp; Ax == By) || (B != null &amp;&amp; Bq == Aw))</code> </pre> <br>  As you can see, it is implied that A and B can be null links.  The expression consists of two parts.  In the first part, reference A is verified, but reference B is not verified. In the second part, reference B is verified, but reference A is not verified. <br><br>  Perhaps the code works because of luck, but it looks very suspicious and dangerous. <br><br>  <b>Errors N17, N18.</b>  <b>Repeat assignments.</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stringize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Diagnostic e)</span></span></span><span class="hljs-function"> </span></span>{ var retVal = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.Location.IsInSource) { retVal = e.Location.SourceSpan.ToString() + <span class="hljs-string"><span class="hljs-string">": "</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.Location.IsInMetadata) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"metadata: "</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"no location: "</span></span>; } retVal = e.Severity.ToString() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + e.Id + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.GetMessage(CultureInfo.CurrentCulture); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retVal; }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0395/">warning</a> : <a href="http://www.viva64.com/ru/d/0395/">V3008</a> The 'retVal' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 324, 313. DiagnosticExtensions.cs 324 <br><br>  Notice that in one of the branches of the 'if' operator, the variable 'retVal' is assigned a value.  However, at the end of the function, the value of the variable 'retVal' is overwritten.  I'm not sure, but maybe the last assignment should be: <br><pre> <code class="cpp hljs">retVal = retVal + e.Severity.ToString() + <span class="hljs-string"><span class="hljs-string">" "</span></span> + e.Id + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.GetMessage(CultureInfo.CurrentCulture);</code> </pre> <br>  Consider another similar case: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMethodsInDocument</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ISymUnmanagedDocument document, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bufferLength, out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bufferLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... count = actualCount; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { count = extentsByMethod.Length; } count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HResult.S_OK; }</code> </pre> <br>  PVS-Studio warning: V3008 The 'count' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 317, 314. SymReader.cs 317 <br><br>  The function returns the value by reference 'count'.  Different values ‚Äã‚Äãare written to 'count' in different parts of the function.  Suspiciously, at the end of the function in the 'count', suddenly it is always written 0. Very strange. <br><br>  <b>Error N19 in tests.</b>  <b>A typo.</b> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">internal </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifySemantics</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (additionalOldSources != null) { oldTrees = oldTrees.Concat( additionalOldSources.Select(s =&gt; ParseText(s))); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (additionalOldSources != null) { newTrees = newTrees.Concat( additionalNewSources.Select(s =&gt; ParseText(s))); } .... }</code> </pre> <br>  PVS-Studio <a href="http://www.viva64.com/ru/d/0418/">warning</a> : <a href="http://www.viva64.com/ru/d/0418/">V3029</a> The conditional expressions of the 'if' are agreed alongside each other are identical.  Check lines: 223, 228. EditAndContinueTestHelpers.cs 223 <br><br>  In the second condition, it was necessary to check not 'additionalOldSources', but 'additionalNewSources'.  If the link 'additionalNewSources' suddenly turns out to be zero, then an exception will be thrown when you try to call the Select () function. <br><br>  <b>Error N20.</b>  <b>Of controversial.</b> <br><br>  Naturally, in the article I did not understand all the warnings that the PVS-Studio analyzer issued.  There are a lot of obviously false positives, but even more situations where I simply have no knowledge of the Roslyn project to judge whether the code contains an error or not.  Consider one of these cases. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SyntaxTrivia </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Whitespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Syntax.InternalSyntax.SyntaxFactory.Whitespace( text, elastic: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> SyntaxTrivia </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ElasticWhitespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Syntax.InternalSyntax.SyntaxFactory.Whitespace( text, elastic: <span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br>  <a href="http://www.viva64.com/ru/d/0389/">V3013</a> It is odd that the body of the "Whitespace" function is fully equivalent (118, line 129).  SyntaxFactory.cs 118 <br><br>  Two functions have identical bodies.  This is suspicious from the point of view of the analyzer.  These functions are suspicious to me too.  But I do not know the project, and, probably, the code is written absolutely correctly.  Therefore, I will only make a guess.  Perhaps inside the ElasticWhitespace () function, use the actual 'elastic' parameter equal to 'true'. <br><br>  <b>Error nxx.</b> <br><br>  I hope the readers understand that I cannot understand in detail with each such case, as was shown above.  I check many projects and I don‚Äôt know each of them.  Therefore, I describe in the articles only the most obvious mistakes.  In this article, I stopped at 20 such cases.  However, I think PVS-Studio was able to detect many more defects.  Therefore, I suggest that Roslyn developers not only rely on this article, but check the project themselves.  For this demo version of the analyzer will not be enough, but we are ready to provide a license key for the time being. <br><br><h2>  Comparison with ReSharper </h2><br>  I have written quite a few articles about checking C # projects and spoke at only one conference.  But I already understood that every time a question will be asked: ‚ÄúDo you have a comparison with ReSharper?‚Äù. <br><br>  I do not like this question for two reasons.  First, it is still a different type of tools.  PVS-Studio is a classic code analyzer focused on finding errors.  ReSharper is a Productivity Tool designed to facilitate programming and able to give a large number of recommendations. <br><br>  PVS-Studio and ReSharper have completely different approaches on many issues.  See, for example, PVS-Studio has <a href="http://www.viva64.com/ru/d/">documentation</a> with a detailed <a href="http://www.viva64.com/ru/d/0368/">description of</a> each diagnostic, examples, and tips for correcting the code.  In the case of ReSharper there is a <a href="https://www.jetbrains.com/resharper/help/Code_Analysis__Index.html">statement</a> about ‚Äú1400 code inspections in C #, VB.NET, XAML, XML, ASP.NET, ASP.NET MVC, Razor, JavaScript, TypeScript, HTML, CSS, ResX‚Äù.  The number 1400 looks solid, but in fact does not say anything.  Perhaps somewhere and there is a description of all these code inspection, but immediately I could not find it.  How can I compare a tool if I can't even read about exactly what errors ReSharper finds in C # programs. <br><br>  Secondly, any comparison we make will be completely criticized.  We have already passed this and have committed to continue to make any comparisons.  For example, we carefully approached the comparison of PVS-Studio with Cppcheck and Visual Studio SCA.  Was spent a lot of time and effort.  The results were presented in a <a href="http://www.viva64.com/ru/b/0241/">brief</a> and <a href="http://www.viva64.com/ru/a/0086/">detailed</a> version.  After that, only the lazy one did not write that we did everything wrong, or that our comparison is dishonest thanks to specially selected projects for verification. <br><br>  We do not see the point of spending time on comparison.  No matter how carefully and honestly we approached him, one can always say that the comparison was biased. <br><br>  Nevertheless, the answer must be whether we are better at something than ReSharper.  And I have that answer. <br><br>  <b>Are you already using ReSharper?</b>  <b>Fine!</b>  <b>Now install PVS-Studio and find errors in your project!</b> <br><br><h2>  Conclusion </h2><br>  I offer to immediately <a href="http://www.viva64.com/ru/pvs-studio-download/">download</a> PVS-Studio and test your project.  See the mistakes?  But you have quite a working code.  Most likely the errors found are located in rarely used parts of the code.  In frequently used parts of the code, such errors, though slow and painful, have been fixed.  Imagine now how much PVS-Studio analyzer could save with regular use.  Of course, the analyzer is able to find far from all errors.  But than to spend time looking for typos and blunders, it is better to spend it with benefit.  And give the stupid mistakes to the mercy of PVS-Studio. <br><br>  PS You do not make stupid mistakes?  Oh well.  It only <a href="http://www.viva64.com/ru/b/0116/">seems that way</a> .  Everybody does.  Look at least <a href="http://www.viva64.com/ru/examples/V501/">here</a> . <br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0363/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Andrey Karpov.  <a href="http://www.viva64.com/en/b/0363/">New Year PVS-Studio 6.00 Release: Scanning Roslyn</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/273811/">https://habr.com/ru/post/273811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273801/index.html">A new version of LinqTestable has been released - libraries for testing requests to the database via ORM</a></li>
<li><a href="../273803/index.html">IBM FlashSystem 900 storage system overview</a></li>
<li><a href="../273805/index.html">Zabbix + SoapUI = monitoring web services</a></li>
<li><a href="../273807/index.html">Parse HTML in .NET and Survive: Analyzing and Comparing Libraries</a></li>
<li><a href="../273809/index.html">Comparison of free software accounting traffic SQUID</a></li>
<li><a href="../273813/index.html">Balancing traffic between two NATs on different providers on the same cisco physical router</a></li>
<li><a href="../273815/index.html">A bit about container virtualization</a></li>
<li><a href="../273817/index.html">7 games in 7 days: rewarded video</a></li>
<li><a href="../273819/index.html">Electronic board of the bank and EDS: integration experience</a></li>
<li><a href="../273823/index.html">New 3CX Phone v14 client details</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>