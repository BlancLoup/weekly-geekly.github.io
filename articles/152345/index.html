<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WebServer as a test task</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How it all began 
 Despite the fact that my work is currently related to desktop applications, I was recently interested in ‚Äúserver technologies‚Äù. Som...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WebServer as a test task</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage2/1be/d1d/02c/1bed1d02c8c5763a05de3cf733e4d021.png"><h4>  How it all began </h4><br>  Despite the fact that my work is currently related to desktop applications, I was recently interested in ‚Äúserver technologies‚Äù.  Some surfing the Internet, reading man's and trying to write something server-like for yourself is all that has been done lately, as there is no clear goal.  Having come up with an interesting task for yourself, it‚Äôs not a bad thing to raise your skill level. <br><br>  At one point, when I finally got bored at work from a routine, I put a check in one of the well-known job search resources, which is not against looking at the market, all of a sudden, something interesting will fall ... As a result, a certain number of job offers, on the topic: "Perhaps this will interest you."  Among such proposals and a proposal came with a test task.  The test task is to write a WebServer in C ++ for Linux with the implementation of the HTTP protocol;  simple ... <br><a name="habracut"></a><br>  Taking the phrase from the test task and typing it into Google, I found more reviews about such a not very short test task on the <a href="">RSDN</a> forum.  The task was one to one in my mailer.  As a task to perform it did not.  The principle is simple: if the test task is worth performing, then it should be no more than 4 hours of working time calculated.  But to try everything that was read and tested in places was interesting.  This became a stimulus, i.e.  setting an interesting problem.  I cannot say to which office this task belongs to, since it came from a personnel agency, but this is not so important. <br><br>  This article will look at the approaches and the corresponding APIs that I have found on this topic.  I will give several implementations of WebServer using different approaches and tools, and comparative testing of the obtained ‚Äúhandicrafts‚Äù has been conducted.  The article is not designed for "bearded" server-writers, but as a review people who have encountered similar tasks (not only in tests) may well be useful.  I will be glad to have constructive comments from everyone, especially from the ‚Äúbearded‚Äù server-writers, since writing an article is not only sharing my experience, but, quite possibly, replenishing it for myself ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  API and Library Overview </h4><br>  The result of consideration of server-description tools became API of * nix systems, Windows API (why not see, although this platform is not used for this task) and libraries such as boost.asio and libevent. <br><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BE%25D0%25BA%25D0%25B5%25D1%2582%25D1%258B_%25D0%2591%25D0%25B5%25D1%2580%25D0%25BA%25D0%25BB%25D0%25B8">The Berkeley sockets,</a> although a universal, portable mechanism, are not entirely unambiguously portable.  So in some platforms close to close the socket, and in some closesocket;  some need to initialize the library (Windows - WSAStartup / WSACleanup), some do not;  somewhere the socket descriptor is int, and somewhere is SOCKET and other minor differences.  It turns out, if you do not use any approaches of cross-platform programming such as pImpl and others, then the same code will not work, and often, it will be the same on different platforms.  All these little things are hidden in libraries like <a href="http://www.boost.org/doc/libs/1_51_0/doc/html/boost_asio.html">boost.asio</a> , <a href="http://libevent.org/">libevent</a> and similar.  In addition, such libraries use the more specific API methods of the respective platform to implement the most optimal work with sockets, providing the user with a convenient interface without hints on the platform. <br><br>  If you take a very generalized server operation, you get the following sequence of actions: <br><ol><li>  Create socket </li><li>  Bind a socket to a network interface </li><li>  Listen to a socket bound to a specific network interface. </li><li>  Accept incoming connections </li><li>  Respond to events occurring on sockets </li></ol><br>  All items, except the fifth, are relatively similar and of little interest, but the response mechanisms for events occurring on the socket are many and most of them are specific to each platform. <br><br>  If you look at Windows, you can see the following methods: <br><ol><li>  Use select.  Mainly for compatibility with the code of other platforms, he has no more advantages here. </li><li>  WSAAsyncSelect - Intended for window applications to send events on a socket to a window queue.  Not fast and is unlikely to be interesting as a server code mechanism. </li><li>  WSAEventSelect work with the object "event" on the network interface.  Already more attractive tool.  Those.  if you plan a server for no more than hundreds of simultaneously serviced connections, then this is the most optimal mechanism by the criterion of speed / speed of development. </li><li>  Overlapped I / O is a faster mechanism than WSAEventSelect, but also more laborious in development. </li><li>  I / O completion ports - for high-load server applications. </li></ol><br>  There is an excellent book on the development of network software for Windows - "Programming in Microsoft Windows networks". <br><br>  Now, if you look at the * nix state, then there is also no small set of event selectors: <br><ol><li>  Same select.  And again his role is compatibility with other platforms.  It is also not fast, since it is triggered (returns) when an event occurs on any of the sockets it oversees.  After such a trigger, you need to run through all and see which of the sockets the event occurred.  To summarize: one actuation is the mileage across the entire pool of monitored sockets. </li><li>  poll is a faster mechanism, but is not designed for a large number of sockets for monitoring. </li><li>  epoll (Linux systems) and kqueue (FreeBSD) are roughly the same mechanisms, but vehement FreeBSD fans in some forums very fervently say that kqueue is much more powerful.  We will not kindle the holy war ... These mechanisms can be considered essential when writing high-loaded server applications in * nix systems.  If we describe briefly their principle of operation and its dignity - they return a certain amount of information relating only to those sockets on which something happened and do not need to run around and check what happened where.  Also, these mechanisms are designed for a larger number of simultaneously serviced connections. </li></ol><br>  In addition to the functions for waiting for events, there are some small but very useful things on descriptors: <br><ol><li>  sendfile (Linux) and TransmitFile (Windows) allow you to feed them a pair of descriptors from where and where to send data.  A very useful thing in HTTP servers when you need to transfer files, as it eliminates buffer allocation and call read / write functions, which has a positive effect on performance. </li><li>  aio - allows you to shift a certain amount of work to the operating system, as it allows you to perform asynchronous operations on the file descriptor.  For example, tell the system that you have a buffer, write it here in this file descriptor, when you finish the signal (similar to reading). </li><li>  Nagle's algorithm is a useful thing when writing applications that need to send data to the network in small portions and without delays in buffering, but it is not always useful.  In applications such as HTTP server, it is better to tell the system, on the contrary, that it buffer outgoing data and send TCP frames with useful information (for this you can use the socket option TCP_CORK). </li><li>  And of course, non-blocking sockets.  No comments... </li><li>  There are also functions such as writev (nix) (and similar Windows WSA functions) that allow you to send several buffers at once, which is useful when you need to send an HTTP packet header and data attached to it and at the same time save on the number of system calls. </li></ol><br>  About the use of libraries, it is better to say the code for the beginning, which will be done below with examples boost.asio and libevent.  boost.asio greatly simplifies the development of network applications, libevent is a server classic. <br><br><h4>  Implementation on epoll </h4><br>  Whichever mechanism is chosen to respond to epoll network events, poll, select, there are still many other nuances. <br><br>  One of the very first questions in the implementation of a multi-threaded server is the choice of the number of threads.  Most of those who once had to quickly assemble their ‚Äúserver on sockets‚Äù for training or pseudo-combat purposes, chose the strategy ‚ÄúOne connection - one stream‚Äù.  In this approach, there are both pluses and minuses.  The biggest plus is the ease of development.  There are a lot of minuses: a large amount of system resources spent, a lot of synchronization actions (code, something with something synchronizing).  However, this approach is not bad for the HTTP server in terms of synchronization, since there are no special intersections between sessions.  But, despite the simplicity of development, I did not consider this strategy for my implementation.  There are different recommendations on the optimal choice of the number of threads - this is the number of processors / processor cores in the system, the same number, but with a certain coefficient.  In the proposed implementation, the number of worker threads is an optional parameter set by the user when the server starts.  For myself, it was decided that the number of worker threads is equal to the number of processors / cores multiplied by two. <br>  In the current context, a workflow is a flow that processes user requests.  In addition to these flows, two more were involved: the listening thread and the main one.  Listening thread - listens to the server socket and accepts incoming connections, then they are placed in the queue for processing to workflows.  The main thread starts the server and waits for a certain action from the user to stop it. <br><br>  The second question that interested me in the implementation of this example is in which threads and how to handle network events when using an epoll.  The first thing that occurred to me was to react to all events monitored by an epoll in one thread, and to process them in other threads (workers), transferring them there via a certain queue.  Those.  one stream tracks both incoming events on the listening socket, and data arrival events on the received connections and connection closing events.  Received an event, put it in a queue, signaled to workflows, workflows called accept to accept a new connection, added observable sockets to the pool of epoll, read, write and close for connections.  The decision is erroneous, since while one event is being processed, say, reading data from a socket, the socket closure event may already be on the socket.  Of course, the reading will end with an error, but it will not come immediately to the actions to clean up all the resources related to the connection, but only when this event is read from the queue.  Many events on closing of a socket simply were lost in my implementation.  The implementation became more difficult, the number of synchronization places grew and under strange conditions there were drops.  Falls were for a different reason.  With each socket in the epoll-event structure as user data, a pointer was attached to the session object, which was responsible for all the work with the client until it was closed.  Since the sequence of event processing became more complicated, hence the fall, since the object bound as user data has already been deleted (for example, when closing a session not by an outside event, but by the logic of the session itself), there was also an event in the queue handled with already broken pointer.  Having received some such experience ‚Äúon rakes‚Äù from the first idea that came up, a different strategy was adopted: the main listener stream through the epoll responds only to events of the listening socket, accepts incoming connections and, if their number is more than allowed for the waiting queue, then closes them , otherwise places received connections into a queue for processing;  worker threads read this queue and put this socket into their epoll suite, which they are watching.  It turns out that workflows work with their epoll descriptor and everything is done within one flow: placement in the epoll, reaction to data arrival events, read / write, close (deletion from the epoll occurs automatically at the system level when the descriptor closes) .  As a result of such an organization, there is only one synchronization primitive for protecting the queue of incoming connections.  On the one hand, only the listening thread writes to this queue, and on the other hand, the working threads from the selected connections are selected from it.  One less problem.  It remains to abandon the binding of the pointer to the session object with the user data of the epoll structure.  Solution: use an associative array;  key is a socket descriptor, data is a session object.  This allows you to work with sessions not only when an event arrives, when we have the opportunity to get user data from an epoll event, but also when, according to some logic, it is necessary, for example, to close some connections by timeout (a pool of connections is available). <br><br>  The first version, written entirely in a single file and in the style of a C # / Java developer (without separating ads and definitions), turned out to be more than 1800 lines of code.  Too much for a test task, despite the fact that the implementation of the HTTP protocol is minimal, the very minimum for processing GET / HEAD without anything else and with a minimum of processing the parameters of the HTTP header.  That's not the point.  I‚Äôll make a reservation once again that the test task was just a ‚Äúkick‚Äù to try something.  The main interest for me in this solution was not the implementation of the HTTP protocol, but the implementation of a multi-threaded server, connection and session management (a session can be understood as a logical data structure with a processing algorithm associated with the connection). <br>  Having broken this monstrous file and sometimes combed the implementation, this is what I did: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCPServer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Common::NonCopyable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TCPServer(InetAddress <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;locAddr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> backlog, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxThreadsCount, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxConnectionsCount, UserSessionCreator sessionCreator); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Common::IDisposable&gt; IDisposablePtr; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;IDisposablePtr&gt; IDisposablePool; Private::ClientItemQueuePtr AcceptedItems; IDisposablePool Threads; };</code> </pre> <br>  This is perhaps the shortest implementation of the server class that I had to write.  This class only creates a few threads: the listener and a few workers, and is their holder. <div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="cpp hljs">TCPServer::TCPServer(InetAddress <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;locAddr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> backlog, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxThreadsCount, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxConnectionsCount, UserSessionCreator sessionCreator) : AcceptedItems(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Private::ClientItemQueue(backlog)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EventsCount = maxConnectionsCount / maxThreadsCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> ; i &lt; maxThreadsCount ; ++i) { Threads.push_back(IDisposablePtr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Private::WorkerThread( EventsCount + (i &lt;= maxThreadsCount - <span class="hljs-number"><span class="hljs-number">1</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : maxConnectionsCount % maxThreadsCount), AcceptedItems ))); } Threads.push_back(IDisposablePtr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Private::ListenThread(locAddr, backlog, AcceptedItems, sessionCreator))); }</code> </pre></div></div>  also not great.  Both classes like <div class="spoiler">  <b class="spoiler_title">listening stream</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ListenThread</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TCPServerSocket , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Common::IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ListenThread(InetAddress <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;locAddr, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> backlog, ClientItemQueuePtr acceptedClients, UserSessionCreator sessionCreator) : TCPServerSocket(locAddr, backlog) , AcceptedClients(acceptedClients) , SessionCreator(sessionCreator) , Selector(<span class="hljs-number"><span class="hljs-number">1</span></span>, WaitTimeout, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::bind(&amp;ListenThread::OnSelect, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::placeholders::_1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::placeholders::_2)) { Selector.AddSocket(GetHandle(), Network::ISelector::stRead); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { WaitTimeout = <span class="hljs-number"><span class="hljs-number">100</span></span> }; ClientItemQueuePtr AcceptedClients; UserSessionCreator SessionCreator; SelectorThread Selector; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSelect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SocketHandle handle, Network::ISelector::SelectType selectType)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,  -      } };</span></span></code> </pre></div></div>  so and <div class="spoiler">  <b class="spoiler_title">workflows</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkerThread</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Common::NonCopyable , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Common::IDisposable { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WorkerThread(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxEventsCount, ClientItemQueuePtr acceptedClients) : MaxConnections(maxEventsCount) , AcceptedClients(acceptedClients) , Selector(maxEventsCount, WaitTimeout, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::bind(&amp;WorkerThread::OnSelect, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::placeholders::_1, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::placeholders::_2), SelectorThread::ThreadFunctionPtr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectorThread::ThreadFunction(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::bind( &amp;WorkerThread::OnIdle, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)))) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { WaitTimeout = <span class="hljs-number"><span class="hljs-number">100</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;SocketHandle, ClientItemPtr&gt; ClientPool; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> MaxConnections; ClientItemQueuePtr AcceptedClients; ClientPool Clients; SelectorThread Selector; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSelect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SocketHandle handle, Network::ISelector::SelectType selectType)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,      ( ,  ,  ) } void OnIdle() { //   .         -  epoll. } };</span></span></code> </pre> </div></div>  use the event flow class <div class="spoiler">  <b class="spoiler_title">SelectThread</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SelectorThread</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EPollSelector , <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> System::ThreadLoop { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EPollSelector::AddSocket; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> System::Thread::ThreadFunction ThreadFunction; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tr1::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;ThreadFunction&gt; ThreadFunctionPtr; SelectorThread(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxEventsCount, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> waitTimeout, ISelector::SelectFunction onSelectFunc, ThreadFunctionPtr idleFunc = ThreadFunctionPtr()); <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~SelectorThread(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISelector::SelectFunction &amp;func, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waitTimeout, ThreadFunctionPtr idleFunc)</span></span></span></span>; };</code> </pre> </div></div>  .  This thread uses <div class="spoiler">  <b class="spoiler_title">EPollSelector</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EPollSelector</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Common::NonCopyable , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISelector { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EPollSelector(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxSocketCount); ~EPollSelector(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSocket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SocketHandle handle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> selectType)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Select</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SelectFunction *function, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;epoll_event&gt; EventPool; EventPool Events; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EPoll; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSelectFlags</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> selectType)</span></span></span></span>; };</code> </pre> </div></div>  for organizing reactions to events occurring on the descriptors of the accepted compounds. <br>  If you look at the original server class, you can see that the last parameter is the functor for creating classes ‚Äî user sessions.  User session is an interface implementation. <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IUserSession</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IUserSession() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IConnectionCtrl *ctrl)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetMaxBufSizeForRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsExpiredSession</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">time_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lastActionTime)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRecvData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnIdle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre>  Depending on the implementation of this interface, you can implement different protocols.  The Init and Done methods are called at the beginning of the session and at its completion, respectively.  GetMaxBufSizeForRead should return the maximum buffer size that will be allocated during data read operations.  The read data comes in OnRecvData.  In order for the session to say that it has expired in time, you need to implement the IsExpiredSession in an appropriate way.  OnIdle is called between any actions, here the session implementation can perform some background actions and mark itself as intended to be closed via the interface <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IConnectionCtrl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IConnectionCtrl() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MarkMeForClose</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateSessionTime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytes)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileHandle, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytes)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> InetAddress </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> SocketTuner </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSocketTuner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  The IConnectionCtrl interface is sent so that the user session can send data to the network (SendData and SendFile methods), mark itself as intended for closing (MarkMeForClose method), say that it is alive (UpdateSessionTime method; updates the time that comes to IsExpiredSession), the session can also receive the address of the incoming connection (GetAddress method) and the SocketTuner object for the socket settings ‚Äî the current connection (GetSocketTuner method). <br>  The HTTP protocol implementation is in the HttpUserSession class.  As I said above, the HTTP implementation was not the most interesting and priority for me, so I didn‚Äôt think much about it;  I thought as much as I had to write what happened :) <br><br><h4>  Implementation on libevent </h4><br>  The implementation on libevent is a favorite for me.  This library allows you to organize asynchronous I / O and hide from the developer many of the subtleties of network programming.  Allows you to implement work with raw data, hanging up callback functions for receiving, sending data and other events, sending data asynchronously.  In addition to low-level data manipulation, there are higher-level protocols.  libevent has a built-in HTTP server, which makes it possible to abstract from the analysis of request headers and the formation of the same response headers.  It is possible to implement RPC means of the library and other features. <br>  If you implement an HTTP server using the built-in, the sequence will be something like this: <br><ol><li>  Create some basic object by calling event_base_new (there is also a simplified for simpler cases - event_init).  A pair function to remove an object is event_base_free. </li><li>  Create an HTTP engine object by calling evhttp_new.  A pair function to remove the evhttp_free object. </li><li>  You can specify the methods that the server will support using the evhttp_set_allowed_methods function with a combination of flags.  So, for example, to support only the GET method, it would look something like this: evhttp_set_allowed_methods (Http, EVHTTP_REQ_GET), where Http is the descriptor created in step (2). </li><li>  Set a callback function to handle incoming requests by calling evhttp_set_gencb. </li><li>  Associate a listening socket with an instance of an HTTP server object by calling evhttp_accept_socket.  A listening socket can be created and configured through all the same socket / bind / listen. </li><li>  Start the event loop by calling the event_base_loop function.  There is a simplified version - event_base_dispatch.  event_base_loop needs to be called in a loop.  This function either does something useful in the bowels of the library, whence calls to the installed callback functions come from, or when there is nothing to do it returns control and something useful can be done at this moment;  also gives you the ability to more easily manage the life cycle of the message processing. </li><li>  In the request handler, you can send some text data by calling the evbuffer_add_printf function or give the file descriptor to the library and let it send it by calling evbuffer_add_file.  These functions work with some buffer object that you can create yourself (and not forget to delete it in time) or use the query field: evhttp_request :: output_buffer.  The beauty is that these functions are asynchronous, i.e.  in the example with sending the file, you can give the file descriptor of the same evbuffer_add_file and it will return control, and after the file has been sent, close the file itself. </li></ol><br>  Everything turns out very nicely in one thread, but as it turned out, making a multi-threaded server is also not difficult.  If you use boost :: thread or your cross-platform class that encapsulates the work flow, or something similar, you can get a fully cross-platform solution, since the libevent cross-platform library.  In my own implementation, I will take some wrapper just above the threads for Linux.  But it is not so important. <br>  The main thread for each workflow must create its own descriptors  perform steps 1-5.  Workflows need only twist message processing cycles - step 6. Step 7 will be performed in each workflow.  To summarize, we can say: we create one listening socket and impose its processing on several worker threads. <br>  So in my implementation, given that I already have some primitives ready for streams, files, and command line parsing, I‚Äôve got an HTTP server with support for only the GET method of about 200 lines in the C # / Java style.  Such a reduction in the work of writing code with the presence of complete control of what is happening can not but rejoice.  In addition, subjectively, the resulting server runs a little faster, but let's look at the tests at the end ... <br><div class="spoiler">  <b class="spoiler_title">Implementing HTTP server on libevent</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;event.h&gt; #include &lt;evhttp.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;tr1/functional&gt; #include &lt;tr1/memory&gt; #include "tcp_server_socket.h" #include "inet_address_v4.h" #include "thread.h" #include "command_line.h" #include "logger.h" #include "file_holder.h" namespace Network { namespace Private { DECLARE_RUNTIME_EXCEPTION(EventBaseHolder) class EventBaseHolder : private Common::NonCopyable { public: EventBaseHolder() : EventBase(event_base_new()) { if (!EventBase) throw EventBaseHolderException("Failed to create new event_base"); } ~EventBaseHolder() { event_base_free(EventBase); } event_base* GetBase() const { return EventBase; } private: event_base *EventBase; }; DECLARE_RUNTIME_EXCEPTION(HttpEventHolder) class HttpEventHolder : public EventBaseHolder { public: typedef std::tr1::function&lt;void (char const *, evbuffer *)&gt; RequestHandler; HttpEventHolder(SocketHandle sock, RequestHandler const &amp;handler) : Handler(handler) , Http(evhttp_new(GetBase())) { evhttp_set_allowed_methods(Http, EVHTTP_REQ_GET); evhttp_set_gencb(Http, &amp;HttpEventHolder::RawHttpRequestHandler, this); if (evhttp_accept_socket(Http, sock) == -1) throw HttpEventHolderException("Failed to accept socket for http"); } ~HttpEventHolder() { evhttp_free(Http); } private: RequestHandler Handler; evhttp *Http; static void RawHttpRequestHandler(evhttp_request *request, void *prm) { reinterpret_cast&lt;HttpEventHolder *&gt;(prm)-&gt;ProcessRequest(request); } void ProcessRequest(evhttp_request *request) { try { Handler(request-&gt;uri, request-&gt;output_buffer); evhttp_send_reply(request, HTTP_OK, "OK", request-&gt;output_buffer); } catch (std::exception const &amp;e) { evhttp_send_reply(request, HTTP_INTERNAL, e.what() ? e.what() : "Internal server error.", request-&gt;output_buffer); } } }; class ServerThread : private HttpEventHolder , private System::Thread { public: ServerThread(SocketHandle sock, std::string const &amp;rootDir, std::string const &amp;defaultPage) : HttpEventHolder(sock, std::tr1::bind(&amp;ServerThread::OnRequest, this, std::tr1::placeholders::_1, std::tr1::placeholders::_2)) , Thread(std::tr1::bind(&amp;ServerThread::DispatchProc, this)) , RootDir(rootDir) , DefaultPage(defaultPage) { } ~ServerThread() { IsRun = false; } private: enum { WaitTimeout = 10000 }; bool volatile IsRun; std::string RootDir; std::string DefaultPage; void DispatchProc() { IsRun = true; while(IsRun) { if (event_base_loop(GetBase(), EVLOOP_NONBLOCK)) { Common::Log::GetLogInst() &lt;&lt; "Failed to run dispatch events"; break; } usleep(WaitTimeout); } } void OnRequest(char const *resource, evbuffer *outBuffer) { std::string FileName; GetFullFileName(resource, &amp;FileName); try { System::FileHolder File(FileName); if (!File.GetSize()) { evbuffer_add_printf(outBuffer, "Empty file"); return; } evbuffer_add_file(outBuffer, File.GetHandle(), 0, File.GetSize()); File.Detach(); } catch (System::FileHolderException const &amp;) { evbuffer_add_printf(outBuffer, "File not found"); } } void GetFullFileName(char const *resource, std::string *fileName) const { fileName-&gt;append(RootDir); if (!resource || !strcmp(resource, "/")) { fileName-&gt;append("/"); fileName-&gt;append(DefaultPage); } else { fileName-&gt;append(resource); } } }; } class HTTPServer : private TCPServerSocket { public: HTTPServer(InetAddress const &amp;locAddr, int backlog, int maxThreadsCount, std::string const &amp;rootDir, std::string const &amp;defaultPage) : TCPServerSocket(locAddr, backlog) { for (int i = 0 ; i &lt; maxThreadsCount ; ++i) { ServerThreads.push_back(ServerThreadPtr(new Private::ServerThread(GetHandle(), rootDir, defaultPage))); } } private: typedef std::tr1::shared_ptr&lt;Private::ServerThread&gt; ServerThreadPtr; typedef std::vector&lt;ServerThreadPtr&gt; ServerThreadPool; ServerThreadPool ServerThreads; }; } int main(int argc, char const **argv) { if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) { std::cerr &lt;&lt; "Failed to call signal(SIGPIPE, SIG_IGN)" &lt;&lt; std::endl; return 0; } try { char const ServerAddr[] = "Server"; char const ServerPort[] = "Port"; char const MaxBacklog[] = "Backlog"; char const ThreadsCount[] = "Threads"; char const RootDir[] = "Root"; char const DefaultPage[] = "DefaultPage"; // Server:127.0.0.1 Port:5555 Backlog:10 Threads:4 Root:./ DefaultPage:index.html Common::CommandLine CmdLine(argc, argv); Network::HTTPServer Srv( Network::InetAddressV4::CreateFromString( CmdLine.GetStrParameter(ServerAddr), CmdLine.GetParameter&lt;unsigned short&gt;(ServerPort)), CmdLine.GetParameter&lt;unsigned&gt;(MaxBacklog), CmdLine.GetParameter&lt;unsigned&gt;(ThreadsCount), CmdLine.GetStrParameter(RootDir), CmdLine.GetStrParameter(DefaultPage) ); std::cin.get(); } catch (std::exception const &amp;e) { Common::Log::GetLogInst() &lt;&lt; e.what(); } return 0; }</span></span></span></span></code> </pre></div></div><br><h4>  Implementation on boost.asio </h4><br>  boost.asio is part of boost, which can help greatly reduce the development of network applications and, moreover, cross-platform ones.  The library hides a lot of routine from the developer. <br>  I did not write the implementation of the HTTP server on boost.  Took ready from examples to boost.asio.  <b>An example of a multi-threaded HTTP server.</b>  <b><a href="&amp;xid=25657,15700021,15700043,15700186,15700191,15700253,15700256,15700259&amp;usg=ALkJrhhGj6rivXxy90Xz4NEOnhRZwdcuVw#boost_asio.examples.">HTTP Server 3</a></b> The implementation of this example is quite suitable for testing in conjunction with the examples above. <br>  There is an implementation of an HTTP server for testing, but it would not be bad for general principles ... Unfortunately, unlike libevent in boost.asio there is no support for some higher-level protocols like HTTP and others.  The library will hide the work with the network via TCP in this case, but the HTTP implementation will have to be done by the developer himself: to collect and parse protocol headers. <br>  Below is a small example of a multi-stream echo server with a description, since I was less interested in parsing / assembling HTTP headers in the light of this topic.  The sequence of steps to create a multi-threaded server using boost.asio is like this: <br><ol><li>  Create objects of the classes boost :: asio :: io_service and boost :: asio :: ip :: tcp :: acceptor. </li><li>  Using boost :: asio :: ip :: tcp :: resolver and boost :: asio :: ip :: tcp :: endpoint translate the local address to which the listening socket will be bound to the structure used by the library. </li><li>  Call bind and listen for an object of class boost :: asio :: ip :: tcp :: acceptor. </li><li>  Create some class "Connection";  it is also ‚ÄúSession‚Äù, the instances of which will be used when receiving incoming user connections. </li><li>  Configure the appropriate callback functions to accept incoming connections, receive data. </li><li>  Start the message loop by calling boost :: asio :: io_service :: run. </li></ol><br>  And as with the libevent example, a multi-threaded server is quite simple to create from a single-threaded one using the steps described above.  In this case, the difference between the single-threaded and multi-threaded server is only that the method boost :: asio :: io_service :: run must be called in each thread for a multi-threaded implementation. <div class="spoiler">  <b class="spoiler_title">Implement the echo server on boost.asio</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;boost/noncopyable.hpp&gt; #include &lt;boost/asio.hpp&gt; #include &lt;boost/shared_ptr.hpp&gt; #include &lt;boost/thread.hpp&gt; #include &lt;boost/make_shared.hpp&gt; #include &lt;boost/bind.hpp&gt; #include &lt;boost/enable_shared_from_this.hpp&gt; #include &lt;boost/array.hpp&gt; namespace Network { namespace Private { class Connection : private boost::noncopyable , public boost::enable_shared_from_this&lt;Connection&gt; { public: Connection(boost::asio::io_service &amp;ioService) : Strand(ioService) , Socket(ioService) { } boost::asio::ip::tcp::socket&amp; GetSocket() { return Socket; } void Start() { Socket.async_read_some(boost::asio::buffer(Buffer), Strand.wrap( boost::bind(&amp;Connection::HandleRead, shared_from_this(), boost::asio::placeholders::error, boost::asio::placeholders::bytes_transferred) )); } void HandleRead(boost::system::error_code const &amp;error, std::size_t bytes) { if (error) return; std::vector&lt;boost::asio::const_buffer&gt; Buffers; Buffers.push_back(boost::asio::const_buffer(Buffer.data(), bytes)); boost::asio::async_write(Socket, Buffers, Strand.wrap( boost::bind(&amp;Connection::HandleWrite, shared_from_this(), boost::asio::placeholders::error) )); } void HandleWrite(boost::system::error_code const &amp;error) { if (error) return; boost::system::error_code Code; Socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, Code); } private: boost::array&lt;char, 4096&gt; Buffer; boost::asio::io_service::strand Strand; boost::asio::ip::tcp::socket Socket; }; } class EchoServer : private boost::noncopyable { public: EchoServer(std::string const&amp; locAddr, std::string const&amp; port, unsigned threadsCount) : Acceptor(IoService) , Threads(threadsCount) { boost::asio::ip::tcp::resolver Resolver(IoService); boost::asio::ip::tcp::resolver::query Query(locAddr, port); boost::asio::ip::tcp::endpoint Endpoint = *Resolver.resolve(Query); Acceptor.open(Endpoint.protocol()); Acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true)); Acceptor.bind(Endpoint); Acceptor.listen(); StartAccept(); std::generate(Threads.begin(), Threads.end(), boost::bind( &amp;boost::make_shared&lt;boost::thread, boost::function&lt;void ()&gt; const &amp;&gt;, boost::function&lt;void ()&gt;(boost::bind(&amp;boost::asio::io_service::run, &amp;IoService)) )); } ~EchoServer() { std::for_each(Threads.begin(), Threads.end(), boost::bind(&amp;boost::asio::io_service::stop, &amp;IoService)); std::for_each(Threads.begin(), Threads.end(), boost::bind(&amp;boost::thread::join, _1)); } private: boost::asio::io_service IoService; boost::asio::ip::tcp::acceptor Acceptor; typedef boost::shared_ptr&lt;Private::Connection&gt; ConnectionPtr; ConnectionPtr NewConnection; typedef boost::shared_ptr&lt;boost::thread&gt; ThreadPtr; typedef std::vector&lt;ThreadPtr&gt; ThreadPool; ThreadPool Threads; void StartAccept() { NewConnection = boost::make_shared&lt;Private::Connection, boost::asio::io_service &amp;&gt;(IoService); Acceptor.async_accept(NewConnection-&gt;GetSocket(), boost::bind(&amp;EchoServer::HandleAccept, this, boost::asio::placeholders::error)); } void HandleAccept(boost::system::error_code const &amp;error) { if (!error) NewConnection-&gt;Start(); StartAccept(); } }; } int main() { try { Network::EchoServer Srv("127.0.0.1", "5555", 4); std::cin.get(); } catch (std::exception const &amp;e) { std::cerr &lt;&lt; e.what() &lt;&lt; std::endl; } return 0; }</span></span></span></span></code> </pre></div></div><br><br><h4>  Testing </h4><br>  It's time to compare the resulting crafts ... <br>  The platform on which everything was developed and tested is a regular laptop with 4GB of RAM and a 2-core processor running the Ubuntu 12.04 desktop. <br>  First of all I put the utility for testing: <br><pre> <code class="bash hljs">sudo apt-get install apache2-utils</code> </pre>  and test it in this way: <pre> <code class="bash hljs">ab -c 100 -k -r -t 5 <span class="hljs-string"><span class="hljs-string">"http://127.0.0.1:5555/test.jpg"</span></span></code> </pre>  For all servers, 4 workflows were set up, 100 parallel connections, a file for transmission of 2496629 bytes and an estimated time interval of 5 seconds. <br>  Results: <br><div class="spoiler">  <b class="spoiler_title">Implementation on epoll</b> <div class="spoiler_text">  Benchmarking 127.0.0.1 (be patient) <br>  Finished 2150 requests <br><br>  Server Software: MyTestHttpServer <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: /test.jpg <br>  Document Length: 2496629 bytes <br><br>  Concurrency Level: 100 <br>  Time taken for tests: 5.017 seconds <br>  Complete requests: 2150 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Keep-Alive requests: 0 <br>  Total transferred: 5389312814 bytes <br>  HTML transferred: 5388981758 bytes <br>  Requests per second: 428.54 [# / sec] (mean) <br>  Time per request: 233.348 [ms] (mean) <br>  Time per request: 2.333 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 1049037.42 [Kbytes / sec] received <br><br>  Connection Times (ms) <br>  min mean [¬± sd] median max <br>  Connect: 0 0 0.5 0 3 <br>  Processing: 74,226 58.2 229,364 <br>  Waiting: 2 133 64.8 141 264 <br>  Total: 77 226 58.1 229 364 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Implementation on libevent</b> <div class="spoiler_text">  Benchmarking 127.0.0.1 (be patient) <br>  Finished 1653 requests <br><br>  Server Software: <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: /test.jpg <br>  Document Length: 2496629 bytes <br><br>  Concurrency Level: 100 <br>  Time taken for tests: 5.008 seconds <br>  Complete requests: 1653 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Keep-Alive requests: 1653 <br>  Total transferred: 4263404830 bytes <br>  HTML transferred: 4263207306 bytes <br>  Requests per second: 330.05 [# / sec] (mean) <br>  Time per request: 302.987 [ms] (mean) <br>  Time per request: 3.030 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 831304.15 [Kbytes / sec] received <br><br>  Connection Times (ms) <br>  min mean [¬± sd] median max <br>  Connect: 0 53 223.3 0 1000 <br>  Processing: 3,228,275.5 62,904 <br>  Waiting: 0 11 42.5 5 639 <br>  Total: 3 280 417.9 62 1864 <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Implementation on boost.asio</b> <div class="spoiler_text">  Benchmarking 127.0.0.1 (be patient) <br>  Finished 639 requests <br><br>  Server Software: <br>  Server Hostname: 127.0.0.1 <br>  Server Port: 5555 <br><br>  Document Path: /test.jpg <br>  Document Length: 2496629 bytes <br><br>  Concurrency Level: 100 <br>  Time taken for tests: 5.001 seconds <br>  Complete requests: 639 <br>  Failed requests: 0 <br>  Write errors: 0 <br>  Keep-Alive requests: 0 <br>  Total transferred: 1655047414 bytes <br>  HTML transferred: 1654999464 bytes <br>  Requests per second: 127.78 [# / sec] (mean) <br>  Time per request: 782.584 [ms] (mean) <br>  Time per request: 7.826 [ms] (mean, across all concurrent requests) <br>  Transfer rate: 323205.36 [Kbytes / sec] received <br><br>  Connection Times (ms) <br>  min mean [¬± sd] median max <br>  Connect: 0 0 1.1 0 4 <br>  Processing: 286 724 120.0 689 1106 <br>  Waiting: 12 364 101.0 394 532 <br>  Total: 286 724 120.0 689 1106 <br></div></div><br>  The results are summarized in the table. <br><table><tbody><tr><td></td><td>  <b>epoll</b> </td><td>  <b>libevent</b> </td><td>  <b>boost.asio</b> </td></tr><tr><td>  <b>Complete requests</b> </td><td>  2150 </td><td>  1653 </td><td>  639 </td></tr><tr><td>  <b>Total transferred (bytes)</b> </td><td>  5389312814 </td><td>  4263404830 </td><td>  1655047414 </td></tr><tr><td>  <b>HTML transferred (bytes)</b> </td><td>  5388981758 </td><td>  4263207306 </td><td>  1654999464 </td></tr><tr><td>  <b>Requests per second [sec] (mean)</b> </td><td>  428.54 </td><td>  330.05 </td><td>  127.78 </td></tr><tr><td>  <b>Time per request [ms] (mean)</b> </td><td>  233.348 </td><td>  302.987 </td><td>  782.584 </td></tr><tr><td>  <b>Transfer rate [Kbytes / sec] received</b> </td><td>  1049037.42 </td><td>  831304.15 </td><td>  323205.36 </td></tr></tbody></table><br>  There are three types of lies: lies, blatant lies and statistics.  Although, I must admit, the result can not fail to please me.  I think you should not pay special attention to the results obtained, but you can look at them as some kind of supporting information that may be useful when making decisions in choosing a tool for developing your own server software.  For fidelity of results, it is advisable to arrange multiple runs on server hardware by clients running on other machines on the network, etc. <br>  100 parallel requests - it would seem small, but quite enough for testing in such modest conditions.  Of course, I would like to check the results on thousands of parallel queries, but there are already other factors.  One of these factors is the number of simultaneously open file descriptors of the process.  You can find out and set some process parameters by calling the getrlimit and setrlimit functions.  In order to find out how many file descriptors are allocated to a process, you can call getrlimit with the RLIMIT_NOFILE flag of the rlimit structure.  For its operating system, it is 1024 file descriptors per process by default and 4096 is the maximum that can be set per process.      ‚Ä¶  ,  ,                  .      <b><a href="http://www.ibm.com/developerworks/ru/library/l-hisock/index.html">    Linux</a></b> <br><br><h4>    </h4><br>   WebServer  ¬´¬ª   ,    ,     .              .             ,   -     ,    -  ,  -   -        . ,       epoll     .           , ,          .  ¬´ ¬ª,         ,    ,      C++,     C,       stl,          . <br>      ,      libevent,     ,      , ,   .          . <br>    , boost  .             . boost.asio              .      ¬´¬ª           , ,   . <br>     <a href="http://www.kernel.org/doc/man-pages/online/pages/man7/aio.7.html">    Linux (aio)</a> ,              ¬´¬ª      . <br><br>         <a href="http://web-srv-test.googlecode.com/svn/trunk/">SVN</a> . ,      .  But!         ,      .   <b><a href="http://habrahabr.ru/post/155959/">¬´  ¬ª</a></b> , ,    ‚Äî   ,  ‚Äî  ,  ‚Äî  .            :) <br><br>  ¬´¬ª           API    . <br><br><h4>  Interesting materials </h4><br><ul><li> <a href="http-libevent.html">  HTTP    libevent</a> </li><li> <a href="http://www.ibm.com/developerworks/aix/library/au-libev/">Boost network performance with libevent and libev</a> </li><li> <a href="http-libeve">MULTI-THREADED HTTPSERVER USING EVHTTP (LIBEVENT)</a> </li><li> <a href="http://www.ibm.com/developerworks/linux/library/l-async/">Boost application performance using asynchronous I/O</a> </li><li> <a href="http://webcrunch.ru/library/equipment/clusters/tuning-freebsd/"> FreeBSD   100-200  </a> </li></ul><br><br>  Thanks for attention! <br></div><p>Source: <a href="https://habr.com/ru/post/152345/">https://habr.com/ru/post/152345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../152333/index.html">Vader - simple logger for dart</a></li>
<li><a href="../152335/index.html">The results of the conference ‚ÄúWindows Azure Cloud Platform for Mobile Applications‚Äù. Video reports and photos</a></li>
<li><a href="../152337/index.html">MIT has developed a real-time mapping system for rescuers</a></li>
<li><a href="../152339/index.html">Medical reference for Android</a></li>
<li><a href="../152341/index.html">Google Play: 25 billion downloads and apps for $ 0.25</a></li>
<li><a href="../152347/index.html">Creative workshop: 80 creative tasks of a designer</a></li>
<li><a href="../152349/index.html">The early answer is currency rates, weather and traffic jams in the tips.</a></li>
<li><a href="../152351/index.html">Problems in the work of services September 24-25</a></li>
<li><a href="../152353/index.html">100,000 passwords ieee.org for the whole month were in open access</a></li>
<li><a href="../152355/index.html">Autumn Technology Forum: focus on web development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>