<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On-demand synchronization implementation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Over the past decade, the availability of the Internet has increased significantly. Therefore, the number of applications that work in conjunction cli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On-demand synchronization implementation</h1><div class="post__text post__text-html js-mediator-article">  Over the past decade, the availability of the Internet has increased significantly.  Therefore, the number of applications that work in conjunction client-server, also increased significantly.  But what to do if access to the network is, but not always?  It is with such a requirement from the customer that we faced in one of the projects.  All who are interested in the solution developed by us, please under the cat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2f5/527/34e/2f552734e9c24e27a5f7574db6ee3c20.png"></div><br><a name="habracut"></a><br><h1>  Initial data </h1><br>  So, a little more about the task.  There are <i>n</i> geographically distant offices.  Each office employs several employees, processing data.  Data may overlap between offices.  In the office most of the time may not have access to the Internet.  Accordingly, a situation may arise when the same object was changed by two employees.  Since the changes are equivalent and it is impossible to apply one of them and reject the other, there is another requirement - a conflict resolution mechanism.  Well, as a cherry on a cake, relatively old laptops with a small amount of RAM are used as workstations in offices. <br><br>  Before bravely rushing to solve a problem, we, of course, tried to find out whether it would not be cheaper to resolve the issue of network availability than to look for a software solution.  But here the customer was adamant and insisted on his internal reasons for such a decision. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Leaving the organizational solution, we moved to the technical.  Much further depended on the choice of a DBMS for a local DB.  The first choice was SQL CE, but after some time, due to big performance problems, the final choice fell on MySql. <br><br>  If we discard the solutions found in the open spaces of the codeproject, then there were 3 alternatives: <br><br><ul><li>  Database replication </li><li>  MS Sync Framework </li><li>  Your <s>bike</s> option </li></ul><br>  The variant with replication is not suitable for many criteria: starting from the requirements for the visual resolution of conflicts and ending with various DBMS on clients and server (although, of course, this can be solved). <br><br>  MS Sync Framework inspired great hopes after reading the list of features.  After the first acquaintance, the hopes became much less.  The main problem was that it was weakly focused on work at the level of domain objects (and this is how it is most convenient for the user to work - to resolve the conflict for the entities with which he works in the application, and not for their individual pieces, which correspond to separate tables). <br><br>  Therefore, we went to meet the adventure on the way to point 3! <br><br><h1>  Software model </h1><br>  So, the final architecture included a client implemented on WPF and a server implemented as a WCF service. <br><br>  For each entity, a class inherited from the base class Entity was created in the domain structure of the application: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Entity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Guid ID { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> DateTime Timestamp { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> EEntityState State { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsDeleted { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> EEntityState { Normal, Created, Modified, Deleted }</code> </pre> <br><ul><li>  <i>ID</i> - object identifier, using Guid allows you to solve the problem of assigning identifiers when creating new objects on various system clients. </li><li>  <i>Timestamp</i> - the time the object was last modified.  This field is updated ONLY on the server when synchronizing user changes.  Based on this field, the server sends to the client objects that have been modified since the previous synchronization. </li><li>  <i>State</i> - the state of the object.  This field is updated ONLY on the client.  Based on this field, the client selects objects that have been modified (created, edited, or deleted) since the last synchronization. </li><li>  <i>IsDeleted</i> - objects in the system are not deleted (another customer requirement).  Therefore, instead of the actual deletion, the object is marked as deleted and does not participate in further selections during the work of the client. </li></ul><br>  Each object in the system has three representations: <br><br><ul><li>  in the form of a domain entity </li><li>  in the form of <i>DTO</i> (Data Transfer Object) - in this view, the object is transmitted during synchronization between the client and the server.  In such an object there are only simple fields.  All links / collections of links are replaced with identifiers of objects to which the link points. </li><li>  in the form of <i>PE</i> (Presentation Entity) - in this view the object is displayed on the form. </li></ul><br><br><h1>  Server part </h1><br>  Initially, on the service side for each entity two methods are implemented: <br><br><ul><li>  <i>Get</i> - get objects changed after the specified date; </li><li>  <i>Save</i> - save changes for transferred objects </li></ul><br>  During testing, it was decided to add a third method - <i>GetCount</i> , which would return the number of objects changed after the specified date.  The <i>Get</i> method, accordingly, will receive parameters for obtaining <i>N</i> objects with offset <i>M.</i>  This was done due to the fact that if the connection to the server was bad, the connection timeout often took off.  It would be possible to simply increase the timeout, but the option with paging data seems more correct. <br><br>  In addition to the methods for processing entities, the following methods are also present on the server: <br><br><ul><li>  <i>BeginSynchronization</i> - initiates the start of synchronization.  At this point, a synchronization check is performed (only one client can synchronize at a time; the session is considered active if it a) has not completed, b) has been active for the last 20 minutes).  If successful, a new session is created. </li><li>  <i>EndSynchronization</i> - end of synchronization.  This operation closes the current synchronization session, and the client receives the synchronization date (which it uses during subsequent synchronizations). </li><li>  <i>Noop</i> - the operation of maintaining the connection.  This operation is used at the time of conflict resolution on the client side, so that the connection does not break on timeout, as well as to update the status of the current synchronization session. </li></ul><br><h1>  Conflict resolution </h1><br>  To solve the problem with the resolution of conflicts in the system, the following editing model was implemented. <br><br>  In the application, each editor can be used in two versions: <br><br><ul><li>  direct editing of the entity; </li><li>  conflict resolution during synchronization. </li></ul><br>  The differences between these options are in the form on which editing takes place - when editing an entity, the form contains an editor and save / cancel buttons (some forms may also have additional buttons, but this does not affect the essence of the matter), while saving this form, the object is saved in DB and closing dialogue.  When resolving conflicts on the form, two editors are displayed at the same time (for a local object and for an object received from the server), management of the state of the object (deleted / not deleted), besides, it is necessary to visually select the different fields inside the editor, and when closing the window you do not need to save changes in the database. <br><br>  To do this, in the application, each editor was designed as a separate control.  This control contained only logic for editing (calling child editors, updating screen state, etc.).  The interface of this editor provided two methods for setting / getting an editable object ( <i>PE</i> ). <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEditor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action EditedObjectChanged; IWindow Window { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-function">ObjectValidationResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Validate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEditedObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PresentationEntity pe</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">PresentationEntity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEditedObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br>  For ease of use, its generic version was introduced: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEditor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPE</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEditor</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPE</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PresentationEntity</span></span></span><span class="hljs-class"> </span></span>{ TPE DisplayObject { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Then he turned into a form that included the logic for translating <i>PE</i> into the domain object and further saving the <i>PE</i> into the database. <br><br>  The conflict resolution dialog simultaneously displays two editors, in each of which either the <i>PE of the</i> local entity or the <i>PE of the</i> server entity are installed respectively. <br><br>  For some editors, users had the opportunity to change not only the fields of the object itself, but also the fields of the child objects (for example, editing the child list).  Accordingly, as a result of the work of the conflict resolution form, not only the object for which the form was called, but also the objects of the child collections could change its state.  Therefore, all objects of the child collections in the form view had the following general class: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildListItemPE</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PresentationsEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Guid</span></span> <span class="hljs-type"><span class="hljs-type">ObjectID</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">ChildEditorPE</span></span> <span class="hljs-type"><span class="hljs-type">EditorPE</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Where <i>ChildEditorPE</i> is <i>PE</i> for the editor of this entity. <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChildEditorPE</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValidatablePresentationEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Guid</span></span> <span class="hljs-type"><span class="hljs-type">ObjectID</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">EEntityState</span></span> <span class="hljs-type"><span class="hljs-type">State</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Thus, after closing the conflict resolution form, we go through the collections of the edited object (using reflection) and update all objects whose editors have a state other than <i>Normal</i> .  As a result, we had a modified object state and object identifiers that were changed while editing the main object. <br><br>  In addition, during the operation of the conflict resolution form, we call the Noop service method on a timer in a parallel thread to support our session. <br><br>  The logic of highlighting the state of the form element is based on the assumption that the editors of the local object and the object received from the server have an identical structure, as well as on the condition of a limited number of control types used (i.e. if you want to display differences for the slider, then you need to add code which will check the equality of the current values, as well as set styles for the states). <br><br>  For each element of the local object editor, a corresponding element is searched for in the object editor received from the server.  Next, the presence of the established binding is checked on the corresponding field (for example, Text for TextBox or ItemsSource for DataGrid) - this is another assumption, all fields in editors that affect the state of the object are associated with the model through Binding.  Next, we get the values ‚Äã‚Äãof the fields in the element belonging to the editor of the local object, and in the element belonging to the editor to the object received from the server.  Based on the comparison of these values, we establish the necessary style. <br><br>  Here are some examples of conflict resolution forms. <br><br>  <i>Elements on the form have a red background color in case the value in the local version of the object differs from the value in the object received from the server.</i> <br><br><img src="https://habrastorage.org/files/ce4/a09/bfe/ce4a09bfea234833b990ef22f2858b2c.png"><br><br>  <i>Lists have a green background if the number of objects and their composition is the same in the local version and in the version obtained from the server.</i>  <i>Items in the list also change the background color depending on their state.</i> <br><br><img src="https://habrastorage.org/files/887/c5c/ffb/887c5cffb996409a975ff61ea598f984.png"><br><br><img src="https://habrastorage.org/files/37d/0ea/22d/37d0ea22dfde4c3d940e5d7b588b88ae.png"><br><br><h1>  Synchronization </h1><br>  The first version of synchronization included the following steps: <br><br><ul><li>  synchronization start - the client initializes the connection to the server; </li><li>  receiving from the server a list of changed objects (that is, objects that other users have changed); </li><li>  getting a list of local changed objects (i.e. objects that the current user has changed); </li><li>  objects that have been changed only on the server are immediately saved to the local database; </li><li>  Objects that have been modified only locally are added to the collection of objects to be sent to the server. </li><li>  Objects that have been modified both locally and on the server are marked for conflict resolution: <br>  o A local copy of the object participates in conflict resolution, and an object created on the basis of the received <i>DTO</i> .  In this case, for an object created on the basis of <i>DTO</i> , additional references to other objects and collections are processed (so that they point not to local objects, but to objects received from the server); </li><li>  send information about changed local entities to the server; </li><li>  start the save process; </li><li>  we complete the synchronization process. </li></ul><br>  In the process, it became necessary to restore the local user base in case of unsuccessful synchronization (for example, the connection with the server was lost, or the user canceled the synchronization).  The first option considered is to wrap everything in a transaction.  But since in the synchronization process we have access to the database from different threads (interaction with the server is carried out in one thread, the forms work in another (and the forms, when displaying an object in theory, can refer to the database for some reference data from the database), then this option was dropped. Therefore, the synchronization process was supplemented with two steps - in the beginning we create a backup of the local database, and in case of an error / cancellation, we restore the database from the previously created backup. <br><br>  The next problem we faced was the timeout of the operation while saving the changes on the server - in the case of a large number of changes of entities of the same type, the operation of saving them could take longer than the set timeout allowed.  A simple solution would be to increase the timeout.  Another solution could be the introduction of paging (by analogy with data acquisition).  But we decided to go along an alternative path, which allowed us to resolve the issue with transactionality and on the server side (so that we could apply either all changes from the synchronization session, or not apply any). <br><br>  All changes made in the <i>Save</i> methods were translated into a JSON object, which was saved to a special table.  This object contained information about the session to which it belongs, the type of entity that matches, and the state of the corresponding <i>DTO</i> . <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">IntermediateItem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Guid SessionId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DTOType { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Content { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  After the end of the main part of synchronization (receiving objects, resolving conflicts and sending changes to the server), the client called the <i>CommitChanges</i> service <i>method</i> , which, in turn, sent a message to the Windows service, which already backtracked the changes from the intermediate table to <i>DTO</i> , translating <i>DTO</i> objects in domain entities and their preservation. <br><br>  The allocation of this operation in a separate win-service was done due to the fact that the preservation operation can take quite a long time.  The client at this time periodically calls the server's <i>GetCommitStatus</i> method in order to check the status of the operation. <br><br><h1>  Instead of conclusion </h1><br>  It is likely that at one time we invented the bicycle.  We also understand that the final decision is not without flaws.  But in the end we got a stable and workable version of the solution for synchronizing offline parts of the system.  But still for future projects (and oddly enough, requests with similar requirements continue to come in regularly) we would be happy to learn other solutions, as well as to improve our model, therefore we will be glad to receive comments and comments. <br><br>  Disadvantages: <br><br><ul><li>  one synchronization at a time - as you can see from the described process, only one user can synchronize at a time.  This causes some inconvenience during the initial synchronization (that is, when the user does not have a local database).  Such a session usually takes 2-3 hours (depending on the speed of access to the server and the speed of the computer).  But given the fact that the number of users of the system is less than 20, and the frequency of new users tends to zero, this does not cause problems.  The average duration of a synchronization session is 20-30 minutes, and taking into account the different geography of offices (including different time zones), synchronization intersections do not often occur; </li><li>  adding entities to the system requires a large number of auxiliary objects (in fact, it‚Äôs not that the lack of a specific solution, but the lack of all patterns is their redundancy); </li><li>  the need to monitor the correct updating of the state of objects; </li><li>  if the client ‚Äúfell off‚Äù from synchronization and did not close its session, then the next client will be able to connect only after the timeout for ‚Äúnot activity‚Äù of the previous session expires (20 minutes). </li></ul><br>  Buns: <br><br><ul><li>  the transactional nature of synchronization operations (both on the server side and on the client side); </li><li>  conflict resolution with visualization of differences; </li><li>  well and the main thing - the customer is satisfied! </li></ul><br>  Partially listed disadvantages can be eliminated: <br><br><ul><li>  for example, routine operations when adding new entities can be mostly automated using code generation; </li><li>  updating the state of objects can be implemented at the repository level; </li><li>  To track closed sessions, you can enter an additional service method, which is called at short intervals (for example, after 15 seconds) and updates the status of the synchronization session.  In this case, you can reduce the timeout "no activity" from 20 minutes to the mentioned 15 seconds.  Of course, this will increase the traffic and load on the server, but since  the number of users is not large and will not change significantly, then this option is quite viable. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/310696/">https://habr.com/ru/post/310696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310686/index.html">Launch of Azure Pack Infrastructure cloud from InfoboxCloud</a></li>
<li><a href="../310688/index.html">How we did a search in elasticsearch on vulners.com</a></li>
<li><a href="../310690/index.html">Tarantool: how to save a million dollars on a database on a high-load project</a></li>
<li><a href="../310692/index.html">Review of the best reports from the conference "Around the Cloud"</a></li>
<li><a href="../310694/index.html">System scripts in php for linux, we write a screenshot</a></li>
<li><a href="../310698/index.html">How the server works with a screwdriver in the power supply</a></li>
<li><a href="../310702/index.html">DBMS era of the Internet of things</a></li>
<li><a href="../310704/index.html">Convenient REST for Xamarin Applications</a></li>
<li><a href="../310706/index.html">HTML 5.1 is coming out, HTML 5.2 is being prepared</a></li>
<li><a href="../310708/index.html">Debugging php in Visual Studio Code (Xdebug, Windows)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>