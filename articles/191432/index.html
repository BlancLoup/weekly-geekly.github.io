<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm for generating a course for the game Scrabble</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, Habr! 

 In this article I will talk about how I created artificial intelligence for the game Scrabble. Details under the cut. 

 Scrabble 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithm for generating a course for the game Scrabble</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/75e/9d3/5dd/75e9d35ddfa1113d93d423101678a78a.jpg" alt="image"><br><br>  Good day, Habr! <br><br>  In this article I will talk about how I created artificial intelligence for the game Scrabble.  Details under the cut. <br><a name="habracut"></a><br><h4>  Scrabble </h4><br>  Erudite is a domestic analogue of the world-famous game Scrabble - a board game that can be played by 2 to 4 people by laying out words from the letters they have in the playing field.  The playing field consists of 15 x 15, that is, 225 cells in which participants in the game make up words.  Each composed word brings points depending on the value of the letters and cells used. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The field for the game Scrabble looks like this: <br><br><img src="https://habrastorage.org/storage2/f8b/933/024/f8b933024bc237aa4c20b9826d1292c1.png"><br>  <i>Figure 1. Playground</i> <br><br><h5>  Fundamental rules </h5><br>  Usually the rules are negotiated by players before the game starts, but there are some generally accepted rules of the game: <br><ul><li>  At the beginning of the game, each player is given seven chips.  In one move, you can put a few words.  Each new word must be in contact (have a common letter or letters) with previously laid out words.  Words are read only horizontally from left to right and vertically from top to bottom. </li><li>  If a player does not want or can not lay out a single word, he has the right to change any number of his letters, having missed the move. </li><li>  If the player has used all seven chips during the turn, then he receives an additional 15 points. </li><li>  The sum of the points of each move consists of the sum of the points made up of letters, as well as the bonuses received for placing letters on the bonus cells. </li><li>  Bonus cells for letters: the points of a letter located on a green cell doubled, on a yellow one they triple. </li><li>  Bonus cells for words: if one of the letters of the word is located on the blue cell, the sum of the points of the whole word doubles, on the red one it is tripled. </li></ul><br><h4>  The first steps </h4><br>  Before developing an algorithm for generating a move, it is necessary to figure out which words and where can be placed on the field.  To do this, it suffices to find how to construct all possible words horizontally in the field ‚Äî the construction along the vertical is obtained in the same way. <br><br>  We introduce two definitions: <br>  <i><b>The prefix of a</b></i> word is any successive set of letters of a word, starting with the first letter of the word, but not including the last. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  <b>HABR</b> word <b>prefixes</b> : <ul><li>  X </li><li>  HA </li><li>  Hub </li></ul></div></div><br>  <i><b>A</b></i> word <i><b>suffix</b></i> is any consecutive set of letters of a word, ending in the last letter of a word, but not including the first. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  Suffixes of the word <b>HABR</b> : <ul><li>  ADB </li><li>  Br </li><li>  R </li></ul></div></div><br><h5>  Anchor points </h5><br><img src="https://habrastorage.org/storage2/6bf/21d/87f/6bf21d87fee89f98c5544b01032483cc.png"><br>  <i>Figure 2. The row under consideration</i> <br><br>  Consider the series shown in the figure above.  It is necessary to find all the words that can be built in this series.  According to the rules of the game, any word must include an existing letter from a number.  Then the places where you can form a word are empty cells adjacent to already occupied cells.  We call these cells <i>points of attachment</i> (English <i>acnhor</i> ).  There are five anchor points in this row, which are highlighted in red in the figure below. <br><br><img src="https://habrastorage.org/storage2/c7f/348/e82/c7f348e827220234112cb32fa29d2b4f.png"><br>  <i>Figure 3. Anchor points</i> <br><br>  Once all the anchor points are found, it is necessary to find the possible number of prefix letters for the anchor points that will form the word.  If the cell adjacent to the left of the anchor point is occupied, then it is used as part of the prefix of the word being composed.  In this case, the possible number of letters of the prefix is ‚Äã‚Äãfixed.  If this cell is empty, the prefix is ‚Äã‚Äãformed from the letters of the player and then the number of letters of the prefix is ‚Äã‚Äãlimited by the distance to the nearest non-empty one or the cell's anchor point. <br><br><img src="https://habrastorage.org/storage2/d36/ad2/ad2/d36ad2ad268faff4cb8b51406c9d5a07.png"><br>  <i>Figure 4. Possible number of prefix letters</i> <br><br><h5>  Algorithm for finding words in a row </h5><br>  For each cell that is an anchor point, we search for all possible words as follows: <br><ol><li>  Find all possible prefixes associated with a given anchor point and satisfying the possible prefix length specified for the anchor point. </li><li>  For each prefix found in the paragraph above, find all suitable suffixes that will form together with the prefix a word from the dictionary.  Suffixes are built using the letters of the player or the letters already on the field. </li></ol>  The word prefix will contain either cells from the player‚Äôs hand or cells already placed on the board, but not simultaneously. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  During the operation of the algorithm, the word " <b>SHIP</b> " for anchor point <b>4</b> can be found if the player has the letters " <b>B</b> " and " <b>b</b> ".  In this case, the prefix will be " <b>KORA</b> ", the suffix will be constructed with the help of two player letters and the letter " <b>L</b> " on the field </div></div><br>  Now, having a way to find all the words on the field, you can go directly to the description of the algorithms for generating a turn. <br><br><h4>  Algorithms for generating progress </h4><br>  I chose three algorithms for generating a move: the algorithm for selecting the maximum value, the brute force method, the alpha-beta cut-off method. <br><br><h5>  Algorithm for choosing the maximum value </h5><br>  At each iteration of the method, a word is searched that will bring in more points than the others.  After finding this word, it is laid out on the field and the search is performed again for a new position and a new set of letters in the hand until at some step the set of found words is empty. <br><br>  The main problem of this algorithm is that the resulting set of words will not necessarily be the best move in this position in terms of the number of points it will bring. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text">  The starting position is set on the field, that is, there are no more words on the field, the player has the following letters: <b>OBLMEOB</b> .  As a result of the first iteration of the algorithm, the word ‚ÄúBLANK‚Äù will be added.  As a result, in the hands of the player will remain the letters <b>E</b> and <b>B</b> of which no longer make a single word in the new position in the figure below: <br><br><img src="https://habrastorage.org/storage2/02a/be3/6aa/02abe36aa1cdbc713b2991452aa31656.png" alt="image"><br>  <i>Figure 1.1.</i>  <i>The result of the algorithm.</i> <br><br>  This move will bring the player <b>11</b> points. <br><br>  However, the best, in terms of points, the move in this position is the move shown in the figure below: <br><br><img src="https://habrastorage.org/storage2/b7b/7c6/fb9/b7b7c6fb9bd4a3f06cacacd151bebf73.png"><br>  <i>Figure 1.2.</i>  <i>The best move.</i> <br><br>  This move will bring the player <b>38</b> points - 23 points for composed words and 15 bonus points for using all letters, which is 3.5 times more than the move indicated above. <br></div></div><br><h5>  Brute force method </h5><br>  The second method of generating a move is a complete bust.  Brute force - a method of finding a solution by exhausting all sorts of options.  First, all the words that can be composed on the field in this position are searched.  Then, for each new position and new letters in the hand, obtained by placing this word on the field, the previous actions are repeated.  This continues until the set of words to be composed is empty. <br>  As a result of the method, all possible moves that can be made by a player in a given position will be considered.  Among these moves, the one that gives the most points is chosen. <br><br>  The main problem of the method is speed.  In order to increase the speed of the method, it is possible to memorize the positions and letters recurring during the placement of words on the hand, that is, to use dynamic programming. <br><br><h5>  Alpha-beta clipping method </h5><br>  Minimax is a decision rule for minimizing potential losses that cannot be prevented during the worst case scenario for a player.  An improvement of this method is its modification - the alpha-beta cut-off method.  The alpha-beta cut-off method is based on the idea that the evaluation of the branch of the search tree can be terminated early if it was found that for this branch the value of the estimating function is in any case worse than that calculated for the previous branch. <br><br>  The algorithm of the method is as follows: first, all possible moves in a given position are searched.  Then, for the resulting positions, all possible moves are searched by the opponent in the new position.  These actions are repeated exactly as many times as the depth of the analysis of the initial position.  In the resulting position tree, a move is sought such that the difference in points between the player and the opponent will be maximized. <br><br>  The main disadvantage of this method lies in the fact that throughout almost the entire game the letters of the opponent are unknown.  Therefore, it makes sense to use this algorithm only at the end of the game - when all the letters are used, except for the letters in the hands of the players. <br><br><h4>  results </h4><br>  For implementation, I used the Java programming language.  The dictionary consisted of 12 thousand words, the program was presented in the form of the usual Set'a. <br><br>  The average generation time is shown in the diagram below: <br><img src="https://habrastorage.org/storage2/85b/621/56e/85b62156ef345d8d8a5c7010d476591f.png"><br>  <i>Figure 5. Generation timeline</i> <br><br>  The research sample included 100 different sequences of the appearance of letters issued to players (according to the stack principle).  As a result, about 1500 different combinations of letters on the hand and positions were considered. <br><br>  However, the gain in generation time led to a loss on points: the algorithm for choosing the maximum value on average brings the player about 30 points, while the other methods - about 60 points. <br><br><h5>  Todo </h5><br>  Unfortunately, the following points were excluded from consideration: <br><ul><li>  Analysis of combinations with rare letters </li><li>  Analysis of letters remaining after the move </li><li>  Analysis of further actions of the enemy </li><li>  Letters that should be changed when skipping a move </li></ul><br>  Basically, the first two points rely on the use of rare letters, such as ‚Äú <b>E</b> ‚Äù and ‚Äú <b>Kommersant</b> ‚Äù, as well as the balance between vowels and consonants in the hands of the player.  Analysis of the actions of the enemy includes attempts to prevent moves that pass through bonus cells.  The study of the above points should improve the operation of the algorithm. <br><br><h4>  Literature </h4><br><ul><li>  <a href="https://www.udacity.com/course/viewer">Lecture by</a> Peter Norvig on the game Scrabble.  From this source borrowed the most ideas. </li><li>  Game <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/399/712/erudit.pdf">rules</a> </li><li>  Brute force <a href="http://en.wikipedia.org/wiki/Backtracking">wiki</a> </li><li>  The Great Thomas Kormen: Algorithms.  Construction and analysis. </li><li>  Alpha beta <a href="http://cs.ucla.edu/~rosen/161/notes/alphabeta.html">cut</a> </li></ul><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/191432/">https://habr.com/ru/post/191432/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191422/index.html">Sound reproduction in Java</a></li>
<li><a href="../191424/index.html">Simple 4-color multichannel garland based on the ATTINY13A microcontroller</a></li>
<li><a href="../191426/index.html">Three rules for good programming</a></li>
<li><a href="../191428/index.html">Calculation of the booster circuit for maximum battery power</a></li>
<li><a href="../191430/index.html">Create autonomous robot Frank. Part one</a></li>
<li><a href="../191434/index.html">Search for vulnerabilities in habrosite</a></li>
<li><a href="../191436/index.html">Automatic code generation in Yii</a></li>
<li><a href="../191438/index.html">Why is not everything normal with normal distribution</a></li>
<li><a href="../191440/index.html">Delegation</a></li>
<li><a href="../191442/index.html">Android - Live Wallpaper on OpenGL ES 2.0 with Simplified DOF Effect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>