<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web server in 5 minutes based on PIC and W5100</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everything you wanted to know about how to launch a simple web server on a W5100 chip in 5 minutes, but were too shy to ask. 



 The article will sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web server in 5 minutes based on PIC and W5100</h1><div class="post__text post__text-html js-mediator-article">  Everything you wanted to know about how to launch a simple web server on a W5100 chip in 5 minutes, but were too shy to ask. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/896/d59/c88896d59d524c4349a7ccc53b60a8a8.jpg" alt="image"><br><br>  The article will simply, in detail and clearly describe how to run, for example, a web server on a wonderful and inexpensive W5100 chip from Wiznet. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is she wonderful? <br>  Secondly - inexpensive. <br>  And in the first place, she does all the work for you.  You just have to lazily send-receive TEXT (more precisely, HTML) data. <br><a name="habracut"></a><br>  <i>Disclaimer1: An electronic engineer with ... ten years of experience article may seem superficial and simplified, since they are (possibly) in the subject.</i>  <i>This article is designed for those who have some experience in electronics, or at least in the programming of microcontrollers, and simply, damn it, wants, finally (together), to run this ... (crossed out) (okay, let it be ‚Äúgreat‚Äù ) W5100 chip.</i> <i><br><br></i>  <i>Disclaimer 2: I did not set a goal for universal education, a full translation of the datasheet and the interpretation of all its points.</i>  <i>My task is to clarify entangled moments and show how to use the W5100 chip and how to run an application on it (for example, a web server).</i> <i><br><br></i>  <i>Based on my explanations and an example of an application, anyone who has experience in microcontrollers and at least the basic concepts in networks will be able to figure out the rest on their own.</i> <i><br><br></i>  <i>Disclaimer 3: Please do not conduct this experiment at home.</i>  <i>And it is desirable that there was a nearby adult.</i> <br><br><h4>  SCOPE </h4><br>  The article does not intend to give comprehensive knowledge of the extensive network topic, there are manuals for this, but it will provide an opportunity to understand what, in principle, is happening and why, and what information to look for in-depth understanding of the subject. <br><br>  However, the example presented at the end will allow you to figure out how to use the Internet (more precisely, Ethernet and TCP / IP) in your applications on microcontrollers, and, despite its simplicity, it can be fully applied in practice.  You will be able to complicate it, because you will understand how to work with a client-server bundle, and finally, having something at hand working and now understanding the topic much better - it will be much easier for you to deepen your knowledge without falling asleep over a dozen pages with descriptions assignment of registers, principles of NAT configuration, or the correct indication of the fragment offset in packets. <br><br>  <i>("... fragments in the packages .." What was it like Woody Allen?)</i> <br><br>  From my own experience: usually, the person who writes the article is sabzhekt clear and understandable, so he writes briefly and ‚Äúclearly‚Äù. <br>  However, this is often not the case for the reader, who may not be in the subject line, and often has to guess what exactly the author had in mind, and should one understand a certain statement like this, or is it quite the opposite?  Therefore, wherever possible, I will not begin to rassusoliv, and in those places where you need to chew to the utmost clarity and unambiguity of understanding - I will not save words. <br><br>  At the same time, remember that no one is perfect (even me), so forgive me if someone left unsatisfied. <br><br>  For those who read to the end, there is a bonus: at the end of the article, the WORKING code on a simple ‚ÄúC‚Äù with a bunch of comments will be given so that even a fifth-grader can understand what is happening in the program.  The code is written for ordinary PICa (aren't everyone still around AVR-boxes and Arduin-boxes?). <br><br><h4>  Ingredients </h4><br>  If you do not yet have a particular desire to make a motherboard and solder a chip in the TQFP80 package to it, I recommend taking the usual Arduin's Ethernet Shield based on the W5100.  You will also need a simple and inexpensive PIC, a layout for the PICa and some connecting wires, an Ethernet patch cord and, to taste, an RS232 serial cable, in case you suddenly wonder what is going on inside the server during operation (the lines for output associated information - to the terminal). <br><br><h4>  Lyrics (can be skipped) </h4><br>  Anyone who has some experience in development, this situation is familiar (or not? Or is it just me that loser?) <br><br>  You take a certain chip on which you need to run the application.  For simplicity, let us assume that you are also familiar with the topic / area in which this application will be used (for example, Ethernet, TCP / IP, HTTP, CGI etc). <br><br>  First, you take a datasheet on a chip, in 100,500 pages, <div class="spoiler">  <b class="spoiler_title">do not skip lyrics</b> <div class="spoiler_text"><br>  and read it carefully.  Then you reread it a few more times and finally begin to understand how to work with this chip.  Then you take errata and repeat the same iterations. <br><br>  After reading these, you finally understand how the chip works, how to program it correctly (100,500 registers -1), but so far it is still not entirely clear how to RIGHT it should be launched.  (For example, does the order refer to the registers, and if so, which order is correct, and if it doesn‚Äôt matter, does it really matter?). <br><br>  Of course, a lot of useful information can be found on the internet and on the forums, but of all the examples found there, it is not quite clear which WORKS work, which work despite the abundance of terrifying mistakes (which you still do not suspect), and which ‚Äúexamples "- just a figment of the imagination of the author, who wrote, but did not check it, hoping that he would run it. <br><br>  Ok, you went through all these stages, NOW everything is clear to you. <br><br>  You correctly connect all the pins of the chip to what you should, correctly connect the chip to the processor, correctly set all the registers and what else it has inside, and lo and behold!  - finally‚Ä¶ <br>  Yes, everything is in order - nothing worked. <br><br>  This is the most nasty stage - when everything is done correctly and strictly according to the datasheet, but it still does not work.  You have a long and dreary understanding of what the problem is, and finally find 1 ... 5 ... 17 bugs.  Well, of course!  This is what was said in datashit / errata.  Well, now it is clear what exactly they had in mind (and what you yourself could guess). <br><br>  Everything. <br>  Application earned. <br>  Now you are special on this chip. <br>  Fanfare  Award.  Beer.  Crowds of fans.  Glory and the next didline. <br></div></div><br><br>  This article is designed to help readers skip the tedious stages and go straight to the ‚Äúeverything worked‚Äù stage and then - in the text. <br><br><h4>  Lyrics - 2 (you can skip) </h4><br>  Many years ago (even a little more), back in pre-Windows98 times, my friend cooked that they were saying that these false users had divorced, the DOS commands don‚Äôt know, they think that if there is Windows 3.11, then go in config.sys not necessarily, but there too, they want a computer. <br><div class="spoiler">  <b class="spoiler_title">skip Lyrics 2?</b> <div class="spoiler_text"> I have always believed that someone likes to poke around inside, but someone just wants to use and not to bathe.  And both species have the right to exist.  (Guy Kawasaki: ‚Äú... How can a microwave give an error message? A microwave should just warm up! No one should go through special microwave programming courses!‚Äù). <br><br>  Today, complaints are often heard that, well, they say, these Arduins spoil the people and multiply ignoramuses - there is no need to unlearn years n and gain experience for another years n + 1 - everyone rushed to rivet their projects, not trying to get deep knowledge in programming and electronics. <br>  Horror, horror. <br>  So what? <br>  I think that this is normal - a person with a creative streak and creative thought came up with an idea (or vice versa) and wants to realize it.  Not having the deepest knowledge.  And that's fine. <br><br>  Also, at the dawn of the Internet, there was such a mod proudly pointing at the bottom of the page: ‚Äúthe site was created entirely manually in notepad.exe.  No HTML editors! ‚Äù.  Nothing like? <br><br>  At the same time, for example, I did not start from C and not even from assembler - my first computer, built from scratch and completely empty, to fill in at least a bootloader for it, I programmed in binary code with 16 address bus switches and 8 data bus toggle switches. <br>  For a long time in a dream, long rows of large red zeros and ones came to me, and when mother sent me to buy bread, my first thought was: </div></div>  "To go for bread ... this is what CODE?" <br><br>  And even I, a bugger with experience, support progress, increased opportunities for newcomers, and a variety of user types. <br><br><h4>  Client - Server.  In outline </h4><br>  It probably makes sense to start from the end and move up. <br><br>  You launch the browser program, enter the site name in it - and get the contents of the web page on the screen. <br>  Of course, the browser does not get a beautiful page with pictures, but a bunch of text, HTML tags, links to pictures / videos, etc., puts it all together, and gives you a beautiful (sometimes) web page. <br><br>  All this is transmitted between the server and the browser via HTTP, which also controls the establishment of the connection between them and their behavior. <br><br>  Since we are dealing with a network / Internet, then in order to be transferred according to the rules adopted on the network / Internet, all this data (HTML, around which HTTP is wrapped) is wrapped in a new ‚Äúlayer‚Äù - TCP / IP. <br><br>  TCP (Transmission Control Protocol) is used to ensure guaranteed connection and delivery of data packets.  Web browsers (like email clients) use TCP. <br><br>  Probably, I should mention that in addition to TCP, there is also User Datagram Protocol (UDP), which is not at all puzzled by such trifles as establishing a connection and guaranteed message delivery, and since it doesn‚Äôt waste time, it writes packets like a machine gun , but it can be used only if the connection (channel) is of high quality and reliable, or if there are no strict requirements for the loss (or, more precisely, NOT the loss) of packets (God, who counts them!). <br><br>  In this article, UDP will not be considered, but the W5100 can also. <br><br>  Since our web server will be connected to the computer via an Ethernet connection, it all turns into another layer - Ethernet frames. <br><br>  In fact, as you know, we could transmit TCP / IP even over a normal RS-232 channel, without any Ethernet. <br><br>  So, we have a nested doll: Ethernet frame, consisting of service bytes ("headers") and bytes with the actual data (Payload). <br><br>  This data contains TCP / IP packets, which, in turn, also consist of header bytes and the actual data. <br><br>  And these latest data, in turn, consist of HTTP-headers and have long been waiting and had a little cool HTML-formatted text and / or images. <br><br>  We will omit the tale about Ethertet, TCP and IP, because the W5100 takes all these difficulties on us, removing the headache from us (this is its beauty!) (I mean the beauty of the W5100, not a headache). <br><br>  But we‚Äôll stop on HTTP a bit more, because we‚Äôll have to pick it up from the W5100 and process it (when the web browser makes a request to our server) and vice versa - create it and give it to the W5100 when we (the server) answer the web the browser. <br><br>  Fully disclose all the nuances of the HTTP protocol in this article is not possible (referring to HTTP / 1.1 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">RFC 2616</a> curious), here we will look at the most basic and what will help us to raise a simple (but quite usable) web server. <br><br>  When we open a web site with a browser (for example: <a href="http://opticaldt.us/">opticaldt.us</a> is not an advertisement!), The browser sends a request to the web site server: <br><br> <code>GET / HTTP/1.1 <br> Host: opticaldt.us <br> Connection: keep-alive <br> Cache-Control: max-age=0 <br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 <br> User-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 <br> Accept-Encoding: gzip,deflate,sdch <br> Accept-Language: en-US,en;q=0.8,ru;q=0.6</code> <br> <br>  Pay attention to this line: GET ... <br><br>  After ‚Äú... /‚Äù and before ‚ÄúHTTP / 1.1‚Äù it is empty. <br>  This means that, by default, the index.html file (or index.htm) is requested. <br>  If there really is an index.html file in this subdirectory on the server, then the browser will open it successfully.  If this file does not exist (or, in general, you made a request for the missing file with any name and extension), the server will respond to you with the ‚Äúerror 404‚Äù page (which also does not come from the air ‚Äî giving it in response to an incorrect request is the server‚Äôs task. there is now directly you must create such a page). <br><br>  As can be seen from the title, the client (browser) reports a lot of interesting and useful about itself. <br>  Since our server will be quite simple, and we will not send anything so special to the client (for example, we will not pull out all intimate details from the header and wow the user with something like, ‚ÄúHello, you came from such and such ip, then the address on the second floor, although the apartment is not yours at all, the provider‚Äôs bill will end in 3 days, don‚Äôt forget to replenish, it‚Äôs time to feed your cat Fedor, with such a resolution of the screen and WindowsXP it‚Äôs not good to visit our amazing site that looked much better would be if you were  not Mozilla, a IE 11, oh yeah, you have a Ukrainian ip, that's why ‚Äúhealthy bulls‚Äù, although no, this is Evpatoria, therefore ‚Äúhello again! Etc., etc.), we only the first line will be interested in the request from the browser - we will need it, as people say, ‚Äúparse‚Äù to find out exactly which file the client (browser) wants to receive from our server. <br><br>  In the simplest version, just to test that the server is working, you can generally send the same HTML page to any request (that is, a request from any file). <br>  (Looking ahead, in our example, we will still give the ‚Äúfile‚Äù to index.html if they request it, and the page with an error, if they request something else). <br><br>  So, we made the above request, by lucky coincidence on this site in this place there is an index.html file, and the server responds to the browser with a message consisting of the header and the actual contents of the index.html file: <br><br> <code>HTTP/1.1 200 OK <br> Date: Sun, 13 Jul 2014 21:32:49 GMT <br> Server: Apache <br> Accept-Ranges: bytes <br> Vary: Accept-Encoding <br> Content-Length: 185 <br> Keep-Alive: timeout=5, max=100 <br> Connection: Keep-Alive <br> Content-Type: text/html</code> <br> <br><pre> &lt;html&gt; &lt;head&gt; &lt;meta http-equiv = "Content-Type" content = "text / html; charset = Windows-1251"&gt; &lt;title&gt; W5100 WebServer &lt;/ title&gt; &lt;/ head&gt; &lt;body&gt; &lt;center&gt; Well, sho, &lt;br&gt; &lt;b&gt; hello World?! &lt;/ b&gt; &lt;/ center&gt; &lt;/ html&gt;
</pre><br><br>  In the first line (‚Äú... 200 OK ..‚Äù) the server reports that the request is correct (that is, there is such a file). <br>  In the ‚ÄúContent-Length: 185‚Äù line, the server warns the client (that is, the browser) about the length of the transmitted file (more precisely, specifically and specifically about the length of the <b>web page</b> that comes immediately after the HTTP headers). <br><br>  In order to ensure more or less correct work with the browser, we (the server) will have to give in response (in addition to the HTML file) at least three parameters in the HTTP header: <br><br>  HTTP / 1.1 200 OK <br>  Content-Type: text / html (if we send exactly this, and not, for example, a picture). <br>  Content-Length: (calculate later) <br><br>  In fact, modern browsers are very liberal, so you can discard the third header line.  Moreover, in our example, after giving the ‚Äúweb page‚Äù to the client, we break the connection, so the client (browser) will guess that he has received everything. <br><br>  But ... If your page is long, or, for example, you are going to send pictures, etc.  - it is better to specify the length of the sent data block (Content-Length). <br><br><h4>  Just a little bit about TCP / IP </h4><br>  When I wrote above that the W5100 does all the work for us with Ethernet and TCP / IP, I just embellished the reality.  Something (quite a bit) we still have to do ourselves.  Namely: to manage the process of establishing a connection and its termination. <br><br>  In short, the server and the client communicate by transferring IP packets to each other, which may contain ‚Äúuseful‚Äù data (for example, an HTML page), and may be purely official, without ‚Äúuseful‚Äù data. <br><br>  Let's open the datasheet of the W5100 chip (yes, now it's time) and consider how the client (browser) and the W5100 communicate in server mode: <br><br><img src="http://habrastorage.org/files/f8b/b3c/b49/f8bb3cb491de42069e8cc8dfb57bd193.jpg" alt="image"><br><br>  Initially, the W5100 in OPEN mode opens / creates a socket (network connection) and enters the listening mode (LISTEN), waiting for a request from a client (ie, a browser). <br><br>  When a request from the client arrives, and a connection is established between the server and the client, the server (W5100) switches to ESTABLISHED mode and <b>data</b> is <b>exchanged</b> between the parties. <br><br>  <i>Note: according to the charter, the maximum size of data in the IP packet is 1500 bytes.</i>  <i>If your data does not fit into one package (large size of HTML code, or you need to transfer a picture and so on), you will have to divide the data into portions less than 1500 bytes and transfer them one by one.</i> <br><br>  Further, when the parties expressed to each other everything that went up in their souls, one of them (as in life) was the first to ‚Äúhang up‚Äù by sending a Disconnect Request. <br><br>  <i>Note: the disconnection does not always occur after the (full) data transfer.</i>  <i>For example, you have a slow channel, or interference has gone, and the browser is tired of waiting for completion and has disconnected due to a timeout.</i>  <i>Either something went wrong at the web server and he decided to terminate the connection in the most interesting place.</i>  <i>Well, in general, anything in life happens.</i> <br><br>  After the connection between them is broken, the server goes into the mode of closing the connection (socket) - CLOSED (no, well, everything that was needed - it was said / sent, why still wait for that?). <br><br>  Everything. <br><br>  If you are a supporter of fleeting connections and / or once you have more than enough - you can stop there. <br>  If you are an optimist in life (or just persistent) and believe that your server may well still be contacted, and more than once - you just need to go back to the ‚ÄúOPEN‚Äù step and then follow the picture.  (Decent servers usually do this).  Although ... maybe in the future there will be cheap plastic disposable server?  Type used 1 time - and threw it away? <br><br>  One could do without it (thanks to the W5100), but I‚Äôll still mention.  In real life, with each exchange of akket between the client and the server and with each change of the connection status, flags are set in the packets that are sent, indicating what is happening and how to live with it. <br><br>  Take the most common IP stack: <br><br>  <i>Let no one be frightened by the beautiful word ‚Äústack‚Äù; sorcerers and magicians from IBM-360 and AS-400 specially invent intricate terms in order to suppress any desire of ordinary mortals to touch their Temple with unwashed hands.</i>  <i>In fact, this is just a protocol, a data transfer format, in which how long and in which order the service fields and the actual data follow.</i>  <i>(Zhvanetsky: "... and even the Bulgarians cannot understand our expression, that" despite the weather conditions "- it means just rain!")</i> <br><br><img src="http://habrastorage.org/files/d21/cab/d4a/d21cabd4ac0343649bde7c0c51bc1a32.jpg" alt="image"><br><br>  We are interested in the three bits in the seventh byte: FLAGS. <br><br>  The combinations of these three bits form the following flags: FIN, SYN, RST, PSH, ACK, URG. <br><br>  FIN - indicates the end of the session; <br>  SYN - connection initialization; <br>  RST - interruption of the connection (usually in response to an error); <br>  ACK - acknowledgment of receipt (packet); <br>  PSH - simply - the requirement for the immediate expulsion of confirmation; <br>  URG - an indication of the aristocracy of this package. <br><br>  If you are curious (which is commendable and useful), how in reality is the exchange of packages and which flags are set and in which cases, and everything else - what are the other header fields for (good, good, ‚Äústack‚Äù) - you have to find it yourself.  In this article, we will not consider this, since the W5100 takes all the care of the packages and flags, but we are dealing with an accomplished fact - the status of the connection at the moment (OPEN, LISTEN, ESTABLISHED, CLOSED). <br><br><h4>  As brief as possible, the description of the W5100 </h4><br>  Well, further it is not possible to delay this moment, it is time to consider the W5100 from the hardware and software sides. <br><br><img src="http://habrastorage.org/files/d42/b46/2ee/d42b462ee17d40f89b2548588ed909ef.jpg" alt="image"><br><br>  On the one hand, the W5100 is connected to the Ethernet connector (via a transformer and matching circuits), on the other hand, from a microcontroller. <br>  It can be connected to the microcontroller (to taste and situation) either using address and data buses, or via the SPI interface. <br>  How exactly to connect the chip - I will not begin to paint, there are many ready-made diagrams with a description on the Internet.  Especially (well, I will reveal the secret) that in our example we will use a ready-made board with this chip. <br><br>  The chip contains Ethernet PHY and MAC, implemented in hardware handlers for Ethernet frames and several IP group protocols, allows you to create up to 4 sockets (network connections) and contains RX and TX buffers with 8K bytes of memory each, which can be distributed between each socket fraternally or fairness (or equally), allocating 1,2,4 or 8 KB per socket (but not forgetting that the size of the entire buffer is 8KB for reception and 8KB for transmission). <br><br>  Memory allocation: <br><br><img src="http://habrastorage.org/files/b3c/643/9dc/b3c6439dc10c485cbda5657c2ec1e7bb.jpg" alt="image"><br><br>  As can be seen from the figure: <br><br>  from the address 0x0000 to the address 0x002F are common to all registers, <br>  from the address 0x0400 to the address 0x07FF - 4 identical groups of registers - one for each socket, <br>  from the address 0x4000 to the address 0x5FFF - transfer buffer (8KB), which you can distribute between sockets at your discretion, <br>  from address 0x6000 to 0x7FFF - receive buffer (8KB), which you can also distribute between sockets at your discretion. <br><br>  All registers are 8 bit.  Most can be both read and write. <br><br>  We will not consider all registers, but only those that we need to create a web server, however, you can easily understand the general idea and further develop it for your specific tasks. <br><br>  <i>An important point: the W5100 uses the byte order, which is popularly called ‚Äúbig endian‚Äù or ‚Äúnetwork order‚Äù.</i>  <i>The deep scientific meaning comes down to the fact that the high bit of the high byte goes first (transmitted) and the last low bit of the low byte, and, most importantly, the <b>high</b> bytes are located in the <b>lower</b> memory addresses.</i>  <i>Ie, for example, to write 4 bytes of the IP address of your server (say 192.168.0.155) to the Source IP Address 0x000F ... 0x0012 (SIPR0 ... SIPR3) registers, you should write "192" to the SIPR0 register, "168" - in SIPR1, "0" - in SIPR2 and "155" - in SIPR3.</i> <br><br><h4>  General registers </h4><br>  (General means they affect the operation of the whole chip and all sockets, that is, <b>they do not</b> refer to a <b>specific</b> socket). <br><br>  0x0000 MR - Mode - everything is clear here - through them we set the mode of operation; <br>  0x0001 ..0x0004 GAR0..3 - Gateway Address (ex. 192.168.0.254); <br>  0x0005 ... 0x0008 SUBR0..3 - Subnet mask Address (ex. 255.255.255.0); <br>  0x0009..0x000E SHAR0..5 - Source Hardware Address <br>  (to put it simply - MAC address, for example, 0A 1B 2C 3D 4E 5F). <br>  (if you are not going to flood the market with your servers, you can specify any MAS, the main thing is that there are no devices with the same MAC address in your network - we don‚Äôt need conflicts, right?) <br><br>  0x000F ... 0x0012 SIPR0..3 - Source IP Address - the address of our web server, for example: 192.168.0.155; <br>  0x001A - RMSR - RX Memory Size - here you specify how much memory the receive buffer will have on each socket; <br>  0001 - MSR - X Memory Size - here you specify how much memory of the transmission buffer will be on each socket; <br><br><h4>  Socket registers </h4><br>  In our example, we will work with only one socket and only with its registers that are needed for a TCP / IP server, therefore, we consider only these registers: <br><br>  00400 S0_MR - Socket0 Mode Register - set the mode of operation of this particular socket; <br>  00401 S0_CR - Socket0 Command Register - here we will issue commands to control the state of the connection; <br>  00403 S0_SR - Socket0 Status Register - from here we will read data about the current status of what is happening; <br>  0x0404, 0x0405 S0_PORT0, S0_PORT1 - Socket0 Source Port - the port on which our server is available (if more correct - the port on which the socket opened by us is available). <br><br>  To be honest, when accessing the service, we must fully indicate the protocol, server address of the service, and port number (as well as the file name and full path to it). <br><br>  For example, if we need the index.html file located on the server with the address 192.168.0.155 with access to the socket through port 123, then in the browser URL line (that is, in the address line) we will need to write: <br><br>  <a href="http://192.168.0.155/">192.168.0.155</a> : 123 / index.html <i>(wait until you press Enter).</i> <br><br>  But ... For connections of the "http: // ..." type (that is, for the HTTP protocol), it is customary to allocate port 80. <br>  Therefore, if we assign port number 80 to Socket0 Source Port, we can omit it in the address bar of the browser, because if the port is not specified, the browser will by definition refer to this port, resulting in a URL of the form <a href="http://192.168.0.155/index.html">192.168.0.155/index. html</a> will work fine without errors.  (Speaking more generally, this is true for all cases for which there are default ports <br>  - if you do not specify them when accessing the service, the client goes to the default port: 80 for HTTP, 23 for Telnet, and so on). <br><br>  Also, as we discussed earlier, if you do not specify the name of the requested file, it is customary for both parties to mean that we are talking about the index.html (or index.htm) file (or index.php).  Therefore, specifying in the address bar of the browser: <a href="http://192.168.0.155/">192.168.0.155</a> , we will get the correct response from the server (that is, if the client does not ask us for a specific file name, then we understand that he is waiting for the index file) (remember that if for example, a client has requested a directory, the contents of which we are embarrassed to show to everyone and everyone (for example, pictures with cats, or scripts, etc.), it will be quite comical to give him a ‚Äú404 error‚Äù page. <br><br>  Well, in order to completely save time on entering the address - if you do not specify the type of protocol, the browser will automatically assume that this is HTTP (if, of course, the browser is not IE who loves it ... Ok, it doesn‚Äôt matter, forget it). <br><br>  Thus, simply by writing in the address bar 192.168.0.155 - all parties will understand that we are talking about <a href="http://192.168.0.155/">192.168.0.155</a> : 80 / index.html <br><br>  So it's decided, yes?  Let's set the address of the socket port - 80 in our server. <br>  At the same time, we don‚Äôt forget about ‚Äúbig endian‚Äù, therefore 80 (more precisely - 0080) will be written like this: S0_PORT0 = 00, S0_PORT1 = 80 (yes, and do not forget - these are decimal ‚Äú80‚Äù, not hexa). <br><br>  00420, 00421 S0_TX_FSR0, S0_TX_FSR1 - Socket0 TX Free Size - the size of the free space in the transfer buffer of Socket 0; <br>  0x0422, 0x0423 S0_TX_RD0, S0_TX_RD1 - Socket0 TX Read Pointer (* read only) - indicates in the transmission buffer the beginning of the data block, which (data) we are going to send to the client. <br><br>  <i>There is a tricky trick (Wiznet decided to chew up kanfetku): if, for example, you read Socket0 TX Read Pointer, and he points, for example, to the address 0x4200, then ... correctly - this does not mean at all that you have to write your transmission data buffer starting from this place.</i>  <i>Aha, aha ... ("if a woman behind the wheel shows a left turn - this does not mean that she is going to go straight!" (C)).</i>  <i>We will talk more about this later.</i> <br><br>  00424, 00425 S0_TX_WR0, S0_TX_WR1 - Socket0 TX Write Pointer - indicates in the send buffer to the <b>end</b> of the data block, which (data) we are going to send to the client. <br><br>  Here it is necessary (again) to make an important explanation. <br>  The last two registers do not define the <b>physical</b> addresses at which we have to write a block of data for transmission in the buffer.  We must calculate these addresses ourselves. <br><br>  One more note: let's say you allocated 2K to the transfer buffer.  You read Socket0 TX Read Pointer and it turned out that it points to the last 10 bytes of the buffer.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In general, you intended to transfer (ie, write to the buffer) 1000 bytes. </font></font> What to do? <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's simple: you write your data to transfer to these 10 bytes, then go to the very beginning of the buffer and continue to write the rest of the data further (ie, 1000 of your data, 10 bytes will be placed at the end of the buffer, and the rest 990 bytes - at the beginning buffers). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The W5100 knows about this disgrace (in fact, he nagged them) and therefore, having reached the end, he will jump to the beginning of the buffer and patiently read the remaining portion. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, now let's deal with this mutant - as from the pointers specified in the registers, calculate the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">physical</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> addresses at which you should write the data to the transfer buffer.</font></font><br><br> ,     ,    ,       ,      ,         3   ,         . <br><br>  ,  -   ,          ,            . <i>(     ,   ; , , ).</i> <br><br> ,    : <br><br> S0_TX_BASE ‚Äî     0. <br><br>       ,      04000. <br>       W5100     ?  , ,  ¬´¬ª       <b></b> ,     ( )     01984. <br> :   0  ,    1 (    )     ,       <b> </b> . <br>      ,   ¬´-¬ª  TMSR  (   ),         ,    ¬´¬ª        . <br><br>  ,   ,      ,  ,  : <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S0_TX_BASE = 0x4000. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S0_TX_MASK - mask, we will need further in the "calculations". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, the mask, in an amicable way, must be calculated for each socket on the basis of what is written (by the way, by you) in the register of memory allocation of the buffer between sockets (TMSR). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I do not calculate anything (I used to think that I was a bummer, but when I became a regular reader, Habra found out that everything is alright - I just have procrastination), I allocated 2KB for each socket (which, as you remember, are not equal to 2000 grams, but 2048 bytes), respectively, the mask is 2048 -1 = 2047 (0x07FF). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total, in our example will be: S0_TX_MASK = 0x07FF. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we add confusion, and then unraveling it with honor:</font></font><br><br>    ,  (read only) S0_TX_RD0, S0_TX_RD1‚Äì         ,     . <br>     ‚Äì       ,    ,  , <b>  </b> (,       ,      ). <br>       ,    ( )         ,  (   ),     S0_TX_WR0, S0_TX_WR1. <br><br> ,  , W5100       ,      S0_TX_RD0, S0_TX_RD1,     ,        ,     ,     ()  ,         S0_TX_WR0, S0_TX_WR1,       . <i>(,    ,  S0_TX_RD0, S0_TX_RD1    S0_TX_WR0, S0_TX_WR1).</i> <br><br> <i>,       ,     ,    ‚Äì  (   ).    ,   , coffee break  .</i> <br><br> ,    -    . <br>         5- ,    ,   ,  . <br><br>   : <br><br> <b></b> : S0_TX_OFFSET = make16 ( S0_TX_RD0, S0_TX_RD1 ) <br><br> //  16-  ¬´¬ª   8- - <br> //  ,   ¬´-¬ª,      S0_TX_RD0, <br> //   ‚Äî  S0_TX_RD1 <br><br>  ,           (       ‚Äì  ),    ,   ,    ,        (   <b></b>  ). <br>         (): <br><br> S0_TX_OFFSET = ( S0_TX_OFFSET &amp; S0_TX_MASK ) <br><br>   , <b></b> ,          : <br><br> S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE <br><br>   ,     ,           ,          (0),  ()        ‚Äî    ,      . <br><br>   ,         ? <br>        () ‚Äì  Socket0 TX Write Pointer. <br><br>     Socket0 TX Read Pointer    Socket0 TX Write Pointer   . <br>   (. )        ,   (     ),    ‚Äì . <br><br> ,   ‚Äì          . <br>  Attention! ‚Äî     ,          ,            ‚Äì  . <br>            : <br><br> Socket0 TX Write Pointer = Socket0 TX Write Pointer + __. <br><br> <i>,       , ,   ¬´Socket0 TX Write Pointer¬ª (16 )     8-  S0_TX_WR0 ( )  S0_TX_WR1 ( ).</i> <br><br> <i>( ‚Äî , ‚Äî   ‚Äì     ,  ...) <br><br> !  ‚Ä¶   ,   ‚Ä¶         . ,   ,      ‚Äì     ‚Äì   ‚Äì   ,  . <br>    :     ?           ,    .     -   ‚Äì    . Deal?</i> <br><br><h4>  Algorithm </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If I had a hope to get an invite for an article, it melts with each new paragraph. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yes - the readers probably think that they bought it so they bought it on "... server in 5 minutes"! Wait - you have not seen the code yet! No, that is, it is not short, of course, but a little on the contrary, but this is all because of the abundance of comments and inserts for debugging. If you need to remove extras so that only a useful code remains - it can be written on a napkin in general! And then, it is better to spend 10 minutes reading here than 2 days to read a datasheet of 100 pages. Well, again - ‚Äúhard in training - 5 minutes in battle "- no one has canceled.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yes, so, the algorithm.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I usually like to understand what is being done in the program, and I prefer to have a flock chart. In the same way, despite the overwhelming desire to immediately write code, I usually manage to pull myself up and start by drawing a flock to first debug the logic of working on it, and only then go to the code. So, let's see how our web server will work (see picture): </font></font><br><br><img src="http://habrastorage.org/files/1c6/116/674/1c61166741984b269fd031363ae29f79.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the principle ‚Äúit‚Äôs better to see 100 times - than once to hear‚Äù still works, then there‚Äôs probably no point in describing what is written in the picture? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only two words: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Process control will occur through S0_CR (Socket0 Command Register) (00401). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checking current states (connections and other) through S0_SR (Socket0 Status Register) (00403).</font></font><br><br>  ,         (   ), , ,                 ‚Äì  . <br><br><h4>  Ethernet Shield ‚Äî  PIC  </h4><br><img src="http://habrastorage.org/files/c2f/bc7/bd5/c2fbc7bd5a38421fb1d966becfb4f61b.jpg" alt="image"><br><br>       ‚Äî    . <br><br> : 23    (  ,    ) ‚Äî    .    ,      ,   . <br><br>   ‚Äì      .     ,  ,      ,         . <br><br><h4>  ( ‚Äì !) </h4><br>    (?), ,   -   (  ) ‚Äì       ,    ,       . <br><br>    CCS .      ( ‚Äì    )    IDE. <br><br>     PIC16F77 (      -).        ( ‚Äì     )   PIC.    ,      print (        ),       . <br><br>    ,   ¬´¬ª     RS232 ‚Äî   ,    .      ‚Äì       . <br><br>       ( )   HTTP  ,  ,    .         index.html ¬´ ¬ª.  ,      ‚Äì    . <br><br>    : <br><br>  GET / HTTP / 1.1 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to the space after the first "/" and before "HTTP" - in this place </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">could be your advertisement</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> could be the name of the requested file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Once there is empty (space) - it means that it is index.html that is requested. (Ok, the explanation is not entirely correct. Usually, when visiting the site, you simply specify the name of the site, without any slash and file name there. The guys on both sides </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paid to who you need</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , agreed that if the file name is not specified, then we will issue response index file). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, entering the address of the browser in the address: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">192.168.0.155/kotiki.jpg </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send a request to the server that looks like this: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GET /kotiki.jpg HTTP / 1.1</font></font><br><br>        ‚Äî        HTTP        ‚Äì   ¬´¬ª index.html (  ).     -  ‚Äî    _404. <br><br>      ,         ,    -       HTML . <br><br> ‚Ä¶ ( <i>!   !</i> ) ,  .    :  HTTP   ,   ¬´  ¬ª,  : <br><br> HTTP/1.1 404 Page not found <br><br> (      ,    HTTP/1.1 200 OK) <br><br>      HTML        ,    ,         .  Internet Explorer. ,     ,            - Internet Explorer. <br><br> ,        ,       :    HTTP     ¬´ ¬ª  ¬´ ¬ª ‚Äî \r \n (    ASCII: 0D 0A ).      ,    (      )    . ,    HTTP    HTML     <b></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of these combinations (that is, \ r \ n \ r \ n or 0D0A0D0A in ASCII codes) otherwise not only you yourself know what browser but others will not understand you either. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oh, and more (still valuable experience and you should know about it). Another fly in the barrel of an overly scrupulous browser (well, you understand): I somehow made a mistake in the HTTP header, indicating the length of the subsequent HTML code (Content-Lenght: ...) literally indicated 1 character more than in fact (well, that is, there are symbols, say, 665, and I indicated that there would be 666). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, all browsers swallowed the page with an eye without blinking, and IE honestly waited until it was blue until the 666th character arrived and until it came - refused to show the page at all.</font></font><br><br>         -,    - .      <b></b>   ,  main(),     ‚Äì   .  ,   ,   (      )  main()         ,      ,      . <br><br> ,  ,    ping  (      ping     ( 192.168.0.155) ‚Äî   . <br>      ping ‚Äî   . <br>  /,    (   ),   ping  . <br>   ,   ping       IP ,   ICMP (Internet Control Message Protocol),     ,        IP  (  ‚Äî  <a href="http//ru.wikipedia.org/wiki/ICMP">RFC 792</a> ), ,          ,  ping-  . <br>   W5100    . <br><br>  , :        ,     ,       . <br><br>  ‚Äì    ,    ,          ,           ,      . <br><br> ,   ,     . <br>       ‚Äî     ¬´ 5 ¬ª. <br><br> -, ! <br><br><div class="spoiler"> <b class="spoiler_title">  ( -  - 6 )</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// =====  -   W5100  Wiznet ====== // *     Ethernet Shield //   W5100 //=========================================================== #include &lt;16F77.H&gt; #fuses HS //  ,  #use delay(clock=16M) ) //    16  //     ‚Äì   #use rs232(baud=19200, xmit=PIN_A2, rcv=PIN_A3) //    RS232 // *  CCS   ¬´ printf¬ª - , //       - // **   //   PICa    Ethernet Shield #define RESET pin_B2 // *active LOW #define MISO pin_B3 // input #define MOSI pin_B5 // output #define SS pin_B0 // output. SlaveSelect, Active LOW #define SCK pin_B1 // output. //**********   W5100 ********************* //************************************************************** #define MR 0x0000 // MODE register #define GAR0 0x0001 // GATEWAY Addr register0 (MSB) #define GAR1 0x0002 // GATEWAY Addr register1 #define GAR2 0x0003 // GATEWAY Addr register2 #define GAR3 0x0004 // GATEWAY Addr register3 (LSB) #define SUBR0 0x0005 // SUBNET MASK Addr register0 (MSB) #define SUBR1 0x0006 // SUBNET MASK Addr register1 #define SUBR2 0x0007 // SUBNET MASK Addr register2 #define SUBR3 0x0008 // SUBNET MASK Addr register3 (LSB) // MAC   #define SHAR0 0x0009 // SOURCE HARDWARE Addr register0 (MSB) #define SHAR1 0x000A // SOURCE HARDWARE Addr register1 #define SHAR2 0x000B // SOURCE HARDWARE Addr register2 #define SHAR3 0x000C // SOURCE HARDWARE Addr register3 #define SHAR4 0x000D // SOURCE HARDWARE Addr register4 #define SHAR5 0x000E // SOURCE HARDWARE Addr register5 (LSB) #define SIPR0 0x000F // Source IP Addr register0 (MSB) #define SIPR1 0x0010 // Source IP Addr register1 #define SIPR2 0x0011 // Source IP Addr register2 #define SIPR3 0x0012 // Source IP Addr register3 (LSB) #define RMSR 0x001A // RX memory size (1K,2K,4K or 8K per socket, from total 8K) #define TMSR 0x001B // TX memory size (1K,2K,4K or 8K per socket, from total 8K) //--  Socket0 (*       ) #define S0_MR 0x0400 // Socket0 MODE register #define S0_CR 0x0401 // Socket0 COMMAND register #define S0_SR 0x0403 // Socket0 STATUS register #define S0_PORT0 0x0404 // Socket0 SOURCE Port register0 (H byte) #define S0_PORT1 0x0405 // Socket0 SOURCE Port register1 (L byte) #define S0_TX_FSR0 0x0420 // Socket0 TX Free SIZE register0 #define S0_TX_FSR1 0x0421 // Socket0 TX Free SIZE register1 #define S0_TX_RD0 0x0422 // Socket0 TX Read POINTER register0 #define S0_TX_RD1 0x0423 // Socket0 TX Read POINTER register1 #define S0_TX_WR0 0x0424 // Socket0 TX Write POINTER register0 #define S0_TX_WR1 0x0425 // Socket0 TX Write POINTER register1 #define S0_RX_RSR0 0x0426 // Socket0 RX Received SIZE register0 (H byte) #define S0_RX_RSR1 0x0427 // Socket0 RX Received SIZE register1 ( L byte) #define S0_RX_RD0 0x0428 // Socket0 RX Read POINTER0 (H byte) #define S0_RX_RD1 0x0429 // Socket0 RX Read POINTER1 (L byte) // -----   (     0 ) ----- #define OPEN 0x01 #define LISTEN 0x02 #define CONNECT 0x04 #define DISCON 0x08 #define CLOSE 0x10 #define SEND 0x20 #define SEND_MAC 0x21 #define SEND_KEEP 0x02 #define RECV 0x40 // -----   (    STATUS 0 ) --- #define SOCK_CLOSED 0x00 #define SOCK_INIT 0x13 #define SOCK_LISTEN 0x14 #define SOCK_ESTABLISHED 0x17 #define SOCK_CLOSE_WAIT 0x1C // ----------  ¬´¬ª  ----------- #define SERVER_IP0 192 //    192.168.0.155 #define SERVER_IP1 168 #define SERVER_IP2 0 #define SERVER_IP3 155 #define SERVER_PORT0 0 //    :80 #define SERVER_PORT1 80 #define GATEWAY_IP0 192 //  .     -  #define GATEWAY_IP1 168 #define GATEWAY_IP2 0 #define GATEWAY_IP3 254 #define SUBNET_MASK0 255 //   ( ) #define SUBNET_MASK1 255 #define SUBNET_MASK2 255 #define SUBNET_MASK3 0 #define MAC0 0x00 //   , ,     #define MAC1 0x1A //        #define MAC2 0x2B #define MAC3 0x3C #define MAC4 0x4D #define MAC5 0x5E //-----------    --------------- void SSPI_write(int Data); //  1   W5100  SPI int SSPI_read ( void); //  1   W5100  SPI void SetW5100register (int16 regaddr, int data); // ()  W5100  SPI int GetW5100register (int16 regaddr); //     W5100  SPI void Init (void); //  W5100   int Open_Socket0(void); //      (/) int Listen_Socket0(void); //      (/) int Socket0_Connection_Established (void); //        (/) int Socket0_Received_Data_Size (void); //    ,    ( 0   ) void Socket0_Received_Data_Reading (void); //      //   -    int Socket0_FIN_Received(void); //       FIN   / void Socket0_Disconnect(void); //    W5100     int Socket0_Closed(void); //       / int Socket0_Connection_Timeout(void); //     -    / void Socket0_Closing(void); //   int Socket0_Received_Request_is_index_html(void); //          Index.html //   / void Socket0_Send_index_html (void); //   ¬´¬ª index.html void Socket0_Send_404_error (void); //   ¬´¬ª ¬´ 404¬ª //------------   ----------------------------------- int16 S0_RX_BASE; //   ,   RX   0 int16 S0_RX_MASK; //  RX  0 int16 S0_RX_OFFSET; //        RX  int16 S0_RX_Start_Addr; //        RX  int16 S0_RX_RSR ; //       int16 S0_TX_BASE; //   ,   X   0 int16 S0_TX_MASK; //  X  0 int16 S0_TX_OFFSET ; //        ,     //     int16 S0_TX_Start_Addr; //       ,    //      int16 S0_TX_End_Addr; //        ,   W5100 //        // ---      HTTP   ¬´-¬ª // *   [222]      .       // ** CONST ‚Äì       (   ) CONST char INDEX[222] = { "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 43\r\n\r\n&lt;HTML&gt;&lt;CENTER&gt;HELLO WORLD !&lt;/CENTER&gt;&lt;/HTML&gt;"}; //     ¬´index.html‚Äù CONST char ERROR404[222] = { "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 39\r\n\r\n&lt;HTML&gt;&lt;CENTER&gt;ERROR 404&lt;/CENTER&gt;&lt;/HTML&gt;"}; //     ¬´ 404‚Äù //     , //       ¬´ 404¬ª,     , ... //CONST char ERROR404[222] = { "HTTP/1.1 404 Page not found\r\nContent-Type: text/html\r\nContent-Lenght: 39\r\n\r\n&lt;HTML&gt;&lt;CENTER&gt;ERROR 404&lt;/CENTER&gt;&lt;/HTML&gt;"}; // ..  IExplorer   HTTP  "HTTP/1.1 404 Page not found" //    ,   ,     int try=0; // ,  .    ‚Äì  //===================== MAIN ============================================ //======================================================================= void main() { Init(); //  W5100   ( ) OpenSocket0: //ooooooooooooooooooo   0 oooooooooooooooooooooooo if ( ! Open_Socket0() ) goto OpenSocket0; //      //ooooooooooooooooo   ooooooooooooooooooooooooo if ( Listen_Socket0() == FALSE ) goto OpenSocket0; //    ¬´¬ª -      //oooooooooooooo   ? oooooooooooooo CheckConnection: // if (Socket0_Connection_Established() == FALSE ) goto CheckConnection; //      (       ) printf("&gt; Connection Established... \r\n"); //   (  )   //ooooooo(   )    - ? oooooo if ( Socket0_Received_Data_Size() == 0 ) { printf("\r\n&gt; (Zero) Received Data size is: %Lu (bytes) \r\n", S0_RX_RSR); //   (  )   goto CheckFIN; //          //      FIN } //    ( =0)        else { printf("\r\n&gt; (NonZero) Received Data size is: %Lu (bytes) \r\n", S0_RX_RSR); //   (  )   } // oooooooooo (    )  * ooooooooooooooo //         //       Socket0_Received_Data_Reading(); //   (  )   // oooooooooooooo    ooooooooooooooooooooooooooooooo //    HTTP   HTML  if ( Socket0_Received_Request_is_index_html() == TRUE) Socket0_Send_index_html (); //    "index.html"    index.html else Socket0_Send_404_error (); //        ¬´¬ª ¬´ 404¬ª //ooooooooooo   FIN ? ooooooooooooooooooooooooooo //        CheckFIN: if ( Socket0_FIN_Received() == TRUE) goto CloseConnection; //  FIN  -    0 //ooooooooooo   ooooooooooooooooooooooo Socket0_Disconnect(); //   0 //ooooooooooo   ? ooooooooooooooooooooooooooooooo if (Socket0_Closed() == TRUE ) goto CloseConnection; //    ‚Äì    //ooooooooooo    -   ? ooooooooooooooooooo if ( Socket0_Connection_Timeout() == TRUE) goto CloseConnection; //   ,   -, ‚Äì    CloseConnection: //ooooooooooo   ooooooooooooooooooooooooooooooooooo Socket0_Closing(); //oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo goto OpenSocket0; //    ,  . //         (    ¬´-¬ª ) } //=================== END of MAIN =========================== //============================================================ //--------------------------------------------------------------- //--------------------------INIT ------------------------------- void Init (void) { output_low(RESET); //  ¬´¬ª   Ethernet  delay_ms(1); output_high(RESET); output_low(SCK); //   ()  SPI output_high(SS) ; //   W5100. SetW5100register(MR, 0x80); //   RST  W5100 Mode Register //------------   (W5100)   0 ------------- SetW5100register(RMSR, 0x55); //  RX :  2    S0_RX_BASE = 0x6000; //   RX   0 S0_RX_MASK = 0x07FF ; // (2048 -1 )= 0x07FF, RX  ( = _ ‚Äì 1 ) SetW5100register(TMSR, 0x55); //  X :  2    S0_TX_BASE = 0x4000; //   TX   0 S0_TX_MASK = 0x07FF; // (2048 -1 )= 0x07FF,   ( = _ ‚Äì 1 ) //------------     -------------- // ..      W5100 // ‚Äì       SetW5100register(SHAR0, MAC0); SetW5100register(SHAR1, MAC1); SetW5100register(SHAR2, MAC2); SetW5100register(SHAR3, MAC3); SetW5100register(SHAR4, MAC4); SetW5100register(SHAR5, MAC5); //------------   IP -------------- //   -    W5100 ‚Äì   SetW5100register(SIPR0, SERVER_IP0); SetW5100register(SIPR1, SERVER_IP1); SetW5100register(SIPR2, SERVER_IP2); SetW5100register(SIPR3, SERVER_IP3); //------------   PORT -------------- //   ‚Äì   ‚Äì   SetW5100register(S0_PORT0, SERVER_PORT0); SetW5100register(S0_PORT1, SERVER_PORT1); //------------  Gateway addr -------------- //   ‚Äì   ‚Äì   SetW5100register(GAR0, GATEWAY_IP0); SetW5100register(GAR1, GATEWAY_IP1); SetW5100register(GAR2, GATEWAY_IP2); SetW5100register(GAR3, GATEWAY_IP3); //------------ set Subnet Mask -------------- SetW5100register(SUBR0, SUBNET_MASK0); SetW5100register(SUBR1, SUBNET_MASK1); SetW5100register(SUBR2, SUBNET_MASK2); SetW5100register(SUBR3, SUBNET_MASK3); printf(" \r\n\r\n &gt; =============== W5100 - ==========\r\n\r\n"); //   (  )   } //-------------------------------------------------------------- //-------------   0 ---------------------------- int Open_Socket0(void) { //   (  )   printf(" \r\n =========== TRY # %u ====================\r\n", try); if (try ==255) try =0; else try++; printf("\r\n&gt; Start Open Socket... \r\n"); //   ‚Äì   ,    SetW5100register(S0_MR, 0x01); //     ‚Äì   ( ) SetW5100register(S0_CR, OPEN); //      // *    ,  ¬´SOCK_INIT¬ª      if (GetW5100register(S0_SR) != SOCK_INIT) //  STATUS  { SetW5100register(S0_CR, CLOSE); //      return FALSE ; //     0 } return TRUE; // .    1 } //-------------------------------------------------------------- //-------------  0    ------------ int Listen_Socket0 (void) { printf("&gt; Sock opened. Go Listen... \r\n"); //   (  )   //           // * ‚Äì ..  ‚Äì ,      SetW5100register(S0_CR, LISTEN); if ( GetW5100register(S0_SR) != SOCK_LISTEN) //    { SetW5100register(S0_CR, CLOSE); //        return FALSE; //       0 } return TRUE; //    ,    1 } //-------------------------------------------------------------------------- //-------------      0 ? -------- // *     ( ) int Socket0_Connection_Established(void) { //  W5100      ,     //    ACK      SOCK_ESTABLISHED // (¬´   ) //         , //    -    if ( GetW5100register(S0_SR) == SOCK_ESTABLISHED) return TRUE ; //   . //    () = ¬´SOCK_ESTABLISHED¬ª    1 else return FALSE; //   ‚Äì    0 printf("&gt; Connection Established... \r\n"); //   (  )   // *    ,    /  } //----      ------------- //----------------------------------------------------- // * ¬´¬ª        //          // (,  /  -) int Socket0_Received_Data_Size (void) //        =    { S0_RX_RSR = make16 (GetW5100register(S0_RX_RSR0), GetW5100register(S0_RX_RSR1) ); //   8-     // RSR0 ‚Äì  , RSR1 ‚Äì   //  ¬´¬ª 16-  -    printf("&gt; Received Data size is: %Lu (bytes) \r\n", S0_RX_RSR); //   (  )   if (S0_RX_RSR == 0 ) return FALSE; //   ( .. =0 ) //    0 else return TRUE; //     ( ..  -) //    1 } //----------      --------------- //------------------------------------------------------------ // *     .    void Socket0_Received_Data_Reading (void) { int16 n; int RXbyte; S0_RX_OFFSET = make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) ); //   8-   16   - //       RX  0 printf("&gt; S0_RX_RD (RX mem read pointer) = %LX \r\n", make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) ) ); S0_RX_OFFSET = (S0_RX_OFFSET &amp; S0_RX_MASK ) ; //         0  printf("&gt; S0_RX_Offset = S0_RX_RD &amp; S0_RX_MASK = %LX \r\n\r\n",S0_RX_OFFSET ); S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE ; //         printf("&gt; S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE = %LX (physical)\r\n\r\n", S0_RX_Start_Addr ); printf("&gt; Going to print-out Received Data... \r\n\r\n"); printf("ooooooooooooooooooooooooooooooooooooooooooo\r\n"); for (n=0; n &lt; S0_RX_RSR ; n++) { if ( S0_RX_Start_Addr &gt; (S0_RX_BASE + S0_RX_MASK) ) S0_RX_Start_Addr = S0_RX_BASE; RXbyte = GetW5100register(S0_RX_Start_Addr); printf("%c", RXbyte); S0_RX_Start_Addr++; } printf("\r\noooooooooooooooo END of received data oooooooooooooo\r\n\r\n"); } // ---        INDEX.HTML  ------ //---------------------------------------------------------------------- int Socket0_Received_Request_is_index_html(void) { int RXbyte=0; S0_RX_OFFSET = make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) ); //   8-   16   - //       RX  0 S0_RX_OFFSET = (S0_RX_OFFSET &amp; S0_RX_MASK ) ; //         0  S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE ; //         printf("\r\n&gt;----------- parsing HTTP header-------------\r\n"); //   (  )   while (RXbyte != 0x2F) //   "/"  HTTP  { if ( S0_RX_Start_Addr &gt; (S0_RX_BASE + S0_RX_MASK) ) S0_RX_Start_Addr = S0_RX_BASE; //           // ,       //   ‚Äì      ‚Äì       RXbyte = GetW5100register(S0_RX_Start_Addr); //    RX ,     printf("%c", RXbyte); //   (  )   S0_RX_Start_Addr++; //   ‚Äì       } //       (¬´¬ª)    HTTP   ‚Äú/‚Äù //        "/" . //      - RXbyte = GetW5100register(S0_RX_Start_Addr); //   printf("\r\n&gt; -------- END of parsing HTTP header -------\r\n"); //   (  )   if (RXbyte == 0x20) return TRUE; //   ¬´¬ª -      ,  index.html //     1 else return FALSE; //         ,    index.html //     - 0 } //------    ¬´ 404¬ª ------------ //------------------------------------------------------------- //    0    HTTP   HTML  //  ¬´ 404¬ª,   W5100    //     ,     void Socket0_Send_404_error (void) { int16 n; char TXbyte; int16 datalength; S0_TX_OFFSET = make16 ( GetW5100register(S0_TX_RD0), GetW5100register(S0_TX_RD1) ); //   8-   16   -  //  ,        X  0 S0_TX_OFFSET = (S0_TX_OFFSET &amp; S0_TX_MASK ) ; //         0  S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE ; //           //    HTTP   HTML  datalength=0; while ( ERROR404[datalength] !=0) datalength++; //   ¬´datalength¬ª      000   // (000 -   ) //  ,  W5100   ,    //    ,   ,    . //  , W5100       . //            W5100: //     -        //     2-  // *(           //       ¬´¬ª  ) S0_TX_End_Addr = make16 ( GetW5100register(S0_TX_WR0), GetW5100register(S0_TX_WR1) ); //    -       S0_TX_End_Addr += datalength ; // increment to fatalength //   (     )  ¬´¬ª //  2       SetW5100register(S0_TX_WR0, make8( S0_TX_End_Addr ,1) ); //   SetW5100register(S0_TX_WR1, make8( S0_TX_End_Addr,0) ); //   printf("\r\n&gt;Data length is: %Lu \r\n", datalength); printf("\r\n&gt;--- Filling TX buffer w data: -----------\r\n"); //   (  )   //        ‚Äì   For (n=0; n &lt; datalength; n++) //      { TXbyte = ERROR404[n]; //     ,      ¬´ ¬ª // ( HTTP   HTML ) //  ¬´¬ª   W5100        //      ,  ,   10  //   ,         // ,        if (S0_TX_Start_Addr &gt; (S0_TX_BASE + S0_TX_MASK)) S0_TX_Start_Addr = S0_TX_BASE; // ..       ‚Äì       // * W5100     (        ))  //   - ,  ,      //(  ,       ) ‚Äì    //    //          //        ‚Äì       SetW5100register( S0_TX_Start_Addr, TXbyte ) ; putc(TXbyte); //   (  )   S0_TX_Start_Addr++ ; //    (    ) } printf("\r\n&gt;--- end of Filling -----------\r\n"); //   (  )   // ,        , // ,    ,      //      -  SEND SetW5100register(S0_CR, SEND); printf("&gt; Data was sent \r\n\r\n"); //   (  )   } //----------------------------------------------------------- //--    ¬´index.html¬ª --------------- //------------------------------------------------------------------- void Socket0_Send_index_html (void) // send index.html "page" index.html { //    ‚Äì         ¬´ 404¬ª //  ¬´¬ª  HTTP   HTML  ‚Äì  int16 n; char TXbyte; int16 datalength; printf("\r\n&gt;...... going to send INDEX.HTML.....\r\n"); //   (  )   S0_TX_OFFSET = make16 ( GetW5100register(S0_TX_RD0), GetW5100register(S0_TX_RD1) ); //  2-         S0_TX_OFFSET = (S0_TX_OFFSET &amp; S0_TX_MASK ) ; S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE ; //         printf("\r\n INDEX[i], datalegth -------------\r\n"); //   (  )   //    datalength=0; while ( INDEX[datalength] !=0) datalength++; //    ‚Äì      000 ‚Äì    printf("%c %Lu ",INDEX[datalength], datalength ); //   (  )   //   W5100        S0_TX_End_Addr = make16 ( GetW5100register(S0_TX_WR0), GetW5100register(S0_TX_WR1) ); // ¬´¬ª  2    S0_TX_End_Addr += datalength ; // increment to fatalength //      //       1-  SetW5100register(S0_TX_WR0, make8( S0_TX_End_Addr ,1) ); //   SetW5100register(S0_TX_WR1, make8( S0_TX_End_Addr,0) ); //   printf("\r\n&gt;Data length is: %Lu \r\n", datalength); printf("\r\n&gt;--- Filling TX buffer w data: -----------\r\n"); //   (  )   //   ‚Äì     For (n=0; n &lt; datalength; n++) { TXbyte= INDEX[n]; //       ¬´ ¬ª index.html // (.. HTTP Header + HTML code) if (S0_TX_Start_Addr &gt; (S0_TX_BASE + S0_TX_MASK)) S0_TX_Start_Addr = S0_TX_BASE; //       ,    ‚Äì    SetW5100register( S0_TX_Start_Addr, TXbyte ) ; //      ( ¬´ ¬ª) ‚Äì    putc(TXbyte); // printout to Terminal ( for testing purpose) //   (  )   S0_TX_Start_Addr++ ; //       } printf("\r\n&gt;--- end of Filling -----------\r\n"); //   (  )   //     ,     //      -  SEND SetW5100register(S0_CR, SEND); printf("&gt; Data was sent \r\n\r\n"); //   (  )   } //-------------------------------------------------------- //---   ,   ,   FIN ? ------ //----------------------------------------------------------------------------- int Socket0_FIN_Received(void) { //        ( ) //    FIN -     //         //    ‚Äì     0 //   1  FIN    0  FIN   if ( GetW5100register(S0_SR) == SOCK_CLOSE_WAIT) return TRUE; else return FALSE; } //--------------------------------------------------------- // ------    Socket0 ----------------- //------------------------------------------------------------- void Socket0_Disconnect(void) { //       //       0 SetW5100register(S0_CR, DISCON); } // ------   0  -------------------- //-------------------------------------------------------- int Socket0_Closed(void) { //            //   (CLOSE),   -,     //   0   // *        , //    -    If ( GetW5100register(S0_SR) == SOCK_CLOSED) return TRUE; else return FALSE; //   1   (  0)  //   0        } // -----   -   0 ? ------------ //------------------------------------------------------------- int Socket0_Connection_Timeout(void) { //    ,     ,     //     ‚Äì    - //   ,        // (   TCP  )   ,   //      // -        //     ‚Äì     0 // :  ,     ¬´SOCK_CLOSED¬ª // -     -?? //            -, //   W5100  ¬´SOCK_CLOSED¬ª     - //      ‚Äì   If ( GetW5100register(S0_SR) == SOCK_CLOSED) return TRUE; else return FALSE; //   1  - ,   0  -   } // ------------  0 ---------------------------- //---------------------------------------------------------------- void Socket0_Closing(void) { // should be performed in case that connection is closed after data exchange, // socket should be closed with Timeout occurrence, // or forcible disconnection is necessary due to abnormal operation etc. printf("&gt;going to Close Socket0 ..... \r\n"); //   (  )   //     0     SetW5100register(S0_CR, CLOSE); printf("&gt; ------ Socket CLOSED ----- \r\n\r\n"); //   (  )   } // ----  ()   SPI ------------- //-------------------------------------------------------- //*     ¬´SSPI¬ª ,      //   (SPI‚Ä¶ )  .      //      ()   ‚Äì     //   ‚Äì     SPI //    ¬´¬ª  (    )  //   -      //*    -   W5100     0  1 void SSPI_write( int Data) { int i; int mask=0x80; //      (    ) //     SPI  W5100   //    -   ( MSB first) output_low(SCK); //       ‚Äì  ¬´¬ª  for (i=0; i&lt;8;i++) //    8  { output_low(MOSI); //   ¬´¬ª   -  0 if ( (mask &amp; Data) != 0) output_high(MOSI); //  ( &amp; ) =1     1 //   ‚Äì       0,    output_high(SCK); //    (  0  1) -       //    SPI ‚Äì   W5100 mask = mask&gt;&gt;1; ; //    1   // *       //        //     (  ) output_low(SCK); //  ,    ¬´¬ª  ( 0 ) } // ¬´..    ¬ª () } //---------------------------------------------------------- //-----------     SPI ------------------ //----------------------------------------------------------- //*    ¬´SSPI¬ª ,      //   (SPI‚Ä¶ )  .      //        ‚Äì     //   ‚Äì    //    ¬´¬ª  //     // *     W5100 -      1  0 //*           //           0  1 //         1,   //  ¬´¬ª     1  0 int SSPI_read ( void) { int Data=0; int i; int mask=0x80; //      (    ) //     SPI  W5100   //    -   ( MSB first) output_low(SCK); //       ‚Äì  ¬´¬ª  for (i=0; i&lt;8;i++) //    8  { output_high(SCK); //    (  0  1) if ( input(MISO)!= 0) Data = Data | mask ; //    1,     ‚Äì    ¬´¬ª  mask = mask&gt;&gt;1; ; //    1   // *     //        //     (  ) output_low(SCK); //  ,    ¬´¬ª  ( 0 ) } return Data; } //--------------------------------------------------------------- //-------  ( )  W5100 ------------- //-------------------------------------------------------------- void SetW5100register (int16 regaddr, int8 data) // 2 : 16     8     { output_low(SS); //    (   0) SSPI_write (0xF0); //       //* make8 ‚Äì  16  -  8  SSPI_write ( make8(regaddr,1) ); //      (MSB) //     SPI SSPI_write ( make8(regaddr,0) ); //      (LSB) //     SPI SSPI_write (data); //   SPI      output_high(SS); //   (   1) } //--------------------------------------------------------- //-----    W5100 ---------- //---------------------------------------------------- int GetW5100register (int16 regaddr) // ‚Äì 2-   // : 1      { int RegData; output_low(SS); //    (   0) SSPI_write (0x0F); //     //* make8 ‚Äì  16   8  SSPI_write ( make8(regaddr,1) ); //      (MSB) //     SPI SSPI_write ( make8(regaddr,0) ); //      (LSB) //     SPI RegData = SSPI_read (); //    W5100    (8 ) //       output_high(SS); //   (   1) return RegData; //     } //************* END of PROGRAM **************</span></span></code> </pre><br><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/230661/">https://habr.com/ru/post/230661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../230649/index.html">Functional Javascript. We write our lenses, part 1</a></li>
<li><a href="../230651/index.html">An overview of the ST Nucleo developer platform using the example of Nucleo-F401RE</a></li>
<li><a href="../230655/index.html">Beaver mysql logger or how to find an error in the MySql application</a></li>
<li><a href="../230657/index.html">Ulefone U7 - thin phablet</a></li>
<li><a href="../230659/index.html">Home library of the modern child</a></li>
<li><a href="../230663/index.html">Java Garbage Collection on Infobox Jelastic cloud hosting</a></li>
<li><a href="../230665/index.html">‚Äú65K methods will be enough for everyone‚Äù or how to deal with the limit of DEX methods in Android</a></li>
<li><a href="../230667/index.html">NASA is considering the placement of cosmonaut settlements on the moon in lunar caves</a></li>
<li><a href="../230669/index.html">Interactive - a new scientific term or a manifesto of love for games</a></li>
<li><a href="../230671/index.html">Chart rendering: not as easy as it sounds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>