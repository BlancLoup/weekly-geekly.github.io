<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Code readability</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The code creates interfaces. But the code itself is an interface. 
 Although the readability of the code is very important, the concept is poorly defi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Code readability</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/alconost/blog/443678/"><img src="https://habrastorage.org/webt/g-/nh/_a/g-nh_a2awcaa_upnpuhgq2hch6g.jpeg"></a> <br><br><h3>  The code creates interfaces.  But the code itself is an interface. </h3><br>  Although the readability of the code is very important, the concept is poorly defined - and often in the form of a simple set of rules: use meaningful variable names, break large functions into smaller ones, use standard design patterns. <br><br>  At the same time, everyone probably had to deal with a code that complies with these rules, but for some reason represents some kind of mess. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can try to solve this problem by adding new rules: if the variable names become very long, you need to refactor the main logic;  if in one class a lot of auxiliary methods have accumulated, it may be necessary to divide it into two;  You cannot use design patterns in an inappropriate context. <br><br>  Such instructions turn into a labyrinth of subjective decisions, and in order to navigate it, you will need a developer who can make the right choice ‚Äî that is, he should already be able to write readable code. <br><br>  Thus, a set of instructions is not an option.  Therefore, we will have to form a broader view of the readability of the code. <br><br><h2>  What is readability for? </h2><br>  In practice, good readability usually means that the code is pleasant to read.  However, such a definition does not go far: firstly, it is subjective, secondly, it binds us to reading plain text. <br><br>  An unreadable code is perceived as a novel that pretends to be a code: a lot of comments revealing the essence of what is happening, sheets of text that need to be read sequentially, clever wording, the only meaning of which is to be ‚Äúsmart‚Äù, fear of re-use of words.  The developer tries to make the code readable, but targets the wrong type of reader. <br><br>  The readability of the text and the readability of the code are not the same. <br><br>  <b>Transferred to <a href="https://alconost.com/%3Futm_source%3Dhabrahabr%26utm_medium%3Darticle%26utm_campaign%3Dtranslation%26utm_content%3Dcode">Alconost</a></b> <br><a name="habracut"></a><br><blockquote>  The code creates interfaces.  But the code itself is an interface. </blockquote><br>  If the code looks beautiful, does it mean that it is readable?  Aesthetics - a pleasant side effect of readability, but as a criterion is not very useful.  Perhaps, in extreme cases, the aesthetics of the code in the project will help to retain employees - but with the same success you can offer a good social package.  In addition, everyone has their own idea of ‚Äã‚Äãwhat ‚Äúbeautiful code‚Äù means.  And over time, this definition of readability turns into a maelstrom of controversy about tabulation, spaces, brackets, camel notation, etc. It is unlikely that someone will lose consciousness after seeing the wrong indents, although this attracts attention during code checking. <br><br>  If the code gives fewer errors, can we consider it more readable?  The fewer mistakes, the better, but what is the mechanism here?  How do you attribute the vague pleasant sensations that you experience when you see a readable code?  In addition, no matter how frowning when reading the code, it will not add errors. <br><br>  If the code is easy to edit, is it readable?  But this is probably the right direction of thought.  Requirements change, functions are added, errors occur - and at some point someone has to edit your code.  And in order not to create new problems, the developer needs to understand what he is editing and how changes will change the behavior of the code.  So, we have found a new heuristic rule: a readable code should be easily edited. <br><br><h2>  Which code is easier to edit? </h2><br>  Immediately I want to blurt out: "The code is easier to edit when the names of variables are given meaningfully," but in this way we will simply rename "readability" to "ease of editing."  We need a deeper understanding, not the same set of rules in a different guise. <br><br>  Let's start by forgetting for a moment that this is about code.  Programming, which is several decades old, is only a point on the scale of human history.  Having limited ourselves to this ‚Äúpoint‚Äù, we will not be able to dig deeply. <br><br>  Therefore, we will look at readability through the prism of interface design, which we encounter at almost every step - and not only with digital ones.  The toy has the functionality that makes it ride or squeak.  The door has an interface that allows you to open, close and lock it.  The data in the book is collected in pages, which provides faster random access than scrolling.  Studying design, you can learn much more about these interfaces - ask the design team if there is such an opportunity.  In the general case, we all prefer good interfaces, even if we do not always know what makes them good. <br><br>  The code creates interfaces.  But the code itself, in combination with the IDE, is an interface.  Interface designed for a very small group of users - our colleagues.  Further we will call them ‚Äúusers‚Äù - to remain in the user interface design space. <br><br>  With this in mind, consider the following examples of user paths: <br><br><ul><li>  The user wants to add a new feature.  To do this, you need to find the right place and add a function without generating new errors. <br></li><li>  The user wants to correct the error.  He will need to find the source of the problem and edit the code so that the error disappears and no new errors appear. <br></li><li>  The user wants to make sure that in boundary cases the code behaves in a certain way.  He will need to find a certain piece of code, then follow the logic and model what will happen. <br></li></ul><br>  And so on: most paths follow a similar pattern.  In order not to complicate matters, let us consider specific examples - but do not forget that this is about finding common principles, and not drawing up a list of rules. <br><br>  You can confidently assume that the user will not be able to immediately open the desired piece of code.  This also applies to your own hobby projects: even if a function is written by you, it is very easy to forget where it is.  Therefore, the code must be such that it is easy to find the right one. <br><br>  To implement a convenient search, you need some search engine optimization - it‚Äôs here that we come to the rescue meaningful names of variables.  If the user cannot find the function by moving through the call stack from a known point, he can start a search for keywords.  However, you cannot include too many keywords in the names.  When searching by code, the only entry point is searched for, from where you can continue working.  Therefore, the user needs to help get to a specific place, and if you overdo it with keywords, there will be too many useless search results. <br><br><blockquote>  If the user has the opportunity to immediately verify that at a particular level of logic, everything is correct, he can forget the previous layers of abstraction and free the mind for the next. </blockquote><br>  You can also search using autocompletion: if you have a general idea of ‚Äã‚Äãwhat function you need to call or which enumeration to use, you can start typing the suggested name and then choose the appropriate option from the autocompletion list.  If the function is intended only for certain cases or you need to carefully read into its implementation due to the peculiarities of its use, you can indicate this by giving a more authentic name: by scrolling the auto-completion list, the user will rather avoid what looks difficult - if, of course, he is not sure , what is he doing. <br><br>  Therefore, short normal names are more likely to be perceived as default options suitable for ‚Äúrandom‚Äù users.  There should be no surprises in functions with such names: you cannot insert setters into functions that look like simple getters - for the same reason that the ‚ÄúView‚Äù button in the interface should not change user data. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cc/a47/753/3cca47753d7f089d36509f51e84c9054.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/43d/3c4/2c543d3c4b9f902b9efc344a6993088f.png"><br>  <font color="#0096d6"><i>In the interface facing the client, familiar functions, such as a pause, are almost without text.</i></font>  <font color="#0096d6"><i>As the functionality becomes more complex, the names are lengthened, which makes users slow down and think.</i></font>  <font color="#0096d6"><i>Screenshot - Pandora</i></font> <br><br>  Users want to find the right information quickly.  In most cases, compilation takes considerable time, and in the running application you will have to manually check many different borderline cases.  Whenever possible, our users will prefer to read the code and understand how it behaves, rather than setting breakpoints and running the code. <br><br>  To do without running the code, two conditions must be met: <br><br><ol><li>  The user understands what the code is trying to do. <br></li><li>  The user is sure that the code does what it says. <br></li></ol><br>  Satisfying the first condition helps abstraction: users should be able to dive into the layers of abstraction to the desired level of detail.  Imagine a hierarchical user interface: at the first levels, navigation is carried out through extensive sections, and then it is becoming more and more concrete ‚Äî up to the level of logic that needs to be studied in more detail. <br><br>  Sequential reading of a file or method is performed in linear time.  But if the user can move up and down the call stacks, this is already a search through the tree, and if the hierarchy is well balanced, this action is performed in logarithmic time.  Certainly, there is a place in interfaces, but it should be carefully considered whether there should be more than two or three method calls in some context. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4e/54b/63b/b4e54b63bef2986ed14b7c01475f0ac3.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff4/016/78d/ff401678d9087319f881763d6506ed17.png"><br>  <font color="#0096d6"><i>On short menus, hierarchical navigation is much faster.</i></font>  <font color="#0096d6"><i>In the "long" menu on the right - only 11 lines.</i></font>  <font color="#0096d6"><i>How often in the code of methods do we fit into this number?</i></font>  <font color="#0096d6"><i>Screenshot - Pandora</i></font> <br><br>  The strategies for the second condition are different for different users.  In low risk situations, sufficient evidence will be comments or method names.  In more risky, complex areas, as well as when the code is overloaded with irrelevant comments, the latter will most likely be ignored.  Sometimes even the names of methods and variables will be in doubt.  In such cases, the user must read a lot more code and keep in mind a more extensive model of logic.  It also helps to limit the context of small areas that are easy to keep attention.  If the user has the opportunity to immediately verify that at a particular level of logic, everything is correct, he can forget the previous layers of abstraction and free the mind for the next. <br><br>  In this mode of operation, individual tokens begin to have a greater meaning.  For example, boolean flag <br><br><pre><code class="plaintext hljs">element.visible = true/false</code> </pre> <br>  it is easy to understand in isolation from the rest of the code, but for this you need to combine two different lexemes in your mind.  If you use <br><br><pre> <b><code class="plaintext hljs">element.visibility = .visible/.hidden</code></b> </pre> <br>  then the value of the flag can be understood on the fly: in this case, it is not necessary to read the variable name to find out that it is relevant to visibility. ¬π We saw similar approaches in designing customer-oriented interfaces.  Over the past decades, the ‚ÄúOK‚Äù and ‚ÄúCancel‚Äù actions confirm buttons have become more descriptive interface elements: ‚ÄúSave‚Äù and ‚ÄúCancel‚Äù, ‚ÄúSend‚Äù and ‚ÄúContinue editing‚Äù, etc., in order to understand what will be done, it is enough for the user to look at the proposed options without reading the entire context completely. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/45c/a82/808/45ca8280883829b703ea2a0c8ae47776.png"><br>  <font color="#0096d6"><i>The string ‚ÄúOffline Mode‚Äù in the example above indicates that the application is offline.</i></font>  <font color="#0096d6"><i>The switch in the example below has the same meaning, but to understand it, you need to look at the context.</i></font>  <font color="#0096d6"><i>Screenshot - Pandora</i></font> <br><br>  The unit tests also help confirm the expected behavior of the code: they act as comments ‚Äî which, however, can be trusted to a greater degree, since they are better kept up to date.  True, for them, too, need to perform an assembly.  But in the case of a well-established CI pipeline, tests are run regularly, so if you make changes to the existing code, you can skip this step. <br><br>  In theory, security follows from a sufficient understanding: as soon as our user understands the behavior of the code, he can safely make edits.  In practice, we have to take into account that developers are ordinary people: our brain uses the same tricks and is also lazy.  Therefore, the less power you need to spend on understanding the code, the safer our actions. <br><br>  The readable code should pass most checks on errors to the computer.  One way to accomplish this is assert debugging checks, however, they also require assembly and running.  Worse, if the user has forgotten the borderline cases, ‚Äúassert‚Äù will not help.  Unit tests with frequently forgotten borderline cases can do better, but as soon as the user makes a change, they will have to wait for the tests to run. <br><br><blockquote>  Summarizing: the readable code should be easy to use.  And - as a side effect - it can look beautiful. </blockquote><br>  To speed up the development cycle, we use the error checking function built into the compiler.  Usually for such cases full assembly is not required, and errors are displayed in real time.  How to take advantage of this opportunity?  Generally speaking, you need to find situations where compiler checks become very strict.  For example, most compilers do not look at how exhaustively the ‚Äúif‚Äù statement is described, but carefully check the ‚Äúswitch‚Äù for missing conditions.  If a user tries to add or change a condition, it will be safer if all previous similar operators were exhaustive.  And at the moment of changing the ‚Äúcase‚Äù condition, the compiler will mark all other conditions that need to be checked. <br><br>  Another common readability issue is the use of primitives in conditional expressions.  This problem is especially acute when the application analyzes JSON, because you really want to put ‚Äúif‚Äù statements around a string or integer equality.  This not only increases the likelihood of typos, but also complicates users with the task of determining possible values.  When checking border cases, there is a big difference between when any string is possible and when there are only two or three separate options.  Even if the primitives are fixed in constants, it is necessary to hurry once, trying to finish the project on time, and an arbitrary value will appear.  But if you use specially created objects or enums, the compiler blocks invalid arguments and gives a specific list of valid ones. <br><br>  Similarly, if some combinations of Boolean flags are not allowed, you should replace them with one enumeration.  Take, for example, a composition that may be in the following states: buffered, loaded completely, and played.  If you present the loading and playback states as two boolean flags <br><br><pre> <b><code class="plaintext hljs">(loaded, playing)</code></b> </pre> <br>  the compiler will allow input of invalid values <br><br><pre> <b><code class="plaintext hljs">(loaded: false, playing: true)</code></b> </pre> <br>  And if you use an enumeration <br><br><pre> <b><code class="plaintext hljs">(.buffering/.loaded/.playing)</code></b> </pre> <br>  this invalid state will be impossible to specify.  In a client-centric default interface, there should be a ban on invalid combinations of settings.  But when we write code inside the application, we often forget to ensure the same protection for ourselves. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/38a/468/91e/38a46891e7b4ad809dd15e89e7e8460c.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fde/c69/142/fdec69142f6e9dd7695516b143574ec0.png"><br>  <font color="#0096d6"><i>Invalid combinations are disabled in advance;</i></font>  <font color="#0096d6"><i>users do not need to think about which configurations are incompatible.</i></font>  <font color="#0096d6"><i>Screenshot - Apple</i></font> <br><br>  Following the considered user paths, we came to the same rules as in the beginning.  But now we have a principle according to which they can be formulated independently and modified according to the situation.  For this we ask ourselves: <br><br><ul><li>  Will it be easy for the user to search for the desired piece of code?  Wouldn't the search results be cluttered with functions unrelated to the query? <br></li><li>  Will the user, having found the necessary code, quickly verify the correctness of his behavior? <br></li><li>  Does the development environment provide safe code editing and reuse? <br></li></ul><br>  Summarizing: the readable code should be easy to use.  And - as a side effect - it can look beautiful. <br><br><h4>  Note </h4><br><ol><li>  It may seem that boolean variables are more convenient to reuse, but this possibility of reuse implies interchangeability.  Take, for example, the <b>tappable</b> and <b>cached flags</b> , which represent concepts located in completely different planes: the ability to click on an item and the caching state.  But if both flags are Boolean, they can be randomly interchanged, having received a non-trivial expression on one line of code, which will mean that caching is associated with the possibility of clicking on an element.  When using enumerations, we will be forced to create explicit, verifiable transformation logic of the ‚Äúunits of measure‚Äù we use to form such relationships. <br></li></ol><br><br>  <b>About the translator</b> <br><br>  The article is translated in Alconost. <br><br>  Alconost is engaged in the <a href="https://alconost.com/services/game-localization%3Futm_source%3Dhabrahabr%26utm_medium%3Darticle%26utm_campaign%3Dtranslation%26utm_content%3Dcode">localization of games</a> , <a href="https://alconost.com/services/software-localization%3Futm_source%3Dhabrahabr%26utm_medium%3Darticle%26utm_campaign%3Dtranslation%26utm_content%3Dcode">applications and websites</a> in 70 languages.  Language translators, linguistic testing, cloud platform with API, continuous localization, 24/7 project managers, any formats of string resources. <br><br>  We also make <a href="https://alconost.com/services/video-production%3Futm_source%3Dhabrahabr%26utm_medium%3Darticle%26utm_campaign%3Dtranslation%26utm_content%3Dcode">advertising and training videos</a> - for websites selling, image, advertising, training, teasers, expliners, trailers for Google Play and the App Store. <br><br>  ‚Üí <a href="https://alconost.com/%3Futm_source%3Dhabrahabr%26utm_medium%3Darticle%26utm_campaign%3Dtranslation%26utm_content%3Dcode">Read more</a> </div><p>Source: <a href="https://habr.com/ru/post/443678/">https://habr.com/ru/post/443678/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443666/index.html">Our approach to coloring the flow</a></li>
<li><a href="../443670/index.html">Error in new version of Google Chrome (73.0.3683.75)</a></li>
<li><a href="../443672/index.html">Risk based testing</a></li>
<li><a href="../443674/index.html">Anonymous prepaid cards - how, to whom and why?</a></li>
<li><a href="../443676/index.html">Vinyl instead of a postage stamp: an unusual rarity</a></li>
<li><a href="../443680/index.html">Four-day work week. Russian experience</a></li>
<li><a href="../443682/index.html">Monetization of the cloud: how to attract customers and not go broke</a></li>
<li><a href="../443684/index.html">Exhaustive list of differences between VB.NET and C #. Part 1</a></li>
<li><a href="../443686/index.html">March 30 - 31, SIBUR CHALLENGE in Nizhny Novgorod</a></li>
<li><a href="../443690/index.html">Parallels RAS: what is it and what is it eaten with?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>