<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Not quite the usual XMPP bot in Python: tunneling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, an article about ICQ in Python was published, which pushed me to develop the theme, albeit in a slightly different direction. A few y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Not quite the usual XMPP bot in Python: tunneling</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, an article about <a href="http://habrahabr.ru/blogs/python/111263/">ICQ in Python</a> was published, which pushed me to develop the theme, albeit in a slightly different direction.  A few years ago I had difficulties with home Internet: access only to a local network, only ICQ and local Jabber server from communication with the outside world;  there was no other way to get out.  As a result, the idea was born to tunnel HTTP traffic to XMPP. <br><br><a name="habracut"></a><br><br><h4>  Scheme </h4><br>  The scheme is based on three main components: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>bot server</b> : accepts messages with HTTP requests, executes, encodes and sends the result to the client </li><li>  <b>bot client</b> : sends HTTP information about the requests to be executed to the server, waits for the result, processes and returns the result of the query execution that is ready for further use </li><li>  <b>http-proxy</b> : a proxy server that processes HTTP requests using a bot client </li></ul><br><br>  Components are located like this: on a remote machine with internet access, a bot server is started.  A bot client and a proxy are launched on <em>localhost</em> ;  client applications are configured to use our proxy, for example: <br><br> <code>$ http_proxy="localhost:3128" wget ... <br></code> <br><br>  For the bot client to communicate with the bot server, a simple XML-based protocol is used. <br><br>  Request to download the index page <a href="http://example.com/">example.com</a> : <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>http://example.com<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  Answer: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">answer</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">chunk</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">count</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"19"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span>encoded_data<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">data</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">answer</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  The answer consists of several parts, chunk'ov.  Here <em>chunk</em> is the <em>chunk</em> number, <em>count</em> is the total number of chunks into which the response to the request was broken.  <em>encoded_data</em> is a base64 encoded response chunk. <br><br>  For greater clarity, I present the scheme graphically: <br><br><pre>                                      local                                            
 + ------------------------------------------------- ---------------------------------- +
 |  http-client (browser, wget) -&gt; http-proxy -&gt; bot-client | 
 + ------------------------------------------------- ---------------------------------- +
                                        / \
                                        ||
                                        \ /
                                     remote
 + ------------------------------------------------- ---------------------------------- +
 |  bot-server |
 + ------------------------------------------------- ---------------------------------- +
</pre><br><br><h4>  Implementation </h4><br><h5>  General information </h5><br>  Xmpppy is used to work with XMPP.  No tricky features are required, you only need to process incoming messages and send replies.  XML is parsed and generated by means of the standard library - <em>xml.dom.minidom</em> . <br><br><h5>  Bot server </h5><br>  The server's task is to receive download requests, give them to the library, which itself will figure out what to download, and return the result, and the server will forward this result to the client. <br><br>  In a simplified scheme, server-side message handling looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> xmpp <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Fetcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Fetcher fetcher = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(con, msg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> fetcher <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.getBody(): <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: ret = fetcher.process_command(msg.getBody()) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: ret = [<span class="hljs-string"><span class="hljs-string">"failed to process command"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ret: reply = xmpp.Message(msg.getFrom(), i) reply.setType(<span class="hljs-string"><span class="hljs-string">'chat'</span></span>) con.send(reply) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: jid = xmpp.JID(<span class="hljs-string"><span class="hljs-string">"my@server.jid"</span></span>) user = jid.getNode() server = jid.getDomain() password = <span class="hljs-string"><span class="hljs-string">"secret"</span></span> conn = xmpp.Client(server, debug=[]) conres = conn.connect() authres = conn.auth(user, password, resource=<span class="hljs-string"><span class="hljs-string">"foo"</span></span>) conn.RegisterHandler(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message_callback) conn.sendInitPresence() fetcher = Fetcher() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: conn.Process(<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br><br>  I deliberately removed error handling and hardcoded values ‚Äã‚Äãto make the code more compact and easier to read.  So what is going on here?  We connect to the jabber server and hang the message handler: <br><br><pre> <code class="python hljs"> conn.RegisterHandler(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message_callback)</code> </pre><br><br>  Thus, for each new incoming message, our <em>message_callback (con, msg)</em> function will be called, the arguments of which will be the handle of the connection and the message itself.  The function itself calls the command handler from the <em>Fetcher</em> class, which does all the ‚Äúblack‚Äù work and returns a list of chunks given to the client.  That's all, this server operation ends. <br><br><h5>  Fetcher </h5><br>  The <em>Fetcher</em> class implements the very logic of executing and encoding HTTP requests.  Entirely I will not give it a code, it can be viewed in the archive attached to the article, I will describe only the main points: <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, command)</span></span></span><span class="hljs-function">:</span></span> doc = xml.dom.minidom.parseString(command) url = self._gettext(doc.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">"url"</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>].childNodes) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: f = urllib2.urlopen(url) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> Exception, err: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">"%s"</span></span> % str(err)] lines = base64.b64encode(f.read()) ret = [] chunk_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span> n = <span class="hljs-number"><span class="hljs-number">1</span></span> chunk_count = (len(lines) + chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>) / chunk_size <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> x &lt; len(lines): ret.append(self._prepare_chunk(n, chunk_count, lines[x:x + chunk_size])) x += chunk_size n += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret</code> </pre><br><br>  The <em>process_command</em> function, as you probably remember, is called by our bot server.  It parses the XML request, determines which url it needs to request, and does it with <em>urllib2</em> .  The downloaded is encoded in base64 so that there are no unexpected problems with special characters, and it is split into equal parts in order not to rest on the restriction on the length of the message.  Then each chunk is wrapped in XML and sent out. <br><br><h5>  Customer </h5><br>  The client, in fact, is only one callback, which glues data and decodes from base64: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(con, msg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> fetcher, output, result <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> msg.getBody(): message = msg.getBody() chunks, count, data = fetcher.parse_answer(message) output.append(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> chunks == count: result = base64.b64decode(<span class="hljs-string"><span class="hljs-string">''</span></span>.join(output))</code> </pre><br><br><h5>  Proxy </h5><br>  To ensure that the tunnel can be used transparently, HTTP-proxy is implemented.  Proxy server is on port 3128 / tcp and waits for requests.  Received requests are sent to the bot server for processing, the result is decoded and sent to the client.  From the point of view of client applications, our proxy is no different from ‚Äúordinary‚Äù ones. <br><br>  To create a TCP server, use <em>SocketServer.StreamRequestHandler</em> from the standard library. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SocketServer.StreamRequestHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> data = self.request.recv(<span class="hljs-number"><span class="hljs-number">1024</span></span>) method, url, headers = parse_http_request(data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: response = fetch_file(server_jid, client_jid, password, url) self.wfile.write(response) self.request.close()</code> </pre><br><br>  The <em>parse_http_request ()</em> function parses an HTTP request, pulling out url, headers and http version from it;  <em>fetch_file ()</em> - requests a <em>url</em> using a bot client. <br><br><h4>  Conclusion </h4><br>  The full source code is available <a href="http://dpaste.org/ArST/">here</a> as a shar archive (you need to run the file and execute it as a shell script).  Of course, this is more a prototype than a full-fledged application, but the prototype is working and at least downloads small files without problems.  This should be enough for the main purpose of the article: to demonstrate the "non-interactive" application of the IM bot. <br><br>  A lot of things can be improved in the project - from adding authentication, normal support for request types, and ending with performance work.  It is very interesting, what kind of performance can be achieved with such an architecture, the study of which, perhaps, I will soon do. </div><p>Source: <a href="https://habr.com/ru/post/111971/">https://habr.com/ru/post/111971/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111965/index.html">My first PDA: Casio E-15</a></li>
<li><a href="../111966/index.html">Atomic tablet Odeon TPC-10, part one</a></li>
<li><a href="../111967/index.html">Introducing Kohana 3.0 - Part 6</a></li>
<li><a href="../111968/index.html">Audit of system calls in Linux</a></li>
<li><a href="../11197/index.html">Wonderful site - livents.ru</a></li>
<li><a href="../111972/index.html">Fire Fox Anatomy</a></li>
<li><a href="../111974/index.html">Install Juniper JunOS 10 M / T series</a></li>
<li><a href="../111975/index.html">January Startup Crash Test - in search of projects</a></li>
<li><a href="../111976/index.html">Automation in the service of relevance</a></li>
<li><a href="../111977/index.html">Automated checking of PHP code at commit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>