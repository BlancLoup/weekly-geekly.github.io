<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Three-dimensional background for the site in real time on JavaScript using three.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Learning material from the resource Phyramid, who have just such a header of the site. 



 By updating our website in 2014, we made a three-dimension...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Three-dimensional background for the site in real time on JavaScript using three.js</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/188/9d4/37b/1889d437b4f040e28ca36af6bc89b8d2.png"><br><br>  <i>Learning material from the resource Phyramid, who have just such a header of the site.</i> <br><br><img src="https://habrastorage.org/files/161/60c/b34/16160cb34a7342ae84ffa48a39b8a298.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      By updating our website in 2014, we made a three-dimensional background in a header consisting of geometric shapes in 3D Max.  But then we thought that it would be much cooler to generate it in real time on JS.  It is said - done, and with the help of the wonderful three.js framework, we made a simple scene.  And that's how it was. <br><br>  A note on the style of the code: at first we wanted to use only the functional style, but due to the peculiarities of the web and the work of the algorithm, we switched to OOP. <br><a name="habracut"></a><br><h4>  Create a surface </h4><br>  The first step was to create the main part of the scene.  To do this, we created a plane with 100x100 segments, and then shifted the vertices randomly.  The important point is that you need to set geometry.dynamic = true and geometry.normalsNeedUpdate = true so that three.js knows that the vertices will change and that he will need to recalculate the lighting. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> makePlaneGeometry = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">width, height, widthSegments, heightSegments</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> geometry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PlaneGeometry(width, height, widthSegments, heightSegments); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X_OFFSET_DAMPEN = <span class="hljs-number"><span class="hljs-number">0.5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Y_OFFSET_DAMPEN = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Z_OFFSET_DAMPEN = <span class="hljs-number"><span class="hljs-number">0.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> randSign = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vertIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; vertIndex &lt; geometry.vertices.length; vertIndex++) { geometry.vertices[vertIndex].x += <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() / X_OFFSET_DAMPEN * randSign(); geometry.vertices[vertIndex].y += <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() / Y_OFFSET_DAMPEN * randSign(); geometry.vertices[vertIndex].z += <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() / Z_OFFSET_DAMPEN * randSign(); } geometry.dynamic = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; geometry.computeFaceNormals(); geometry.computeVertexNormals(); geometry.normalsNeedUpdate = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> geometry; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> makePlane = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">geometry</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial({<span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0x00576b</span></span>, <span class="hljs-attr"><span class="hljs-attr">wireframe</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> plane = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Mesh(geometry, material); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> plane; }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> init = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">container, viewWidth, viewHeight</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scene = makeScene(); <span class="hljs-comment"><span class="hljs-comment">// (...) var plane = makePlane(makePlaneGeometry(400, 400, 100, 100)); scene.add(plane); // (...) };</span></span></code> </pre> <br><br><h4>  Playing with the frame </h4><br>  Simple material for the frame helped visualize the model: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshBasicMaterial({<span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0x00576b</span></span>, <span class="hljs-attr"><span class="hljs-attr">wireframe</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>});</code> </pre><br><br>  TrackballControls.js was used to move around the stage.  And that's what we got as a result: <br><br><img src="//habrastorage.org/files/610/e80/44c/610e8044cda24b839569886a43fe5455.png"><br><br>  Cool, but not yet polished.  Add real material and light. <br><br><h4>  Adding material and light </h4><br>  To achieve the desired appearance, the ambient occlusion shading model was required.  In addition, you need to make visible the edges of the model without smoothing.  Therefore, the lambert material with flat shading fit perfectly: <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> material = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.MeshLambertMaterial({<span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-number"><span class="hljs-number">0xffffff</span></span>, <span class="hljs-attr"><span class="hljs-attr">shading</span></span>: THREE.FlatShading});</code> </pre><br><br>  Two light sources were used.  The first - ambient, was placed for uniform illumination.  The second, directional, created all these cool shadows that give the model a polygonal look. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> makeLights = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ambientLight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.AmbientLight(<span class="hljs-number"><span class="hljs-number">0x1a1a1a</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene.add(ambientLight); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dirLight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.DirectionalLight(<span class="hljs-number"><span class="hljs-number">0xdfe8ef</span></span>, <span class="hljs-number"><span class="hljs-number">0.09</span></span>); dirLight.position.set(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scene.add(dirLight); };</code> </pre><br><br><h4>  Camera placement </h4><br>  We wanted to place a camera looking at a plane from about a 45 degree angle, which is pretty simple.  Having played with the camera, we chose an angle of 75 degrees, which gives the effect of observation "from the top of the mountain." <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> camera = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.PerspectiveCamera(fov, aspectRatio, <span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>); camera.up = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); camera.rotation.x = <span class="hljs-number"><span class="hljs-number">75</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI / <span class="hljs-number"><span class="hljs-number">180</span></span>; camera.position.z = zPos;</code> </pre><br><br>  The field of view caused problems, because on wide canvases the scene looked strange, something like when setting up an FOV in Quake by 180 degrees.  We wrote a code for a rough FOV calculation based on the screen resolution. <br><br><h4>  Haze and alpha-blending </h4><br><br>  The picture is already beginning to resemble our goal, but there is one problem.  The boundaries of the plane are clearly visible.  Here is a prime example of this, with the camera looking down. <br><br><img src="//habrastorage.org/files/288/492/4b6/2884924b684640e2876bb15d062d8051.png"><br><br>  First, we wanted to transform the plane into a sphere, and place the camera inside the sphere, in the center.  The approach seemed to solve the problem, but the surface already looked wrong and was going to fold at the poles. <br><br>  The solution was to add an exponential haze, which turned out very cool.  After the alpha blending was turned on, the haze smoothly turned into the background of the splash screen and gave a cool effect. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> renderer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.WebGLRenderer({<span class="hljs-attr"><span class="hljs-attr">antialiasing</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">alpha</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}); (...) scene.fog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> THREE.FogExp2(<span class="hljs-number"><span class="hljs-number">0x222228</span></span>, <span class="hljs-number"><span class="hljs-number">0.003</span></span>);</code> </pre><br><br>  Here is a picture with enhanced smoke effect: <br><br><img src="//habrastorage.org/files/c96/e3c/48c/c96e3c48c64f410dbe990a35677d5471.png"><br><br><h4>  Interactivity (part one - the mouse) </h4><br>  Finally, the scene began to look right, but management was still imperfect.  TrackballControls allows you to move freely around the stage, but we only had to allow turns about the Z axis. We decided to write controls from scratch, based on the demo with a rotating cube from three.js <br><br>  When the user moves the mouse, it is necessary to turn off autorotation and remember the distance the mouse was moved to add it to the rotation around Z in the next frame. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registerMouseMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.autorotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mouseXOnMouseMove = event.clientX - (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MOUSE_MOVE_DAMPENING = <span class="hljs-number"><span class="hljs-number">0.0075</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotationOnMouseDown + (mouseXOnMouseMove - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseXOnMouseDown) * MOUSE_MOVE_DAMPENING; };</code> </pre><br><br>  A click handler is also required so that movements are registered only if the user holds down the mouse button (and memorize the original position of the mouse to calculate the distance). <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registerMouseDown = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ startMouseMovementDetection(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseXOnMouseDown = event.clientX - (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotationOnMouseDown = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotation; };</code> </pre><br><br>  All that remains is to make a turn. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.autorotation) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.object.rotation.z += OBJECT_AUTOROTATION_AMOUNT; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.object.rotation.z -= (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotation + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.object.rotation.z) * TARGET_ROTATION_DAMPENING; }</code> </pre><br><br>  We added another restriction on movement - if an object is moving too slowly, we consider that it is noise or residual phenomena from the last dragging, therefore we return the rotation method to the state of autorotation. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotation + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.object.rotation.z) &lt; OBJECT_ROTATION_THRESHOLD) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.autorotation = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><br>  Interactivity (part two - touch) <br><br>  Almost done!  Another thing we need to do is control by touch.  It works about the same as mouse control. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> registerTouchDown = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.touches.length === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseXOnMouseDown = event.touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].pageX - (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseYOnMouseDown = event.touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].pageY - (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotationOnMouseDown = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotation; } }</code> </pre><br><br>  But there is a problem.  On devices with a touch screen, the gesture responsible for moving the scene is also responsible for scrolling the page.  This had a bad effect on handling, because in practice we turned off scrolling. <br><br>  Because of this, we had to check the direction of pulling.  If it is mostly horizontal, then we rotate the plane.  If it was mostly vertical, we did nothing and allowed the default events to happen. <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerTouchMove</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.touches.length === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MOUSE_MOVE_DAMPENING = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.autorotation = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mouseXOnMouseMove = event.touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].pageX - (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mouseYOnMouseMove = event.touches[<span class="hljs-number"><span class="hljs-number">0</span></span>].pageY - (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height / <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xDiff = mouseXOnMouseMove - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseXOnMouseDown; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> yDiff = mouseYOnMouseMove - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mouseYOnMouseDown; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(xDiff) &gt; <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(yDiff)) { event.preventDefault(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.targetRotationOnMouseDown + xDiff * MOUSE_MOVE_DAMPENING; } } }</code> </pre><br><br><h4>  Resize resolution update </h4><br>  Last but not least, the ability to dynamically update the entire image when the browser window is resized. <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updateDimensions = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.offsetWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.container.offsetHeight; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aspectRatio = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width / <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fov = fovForAspectRatio(aspectRatio); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> zPos = cameraZPositionForFov(fov); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera.aspect = aspectRatio; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera.fov = fov; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera.position.z = zPos; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.camera.updateProjectionMatrix(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderer.setSize(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.width, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.height); };</code> </pre><br><br><h4>  results </h4><br>  Done!  This is how it comes out when viewing it in full screen (we have a fullscreen view on page 404).  <a href="http://www.phyramid.com/">Living example</a> . <br><br><img src="//habrastorage.org/files/31a/604/ed6/31a604ed6206478b8f2a7d5928d27e91.png"><br><br>  Creating a 3D header was a very exciting experience, and we are impressed with the power of three.js.  We hope that this article will help you create similar things. </div><p>Source: <a href="https://habr.com/ru/post/247811/">https://habr.com/ru/post/247811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247793/index.html">Monitoring from Brazil - continue to conquer Latin America</a></li>
<li><a href="../247799/index.html">ATtiny13a: Controller of the STOP signal and the parking lights of the car</a></li>
<li><a href="../247805/index.html">Concurrent programming with CUDA. Part 3: Fundamental GPU algorithms: convolution (reduce), scan (scan) and histogram (histogram)</a></li>
<li><a href="../247807/index.html">Combinatorial algorithms: combination index, partitioning into subsets</a></li>
<li><a href="../247809/index.html">Perhaps the first game on Dart + Box2D</a></li>
<li><a href="../247813/index.html">Non-personalized recommendations: association method</a></li>
<li><a href="../247815/index.html">Micro-conference UX-Wednesday ‚Ññ21 in the framework of User Experience Russia 2014</a></li>
<li><a href="../247817/index.html">Herringbone, light up! Part 1: Garland and build software for OpenWRT</a></li>
<li><a href="../247819/index.html">New Release Candidate for 3CX Phone System 12.5 (+ demo key!)</a></li>
<li><a href="../247823/index.html">Free CCNA Cisco video course available on one of the YouTube channels</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>