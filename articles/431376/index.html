<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data migration in a bloody enterprise: what to analyze, so as not to overwhelm the project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A typical system integration project for us looks like this: the customer has a wagon system for customer accounting, the task is to assemble customer...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data migration in a bloody enterprise: what to analyze, so as not to overwhelm the project</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/yk/_w/ry/yk_wry8j7irc6ma2zn65mdw0ulq.jpeg"><br><br>  A typical system integration project for us looks like this: the customer has a wagon system for customer accounting, the task is to assemble customer cards into a single database.  And not only to collect, but also to clear from duplicates and debris.  To get a clean, structured, full customer cards. <br><br>  For beginners, I will explain that the migration proceeds according to the following scheme: <i>sources ‚Üí data conversion ( <a href="https://ru.wikipedia.org/wiki/ETL">ETL</a> or <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2580%25D0%25B2%25D0%25B8%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BF%25D1%2580%25D0%25B8%25D1%258F%25D1%2582%25D0%25B8%25D1%258F">bus</a> responds) ‚Üí receiver</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On one project, we lost three months simply because a third-party integrator team did not study the data in the source systems.  The most annoying that this could have been avoided. <br><a name="habracut"></a><br>  Worked like this: <br><br><ol><li>  System integrators customize the ETL process. </li><li>  ETL converts the raw data and gives it to me. </li><li>  I study the upload and send errors to integrators. </li><li>  The integrators fix the ETL and start the migration again. </li></ol><br>  The article will show how to analyze data with system integration.  I studied the ETL uploads, it was very helpful.  But on the source data the same techniques would speed up the work by a factor of two. <br><br>  Tips will be useful for testers, enterprise-product implementers, system integrators, analysts.  Techniques are universal for relational databases, and at full power they are revealed on volumes from a million clients. <br><br>  But first, about one of the main myths of system integration. <br><br><h2>  Documentation and architect help (actually not) </h2><br>  Integrators often do not study data before migration ‚Äî they save time.  Read the documentation, look at the structure, talk with the architect - and that's enough.  After this, the integration is already planned. <br><br>  It turns out badly.  Only an analysis will show what is really going on in the database.  If you do not get into the data with rolled up sleeves and a magnifying glass, the migration will go awry. <br><br>  <b>The documentation is lying.</b>  A typical enterprise system has been operating for 5‚Äì20 years.  All these years, changes in it have been documented by various departments and contractors.  Each with its own bell tower.  Therefore, there is no integrity in the documentation; no one fully understands the logic and structure of data storage.  Not to mention that the terms are always burning and there is not enough time for documenting. <br><br>  The usual story: in the customer table there is a field "SNILS", on paper is very important.  But when I look at the data, I see that the field is empty.  As a result, the customer agrees that the target database will do without a field for the SNILS, since there is still no data. <br><br>  A special case of documentation is the regulations and descriptions of business processes: how data gets into the database, under what circumstances, in what format.  All this does not help either. <br><br>  <b>Business processes are flawless only on paper.</b>  Early in the morning, a nevyshvatsya operator Anatoly comes into the bank's office office on the outskirts of Vyksa.  Under the window all night shouted, and in the morning Anatoly quarreled with the girl.  He hates the whole world. <br><br>  Nerves have not yet come in order, and Anatoly completely drives in the name of the new client in the field for the surname.  He completely forgets about his birthday - the default ‚Äú01/01/1900 g‚Äù remains in the form.  Do not care about the regulations, when everything around is so annoying !!! <br><br>  Chaos wins business processes, very slim on paper. <br><br>  <b>The system architect does not know everything.</b>  The point is again in the honorable life of enterprise-systems.  Over the years that they work, architects change.  Even if you talk with the current one, the decisions of previous ones will come up as surprises during the project. <br><br>  And be sure: even a pleasant in all respects architect will keep his facies and crutches of the system secret. <br><br>  Integration "by instrument", without data analysis - an error.  I'll show you how we study data in HFLabs with system integration.  In the last project, I analyzed only uploads from ETL.  But when the customer issues access to the source data, I check them by the same principles. <br><br><h2>  Field padding and null values </h2><br>  The simplest checks are for completeness of the tables as a whole and for completeness of individual fields.  With them, and start. <br><br>  <b>How many total rows in the table.</b>  The simplest query possible. <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt;;</code> </pre> <br>  I get the first result. <br><table><tbody><tr><th>  Individuals </th><th>  amount </th></tr><tr><td>  Total </td><td>  99 966 324 </td></tr></tbody></table>  Here I look at the adequacy of the data.  If only two million customers came in the unloading for a large bank, something is clearly wrong.  But so far everything looks as expected, moving on. <br><br>  <b>How many lines are filled for each field separately.</b>  I check all the columns in the table. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;column_name&gt;, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> &lt;column_name&gt; cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> &lt;column_name&gt; <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> <br>  The first one came across the field on his birthday, and he was immediately curious: for some reason, the data did not come at all. <br><table><tbody><tr><th>  Individuals </th><th>  amount </th></tr><tr><td>  Total </td><td>  99 966 324 </td></tr><tr><td>  DR </td><td>  0 </td></tr></tbody></table>  If in the upload all the values ‚Äã‚Äãin the field are ‚ÄúNULL‚Äù, first of all I look at the original system.  Perhaps there the data is stored properly, but they were lost during the migration. <br><br>  I see that the source system birthdays in place.  I go to integrators: guys, an error.  It turned out that in the ETL process the decode function worked incorrectly.  The code is corrected, in the next unload we check the changes. <br><br>  I go further to the field with the TIN. <br><table><tbody><tr><th>  Individuals </th><th>  amount </th></tr><tr><td>  Total </td><td>  99 966 324 </td></tr><tr><td>  DR </td><td>  0 </td></tr><tr><td>  TIN </td><td>  65,136 </td></tr></tbody></table>  There are 100 million people in the database, and only 65,000 have an INN, which is 0.07%.  Such a low occupancy is a signal that the field in the receiver base may not be needed at all. <br><br>  I check the source system, that's right: the TIN is similar to the actual, but there are almost none.  So it's not about migration.  It remains to find out whether the customer in the target database needs an almost empty field under the TIN. <br><br>  Got to the client removal flag. <br><table><tbody><tr><th>  Individuals </th><th>  amount </th></tr><tr><td>  Total </td><td>  99 966 324 </td></tr><tr><td>  DR </td><td>  0 </td></tr><tr><td>  TIN </td><td>  65,136 </td></tr><tr><td>  Delete flag </td><td>  0 </td></tr></tbody></table>  Flags not filled.  This is what, the company does not remove customers?  I looked into the original system, talking to the customer.  It turns out that yes: the formal flag, instead of deleting customers, delete their accounts.  No accounts - the client as it were deleted. <br><br>  In the target system, the remote client flag is obligatory, this is a feature of the architecture.  So, if the client has zero accounts in the receiving system, it should be closed through additional logic or not imported at all.  Here as the customer decides. <br><br>  Next - a sign with addresses.  Usually in such tables something is wrong, because the addresses are complicated, they are entered in different ways. <br><br>  I check the completeness of the components of the address. <br><table><tbody><tr><th>  Addresses </th><th>  amount </th></tr><tr><td>  Total </td><td>  254 803 976 </td></tr><tr><td>  A country </td><td>  229,256,090 </td></tr><tr><td>  Index </td><td>  46,834,777 </td></tr><tr><td>  City </td><td>  6,474,841 </td></tr><tr><td>  The outside </td><td>  894 040 </td></tr><tr><td>  House </td><td>  20,903 </td></tr></tbody></table>  Addresses are filled non-uniformly, but it‚Äôs too early to draw conclusions: first I‚Äôll ask the customer what they are for.  If for segmentation by country, everything is fine: there is enough data.  If for mailing, then the problem is: the house is almost empty, there are no apartments. <br><br>  As a result, the customer saw that ETL took the addresses from the old and irrelevant plate.  It is in the base as a monument.  And there is another table, new and good, the data must be taken from it. <br><br>  During the analysis of occupancy, I alone put the fields that refer to reference books.  The "IS NOT NULL" condition does not work with them: instead of "NULL" in the cell, it is usually "0".  Therefore, reference fields are checked separately. <br><br>  <b>Changes in field filling.</b>  So, I checked the total occupancy and occupancy of each field.  Found problems, integrators corrected the ETL process and restarted the migration. <br><br>  The second unload is driven through all the steps listed above.  I record statistics in the same file to see the changes. <br><br>  Fullness of all fields. <br><table><tbody><tr><th>  Individuals </th><th>  Unloading 1 </th><th>  Unload 2 </th><th>  Delta </th></tr><tr><td>  Total </td><td>  99 966 324 </td><td>  94 847 160 </td><td>  -5 119 164 </td></tr></tbody></table>  Between uploads 5 million records disappeared.  I go to the integrators, asking typical questions: <br><br><ul><li>  ‚ÄúWhy are the records lost?‚Äù; </li><li>  ‚ÄúWhat data was screened out?‚Äù; </li><li>  "What data is left?" </li></ul><br>  It turns out that there is no problem: the ‚Äútechnical‚Äù customers were simply removed from the fresh download.  They are in the base for tests, they are not living people.  But with the same probability the data could disappear by mistake, it happens. <br><br>  But the birthdays in the new unloading appeared, as I expected. <br><table><tbody><tr><th>  Individuals </th><th>  Unloading 1 </th><th>  Unload 2 </th><th>  Delta </th></tr><tr><td>  Total </td><td>  99 966 324 </td><td>  94 847 160 </td><td>  -5 119 164 </td></tr><tr><td>  DR </td><td>  0 </td><td>  77,046,780 </td><td>  77,046,780 </td></tr></tbody></table>  But!  It is not necessarily good when the previously missing data suddenly appeared in the new upload.  For example, birthdays could be filled with default dates - there is nothing to rejoice about.  Therefore, I always check which data came from. <br><br>  <i>What to check in a nutshell.</i> <i><br><br></i> <ol><li>  <i>The total number of entries in the tables.</i>  <i>Is this amount adequate to the expectations?</i> </li><li>  <i>The number of filled lines in each field.</i> </li><li>  <i>The ratio of the number of rows filled in each field to the number of rows in the table.</i>  <i>If it is too small, it is a reason to think whether it is necessary to drag the field to the target base.</i> </li></ol> <i><br></i>  <i>Repeat the first three steps for each upload.</i>  <i>Follow the dynamics: where and why increased or decreased.</i> <br><br><h2>  The length of the values ‚Äã‚Äãin the string fields </h2><br>  I follow one of the basic rules of testing - I check the boundary values. <br><br>  <b>What values ‚Äã‚Äãare too short.</b>  Among the shortest values ‚Äã‚Äãis full of garbage, so it is interesting to dig. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> (&lt;column_name&gt;) &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre> <br>  In this way I check the name, phone numbers, TIN, OKVED, site addresses.  Nonsense like "A * 1", "0", "11", "-" and "..." pop up. <br><br>  <b>Is everything OK with maximum values?</b>  The end-to-end field is a marker that the data did not fit during the transfer, and they were cut off automatically.  MySQL breaks off this famously and without warning.  It seems that the migration went smoothly. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;table_name&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>(&lt;column_name&gt;) = <span class="hljs-number"><span class="hljs-number">65</span></span>;</code> </pre> <br>  In this way, I found in the field with the document type the string "Certificate of registration of an immigrant's application for recognition of his."  I told the integrators, the length of the field corrected. <br><br>  <b>How values ‚Äã‚Äãare distributed in length.</b>  In HFLabs, the table of the distribution of rows in length we call the "frequency". <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>(&lt;column_name&gt;), <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(&lt;column_name&gt;) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">length</span></span>(&lt;column_name&gt;);</code> </pre> <br>  Here I seek out anomalies in the distribution of length.  For example, here is a frequency for a table with postal addresses. <br><table><tbody><tr><th>  Length </th><th>  amount </th></tr><tr><td>  122 </td><td>  120 </td></tr><tr><td>  123 </td><td>  90 </td></tr><tr><td>  124 </td><td>  130 </td></tr><tr><td>  125 </td><td>  1100 </td></tr><tr><td>  126 </td><td>  70 </td></tr></tbody></table>  Values ‚Äã‚Äãwith a length of 125 are too many.  I look into the source database and find that three years ago, for some reason, some of the addresses were cut off to 125 characters.  In other years, everything is fine.  I go with this problem to the customer and integrators, we understand. <br><br>  <i>What to check in a nutshell.</i> <i><br><br></i> <ol><li>  <i>The shortest values ‚Äã‚Äãin string fields.</i>  <i>Often strings with less than three characters are garbage.</i> </li><li>  <i>Values ‚Äã‚Äãthat "rest against" the length of the width of the field.</i>  <i>Often they are circumcised.</i> </li><li>  <i>Anomalies in the distribution of rows in length.</i> </li></ol><br><h2>  Popular Values </h2><br>  I divide into three categories the values ‚Äã‚Äãthat fall in the top popular: <br><br><ul><li>  <i>really common</i> , as the name "Tatiana" or middle name "Vladimirovich."  Here it must be remembered that, in general, ‚ÄúTatyana‚Äù should not be 100 times more popular than ‚ÄúAnna‚Äù, and ‚ÄúIsmail‚Äù can hardly be more popular than ‚ÄúEgor‚Äù; </li><li>  <i>garbage</i> , like ".", "1", "-" and the like; </li><li>  <i>default</i> on the input form, as "01/01/1900" for dates. </li></ul><br>  Two cases out of three are problem markers, it is useful to look for them. <br><br>  Popular values ‚Äã‚ÄãI look for in the fields of three types: <br><br><ol><li>  Normal string fields. </li><li>  String field references.  These are ordinary string fields, but the number of different values ‚Äã‚Äãin them is of course regulated.  Countries, cities, months, phone types are stored in such fields. </li><li>  Classifier fields - they contain a link to an entry in a third-party classifier table. </li></ol><br>  The fields of each of these types are studied a little differently. <br><br>  <b>For string fields, what are the top 100 popular values.</b>  If you want, you can take a little more, but all anomalies are usually placed in the first hundred values. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;column_name&gt;, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> &lt;column_name&gt; <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  I check the fields this way: <br><br><ul><li>  Full name, as well as separate surnames, names and patronymic names; </li><li>  dates of birth and generally any dates; </li><li>  addresses  Both the full address and its individual components, if they are stored in the database; </li><li>  telephones; </li><li>  series, number, type, place of issue of documents. </li></ul><br>  Almost always among the most popular are test and default values, some kind of stubs. <br><br><img src="https://habrastorage.org/webt/hl/sg/cr/hlsgcrpcy9y1i-gpyfoead8byzg.png"><br><br>  It happens that the problem found is not a problem at all.  Once I found a suspiciously popular phone number in the database.  It turned out that customers indicated this number as a worker, and in the database there were simply many employees of the same organization. <br><br>  Along the way, such an analysis will reveal hidden reference fields.  According to logic, these fields are not supposed to be reference books, but in fact in the database they are.  For example, I choose popular values ‚Äã‚Äãfrom the ‚ÄúPosition‚Äù field, and there are only five of them. <br><table><tbody><tr><th>  Position </th></tr><tr><td>  Director </td></tr><tr><td>  Accountant </td></tr><tr><td>  Specialist </td></tr><tr><td>  Secretary </td></tr><tr><td>  System Administrator </td></tr></tbody></table>  Perhaps the company serves only five professions.  Not very similar to the truth, right?  Rather, in the form for operators, instead of a string, a reference book was made and they forgot to pour out values.  The important question here is: is it reasonable to fill positions through the directory.  So, through data analysis, I come out with possible problems with the carrier software. <br><br>  <b>For reference fields and classifiers, I check how popular all values ‚Äã‚Äãare.</b>  For a start I understand which fields are reference books.  Scripts can not do here, take the documentation and estimate.  Typically, reference books are created for values ‚Äã‚Äãwhose number is of course and relatively small: <br><br><ul><li>  country, </li><li>  languages, </li><li>  currency, </li><li>  months </li><li>  cities. </li></ul><br>  In an ideal world, the content of reference fields is clear and uniform.  But our world is not like this, so I check it with a query. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;column_name&gt;, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> &lt;column_name&gt; <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">desc</span></span>;</code> </pre> <br>  Usually in the string-field directories is this. <br><table><tbody><tr><th>  Place of Birth </th><th>  amount </th></tr><tr><td>  Tajikistan </td><td>  467,599 </td></tr><tr><td>  Tajikistan </td><td>  410 484 </td></tr><tr><td>  Russia </td><td>  292,585 </td></tr><tr><td>  TAJIKISTAN </td><td>  234,465 </td></tr><tr><td>  Russia </td><td>  158,163 </td></tr><tr><td>  RUSSIA </td><td>  76 367 </td></tr></tbody></table>  Typical problems: <br><br><ul><li>  typos; </li><li>  spaces; </li><li>  different case </li></ul><br>  Finding a mess, go to the integrators with examples on hand.  Let them leave the garbage in the source, and eliminate the discrepancies.  Then in the target base for rigor it will be possible to turn reference strings into classifiers. <br><br>  I check the popular values ‚Äã‚Äãin the classifier fields to catch the lack of options.  Faced with such cases. <br><table><tbody><tr><th>  Floor </th><th>  Phone type </th></tr><tr><td><ol><li>  Female </li><li>  Not determined </li></ol></td><td><ol><li>  Home </li></ol></td></tr></tbody></table>  Such classifiers look very strange, they should be shown to the customer.  Every time I had an error behind such cases: either something was wrong in the database, or the data was not downloaded from there. <br><br>  <i>What to check in a nutshell.</i> <i><br><br></i> <ol><li>  <i>Which string fields are reference and which ones are not.</i> </li><li>  <i>For simple string fields, top popular values.</i>  <i>Usually in the top trash and default data.</i> </li><li>  <i>For string reference fields - the distribution of all values ‚Äã‚Äãin popularity.</i>  <i>The sample will show discrepancies in the reference values.</i> </li><li>  <i>For classifiers - whether there are enough options in the database.</i> </li></ol><br><h2>  Consistency and cross-checking </h2><br>  From analyzing the data inside the tables I turn to the analysis of relationships. <br><br>  <b>Whether the data is bound to be bound.</b>  We call this parameter ‚Äúconsistency‚Äù.  I take a subordinate table, for example, with telephones.  To her in a pair - the parent table of customers.  And I see how many client IDs in the subordinate table that are not in the parent. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;ID1&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;table1&gt;) <span class="hljs-keyword"><span class="hljs-keyword">minus</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;ID2&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;table2&gt;));</code> </pre> <br>  If the request gave a delta, it means no luck - there is unrelated data in the upload.  So I check tables with phones, contracts, addresses, bills and so on.  Once during the project, I found 23 million numbers that were just hanging in the air. <br><br>  In the opposite direction it also works - I am looking for clients who for some reason do not have a single contract, address, telephone number.  Sometimes this is normal - well, there is no address from the client, that such  Here you need to find out from the customer, the documentation is easily deceived. <br><br>  <b>Are there duplicate primary keys in different tables?</b>  Sometimes identical entities are stored in different tables.  For example, heterosexual clients.  (Nobody knows why, because the structure was claimed by Brezhnev.) And in the receiver, the table is the same, and when migrating, customer ITs will conflict. <br><br>  I turn my head on and look at the structure of the base: where it is possible to crush similar entities.  These may be customer tables, contact numbers, passports, and so on. <br><br>  If there are several tables with similar entities, I do a cross-check: I check the intersection of identifiers.  Intersect - sticking patch.  For example, we collect IDs for a single table using the ‚Äúsource table name + ID‚Äù scheme. <br><br>  <i>What to check in a nutshell.</i> <i><br><br></i> <ol><li>  <i>How many related tables unrelated data.</i> </li><li>  <i>Are there any potential primary key conflicts?</i> </li></ol><br><h2>  What else to check </h2><br>  <b>Do not have Latin characters where they do not belong.</b>  For example, in surnames. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;column_name&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">regexp_like</span></span>(&lt;column_name&gt;, <span class="hljs-string"><span class="hljs-string">'[AZ]'</span></span>, <span class="hljs-string"><span class="hljs-string">'i'</span></span>);</code> </pre> <br>  So I catch a wonderful Latin letter "C", which coincides with the Cyrillic.  The error is unpleasant, because by the name of the Latin ‚ÄúC‚Äù operator will never find a client. <br><br>  <b>Were there any extraneous characters in the string fields intended for numbers?</b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> &lt;column_name&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">table</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">regexp_like</span></span>(&lt;column_name&gt;, <span class="hljs-string"><span class="hljs-string">'[^0-9]'</span></span>);</code> </pre> <br>  Problems emerge in the fields with the passport number of the Russian Federation or the TIN.  Phones are the same, but there I allow plus, parentheses and hyphens.  The request will also reveal the letter ‚ÄúO‚Äù, which is set instead of zero. <br><br>  <b>How data is adequate.</b>  You never know where the problem will come up, so I'm always on my guard.  Met such cases: <br><br><ul><li>  <i>50 000 phones at the client "Sofia Vladimirovna" - is this normal?</i>  The answer is: not normal.  The client is technical, he was hung up with "ownerless" phone numbers to make sms-mailings.  Pull the client into the new database is not necessary; </li><li>  <i>The TIN is filled, in fact in the column is "79853617764", "89109462345", "4956780966" and so on.</i>  What kind of phones, okay?  Where is TIN?  Answer: what kind of numbers - it is not known who put - it is not clear.  Nobody uses them.  The current TIN is stored in another field of another table, taken from there; </li><li>  <i>the field ‚Äúaddress in one line‚Äù does not correspond to the fields in which the address is stored in parts.</i>  Why are the addresses different?  Answer: once the operators filled in addresses in one line, and the external system parsed the addresses in separate fields.  For segmentation.  Time passed, people changed addresses.  Operators regularly updated them, but only as a string: the address remains in parts old. </li></ul><br><h2>  All you need is SQL and Excel </h2><br>  To analyze the data, expensive software is not needed.  Enough of the good old Excel and SQL knowledge. <br><br>  I use Excel to build a long query.  For example, I check the fields for fullness, and in the table there are 140 of them. I will write with my hands before the carrot zagsheniya, so I collect the query with formulas in the excel plate. <br><br><img src="https://habrastorage.org/webt/ww/m3/br/wwm3br0qxpp7gudattxhkxnx1fm.png"><br>  <sub>In the column "A" I insert the names of the fields, take them in the documentation or service tables.</sub>  <sub>In column "B" - the formula for gluing the request</sub> <br><br>  I insert the field names, write the first formula in the ‚ÄúB‚Äù column, pull the corner - and that's it. <br><br><img src="https://habrastorage.org/webt/1r/ld/ct/1rldctxhypv2xw3era05-lkixhu.gif"><br>  <sub>Works in Excel, Google Docs, and Excel Online (available on Yandex.Disk)</sub> <br><br>  Data analysis saves the car time and saves the nerves of managers.  It‚Äôs easier to meet the deadline.  If the project is large, analytics will save millions of rubles and reputation. <br><br><h2>  Not numbers, but conclusions </h2><br>  She formulated a rule for herself: do not show bare numbers to the customer, you still cannot achieve the effect.  My task is to analyze the data and draw conclusions, and attach the numbers as evidence.  Conclusions are primary, numbers are secondary. <br><br>  What I collect for the report: <br><br><ul><li>  <i>problem formulations in the form of a hypothesis or a question</i> : ‚ÄúThe TIN is 0.07% complete.  How do you use this data, how relevant are they, how to interpret them?  Is there just an INN in one table? ‚Äù.  You can not blame: "Your TIN is not filled at all."  In response, you will receive only aggression; </li><li>  <i>examples of problems.</i>  These are the signs, which are so many in the article; </li><li>  <i>Options for how to do it:</i> ‚ÄúIt may be worth removing the TIN from the target base so as not to produce empty fields.‚Äù </li></ul><br>  I do not have the right to decide what to take from the source database and how to change the data during the migration.  Therefore, with the report I go to the customer or integrators, and we figure out how to proceed further. <br><br>  Sometimes the customer, having seen the problem, replies: ‚ÄúDo not worry, do not pay attention.  Let's buy an extra terabyte of memory, and that's all.  It's cheaper than optimizing. ‚Äù  You cannot agree to this: if you take everything, there will be no quality in the receiver.  All the same trash redundant data is being migrated. <br><br>  Therefore, we gently but steadily ask: "Tell us how you will use these data in the target system."  Not "why are needed", namely "how will you use."  Answers "we will think up then" or "it just in case" do not suit.  Sooner or later, the customer understands what data you can do without. <br><br>  The main thing - to find and resolve all issues, until the system is not launched in the prod.  On live to change the architecture and data model - go crazy. <br><br>  With basic analytics on it all, study the data! <br><br>  <i>HFLabs is looking for an analyst trainee with a salary of 50 000 ‚ÇΩ.</i>  <i>We will teach the right person everything I told in the article, and other tricks.</i> <br><br>  <i>The vacancy is suitable for technicians who want to change their profile or have not yet decided which field to work in.</i>  <i>If interested, send feedback <a href="https://hh.ru/vacancy/28312459">from the vacancy page on hh.ru.</a></i> </div><p>Source: <a href="https://habr.com/ru/post/431376/">https://habr.com/ru/post/431376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../431362/index.html">How a designer get rid of his routine and keep his interest in his work</a></li>
<li><a href="../431366/index.html">Rumors: Corel buys Parallels, the deal will be closed in December, employees were informed yesterday</a></li>
<li><a href="../431370/index.html">The fastest reports in the wild west. And a handful of bugs to boot ...</a></li>
<li><a href="../431372/index.html">Interrupts from external devices in the x86 system. Part 2. Linux kernel boot options</a></li>
<li><a href="../431374/index.html">The last judgment: an analysis of the financial performance of the game in the early access</a></li>
<li><a href="../431378/index.html">The whole truth about the RTOS. Article # 23. Queues: introduction and basic services</a></li>
<li><a href="../431380/index.html">Mitap Netologii and Skyeng about soft skills "What a developer needs to know, except for the code"</a></li>
<li><a href="../431382/index.html">JVM Ecosystem Survey Results</a></li>
<li><a href="../431384/index.html">CLion 2018.3: remote development, code profiling, speed and not only</a></li>
<li><a href="../431388/index.html">The world through the eyes of the car. How do drones see it?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>