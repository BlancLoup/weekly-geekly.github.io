<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous JavaScript Programming - Staying Alive</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Programmers take certain features for granted - sequential programming, for example, when writing an algorithm that takes one step only after the othe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous JavaScript Programming - Staying Alive</h1><div class="post__text post__text-html js-mediator-article">  Programmers take certain features for granted - sequential programming, for example, when writing an algorithm that takes one step only after the other. <br><br>  However, if you are writing JavaScript code that uses blocking I / O or other lengthy operations, sequential coding is out of the question, since blocking a single execution thread in the system is a very bad idea.  The solution is to implement algorithms using asynchronous callbacks, that is, to split the sequential code into several callbacks. <br><br>  This solves the problem, but means that we lose the ability to write a sequential algorithm, and a nontrivial sequential code is converted into a graph of callback functions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is becoming even more critical for large scale applications that make extensive use of asynchrony.  Using the transfer of callback functions for asynchronous actions is not very convenient and can create complex processes for transferring callbacks due to the need to handle return values. <br><br>  The JavaScript community is aware of this, especially the Node.JS community, since Node.JS focuses on asynchronous code. <a name="habracut"></a><br><br>  <a href="http://wiki.commonjs.org/wiki/CommonJS">The CommonJS team</a> responded to this call in the form of <a href="http://wiki.commonjs.org/wiki/Promises">Promises</a> , which are aimed at providing an interface for interacting with an object that is the result of an action that is performed asynchronously and that may or may not be completed at any given time. <br>  Thus, various components can return promises for asynchronous actions, and consumers can use promises in a predictable way.  Promises can also provide a fundamental entity to be used for a more convenient syntactically level of language extensions that help to work with asynchrony. <br><br>  <a href="http://www.infoq.com/articles/stratifiedjs">Stratified JavaScript</a> is another approach that suggests simplifying programming with a superset of the JavaScript language.  But if you cannot change programming languages, you can use a flexible API that allows you to emulate sequential code.  If this API allows the use of short notation, it is often called an embedded DSL. <br><br>  InfoQ decided to take a look at the list of these APIs and DSLs, and talk with their creators about how they approached the problem, the design principles, the paradigms they follow, and much more.  And, of course, about the limitations of these solutions. <br><br>  In particular, InfoQ has contacted: <br><ul><li>  Tim Caswell of <a href="https://github.com/creationix/step">Step</a> , </li><li>  Will Conant from <a href="https://github.com/willconant/flow-js">Flow-js</a> , </li><li>  Kris Zyp from <a href="https://github.com/kriszyp/node-promise">node-promise</a> , </li><li>  Caolan McMahon from <a href="https://github.com/caolan/async">Async</a> , </li><li>  Fabian Jakobs from <a href="">Async.js</a> , </li><li>  AJ O'Neal from <a href="https://github.com/coolaj86/futures">FuturesJS</a> and </li><li>  Isaac Z. Schlueter from <a href="https://github.com/isaacs/slide-flow-control">slide-flow-control</a> </li></ul><br><br>  <b>InfoQ: What problems does your library focus on?</b>  <b>That is, it focuses mainly on removing template code, avoiding manual processing of asynchronous I / O, or it also provides conducting or other functionality (for example, to help with the simultaneous processing of several I / O calls with the expectation of the results of their execution, and so on).</b> <br><br><blockquote>  <b>Tim (Step)</b> : Step‚Äôs goals are to remove both the template code and the more readable asynchronous code.  Our library is very minimalistic, and does not do anything that you can not repeat manually with the abundant use of try..catch blocks and variable counters.  A feature of our library is the simple formation of chains of sequential calls with optional groups of parallel calls at each step. <br></blockquote><br><blockquote>  <b>Will (Flow-js)</b> : Flow-JS provides a JavaScript construct that is similar to a continuation or fiber that exists in other programming languages.  Practically, it can be used to destroy the so-called "pyramids" from your multi-step asynchronous logic.  Instead of directly using the literals of nested callback functions, you use the special value ‚Äúthis‚Äù as the callback function for the next function specified in the definition of the execution thread. <br></blockquote><br><blockquote>  <b>Kris Zyp (node-promise)</b> : The problem is that the typical style of the flow of callbacks (transmission of continuity) combines the complexity of the interface and the mixing of functional parameters with the result handlers.  Promises encapsulate the event completion of the calculation, allowing functions / methods to be executed with clean input parameters, while the return value, like a promise, stores the result. <br><br>  I explained these principles a little more <a href="http://www.sitepen.com/blog/2010/05/03/robust-promises-with-dojo-deferred-1-5/">here</a> and <a href="http://www.sitepen.com/blog/2010/09/20/promised-io/">here</a> . <br><br>  Encapsulating event-based computations, promises work fine for conducting parallel and sequential actions, even with complex conditional logic.  The node-promise library includes functions to do this simply (all () and step () functions at promised-io) <br><br>  By the way, just for the information, <a href="http://github.com/kriszyp/promised-io">promised-io is</a> actually the heir of node-promise.  It has the same core, but promised-io also includes promise-style NodeJS I / O functions, and a platform normalization layer is available that provides access to similar functions in the browser. <br></blockquote><br><blockquote>  <b>Caolan (Async)</b> : Yes, the main task is to remove the template code.  The code for calling functions in series or in parallel, followed by waiting for callbacks in JavaScript, is quite detailed, but obvious.  Shortly after node.js moved from promises to callbacks as the underlying asynchronous processing mechanism, I discovered that I was using the same templates over and over again.  It seemed obvious that they needed to be extracted into a separate library. <br><br>  Since then, it has grown to cover more sophisticated features that allow you to conduct callbacks based on their dependencies.  For the most part, however, this is a fairly low-level library that leaves the overall structure to developers.  Nevertheless, I found that JavaScript is often suitable for a more functional programming style, and immediately added asynchronous versions of map, reduce, filter, and other common functions.  The library really shows its strength when used in this style, and allows you to stick with ordinary callbacks without using sequels or promise objects. <br></blockquote><br><blockquote>  <b>Fabian (Async.js)</b> : Async.js tries to simplify standard asynchronous templates in javascript.  Its main purpose is to apply a series of asynchronous functions to a set of homogeneous objects.  It grew from a forEach asynchronous function into a set of generic concepts.  This is especially useful for asynchronous work with the file system in node.js, although the library is not tied to node.js and can be used for any other similar cases.  This piece of code shows the use of async.js: <br><pre><code class="hljs lua">async.readdir(__dirname) .stat() .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> file.stat.isFile() }) .readFile(<span class="hljs-string"><span class="hljs-string">"utf8"</span></span>) .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(file.data); }) .<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"ERROR: "</span></span>, err); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"DONE"</span></span>); });</code> </pre>  This code operates with all elements of the current directory.  This is a uniform set of objects.  For each item in the catalog, a sequence of asynchronous operations is performed.  First, all elements that are not files are filtered out, then the contents of the files are read from the disk in utf-8 encoding and printed to the console.  After all the operations have been completed, the final callback function is called with the error indicator parameter. <br></blockquote><br><blockquote>  <b>AJ (FuturesJS)</b> : It‚Äôs pretty hard to talk about asynchronous and event-driven programming. <br><br>  I created Futures mainly for: <br><br><ul><li>  providing one library of asynchronous control flow for both browser and server (Node.JS); </li><li>  publishing a quality template for handling callbacks and error handler calls; </li><li>  control the flow of application execution, in which events depend on each other; </li><li>  handling callbacks for a variety of resources, such as mash-ups; </li><li>  encouraging the use of advanced programming practices, such as model use and error handling. </li></ul><br><br>  Futures.future and Futures.sequence simply reduce the number of boilerplate code and provide some flexibility. <br><br>  Futures.join can connect (in the same manner as join works for operating system execution threads) or synchronize (for events that occur periodically) several future objects. <br><br>  Futures.chainify makes it easy to create asynchronous models, similar to the Twitter Anywhere API. <br></blockquote><br><blockquote>  <b>Isaac (slide-flow-control)</b> : The task to which the slide is dedicated is that I needed something I could tell about at the OakJS meeting, and did not want to come up with any new idea, because I am very lazy.  Basically, I wanted to do almost no work, just show what was done, drink some beer, enjoy Chinese cuisine, chat with interesting people, swim a little in positive attention, and then return home.  The ratio of the amount of work to the win received is very important for me, both in software and in life.  So, I just put together terribly simple asynchronous helper methods that I use at npm so that they fit into a set of slides, called it ‚Äúslide‚Äù because of this feature, and introduced this library. <br><br>  Another task this library is dedicated to is to show how easy it is to write your own library of flow control.  Everyone thinks that his own library is the best, so it‚Äôs important to just give people a few basic patterns and let them create. <br></blockquote><br><br>  <b>InfoQ: Does the library implement ideas from computer science scientists?</b> <br><blockquote>  <b>Tim (Step)</b> : Directly - nothing. <br></blockquote><br><blockquote>  <b>Will (Flow-js)</b> : Not that I know.  It was just my first blow to the creation of business logic, which simplifies the execution of many synchronous calls to external services managed from Node.js. <br></blockquote><br><blockquote>  <b>Kris Zyp (node-promise)</b> : Yes, of course.  Most computer-aided research on asynchronous design points to Promises (promises) in various forms, as the most appropriate mechanism for functional flows and proper division of interests.  The term ‚Äúpromise‚Äù was originally proposed by Daniel P. Friedman and David Wise, beginning in 1976.  You can learn more about the rich history of computer science regarding promises from <a href="http://en.wikipedia.org/wiki/Futures_and_promises">a Wikipedia article</a> . <br></blockquote><br><blockquote>  <b>Caolan (Async)</b> : I have no experience in the field of computer science, and I implemented the Async library on a purely pragmatic basis.  When I needed a higher order function to clean up a bit of asynchrony in JavaScript, and I used it repeatedly, it went into the library. <br></blockquote><br><blockquote>  <b>Fabian (Async.js)</b> : The implementation of async.js is vaguely reminiscent of <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">Haskell Monads</a> , but this is rather random. <br></blockquote><br><br><blockquote>  <b>AJ (FuturesJS)</b> : Yes.  The following materials had the greatest impact: <br><ul><li>  <a href="http://googletesting.blogspot.com/2009/07/how-to-think-about-oo.html">Google's How to think about OO</a> </li><li>  <a href="http://yuiblog.com/crockford/">Yahoo! S Crockford on JavaScript Act III</a> </li><li>  <a href="http://www.youtube.com/user/GoogleTechTalks">Google's Lazy Programmers Guide to Secure Computing</a> </li></ul><br>  The best thing about asynchronous programming is that it naturally forces you to write more modular code, and if you have asynchronous models of any kind, then you have to follow the principle of always passing parameters inside the model and never transmit data that relates to the model. , beyond this model. <br></blockquote><br><blockquote>  <b>Isaac (slide-flow-control)</b> : It uses one type of continuation pattern.  A lot of computer science research misses this topic, I think.  This is my finger pointing to the moon.  To get there, you need a rocket.  Longer fingers will not help.  When you realize this, deeper mysteries will reveal themselves. <br></blockquote><br><br>  <b>InfoQ: Does the library offer any error handling strategies?</b>  <b>How does it interact with throwing exceptions?</b> <br><br><blockquote>  <b>Tim (Step)</b> : If an exception is thrown at any step, it is caught and passed to the next step as an error parameter.  Also, any non-undefined return values ‚Äã‚Äãare passed to the next step as a callback parameter.  Thus, the steps can be synchronous or asynchronous using the same syntax. <br></blockquote><br><blockquote>  <b>Will (Flow-js)</b> : Flow-JS does not have any built-in exception handling, which is definitely its weak point.  Tim Caswell wrote a flow-based module called Step, which frames the calls to each of the provided functions in try / catch blocks and passes caught exceptions to the next function in sequence. <br></blockquote><br><blockquote>  <b>Kris Zyp (node-promise)</b> : Yes, promises are designed to provide the asynchronous equivalent of a synchronous execution thread.  As a JavaScript function can throw an exception or return a value successfully, a promise can be resolved to a successful value or to an error state.  Promises returned to callers can propagate errors until the error handler ‚Äúcatches‚Äù them, just as the thrown exception propagates until it is caught.  The node-promise library supports this concept shortly, allowing you to easily register error handlers or propagate errors until they are caught (to eliminate the situation of silently swallowing errors).  Having direct synchronous equivalents of promises, the flow of code execution using promises is very easy to read. <br></blockquote><br><blockquote>  <b>Caolan (Async)</b> : Exception handling with asynchronous code can be a bit more complicated, especially if you are not familiar with highly asynchronous environments such as node.js.  For me, in fact, error handling is more important than the style that you adapt to this processing.  In the browser, this is especially important because it is easy to accidentally raise the exception to the top level, thereby killing all the JavaScript on the page. <br><br>  There is much that can be said about this.  Exception handling should be straightforward and preferably familiar, so that it is easy to implement and it becomes obvious if you forget about it.  Unfortunately, JavaScript in the browser does not help us in this sufficiently yet, but node.js provided a simple convention that can be easily used in both environments. <br><br>  The Async library adopted this convention using the first callback argument to pass the error to the next step in your program.  If the first argument is null (or another false value), then it can be ignored, otherwise it is considered as an exception.  Where possible, the implementation will be carried out by the Async library using an abbreviated scheme to speed up the process.  If one function from the executed collection is executed with an error, the subsequent functions in the collection will not be executed. <br></blockquote><br><blockquote>  <b>Fabian (Async.js)</b> : Async.js is built using the node.js error handling convention.  The first argument to any callback function is reserved for the error object.  If the evaluation ends in an error, or an exception is thrown, the error / exception is passed as the first argument to the callback function.  Async.js supports two error handling strategies that can be configured through its API.  In the event of an error, either the whole set operation is stopped, and the error handler is called, or the error element is skipped. <br></blockquote><br><blockquote>  <b>AJ (FuturesJS)</b> : Since exceptions cannot be thrown asynchronously, the user is instead prompted to pass any exceptions as the first parameter to the callback function. <br><br>  The basic idea is to execute try {} catch (e) {} for an error, and pass the error instead of stopping the application at some indefinite point in time.  Futures.asyncify () does this in order to use synchronous functions in the dominant asynchronous environment. <br><br>  Here is an example: <pre> <code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Futures = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'futures'</span></span>), doStuffSync, doStuff; doStuffSync = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span> % <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()*<span class="hljs-number"><span class="hljs-number">11</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Some Error"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Some Data"</span></span>; }; doStuff = Futures.asyncify(doStuffSync); doStuff.whenever(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }); doStuff(); doStuff(); doStuff(); doStuff(); }());</code> </pre><br></blockquote><br><blockquote>  <b>Isaac (slide-flow-control)</b> : Never throw exceptions!  Never!  Throwing an exception is evil.  Do not do this.  When the callback function is called, the first argument is either an error or null.  If this is an error, process it, or pass callback functions to handle it.  Send the error to the first parameter of your callback function to signal the appearance of an error. <br></blockquote><br><br>  <b>InfoQ: Was there a mastermind or under what influence your library was created (for example, F # Workflows, Rx (Javascript version), or other projects)?</b> <br><br><blockquote>  <b>Tim (Step)</b> : Yes, the style was borrowed directly from the project <a href="https://github.com/willconant/flow-js">flow-js</a> . <br></blockquote><br><blockquote>  <b>Will (Flow-js)</b> : Not really.  It was just the first decision that occurred to me. <br></blockquote><br><blockquote>  <b>Kris Zyp (node-promise)</b> : The Mark Miller E programming language and the use of promises in it, the Tyler Close ref_send library, the Kris Kowal Q library, the Neil Mix NarrativeJS library, in the Twisted and Dojo, and many other libraries. <br></blockquote><br><blockquote>  <b>Caolan (Async)</b> : I‚Äôm afraid that since I didn‚Äôt use F # or Rx, I can‚Äôt express my attitude to these projects.  However, I drew inspiration from Underscore.js, an excellent functional library for programming in JavaScript.  Most of the functions that use iterators from Underscore were modified to start working asynchronously with callbacks, and implemented in the Async library. <br></blockquote><br><blockquote>  <b>Fabian (Async.js)</b> : The characteristic call chains in the API were inspired by jQuery.  One of my goals was to provide a jQuery-like API for the node.js file system module.  <a href="http://www.python.org/dev/peps/pep-0255/">Python-style generators</a> also had <a href="http://www.python.org/dev/peps/pep-0255/">a</a> great influence.  Each element in the chain generates values ‚Äã‚Äãthat can be used by subsequent elements of the chain.  The whole operation is called the last element in the chain, which ‚Äúpulls‚Äù values ‚Äã‚Äãthrough the chain.  From this point of view, async.js differs from jQuery and Rx, where the values ‚Äã‚Äãare pushed by the source.  This "pulling" system makes it possible to calculate all values ‚Äã‚Äãlazily, and also allows you to create generators that return an infinite number of values ‚Äã‚Äã(for example, all even integers). <br></blockquote><br><blockquote>  <b>AJ (FuturesJS)</b> : Not immediately, no. <br><br>  I built a mashup site using Facebook and Amazon, and my first attempt was a jumble because I simply did not understand how to work with a model created from two resources (I was not really familiar with JavaScript at the time; I was going by trial and error in the <a href="http://wtfjs.com/">‚ÄúWTFJS‚Äù</a> style and used a bit of jQuery to simplify the painful work with the DOM). <br><br>  So I found it easier to always assume that it would take some time to get any data than ever to assume that the data would already exist if necessary, and then I realized that I had to reorganize the whole chain from bottom to top to make any particular set data could be processed asynchronously. <br><br>  I tried, failed, and half-done using several different methods, and then, to my luck, someone in the mailing list of <a href="https://groups.google.com/d/msg/ujsug/NBddMI5TV9M/14TI4HSYK2wJ">my local JavaScript user group</a> mentioned <a href="http://yuiblog.com/crockford">Crawford's lecture series on JS</a> .  After watching the entire series (I watched the third section at least 3 times), I finally began to better understand how to manage the ‚Äúproblems‚Äù (or, rather, the possibilities) of asynchronous programming.  Next, I found Crawford's slides and started with an example of promises, which he cited, as from his starting point. <br><br>  Later, I started playing with Node.JS, and as a result I changed my error handling strategy (but I updated the documentation only a few days ago).  In Futures 2.0, which I will release this coming Sunday, I also added EventEmitter from Node.JS for use in the browser. <br></blockquote><br><blockquote>  <b>Isaac (slide-flow-control)</b> : No  It was, I believe, inspired by the templates that we came to NodeJS for using callbacks.  I'm just a supporter of completeness, because I'm not smart enough to remember more than one kind of things (or maybe two, on a good day, with lots of coffee) without getting confused and going to the toilet, thinking that this is a bathroom. and then getting all the clothes smelling, like ... However, you understood the idea. <br><br>  Use things of the same type, everywhere.  That's all.  Functions that take a callback as the last argument.  Callback functions that receive an error message as the first argument, or null / undefined if everything went well.  Slide is just a few helper functions that make it easier to do a bunch of things using this scheme. <br></blockquote><br><br>  <b>InfoQ: Are there any new features or changes in the JavaScript language that can make the libraries better, for example, they can be more concise, etc.?</b> <br><br><blockquote>  <b>Tim (Step)</b> : Perhaps, but not without major changes in the semantics of the language.  Maybe a coffeescript preprocessor can help with syntax, but I think it‚Äôs better to stick with vanilla javascript most of the time. <br></blockquote><br><blockquote>  <b>Will (Flow-js)</b> : In my opinion, Javascript desperately needs something like fibers from Ruby 1.9.  I spent a lot of time working with Node.js for my future projects, but at some point asynchronous programming always makes the brain melt.  There are many tools to make it more manageable, but I can‚Äôt prove it, but I feel that having so many libraries like Flow-js is only evidence that Javascript is really unsuccessful for parallel programming. <br><br>  I know that one of the goals of Node was to avoid modifications in the core of the V8 JavaScript engine, but as far as I know, <a href="http://asana.com/blog/%3Fp%3D49">guys from Asana added fibers to the core without any special problems</a> . <br></blockquote><br><blockquote>  <b>Kris Zyp (node-promise)</b> : Yes, there has recently been a <a href="https://mail.mozilla.org/pipermail/es-discuss/2010-March/010865.html">discussion around single-staff or small sequels</a> similar to generators, which can help avoid the need for a callback, which complicate branching and thread loops.  This can be used in conjunction with promises to create extremely simple and easy-to-read asynchronous code. <br><br>  By the way, one more note - the node-promise library also implements the <a href="http://wiki.commonjs.org/wiki/Promises/A">http://wiki.commonjs.org/wiki/Promises/A</a> specification, that is, it can interact with Dojo and, probably, with future JQuery promises. <br></blockquote><br><blockquote>  <b>Caolan (Async)</b> : The Async library was designed to make the most of the language in its current form.  To work as is, without trying to create a new language over JavaScript. <br><br>  However, adding yield to JavaScript 1.7 may have some interesting applications for future projects.  Using yield, it would be possible to port some Twisted-like functions to JavaScript for a more synchronous-like coding style.  This is what my colleague is studying with <a href="https://github.com/Jc2k/whorl">Whorl</a> , although this project seems to have stopped developing. <br></blockquote><br><br><blockquote>  <b>Fabian (Async.js)</b> : Standardizing <a href="https://developer.mozilla.org/en/JavaScript/Guide/Iterators_and_Generators">generators and iterators supported by Mozilla</a> can make the async.js code more concise and simplify asynchronous problems. <br></blockquote><br><blockquote>  <b>AJ (FuturesJS)</b> : The most frequently repeated code in the library is the one that makes the code work the same in the browser and in Node.JS.  I know that some libraries (such as teleport) were created to try to resolve this issue, but I have not played with any of them yet.  This, of course, would be nice if asynchronous require was embedded in the language. <br><br>  From my point of view, a language with such natural asynchrony, like JavaScript, should have something similar to futures built into the core of the language. <br><br>  Although CommonJS has <a href="http://wiki.commonjs.org/wiki/Promises">several proposals</a> for standardizing server promises, while their focus is more on data privacy, futures are more focused on flow control, ease of use by end-developers, and browser compatibility. <br></blockquote><br><blockquote>  <b>Isaac (slide-flow-control)</b> : No  My flow control library is the best.  It cannot be improved in any other way, because this best is directly related to my self, so any external influence would make it less mine, and thus less good.  If you want to gain experience, I suggest you write your own library.  You will see that it is the best, as soon as you write it.  If it seems to any other library that something could be better, then you can rush back to the editor, hiding your shame, and quickly reinvent all your ideas, but a little differently than before, and then you will know in your heart that your new is now the best. <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/111634/">https://habr.com/ru/post/111634/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111627/index.html">We create an original gift with the help of chemistry, physics and electronics: part 2</a></li>
<li><a href="../111628/index.html">Droider Chart. Issue 34</a></li>
<li><a href="../11163/index.html">Divine mouthpiece.</a></li>
<li><a href="../111631/index.html">In the United States are going to develop a system of Internet passports</a></li>
<li><a href="../111632/index.html">Do you have a lot of startup ideas? - Forget it!</a></li>
<li><a href="../111635/index.html">All new!</a></li>
<li><a href="../111636/index.html">Infographics: Censorship on the Internet. It seems to you that the Internet is independent</a></li>
<li><a href="../111637/index.html">6-week Google Chrome update cycle</a></li>
<li><a href="../111638/index.html">Laziness (Mechanism, Part 2): Objectives</a></li>
<li><a href="../111640/index.html">Manage IT-projects - how to play rugby</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>