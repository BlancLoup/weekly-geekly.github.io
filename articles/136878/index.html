<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Game cycles or ElectroCardioGama</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The game cycle is the pulse of each game. No game will work without it. However, unfortunately for each new game developer, there are no good articles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Game cycles or ElectroCardioGama</h1><div class="post__text post__text-html js-mediator-article">  The game cycle is the pulse of each game.  No game will work without it.  However, unfortunately for each new game developer, there are no good articles on the web that have paid enough attention to this topic.  But do not be sad, because as soon as you got the opportunity to read a one-of-a-kind article that gives the issue of game cycles deserved attention.  On duty, I often have to deal with a large number of code of small mobile games.  And every time I wonder how many realizations of the game cycle there are.  You too can wonder how for such a seemingly simple thing, you can come up with many implementations.  But you can!  And in the article I will try to talk about the advantages and disadvantages of the most popular options for game cycles.  Also, I will try to describe the best in my opinion version of the implementation of the game cycle. <br>  (Thanks to Kao Cardoso for Felix this article is also available in Brazilian Portuguese) (Thanks for me, in Russian also, approx. Transl.) <br><a name="habracut"></a><br><h4>  Game cycle </h4><br>  Each game contains a sequence of calls for reading user input, updating the game state, processing AI, playing music and sound effects, drawing graphics.  This sequence of calls is performed within the game cycle.  Ie, as it was said in the teaser, the game cycle is the pulse of each game.  In the article I will not go into the details of the implementation of the tasks mentioned above, but will focus exclusively on the problem of the game cycle.  For the same reason, I will simplify the list of tasks to two functions: status update and rendering.  Below is a sample code for the most simple implementation of the game cycle. <br><pre><code class="python hljs">bool game_is_running = true; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( game_is_running ) { update_game(); display_game(); }</code> </pre> <br><br>  The problem with this implementation is that it does not handle time.  The game is just running.  On a weak gland, the game works slowly, on a strong one - quickly.  Long ago, when computer performance was known and about the same on different machines, this implementation did not give rise to problems.  Today, when there are many platforms with different performance, there is a need to handle time.  This can be done in different ways.  I will tell about them later.  In the meantime, let me explain a couple of points that will continue to be used. <br><br>  <b>FPS</b> <br>  FPS is an abbreviation of ‚ÄúFrames Per Second‚Äù (Frames Per Second, approx. Transl.).  In the context of the above implementation of the game cycle, this is the number of display_game () calls per second. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Game speed</b> <br>  Game speed is the number of game state updates per second.  In other words, the number of calls to update_game () per second of time. <br><br><h4>  FPS depending on constant game speed </h4><br><h5>  Implementation </h5><br>  The simplest solution to the timing problem is to simply make calls with a fixed frequency 25 times / sec.  The code implementing this approach is below. <br><pre> <code class="python hljs">const int FRAMES_PER_SECOND = <span class="hljs-number"><span class="hljs-number">25</span></span>; const int SKIP_TICKS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / FRAMES_PER_SECOND; DWORD next_game_tick = GetTickCount(); // GetTickCount() returns the current number of milliseconds // that have elapsed since the system was started int sleep_time = <span class="hljs-number"><span class="hljs-number">0</span></span>; bool game_is_running = true; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( game_is_running ) { update_game(); display_game(); next_game_tick += SKIP_TICKS; sleep_time = next_game_tick - GetTickCount(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( sleep_time &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ) { Sleep( sleep_time ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { // Shit, we are running behind! } }</code> </pre> <br><br>  This is a realization with one big plus: SIMPLICITY!  As soon as you know that update_game () is called 25 times per second, writing the rest of the code becomes easier for the fixed turnip.  For example, implementing replay functionality becomes a trivial task.  If the game does not use random variables, then you can simply log user input and play it back later.  On your test machine, you can pick up a compromise value for FRAMES_PER_SECOND, but what happens on a faster or slower hardware?  Let's find this out. <br><br><h5>  Weak iron </h5><br>  If the iron is able to withstand a given FPS, then there is no problem.  Problems will appear when the machine can not keep FPS at a given level.  The game will run slower.  In the worst case, the game will lag some intervals, while others work fine.  Time will flow at different speeds, which ultimately can make your game unplayable. <br><br><h5>  Productive iron </h5><br>  There will be no problems on powerful hardware, but the computer will be idle, wasting "precious" (apparently this is irony? - approx. Transl.) Processor time.  Were ashamed to run the game from 25..30 FPS, when she could give out for over 300!  Your game will lose in attractiveness compared to what it could show when using the processor to its fullest.  On the other hand, on mobile platforms, it can be for the better - it will save energy. <br><br><h5>  Conclusion </h5><br>  Setting an FPS at a fixed game speed is a simple solution that allows you to keep the code simple.  But there are problems: by setting too much importance for FPS, we will create problems on a weak iron;  setting the value too low will inefficiently use powerful hardware. <br><br><h4>  Game speed dependent on variable FPS </h4><br><h5>  Implementation </h5><br>  Another solution to the problem is to let the game run as fast as possible and make the game speed dependent on the current FPS.  The game will be updated using the amount of time spent drawing the previous frame. <br><pre> <code class="python hljs">DWORD prev_frame_tick; DWORD curr_frame_tick = GetTickCount(); bool game_is_running = true; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( game_is_running ) { prev_frame_tick = curr_frame_tick; curr_frame_tick = GetTickCount(); update_game( curr_frame_tick - prev_frame_tick ); display_game(); }</code> </pre> <br>  The code is complicated because  we must now handle the time delta in update_game ().  But the code is slightly complicated.  I have seen many clever developers who have implemented this approach.  Surely some of them would like to be able to read this post before they implemented such a cycle on their own.  Below, I will show why such an approach can have serious problems both on a weak gland and on a powerful one (yes ... and on a powerful one too). <br><br><h5>  Weak iron </h5><br>  Weak iron can sometimes cause delays in places where the game becomes ‚Äúheavy‚Äù.  This will definitely take place in 3D games when too many polygons are drawn.  As a result, failure in FPS will slow down the processing of user input.  Updating the game will respond to failures of the FPS, as a result, the state of the game will change with noticeable lags.  As a result, the player‚Äôs reaction time, exactly like the AI, will slow down, which may make even a simple maneuver impossible.  For example, an obstacle that can be overcome with a normal FPS will not be possible to overcome with a low FPS.  Even more serious problems on weak gland will be when using physics.  A physics simulation may <a href="http://gafferongames.com/game-physics/fix-your-timestep/">explode</a> . <br><br><h5>  Powerful iron </h5><br>  You may be surprised that the above implementation of the game cycle may not work correctly on fast hardware.  Unfortunately it can.  And before you show why, let me explain a few moments of mathematics on a computer.  In view of the finite bitness of representing a floating-point number, some values ‚Äã‚Äãcannot be represented.  Thus, a value of 0.1 cannot be represented in binary form and will be rounded when stored in a double variable.  I'll demonstrate this using the python console: <br> <code>&gt;&gt;&gt; 0.1 <br> 0.10000000000000001</code> <br>  This in itself is not a bad thing, but in sequential calculations it leads to problems.  Suppose you have a car, the speed of which is equal to 0.001 in parrots (free translation, approx. Transl.).  After 10 seconds, the car will move to a distance of 10.0 parrots.  If we divide this calculation into frames, we get the following function with FPS as a parameter: <br> <code>&gt;&gt;&gt; def get_distance( fps ): <br> ... skip_ticks = 1000 / fps <br> ... total_ticks = 0 <br> ... distance = 0.0 <br> ... speed_per_tick = 0.001 <br> ... while total_ticks &lt; 10000: <br> ... distance += speed_per_tick * skip_ticks <br> ... total_ticks += skip_ticks <br> ... return distance</code> <br> <br>  And let's try to calculate the path for 40 FPS. <br> <code>&gt;&gt;&gt; get_distance( 40 ) <br> 10.000000000000075</code> <br> <br>  Wait ka!  This is not 10.0 parrots!  What happened?  Everything is simple ... Since  we split the path calculation into 400 frames, then a significant error accumulated during the summation.  Can you imagine what will happen at 100 FPS? <br> <code>&gt;&gt;&gt; get_distance( 100 ) <br> 9.9999999999998312</code> <br> <br>  Wow!  The error has become even more !!!  This is because we make even more additions at 100 FPS.  So the error accumulates more.  Thus, the game will work differently with 40 FPS and 100 FPS. <br> <code>&gt;&gt;&gt; get_distance( 40 ) - get_distance( 100 ) <br> 2.4336088699783431e-13</code> <br>  You may think that such a difference is insignificant and can be neglected.  However, if you use this value in any other calculations, then problems will arise more serious (as an example - the integration of diff. Ur-s, note trans.).  Thus, the error can accumulate so large that it zakachapit (slightly censor than in the original, approx. Transl.) Your product on large FPS.  You ask how likely it is?  Probably enough to attract attention.  I had the honor to contemplate the game with such a realization of the game cycle.  And, indeed, it had problems with large FPS.  After the developer realized that the ‚Äúdog is buried‚Äù in the very core of the game code, it was necessary to refactor a ton of code to fix the bug. <br><br><h5>  Conclusion </h5><br>  At first glance, this type of game cycle seems very good, but only at first.  Both weak and powerful iron can cause problems.  In addition, the implementation of the state update function has become more complicated compared to the first implementation.  So in her furnace? <br><br><h4>  Constant game speed and maximum FPS </h4><br><h5>  Implementation </h5><br>  Our first implementation, "FPS, depending on the constant speed of the game," has problems on a weak gland.  It generates lags for both FPS and game state updates.  A possible solution to this problem is to perform a state update at a fixed frequency, but reduce the frequency of rendering.  Below is the implementation code for this approach: <br><pre> <code class="python hljs">const int TICKS_PER_SECOND = <span class="hljs-number"><span class="hljs-number">50</span></span>; const int SKIP_TICKS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / TICKS_PER_SECOND; const int MAX_FRAMESKIP = <span class="hljs-number"><span class="hljs-number">10</span></span>; DWORD next_game_tick = GetTickCount(); int loops; bool game_is_running = true; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( game_is_running ) { loops = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( GetTickCount() &gt; next_game_tick &amp;&amp; loops &lt; MAX_FRAMESKIP) { update_game(); next_game_tick += SKIP_TICKS; loops++; } display_game(); }</code> </pre> <br><br>  The game will be updated with a fixed frequency 50 times per second, and the drawing will be performed with the maximum possible frequency.  Note that if the drawing is performed more often than the update state, then some adjacent frames will be the same, so in reality the maximum FPS value will be limited by the frequency of updating the game state.  On a weak gland, the FPS will decrease until the state update cycle reaches the value MAX_FRAMESKIP.  In practice, this means that the game will really start to slow down only when the FPS drawing sags below the value 5 (= FRAMES_PER_SECOND / MAX_FRAMESKIP). <br><br><h5>  Weak iron </h5><br>  On a weak hardware, the FPS will drop, but the game itself will most likely work at normal speed.  If the iron is not able to withstand even the minimum FPS, it will begin to slow down and update the state, and the drawing will lose even a hint of smooth animation. <br><br><h5>  Powerful iron </h5><br>  On a powerful hardware game will work without any problems, but as in the first implementation, the processor will be used inefficiently.  Finding a balance between a quick upgrade and the ability to work on a weak gland is crucial. <br><br><h5>  Conclusion </h5><br>  Using fixed game speed and maximum possible FPS is a solution that is easy to implement and keeps the code simple.  But still there are some problems: setting the state update rate too high will cause problems on the weak gland (though not as serious as in the case of the first implementation), and setting the state update rate low will inefficiently use the computing power (resources could be used for increase the smoothness of animations, but instead they are spent on frequent drawing). <br><br><h4>  Constant game speed independent of variable FPS </h4><br><h5>  Implementation </h5><br>  Is it possible to improve the previous implementation so that it works faster on a weak gland and would be more attractive visually on a powerful one?  Well, fortunately for us, yes, it is possible!  The game state does not need to be updated 60 times per second.  User input, AI, as well as updating the state of the game, enough to update 25 times per second (I do not agree with this, not always, approx. Transl.).  So let's call update_game () 25 times per second, not more, not less.  But let the drawing be done as often as the iron pulls.  But slow rendering should not affect the frequency of updating the state.  How to achieve this is shown in the following code. <br><pre> <code class="python hljs">const int TICKS_PER_SECOND = <span class="hljs-number"><span class="hljs-number">25</span></span>; const int SKIP_TICKS = <span class="hljs-number"><span class="hljs-number">1000</span></span> / TICKS_PER_SECOND; const int MAX_FRAMESKIP = <span class="hljs-number"><span class="hljs-number">5</span></span>; DWORD next_game_tick = GetTickCount(); int loops; float interpolation; bool game_is_running = true; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( game_is_running ) { loops = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( GetTickCount() &gt; next_game_tick &amp;&amp; loops &lt; MAX_FRAMESKIP) { update_game(); next_game_tick += SKIP_TICKS; loops++; } interpolation = float( GetTickCount() + SKIP_TICKS - next_game_tick ) / float( SKIP_TICKS ); display_game( interpolation ); }</code> </pre> <br><br>  As a result, the implementation of update_game () will remain simple.  However, unfortunately, the display_game () function becomes more complex.  You will need to implement interpolation and prediction.  But do not worry, it is not as difficult as it seems.  Later, I'll tell you how interpolation and prediction work, but first let me show you why they are needed. <br><br><h4>  Why do you need interpolation </h4><br>  The game state is updated 25 times per second.  Therefore, if interpolation is not used, then frames will be displayed with the same maximum frequency.  Here it should be noted that 25 frames per second is not as slow as it might seem to someone.  For example, in movies, frames are replaced with a frequency of 24 frames per second.  So 25 frames per second seems sufficient, but not for fast moving objects.  For such objects, you should increase the frequency of updating the state to get a smoother animation.  An alternative to the increased refresh rate is precisely the combination of interpolation and prediction. <br>  <i>* Approx.</i>  <i>trans .: in the <a href="http://www.neoaxis.com/ru/neoaxis/features/physics">NeoAxis</a> engine for the physical object you can set the flag Continuous Collision Detection;</i>  <i>I suspect that it is just that processing is performed, similar to the implementation of the game cycle described above.</i> <br><br><h4>  Interpolation and prediction </h4><br>  As it was written above, the state is updated on its own, independent frequency.  Therefore, it is possible that the drawing starts between two consecutive ticks.  Suppose you have updated the status 10 times.  Then the drawing is called and it runs somewhere between 10 and 11 ticks.  Let it be discrete time 10.3.  As a result, ‚Äúinterpolation‚Äù will have a value of 0.3.  As an example, imagine a car moving as follows: <br> <code>position = position + speed;</code> <br>  If at the 10th step of the status update cycle the position is 500, the speed will be 100, then at the 11th step the position will be 600. So what will be the position of the machine during the drawing?  You can simply take a position in the last step, i.e.  500. But it is much better to predict the position in the next step and interpolate for time 10.3.  Get the view code: <br> <code>view_position = position + (speed * interpolation)</code> <br>  Thus, the machine will be drawn at position 530. The variable ‚Äúinterpolation‚Äù generally contains a value from 0 to 1 relative position in time between the current and next frames (redone for better understanding, approx. Transl.).  There is no need to make predictions too complex to ensure smooth animation.  Of course, a situation is possible when one object partially intersects with another immediately before the detection of a collision.  But, as we saw earlier, the state of the game is updated 25 times per second, so the rendering artifact will be visible only a split second (and what if the density of objects is large and there are a lot of collisions? - approx. Transl.) And with little probability it will be noticed by the user. <br><br><h5>  Weak iron </h5><br>  In most cases, update_game () will run much faster than display_game ().  In fact, we can take for granted that even on a weak gland, the update_game () function is called 25 times per second.  Therefore, our game will handle user input and update state without any problems even in the case when the drawing is performed at a frequency of 15 frames per second. <br><br><h5>  Powerful iron </h5><br>  On powerful hardware, the game will still go at a fixed speed of 25 ticks per second, but rendering will be faster.  Interpolation + prediction will add to the attractiveness of the animation, because  in fact, rendering will be performed at a higher FPS.  The beauty is that this way you cheat with FPS.  You do not update the state of the game with great frequency, but only a picture.  But at the same time your game will still have a high FPS. <br><br><h5>  Conclusion </h5><br>  Decoupling updates and rendering from each other seems like the best solution.  However, it is necessary to implement interpolation and prediction in display_game ().  True, this task is not too complicated (only when using primitive object mechanics, approx. Transl.). <br><br><h4>  Conclusion </h4><br>  The game loop is not such a simple thing as you might think.  We considered 4 possible implementations.  And among them there is at least one (where the state update is tightly tied to the FPS), which you should definitely avoid.  A constant frame rate may be acceptable on mobile devices.  However, if you want to port the game to different platforms, you will have to decouple the update frequency and drawing frequency, implement interpolation and prediction.  If you do not want to bother with prediction and interpolation, then you can use a large frequency of updating the state, but finding its optimal value for a weak and powerful iron can be a difficult task. <br><br>  Now march to code your &lt;% place_your_game_title_here%&gt;! <br><br><h4>  Associated articles (from translator) </h4><br><ol><li>  <a href="http://habrahabr.ru/blogs/silverlight/125037/">habrahabr.ru/blogs/silverlight/125037</a> - Game cycle in SL </li><li>  <a href="http://habrahabr.ru/blogs/gdev/112444/">habrahabr.ru/blogs/gdev/112444</a> - there is mention of the fact that in Unity3D there is no game cycle as such (apparently it is hidden away?) </li><li>  <a href="http://habrahabr.ru/blogs/gdev/102930/">habrahabr.ru/blogs/gdev/102930</a> - about the creation of the game engine </li><li>  <a href="http://habrahabr.ru/blogs/android_development/136968/">habrahabr.ru/blogs/android_development/136968</a> - an example of playing coconut </li><li>  <a href="http://gafferongames.com/game-physics/fix-your-timestep/">gafferongames.com/game-physics/fix-your-timestep</a> - another article about discrete time in games </li></ol></div><p>Source: <a href="https://habr.com/ru/post/136878/">https://habr.com/ru/post/136878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136873/index.html">Amateur mod for Heroes 3 - Horn of the Abyss</a></li>
<li><a href="../136874/index.html">On the possibilities of antiviruses. Part 2</a></li>
<li><a href="../136875/index.html">Report on the 3rd Kiev Habravstreche</a></li>
<li><a href="../136876/index.html">GTD - Big Plus</a></li>
<li><a href="../136877/index.html">The little redis book</a></li>
<li><a href="../136879/index.html">Some file sharing services suspend</a></li>
<li><a href="../136880/index.html">Justin's robot has become even more agile.</a></li>
<li><a href="../136883/index.html">Size of java objects. We use the knowledge gained</a></li>
<li><a href="../136885/index.html">Advertising in the mobile version of LJ</a></li>
<li><a href="../136886/index.html">Three approaches to the methodology of building a complex client application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>