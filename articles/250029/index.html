<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compiling nested classes: javac and ecj</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, in the Java language there are nested (nested) classes declared inside another class. There are even four types of them - static nested, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compiling nested classes: javac and ecj</h1><div class="post__text post__text-html js-mediator-article">  As you know, in the Java language there are nested (nested) classes declared inside another class.  There are even four types of them - static nested, <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/innerclasses.html">inner (inner)</a> , <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html">local (local)</a> and <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html">anonymous (anonymous)</a> (in this article we do not touch on lambda expressions that appeared in Java 8).  All of them are united by one interesting feature: the Java virtual machine has no idea about the special status of these classes.  From her point of view, these are ordinary classes located in the same package as the external class.  All work on converting nested classes to regular ones falls on the compiler.  And here it is curious to see how different compilers cope with it.  We look at the behavior of javac 1.8.0.20 and the ecj compiler from Eclipse JDT Core 3.10 (included with Eclipse Luna). <br><a name="habracut"></a><br>  Here are the main problems associated with compiling nested classes: <br><ul><li>  Access rights; </li><li>  Passing an object reference to an external class (irrelevant for static nested classes); </li><li>  Passing local variables from external context (similar to closure). </li></ul><br>  This article will talk about the first two problems. <br><br><h4>  Access rights </h4><br>  With access rights there is a big trouble.  We can declare a field or method of a nested class as private, and according to the Java specification, this field or method can still be accessed from an external class.  It is possible and vice versa: to refer to a private field or a method of an external class from a nested one, or from one nested class to use another.  However, from the point of view of a Java machine, accessing private members of another class is unacceptable.  The same goes for accessing protected members of a parent class located in another package.  To circumvent this limitation, compilers create special access methods.  They are all static, have access package-private and are called starting with access $.  Moreover, ecj calls them simply access $ 0, access $ 1, etc., and javac adds at least three digits, where the last two encode a specific operation (read = 00, write = 02), and initial ones encode a field or method.  Access methods are required to read fields, write fields and call methods. <br><br>  The access methods for reading fields have one parameter ‚Äî an object, and the methods for writing fields ‚Äî two parameters (an object and a new value).  In this case, the write methods in ecj return void, and in javac, the new value (the second parameter).  Take for example the following code: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer i)</span></span></span><span class="hljs-function"> </span></span>{ b = ia; ia = <span class="hljs-number"><span class="hljs-number">5</span></span>; } } }</code> </pre> <br><br>  If the bytecode generated by javac is translated back to java, you get something like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">000</span></span>(Outer obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.a; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">002</span></span>(Outer obj, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (obj.a = val); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer i)</span></span></span><span class="hljs-function"> </span></span>{ b = Outer.access$<span class="hljs-number"><span class="hljs-number">000</span></span>(i); Outer.access$<span class="hljs-number"><span class="hljs-number">002</span></span>(i, <span class="hljs-number"><span class="hljs-number">5</span></span>); } }</code> </pre><br>  The ecj code is similar, only the methods are called access $ 0, access $ 1 and the second returns void.  Everything will become much simpler if you remove the word private: then access methods will not be needed and the fields can be accessed directly. <br><br>  Interestingly, javac behaves smarter with field increments.  For example, compile this code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer i)</span></span></span><span class="hljs-function"> </span></span>{ i.a++; } } }</code> </pre> <br>  Javac will display something like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> access$<span class="hljs-number"><span class="hljs-number">008</span></span>(Outer obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.a++; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer i)</span></span></span><span class="hljs-function"> </span></span>{ Outer.access$<span class="hljs-number"><span class="hljs-number">008</span></span>(i); } }</code> </pre> <br>  A similar behavior is observed with decrement (the name of the method will end with 10), as well as with pre-increment and pre-decrement (04 and 06).  In all these cases, the ecj compiler will first call the read method, then add or subtract one and call the write method.  If someone wonders where the odd numbers are, they will be used for direct access to the protected fields of the parent of the outer class (for example, Outer.super.x = 2, I can‚Äôt imagine where it could be useful!). <br><br>  By the way, it is curious that javac 1.7 behaved even smarter, generating special methods for any assignment operations like + =, &lt;&lt; =, etc. (the right part was calculated and transferred to the generated method as a separate parameter).  A special method was generated, even if you applied + = to an inaccessible string field.  In javac 1.8, this functionality broke, and it seems that by accident: the <a href="">corresponding code is</a> present in the compiler's source code. <br><br>  If the programmer himself creates a method with the appropriate signature (for example, access $ 000, never do that!), Javac will refuse to compile the file, displaying the message "the symbol (conflict) conflict with a compiler-synthesized symbol in (class)".  The ecj compiler quietly transfers conflicts by simply increasing the counter until it finds a free method name. <br><br>  When you try to call an inaccessible method, an auxiliary static method is created that has the same parameters and a return type, only an additional parameter is added to transfer the object.  A more interesting situation is the use of a private constructor.  When constructing an object, you must call the constructor.  Therefore, compilers generate a new non-private constructor, which calls the necessary private one.  How to create a constructor that does not conflict with the existing ones exactly according to the signature?  Javac for this purpose generates a new class!  Take this code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); } } }</code> </pre> <br>  When compiling, not only Outer.class and Outer $ Nested.class will be created, but another class Outer $ 1.class.  The code created by the compiler looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} Outer(Outer$<span class="hljs-number"><span class="hljs-number">1</span></span> ignore) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$1 </span></span>{} <span class="hljs-comment"><span class="hljs-comment">//      ,  ,     class Outer$Nested { void create() { new Outer((Outer$1)null); } }</span></span></code> </pre><br>  The solution is convenient in the sense that a conflict over the signature of the constructor will not be guaranteed.  The ecj compiler decided to do without an extra class and add the same class with a dummy parameter: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} Outer(Outer ignore) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer((Outer)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } }</code> </pre><br>  In the event of a conflict with an existing designer, new dummy parameters are added.  For example, you have three constructors: <br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer i1)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Outer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer i1, Outer i2)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre><br>  If you use each of them from a nested class, ecj creates three new ones that have three, four, and five Outer parameters. <br><br><h4>  Passing an External Class Object Reference </h4><br>  Inner classes (including local and anonymous) are tied to a specific object in the outer class.  To achieve this, a new final-field is added to the inner class by the compiler (usually with the name this $ 0), which contains a reference to the surrounding class.  At the same time, the corresponding parameter is added to each constructor.  If you take this simple code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nested(); } }</code> </pre> <br>  The compilers (ecj and javac behavior here seems to) turn this code into something like this (I remind you that I restore it manually using bytecode, so that it is clearer): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer$Nested(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Outer <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">0</span></span>; Outer$Nested(Outer obj) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">0</span></span> = obj; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } }</code> </pre> <br>  It is curious that the assignment of this $ 0 occurs before calling the parent class constructor.  In normal Java code, you cannot assign a value in the field before executing the parent constructor, but bytecode does not prevent this.  Because of this, if you override the method called by the constructor of the parent class, this $ 0 will already be initialized and you can easily access the fields and methods of the outer class. <br><br>  If you create a conflict by name, starting a field with the name this $ 0 in the Nested class (never do that!), The compilers will not be confused: they will call their internal field this $ 0 $. <br><br>  The Java language allows you to create an instance of the inner class not only on the basis of this, but also on the basis of another object of the same type: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer other)</span></span></span><span class="hljs-function"> </span></span>{ other.new Nested(); } }</code> </pre> <br>  An interesting point arises here: the other may turn out to be null.  For good, you should fall in this place with a NullPointerException.  Usually, the virtual machine itself ensures that you do not dereference null, but in fact there will be no dereference until you use the outer class inside the Nested object, which may happen much later or not at all.  The compilers have to get out again: they insert a dummy call, turning the code into something like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Outer other)</span></span></span><span class="hljs-function"> </span></span>{ other.getClass(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer$Nested(other); } }</code> </pre> <br>  The call to getClass () is safe: for any object it must succeed and takes a little time.  If it turns out that in other null, the exception will happen even before the creation of the Nested object. <br><br>  If the nesting level of classes is more than one, then new variables appear in the innermost ones: this $ 1 and so on.  As an example, consider this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubNested</span></span></span><span class="hljs-class"> </span></span>{ {test();} } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Nested().new SubNested(); } }</code> </pre> <br>  Here javac will create something like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Outer$Nested tmp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer$Nested(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); tmp.getClass(); <span class="hljs-comment"><span class="hljs-comment">//  ,   new Outer$Nested$SubNested(tmp); } } class Outer$Nested { final Outer this$0; Outer$Nested(Outer obj) { this.this$0 = obj; super(); } } class Outer$Nested$SubNested { final Outer$Nested this$1; Outer$Nested$SubNested(Outer$Nested obj) { this.this$1 = obj; super(); this.this$1.this$0.test(); } }</span></span></code> </pre> <br>  The call to getClass () could have been removed, since we just created this object, but the compiler does not bother.  But ecj generated an access method altogether unexpectedly: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Outer <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">0</span></span>; Outer$Nested(Outer obj) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">0</span></span> = obj; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Outer access$<span class="hljs-number"><span class="hljs-number">0</span></span>(Outer$Nested obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class">$</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubNested</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Outer$Nested <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">1</span></span>; Outer$Nested$SubNested(Outer$Nested obj) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>$<span class="hljs-number"><span class="hljs-number">1</span></span> = obj; <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); Outer$Nested.access$<span class="hljs-number"><span class="hljs-number">0</span></span>(obj).test(); } }</code> </pre> <br>  Very strange, given that this $ 0 does not have a private flag.  On the other hand, ecj guessed to reuse the obj parameter instead of referring to the field this.this $ 1. <br><br><h4>  findings </h4><br>  Nested classes present some headaches for compilers.  Do not hesitate to access package-private: in this case, the compiler will do without autogenerated methods.  Of course, modern virtual machines almost always make them idle, but still the presence of these methods requires more memory, inflates the pool of class constants, lengthens the stack-traces and adds extra steps when debugging. <br><br>  Different compilers can generate very different code in similar situations: even the number of generated classes may differ.  If you are writing bytecode analysis tools, you must take into account the behavior of different compilers. </div><p>Source: <a href="https://habr.com/ru/post/250029/">https://habr.com/ru/post/250029/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250015/index.html">Stop using passwords in Plesk</a></li>
<li><a href="../250021/index.html">Getting rid of JavaScript in social buttons (Facebook, VK, Twitter, etc.)</a></li>
<li><a href="../250023/index.html">Limiting the number of attempts to enter a password in the authorization web form using Nginx or HAProxy using the example of WordPress</a></li>
<li><a href="../250025/index.html">Git game or in search of Linus Torvalds</a></li>
<li><a href="../250027/index.html">Export Favorites on Habr√© to PDF. Version 2.0</a></li>
<li><a href="../250031/index.html">Interval reps "in the pocket"</a></li>
<li><a href="../250035/index.html">The digest of interesting materials for the mobile developer # 89 (February 2-8)</a></li>
<li><a href="../250039/index.html">Symfony2. Universal tool for quick cooking of table lists in the administrative panel</a></li>
<li><a href="../250043/index.html">Developing microservices using Scala, Spray, MongoDB, Docker and Ansible</a></li>
<li><a href="../250045/index.html">Imarker usage statistics (SORM-like web analytics system)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>