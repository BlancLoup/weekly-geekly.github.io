<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Beginning the translation of the ‚Äúlegacy‚Äù of the Angular JS project to the Angular 1.5 Components / ES6 and TypeScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the article, I wanted to share a version of the beginning of the gradual migration of the Angular JS project ‚Äúlegacy‚Äù to all the good things that A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Beginning the translation of the ‚Äúlegacy‚Äù of the Angular JS project to the Angular 1.5 Components / ES6 and TypeScript</h1><div class="post__text post__text-html js-mediator-article">  In the article, I wanted to share a version of the beginning of the gradual migration of the Angular JS project ‚Äúlegacy‚Äù to all the good things that Angular 1.5 <a href="https://habrahabr.ru/post/277087">gave us</a> and a bunch of ES6 / TypeScript. <br><br>  So, it‚Äôs given: a standard project, the development of which began even on the bearded Angular 1.2 (a person far from the world of the frontend), presented in a more or less standard form - modules for routs, services, directives and incredibly fat controllers, the functionality of which slowly stand out in separate directives.  Hell of a flow of features to implement, the complete absence of models, access to objects and their modifications - as God would per capita. <br><br>  Also, the project already has a more or less well-established and prescribed process for assembling / minifying and deploying all this stuff with the help of gulp, CI, and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task is not to go into the support of the project in the form in which it is, to start writing good, supported code, learn something new. <br><a name="habracut"></a><br><h2>  Introductory </h2><br>  Just arrived Angular 1.5, who presented the "components" and after a certain amount of read manuals on various related topics (including migration 1.3 -&gt; 1.4, 1.4 -&gt; 1.5, 1.x -&gt; 2) such points were adopted as a program for the foreseeable future : <br><br><ol><li>  Old functionality for the time being just do not touch </li><li>  We immediately write the functional in the form of a component (we store styles, patterns and tests in the same place where the code of a specific component) </li><li>  We are not at all embarrassing to use features from ES6 / ES7 </li><li>  We write on Typescript </li><li>  We rework the old functionality in a new way as it receives tasks large enough to refactor. </li></ol><br>  Now you need to decide on the strapping. <br><br>  Browsers at this stage of development do not support ES6 imports, which means that in order to use them (and I wanted more ‚Äúneutive‚Äù), you need to build the project under the browser by one of the ‚Äúcollectors‚Äù.  After some research, the choice fell on the <a href="https://webpack.github.io/">webpack</a> - its ideology is perfectly combined with the ideology of the components and allows you to connect the necessary templates and styles directly from the component code. <br><br>  After a couple of months, it was updated from a stable 1.x to 2 (beta).  Version 2 has some very important <a href="https://gist.github.com/sokra/27b24881210b56bbaff7">innovations</a> - first of all, this is native support for ES6 Imports (including the gradual loading of parts of the code as the client needs in this code). <br><br>  For the webpack, we will need several ‚Äúloaders‚Äù - these are some kind of middleware, giving the webpack how to add this or that file to the assembly.  I have this set relatively modest: <br><br><ul><li>  <strong>ts-loader</strong> , later replaced by <strong>awesome-typescript-loader</strong> (since atl managed to be made to support baseUrl from the typescript 2.0 settings, for which the transition to typescript 2.0 was mainly made) <br><br></li><li>  <strong>ng-annotate-loader</strong> , later replaced by a plug-in for babel <strong>babel-plugin-angularjs-annotate</strong> due to the non-support of the first ES6 imports - an ultra-useful thing, the implementation of the ng-annotate module, which allows to visually clear the code of angular components <a href="https://docs.angularjs.org/guide/di">without minification-proof dependency injection</a> and instead <br><br><pre><code class="hljs actionscript">.factory(<span class="hljs-string"><span class="hljs-string">'serviceId'</span></span>, [<span class="hljs-string"><span class="hljs-string">'depService'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(depService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }])</span></span></code> </pre> <br>  start writing more or less human: <br><br><pre> <code class="hljs php">.factory(<span class="hljs-string"><span class="hljs-string">'serviceId'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(depService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@ngInject</span></span></span><span class="hljs-comment">*/</span></span> <span class="hljs-comment"><span class="hljs-comment">// ... })</span></span></code> </pre><br></li><li>  <strong>less-loader</strong> for compiling less at boot time (in the legacy part of the project we have most of the styles written in less, and I didn‚Äôt see a reason not to continue using less, especially since we already have a bunch of mixins and variables) <br><br></li><li>  <strong>style-loader</strong> - download css, resulting in less output <br><br></li><li>  <strong>raw-loader</strong> - in my case, loading html directly into js </li></ul><br>  Even with the webpack almost bundled <strong>webpack-dev-server is</strong> supplied, which allows you to greatly accelerate the recompilation with changes - this is a local server that distributes the usual statics from this directory, and the code collected by the webpack keeps, reassembles and distributes directly from memory. <br><br>  We also need the <a href="https://www.typescriptlang.org/">TypeScript</a> compiler itself.  After the same couple of months, it was updated with beta 2.0 to beta 2.0, mainly due to the fact that 2.0 allows you to set the base url for all imports, finally get rid of the prevalence of relative paths within the files and replace a bit depressing: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> IConversation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../interfaces/IConversation"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Conversation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../models/Conversation"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Interaction <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../models/Interaction"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NotificationService <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "../../../helpers/NotificationService";</code> </pre><br>  On quite enterprise: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> IConversation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "interfaces/IConversation"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Conversation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "models/Conversation"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Interaction <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "models/Interaction"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> NotificationService <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "helpers/NotificationService";</code> </pre><br>  We will also probably need a transpiler (this is like a compiler, only to compile ES6 to ES5) in order for our most modern code to work normally for the most ordinary users of the service.  The most popular now is <a href="https://babeljs.io/">Babel JS</a> .  Of course, you can use the TypeScript compiler directly as a transspiler, but it does worse than babel (async / await, for example, typescript does not transpaylit, as far as I know), so I decided to compile TypeScript in ES6 and then using Babel and preset <strong>es2015 -webpack</strong> (this is a special preset for webpack 2, it doesn‚Äôt convert ES6 Imports to CommonJS, as the webpack can now build ES6 Imports by itself). <br><br>  We will also need a <a href="https://github.com/typings/typings">TypeScript Definition Manager</a> (formerly tsd. Many articles recommend tsd, but tsd is already deprecated and as such asks to use the typings project instead). <br><br>  So let's get started. <br><br><h2>  Install and configure the environment </h2><br>  First of all, install all of the above: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">npm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">install</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--save-dev</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">webpack</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">2</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">1</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">0</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">beta</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">20</span></span> typescript@<span class="hljs-number"><span class="hljs-number">2</span></span> less-loader raw-loader style-loader typescript typings webpack webpack-dev-server babel-runtime babel-preset-es2015-webpack babel-polyfill babel-plugin-angularjs-annotate babel-loader babel-core awesome-typescript-loader</code> </pre><br>  Probably typescript, webpack and typings will have to be installed globally in order to work comfortably. <br><br>  We will also need to install all the necessary definitions for our comfortable work with typescript: <br><br><pre> <code class="hljs sql">typings <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> angular <span class="hljs-comment"><span class="hljs-comment">--source=dt --global --save</span></span></code> </pre><br>  And maybe <br><br><pre> <code class="hljs sql">typings <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> jquery <span class="hljs-comment"><span class="hljs-comment">--source=dt --global --save</span></span></code> </pre><br>  And all that is still used there. <br><br>  The result of these commands will be the typings.json file created in the current directory, which will later restore all your typings by calling the command <br><br><pre> <code class="hljs sql">typings <span class="hljs-keyword"><span class="hljs-keyword">install</span></span></code> </pre><br>  Those.  This is a similar analog of the lock-file or package.json for the definition manager.  This file must be added to the repository.  There will also be a typings folder with the actual downloaded definitions for use in typescript.  (you can add it to .gitignore and make typing call a part of the project build) <br><br>  Next, let's start writing for all this configs. <br><br><h3>  Configurations </h3><br>  <strong>./declarations.d.ts</strong> <br>  It is used for the same purpose for which definitions from typings are used, but contains those interfaces that were not found in the typings manager's repositories.  I have there for example <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> require(<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; // used by webpack <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> let antlr4: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> let rangy: <span class="hljs-keyword"><span class="hljs-keyword">any</span></span>;</code> </pre><br>  Of course, with any - I was too lazy, in theory there is a need to completely describe the interface and then you will have the correct autocomplete for these objects in your IDE and, most importantly, validation of using the methods / properties of these objects at the compilation stage.  This is for me todo, so to speak. <br><br>  Require is mandatory here, otherwise your webpack code will not be collected. <br><br>  <strong>./tsconfig.json</strong> <br>  This is the typescript compiler configuration. <br><br><pre> <code class="hljs pgsql">{ "compilerOptions": { "target": "ES6", "sourceMap": <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, // <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> "experimentalDecorators": <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, // decorators support, see ts reference "baseUrl": "./path/to/your/app" // url that will be <span class="hljs-string"><span class="hljs-string">'root'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> imports }, "files": [ "declarations.d.ts", // declarations file <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> previous <span class="hljs-type"><span class="hljs-type">point</span></span> "typings/index.d.ts" // declarations, downloaded <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> definition manager ] }</code> </pre><br>  The files array declared here allows us not to write terrifying in every file <br><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;reference path="..." /&gt;</span></span></span></span></code> </pre><br>  Well, as you can see in this config there is no outfile and any significant project files.  Just because we give these questions to the webpack. <br><br>  <strong>./webpack.config.js</strong> <br>  Actually webpack configuration. <br><br><pre> <code class="hljs pgsql"><span class="hljs-string"><span class="hljs-string">'use strict'</span></span>; var <span class="hljs-type"><span class="hljs-type">path</span></span> = require(<span class="hljs-string"><span class="hljs-string">'path'</span></span>); var webpack = require(<span class="hljs-string"><span class="hljs-string">'webpack'</span></span>); var TsConfigPathsPlugin = require(<span class="hljs-string"><span class="hljs-string">'awesome-typescript-loader'</span></span>).TsConfigPathsPlugin; // plugin <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> typescript base <span class="hljs-type"><span class="hljs-type">path</span></span>. Skip it <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you don<span class="hljs-string"><span class="hljs-string">'t need this. var babelSettings = { plugins: [['</span></span>angularjs-annotat<span class="hljs-string"><span class="hljs-string">e', {'</span></span>explicitOnly<span class="hljs-string"><span class="hljs-string">' : true}]], //explicitOnly here to disallow auto-annotating of each function. Skip it if you need automatioc anotation presets: ['</span></span>es2015-webpack<span class="hljs-string"><span class="hljs-string">'] }; module.exports = { module: { loaders: [ { test: /\.tsx?$/, loader: '</span></span>babel-loader?<span class="hljs-string"><span class="hljs-string">' + JSON.stringify(babelSettings) + '</span></span>!awesome-typescript-loader<span class="hljs-string"><span class="hljs-string">', }, {test: /\.html$/, loader: '</span></span>raw<span class="hljs-string"><span class="hljs-string">'}, {test: /\.less$/, loader: '</span></span>style!css?sourceMap!less?sourceMap<span class="hljs-string"><span class="hljs-string">'} ] }, entry: { components: '</span></span>./<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/app/components/components.ts<span class="hljs-string"><span class="hljs-string">' // entry1: '</span></span>./<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/app/components/entry1/entry1.component.ts<span class="hljs-string"><span class="hljs-string">' // entry1: '</span></span>./<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/app/components/entry2/entry2.component.ts<span class="hljs-string"><span class="hljs-string">' // models: '</span></span>./<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/app/models/models.bundle.ts<span class="hljs-string"><span class="hljs-string">' // ...whatever you want }, resolve: { extensions: ['</span></span>.ts<span class="hljs-string"><span class="hljs-string">', '</span></span>.js<span class="hljs-string"><span class="hljs-string">', '</span></span>.html<span class="hljs-string"><span class="hljs-string">', '</span></span>.css<span class="hljs-string"><span class="hljs-string">', '</span></span>.less<span class="hljs-string"><span class="hljs-string">'], alias: { // lessWebApp: path.join(__dirname, '</span></span>/<span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/app/less<span class="hljs-string"><span class="hljs-string">') - whatever you want to be used in your code }, plugins: [ new TsConfigPathsPlugin() ] }, devtool: '</span></span>source-map<span class="hljs-string"><span class="hljs-string">', output: { path: path.join(__dirname, '</span></span><span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/build/js/bundles<span class="hljs-string"><span class="hljs-string">'), publicPath: '</span></span>/js/bundles<span class="hljs-string"><span class="hljs-string">', filename: '</span></span>[<span class="hljs-type"><span class="hljs-type">name</span></span>].bundle.js<span class="hljs-string"><span class="hljs-string">' }, plugins: [ // new webpack.optimize.CommonsChunkPlugin({ name: '</span></span>common<span class="hljs-string"><span class="hljs-string">', filename: '</span></span>common.bundle.js<span class="hljs-string"><span class="hljs-string">' }) - use this to move out common chunks to one separate chunk ], devServer: { contentBase: path.join(__dirname, '</span></span><span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/your/build/<span class="hljs-string"><span class="hljs-string">'), publicPath: '</span></span>/js/bundles/<span class="hljs-string"><span class="hljs-string">' } };</span></span></code> </pre><br>  So‚Ä¶ <br><br><h3>  Let's go directly to </h3><br>  Here it is worth describing a few more points.  In our standard directory structure of the application, among all these directives / controllers / modules we have created a new component (as well as models, helpers, etc ...), in which the components themselves will live.  The base file in this directory is the components.ts file, it imports our components from subdirectories.  We use this file as an entry-point for the webpack.  It looks something like this: <br><br>  <strong>./path/to/your/app/components/components.ts</strong> <br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> component-based modules with their own routes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Module1 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"components/module1/module1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Module2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"components/module2/module2"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ts helpers <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> services <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AnnotateHelper <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"services/AutoMarkupService"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ParserHelper <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"helpers/ParserHelper"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> organized <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> modules components <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AgentAvatarComponent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"components/agent/agent_avatar/agentAvatar.component"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> StaticInfoComponent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"components/shared/static_info/staticInfo.component"</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... let componentModule = angular.<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>(<span class="hljs-string"><span class="hljs-string">'api.components'</span></span>, [ Module1.name, Module2.name <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... ]); componentModule .component(AgentAvatarComponent.name, AgentAvatarComponent) .component(StaticInfoComponent.name, StaticInfoComponent) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... .factory(<span class="hljs-string"><span class="hljs-string">'ParserService'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ParserHelper) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> static helpers <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> .... .factory(<span class="hljs-string"><span class="hljs-string">'autoMarkupService'</span></span>, AutoMarkupService.getInstance); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> helpers that handles something inside <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> componentModule;</code> </pre><br>  It is necessary to add that there may be (and should be) more than one entry point, otherwise, as the project grows, everything will start awfully long to compile.  Above in the webpack config you can see how several entry-points are set.  Well, yes, they should not intersect over imports.  If there is something common (for example, models), then this common thing also needs to be allocated to a separate bundle and not to forget about <a href="https://github.com/webpack/docs/wiki/optimization">optimization</a> , common chunks and the ability to organize lazy loading of scripts. <br><br>  It is quite clear that the same ParserHelper from this example - just a class with static methods - can be imported into a ts-file directly, without using the Angulyarovsky DI (which is often nice), but here it is registered as a factory to ensure backward compatibility with the legacy part of the application. .  Those.  This is one of the services that have already been rewritten to ts.  But in AutoMarkupService we already want to store some state, or maybe we just need a standard Angulyarovsky DI there.  And therefore for its registration in an angulyar we use a simple pattern with getInstance: <br><br>  <strong>./path/to/your/app/services/AutoMarkupService.ts</strong> <br><pre> <code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> IHttpService = angular.IHttpService;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> IPromise = angular.IPromise;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> Model from "models/Model";</span></span> export <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoMarkupService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> instance: AutoMarkupService = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getInstance($http, legacyUrlConfig) { <span class="hljs-comment"><span class="hljs-comment">/*@ngInject*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!AutoMarkupService.instance) { AutoMarkupService.instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoMarkupService($http, legacyUrlConfig); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AutoMarkupService.instance; } constructor(<span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $http: IHttpService, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> legacyUrlConfig: {modelUrl: string}) { <span class="hljs-comment"><span class="hljs-comment">// do something } public doSomething(): IPromise&lt;Model&gt; { return this.$http.get(this.legacyUrlConfig.modelUrl); } }</span></span></code> </pre><br>  In an amicable way, all this needs to be redone to some kind of base class or immediately to a decorator. <br><br>  Now for the components themselves: <br><br>  First of all, we need a very small decorator, which will greatly facilitate our work: <br><br>  <strong>./path/to/your/app/helpers/decorators.ts</strong> <br><pre> <code class="hljs cmake">// .... <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> const Component = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(options: ng.IComponentOptions): <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (controller: <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span>) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> angular.extend(options, {controller}); }; }; // ....</code> </pre><br>  And now carefully look at what can be done with all that we have already built <br><br>  <strong>./path/to/your/app/components/shared/static_info/staticInfo.component.ts</strong> <br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"helpers/decorators"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./staticInfo.style.less'</span></span>); @Component({ <span class="hljs-attr"><span class="hljs-attr">bindings</span></span>: { <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"@"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">template</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./staicInfo.template.html'</span></span>), <span class="hljs-attr"><span class="hljs-attr">controllerAs</span></span>: <span class="hljs-string"><span class="hljs-string">'vm'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticInfoComponent</span></span></span><span class="hljs-class"> </span></span>{ public message: string; <span class="hljs-comment"><span class="hljs-comment">/** * here you can put any angular DI and it will work */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">// this.message -&gt; undefined } /** * function that will be called right after constructor(), * but in constructor() you will not have any bindings applied and here - will be */ $onInit() { // this.message -&gt; already binded and working. } }</span></span></code> </pre><br>  Notice that here through require we connect the template and style.  This require is for the webpack, after the build, instead of require, in this place there will be the actual css and html in text form.  Well, or (depending on the webpack settings) they will be somewhere in other files, but by the time this function is called, they will definitely be loaded. <br><br>  The same important point about $ onInit is that while you are in es2015 it is in fact not needed.  In es2015, there are no classes yet and all this has been transferred to the object and by the time the constructor is called, all the binding has already been transferred.  But you only need to change the preset to es2016 or even throw out Babel (for example, for ease of debugging), as everything stops working.  $ onInit is generally an Angular standard callback. <br><br><h3>  How to collect all this and make it work </h3><br>  After all the preparatory stages, it remains only in the root directory (where we have all of our package.json, tsconfig.json, webpack.config.js, etc.) run <br><br><pre> <code class="hljs">webpack</code> </pre> <br>  According to the results of the work, a .js file will be collected in the directory specified by the webpack config file, which should be included on your .html page along with all the others (or add special automation to your build, which will be collected and minimized on the same page as all others). <br><br>  Team <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">webpack</span></span> -w</code> </pre> <br>  It will launch the webpack in watcher mode and rebuild everything with every change to ts or related html and less. <br><br>  Team <br><br><pre> <code class="hljs pgsql">webpack-dev-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> -w</code> </pre> <br>  It will launch webpack-dev-server, which will give the usual statics (in our case, this is the ‚Äúlegacy‚Äù part of the application) from the addresses specified in the config, and the part for which the webpack is now responsible is kept in memory and recompiled very quickly. <br><br><h3>  Some more hints </h3><br><ol><li>  Starting a webpack build can be easily added to your main build process (for example, in some gulp build).  With us, it looks something like this: <br><br>  <strong>./gulp/tasks/scripts.js</strong> <br><pre> <code class="hljs lua">// .... // use webpack.<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.js to build modules gulp.task(<span class="hljs-string"><span class="hljs-string">'webpack'</span></span>, <span class="hljs-string"><span class="hljs-string">"executes build of ts/es6 part of application"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cb)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (shared.state.isSkipWebpack) { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Skipping webpack task during watch. Please use internal webpack watch'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(); } let <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../../webpack.config'</span></span>); webpack(<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, stats)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'webpack'</span></span>, err); } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'[webpack]'</span></span>, stats.toString({ chunks: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, errorDetails: <span class="hljs-literal"><span class="hljs-literal">true</span></span> })); cb(); }); }); // ....</code> </pre><br><br></li><li>  If it seems to you that the webpack is slow, it's time to optimize the build.  CommonChunks plugin, splitting a project into many different logical bundles, tuning cache settings, using dev-server in the end. <br><br></li><li>  Also, if your frontend is non-detachable from the backend and it seems that for this reason using webpack-dev-server is impossible, just know that one of the standard webpack-dev-server components is <a href="http-proxy">node-http-proxy</a> and correspondingly in a couple of movements. in the direction of changing the config, you can configure a proxy, which will redirect your requests to it ... for example, to your staging server.  Or somewhere else. <br><br></li><li>  Babel is a very powerful tool that is almost completely beyond the scope of this article.  It includes a huge number of plug-ins that you can use on your project. <br><br></li><li>  To facilitate the work of people who are not involved in the development of frontend, or to simplify containerization, or for something else, you can create simple helpers to run all the necessary applications.  This will not put them globally. <br><br>  <strong>./runners/typings</strong> <br><pre> <code class="hljs objectivec"> <span class="hljs-meta"><span class="hljs-meta">#!/bin/sh </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"node/node"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"node_modules/typings/dist/bin.js"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$@"</span></span></span></span></code> </pre><br>  <strong>./runners/webpack</strong> <br><pre> <code class="hljs objectivec"> <span class="hljs-meta"><span class="hljs-meta">#!/bin/sh </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"node/node"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"node_modules/webpack/bin/webpack.js"</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$@"</span></span></span></span></code> </pre><br><br>  etc.  (yes, by the way, our node is also put locally in our project directory, next to node_modules) <br><br>  And run the packages installed in node_modules, not globally.  This is very useful if you, for example, build a project with some kind of build system, you have some npm there and in order not to put the rest globally, in this build system you can call the necessary commands in this way: <br><br><pre> <code class="hljs sql">./runners/typings <span class="hljs-keyword"><span class="hljs-keyword">install</span></span></code> </pre> <br></li><li>  Write tests and documentation. <br><br></li><li>  Smoking will kill. </li></ol><br><h3>  the end </h3><br>  Here you go.  In general, the final (to date) construction looks something like this, these are probably the results of the month for some very inconsistent reading of various articles devoted to this topic, most of which are somewhat outdated (for example, how to get beaten from the reference path and relative import paths in they were not written) and dozens of different experiments (this is not the first or second iteration, all mostly in their free time - on which you have to cut features - and personal time, of course).  I hope someone this excursion will be useful.  I am also waiting for critics and suggestions for improving everything that I‚Äôve pondered here (after all, in fact, I‚Äôm not really a frontend developer and probably missed a lot).  Thank. </div><p>Source: <a href="https://habr.com/ru/post/304806/">https://habr.com/ru/post/304806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304790/index.html">Error in PM error message is ineffective</a></li>
<li><a href="../304794/index.html">First look at the new Cisco Firepower Threat Defense software (UPD 02.09.16)</a></li>
<li><a href="../304798/index.html">Everything you wanted to know about RAID controllers, but it was too lazy to look</a></li>
<li><a href="../304800/index.html">Bloom filter for web developers</a></li>
<li><a href="../304804/index.html">Comparison of online name resolution services</a></li>
<li><a href="../304810/index.html">Mobile VR-game on the Unreal Engine: pitfalls</a></li>
<li><a href="../304812/index.html">Oracle has stopped developing Java EE?</a></li>
<li><a href="../304814/index.html">Ansible: testing playbooks (part 2)</a></li>
<li><a href="../304816/index.html">How to learn programming languages</a></li>
<li><a href="../304818/index.html">Why do hackers really attack the exchanges and is the problem so big?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>