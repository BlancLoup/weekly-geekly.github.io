<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of the wave algorithm for finding the shortest path to dynamically moving objects in unity3d on C # in a 2d game</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to show how to implement the wave algorithm and my modification of it to work with dynamic objects in unity3d. 

 Application a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of the wave algorithm for finding the shortest path to dynamically moving objects in unity3d on C # in a 2d game</h1><div class="post__text post__text-html js-mediator-article">  In this article I want to show how to implement the wave algorithm and my modification of it to work with dynamic objects in unity3d. <br><br><h4>  Application area </h4><br>  This method is suitable for 2D games.  And its modification to find the path to moving objects.  The scope is very extensive and covers many game genres and situations, for example: <br><ol><li>  Games genre TD.  Where game locations are conveniently represented in the form of a cross-country matrix, for example, 0 is the area along which you can move, -1 is the area unavailable for movement, -2 is a trap, etc .; </li><li>  Strategy games, especially turn-based.  For example, fighting in the series of games ‚ÄúHeroes of Might and Magic‚Äù; </li><li>  Platformers; </li><li>  Checkers, chess, snake and others. </li></ol><br><h4>  Justification for writing an article </h4><br>  There are quite a lot of articles on working with algorithms for finding the shortest path on the Internet, but all the same they constantly create topics on the forums and ask questions ‚Äúhow to find the way to the object‚Äù.  I highlighted several reasons why this article has the right to exist: <br><ol><li>  For unity3d, there are many algorithms for finding the shortest paths in the form of assets, that is, ready-made solutions.  But sometimes it is worth not to take a ready-made solution, but write your own, optimal specifically for your case.  Especially if there are many objects in the game, then a poor implementation of the algorithm can greatly affect performance.  And the more performance will suffer if these objects are many and they change their location; </li><li>  The standard version of the wave algorithm is not the best option for dynamic objects, so I want to show its modification, which I developed while working on my strategic game; </li><li>  On the Internet, there are no good, simple, articles on the implementation of the wave algorithm in unity3d. </li></ol><br><a name="habracut"></a><br><h4>  Description of the wave algorithm </h4><br>  There is a starting position S and a point F, which you need to reach avoiding obstacles by the shortest route.  The wave algorithm is one of the fastest and most efficient, but running ahead will tell you why it is not ideal for finding a way to moving objects.  In case the object stands still, we can once find the path to it and start moving.  But if this object moves, then we need to recalculate the path to it every game tact, that is, every call to the Update () method. <br><br>  And if you have in the game involved hundreds or thousands of units?  And everyone counts the path, and even each call to the Update () method?  For example, a battle of 500 by 500, at 30 frames per second, will have to call the FindPath () method 1000 * 30 = 30,000 times per second. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To work we need a discrete working field, or just a map of the location presented in a matrix form. <br><pre> -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
 -1 0 0 0 0 0 0 0 -1
 -1 0 0 0 0 0 0 0 -1
 -1 0 0 0 0 0 0 0 -1
 -1 0 0 -1 -1 -1 -1 0 0 -1
 -1 0 0 0 0 0 0 0 -1
 -1 0 0 0 0 0 0 0 -1
 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
</pre><br>  Example of location map (or cross-country matrix): <br>  -1 - impassable area, wall or log. <br>  0 - passable area. <br><br><h4>  Algorithm </h4><br>  <i>Initialization</i> <br><br><pre><code class="cs hljs">   <span class="hljs-number"><span class="hljs-number">0</span></span> d := <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  <i>Wave propagation</i> <br><br><pre> <code class="cs hljs">    loc,   d         d + <span class="hljs-number"><span class="hljs-number">1</span></span>  d := d + <span class="hljs-number"><span class="hljs-number">1</span></span>  (   )  (   ,  &lt;  )</code> </pre><br>  <i>Recovery path</i> <br><br><pre> <code class="cs hljs">             ,    <span class="hljs-number"><span class="hljs-number">1</span></span>                  ‚Äî          </code> </pre><br><img src="https://habrastorage.org/files/4e7/a5b/8d3/4e7a5b8d32184b5bb0fded79556e53a5.png"><br><br><img src="https://habrastorage.org/files/2e5/252/198/2e5252198e344646b054327c7301ec56.png"><br><br><img src="https://habrastorage.org/files/1e1/6fa/ca0/1e16faca0b8d47e79d8f761be2f8941f.png"><br><br><img src="https://habrastorage.org/files/1ef/53d/91d/1ef53d91dbbc4769a77f98c3f3bfeed7.png"><br><br><img src="https://habrastorage.org/files/724/868/ad2/724868ad28424a1483a812e149f6c7bb.png"><br><br><h4>  Algorithm implementation in unity3d </h4><br><br>  The demonstration will be held on the example of a prototype of my strategic game.  There is a player‚Äôs side and an opponent‚Äôs side, the task of the warriors is to find the nearest enemy, reach it bypassing other warriors and obstacles and start the battle. <br><br><ol><li>  For debugging it will be convenient to divide the playing field into cells and display them.  For convenience, at this step you can make the coordinates of the first cell equal to (0,0), adjacent to the right (0.1), and so on. <br><img src="https://habrastorage.org/files/de0/121/c61/de0121c61bff413ebb80370f66440e65.png"></li><li>  Now create a class Battlefield.cs and attach it to the object "field" using the inspector. <br><div class="spoiler">  <b class="spoiler_title">Battlefield.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Battlefield2</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] battlefield; <span class="hljs-comment"><span class="hljs-comment">//   public int enemyNumber = 6, playerNumber = 3; //public      public static int x, y; //     public GameObject enemyMilitiaman; //   public GameObject swordsmanGO; // . public static bool ready = false; //     ,      . void Start () { battlefield = new int[,]{ //   . 1 - . 0 -   {1,1,1,1,1,1,1,1,1,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,0,0,0,0,0,0,0,0,1}, {1,1,1,1,1,1,1,1,1,1}}; setEnemyPosition (enemyNumber); //     setPlayerPosition (playerNumber); //    ready = true; //     } // Update is called once per frame void Update () { } void setEnemyPosition(int numberEnemies){ ////// //////     ,      1   (14,2) ///// //    GameObject go = Instantiate(enemyMilitiaman, new Vector3(14, 2, 10), Quaternion.identity) as GameObject; battlefield[14, 2] = 1; //     ,  ,    , . } void setPlayerPosition(int numberPlayerWarior){ ////// //////     ,      1   (2,6) ///// GameObject go = Instantiate(swordsmanGO, new Vector3(2, 6, 10), Quaternion.identity) as GameObject; battlefield[2, 6] = 1; } public static void printMatrix(){ string arr = ""; for (int i = 0; i &lt; x; i++) { for (int j = 0; j &lt; y; j++) { arr += battlefield[i,j] + ","; } arr += "\n"; } print (arr); } }</span></span></code> </pre><br></div></div><br>  The code is commented out and should not cause you any difficulties. <br><br>  In the Battlefield class, we create a location map (matrix) describing our location.  Dale call the methods that place the player and the enemy units on the playing field. In the same methods, write to the cell of the matrix on which the unit was placed, that it is already occupied and make it impassable by changing the value from 0 to 1. That is why it was important to make cell coordinates in the playing field integers and start counting from (0,0).  Then when creating an object, its coordinates will coincide with the coordinates of the cell in the matrix. <br></li><li>  Now create the swordsman class Swordsman.cs and hang it on the swordsman‚Äôs prefab <br><div class="spoiler">  <b class="spoiler_title">Swordsman.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Swordsman2</span></span> : <span class="hljs-title"><span class="hljs-title">Warrior</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 currentPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 lastPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ready = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> readyAttack = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> endBattle = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject closestEnemy; <span class="hljs-comment"><span class="hljs-comment">//  GameObject[] gos; //    private float waitMove; //      void Start () { currentPosition = transform.localPosition; //    lastPosition = currentPosition; //    . //        waitMove = UnityEngine.Random.Range (0.4f, 0.65f); } void Update () { //        if (Battlefield.ready) { if(ready){ //  ,     Enemy gos = GameObject.FindGameObjectsWithTag("Enemy"); if(gos.Length == 0){ endBattle = true; //   ,    print ("End Battle"); } //—ñ  —ñ,  —ñ if(!endBattle){ //      GameObject goClosestEnemy = findClosestEnemy(); int targetX, targetY; targetX = (int)goClosestEnemy.transform.localPosition.x; targetY = (int)goClosestEnemy.transform.localPosition.y; int[,] cMap = findWave(targetX, targetY); //      if(!stopMove(targetX, targetY)) // ,       //       StartCoroutine(move(cMap, targetX, targetY)); if(readyAttack){//,     if(stopMove(targetX, targetY)){ StartCoroutine(attack()); } } } //          currentPosition = transform.localPosition; //,     Battlefield.battlefield[(int)currentPosition.x, (int)currentPosition.y] = 1; //  ,     ,    if (currentPosition != lastPosition) { Battlefield.battlefield[(int)lastPosition.x, (int)lastPosition.y] = 0; lastPosition = currentPosition; //      } } } } private IEnumerator attack(){ readyAttack = false; //  ,    1   0.8  yield return new WaitForSeconds(0.8f); //////// ////////    //////// readyAttack = true; } /// &lt;summary&gt;   /// &lt;/summary&gt; /// &lt;param name="cMap"&gt;  &lt;/param&gt; /// &lt;param name="targetX"&gt;  x&lt;/param&gt; /// &lt;param name="targetY"&gt;  y&lt;/param&gt; private IEnumerator move(int[,] cMap, int targetX, int targetY){ ready = false; int[] neighbors = new int[8]; //    //           Vector3 moveTO = new Vector3(-1,0,10); //   ,      for neighbors[0] = cMap[(int)currentPosition.x+1, (int)currentPosition.y+1]; neighbors[1] = cMap[(int)currentPosition.x, (int)currentPosition.y+1]; neighbors[2] = cMap[(int)currentPosition.x-1, (int)currentPosition.y+1]; neighbors[3] = cMap[(int)currentPosition.x-1, (int)currentPosition.y]; neighbors[4] = cMap[(int)currentPosition.x-1,(int) currentPosition.y-1]; neighbors[5] = cMap[(int)currentPosition.x, (int)currentPosition.y-1]; neighbors[6] = cMap[(int)currentPosition.x+1,(int) currentPosition.y-1]; neighbors[7] = cMap[(int)currentPosition.x+1,(int) currentPosition.y]; for(int i = 0; i &lt; 8; i++){ if(neighbors[i] == -2) //    ,  ,        //     ,         //     neighbors[i] = 99999; } Array.Sort(neighbors); //         //     . for (int x = (int)currentPosition.x-1; x &lt;= (int)currentPosition.x+1; x++) { for (int y = (int)currentPosition.y+1; y &gt;= (int)currentPosition.y-1; y--) { if(cMap[x,y] == neighbors[0]){ //     ,      moveTO = new Vector3(x,y,10); } } } //      ,      . //  ,   ,   8 ,     if(moveTO == new Vector3(-1,0,10)) moveTO = new Vector3(currentPosition.x, currentPosition.y, 10); // , -     //    1     transform.localPosition = moveTO; // . yield return new WaitForSeconds(waitMove); ready = true; } //    //TargetX, TargetY -    public int[,] findWave(int targetX, int targetY){ bool add = true; //     //    ,     int[,] cMap = new int[Battlefield.X, Battlefield.Y]; int x, y, step = 0; //    0 for (x = 0; x &lt; Battlefield.x; x++) { for (y = 0; y &lt; Battlefield.y; y++) { if(Battlefield.battlefield[x,y] == 1) cMap[x,y] = -2; //   1,    ( -2) else cMap[x,y] = -1; //     } } //   ,      cMap[targetX,targetY] = 0; while (add == true) { add = false; for (x = 0; x &lt; Battlefield.x; x++) { for (y = 0; y &lt; Battlefield.y; y++) { if(cMap[x,y] == step){ //     ,       //      + 1 if(y - 1 &gt;= 0 &amp;&amp; cMap[x, y - 1] != -2 &amp;&amp; cMap[x, y - 1] == -1) cMap[x, y - 1] = step + 1; if(x - 1 &gt;= 0 &amp;&amp; cMap[x - 1, y] != -2 &amp;&amp; cMap[x - 1, y] == -1) cMap[x - 1, y] = step + 1; if(y + 1 &gt;= 0 &amp;&amp; cMap[x, y + 1] != -2 &amp;&amp; cMap[x, y + 1] == -1) cMap[x, y + 1] = step + 1; if(x + 1 &gt;= 0 &amp;&amp; cMap[x + 1, y] != -2 &amp;&amp; cMap[x + 1, y] == -1) cMap[x + 1, y] = step + 1; } } } step++; add = true; if(cMap[(int)transform.localPosition.x, (int)transform.localPosition.y] &gt; 0) //  add = false; if(step &gt; Battlefield.X * Battlefield.Y) //  ,      add = false; } return cMap; //   ,      move() } //      ,   public bool stopMove(int targetX, int targetY){ bool move = false; for (int x = (int)currentPosition.x-1; x &lt;= (int)currentPosition.x+1; x++) { for (int y = (int)currentPosition.y+1; y &gt;= (int)currentPosition.y-1; y--) { if(x == targetX &amp;&amp; y == targetY){ move = true; } } } return move; } //    GameObject findClosestEnemy() { float distance = Mathf.Infinity; Vector3 position = transform.position; foreach (GameObject go in gos) { float curDistance = Vector3.Distance(go.transform.position,position); if (curDistance &lt; distance) { closestEnemy = go; distance = curDistance; } } return closestEnemy; } }</span></span></code> </pre><br></div></div><br>  Each step is described in detail in the comments to the code. <br><br>  In the Update () method we check if there is an enemy, then we are looking for the nearest one.  Next, call the findPath () method, which searches for the path.  Behind it we call the method move (), which moves an object 1 cell towards the enemy, if the object has not yet reached the target.  If the object has already reached the target, then we call the attack () method. <br></li></ol><br><br><h4>  Modification of the wave algorithm for dynamic objects </h4><br>  As I wrote earlier, the findPath () method has to be called for each unit in the Update () method.  Because the enemies move in the same way as the player‚Äôs units.  And after 1 game tact, the enemy can change position, and the old path will not be relevant. <br><br>  The following situation turns out, we found a way to the enemy.  moved into a cage with a minimum weight.  The enemy changed his location, we again calculated the way to him, again moved into the cage with a minimum of weights. <br><br>  In this case, we use only those cells that are adjacent to our unit, and we do not need the rest of the way.  Then we do not need to calculate all the way to the enemy.  And you just need to find out on which neighboring cell to move the unit, so that it is closest to the enemy. <br><br>  The object we need to reach is called F. And the object that is looking for a path to F is called S. In unity3d it is very easy to calculate the distance from S to F. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> curDistance = Vector3.Distance(F.transform.position, S.transform.position);</code> </pre><br>  Now we just need to go through the adjacent cells.  Calculate the distance from each neighboring cell to the object F and move into the cell with the minimum distance. <br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[] neighbors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; Vector3 goTo; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)currentPosition.x<span class="hljs-number"><span class="hljs-number">-1</span></span>; x &lt;= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)currentPosition.x+<span class="hljs-number"><span class="hljs-number">1</span></span>; x++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)currentPosition.y+<span class="hljs-number"><span class="hljs-number">1</span></span>; y &gt;= (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)currentPosition.y<span class="hljs-number"><span class="hljs-number">-1</span></span>; y--) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> curDistance = Vector3.Distance(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(x,y,<span class="hljs-number"><span class="hljs-number">0</span></span>), S.transform.position); neighbors[n] = curDistance; } }</code> </pre><br>  Find the minimum value and cell index in the neighbors array.  Further, by the cell index, we determine the coordinates of the cell where the object S is to be moved. Repeat until we reach the goal F. <br><br><h5>  Demonstration </h5><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/40E8R-i4j30%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700190,15700248,15700253&amp;usg=ALkJrhj1Gc24MAzAjMeURjT053jUPkK6ng" frameborder="0" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/264189/">https://habr.com/ru/post/264189/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../264173/index.html">Globals are Cossack swords for data storage. Trees Part 2</a></li>
<li><a href="../264175/index.html">Real-time stateful React components update for Browserify</a></li>
<li><a href="../264179/index.html">Writing a bot for Tox messenger</a></li>
<li><a href="../264181/index.html">RPC, Messaging, REST: Terminology</a></li>
<li><a href="../264185/index.html">Modern Adaptec RAID controllers from A to Z. Part 2</a></li>
<li><a href="../264191/index.html">Interpolation of data: we connect points so that it was beautiful</a></li>
<li><a href="../264193/index.html">How to find out the year of release of the song on the set of audio characteristics?</a></li>
<li><a href="../264195/index.html">Hybrid Conf - the first conference on programmatic-advertising in Russia</a></li>
<li><a href="../264197/index.html">HDD sled - cost effective grain</a></li>
<li><a href="../264199/index.html">Triggers and Background Jobs in Windows Store Applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>