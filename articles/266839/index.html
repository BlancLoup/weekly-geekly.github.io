<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Working with lighting in Unity - theory and practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In video games, beautiful real-time lighting beats heavily in performance, which is especially noticeable on mobile devices. Thus, developers are forc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Working with lighting in Unity - theory and practice</h1><div class="post__text post__text-html js-mediator-article">  In video games, beautiful real-time lighting beats heavily in performance, which is especially noticeable on mobile devices.  Thus, developers are forced to look for workarounds for this problem.  <b>Lightmapping</b> is a technology that preserves information about lighting in texture, which allows you to free up computing resources for other needs. <br>  In this article I will introduce the reader to the theory of lighting in games, describe the process of creating a ‚Äúlightmap‚Äù in Unity 5, and share some tips. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/353/acc/7be/353acc7bef934ee79d47c213c823949b.png" alt="image"></div><a name="habracut"></a><br>  Over the past couple of years I have had a lot of work with ‚Äúlightmapping‚Äù both at work and on my own indie project.  When your team has few production resources and you cannot allocate a lot of time to creating unique graphics for gaming locations, the lighting becomes one of the key factors helping to revive and diversify the picture. <br><br><h1>  Lighting theory </h1><br><h3>  <font color="#9cc2ce">Reflected light</font> </h3><br>  Let's define the terminology.  Illumination in computer graphics is divided, relatively speaking, into two categories: <br><br><ul><li>  <b>Direct Illumination.</b>  Direct hit of light rays on the surface. </li><li>  <b>Indirect Illumination.</b>  Rays are reflected from the surface, scattered and form a soft fill light. </li></ul><br>  There are many methods for calculating reflected illumination, the two most famous are Global Illumination (GI) and Final Gather (FG).  They can be used separately, but together they give a particularly good result.  However, you have to pay for everything: the render, that is, the process of calculating complex lighting and its subsequent visualization, will take a lot of time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Global Illumination</b> (GI) is the most ‚Äúhonest" way to simulate reflected light.  From the light source photons fly out - particles that carry information about the color and brightness of the light.  Hitting a surface, they illuminate it, but lose some of the energy, as a result of which their color and brightness change.  Then the photons bounce off and hit the next surface, re-losing some of the energy.  This happens several times depending on the settings of the renderer. <br><br>  <b>Final Gather</b> (FG) scatter points around the stage, - final gather points - from which rays travel in different directions.  After a collision with a surface, the rays return to the parent point information about the color and its brightness.  Imagine such a picture: the evening, the sun has almost gone beyond the horizon;  it becomes dark, but a small part of the room is still flooded with orange sunset light.  The final gather point located on the floor sends several rays in different directions, some of them reach the illuminated part of the room and return to the starting point with this information, thereby slightly illuminating the floor with ‚Äúreflected‚Äù orange light.  This is not such an ‚Äúhonest‚Äù way as GI, but it produces a good result and is often used to fill the scenes with beautiful soft lighting. <br><br>  For the next picture, I unscrewed the parameters of the reflected light to insane values, so you can clearly see how the light particles bounce off objects. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/08e/1e5/6a6/08e1e56a696144ac99dc0f0ecf205339.png" alt="image"></div><br><h3>  <font color="#9cc2ce">Ambient occlusion</font> </h3><br>  In addition to reflected light, we are interested in the so-called <b>Ambient Occlusion</b> (AO).  This is the effect of shading in the corners, cracks, narrow openings.  Imagine that a beam of light flies into a corner of a room; it is reflected several times from both walls, gradually fading out.  The farther into the corner, the less light goes there. <br><br>  As a rule, Ambient Occlusion is used to artistically emphasize the shading effect - in reality, the rays of light do not lose energy so quickly that the darkness in the corners of the room is as dark as we are shown in games.  If you render physically correct lighting, your engine itself calculates the rate of energy loss by a beam of light, and you do not need to render the Ambient Occlusion map (texture) separately.  But you can do this if you need to implement the artistic intent. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/b4c/12c/d37/b4c12cd3782e48feb567318e27036262.png" alt="image"></div><br>  By the way, it was necessary: ‚Äã‚Äãsome digital 2d-artists love to imitate this effect while drawing, and in general the process of their work is very similar to how they create 3d-graphics. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/748/66f/959/74866f9597eb497eaf41ab221a123a25.png" alt="image"></div><br><h3>  <font color="#9cc2ce">Texture Atlases</font> </h3><br>  The next term you should know is a <b>texture atlas</b> .  Roughly speaking, this is one large texture, which contains several small textures.  Most often, texture atlases are created to save computational resources.  Let me give you an extremely simplified example - specialists, hide torches and pitchforks!  Let you have a tavern in the game, in which there are 20 wooden objects (tables, chairs, spoons ...), each has its own texture.  As a result, the CPU will turn to the GPU 20 times, demanding to render each object separately.  If we assign all wooden objects one material that refers to one texture atlas, in which all 20 textures are sewn, then the GPU can render 20 objects in one call (also draw call, I will provide interesting links on this topic at the end of the article). <br><br>  In the case of ‚Äúlightmapping,‚Äù an additional small texture is created for each object, in which the lighting information is baked.  Then many, many small textures of different objects are placed in large textural atlases.  As in the case of wooden furniture, we also get a performance boost. <br><br><h1>  Work with Unity </h1><br><h3>  <font color="#9cc2ce">general information</font> </h3><br>  But back to the lightmap in Unity itself.  First of all, be patient and, if possible, a powerful computer.  The rendering process has the ability to completely occupy the processor and RAM, so I turn it on before I go to work or go to sleep.  Thus, I return to the computer just at the moment when the render is complete. <br>  Looking ahead, I‚Äôll warn you that Unity is caching intermediate lighting calculation results.  If you see that you have lost 10 gigabytes of space on the system disk, this is it.  To configure the cache, go to: <i>Edit - Preferences - GI Cache</i> .  Here you can specify where it is saved and its maximum size.  You can remove the compression, ‚Äúweigh‚Äù will be more, but work more quickly.  Here you can clear the cache, but keep in mind that if you have a scene with a ready-made ‚Äúlightmap‚Äù, it will also be deleted, be careful. <br><br>  5 types of light sources are available in Unity: <br><br><ul><li>  <b>Directional Light</b> .  The easiest, imitates sunlight.  It is an infinite set of rays parallel to each other. </li><li>  <b>Point Light</b> .  Point source of light, that is, the rays diverge in all directions from one point.  A good example of such a light source would be an ordinary light bulb. </li><li> <b>Area Light</b> .  Light source having an area.  Imagine a rectangular panel from which the light emanates, and this will be the area light.  Such light sources are most often used in offices, shopping centers and other non-residential premises where it is necessary to light large spaces. </li><li>  <b>Ambient Light</b> .  Fill light without source.  Examples of use: light too dark shadows;  add atmospheric dungeon, filling it with barely visible light of bioluminescent plants. </li><li>  <b>Light Probes</b> .  A special light source that affects only dynamic objects.  Technically, this is not a source of light, but for simplicity, let's call it that. </li></ul><br>  In Unity, all objects are divided into <b>dynamic</b> (dynamic) and <b>static</b> (static).  Static objects are those that are always standing still and not moving anywhere.  It is for them that the ‚Äúbaking‚Äù of the lighting takes place.  Dynamic objects are those that are on the contrary in motion.  This includes such elements of the scene as a hero, a monster, a waving flag, a stone falling from a cliff.  ‚ÄúLightmapping‚Äù is not suitable for these objects, they are illuminated either by real-time light sources or by means of light probes, which I will discuss in addition at the end of the article. <br><br><h3>  <font color="#9cc2ce">Parameters of light sources</font> </h3><br>  I want to pay attention to how much the key settings of the light sources (the available settings differ depending on the type of light source): <br><br><ul><li>  <b>Baking</b> .  Allows you to select the light source processing method.  For ‚Äúlightmapping,‚Äù we put Baked. </li><li>  <b>Color</b> .  Actually, the color of the light source. </li><li>  <b>Radius</b> .  Parameter Point Light'a, responsible for how far the rays of light fly. </li><li>  <b>Intensity</b> .  Just the brightness of the light source. </li><li>  <b>Bounce Intensity</b> .  Determines the brightness of the reflected rays emitted from the current light source. </li><li>  <b>Shadow Type</b> .  Defines the display of shadows.  I advise you to use Soft Shadows, it gives beautiful shadows at the cost of increased render time. </li><li>  <b>Baked Shadow Angle</b> .  Only available for Soft Shadows.  Imagine a long shadow.  The further it goes from the object, discarding it, the more blurred it becomes.  If the parameter is set to ‚Äú0‚Äù, then the shadow will practically not be blurred.  If set to more than ‚Äú0‚Äù, a blur will appear. </li></ul><div style="text-align:center;"><img src="https://habrastorage.org/files/60d/839/b8b/60d839b8b01c4e9ab1f96179d7e4b214.png" alt="image"></div><br><h3>  <font color="#9cc2ce">Setting scene lighting</font> </h3><br>  The scene lighting settings window is called via <i>Window - Lighting</i> , and consists of three tabs: <b>Object</b> , <b>Scene</b> , <b>Lightmaps</b> .  To start the lighting render, use the Build button at the very bottom of the window.  There is also a tick Auto, which automatically starts the render every time you make changes to the scene;  use it if you have a powerful computer.  More below is information about the number and size of ‚Äúlightmaps‚Äù, will appear upon completion of the ‚Äúlightmapping‚Äù process. <br><br><h3>  <font color="#9cc2ce">Section - Object</font> </h3><br>  <b>Object</b> displays the settings for a specific object.  If you select an element of the environment in your scene, here you will see a number of settings and parameters.  Provided that the object is static, there will be a tick on the Lightmap Static checkbox.  Most often you will use the Scale in Lightmap field here.  As I said earlier, for each object the light is ‚Äúbaked‚Äù into a separate small texture, which is then placed in a large lightmap atlas.  With the Scale in Lightmap parameter you can adjust how much space this texture will occupy.  Of course, the less space is allocated to it, the worse will be the quality of the light ‚Äúbaked‚Äù in it.  By default it is ‚Äú1‚Äù, but if you know that the object will rarely come into view or it is located far in the background, you can safely reduce this parameter to 0.1 or even less. <br><br><h3>  <font color="#9cc2ce">Section - Scene</font> </h3><br>  In <b>Scene</b> are the key settings for rendering lighting.  I tell the basics of working with light, and also share the experience of ‚Äúlightmapping‚Äù specifically for mobile platforms, so I deliberately skip things like realtime GI or use HDR texture as a light source. <br><br>  In Ambient Source, you set up the Ambient Light fill source that I mentioned.  You are invited to choose between a sky-texture, a sky of a single color, as well as a sky created on the basis of a color gradient.  I prefer to choose Gradient.  It allows you to set up three colors - the dome of the sky, the equator and the earth, which will create a rather complicated and interesting fill light for your scene.  Ambient Intensity indicates the brightness of this light.  Depending on the artistic intent, you can even have a very bright scene lit by one Ambient Light. <br><br>  The Baked GI tab contains the basic lighting quality settings, both direct and reflected, including GI and FG. <br>  Before we delve into these settings, I want to give one piece of advice.  Always keep in mind that by placing light sources on the scene, adjusting shadows and Ambient Light, after rendering the lightmap you will get a completely different picture, only remotely resembling what you did.  Therefore, I recommend working with iterations: you expose the minimum quality of lighting to render quickly, look at the result of the render, and then make edits and run the re-render.  When you are more or less satisfied with the result, you can improve the quality of the render and enable Final Gather.  This will take a long time, so it makes sense to turn on such a render before you leave the computer for a relatively long period of time. <br><br>  The settings in the Baked GI tab are operated by a unit like texel.  Simply put, texel is a pixel, but not on the screen, but in the texture space of a three-dimensional model.  But don‚Äôt bother with your head - it‚Äôs hard to say how Unity operates with texels and how they depend on the scale of the objects, so just move in an experimental way.  For example, for my mobile RPG, I make the final ranner with Baked Resolution set to 25. <br><br><div class="spoiler">  <b class="spoiler_title">Texel on Wikipedia</b> <div class="spoiler_text">  <b>Texel</b> (short for English <b>Tex</b> ture <b>el</b> ement) is the minimum unit of texture of a three-dimensional object.  Pixel texture. <br>  The easiest way to explain the meaning of the term "texel" on the example of three-dimensional games.  If you come close to the wall in some old 3D-game - (Wolfenstein or Duke Nukem), you can see how the texture of the wall splits into monochromatic squares, which increase when you approach and gather back into a meaningful drawing at a distance.  These squares are called texels, and the larger the original texture pattern, the less texels become.  For a perfect display of the texture, the number of texels should coincide with the number of pixels on the monitor, but almost all the engines allow the viewer to get closer to the wall than the detail allows. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B5%25D0%25BB_(%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0)">A source.</a> </div></div><br>  Below I will talk about each parameter separately, but before that you need to know something else.  If you run the render lighting in Unity, then the bottom right will say what the engine is currently busy with.  At the very end of the rendering process, Compositing will be written there. <br><br>  The fact is that ‚Äúlightmap‚Äù is generated in layers.  During rendering, several separate textures are created.  I don't know which cards Unity does, but among them there is either all or part of the list: Diffuse (direct light), GI (Global Illumination), FG (Final Gather), AO (Ambient Occlusion) and others.  After that, the engine takes these cards and merges with each other.  For example, it can be based on a Diffuse layer, an FG layer is put above it in Lighten blending mode (just like in Photoshop), and an AO layer is put higher in Multiply mode ... As a result, these layers merge into one picture and the final ‚Äú lightmap ‚Äù. <br><br><h3>  <font color="#9cc2ce">Tab - Baked GI</font> </h3><br><ul><li>  <b>Baked Resolution</b> .  This parameter can be considered the overall quality of the lightmap, which is also Diffuse, as I mentioned in the last paragraph.  The higher you put it, the clearer the picture will be.  But do not get carried away, there is a certain limit, after which you will not notice any difference.  In general, it is important to find a balance between the quality of the ‚Äúbaking‚Äù and the render time. </li><li>  <b>Baked Padding</b> .  The distance between the individual textures on the general atlas.  It is necessary so that during compression, when the atlas begins to ‚Äúfloat‚Äù, the color of one separate texture does not slap another texture.  For my game, I usually put in the range of 1-3. </li><li>  <b>Compressed</b> .  Almost always you will be ticked here, while Unity will compress the lightmap-atlas.  In the uncompressed state, they ‚Äúweigh‚Äù indecently a lot. </li><li>  <b>Indirect Resolution</b> .  This parameter can be considered the quality, or detail, of the GI, FG, and possibly AO layers.  It makes no sense to put a large number here, you will not see the difference.  For example, if you put 40 in Baked Resolution, then you can safely put in Indirect around 3-8. </li><li>  <b>Ambient Occlusion</b> .  As I wrote at the very beginning of the article, AO is shading in all sorts of corners and cracks due to the loss of energy by the light beam.  This parameter adjusts how quickly energy is lost.  The higher the parameter, the darker the AO will be.  Let me remind you that AO is an artistic device that actually has nothing in common with physically correct lighting. </li><li>  <b>Max Distance</b> .  By and large, this is just a blackout distance for Ambient Occlusion.  If we take the corner of a room as an example, then at high Max Distance, the darkening will start very early, and at low Max Distance, the darkening will only be at the very depth of the corner. </li><li>  <b>Final Gather</b> .  Includes the reflected light method described at the beginning of the article.  By default, only GI is rendered, and here you turn on FG.  Nowhere are there any settings for the number of points that FG spreads around the scene.  I suppose that this somehow depends on Indirect Resolution. </li><li>  <b>Ray Count</b> .  The number of rays that each FG point emits.  Most likely, 32 or 64 beams will be enough for your eyes. </li></ul><br><h3>  <font color="#9cc2ce">Tab - General GI</font> </h3><br>  Let's go through the settings of interest in the General GI tab: <br><br><ul><li>  <b>Directional Mode</b> .  A very specific parameter ‚Äúbaking‚Äù for each ‚Äúlightmap‚Äù is the second atlas.  A regular lightmap is a simple texture, which is then superimposed on top of your objects, simulating their lightness.  The second atlas, called Directional, contains information about the direction of the rays of light.  It makes sense to include this mode only if you use normal maps and are not working on a mobile game.  Otherwise, it is recommended to take Non Directional. </li><li>  <b>Indirect Intensity</b> .  It can be said that this is the brightness of the layers with indirect light, in particular FG.  Earlier, I already told you that a ‚Äúlightmap‚Äù is actually assembled from layers superimposed on top of one another. </li><li>  <b>Bounce Boost</b> .  Adjusts the brightness of the reflected photons, information about which is contained in the layer with GI. </li><li>  <b>Atlas Size</b> .  The size of texture atlases with ‚Äúbaked‚Äù lighting is indicated here.  If you are making a game for mobile devices straight from the 19th century, it makes sense to put 1024 here, since textures of 2048 are not supported by very old devices.  Otherwise, I recommend to put 2048, it is supported by almost all devices of recent years.  As you understand, the smaller the size of a single atlas, the more they will have to do.  If you are familiar with the term Draw Call, then you can easily predict that increasing the number of atlases will hit performance.  Therefore, if you do not have specific requirements, try to render in 2048. </li></ul><br><h3>  <font color="#9cc2ce">Tab - Fog</font> </h3><br>  And finally, fog!  Fog, I mean.  It has no relation to the lighting renderer, it can be turned on and off at any time.  It's all very simple, so take and experiment.  Let me just say that fog is an extremely powerful artistic tool.  You can radically change the atmosphere of the scene through the fog, thanks to him the sunny scene will become brighter, darker - darker. <br><br>  In addition, fog can be used as a productivity tool.  For example, you want to turn off all textures in the distance and hide them behind the fog.  In older versions of World of Warcraft, if you played, you couldn't help but notice how thick the fog was there. <br><br><h3>  <font color="#9cc2ce">Section - Lightmaps</font> </h3><br>  The third section is the <b>Lightmaps</b> , where the rendered lightmaps will be located.  And if there are many atlases, in the upper part of the tab you will not be able to see all the atlases, the scroll in that window is inactive.  Therefore, we look at the bottom and scroll with the mouse wheel. <br><br>  Here it is important for us to see how full the last, lowest ‚Äúlightmap‚Äù atlas is.  If it is almost empty, then either we increase the quality of the lightmap in order to fill the entire atlas, or we decrease it so that the atlas is empty and removed.  The picture below shows two well-filled atlas, and one - so far as. <br><br>  ‚ÄúLightmaps‚Äù are stored in EXR files with a depth of 32 bits. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/085/8f7/221/0858f72211fb40cf872b007c33b34896.png" alt="image"></div><br><h3>  <font color="#9cc2ce">Light probes</font> </h3><br>  I also promised to tell you about <b>Light Probes</b> .  They are small areas that absorb information about the lighting of the surrounding space.  When there are many such spheres, they create a kind of irradiance map of your level or location.  They are then used to illuminate dynamic objects in which the light is not ‚Äúbaked‚Äù. <br><br>  To better understand their meaning, I will give an example.  There is one Point Light on your stage that has Baked settings, that is, it is used to ‚Äúbake‚Äù the light.  You do not do it Real-time, because it is expensive in terms of performance, and many mobile devices do not support such a light source at all.  Then you ‚Äúlightmap‚Äù the scene and see that your Point Light illuminates the surroundings.  But if you take a monster and place it near a light source, it will remain dark, because it belongs to the class of dynamic objects, and your Point Light only affects static ones. <br><br>  Now you place a grid from Light Probes around the light source, bake the lights again.  And now your monster can walk around Point Light and be illuminated by it!  This is an extremely effective and inexpensive way to simulate lighting.  To add ‚Äúsamples‚Äù to the scene, go to the <i>Game Object - Light - Light Probe Group</i> .  A cube of four spheres will appear on the scene.  To select individual spheres, use ctrl + click.  Several buttons will appear in the Inspector to add or remove spheres.  You can also use the ctrl + D combination to duplicate spheres. <br><br>  Arrange Light Probes carefully, place them where you want them to absorb the lighting information, and then transfer it to dynamic objects.  In order to avoid graphic artifacts and flickering light, make sure that Light Probes form a smooth, beautiful grid. <br><br>  Below is a screenshot of the correctly displayed grid.  If you look closely, you will notice that Light Probes are not displayed in a random order, but are surrounded by sources of light, trying to effectively catch the transition from light to shadow and back. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/804/6af/3a6/8046af3a659846358923990d0eb6d03d.png" alt="image"></div><br><h3>  <font color="#9cc2ce">Conclusion</font> </h3><br>  Finally I want to give advice on creating models of the environment under the ‚Äúlightmapping‚Äù.  Creating content for the game, I knew from which side the game camera would look, so for the sake of questionable optimization I deleted the back walls of some objects.  At that time, I had the experience of rendering lightmaps, but only in Maya, not in Unity.  It turned out that when rendering lighting in Unity, near objects that have holes, that is, distant polygons, hard, well-marked artifacts appear.  Keep in mind. <br><br><h3>  <font color="#9cc2ce">Useful and interesting links</font> </h3><br><ul><li>  <a href="https://www.marmoset.co/toolbag/learn/pbr-theory">An explanation</a> of a physically correct lighting and render system written for 3d artists. </li><li>  If you want to learn more about draw calls and graphics optimization, then there is a great material for non-programmers - <a href="http://simonschreibt.de/gat/renderhell/">render hell 2.0</a> . </li><li>  On the Unity website there is a good <a href="http://unity3d.com/ru/learn/tutorials/modules/beginner/graphics/lighting-and-rendering">description of</a> their lighting system, sometimes echoing my material. </li><li>  In this small <a href="http://poke-a-pixel.com/2015/02/diablo-3-lighting/">note,</a> using the example of Diablo III, it demonstrates how the developer of AAA games uses the same trick - it significantly changes the atmosphere of the levels with one light without changing the environment graphics. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/266839/">https://habr.com/ru/post/266839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266829/index.html">Paradigm of situationally oriented programming</a></li>
<li><a href="../266831/index.html">PE (Portable Executable): On Stranger Tides</a></li>
<li><a href="../266833/index.html">15 year old code and newspaper ad</a></li>
<li><a href="../266835/index.html">Inventing servers - Open Compute Project</a></li>
<li><a href="../266837/index.html">Testing on Android: Robolectric + Jenkins + Ja–°o–°o</a></li>
<li><a href="../266843/index.html">Preparing Nexus Player (FUGU) for working with SoCWatch</a></li>
<li><a href="../266845/index.html">Armory 1.2: Workspaces and switching between projects</a></li>
<li><a href="../266847/index.html">Mikrotik: small utility. Part 1</a></li>
<li><a href="../266849/index.html">Book about viruses</a></li>
<li><a href="../266851/index.html">Start loving go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>