<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing PHP programs using fork ()</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PHP Parallel Programs 
 Previously, the title of the topic was ‚ÄúWriting multi-threaded programs in PHP‚Äù . In PHP, there is exactly one ‚Äúnormal‚Äù way to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing PHP programs using fork ()</h1><div class="post__text post__text-html js-mediator-article"><h4>  PHP Parallel Programs </h4><br>  <i>Previously, the title of the topic was ‚ÄúWriting multi-threaded programs in PHP‚Äù</i> .  In PHP, there is exactly one ‚Äúnormal‚Äù way to write applications that use multiple cores / processors ‚Äî this is <a href="http://www.opennet.ru/man.shtml%3Ftopic%3Dfork%26category%3D3%26russian%3D5">fork ()</a> .  I will tell you about the use of the fork () system call in PHP and the pcntl extension.  As an example, we will write a fairly fast parallel implementation of grep (with a speed similar to <code>find . -type f -print0 | xargs -0 -P $NUM_PROCS grep $EXPR</code> ). <br><a name="habracut"></a><br><h4>  Implementation </h4><br>  Implementing this system call in PHP is very simple: <br><br><pre> <code class="hljs objectivec">PHP_FUNCTION(pcntl_fork) { pid_t <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { PCNTL_G(last_error) = errno; php_error_docref(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> TSRMLS_CC, E_WARNING, <span class="hljs-string"><span class="hljs-string">"Error %d"</span></span>, errno); } RETURN_LONG((<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); }</code> </pre><br><h4>  What is the fork () system call </h4><br>  The fork () system call in * nix-systems is a system call that makes a complete copy of the current process.  The fork () system call returns its value twice: the parent receives the PID of the descendant, and the descendant receives 0. Oddly enough, in many cases, this is enough to write applications that use multiple CPUs. <br><br><pre> <code class="php hljs">$ php -r <span class="hljs-string"><span class="hljs-string">'$pid = pcntl_fork(); echo posix_getpid() . ": Fork returned $pid\n";'</span></span> <span class="hljs-number"><span class="hljs-number">9545</span></span>: Fork returned <span class="hljs-number"><span class="hljs-number">9546</span></span> <span class="hljs-number"><span class="hljs-number">9546</span></span>: Fork returned <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Pitfalls when using fork () </h4><br>  In fact, fork () does its work without thinking about what the user process has in memory - it copies everything, for example, functions that are registered via atexit (register_shutdown_function).  Example: <br><br><pre> <code class="php hljs">$ php -r <span class="hljs-string"><span class="hljs-string">'register_shutdown_function(function() { echo "Exited!\n"; }); pcntl_fork();'</span></span> Exited! Exited!</code> </pre><br>  Unfortunately, PHP at the end of the script executes a call to destructors (including internal destructors of database connection resources).  Example for the mysqli extension: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/* test.php */</span></span> $conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mysqli(..., <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot connect\n"</span></span>); $pid = pcntl_fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Parent exiting\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Sending query\n"</span></span>; $res = $conn-&gt;query(<span class="hljs-string"><span class="hljs-string">"SHOW TABLES"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot get query result\n"</span></span>); print_r($res-&gt;fetch_all()); <span class="hljs-comment"><span class="hljs-comment">/* $ php test.php Parent exiting Sending query Warning: mysqli::query(): MySQL server has gone away in test.php on line 9 Warning: mysqli::query(): Error reading result set's header in test.php on line 9 Cannot get query result */</span></span></code> </pre><br>  The output of the program will not necessarily be as written.  Sometimes the descendant ‚Äúhas time‚Äù before the execution of the procedure for closing the connection in the parent and everything works as it should. <br><br><h4>  We struggle with deferred execution of functions / destructors </h4><br>  In fact, the problem of deferred execution can be solved if you know exactly what you want.  For example, in C, there is a <a href="http://www.opennet.ru/man.shtml%3Ftopic%3D_exit%26category%3D3%26russian%3D5">_exit ()</a> function that exits without running any installed handlers.  Unfortunately, there is no such function in PHP, but its behavior can be partially emulated using signals: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ posix_kill(posix_getpid(), SIGTERM); }</code> </pre><br>  This ‚Äúhack‚Äù will be enough for us to keep the connection with the database active for two PHP processes at the same time, although it is better, of course, not to do this in practice :): <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/* test.php */</span></span> $conn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> mysqli(..., <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot connect\n"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_exit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ posix_kill(posix_getpid(), SIGTERM); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show_tables</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $conn; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Sending query\n"</span></span>; $res = $conn-&gt;query(<span class="hljs-string"><span class="hljs-string">"SHOW TABLES"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">die</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot get query result\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"Tables count: "</span></span> . $res-&gt;num_rows . <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } $pid = pcntl_fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { show_tables(); _exit(); } sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); show_tables(); <span class="hljs-comment"><span class="hljs-comment">/* $ php test.php Sending query Tables count: 24 Terminated: 15 &lt;---     $ Sending query Tables count: 24 */</span></span></code> </pre><br><h4>  Writing grep </h4><br>  Let's now, for example, write a simple version of grep that will search by mask in the current directory. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  : $ php grep.php argv ./grep.php:$pattern = "/$argv[1]/m"; */</span></span> exec(<span class="hljs-string"><span class="hljs-string">"find . -type f"</span></span>, $files, $retval); <span class="hljs-comment"><span class="hljs-comment">//       $pattern = "/$argv[1]/m"; foreach($files as $file) { $fp = fopen($file, "rb"); //       ,       $is_binary = strpos(fread($fp, 1024), "\0") !== false; fseek($fp, 0); if ($is_binary) { if (preg_match($pattern, file_get_contents($file))) echo "$file: binary matches\n"; } else { while (false !== ($ln = fgets($fp))) if (preg_match($pattern, $ln)) echo "$file:$ln"; } fclose($fp); }</span></span></code> </pre><br><h4>  Writing a parallel version of grep </h4><br>  Now we will think about how we can speed up this program by parallelizing it.  You can easily notice that we can divide the $ files array (file list) into several parts and process these parts independently.  Moreover, we can do this in all cases when we have a large list of tasks: we simply take each N in the corresponding process and process it.  Therefore, we will write a more or less general function for this: <br><br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">'PROCESSES_NUM'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      function parallelForeach($arr, $func) { for ($proc_num = 0; $proc_num &lt; PROCESSES_NUM; $proc_num++) { $pid = pcntl_fork(); if ($pid == 0) break; } if ($pid) { for ($i = 0; $i &lt; PROCESSES_NUM; $i++) pcntl_wait($status); return; } //   PROCESSES_NUM      $l = count($arr); for ($i = $proc_num; $i &lt; $l; $i += PROCESSES_NUM) $func($arr[$i]); exit(0); }</span></span></code> </pre><br><br>  It remains to replace foreach () with the use of our parallelForeach function and add error handling: <br><div class="spoiler">  <b class="spoiler_title">Full source code</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/* parallel-grep.php */</span></span> define(<span class="hljs-string"><span class="hljs-string">'PROCESSES_NUM'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($argc != <span class="hljs-number"><span class="hljs-number">2</span></span>) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Usage: $argv[0] &lt;pattern&gt;\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } grep($argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grep</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($pattern)</span></span></span><span class="hljs-function"> </span></span>{ exec(<span class="hljs-string"><span class="hljs-string">"find . -type f"</span></span>, $files, $retval); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($retval) <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>($retval); $pattern = <span class="hljs-string"><span class="hljs-string">"/$pattern/m"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> === preg_match($pattern, <span class="hljs-string"><span class="hljs-string">'123'</span></span>)) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Incorrect regular expression\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } parallelForeach($files, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($f)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($pattern)</span></span></span><span class="hljs-function"> </span></span>{ grepFile($pattern, $f); }); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grepFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($pattern, $file)</span></span></span><span class="hljs-function"> </span></span>{ $fp = fopen($file, <span class="hljs-string"><span class="hljs-string">"rb"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$fp) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Cannot read $file\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $binary = strpos(fread($fp, <span class="hljs-number"><span class="hljs-number">1024</span></span>), <span class="hljs-string"><span class="hljs-string">"\0"</span></span>) !== <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; fseek($fp, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($binary) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($pattern, file_get_contents($file))) <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$file: binary matches\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">false</span></span> !== ($ln = fgets($fp))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($pattern, $ln)) <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"$file:$ln"</span></span>; } } fclose($fp); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallelForeach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($arr, $func)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($proc_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; $proc_num &lt; PROCESSES_NUM; $proc_num++) { $pid = pcntl_fork(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { fwrite(STDERR, <span class="hljs-string"><span class="hljs-string">"Cannot fork\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($pid) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = <span class="hljs-number"><span class="hljs-number">0</span></span>; $i &lt; PROCESSES_NUM; $i++) { pcntl_wait($status); $exitcode = pcntl_wexitstatus($status); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($exitcode) <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } $l = count($arr); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($i = $proc_num; $i &lt; $l; $i += PROCESSES_NUM) $func($arr[$i]); <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> </div></div><br>  Check out the work of our grep on PHP 5.3.10 source code: <br><br><pre> <code class="php hljs">$ php ~/parallel-grep.php <span class="hljs-string"><span class="hljs-string">'^PHP_FUNCTION'</span></span> | head ./ext/calendar/calendar.c:PHP_FUNCTION(cal_info) ./ext/calendar/calendar.c:PHP_FUNCTION(cal_days_in_month) ./ext/calendar/calendar.c:PHP_FUNCTION(cal_to_jd) ./ext/calendar/calendar.c:PHP_FUNCTION(cal_from_jd) ./ext/calendar/calendar.c:PHP_FUNCTION(jdtogregorian) ./ext/calendar/calendar.c:PHP_FUNCTION(gregoriantojd) ./ext/calendar/calendar.c:PHP_FUNCTION(jdtojulian) ./ext/calendar/calendar.c:PHP_FUNCTION(juliantojd) ./ext/calendar/calendar.c:PHP_FUNCTION(jdtojewish) ./ext/calendar/calendar.c:PHP_FUNCTION(jewishtojd) $ time php ~/parallel-grep.php <span class="hljs-string"><span class="hljs-string">'^PHP_FUNCTION'</span></span> | wc -l <span class="hljs-number"><span class="hljs-number">4056</span></span> real <span class="hljs-number"><span class="hljs-number">0</span></span>m2<span class="hljs-number"><span class="hljs-number">.073</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m3<span class="hljs-number"><span class="hljs-number">.265</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.550</span></span>s $ time grep -R <span class="hljs-string"><span class="hljs-string">'^PHP_FUNCTION'</span></span> . | wc -l <span class="hljs-number"><span class="hljs-number">4056</span></span> real <span class="hljs-number"><span class="hljs-number">0</span></span>m3<span class="hljs-number"><span class="hljs-number">.646</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m3<span class="hljs-number"><span class="hljs-number">.415</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.209</span></span>s $ time find . -type f -print0 | xargs <span class="hljs-number"><span class="hljs-number">-0</span></span> -P <span class="hljs-number"><span class="hljs-number">2</span></span> grep <span class="hljs-string"><span class="hljs-string">'^PHP_FUNCTION'</span></span> | wc -l <span class="hljs-number"><span class="hljs-number">4056</span></span> real <span class="hljs-number"><span class="hljs-number">0</span></span>m1<span class="hljs-number"><span class="hljs-number">.895</span></span>s user <span class="hljs-number"><span class="hljs-number">0</span></span>m3<span class="hljs-number"><span class="hljs-number">.247</span></span>s sys <span class="hljs-number"><span class="hljs-number">0</span></span>m0<span class="hljs-number"><span class="hljs-number">.249</span></span>s</code> </pre><br><br>  Works!  I described one of the frequently used patterns for parallel programming in PHP - parallel processing of the queue of tasks.  I hope my article will help someone to stop being afraid to write multithreaded PHP applications if the task allows for such a decomposition, as in the example with grep.  Thank. </div><p>Source: <a href="https://habr.com/ru/post/148688/">https://habr.com/ru/post/148688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148678/index.html">Overview of the laboratory power supply Mastech 3003D</a></li>
<li><a href="../148683/index.html">Ninja Tel - amateur wireless telephone network on Defcon</a></li>
<li><a href="../148684/index.html">Bitly announced Realtime search service.</a></li>
<li><a href="../148685/index.html">Apple buys AuthenTec</a></li>
<li><a href="../148686/index.html">In the beginning was the Word</a></li>
<li><a href="../148689/index.html">Linux - WiFi Starting Script</a></li>
<li><a href="../148690/index.html">The design of the first iPhone was ‚Äúborrowed‚Äù from Sony</a></li>
<li><a href="../148691/index.html">Acer Aspire M3 Ultra - Unusual Ultrabook Review</a></li>
<li><a href="../148692/index.html">Software capture from webcam</a></li>
<li><a href="../148693/index.html">OAuth 2.0 editor asked to cross out your name from specifications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>