<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your first Linux device driver</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear habrachiteli. 

 The purpose of this article is to show the principle of implementation of device drivers on a Linux system, using the exa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your first Linux device driver</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear habrachiteli. <br><br>  The purpose of this article is to show the principle of implementation of device drivers on a Linux system, using the example of a simple symbolic driver. <br><br>  For me, the main goal is to summarize and form the basic knowledge for writing future kernel modules, as well as gain experience in presenting technical literature to the public, since  in six months I will be performing with my graduation project (yes, I am a student). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is my first article, please do not judge strictly! <br><br><h3>  PS </h3>  It turned out too many letters, so I decided to divide the article into three parts: <br><br>  Part 1 - Introduction, initialization and cleaning of the kernel module. <br>  Part 2 - Functions open, read, write and trim. <br>  Part 3 - We write Makefile and test the device. <br><br>  Before the introduction, I want to say that the basic things will be described here, more detailed information will be presented in the second and last part of this article. <br><br>  So, let's begin. <br><a name="habracut"></a><br><h2>  Preparatory work </h2><br><h4>  UPD. </h4>  Thanks <a href="https://habrahabr.ru/users/kolyuchkin/" class="user_link">Kolyuchkin</a> for clarifying. <br><br>  A character driver (Char driver) is a driver that works with character devices. <br>  Character devices are devices that can be accessed as a byte stream. <br>  An example of a character device is / dev / ttyS0, / dev / tty1. <br><br><h4>  UPD. </h4>  To the question about kernel verification: <br><pre><code class="bash hljs">~$ uname -r 4.4.0-93-generic</code> </pre> <br>  The driver represents each character device with the scull_dev structure, and also provides the cdev interface to the kernel. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_dev</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_qset</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> quantum; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> qset; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> size; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">semaphore</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sem</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cdev</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cdev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,    */</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_dev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_device</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  The device will present a linked list of pointers, each of which points to the scull_qset structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_qset</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **data; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_qset</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br>  For clarity, look at the picture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bb/fa7/089/6bbfa7089b98baf192e63a9863623c40.gif" alt="image"><br><br>  To register a device, you need to set special numbers, namely: <br><br>  MAJOR - senior number (is unique in the system). <br>  MINOR - low number (not unique in the system). <br><br>  The kernel has a mechanism that allows you to register specialized numbers manually, but this approach is undesirable and it is better to politely ask the kernel to dynamically allocate them for us.  Sample code will be below. <br><br>  After we have determined the numbers for our device, we need to establish a connection between these numbers and driver operations.  This can be done using the file_operations structure. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">file_operations</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">scull_fops</span></span></span><span class="hljs-class"> = {</span></span> .owner = THIS_MODULE, .read = scull_read, .write = scull_write, .open = scull_open, .release = scull_release, };</code> </pre><br>  The kernel has special module_init / module_exit macros that indicate the path to the module initialization / deletion functions.  Without these definitions, initialization / deletion functions will never be called. <br><br><pre> <code class="cpp hljs">module_init(scull_init_module); module_exit(scull_cleanup_module);</code> </pre><br>  Here we will store basic information about the device. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scull_major = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* MAJOR */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scull_minor = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* MINOR */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scull_nr_devs = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scull_quantum = <span class="hljs-number"><span class="hljs-number">4000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> scull_qset = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span></code> </pre><br>  The final stage of the preparatory work will be to connect the header files. <br>  A brief description is given below, but if you want to dig deeper, then welcome to the wonderful site: <a href="http://elixir.free-electrons.com/linux/latest/source">lxr</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; /*          */ #include &lt;linux/init.h&gt; /*       */ #include &lt;linux/fs.h&gt; /*       */ #include &lt;linux/cdev.h&gt; /*       */ #include &lt;linux/slab.h&gt; /*       */ #include &lt;asm/uaccess.h&gt; /*      */</span></span></span></span></code> </pre><br><h2>  Initialization </h2><br>  Now let's look at the device initialization function. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scull_init_module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rv, i; <span class="hljs-keyword"><span class="hljs-keyword">dev_t</span></span> dev; rv = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs, <span class="hljs-string"><span class="hljs-string">"scull"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"scull: can't get major %d\n"</span></span>, scull_major); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } scull_major = MAJOR(dev); scull_device = kmalloc(scull_nr_devs * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct scull_dev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scull_device) { rv = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(scull_device, <span class="hljs-number"><span class="hljs-number">0</span></span>, scull_nr_devs * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct scull_dev)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; scull_nr_devs; i++) { scull_device[i].quantum = scull_quantum; scull_device[i].qset = scull_qset; sema_init(&amp;scull_device[i].sem, <span class="hljs-number"><span class="hljs-number">1</span></span>); scull_setup_cdev(&amp;scull_device[i], i); } dev = MKDEV(scull_major, scull_minor + scull_nr_devs); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fail: scull_cleanup_module(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br>  First, by calling alloc_chrdev_region, we register a range of device symbol numbers and specify the device name.  After calling MAJOR (dev) we get the major number. <br>  Next, the returned value is checked, if it is an error code, then we exit the function.  It is worth noting that when developing a real device driver, you should always check return values, as well as pointers to any elements (NULL?). <br><br><pre> <code class="cpp hljs">rv = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs, <span class="hljs-string"><span class="hljs-string">"scull"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rv) { printk(KERN_WARNING <span class="hljs-string"><span class="hljs-string">"scull: can't get major %d\n"</span></span>, scull_major); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; } scull_major = MAJOR(dev);</code> </pre><br>  If the returned value is not an error code, we continue to perform initialization. <br><br>  We allocate memory by making a call to the kmalloc function and be sure to check the pointer to NULL. <br><br><h4>  UPD </h4>  It is worth mentioning that instead of calling the two functions kmalloc and memset, you can use one call to kzalloc, which allocates a memory area and initializes it to zero. <br><br><pre> <code class="cpp hljs">scull_device = kmalloc(scull_nr_devs * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct scull_dev), GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scull_device) { rv = -ENOMEM; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> fail; } <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(scull_device, <span class="hljs-number"><span class="hljs-number">0</span></span>, scull_nr_devs * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct scull_dev));</code> </pre><br>  We continue initialization.  The main function here is scull_setup_cdev, we will talk about it a little later.  MKDEV is used to store older and younger device numbers. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; scull_nr_devs; i++) { scull_device[i].quantum = scull_quantum; scull_device[i].qset = scull_qset; sema_init(&amp;scull_device[i].sem, <span class="hljs-number"><span class="hljs-number">1</span></span>); scull_setup_cdev(&amp;scull_device[i], i); } dev = MKDEV(scull_major, scull_minor + scull_nr_devs);</code> </pre><br>  We return the value or process the error and delete the device. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; fail: scull_cleanup_module(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }</code> </pre><br>  Above, we presented the scull_dev and cdev structures that implement the interface between our device and the kernel.  The scull_setup_cdev function initializes and adds a structure to the system. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scull_setup_cdev</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct scull_dev *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err, devno = MKDEV(scull_major, scull_minor + index); cdev_init(&amp;dev-&gt;cdev, &amp;scull_fops); dev-&gt;cdev.owner = THIS_MODULE; dev-&gt;cdev.ops = &amp;scull_fops; err = cdev_add(&amp;dev-&gt;cdev, devno, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) printk(KERN_NOTICE <span class="hljs-string"><span class="hljs-string">"Error %d adding scull %d"</span></span>, err, index); }</code> </pre><br><h2>  Deletion </h2><br>  The scull_cleanup_module function is called when a device module is removed from the kernel. <br>  Reverse initialization process, remove device structures, free up memory, and delete junior and major numbers allocated by the kernel. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scull_cleanup_module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">dev_t</span></span> devno = MKDEV(scull_major, scull_minor); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scull_device) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; scull_nr_devs; i++) { scull_trim(scull_device + i); cdev_del(&amp;scull_device[i].cdev); } kfree(scull_device); } unregister_chrdev_region(devno, scull_nr_devs); }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/cdev.h&gt; #include &lt;linux/slab.h&gt; #include &lt;asm/uaccess.h&gt; int scull_major = 0; int scull_minor = 0; int scull_nr_devs = 1; int scull_quantum = 4000; int scull_qset = 1000; struct scull_qset { void **data; struct scull_qset *next; }; struct scull_dev { struct scull_qset *data; int quantum; int qset; unsigned long size; unsigned int access_key; struct semaphore sem; struct cdev cdev; }; struct scull_dev *scull_device; int scull_trim(struct scull_dev *dev) { struct scull_qset *next, *dptr; int qset = dev-&gt;qset; int i; for (dptr = dev-&gt;data; dptr; dptr = next) { if (dptr-&gt;data) { for (i = 0; i &lt; qset; i++) kfree(dptr-&gt;data[i]); kfree(dptr-&gt;data); dptr-&gt;data = NULL; } next = dptr-&gt;next; kfree(dptr); } dev-&gt;size = 0; dev-&gt;quantum = scull_quantum; dev-&gt;qset = scull_qset; dev-&gt;data = NULL; return 0; } struct file_operations scull_fops = { .owner = THIS_MODULE, //.read = scull_read, //.write = scull_write, //.open = scull_open, //.release = scull_release, }; static void scull_setup_cdev(struct scull_dev *dev, int index) { int err, devno = MKDEV(scull_major, scull_minor + index); cdev_init(&amp;dev-&gt;cdev, &amp;scull_fops); dev-&gt;cdev.owner = THIS_MODULE; dev-&gt;cdev.ops = &amp;scull_fops; err = cdev_add(&amp;dev-&gt;cdev, devno, 1); if (err) printk(KERN_NOTICE "Error %d adding scull %d", err, index); } void scull_cleanup_module(void) { int i; dev_t devno = MKDEV(scull_major, scull_minor); if (scull_device) { for (i = 0; i &lt; scull_nr_devs; i++) { scull_trim(scull_device + i); cdev_del(&amp;scull_device[i].cdev); } kfree(scull_device); } unregister_chrdev_region(devno, scull_nr_devs); } static int scull_init_module(void) { int rv, i; dev_t dev; rv = alloc_chrdev_region(&amp;dev, scull_minor, scull_nr_devs, "scull"); if (rv) { printk(KERN_WARNING "scull: can't get major %d\n", scull_major); return rv; } scull_major = MAJOR(dev); scull_device = kmalloc(scull_nr_devs * sizeof(struct scull_dev), GFP_KERNEL); if (!scull_device) { rv = -ENOMEM; goto fail; } memset(scull_device, 0, scull_nr_devs * sizeof(struct scull_dev)); for (i = 0; i &lt; scull_nr_devs; i++) { scull_device[i].quantum = scull_quantum; scull_device[i].qset = scull_qset; sema_init(&amp;scull_device[i].sem, 1); scull_setup_cdev(&amp;scull_device[i], i); } dev = MKDEV(scull_major, scull_minor + scull_nr_devs); printk(KERN_INFO "scull: major = %d minor = %d\n", scull_major, scull_minor); return 0; fail: scull_cleanup_module(); return rv; } MODULE_AUTHOR("Your name"); MODULE_LICENSE("GPL"); module_init(scull_init_module); module_exit(scull_cleanup_module);</span></span></span></span></code> </pre><br></div></div><br>  I am pleased to hear constructive criticism and will wait for feedback. <br><br>  If you have found errors or I have not correctly stated the material, please point me to this. <br>  For a faster reaction, write to the LAN. <br><br>  Thank! <br><br><h3>  Literature </h3><br><ul><li>  Linux device drivers 3rd edition </li><li>  Essential linux device drivers </li></ul></div><p>Source: <a href="https://habr.com/ru/post/337946/">https://habr.com/ru/post/337946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337934/index.html">Amazingly useful tool: lsof</a></li>
<li><a href="../337936/index.html">Chief, I want to work from home</a></li>
<li><a href="../337938/index.html">4 reasons to become a Data Engineer</a></li>
<li><a href="../337940/index.html">We write telegrams of a bot parser of vacancies on JS</a></li>
<li><a href="../337942/index.html">Welcome to mini ai cups</a></li>
<li><a href="../337950/index.html">We enter the rating of the participant Dribbble and Behance on "My Circle"</a></li>
<li><a href="../337952/index.html">Mathematics for the programmer</a></li>
<li><a href="../337958/index.html">iOS + Kotlin. What can be done now</a></li>
<li><a href="../337960/index.html">In unity - profit. ESET examines browser miner</a></li>
<li><a href="../337962/index.html">Where to go vendor when Amazon is too tough: we come up with a marketplace for niche gadgets</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>