<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Changing the program code during its execution on the example of Common Lisp</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In my humble opinion, Lisp is a gem among functional programming languages. Despite the fact that this is one of the first high-level l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Changing the program code during its execution on the example of Common Lisp</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/469/9d8/066/4699d806688e00fc08f2a3ecc044504a.jpg" align="right"><br><h4>  Introduction </h4><br>  In my humble opinion, <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2581%25D0%25BF">Lisp</a> is a gem among functional programming languages.  Despite the fact that this is one of the first high-level languages ‚Äã‚Äãin history (1958), it still does not cease to amaze.  It seems to me that he is so ahead of his time that his hour is just getting ready to come. <br><br>  So let's try to write a program that will be problematic to create in other languages.  As the name of the article suggests, this program will edit its own code as it is executed.  To create it, I use <a href="http://ru.wikipedia.org/wiki/Common_Lisp">Common Lisp</a> , or rather its <a href="http://www.sbcl.org/">SBCL</a> interpreter. <br><a name="habracut"></a><br><br>  <i>Note: if you take a clean <abbr title="Steel Bank Common Lisp">SBCL</abbr> , then it has the property not to flush the stdio stream after each output, I myself use <abbr title="Steel Bank Common Lisp">SBCL</abbr> via <a href="http://www.gnu.org/software/emacs/">Emacs</a> and <a href="http://common-lisp.net/project/slime/">Slime</a> , there is no such problem there.</i>  <i>I have not found an adequate solution yet.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  How? </h4><br>  Lisp has remarkable properties, among which I would like to mention a very simple syntax and uniformity of code.  The cool thing is that any Lisp code is data for it, and many data can be code.  In particular, it makes it possible to write auto-applicative (self-applicable) and auto-replicative (self-replicating) functions.  A little bit about them is written <a href="http://it.kgsu.ru/Lisp/lisp0042.html">here</a> ;  the information in turn is taken from the book ‚ÄúThe World of Lisp‚Äù (E. Hyuvenen, I. Sepp√§nen) Volume 1, page 280. For example, a <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D0%25B0%25D0%25B9%25D0%25BD_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">quine</a> , which is both an auto-applicative and auto-replicative function, is written like this: <br><br><pre><code class="lisp hljs">((<span class="hljs-name"><span class="hljs-name">lambda</span></span> (<span class="hljs-name"><span class="hljs-name">x</span></span>) (<span class="hljs-name"><span class="hljs-name">list</span></span> x (<span class="hljs-name"><span class="hljs-name">list</span></span> 'quote x))) '(lambda (x) (list x (list 'quote x))))</code> </pre> <br>  When interpreting, of course, it deduces itself. <br>  Why not write a function that returns not an exact copy of itself, but some new version, which will later be executed again to make an even more mutated version?  So do. <br><br><h4>  Command processor </h4><br>  To make senseless not to shake the air and not to produce spherical horses in a vacuum, let's build a pseudo-practical program.  The easiest option that comes to mind is a command processor.  The user enters, say, from the keyboard a command, the product of our creativity executes it. <br><br>  The whole point will be that the source (in all senses) code will be very minimalist.  As soon as we feed him to the interpreter, we will no longer return to the immediate work with the <acronym>REPL</acronym> .  Our program will be continuously implemented and developed (or degraded) over time thanks to our teams. <br><br>  So, let's start with a function that returns an s-expression, which is the definition of a <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D1%258F%25D0%25BC%25D0%25B1%25D0%25B4%25D0%25B0-%25D0%25B8%25D1%2581%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">lambda function</a> , which is the starting code.  This lambda function takes, as the only parameter, its source code and gives as a result also some code, which in turn is destined to be executed at the next iteration. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> start-program () '(lambda (program) (princ <span class="hljs-string"><span class="hljs-string">"$&gt; "</span></span>) (let ((input (read))) (when (listp input) (let ((command (car input))) (cond ((eq command 'code) ;   = code, (setf program ;    (funcall ;  ,    (eval (list 'lambda '(program input) (cadr input))) program input) ) ) (<span class="hljs-literal"><span class="hljs-literal">t</span></span> (format <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown command ~A ~%"</span></span> command)) ) ) ) program ) ) )</code> </pre> <br>  Our initial code does little.  He prompts the user, reads an <a href="http://ru.wikipedia.org/wiki/S-%25D0%25B2%25D1%258B%25D1%2580%25D0%25B0%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">s-expression</a> from the keyboard, if it is a list, then the first element is the name of the command, the rest are its arguments.  The out-of-box command processor can handle only one single ‚Äúcode‚Äù command.  This command takes its first argument and creates a lambda function from it that is applied to program and input.  Why so hard?  Because eval does its dirty work in a zero lexical environment, which means that the program and input local variables are not available to us, although they may be required.  We need to find a way to pass them inside eval;  nothing better than lamda with the parameters did not occur to me.  I do not exclude that there are more elegant ways.  The result of the internal eval is assigned to the variable program.  In general, it would be possible to simply assign program the remainder of input, but in this case we will not be able to perform additional functions using the code command.  About them later. <br>  The following <b>main</b> function organizes the program operation cycle.  All the magic is hidden in it. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">defun</span></span> main () (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">program</span></span> (<span class="hljs-name"><span class="hljs-name">start-program</span></span>))) <span class="hljs-comment"><span class="hljs-comment">;    ; ,    , ..  nil (loop while program do ;  try - catch,   , ;      (handler-case ;   program   , ;    program   program (setf program (funcall (eval program) program)) ;   ,    (error (c1) (format t "Error! ~A~%" c1) ) ) ) ) )</span></span></code> </pre> <br><img src="https://habrastorage.org/storage2/627/3e7/c5f/6273e7c5f56a2e616f088ef54a38ce9b.png"><br>  So, the cycle goes until the program (program variable) is not empty.  The program on the zero iteration is the result of the <b>start-program</b> function, and on a non-zero iteration we assign to it (the program variable) the result of the function contained in it (the program variable) with the program parameter (again it is the same).  This is not a tautology, and it is important to understand how it works before moving on.  Understood?  Now run in the <acronym>REPL</acronym> <b>main</b> and see the prompt: <br><br><pre> <code class="lisp hljs">CL-USER&gt; (<span class="hljs-name"><span class="hljs-name">main</span></span>) $&gt;</code> </pre> <br>  You can create.  If you get tired and want to go back to the <acronym>REPL</acronym> , all you have to do is execute our only code command in the nil parameter.  It will replace the source text with nil, and the cycle will take it as a condition of completion.  But we, of course, will not do it yet.  From now on, all commands are entered into our running program.  I will often omit the "$&gt;" for easy copying. <br><br>  At the current stage, programming our command processor is difficult and inconvenient.  We need to call the code command and pass the whole new source code to it.  But there is no way out.  Let's create an eval team that will start solving problems.  It will allow us to execute any code, in particular, to set new functions. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">code</span></span> '(lambda (program) (princ <span class="hljs-string"><span class="hljs-string">"$&gt; "</span></span>) (let ((input (read))) (when (listp input) (let ((command (car input))) (cond ((eq command 'code) (setf program (funcall (eval (list 'lambda '(program input) (cadr input))) program input))) ((eq command 'eval) (eval (cadr input))) ;  (<span class="hljs-literal"><span class="hljs-literal">t</span></span> (format <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-string"><span class="hljs-string">"Unknown command ~A ~%"</span></span> command)) ) ) ) program ) ) )</code> </pre> <br>  Perhaps it will issue STYLE-WARNING, it's not scary.  Check: <br><br><pre> <code class="lisp hljs">$&gt; (<span class="hljs-name"><span class="hljs-name">eval</span></span> (<span class="hljs-name"><span class="hljs-name">print</span></span> (<span class="hljs-name"><span class="hljs-name">+</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>))) <span class="hljs-number"><span class="hljs-number">5</span></span> $&gt;</code> </pre> <br>  Voila, it works! <br>  Spice up the system with three functions (rsubs, rrem, rins).  <b>rsubs</b> (Recursive substitution) replaces the recursive old form (the first parameter old) with a new one (the second parameter new) in the form (the third parameter form).  <b>rrem</b> (Recursive remove) removes the form (first parameter what) from the form (second parameter form) also recursively.  Finally, <b>rins</b> (Recursive insert) inserts next to the form (the first parameter where) the form (second parameter what) in the form (third parameter form), and if the key is given: before t, then the insertion is performed before the form where, otherwise - after it.  You have to execute three commands. <br><br><div class="spoiler">  <b class="spoiler_title">View three teams</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">eval</span></span> (<span class="hljs-name"><span class="hljs-name">defun</span></span> rsubs (<span class="hljs-name"><span class="hljs-name">old</span></span> new form) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">atom</span></span> form) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">equal</span></span> form old) new form)) ((<span class="hljs-name"><span class="hljs-name">equal</span></span> form old) new) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">loop</span></span> for el in form collect (<span class="hljs-name"><span class="hljs-name">rsubs</span></span> old new el))) ) ) ) (<span class="hljs-name"><span class="hljs-name">eval</span></span> (<span class="hljs-name"><span class="hljs-name">defun</span></span> rrem (<span class="hljs-name"><span class="hljs-name">what</span></span> form) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">atom</span></span> form) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">equal</span></span> what form) <span class="hljs-literal"><span class="hljs-literal">nil</span></span> form)) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">loop</span></span> for el in form if (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">equal</span></span> what el)) collect (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">listp</span></span> el) (<span class="hljs-name"><span class="hljs-name">rrem</span></span> what el) el) )) ) ) ) (<span class="hljs-name"><span class="hljs-name">eval</span></span> (<span class="hljs-name"><span class="hljs-name">defun</span></span> rins (<span class="hljs-name"><span class="hljs-name">where</span></span> what form <span class="hljs-symbol"><span class="hljs-symbol">&amp;key</span></span> before) (<span class="hljs-name"><span class="hljs-name">cond</span></span> ((<span class="hljs-name"><span class="hljs-name">atom</span></span> form) form) (<span class="hljs-name"><span class="hljs-name">t</span></span> (<span class="hljs-name"><span class="hljs-name">loop</span></span> for el in form append (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">equal</span></span> el where) (<span class="hljs-name"><span class="hljs-name">if</span></span> before (<span class="hljs-name"><span class="hljs-name">list</span></span> what el) (<span class="hljs-name"><span class="hljs-name">list</span></span> el what)) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">listp</span></span> el) (<span class="hljs-name"><span class="hljs-name">list</span></span> (<span class="hljs-name"><span class="hljs-name">rins</span></span> where what el <span class="hljs-symbol"><span class="hljs-symbol">:before</span></span> before)) (<span class="hljs-name"><span class="hljs-name">list</span></span> el) ) ) )) ) ) )</code> </pre> </div></div><br>  You can already add new commands to our processor in a more beautiful way, precisely because code does not simply replace the code with its argument, but executes it beforehand.  Add a view command that displays the contents of the program variable.  A very useful command for tracking code changes.  As you can see, here is the insertion of a new code after the atom cond. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">code</span></span> (<span class="hljs-name"><span class="hljs-name">rins</span></span> 'cond '((eq command 'view) (progn (format <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-string"><span class="hljs-string">"---code---"</span></span>) (print program) (terpri))) program))</code> </pre> <br>  We are testing, we should have something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Sample command output (view)</b> <div class="spoiler_text"><pre> <code class="lisp hljs">$&gt; (<span class="hljs-name"><span class="hljs-name">view</span></span>) ---code--- (<span class="hljs-name"><span class="hljs-name">LAMBDA</span></span> (<span class="hljs-name"><span class="hljs-name">PROGRAM</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINC</span></span> <span class="hljs-string"><span class="hljs-string">"$&gt; "</span></span>) (<span class="hljs-name"><span class="hljs-name">LET</span></span> ((<span class="hljs-name"><span class="hljs-name">INPUT</span></span> (<span class="hljs-name"><span class="hljs-name">READ</span></span>))) (<span class="hljs-name"><span class="hljs-name">WHEN</span></span> (<span class="hljs-name"><span class="hljs-name">LISTP</span></span> INPUT) (<span class="hljs-name"><span class="hljs-name">LET</span></span> ((<span class="hljs-name"><span class="hljs-name">COMMAND</span></span> (<span class="hljs-name"><span class="hljs-name">CAR</span></span> INPUT))) (<span class="hljs-name"><span class="hljs-name">COND</span></span> ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'VIEW) (<span class="hljs-name"><span class="hljs-name">PROGN</span></span> (<span class="hljs-name"><span class="hljs-name">FORMAT</span></span> T <span class="hljs-string"><span class="hljs-string">"---code---"</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINT</span></span> PROGRAM) (<span class="hljs-name"><span class="hljs-name">TERPRI</span></span>))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'CODE) (<span class="hljs-name"><span class="hljs-name">SETF</span></span> PROGRAM (<span class="hljs-name"><span class="hljs-name">FUNCALL</span></span> (<span class="hljs-name"><span class="hljs-name">EVAL</span></span> (<span class="hljs-name"><span class="hljs-name">LIST</span></span> 'LAMBDA '(PROGRAM INPUT) (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT))) PROGRAM INPUT))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'EVAL) (<span class="hljs-name"><span class="hljs-name">EVAL</span></span> (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT))) (<span class="hljs-name"><span class="hljs-name">T</span></span> (<span class="hljs-name"><span class="hljs-name">FORMAT</span></span> T <span class="hljs-string"><span class="hljs-string">"Unknown command ~A ~%"</span></span> COMMAND))))) PROGRAM)) $&gt;</code> </pre> </div></div><br>  Fine!  Now it‚Äôs easy for us to add a command that will add commands.  Well, how else to call it?  The command syntax will be as follows: <i>(add-cmd name-new-command-what-she-will-do)</i> .  But here we are in for a spicy situation.  The previous time we inserted the code of the new command after the atom cond, because it was the easiest thing.  This name is common, and if one more mention of it appears in the text, the insertion will be performed there, which will break the work of those parts that we were not going to touch.  You can solve this problem in many ways, for example, enter a unique marker and insert new commands after it.  The marker will be an impracticable condition that we add after cond: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">code</span></span> (<span class="hljs-name"><span class="hljs-name">rins</span></span> 'cond '((eq <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) 'secret-marker) program))</code> </pre> <br><img src="https://habrastorage.org/storage2/cb1/3ee/98c/cb13ee98c2924e4f10f586ac05aabe8a.png"><br>  Is done.  Now we will transfer to rins the location of the insert using this marker.  Bulkness of the marker does not mean anything, because we will create a team that will know him, and we will no longer need to remember him.  By the way, it is impossible for the add-cmd command code to use the definition of a marker, otherwise rins will find and break it.  You can try to deceive rins by distorting the marker, but it is much easier to simply put it into a separate external function (rins is not looking for them).  The <b>add-command-to-program</b> function takes the program parameter as the first parameter and returns it updated by adding a new command to the command that executes the action action: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">eval</span></span> (<span class="hljs-name"><span class="hljs-name">defun</span></span> add-command-to-program (<span class="hljs-name"><span class="hljs-name">program</span></span> command action) (<span class="hljs-name"><span class="hljs-name">rins</span></span> '((eq <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) 'secret-marker) <span class="hljs-comment"><span class="hljs-comment">;   `((eq command ',command) ,action) ;   program ) ) )</span></span></code> </pre> <br>  We actually create the add-cmd command. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">code</span></span> (<span class="hljs-name"><span class="hljs-name">rins</span></span> '((eq <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) 'secret-marker) <span class="hljs-comment"><span class="hljs-comment">;     `((eq command 'add-cmd) ;    add-cmd (setf program (add-command-to-program program (cadr input) (caddr input))) ) program ) )</span></span></code> </pre> <br>  Wonderful!  Now there is nothing easier than adding new commands (the last two of them are better not to run yet): <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">add-cmd</span></span> hi (<span class="hljs-name"><span class="hljs-name">princ</span></span> <span class="hljs-string"><span class="hljs-string">"Hi, "</span></span>)) (<span class="hljs-name"><span class="hljs-name">add-cmd</span></span> quit (<span class="hljs-name"><span class="hljs-name">setf</span></span> program <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) (<span class="hljs-name"><span class="hljs-name">add-cmd</span></span> reset (<span class="hljs-name"><span class="hljs-name">setf</span></span> program (<span class="hljs-name"><span class="hljs-name">start-program</span></span>)))</code> </pre> <br>  More useful will be the ability to save to a program file and then download it from a file.  Define the appropriate save and load commands: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">add-cmd</span></span> save (<span class="hljs-name"><span class="hljs-name">with-open-file</span></span> (<span class="hljs-name"><span class="hljs-name">stream</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> input) <span class="hljs-symbol"><span class="hljs-symbol">:direction</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:output</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:if-exists</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:overwrite</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:if-does-not-exist</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:create</span></span>) (<span class="hljs-name"><span class="hljs-name">print</span></span> program stream))) (<span class="hljs-name"><span class="hljs-name">add-cmd</span></span> load (<span class="hljs-name"><span class="hljs-name">setf</span></span> program (<span class="hljs-name"><span class="hljs-name">with-open-file</span></span> (<span class="hljs-name"><span class="hljs-name">stream</span></span> (<span class="hljs-name"><span class="hljs-name">cadr</span></span> input)) (<span class="hljs-name"><span class="hljs-name">read</span></span> stream))))</code> </pre> <br>  Now we can save our work in any text file and download them from there.  But it should be remembered that we save and load only the contents of the program;  All the functions defined by us with the eval + defun command are not saved in these files, they are stored in the interpreter's memory.  It is possible to correct this annoying misunderstanding, but we will not touch it now. <br><br><pre> <code class="lisp hljs">$&gt; (<span class="hljs-name"><span class="hljs-name">save</span></span> <span class="hljs-string"><span class="hljs-string">"1.txt"</span></span>) $&gt; (<span class="hljs-name"><span class="hljs-name">load</span></span> <span class="hljs-string"><span class="hljs-string">"1.txt"</span></span>)</code> </pre> <br><br><h4>  Customization </h4><br><img src="https://habrastorage.org/storage2/664/004/214/664004214b00ee19a6952a2146cfa20f.png"><br>  For a change, let's customize our dialogue.  For example, add a funny greeting function: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">eval</span></span> (<span class="hljs-name"><span class="hljs-name">defun</span></span> greeting () (<span class="hljs-name"><span class="hljs-name">let</span></span> ((<span class="hljs-name"><span class="hljs-name">sentences</span></span> (<span class="hljs-name"><span class="hljs-name">vector</span></span> <span class="hljs-string"><span class="hljs-string">"My life for Ner'zhul. "</span></span> <span class="hljs-string"><span class="hljs-string">"I wish only to serve. "</span></span> <span class="hljs-string"><span class="hljs-string">"Thy bidding, master? "</span></span> <span class="hljs-string"><span class="hljs-string">"Where shall my blood be spilled? "</span></span> <span class="hljs-string"><span class="hljs-string">"I bow to your will. "</span></span> ))) (<span class="hljs-name"><span class="hljs-name">elt</span></span> sentences (<span class="hljs-name"><span class="hljs-name">random</span></span> (<span class="hljs-name"><span class="hljs-name">length</span></span> sentences))) ) ) )</code> </pre> <br>  Now apply them to the shell: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">code</span></span> (<span class="hljs-name"><span class="hljs-name">rsubs</span></span> '<span class="hljs-string"><span class="hljs-string">"$&gt; "</span></span> '(greeting) program))</code> </pre> <br>  It will turn out something like: <br><br><pre> <code class="lisp hljs">I bow to your will. (<span class="hljs-name"><span class="hljs-name">hi</span></span>) Hi, I wish only to serve.</code> </pre> <br>  Finally, I propose to get rid of unnecessary brackets by replacing (read) with something more complicated: we will read the string and frame it with brackets ourselves. <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">code</span></span> (<span class="hljs-name"><span class="hljs-name">rsubs</span></span> '(read) '(read-from-string (concatenate 'string <span class="hljs-string"><span class="hljs-string">"("</span></span> (read-line) <span class="hljs-string"><span class="hljs-string">")"</span></span>)) program))</code> </pre> <br>  Result: <br><br><pre> <code class="lisp hljs">Thy bidding, master? hi Hi, Where shall my blood be spilled?</code> </pre> <br>  Let's take another look at the code again: <br><br><div class="spoiler">  <b class="spoiler_title">Final result</b> <div class="spoiler_text"><pre> <code class="lisp hljs">Thy bidding, master? view ---code--- (<span class="hljs-name"><span class="hljs-name">LAMBDA</span></span> (<span class="hljs-name"><span class="hljs-name">PROGRAM</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINC</span></span> (<span class="hljs-name"><span class="hljs-name">GREETING</span></span>)) (<span class="hljs-name"><span class="hljs-name">LET</span></span> ((<span class="hljs-name"><span class="hljs-name">INPUT</span></span> (<span class="hljs-name"><span class="hljs-name">READ-FROM-STRING</span></span> (<span class="hljs-name"><span class="hljs-name">CONCATENATE</span></span> 'STRING <span class="hljs-string"><span class="hljs-string">"("</span></span> (<span class="hljs-name"><span class="hljs-name">READ-LINE</span></span>) <span class="hljs-string"><span class="hljs-string">")"</span></span>)))) (<span class="hljs-name"><span class="hljs-name">WHEN</span></span> (<span class="hljs-name"><span class="hljs-name">LISTP</span></span> INPUT) (<span class="hljs-name"><span class="hljs-name">LET</span></span> ((<span class="hljs-name"><span class="hljs-name">COMMAND</span></span> (<span class="hljs-name"><span class="hljs-name">CAR</span></span> INPUT))) (<span class="hljs-name"><span class="hljs-name">COND</span></span> ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> T NIL) 'SECRET-MARKER) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'LOAD) (<span class="hljs-name"><span class="hljs-name">SETF</span></span> PROGRAM (<span class="hljs-name"><span class="hljs-name">WITH-OPEN-FILE</span></span> (<span class="hljs-name"><span class="hljs-name">STREAM</span></span> (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT)) (<span class="hljs-name"><span class="hljs-name">READ</span></span> STREAM)))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'SAVE) (<span class="hljs-name"><span class="hljs-name">WITH-OPEN-FILE</span></span> (<span class="hljs-name"><span class="hljs-name">STREAM</span></span> (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT) <span class="hljs-symbol"><span class="hljs-symbol">:DIRECTION</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:OUTPUT</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:IF-EXISTS</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:OVERWRITE</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:IF-DOES-NOT-EXIST</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:CREATE</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINT</span></span> PROGRAM STREAM))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'RESET) (<span class="hljs-name"><span class="hljs-name">SETF</span></span> PROGRAM (<span class="hljs-name"><span class="hljs-name">START-PROGRAM</span></span>))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'QUIT) (<span class="hljs-name"><span class="hljs-name">SETF</span></span> PROGRAM NIL)) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'HI) (<span class="hljs-name"><span class="hljs-name">PRINC</span></span> <span class="hljs-string"><span class="hljs-string">"Hi, "</span></span>)) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'ADD-CMD) (<span class="hljs-name"><span class="hljs-name">SETF</span></span> PROGRAM (<span class="hljs-name"><span class="hljs-name">ADD-COMMAND-TO-PROGRAM</span></span> PROGRAM (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT) (<span class="hljs-name"><span class="hljs-name">CADDR</span></span> INPUT)))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'VIEW) (<span class="hljs-name"><span class="hljs-name">PROGN</span></span> (<span class="hljs-name"><span class="hljs-name">FORMAT</span></span> T <span class="hljs-string"><span class="hljs-string">"---code---"</span></span>) (<span class="hljs-name"><span class="hljs-name">PRINT</span></span> PROGRAM) (<span class="hljs-name"><span class="hljs-name">TERPRI</span></span>))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'CODE) (<span class="hljs-name"><span class="hljs-name">SETF</span></span> PROGRAM (<span class="hljs-name"><span class="hljs-name">FUNCALL</span></span> (<span class="hljs-name"><span class="hljs-name">EVAL</span></span> (<span class="hljs-name"><span class="hljs-name">LIST</span></span> 'LAMBDA '(PROGRAM INPUT) (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT))) PROGRAM INPUT))) ((<span class="hljs-name"><span class="hljs-name">EQ</span></span> COMMAND 'EVAL) (<span class="hljs-name"><span class="hljs-name">EVAL</span></span> (<span class="hljs-name"><span class="hljs-name">CADR</span></span> INPUT))) (<span class="hljs-name"><span class="hljs-name">T</span></span> (<span class="hljs-name"><span class="hljs-name">FORMAT</span></span> T <span class="hljs-string"><span class="hljs-string">"Unknown command ~A ~%"</span></span> COMMAND))))) PROGRAM)) My life for Ner'zhul.</code> </pre></div></div><br>  With this thing you can have fun as you like!  But enough for today. </div><p>Source: <a href="https://habr.com/ru/post/165095/">https://habr.com/ru/post/165095/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../165085/index.html">JS module for Java developers</a></li>
<li><a href="../165087/index.html">The simplest image clustering by the k-means method (k-means)</a></li>
<li><a href="../165089/index.html">XIMA Chronicall emergency troubleshooting telephone monitoring and reporting system</a></li>
<li><a href="../165091/index.html">13 reasons not to be a manager</a></li>
<li><a href="../165093/index.html">A brief, incomplete, and mostly incorrect history of programming languages</a></li>
<li><a href="../165097/index.html">EC2 - price analysis for a startup</a></li>
<li><a href="../165103/index.html">Video digest of the latest gaming industry news | Geek Week # 7</a></li>
<li><a href="../165105/index.html">Programming on Android for a web developer or a quick start for the little ones. Part 1</a></li>
<li><a href="../165107/index.html">Index access to Multibyte PHP strings or learning OOP in practice</a></li>
<li><a href="../165109/index.html">Curiosity launched the first stage of terraforming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>