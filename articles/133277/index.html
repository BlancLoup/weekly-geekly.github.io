<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hask category</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this short article I will talk about category theory in the context of the Haskell type system. No zaumy, no tricks - I will try to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hask category</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  In this short article I will talk about category theory in the context of the Haskell type system.  No zaumy, no tricks - I will try to explain everything clearly.  I want to show the close connection of a programming language with mathematics in order to provoke the reader's awareness of one thing, through the other and vice versa. <br><br>  I would not like to repeat the translation on this topic, which was already on Habr√©: <a href="http://habrahabr.ru/blogs/programming/125782/">Monads from the point of view of category theory</a> , but for the integrity of the article, I will still give basic definitions.  At the same time, unlike the article, I do not want to focus on mathematics. <br><br>  This article largely repeats (including borrowing illustrations) a section from the English <a href="http://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell Wikibook</a> , but nonetheless is not a direct translation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  What is a category? </h2><br><br><h3>  Examples </h3><br>  For clarity, we first consider a couple of pictures depicting simple categories.  They have red circles and arrows: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/7c2/1f1/ae87c21f1921961432f4e81d1dde1aa5.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfe/588/ccf/bfe588ccf7515c8d4a6ec296b10c6686.png"></div><br>  Red circles represent ‚Äúobjects‚Äù, and arrows - ‚Äúmorphisms‚Äù. <br><br>  I want to give one illustrative example from real life, which will give some intuitive insight into the nature of objects and morphisms: <br><br>  Cities can be considered ‚Äúobjects‚Äù, and movements between cities - ‚Äúmorphisms‚Äù.  For example, you can imagine a flight map (I somehow did not find a good picture) or a railroad map - they will look like the pictures above, only more complicated.  Attention should be paid to two points that seem to be taken for granted, but are important for the future: <br><ul><li>  It happens that there is no way to get from one city to another by train or by plane - there are no morphisms between these cities. </li><li>  If we move within the same city, then this is also a morphism - we are traveling from the city to it, as it were. </li><li>  If there is a train from St. Petersburg to Moscow, and from Moscow there is a flight to Amsterdam, then we can buy a train ticket and a plane ticket, ‚Äúcombine‚Äù them and thus get from St. Petersburg to Amsterdam - that is, you can map draw an arrow from St. Petersburg to Amsterdam depicting this combined morphism. </li></ul>  I hope everything is clear with this example.  And now a little formalism for clarity. <a name="habracut"></a><br><br><h3>  Definition </h3><br>  So, we already know that a category consists of objects and morphisms: <br><ol><li>  There is a <i>class (set) of objects</i> .  Objects can be any entities. </li><li> For any two objects <code>A</code> and <code>B</code> , the <i>class of morphisms</i> <code>Hom(A,B)</code> defined.  For a morphism <code>f</code> from this class, the object <code>A</code> is called a <i>domain</i> , and <code>B</code> is a <i>co</i> - <i>domain</i> .  It is written like this: <br>  <code>f ‚àà Hom(A,B)</code> or <code>f : A ‚Üí B</code> </li><li>  For any two morphisms <code>f : A ‚Üí B</code> and <code>g : B ‚Üí C</code> , their <i>composition</i> is defined ‚Äî the morphism <code>h = g ‚àò f</code> , <br>  <code>h : A ‚Üí C</code>  It is important that the domain <code>g</code> and the domain <code>f</code> coincide. </li><li>  The composition is <i>associative</i> , that is, for any morphisms <code>f : A ‚Üí B</code> , <code>g : B ‚Üí C</code> and <code>h : C ‚Üí D</code> , the equality <br> <code>(h ‚àò g) ‚àò f = h ‚àò (g ‚àò f)</code> </li> <li>  For any object <code>A</code> there is a ‚Äúunit‚Äù morphism, which is denoted <code>id</code> <sub><code>A</code></sub> <code>: A ‚Üí A</code> and it is neutral with respect to the composition, that is, for any morphism <code>f : A ‚Üí B</code> satisfied: <br>  <code>id</code> <sub><code>B</code></sub> <code>‚àò f = f = f ‚àò id</code> <sub><code>A</code></sub> </li></ol>  In the future, the index will bother me and I will write just <code>id</code> , since its area / area is restored from the context. <br><br>  It can be verified that for the examples above, all the properties are fulfilled: the composition is defined when necessary, associative, and the corresponding isolated morphisms are neutral with respect to it.  The only problem arises from the associativity in the example about moving between cities - here you need to think about the composition as ‚Äúcombining tickets‚Äù, and not just sequential movements of a particular person. <br><br>  Exercise for self-test: check whether the following picture represents a category <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/d28/8fd/7ddd288fd236e4df73aad9a63946b2e4.png"></div><br><br><br><h2>  Hask category </h2><br>  And now the main example, the main topic of the article.  The <b>Hask</b> category consists of Haskell language types and functions between them.  More strictly: <br><ol><li>  <b>Hask</b> objects: data types with <sup><a href="https://habr.com/ru/post/133277/">1</a></sup> <code>*</code> .  For example, primitive types: <code>Integer</code> , <code>Bool</code> , <code>Char</code> , etc.  The ‚ÄúType‚Äù <code>Maybe</code> has a command <code>* ‚Üí *</code> , but the type <code>Maybe Bool</code> has a command <code>*</code> and is therefore an object in <b>Hask</b> .  The same with any parameterized types, but about them later.  Notation: <code>a ‚à∑ *</code> ‚â° ‚Äútype <code>a</code> has a keynd <code>*</code> ‚Äù ‚â° ‚Äú <code>a</code> is an object in <b>Hask</b> ‚Äù. </li><li>  <b>Hask morphisms</b> : any Haskell functions from one object (type) to another.  If <code>a, b ‚à∑ *</code> , then the function <code>f ‚à∑ a ‚Üí b</code> is a morphism with a domain <code>a</code> and a domain <code>b</code> .  Thus, the class of morphisms between objects <code>a</code> and <code>b</code> is denoted by the type <code>a ‚Üí b</code> .  For completeness of the analogy with mathematical notation, we can introduce the following synonym: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Hom</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">,</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) = a ‚Üí b</span></span></code> </pre>  But I will not continue to use it, since the arrow, in my opinion, is clearer. </li><li>  Composition: standard function <code>(.) ‚à∑ (b ‚Üí c) ‚Üí (a ‚Üí b) ‚Üí (a ‚Üí c)</code> .  For any two functions <code>f ‚à∑ a ‚Üí b</code> and <code>g ‚à∑ b ‚Üí c</code> composition is <code>g . f ‚à∑ a ‚Üí c</code>  <code>g . f ‚à∑ a ‚Üí c</code> is determined in a natural way: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">g</span></span> . f = Œªx ‚Üí g (fx)</code> </pre> </li><li>  The composition associativity is obvious from this definition: For any three functions <br>  <code>f ‚à∑ a ‚Üí b</code> , <code>g ‚à∑ b ‚Üí c</code> and <code>h ‚à∑ c ‚Üí d</code> <br><pre> <code class="hljs">(h . g) . f ‚â° h . (g . f) ‚â° Œªx ‚Üí h (g (fx))</code> </pre>  Direct check: <pre> <code class="hljs"> (h . g) . f ‚â° Œªx ‚Üí (h . g) (fx) ‚â° Œªx ‚Üí (Œªy ‚Üí h (gy)) (fx) ‚â° Œªx ‚Üí h (g (fx)) h . (g . f) ‚â° Œªx ‚Üí h ((g . f) x) ‚â° Œªx ‚Üí h ((Œªy ‚Üí g (fy)) x) ‚â° Œªx ‚Üí h (g (fx))</code> </pre> </li><li>  For any type <code>a ‚à∑ *</code> function <code>id ‚à∑ a ‚Üí a</code> is also defined in a natural way: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">id</span></span> = Œªx ‚Üí x</code> </pre>  From this definition, the execution of the required properties is obvious.  Let <code>f ‚à∑ a ‚Üí b</code> <br><pre> <code class="hljs objectivec">f . <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚â° Œªx ‚Üí f (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> x) ‚â° Œªx ‚Üí fx ‚â° f <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> . f ‚â° Œªx ‚Üí <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> (fx) ‚â° Œªx ‚Üí fx ‚â° f</code> </pre></li></ol>  This function is polymorphic, so it is one for all, but from the point of view of a single morphism, we will perceive it as a separate morphism for each specific type, for example, for a <code>Char</code> object it will be a monomorphic function <code>id ‚à∑ Char ‚Üí Char</code> .  That's why I said before about the index - in Haskell, you can not write every time what <code>id</code> we need, because its type is automatically taken out of context. <br><br>  So, as we see, all the required entities are present, their interrelationships are presented, and the required properties are fulfilled, so <b>Hask</b> is a full-fledged category.  Notice how all concepts and constructs are transferred from mathematical notation to Haskell with minimal syntactic changes. <br><br>  Then I will talk about what functors are and how they are embodied in the category <b>Hask</b> . <br><br><h2>  Functors </h2><br>  Functors are transformations from one category to another.  Since each category consists of objects and morphisms, the functor should consist of a pair of mappings: one will match objects from the first category to objects in the second, and the other will map to morphisms from the first category ‚Äî morphisms to the second. <br><br>  First I will give a mathematical definition, and then I will demonstrate how simple it becomes in the case of Haskell. <br><br><h3>  Mathematical definition </h3><br>  Consider two categories <code><b>C</b></code> and <code><b>D</b></code> and the functor <code>F</code> from <code><b>C</b></code> to <code><b>D</b></code>  The notation used is the same as for morphisms, only the functor is denoted by a capital letter: <code>F : <b>C</b> ‚Üí <b>D</b></code>  This <code>F</code> performs two roles: <br><ol><li>  Each object <code>A</code> from category <code><b>C</b></code> is associated with an object from category <code><b>D</b></code> and is denoted by <code>F(A)</code> . </li><li>  Each morphism <code>g : A ‚Üí B</code> from category <code><b>C</b></code> is associated with a morphism from category <code><b>D</b></code> and denoted by <code>F(g) : F(A) ‚Üí F(B)</code> . </li></ol>  Once again, a functor is a pair of mappings: <br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">A</span></span> ‚Ü¶ F(A) g : A ‚Üí B ‚Ü¶ F(g) : F(A) ‚Üí F(B)</code> </pre><br>  In the picture, the first display is depicted with yellow dotted arrows, and the second is blue: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f8/4b7/7a4/0f84b77a4fecdcadbf91c2e7094afa6b.png"></div><br><br>  The functor is required to fulfill two completely natural requirements: <br><ol><li>  He must translate every single morphism of a given object into a single morphism of its image: <br>  <code>F(id</code> <sub><code>A</code></sub> <code>) = id</code> <sub><code>F(A)</code></sub> </li><li>  He must translate the composition of morphisms into the composition of their images: <br> <code>F(h ‚àò g) = F(h) ‚àò F(g)</code> </li> </ol><br><br><h3>  Functors in Hask </h3><br>  Now we look at functors from the <b>Hask</b> category in <b>Hask</b> .  By the way, such functors that translate a category into it are called <i>endofunctors</i> . <br><br>  So, then we need to translate types into types, and functions in functions are two mappings.  And what is the construction language Haskell embodies the first?  That's right, types with a knight <code>* ‚Üí *</code> . <br><br>  For example, the <code>Maybe ‚à∑ * ‚Üí *</code> type mentioned already <code>Maybe ‚à∑ * ‚Üí *</code> .  This is a mapping that matches to any object <code>a ‚à∑ *</code> an object from the same category <code>(Maybe a) ‚à∑ *</code> .  Here, <code>Maybe a</code> should be taken not as a constructor of a parameterized type with a given parameter <code>a</code> , but as a single character, similar to <code>F(A)</code> from a mathematical definition. <br><br>  So, the first mapping comes to us for nothing - this is any type constructor with a parameter. <br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> Maybe a = <span class="hljs-built_in"><span class="hljs-built_in">Nothing</span></span> | Just a</code> </pre><br>  But how to get the second display?  To do this, Haskell has a special class defined: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap ‚à∑ (a ‚Üí b) ‚Üí (fa ‚Üí fb)</code> </pre>  where <code>f ‚à∑ * ‚Üí *</code> .  That is, <code>fmap</code> is a polymorphic function that takes the morphism <code>a ‚Üí b</code> , and returns the morphism <code>fa ‚Üí fb</code> .  Based on this, we will make <code>Maybe</code> real functor, defining the following function for it: <br><pre> <code class="hljs bash"> instance Functor Maybe <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> fmap g = <span class="hljs-built_in"><span class="hljs-built_in">fg</span></span> <span class="hljs-built_in"><span class="hljs-built_in">where</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fg</span></span> Nothing = Nothing <span class="hljs-built_in"><span class="hljs-built_in">fg</span></span> (Just x) = Just (gx)</code> </pre><br>  So, we got two maps: <br><pre> <code class="hljs markdown"> a ‚à∑ <span class="hljs-bullet"><span class="hljs-bullet">* ‚Ü¶ Maybe a ‚à∑ *</span></span> g ‚à∑ a ‚Üí b ‚Ü¶ fmap g ‚à∑ Maybe a ‚Üí Maybe b</code> </pre><br>  There is nothing that, unlike mathematical notation, they have different names, it is just the specificity of the language, which does not affect the meaning. <br><br>  Well, what about meeting the requirements?  <code>fmap</code> must save the <code>id</code> and translate the composition into the composition: <br><pre> <code class="hljs objectivec"> fmap <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> ‚â° <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> fmap (h . g) ‚â° (fmap h) . (fmap g)</code> </pre><br>  It is easy to verify this in the case of the above definition of <code>fmap</code> for <code>Maybe</code> . <br><br>  Notice that we get the first mapping by simply declaring a type constructor with a parameter.  And for him, as for the mapping between objects, it does not matter how the <code>Maybe</code> type is arranged: it simply associates with the object <code>a</code> object <code>Maybe a</code> , whatever that may be. <br><br>  In the case of the display of morphisms, everything is not so simple: we have to manually define <code>fmap</code> , taking into account the <code>Maybe</code> structure.  On the one hand, this gives us a certain flexibility - we decide how a function will transform a specific data structure.  But on the other hand, it would be convenient to receive this definition for nothing, if we want it to be organized in a natural way.  For example, for the type <br><pre> <code class="hljs haskell"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> [a] | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Buz</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Char</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Qux</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre>  the function <code>g ‚à∑ a ‚Üí b</code> should recursively bypass all data constructors and wherever they have a parameter of type <code>a</code> convert it with <code>g</code> .  Moreover, if <code>[a]</code> or <code>Maybe a</code> is encountered, then their <code>fmap g</code> should work for them, which again bypasses their structure and transforms it. <br><br>  And lo and behold, it is possible!  GHC has a <a href="http://haskell.org/ghc/docs/6.12.1/html/users_guide/deriving.html">corresponding extension</a> .  We write in the code: <br><pre> <code class="hljs haskell"> <span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DeriveFunctor #-}</span></span> ‚Ä¶ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = ‚Ä¶ </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span></span></code> </pre><br>  And we immediately get a full <b>end</b> - <b>function of the</b> category <b>Hask</b> - <code>Foo</code> , with the corresponding <code>fmap</code> . <br><br>  By the way, it should be said that these functors actually map the <b>Hask</b> category into its <i>subcategory</i> , that is, into a category with a smaller class of objects and morphisms.  For example, by displaying <code>a ‚Ü¶ Maybe a</code> we can‚Äôt get a simple type <code>Int</code> - whatever <code>a</code> we took.  Nevertheless, the resulting subclass of objects and the class of functions on them as morphisms also form a category. <br><br>  In the Functor class <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Functor.html">documentation,</a> you can also see a list of types for which the embodiment was originally defined.  But they are mainly made in order to then say that this type is a monad. <br><br><h2>  Conclusion </h2><br>  So, I talked about the <b>Hask</b> category and the functors in it, and I hope it helped to realize the Haskell type system from a new perspective.  Perhaps it seems useless from a practical point of view, since the meaning of <code>fmap</code> everyone probably understands in its own way and without knowing what a functor is.  But then I‚Äôm going to write about natural transformations, monads and other categorical constructions in the key of the <b>Hask</b> category and then, I think, mathematical analogies will be more useful, allowing you to better understand the inner nature of these constructions of the language and apply them further more consciously. <br><hr><ol><li>  If who did not meet earlier with kaynd (kinds), I will explain in two words.  Kaynda is something like a type system over ordinary types.  Kaynda are of two types: <br><ul><li>  <code>*</code> - this is a simple, not parameterized type.  For example, <code>Bool</code> , <code>Char</code> , etc.  Custom <code>data Foo = Bar | Buz (Maybe Foo) | Quux [Int]</code> type <code>data Foo = Bar | Buz (Maybe Foo) | Quux [Int]</code> <code>data Foo = Bar | Buz (Maybe Foo) | Quux [Int]</code>  <code>data Foo = Bar | Buz (Maybe Foo) | Quux [Int]</code> will also be simple: <code>Foo ‚à∑ *</code> , because the <i>type constructor</i> has no parameters (although its <i>data constructors</i> have) </li><li>  <code>‚Ä¶ ‚Üí ‚Ä¶</code> - this is a more complicated keynd, it can have any other keyes composed of <code>*</code> and <code>‚Üí</code> on the ground ellipsis.  For example: <code>[] ‚à∑ * ‚Üí *</code> , or <code>(,) ‚à∑ * ‚Üí (* ‚Üí *)</code> or anything else more complicated: <code>((* ‚Üí *) ‚Üí *) ‚Üí (* ‚Üí *)</code> . </li></ul><br>  The meaning of all this is simple: type constructors are kind of functions on types and describe how these functions interact correctly.  For example, we cannot write <code>[Maybe]</code> , because <code>[] ‚à∑ * ‚Üí *</code> , that is, the argument of the parentheses must have a kand <code>*</code> , while <code>Maybe</code> it has <code>* ‚Üí *</code> , that is, <code>Maybe</code> also a function and if we give it an argument <code>Int ‚à∑ *</code> , then we get <code>Maybe Int ‚à∑ *</code> and we can already pass it to the brackets: <code>[Maybe Int] ‚à∑ *</code> .  For this kind of control, the kayndas exist. <a href="https://habr.com/ru/post/133277/"></a></li></ol><br></div><p>Source: <a href="https://habr.com/ru/post/133277/">https://habr.com/ru/post/133277/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133269/index.html">Detachment of special opinion</a></li>
<li><a href="../133270/index.html">Custom annotations in symfony 2</a></li>
<li><a href="../133272/index.html">"Premium" War Runet</a></li>
<li><a href="../133274/index.html">Why large messengers do not work with XMPP or Reflections on the fate of the protocol</a></li>
<li><a href="../133276/index.html">CSS3. Work with shadows. Part 1</a></li>
<li><a href="../133278/index.html">Prototypes of new JavaScript extensions</a></li>
<li><a href="../133279/index.html">Installing Windows 8 will be 50% faster</a></li>
<li><a href="../133280/index.html">HTC Desire S - video footage</a></li>
<li><a href="../133281/index.html">Quick start - we program on Go under Windows - the Environment setup</a></li>
<li><a href="../133282/index.html">TripAdvisor and Blackmail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>