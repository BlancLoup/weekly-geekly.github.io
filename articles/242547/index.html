<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: A new beginning</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Runs to the south and turns to the north, turns, wind turns on its run, 
 And the wind returns to its full circle; 
 All the rivers run into the sea, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: A new beginning</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/files/c97/a13/699/c97a13699b5b4bb98ffe09c0be6860fe.PNG">  <b><i>Runs to the south and turns to the north, turns, wind turns on its run,</i></b> <b><i><br></i></b>  <b><i>And the wind returns to its full circle;</i></b> <b><i><br></i></b>  <b><i>All the rivers run into the sea, - and the sea does not overflow,</i></b> <b><i><br></i></b>  <b><i>To the place where the rivers run, - There they continue to run;</i></b> <b><i><br><br></i></b>  <b><i><a href="http://lib.ru/HRISTIAN/ekkleziast.txt">Book of Ecclesiastes</a> .</i></b> <br><br>  In 1998, a completely unique, for its time, application was developed, allowing to reduce the process of developing an abstract board game (or puzzle) to a small textual description in a language remotely resembling <a href="http://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2581%25D0%25BF">Lisp</a> .  This project was named <a href="http://www.zillions-of-games.com/">Zillions of Games</a> and created a real sensation among board game lovers.  Currently, more than 2000 applications have been created using this technology. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It quickly became clear that <b>ZoG</b> has many flaws.  I already <a href="http://habrahabr.ru/post/221779/">wrote</a> about this on Habr√© and will not be repeated.  Let me just say that the developers did not take into account the peculiarities of a huge number of already existing games, and some of the important options were ‚Äúhard-coded‚Äù in such a way that their change became extremely problematic.  Greg Schmidt, in 2007, tried to correct the situation by releasing the <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom Development Kit</a> , but the close integration of this solution with <b>ZoG</b> did not solve all the problems. <br><br>  The <a href="http://www.cameronius.com/cv/publications/ciaig-browne-maire-19.pdf">Ludi</a> project has identified new frontiers using a universal game ‚Äúengine‚Äù and <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B5%25D0%25BD%25D0%25B5%25D1%2582%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25B0%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC">genetic algorithms</a> to automate the process of developing new board games.  Unfortunately, this approach initially included a conscious simplification of both the game mechanics and the level of AI used.  A discussion of the objectives of this project is beyond the scope of this article, but some of its technical solutions undoubtedly served as a starting point for starting my own development. <br><br>  My goal is to develop a more versatile and easy-to-use "engine" for creating abstract board games.  For almost a year I have been studying the possibilities of <b>ZoG</b> and <b>Axiom</b> and learned a lot about their limitations.  I think I can solve their problems by creating a more universal and cross-platform solution.  I am going to tell you about the progress of this project. <br><a name="habracut"></a><br><h4>  <b>Openness and modularity</b> </h4><br>  Perhaps the main drawback of <b>ZoG</b> is its secrecy.  The product is assembled "once and for all" under one single platform - Windows.  If the source codes were open, you could try porting them to Linux, Android, iOS ... Another problem is solidity. <br><br>  <b>ZoG</b> has the beginnings of modularity, allowing you to connect to games <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B0%25D0%25B5%25D0%25BC%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25B8%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25BE%25D1%2582%25D0%25B5%25D0%25BA%25D0%25B0">DLL</a> containing custom AI implementations.  <b>Axiom</b> goes a little further, allowing you to run applications in <b>autoplay</b> mode, without using the <b>ZoG</b> kernel.  Even despite the serious limitation of this solution (only two-player applications are supported), this example clearly shows how useful modularity would be!  The ability to organize a game of two bots (using different AI settings) and collect statistics on a large number of their games is difficult to overestimate.  But how much better it would be if the product were completely modular! <br><br><ul><li>  Move Generation Module </li><li>  Progress module </li><li>  Control module </li><li>  AI module </li><li>  Visualization module </li></ul><br>  All work with the description of the games must be performed by the module for generating moves.  This is the "heart" of the project.  Transferring all the functionality not related to its tasks to other modules will make it as simple as possible.  You can improve this module without looking at questions of AI and user interaction.  You can completely change the format of the description of the games or add support for descriptions in the format <b>ZoG</b> , <b>Axiom</b> and <b>Ludi</b> .  Modularity is the basis of the flexibility of the solution! <br><br>  A turn execution module is a game state keeper.  Information about the current game state is transmitted to all other modules on demand.  For the reasons that I will discuss below, the execution of a move must pass through a generation module whose task is to form a command in terms of the progress execution module.  Also, the task of the generation module is the primary configuration of the game space, based on the game description. <br><br>  The control module is essentially the application itself.  He asks the generation module for lists of possible moves and changes the game state, passing the selected turn to the progress module.  The control module can connect one or several AI bots to the game.  As much as required (and possibly different)!  The type of control module used is determined by the tasks to be solved.  This can be <b>autoplay</b> for collecting game statistics, a game server (it can manage several state repositories at once, leading a large number of game sessions) or an individual application for playing offline. <br><br>  The ability to connect various AI implementations will improve the quality of the game.  It is clear that the modules for the game of Chess and Go must use different approaches.  Games with incomplete information and games using random data also require an individual approach.  Universal AI implementation will be equally bad to play all games!  The modular connection of the AI ‚Äã‚Äãwill allow you to compare the "power" of the algorithms used, including them in the game mode "between themselves".  Since AI is architecturally separated from the game state storage, one implementation of the game bot will be able to support an unlimited number of game sessions simultaneously. <br><br>  The visualization of the gameplay can also be different.  The first thing that comes to mind is 2D and 3D implementations.  The platform for which the application is being developed is also important.  It is less obvious that visualization can be an important part of the gameplay!  For example, in the <a href="http://www.iggamecenter.com/info/ru/surakarta.html">Surakarta</a> game, the capture of figures will be completely unobvious in the absence of proper animation of the moves. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9ad/1cd/c7c/9ad1cdc7c76041dc8776c5f4cb1a086a.jpg"></div><br>  In general, modularity seems like a good idea for such a project, and open source codes will allow everyone to participate in it.  Currently, I do not set myself commercial goals, but I think that, if desired, I will find a way to make money without closing the source codes. <br><br><h4>  <b>Gaming space</b> </h4><br>  Before starting the performance, it is necessary to prepare the scene.  The board is not just a place where figures are placed.  In addition, the directions of movement of the figures (in fact, the connection between the board fields), gaming areas (for example, the zones of transformation of figures), forbidden fields, etc. can be determined.  Here is the definition of the board in the ZoG chess implementation: <br><br><div class="spoiler">  <b class="spoiler_title">ZoG board definition</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> Board-Definitions (<span class="hljs-name"><span class="hljs-name">image</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\Chess8x8.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\Chess8x8.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">grid</span></span> (<span class="hljs-name"><span class="hljs-name">start-rectangle</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span> <span class="hljs-number"><span class="hljs-number">53</span></span>) (<span class="hljs-name"><span class="hljs-name">dimensions</span></span> (<span class="hljs-string"><span class="hljs-string">"a/b/c/d/e/f/g/h"</span></span> (<span class="hljs-number"><span class="hljs-number">49</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-comment"><span class="hljs-comment">; files ("8/7/6/5/4/3/2/1" (0 49)) ; ranks ) (directions (n 0 -1) (e 1 0) (s 0 1) (w -1 0) (ne 1 -1) (nw -1 -1) (se 1 1) (sw -1 1) ) ) (symmetry Black (ns)(sn) (nw sw)(sw nw) (ne se)(se ne)) (zone (name promotion-zone) (players White) (positions a8 b8 c8 d8 e8 f8 g8 h8) ) (zone (name promotion-zone) (players Black) (positions a1 b1 c1 d1 e1 f1 g1 h1) ) (zone (name third-rank) (players White) (positions a3 b3 c3 d3 e3 f3 g3 h3) ) (zone (name third-rank) (players Black) (positions a6 b6 c6 d6 e6 f6 g6 h6) ) )</span></span></code> </pre> <br></div></div><br>  You may notice that in addition to the actual game settings, there are settings associated with visualization.  I firmly believe that these settings are not the place.  There may be several implementations of the visualization module and they will need different settings.  Moreover, the game simulation can work without a visualization module at all (as <b>autoplay</b> in <b>Axiom</b> ).  Indeed, since <b>Axiom</b> uses <b>ZoG</b> for visualization, the definition does not contain anything extra: <br><br><div class="spoiler">  <b class="spoiler_title">Axiom board definition</b> <div class="spoiler_text"><pre> <code class="lisp hljs">{board <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> {grid} board} {directions <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> {direction} n <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> {direction} s <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {direction} e <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> {direction} w <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> {direction} nw <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> {direction} sw <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {direction} ne <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> {direction} se directions} {symmetries Black {symmetry} ns Black {symmetry} nw sw Black {symmetry} ne se symmetries}</code> </pre><br></div></div><br>  Unfortunately, it also does not contain definitions of playing areas (the location of playing areas has to be determined in the code manually).  This is not the only simplification of the <b>Axiom</b> .  The definition of a board in this project cannot contain more than one <b>grid,</b> and this <b>grid</b> must be two-dimensional.  A board defined in this way is a one-dimensional array, but for the convenience of the programmer, synonyms are defined for each of the fields, according to the following scheme: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/4d2/76d/a04/4d276da04e6542a385c3c30deeb6872f.PNG"></div><br>  Compared to the more flexible <b>grid</b> definition scheme in <b>ZoG</b> , these restrictions are quite inconvenient (especially since the imposed field naming scheme is also used for visualization).  Fortunately, it is possible to define a board of arbitrary shape.  Both <b>Axiom</b> and <b>ZoG</b> provide the possibility of element-by-element determination of each position of the board with the possibility of determining the connections between arbitrary pairs of positions.  Using this approach, you can define a board of any topology.  Its only drawback is the extreme verbosity and complexity of the description. <br><br>  In addition to the arrangement of the pieces on the board and in the reserve, it must be possible to store attributes for individual pieces as well as for the board‚Äôs fields.  A good example of the need to use attributes is the " <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">castling</a> " rule in <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Chess</a> .  This is a complex move, which includes the simultaneous movement of the king and one of the rooks, possible under the condition that none of these pieces moved before the execution of this move.  The attribute can be used to store a boolean sign that the figure has moved ever.  Field attributes can also find some pretty interesting uses. <br><br>  It should be noted that the attributes are not just variables, but part of the game state.  The attribute value can be changed when performing a turn (including the AI ‚Äã‚Äãmodule) and should be available for all subsequent moves, but not for moves performed in another branch of the game.  Currently, <b>ZoG</b> supports storing boolean attributes of shapes.  <b>Axiom</b> does not support attribute storage, but allows adding a description of variables and arrays to the board definition.  Such variables can be used, for example, as counters of the number of eaten figures: <br><br><pre> <code class="lisp hljs">{board <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> {grid} {variable} WhitePieces {variable} BlackPieces board}</code> </pre><br>  Another limitation of both <b>ZoG</b> and <b>Axiom</b> is the rule that each field of the board can contain no more than one figure.  If any figure completes a move on a field occupied by another figure, the figure that previously occupied the field is automatically considered ‚Äúeaten‚Äù.  This rule is well combined with the ‚Äúchess‚Äù principle of taking figures and simplifies the descriptions of games using it, but makes it difficult to implement such games as <a href="http://www.iggamecenter.com/info/ru/bashni.html">Stolovye drafts</a> and <a href="http://www.iggamecenter.com/info/ru/tavreli.html">Tavreli</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/455/804/146/45580414699f406281745176b1d91d9b.JPG"></div><br>  In these games, the pieces can line up in ‚Äúcolumns.‚Äù  Such a "column" can move entirely as a single figure.  After some reflection, I decided that it was better not to abandon the automatic implementation of the ‚Äúchess‚Äù capture, but to improve the mechanisms for moving groups of pieces.  Indeed, to implement the ‚Äúcolumns‚Äù, you can always add another dimension to the board (this is all the more simple, since the visualization module will be separated from the modules for generating the moves and AI and it will be possible to use any logic to display the three-dimensional board on its two-dimensional visualization).  An additional argument in favor of this decision was that the ‚Äúcolumnar‚Äù movement of figures is not the only type of group movement.  For example, in <a href="https://s3-eu-west-1.amazonaws.com/mosigra.product.other/522/067/pentago.pdf">Pentago</a> , fragments of the board can be rotated, along with the shapes mounted on them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3f9/8db/7ba/3f98db7ba32042ec8dff2eb42878fa2e.jpg"></div><br>  Summarizing, we can say that for my game framework, I decided to take all the best that was invented in <b>ZoG</b> , <b>Axiom</b> and <b>Ludi</b> and add what, in my opinion, they lack. <br><br><h4>  <b>Generation</b> </h4><br>  Generating a move is akin to <a href="http://en.wikipedia.org/wiki/Nondeterministic_programming">non-deterministic programming</a> .  The task of the move generator is to provide, on request, a list of all possible moves from the current position.  Which move, from this list, will be chosen by the player or AI is not his business.  Consider exactly how the generation of moves in <b>ZoG</b> .  As an example, take the macro of the generation of the course by a long-range figure (queen or bishop).  Here is how it is used in determining the shape: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Bishop) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wbishop.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bbishop.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bbishop.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">slide</span></span> ne) (<span class="hljs-name"><span class="hljs-name">slide</span></span> nw) (<span class="hljs-name"><span class="hljs-name">slide</span></span> se) (<span class="hljs-name"><span class="hljs-name">slide</span></span> sw) ) )</code> </pre><br>  As a parameter, the direction of movement on the board is transferred to the macro.  If you do not consider the possibility of installing new pieces on the board, the generation of the move looks easy.  For each of the pieces on the board, all the moves determined by the rules are iterated.  Then the magic begins ... <br><br>  Each of the definitions can add to the list several possible moves!  Adding a move to the list is done with the <b>add</b> command (part-time setting the moving figure on the board).  I already <a href="http://habrahabr.ru/post/221779/">wrote</a> that such an architectural solution is extremely unfortunate.  The formation team must be separated from the teams that manipulate the figures (as was done in <b>Axiom</b> ).  Let's see how the macro works: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre><br>  First, a movement is performed one cell in a given direction, after which, in a cycle, the achieved field is checked for the absence of figures in it, a move is formed and another movement is made to another cell in the same direction.  If you stop at this, the figure will be able to "slide" on empty cells, but how to take enemy figures? <br><br>  Very simple!  Having <b>executed the</b> verify command, checking that the field is not occupied by a friendly figure, we form another <b>add</b> command, completing the move.  If an enemy figure was placed on this cell, it will be taken automatically (since more than one figure cannot be placed on one board field at a time).  If the figure was friendly, the calculation of the course is interrupted by the command <b>verify</b> (violation of the conditions specified in this command, immediately interrupts the calculation of the current course). <br><br>  Both in <b>ZoG</b> and <b>Axiom</b> you can only walk with your own figures (or rather, you can walk with enemy figures, but only if this is indicated in the mode of calculating the turn).  I find this restriction extremely inconvenient, since there are many games in which it is possible to walk around the opponent‚Äôs pieces (in the ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Stavropol checkers</a> ‚Äù, for example).  It would be more consistent to perform the calculation of the course for all figures, regardless of their affiliation.  It would be necessary to add just one check to the macro defining the move in order to walk only with your own figures: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> slide ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> friend?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? add $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> not-friend?) add ))</code> </pre><br>  The ability to make a move consisting of several ‚Äúpartial‚Äù moves is important.  In implementations of drafts, this feature is used to perform "chains" of taking: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> checker-jump ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not-in-zone</span></span>? promotion-zone) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) else (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> King jumptype) ) ) )</code> </pre><br>  The partial move is formed by the <b>add-partial</b> command (for it, as for the <b>add</b> command, there is a variant of the move, with the ‚Äútransformation‚Äù of the figure).  Such a move is always part of a larger, ‚Äúcomposite‚Äù move.  As a rule, for subsequent moves, a ‚Äúmode‚Äù is set in which the continuation should be carried out.  So in checkers, the capture can be continued only by subsequent captures, but not by a ‚Äúquiet‚Äù move. <br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  In <b>ZoG</b> , the implementation of partial moves leaves much to be desired.  Attempting to execute the <b>add-partial</b> command in a loop results in an error.  As a result, the taking performed by a lady can only be implemented in the following, very awkward way: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-1 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> king-jump-2 ($<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">while</span></span> empty? $<span class="hljs-number"><span class="hljs-number">1</span></span> ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> enemy?) capture $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) $<span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">add-partial</span></span> jumptype) ) )</code> </pre><br>  And so on, right up to the king-jump-7!  Let me remind you that in most varieties of drafts, with ‚Äúlong-range‚Äù queens, a lady, after completing a capture, can stop at <b>any</b> field, from a continuous chain of empty fields, following a figure taken.  There is, however, one <a href="http://thaichess.narod.ru/index/0-36">version of</a> this game, in which the rule of the ‚Äúchain‚Äù of taking is formulated differently.  That's what I like in checkers - everyone can find an option to his liking. <br></div></div><br>  Such a system for describing rules is very flexible, but sometimes more complex logic is required.  For example, if a figure, when performing a ‚Äúpartial‚Äù move, does not have to re-pass through previously passed fields, it is logical to use flags associated with the positions on the board.  Visiting the field, we will re-flag so that we will not re-enter this field again: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? my-flag)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> my-flag true)</code> </pre><br>  In addition to the ‚Äúpositional‚Äù, global flags can be used in <b>ZoG</b> .  These features should not be confused with the attributes of shapes.  Unlike the latter, they are not part of the game state.  Unfortunately, both the attributes of figures and flags in <b>ZoG</b> can only be boolean (in <b>Axiom,</b> attributes are not supported at all).  This limitation makes it difficult to perform operations associated with various kinds of calculations.  For example, in <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2233">this</a> small puzzle, I had to use a pair of Boolean flags to ‚Äúcount‚Äù the figures that fell into the ‚Äúplug‚Äù (I didn‚Äôt need the exact number, as long as there were more than one figure). <br><br>  Another thing that needs to be corrected is the lack of an intelligible ‚Äúlife cycle‚Äù of a turn.  All flags are automatically reset before starting a turn, but it would be more convenient to select the initialization phases explicitly.  In my opinion, when calculating the course, the following phases should be performed: <br><br><ol><li>  Variable initialization and check of prerequisites of the compound stroke </li><li>  Variable initialization and partial stroke precondition check </li><li>  Partial stroke generation </li><li>  Partial move postcondition check </li><li>  Generation of completion and verification of post-conditions for a compound course </li><li>  Check the completion of the game </li></ol><br>  The group of steps from the second to the fourth, when performing a composite move, can be repeated many times.  The idea of ‚Äã‚Äãthe pre- and post-conditions, which I call invariants, I took from the <b>Ludi</b> project.  However, I will talk more about the use of invariants in the future. <br><br><h4>  <b>About the importance of notation</b> </h4><br>  Generating all possible moves from a position is only half the battle.  To control the game state, a compact form of presentation of the generated moves is required.  <b>ZoG</b> uses a <b>ZSG</b> abstract for this purpose.  Here is the record of the possible start of a chess game in this form: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e2 - e4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Pawn e7 - e5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight g1 - f3 <span class="hljs-number"><span class="hljs-number">2</span></span>. Knight b8 - c6 <span class="hljs-number"><span class="hljs-number">3</span></span>. Bishop f1 - c4 <span class="hljs-number"><span class="hljs-number">3</span></span>. Knight g8 - f6 <span class="hljs-number"><span class="hljs-number">4</span></span>. King e1 - g1 Rook h1 - f1 @ f1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> @ g1 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>. Pawn d7 - d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Pawn e4 x d5 <span class="hljs-number"><span class="hljs-number">5</span></span>. Knight f6 x d5</code> </pre><br>  Such a record is close to the usual <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BD%25D0%25BE%25D1%2582%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">chess notation</a> and, in general, is understandable to the user.  Some bewilderment can only be caused by White‚Äôs fourth move.  So in <b>ZSG</b> <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">castling</a> looks like.  Part of the description of the move to the ' <b>@</b> ' symbol is understandable - this is the simultaneous movement of the rook and the king, but what follows next?  Thus, in <b>ZSG</b> , it looks like a reset of the attributes of figures, the execution of which is necessary in order not to give an opportunity to perform castling again. <br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  <b>ZoG</b> uses <b>ZSG-</b> notation also to show the game in a form understandable to the player.  To the right of the board image, an auxiliary window ‚ÄúMoves List‚Äù can be opened.  This list can be used to navigate through the batch record (not very convenient, since the tree view of the alternative branches of the game is not supported).  The part of the move entry associated with changing the attributes of the pieces is not displayed to the user. <br></div></div><br>  The record of the move in the <b>ZSG</b> notation should contain complete information sufficient to correctly change the game state.  If the information about the attribute changes was not saved, the game, according to this record, could be played incorrectly (for example, the player would have the opportunity to rerun the castling).  Unfortunately, in DLL extensions (such as <b>Axiom</b> ), extended information may not be transmitted. <br><br>  Working with DLL extensions, <b>ZoG is</b> forced to perform a rather cunning manipulation when performing positioning on a selected turn (for example, when rolling back a turn).  From the previous position, <b>all</b> possible moves are generated, and then, in the list, the selected move is searched for by its <b>ZSG</b> representation.  The generated move applies to the game state, possibly performing side effects that are not reflected in its <b>ZSG</b> presentation. <br><br>  The situation is aggravated by the fact that the only way to get the game state, at the time of a move in the past, is the consistent application of all moves, from the beginning of the game, to the initial state of the board.  In really <a href="http://habrahabr.ru/post/234587/">difficult cases</a> , such navigation is not fast.  Another drawback of the <b>ZSG</b> notation can illustrate the following turn from the <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE">Go</a> game: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. White Stone G19 x A19 x B19 x C19 x D19 x E19 x F19</code> </pre><br>  Here, in position G19, a white stone is set, which leads to the removal of a group of black stones.  Since all the pieces involved in the execution of the turn should be mentioned in the <b>ZSG</b> presentation, the stroke recording can be very long (in Go, up to 360 stones can be taken in one move).  What it can lead to, I already wrote <a href="http://habrahabr.ru/post/235483/">earlier</a> .  The size of the buffer allocated by <b>ZoG</b> for stroke recording may not be enough.  In addition, if for some reason the order of removing the stones changes (during the development of the game this happens), an attempt to use the course, with the old order of taking, will end in error. <br><br>  Fortunately, there is an easy way to deal with all these problems.  Let's look at how the moves of the pieces in <b>ZRF</b> are determined: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Pawn) (<span class="hljs-name"><span class="hljs-name">image</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\wpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\wpawn.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Chess\SHaag\bpawn.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Chess\bpawn.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> nw) (<span class="hljs-name"><span class="hljs-name">Pawn-capture</span></span> ne) (<span class="hljs-name"><span class="hljs-name">Pawn-move</span></span>) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> e) (<span class="hljs-name"><span class="hljs-name">En-Passant</span></span> w) ) )</code> </pre><br>  The names of the moves defined in <b>ZoG</b> macros are not available to the move generator.  But what prevents us from abandoning macros and making move descriptions named?  Here's what the chess game record will look like: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. e2 - e4 Pawn-move <span class="hljs-number"><span class="hljs-number">1</span></span>. e7 - e5 Pawn-move <span class="hljs-number"><span class="hljs-number">2</span></span>. g1 - f3 leap2 n nw <span class="hljs-number"><span class="hljs-number">2</span></span>. b8 - c6 leap2 n ne <span class="hljs-number"><span class="hljs-number">3</span></span>. f1 - c4 slide nw <span class="hljs-number"><span class="hljs-number">3</span></span>. g8 - f6 leap2 n nw <span class="hljs-number"><span class="hljs-number">4</span></span>. e1 - g1 OO <span class="hljs-number"><span class="hljs-number">4</span></span>. d7 - d5 Pawn-move <span class="hljs-number"><span class="hljs-number">5</span></span>. e4 x d5 Pawn-capture nw <span class="hljs-number"><span class="hljs-number">5</span></span>. f6 x d5 leap2 w nw</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  Attentive readers may notice that in the ‚Äúfor black‚Äù moves I used directions that did not correspond to the directions on the chessboard.  This is due to the fact that ‚Äúsymmetry‚Äù is defined for blacks: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">symmetry</span></span> Black (<span class="hljs-name"><span class="hljs-name">ns</span></span>)(<span class="hljs-name"><span class="hljs-name">sn</span></span>) (<span class="hljs-name"><span class="hljs-name">nw</span></span> sw)(<span class="hljs-name"><span class="hljs-name">sw</span></span> nw) (<span class="hljs-name"><span class="hljs-name">ne</span></span> se)(<span class="hljs-name"><span class="hljs-name">se</span></span> ne))</code> </pre><br>  Roughly speaking, what is ‚Äúnorth‚Äù for whites, is ‚Äúsouth‚Äù for blacks, and vice versa. <br></div></div><br>  The benefits of such a record are not obvious, but it has one important advantage.  All moves are described in a single form and these descriptions do not contain anything superfluous (the names of the descriptions of the moves, of course, could have been made more ‚Äútalking‚Äù).  In the description of the castling, it was possible to get rid of the change of attributes and even the description of the move of the rook (this description no longer depends on the details of the implementation of the move).  The usefulness of such a record in the case of a Go game is even more obvious: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. G19 drop-to-empty White Stone</code> </pre><br>  And it's all!  If the opponent‚Äôs stones are taken in accordance with the rules of the game, there is no need to list them all in the course description.  It is enough to specify the initial and final field of the movement (possibly with a sign of taking), the name of the move being executed and the string of parameters passed to it.  Of course, in order to execute a move, according to this description, for decoding, you will have to turn to the module for generating moves, but <b>ZoG</b> does just that! <br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  In very rare, one might say exotic <a href="http://www.chessvariants.org/other.dir/ultima.html">cases</a> , it may be necessary to perform a move consisting only in taking a figure (one's own or an opponent).  The recording of such a move, in the new notation, will look as follows: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. x G19 capture-piece</code> </pre><br></div></div><br>  Another feature that should be supported is the functionality of "partial" moves.  Here is an example from the <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Russian Checkers</a> : <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. Checker g3 - f4 <span class="hljs-number"><span class="hljs-number">1</span></span>. Checker f6 - g5 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - d4 <span class="hljs-number"><span class="hljs-number">2</span></span>. partial <span class="hljs-number"><span class="hljs-number">2</span></span> Checker g5 - e3 = XChecker on f4 <span class="hljs-number"><span class="hljs-number">2</span></span>. Checker e3 - c5 = XChecker on d4 x d4 x f4</code> </pre><br>  Here the blacks, on the second move, take two pieces on d4 and f4.  The preliminary "transformation" of the pieces in the <b>XChecker</b> is a feature of the implementation and serves to prevent the possibility of re-taking the "broken" pieces on the same turn.  The phrase " <b>partial 2</b> " describes the beginning of the "composite" move, consisting of two "partial" moves.  This form of description is inconvenient, because at the time of generation of the first move, the length of the sequence of ‚Äúpartial‚Äù moves may be unknown.  This is how the description will look like in the new format: <br><br><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">1</span></span>. g3 - f4 checker-shift nw <span class="hljs-number"><span class="hljs-number">1</span></span>. f6 - g5 checker-shift ne <span class="hljs-number"><span class="hljs-number">2</span></span>. e3 - d4 checker-shift nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + g5 - e3 checker-jump nw <span class="hljs-number"><span class="hljs-number">2</span></span>. + e3 - c5 checker-jump sw <span class="hljs-number"><span class="hljs-number">2</span></span>. +</code> </pre><br>  Implementation details associated with the "transformation" of figures are superfluous.  The capture of figures should also not be indicated, since, in checkers, the capture is performed as a ‚Äúside effect‚Äù of the move of the figure, and not according to the ‚Äúchess principle‚Äù.  The partial move will be encoded with a " <b>+</b> " at the beginning of the line.  A single " <b>+</b> " means the completion of a "composite move" (in fact, this is the usual "partial" move, which contains the omission of a move - an empty line). <br><br>  Thus, using the named rules for executing moves, we managed to create a universal notation that fully satisfies our requirements.  Of course, it has nothing to do with conventional chess with any other notation, but it so happens that the generally accepted notations for chess, checkers and other games also have nothing in common with each other.  The visualization module can always perform the conversion of a move record into a more familiar form adopted for a particular game.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can also be converted to some other universal form, for example </font></font><a href="http://ru.wikipedia.org/wiki/Smart_Game_Format"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SGF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game life cycle</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Along with the information on the placement of pieces on the board, the sequence of turn is an integral part of the state that is changed during the game. </font><font style="vertical-align: inherit;">In the simplest (and most common) case, one bit is enough to store this information, but </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides slightly more options for implementing more complex cases. </font><font style="vertical-align: inherit;">This is how the description of the sequence of moves for the game </font><a href="http://www.iggamecenter.com/info/ru/splut.html"><font style="vertical-align: inherit;">Splut</font></a><font style="vertical-align: inherit;"> might look </font></font><a href="http://www.iggamecenter.com/info/ru/splut.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">!</font></font></a>  : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South West North East) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South West West repeat North North North East East East South South South West West West )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this game, each player makes three moves at a time, but if the first player is given the opportunity to make three moves from the initial position, he will be able to destroy one of the opponent's pieces, which will give him a significant advantage. For this reason, the first player must make one move (this gives the opportunity to prepare for the attack of the player opposite, but not attack him), the second - two moves (this is also not enough to attack the opposing player), after which each player always three moves each.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f78/6b5/862/f786b5862708474184d805653c2fe9fc.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repeat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> label </font><font style="vertical-align: inherit;">indicates the beginning of a cyclically repeating sequence of moves. If it is absent, the entire description is repeated cyclically. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allows you to use the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repeat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> label </font><font style="vertical-align: inherit;">no more than once. Another important feature is the determination of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> travel </font><b><font style="vertical-align: inherit;">mode</font></b><font style="vertical-align: inherit;"> . Here is how the description of the sequence of moves of the game, in which each of the players performs two moves, may look (the first move is the movement of a piece, the second is the capture of an opponent's piece):</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> White Black) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">White</span></span> capture-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> normal-move) (<span class="hljs-name"><span class="hljs-name">Black</span></span> capture-move) )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another possibility associated with the description of moves by other figures, but it is extremely inconvenient to use. The fact is that such a description has no alternative. If the description indicates that the move must be carried out by an opponent figure, the player must perform such a move! In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it is impossible to describe the move " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to choose</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " with your own or someone else's figure. If such an opportunity is necessary in the game (as, for example, in the " </font></font><a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2247"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stavropol drafts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"), you have to neutralize all the pieces (creating for this purpose a player not participating in the game) and determine for all players the possibility of a move with neutral pieces. Above, I have already said that it is much easier to allow players to initially move with any pieces ( and its opponent), adding the necessary checks in the course of generating algorithms. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as can be seen, a set of possibilities offered by </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , to describe the sequence of moves is extremely limited. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Axiom</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also adds new features, because (usually) No. lnyaetsya over </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ludi</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this respect, even poorer. In order to maximize the unification of game rules (necessary for the possibility of using genetic algorithms), in this project, all descriptive features are consciously simplified, which leads to the cutting off of whole layers of games.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/52b/c1e/8a3/52bc1e8a3f374c8386884241a1571a18.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="http://skyruk.livejournal.com/390109.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bao Kiswahili</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " is a good example of a game with a complex life cycle. In this game there are two phases, the rules for performing a turn are significantly different. At the beginning of the game, a part of the stones is ‚Äúin the hand‚Äù of each of the players. While the stones "in hand" are not over, there is a throwing of stones into the holes, one stone each. When the stones ‚Äúin hand‚Äù end, the second phase of the game begins, connected with the redistribution of the stones thrown in. This is not to say that this game cannot be described in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZRF</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> description </font><b><font style="vertical-align: inherit;">language</font></b><font style="vertical-align: inherit;"> ), but due to the limitations of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , such an implementation would </font><b><font style="vertical-align: inherit;">turn</font></b><font style="vertical-align: inherit;"> out to be extremely confusing (which would certainly not have the best effect on the quality of AI work). Let's see how the description of such a game could look like in an ‚Äúideal world‚Äù:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">label</span></span> phase-ii) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here, each </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turn-order</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> list </font><font style="vertical-align: inherit;">defines its recurring sequence of moves (distinguished by the progress mode). The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">label</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> keyword </font><font style="vertical-align: inherit;">defines a label, the transition to which can be formed during the generation of the next move. You may notice that here we proceed from the implicit assumption that such a transition always occurs after the move of the second player (otherwise the sequence of moves will be broken). How to make the transition to the next phase at an arbitrary point in time?</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> pi-move) (<span class="hljs-name"><span class="hljs-name">North</span></span> pi-move) ) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">labels</span></span> - phase-ii) (<span class="hljs-name"><span class="hljs-name">South</span></span> p-ii-move) (<span class="hljs-name"><span class="hljs-name">labels</span></span> phase-ii -) (<span class="hljs-name"><span class="hljs-name">North</span></span> p-ii-move) ) )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here the labels are transferred to the body of the loop and contain two names each. The names of the labels in the lists of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">labels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are listed in accordance with the order of enumeration of players in the list of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">players</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The name used for the transition is determined depending on which player performed the move last. If it was </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">North</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it will go to the first label, otherwise - to the second. If any of the names in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">labels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will not be used, the corresponding position can be filled with a dash.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/060/833/75d/06083375de8a4b97b7cffb138b3d5b9f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An important point in the management of alternating moves is the possibility of performing a repeated move. In games of the </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B0%25D1%2580%25D0%25B4%25D1%258B"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> family </font><font style="vertical-align: inherit;">, such as </font></font><a href="http://skyruk.livejournal.com/231444.html%3Fthread%3D4494868"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ur</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for example, the ability to perform repeated moves is an important element of the game tactics. In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can use the skip move to emulate this possibility, but this approach essentially confuses the description of the game (especially with the participation of several players). It is much more logical to use the label to repeat the move:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) South (<span class="hljs-name"><span class="hljs-name">label</span></span> repeat) North )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After completing the transition to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repeat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the player will return to repeating the last move (the label closest to the current position in the list of moves will be valid). </font><font style="vertical-align: inherit;">I like the </font></font><a href="https://ru.wikipedia.org/wiki/Perl"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> approach </font><font style="vertical-align: inherit;">to implicit definitions. </font><font style="vertical-align: inherit;">Implicit generation of control structures can significantly simplify the description. </font><font style="vertical-align: inherit;">Since repeated moves can be used in many games, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repeat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> labels </font><font style="vertical-align: inherit;">preceding each turn can be implicitly formed:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North) (<span class="hljs-name"><span class="hljs-name">turn-order</span></span> South North )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, since the sequence of moves fully corresponds to the players listed in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">players</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the entire </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turn-order</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> phrase can be automatically generated </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">players</span></span> South North)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The simpler the description is, the better. </font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Broken invariant</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main thing that I do not like in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be expressed in one word - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkmated</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At first glance, this is just a condition (quite common in games of the chess family), which relates the completion of the game to the formation of a </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matte situation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Alas, on closer examination, simplicity is deceptive. The use of this keyword implies not only the execution, after each move, checks the completion of the game, but also imposes a certain "behavior" on the player. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And the module for generating moves and AI must take into account that after completing a move, your king should not be under </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">check</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At the same time, it is not enough to perform a check only for a piece that has descended, the check may well be " </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">open</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". It is not easy to correctly implement all the necessary checks (in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><b><font style="vertical-align: inherit;">anyway,</font></b><font style="vertical-align: inherit;"> this was not possible):</font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/OR74gUlfQNY%3Ffeature%3Doembed&amp;xid=17259,15700002,15700022,15700186,15700191,15700253&amp;usg=ALkJrhjDJ2nFbkoextfz9c4-puln2v8gDQ" frameborder="0" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the usual </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2591%25D0%25B3%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shogi,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this game differs only in the number of players. Unfortunately, this difference is enough to make the work of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkmated</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (and all associated with this word "magic") incorrect. The correct check of being in check is performed only in relation to one of the players. As a result, the king may well be under attack and be eaten! Of course, this is not the best way reflected in the work of AI. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If this problem seems insignificant, it is worth remembering the coalitions usually formed in the games of four players ‚Äúa couple for a couple‚Äù. In the case of coalition formation, we must take into account that friendly figures do not threaten the king! For example, two friendly kings may well be placed on the adjacent board fields.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b00/77d/949/b0077d949f2d472da9e12d64099d924d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even more complicated if the player can have several kings. In " </font></font><a href="http://skyruk.livejournal.com/283735.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chess of Tamerlan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", the royal pawn turns into a prince (in fact, into the second king). If this happens, you can win only by eating the first king (any of the two) and mating the second. In this game, you can get the third king, having twice spent the transformation of the "pawn pawn"! The expressive possibilities of " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkmated</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " are not enough to adequately describe this situation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another difficulty can be the process of mating. So in the Mongolian version of chess ( </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2582%25D0%25B0%25D1%2580_%25D0%25B8_%25D1%2585%25D0%25B8%25D0%25B0%25D1%2588%25D0%25B0%25D1%2582%25D0%25B0%25D1%2580"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shatar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), the result of the matting depends on the order in which the pieces perform successive ‚Äúshahs‚Äù. </font><font style="vertical-align: inherit;">The result can be both a victory and a draw (for example, when a mate is a pawn) and even a defeat (it is forbidden to mate, but a check can be made). </font><font style="vertical-align: inherit;">Slightly less exotic, in this regard, Japanese Shogi. </font><font style="vertical-align: inherit;">In this game, it is forbidden to checkmate a pawn, but you can check with a pawn and mate with a pawn.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">       .   ,   <a href="http://habrahabr.ru/post/234587/"></a> ,     .     ,     ,    ,   .    ,   ,   ,  . <br><br>     (    )    ,       .  ,         .      ,     ,    . <br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviously, it is necessary to separate the logic of checking the completion of the game from checking that the king falls under the check, which is, in essence, an </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D0%25BD%25D1%2582_(%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">invariant</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that is checked after each turn. </font><font style="vertical-align: inherit;">Violation of the invariant makes the execution of a move impossible (a move is removed from the list of available moves). </font><font style="vertical-align: inherit;">This is how (simplistic) the test of the king‚Äôs check for Tamerlan Chess may look like:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King))) <span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to understand that this test should be performed only for one‚Äôs own kings (I used the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">my?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Predicate </font><font style="vertical-align: inherit;">, since, with the support of coalitions, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">friend</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute </font><font style="vertical-align: inherit;">will be satisfied not only for one‚Äôs own pieces, but also for a friendly player‚Äôs pieces). There is a permissible (and desirable) situation in which the enemy king falls under a check after the execution of a turn, but with regard to his own king, such a situation must be impossible! Subject to the support of checking such invariants, checking the completion of the game with a mat becomes trivial. If there are no possible moves and the king is under check, the game is lost:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">=</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> moves) <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">pieces</span></span> my? (<span class="hljs-name"><span class="hljs-name">is-piece</span></span>? King) is-attacked?)) <span class="hljs-number"><span class="hljs-number">0</span></span>) ) )</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The ability to define invariants will be useful in other games, such as </font></font><a href="http://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checkers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The greatest difficulty in the implementation of games of this family is associated with the implementation of the "majority rule". In almost all checkers games, a move with a take is mandatory. Also, for most games of this family, it is typical to perform "chains of take", in the framework of one move. The figure that performed the take continues to take other figures, if possible. In most games, the player is obliged to bring the chain of takeings to the end, but there are exceptions to this rule, for example </font></font><a href="http://www.iggamecenter.com/info/ru/fanorona.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fanorona</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a4a/f83/3d8/a4af833d85d445b5ba17aca59056b741.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using the mechanism of partial moves, the "chain of take" is quite simple to implement. </font><font style="vertical-align: inherit;">Difficulties begin when, in addition to this, a condition is imposed, according to which, from all possible options, it is required to choose a chain that takes the maximum number of figures. </font><font style="vertical-align: inherit;">In </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> this logic is re-implemented at the ‚Äúhardcode‚Äù level:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> true)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This setting is suitable for " </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">International drafts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", but in the " </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Italian drafts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " the majority rule is formulated differently. </font><font style="vertical-align: inherit;">In this variant of the game, if there are several variants with the same number of takes, it is required to choose the variant in which more turned checkers (ladies) are taken. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZoG</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> developers </font><b><font style="vertical-align: inherit;">have</font></b><font style="vertical-align: inherit;"> foreseen this by entering the following setting value:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">option</span></span> <span class="hljs-string"><span class="hljs-string">"maximal captures"</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using this setting, not only the number of pieces taken, but also their type is taken into account. </font><font style="vertical-align: inherit;">Unfortunately, it is impossible to foresee everything. </font><font style="vertical-align: inherit;">Here is how the ‚Äúmajority rule‚Äù is formulated in the ‚Äú </font></font><a href="http://skyruk.livejournal.com/256132.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Old French Checkers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù:</font></font><br><blockquote> <b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If during a series of takes, you can cut the same number of pieces with a simple piece or a queen, the player must take a queen. </font><font style="vertical-align: inherit;">However, if the number of checkers removed is the same in both cases, but in one &lt;branch&gt; there are opponent's queens (or there are more of them), the player must choose this option, even if it is then necessary to chop with a simple checker, and not a lady</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, at present, almost no one plays this version of drafts, but its very existence clearly demonstrates the shortcomings of the ‚Äúhardcode‚Äù implementation. </font><font style="vertical-align: inherit;">Using the mechanism of invariants allows you to implement all possible variants of the "rule of the majority" in a universal way. </font><font style="vertical-align: inherit;">For the "Old French Drafts" implementation will be as follows:</font></font><br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-count max-capturing-count) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-count max-capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-count capturing-count) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> capturing-sum max-capturing-sum) ) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;</span></span> capturing-sum max-capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-capturing-sum capturing-sum) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value) ) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">&gt;=</span></span> attacking-value max-attacking-value) ) (<span class="hljs-name"><span class="hljs-name">let</span></span> max-attacking-value attacking-value)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here, we proceed from the assumption that the rules for generating a stroke correctly fill local variables: </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capturing-count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the number of pieces taken</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capturing-sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the total value of the figures taken</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attacking-value</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the dignity of the figure performing the move</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each of these variables is associated with a battery value, stored in a variable with the prefix </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">max</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Three checks are performed sequentially. Violation of any of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verify</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conditions </font><font style="vertical-align: inherit;">immediately terminates the generation of the next turn (the turn is not saved in the list of possible moves). Since the checks performed are related to the values ‚Äã‚Äãbeing changed, this is not enough for the conditions to work correctly. Each such check forms a ‚Äúbroken invariant‚Äù associated with the generated move. After each change in the value of the battery, all associated invariants are re-checked. If any of the conditions are violated, the previously generated move is removed from the list of possible moves.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">     <b>ZoG</b> ,    .        ¬´ ¬ª, ,  ,   : <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">move-priorities</span></span> jumptype nonjumptype) (<span class="hljs-name"><span class="hljs-name">piece</span></span> (<span class="hljs-name"><span class="hljs-name">name</span></span> Checker) (<span class="hljs-name"><span class="hljs-name">image</span></span> Red <span class="hljs-string"><span class="hljs-string">"images\Checkers\Shaag\chkrRM.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Checkers\chkrRM.bmp"</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Checkers\Shaag\chkrBM.bmp"</span></span> <span class="hljs-string"><span class="hljs-string">"images\Checkers\chkrBM.bmp"</span></span>) (<span class="hljs-name"><span class="hljs-name">moves</span></span> (<span class="hljs-name"><span class="hljs-name">move-type</span></span> jumptype) (<span class="hljs-name"><span class="hljs-name">checker-jump</span></span> nw) (<span class="hljs-name"><span class="hljs-name">checker-jump</span></span> ne) (<span class="hljs-name"><span class="hljs-name">move-type</span></span> nonjumptype) (<span class="hljs-name"><span class="hljs-name">checker-shift</span></span> nw) (<span class="hljs-name"><span class="hljs-name">checker-shift</span></span> ne) ) )</code> </pre><br>      ,     . <br></div></div><br><h4>  <b>Conclusion</b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I tried to talk about my plans to create a new universal "engine" for the development of abstract logic games and puzzles. </font><font style="vertical-align: inherit;">I am aware that this work is not for one month (maybe even not for a year), but, in this case, the process, for me, is much more important than the result. </font><font style="vertical-align: inherit;">I do not plan to extract any benefits from this work and, even more so, I do not plan to close the source codes of the project. </font><font style="vertical-align: inherit;">If any license will be used, I will try to find the most liberal option. </font><font style="vertical-align: inherit;">I will be glad if someone joins my work, but if I don‚Äôt find any, I won‚Äôt worry too much. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Viam supervadet vadens</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/242547/">https://habr.com/ru/post/242547/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242537/index.html">6 A / B tests that you can conduct today (and get results)</a></li>
<li><a href="../242539/index.html">David Chappell about the clouds and the future development</a></li>
<li><a href="../242541/index.html">Writing a framework on asyncio, aiohttp and thinking about Python3 part one</a></li>
<li><a href="../242543/index.html">Detailed description of development capabilities with Microsoft Azure Cloud Services</a></li>
<li><a href="../242545/index.html">Practical application of FlexBox</a></li>
<li><a href="../242557/index.html">DaData.ru calculates coordinates, and the address parser wags its tail</a></li>
<li><a href="../242559/index.html">Top 5 ORM for Android</a></li>
<li><a href="../242567/index.html">How to sell an idea or 7 types of idea buyers</a></li>
<li><a href="../242569/index.html">Internet services: how to find now and what they promise in the near future</a></li>
<li><a href="../242571/index.html">Will SAFe be an industry standard in Enterprise Agile?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>