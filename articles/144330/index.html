<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Plunge into the depths of C # dynamic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most notable additions to C # 4 is dynamic. This has been told many times. But DLR (Dynamic Language Runtime) is always out of sight. In th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Plunge into the depths of C # dynamic</h1><div class="post__text post__text-html js-mediator-article">  One of the most notable additions to C # 4 is dynamic.  This has been told many times.  But DLR (Dynamic Language Runtime) is always out of sight.  In this article we will look at the internal structure of the DLR, the work of the compiler itself, and also give a definition of the concepts of a statically-dynamically-typed language with weak and strong typifications.  And, of course, the PIC (Polymorphic Inline Cache) technique used in the Google V8 engine, for example, will not be overlooked. <br><a name="habracut"></a><br>  Before moving on, I would like to refresh some of the terms and concepts. <br><br>  In order not to repeat, by the expression variable we will mean any data object (variable, constant, expression). <br><br>  Programming languages ‚Äã‚Äãby type checking criteria are usually divided into statically typed (the variable is associated with the type at the time of declaration and the type cannot be changed later) and dynamically typed (the variable is associated with the type at the time of assignment of the value and the type cannot be changed later). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      C # is an example of a language with static typing, while Python and Ruby are dynamic. <br><br>  According to the criterion of type security policies, languages ‚Äã‚Äãwith weak (the variable does not have a strictly defined type) and strong / strict (the variable has a strictly defined type, which cannot be changed later) are typed. <br><br><h5>  C # 4 dynamic keyword </h5><br>  Although dynamic adds the ability to write clean code and interact with dynamic languages ‚Äã‚Äãlike IronPython and IronRuby, C # does not cease to be a statically typed language with strong typing. <br><br>  Before a detailed examination of the mechanism of the dynamic itself, we give an example of the code: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    System.String dynamic d = "stringValue"; Console.WriteLine(d.GetType()); //       d = d + "otherString"; Console.WriteLine(d); //   System.Int32 d = 100; Console.WriteLine(d.GetType()); Console.WriteLine(d); //       d++; Console.WriteLine(d); d = "stringAgain"; //      d++; Console.WriteLine(d);</span></span></code> </pre> <br>  The result of the execution is shown below in the screenshot: <br><br><img src="https://habrastorage.org/storage2/fcf/9a6/43f/fcf9a643f8cbaf0366eb81cc2f78eb3f.png"><br><br>  And what do we see?  What is the typing here? <br><br>  I will answer immediately: typing is strong, and here's why. <br><br>  Unlike other built-in types of the C # language (for example, string, int, object, etc.), dynamic has no direct mapping to any of the basic BCL types.  Instead, <b>dynamic</b> is a special alias for <b>System.Object</b> with additional metadata necessary for proper late binding. <br><br>  So, the view code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> d = <span class="hljs-number"><span class="hljs-number">100</span></span>; d++;</code> </pre><br>  Will be converted to the form: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> d = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> arg = d; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Program.&lt;dynamicMethod&gt;o__SiteContainerd.&lt;&gt;p__Sitee == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Program.&lt;dynamicMethod&gt;o__SiteContainerd.&lt;&gt;p__Sitee = CallSite&lt;Func&lt;CallSite, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(Binder.UnaryOperation(CSharpBinderFlags.None, ExpressionType.Increment, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Program), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })); } d = Program.&lt;dynamicMethod&gt;o__SiteContainerd.&lt;&gt;p__Sitee.Target(Program.&lt;dynamicMethod&gt;o__SiteContainerd.&lt;&gt;p__Sitee, arg);</code> </pre><br>  As you can see, the variable <i>d of</i> type <i>object is</i> declared.  Then binders from the Microsoft.CSharp library come into play. <br><br><h5>  DLR </h5><br>  For each dynamic expression in code, the compiler generates a separate <b>dynamic node call</b> , which is the operation itself. <br><br>  So, for the view code <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> d = <span class="hljs-number"><span class="hljs-number">100</span></span>; d++;</code> </pre><br>  a class like this will be generated: <br><br><pre> <code class="bash hljs">private static class &lt;dynamicMethod&gt;o__SiteContainerd { // Fields public static CallSite&lt;Func&lt;CallSite, object, object&gt;&gt; &lt;&gt;p__Sitee; }</code> </pre><br>  The field type <i>&lt;&gt; p__Sitee</i> is the class System.Runtime.CompilerServices.CallSite.  Consider it in more detail. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CallSite</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">CallSite</span></span> <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Target; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Update { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CallSite&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CallSiteBinder binder</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Although the <b>Target</b> field is generic, in fact it is always a <b>delegate</b> .  And the last line in the above example is not just a variation of the operation: <br><br><pre> <code class="cs hljs">d = Program.&lt;dynamicMethod&gt;o__SiteContainerd.&lt;&gt;p__Sitee.Target(Program.&lt;dynamicMethod&gt;o__SiteContainerd.&lt;&gt;p__Sitee, arg);</code> </pre><br>  The static Create method of the CallSite class is: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> CallSite&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CallSiteBinder binder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T).IsSubclassOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MulticastDelegate))) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Error.TypeMustBeDerivedFromSystemDelegate(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CallSite&lt;T&gt;(binder); }</code> </pre><br>  The <b>Target</b> field is an L0 cache (there are also L1 and L2 caches), which is used to quickly dispatch calls based on the call history. <br><br>  I draw your attention to the fact that the call node is ‚Äúself-learning‚Äù, so the DLR needs to periodically update the value of Target. <br><br>  To describe the logic of the DLR I will give the answer of Eric Lippert on this (free translation): <br><br><blockquote>  First, the runtime decides what type of object we are dealing with (COM, POCO). <br><br>  Next comes the compiler.  Since there is no need for a lexer and a parser, DLR uses a special version of the C # compiler, which has only a metadata analyzer, a semantic expression analyzer, and a code generator, which instead of IL generates an Expression Trees. <br><br>  The metadata analyzer uses reflection to determine the type of the object, which is then passed to the semantic analyzer to establish the possibility of calling a method or performing an operation.  Next comes the construction of the Expression Tree, as if you were using a lambda expression. <br><br>  The C # compiler brings the expression tree back to the DLR along with the caching policy.  The DLR then stores this delegate in the cache associated with the call site. <br></blockquote><br>  To do this, use the <b>Update</b> property of the CallSite class.  When you call a dynamic operation stored in the Target field, it is redirected to the Update property, where the call to the binders occurs.  When the next time the call occurs, instead of re-performing the above actions, the already prepared delegate will be used. <br><br><h5>  Polymorphic Inline Cache </h5><br>  The performance of dynamic languages ‚Äã‚Äãsuffers due to additional checks and search queries running in all places of the call.  The rectilinear implementation is constantly looking for members in the class priority lists and, possibly, permits overloading of the method argument types each time a line of code is executed.  In languages ‚Äã‚Äãwith static typing (or with a sufficient number of type indications in the code and type inference), you can generate instructions or calls to runtime functions that are suitable for all call points.  This is possible because static types let you know everything you need during compilation. <br><br>  In practice, repeated operations on the same types of objects can be reduced to a general type.  For example, when you first calculate the value of the expression x + y for integers x and y, you can remember a code snippet or an exact execution time function that adds two integers.  Then, for all subsequent calculations, the value of this expression will not be required to search for a function or a code fragment due to the cache. <br><br>  The above delegate caching mechanism (in this case) when the call node is self-learning and updated is called Polymorphic Inline Cache.  Why? <br><br>  <b>Polymorphic</b> .  Target call node can have several forms, based on the types of objects used in a dynamic operation. <br><br>  <b>Inline</b> .  The life cycle of an instance of the CallSite class takes place exactly in the place of the call itself. <br><br>  <b>Cache</b>  Work is based on different cache levels (L0, L1, L3). <br></div><p>Source: <a href="https://habr.com/ru/post/144330/">https://habr.com/ru/post/144330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144325/index.html">"Lokalka" - a game for those who are in the subject</a></li>
<li><a href="../144326/index.html">EMC bought Syncplicity</a></li>
<li><a href="../144327/index.html">Andreessen Horowitz estimates half a billion Github</a></li>
<li><a href="../144328/index.html">Debriefing - Episode 18 - Special: Join the Rebellion</a></li>
<li><a href="../144329/index.html">Autoposting services for VKontakte</a></li>
<li><a href="../144334/index.html">Type-rich programming</a></li>
<li><a href="../144336/index.html">Pinterest architecture - 18 million visitors, 10-fold increase, 12 employees, 410 TB of data</a></li>
<li><a href="../144337/index.html">Improving the 404th error page</a></li>
<li><a href="../144339/index.html">Web Evolution (Part 1: Interface)</a></li>
<li><a href="../144340/index.html">A tale about how I won an MSDN Premium subscription in a contest, but Microsoft refused to activate it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>