<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hibernate Developer Documentation - Chapter II. Transactions and multithreading</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the translation of the second chapter of the official documentation Hibernate . 

 Article translation is relevant for the version Hi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hibernate Developer Documentation - Chapter II. Transactions and multithreading</h1><div class="post__text post__text-html js-mediator-article">  <i>I present to you the translation of the <a href="http://docs.jboss.org/hibernate/orm/4.2/devguide/en-US/html_single/">second chapter of the official documentation Hibernate</a> .</i> <br><br>  <i>Article translation is relevant for the version Hibernate 4.2.19.Final</i> <br><br>  <b>Content</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="https://habr.com/ru/post/269485/">2.1.</a>  <a href="https://habr.com/ru/post/269485/">Transaction definition</a> <br>  <a href="https://habr.com/ru/post/269485/">2.2.</a>  <a href="https://habr.com/ru/post/269485/">Physical transactions</a> <br>  <a href="https://habr.com/ru/post/269485/">2.2.1.</a>  <a href="https://habr.com/ru/post/269485/">Physical Transactions - JDBC</a> <br>  <a href="https://habr.com/ru/post/269485/">2.2.2.</a>  <a href="https://habr.com/ru/post/269485/">Physical Transactions - JTA</a> <br>  <a href="https://habr.com/ru/post/269485/">2.2.3.</a>  <a href="https://habr.com/ru/post/269485/">Physical Transactions - CMT</a> <br>  <a href="https://habr.com/ru/post/269485/">2.2.4.</a>  <a href="https://habr.com/ru/post/269485/">Physical Transactions - Other</a> <br>  <a href="https://habr.com/ru/post/269485/">2.2.5.</a>  <a href="https://habr.com/ru/post/269485/">Physical Transactions - Legacy</a> <br>  <a href="https://habr.com/ru/post/269485/">2.3.</a>  <a href="https://habr.com/ru/post/269485/">Hibernate transaction application</a> <br>  <a href="https://habr.com/ru/post/269485/">2.4.</a>  <a href="https://habr.com/ru/post/269485/">Patterns and anti-transaction patterns</a> <br>  <a href="https://habr.com/ru/post/269485/">2.4.1.</a>  <a href="https://habr.com/ru/post/269485/">Session-to-operation anti-pattern</a> <br>  <a href="https://habr.com/ru/post/269485/">2.4.2.</a>  <a href="https://habr.com/ru/post/269485/">Session-to-request pattern</a> <br>  <a href="https://habr.com/ru/post/269485/">2.4.3.</a>  <a href="https://habr.com/ru/post/269485/">Conversations (Conversations)</a> <br>  <a href="https://habr.com/ru/post/269485/">2.5.</a>  <a href="https://habr.com/ru/post/269485/">Object identity</a> <br>  <a href="https://habr.com/ru/post/269485/">2.6.</a>  <a href="https://habr.com/ru/post/269485/">General issues</a> <br><a name="habracut"></a><br><a name="2_1"></a><h3>  2.1.  Transaction definition </h3><br>  It is important to understand that the term ‚Äútransaction‚Äù has many meanings in relation to persistence and object-relational projection. <br>  In most, but not all cases, the following definitions are appropriate. <br><ul><li>  May be related to physical database transactions. </li><li>  May be related to the logical concept of ‚Äútransaction‚Äù, as related to the context of persistence. </li><li>  May refer us to the concept of Unit-of-Work, as a well-defined architectural pattern. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Important</b> <div class="spoiler_text">  This documentation considers the logical and physical concepts of a transaction as one concept. <br></div></div><br><br><a name="2_2"></a><h3>  2.2.  Physical transactions </h3><br>  Hibernate uses the JDBC API for persistence.  In the Java world, there are two well-defined transaction mechanisms: JDBC and JTA directly.  Hibernate supports both transaction integration mechanisms and allows applications to manage physical transactions. <br><br>  The first concept in understanding Hibernate transaction support is the <i>org.hibernate.engine.transaction.spi.TransactionFactory</i> interface, which provides two main functions: <br><ul><li>  It allows Hibernate to understand the transaction semantics of the current environment.  Are we working now in the environment of JTA?  Is the physical transaction already active at this time, etc. </li><li>  It acts as a factory of <i>org.hibernate.Transaction</i> instances used by the application to manage and verify the status of transactions, <i>org.hibernate.Transaction</i> is Hibernate's logical transaction concept.  JPA has a similar concept in the <i>javax.persistence.EntityTransaction</i> interface. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Important</b> <div class="spoiler_text">  <i>javax.persistence.EntityTransaction</i> is available only when you use resource-local transactions.  Hibernate provides access to <i>org.hibernate.Transaction</i> regardless of the environment. <br></div></div><br>  <i>org.hibernate.engine.transaction.spi.TransactionFactory</i> is a standard Hibernate service.  See  Details in <a href="http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html_single/">section 7.5.16, ‚Äúorg.hibernate.engine.transaction.spi.TransactionFactory‚Äù</a> . <br><br><a name="2_2_1"></a><h3>  2.2.1.  Physical Transactions - JDBC </h3><br>  Transaction management using JDBC is achieved by the methods <i>java.sql.Connection.commit ()</i> and <i>java.sql.Connection.rollback ()</i> (JDBC does not define an explicit method for initiating a transaction).  In Hibernate, this approach is represented by the class <i>org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</i> <br><br><a name="2_2_2"></a><h3>  2.2.2.  Physical Transactions - JTA </h3><br>  JTA-approach to transactions is achieved by the <i>javax.transaction.UserTransaction</i> interface, obtained from the <i>org.hibernate.service.jta.platform.spi.JtaPlatform</i> API.  This approach is represented by the <i>org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</i> class <i>.</i> <br>  See JTA Integration <a href="http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html_single/">Section 7.5.9, ‚Äúorg.hibernate.service.jta.platform.spi.JtaPlatform‚Äù</a> <br><br><a name="2_2_3"></a><h3>  2.2.3.  Physical Transactions - CMT </h3><br>  Another JTA-based transaction approach uses the <i>javax.transaction.TransactionManager</i> interface, obtained from the <i>org.hibernate.service.jta.platform.spi.JtaPlatform</i> API.  This approach is represented by the <i>org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</i> class.  In the current environment of JEE CM, access to <i>javax.transaction.UserTransaction is</i> closed. <br><div class="spoiler">  <b class="spoiler_title">Important</b> <div class="spoiler_text">  The term CMT is potentially misleading.  The important part is that the physical JTA transactions are managed by some other means other than the Hibernate API. <br></div></div><br>  See on JTA integration <a href="http://docs.jboss.org/hibernate/orm/4.3/devguide/en-US/html_single/">section 7.5.9, ‚Äúorg.hibernate.service.jta.platform.spi.JtaPlatform‚Äù</a> . <br><br><a name="2_2_4"></a><h3>  2.2.4.  Physical Transactions - Other </h3><br>  It is also possible to connect a custom transaction management solution by implementing the <i>org.hibernate.engine.transaction.spi.TransactionFactory</i> contract.  The initiator of the default service has built-in support for recognizing custom solutions through <i>hibernate.transaction.factory_class</i> , which may indicate: <br><ul><li>  The <i>org.hibernate.engine.transaction.spi.TransactionFactory</i> instance. </li><li>  The name of the implementation class is <i>org.hibernate.engine.transaction.spi.TransactionFactory</i> .  The implementation class must have a constructor with no arguments. </li></ul><br><br><a name="2_2_5"></a><h3>  2.2.5.  Physical Transactions - Legacy </h3><br>  Most of those classes mentioned above were migrated to new packages during development version 4.0.  To help with upgrading to a new version, Hibernate will recognize obsolete names for a short period of time. <br><ul><li>  <i>org.hibernate.transaction.JDBCTransactionFactory</i> maps to <i>org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</i> </li><li>  <i>org.hibernate.transaction.JTATransactionFactory</i> maps to <i>org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</i> </li><li>  <i>org.hibernate.transaction.CMTTransactionFactory</i> maps to <i>org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</i> </li></ul><br><br><a name="2_3"></a><h3>  2.3.  Hibernate transaction application </h3><br>  Hibernate uses JDBC connections and JTA resources directly, with no additional synchronization logic.  It is important for you to become familiar with JDBC, ANSI SQL, and the specifics of transaction isolation in your DBMS. <br>  Hibernate does not synchronize on objects in memory.  The behavior determined by the isolation level of your DB transactions does not change when you use Hibernate.  The <i>org.hibernate.Session</i> object acts as a repeatable reads and cache requests that are limited to the limits of the transaction. <br><br><div class="spoiler">  <b class="spoiler_title">Important</b> <div class="spoiler_text">  To reduce blocking competition, transactions should be as short as possible.  Long transactions make it difficult to scale your application to high loads.  You do not need to keep transactions open while the end user is working; you need to open them after the user has finished working.  This concept is also differently called transactional write-behind. <br></div></div><br><br><a name="2_4"></a><h3>  2.4.  Patterns and anti-transaction patterns </h3><br><a name="2_4_1"></a><h3>  2.4.1.  Session-to-operation anti-pattern </h3><br>  This is an anti-pattern for opening and closing a <i>Session</i> object for each operation to the database in one thread.  It is also an anti-pattern in terms of database transactions.  Group your calls into one scheduled sequence.  Also, do not auto-commit transactions per SQL statement.  Hibernate turns off, or expects the application server to turn off auto-commit mode immediately.  Transactions to the database have never been optional.  All communications with the database must be wrapped in a transaction.  Avoid auto-commit when reading data, because quite rarely a lot of small transactions will work faster than one properly defined transaction.  Moreover, such a multitude of transactions is difficult to maintain and expand. <br><div class="spoiler">  <b class="spoiler_title">Important</b> <div class="spoiler_text">  The use of autocommit does not necessarily lead to the use of database transactions for each expression.  Instead, in autocommit mode, JDBC drivers simply make each call as part of an implicit transaction call.  This is the same as if your application made a commit () transaction call after each JDBC call. <br></div></div><br><a name="2_4_2"></a><h3>  2.4.2.  Session-to-request pattern </h3><br>  The most common transaction pattern.  The term ‚Äúrequest‚Äù here should be understood in the context of a system that responds to a series of requests from a user / client.  Web applications are a prime example of such systems, but, of course, they are not the only ones.  At the stage of starting the processing of a request, the application opens the <i>Session</i> object, initiates a transaction, does all the related work with the data, completes the transaction and closes the <i>Session</i> .  The essence of the pattern is a one-to-one relationship between a transaction and a session. <br>  As part of the pattern, there is a common technique for determining the current session to simplify the transfer of this <i>Session</i> between application components.  Hibernate provides support for this technique through the <i>getCurrentSession ()</i> method of the <i>SessionFactory</i> class.  The concept of a ‚Äúcurrent‚Äù session should have a scope that defines the boundaries in which the definition of ‚Äúcurrent‚Äù is true.  This is the task of the <i>org.hibernate.context.spi.CurrentSessionContext</i> contract.  There are two reliably defined scopes: <br><ul><li>  A JTA transaction that, through callback, can let Hibernate know when it has completed, which in turn provides the ability to terminate the current session.  This strategy is represented by <i>org.hibernate.context.internal.JTASessionContext</i> - the implementation of the <i>org.hibernate.context.spi.CurrentSessionContext</i> contract.  Using this implementation, the <i>Session</i> will be opened as soon as <i>getCurrentSession () is called</i> within the transaction. </li><li>  The request cycle itself.  <i>Org.hibernate.context.internal.ManagedSessionContext</i> is best represented by the implementation of the <i>org.hibernate.context.spi.CurrentSessionContext</i> contract.  There is an external component responsible for managing the life cycle and scope of the ‚Äúcurrent‚Äù session.  At the stage of starting the scope, the <i>bind ()</i> method is called on the <i>ManagedSessionContext</i> with the transfer of the link to the session.  At the end, the <i>unbind ()</i> method is <i>called</i> . </li></ul><br><div class="spoiler">  <b class="spoiler_title">Important</b> <div class="spoiler_text">  The <i>getCurrentSession ()</i> method has one nasty side in JTA.  If you use it, the <i>after_statement</i> connection release mode will also be used by default.  Due to limitations of JTA, Hibernate cannot automatically clean up any unclosed instance of ScrollableResults or Iterator returned by <i>scroll ()</i> or <i>iterate ()</i> .  The release of DB cursors is done by calling <i>ScrollableResults.close ()</i> or <i>Hibernate.close (Iterator)</i> explicitly from the finally section. <br></div></div><br><a name="2_4_3"></a><h3>  2.4.3.  Dialogues </h3><br>  Session-to-request pattern is not the only unit of work design tool.  Many business processes require a whole series of user interactions that alternate with access to the database.  In web and enterprise applications, it is unacceptable for a database transaction to cover all user interaction.  Consider the following example: <br><br>  <b>Procedure 2.1.</b>  <b>Example of ‚Äúlong-playing‚Äù dialogue</b> <br><ol><li>  The first screen of the dialog opens.  The data shown to the user is loaded in a separate session session and database transaction.  The user can modify any dialog fields. </li><li>  After five minutes of editing, the user uses the UI element to save.  Changes are reflected in the database.  The user also expects exclusive data access during the editing session. </li></ol><br><br>  Even though we have several cases of access to the database, from the user's point of view, this series of steps represents one unit of perfect work (Unit of Work).  There are many ways to implement this in an application. <br><br>  The first (naive) method is to keep <i>Session</i> sessions and transactions open while the user is editing, using database synchronization mechanisms to provide exclusive user access to editable data, and prevent other users from accessing them, ensuring isolation and atomicity.  This is an anti-pattern, since unnecessary synchronization is a bottleneck for performance problems arising in high-load applications. <br><br>  A number of database transactions is used to implement a dialogue with the database.  In this case, ensuring the isolation of business processes falls on the shoulders of the application.  One conversation usually covers multiple transactions.  Multiple database accesses can be atomic if only one transaction (usually the last one) writes to the database.  All others only read the data.  A typical implementation path is through the creation of a wizard-style dialog covering several steps of a request / response cycle.  Hibernate includes some features that allow you to implement similar functionality. <br><br><ul><li>  <b>Automatic Versioning</b> <br>  Hibernate can perform concurrency control for you.  It can automatically detect if third-party <br>  update data while waiting user. <br></li><li>  <b>Detached Objects</b> <br>  If you prefer to use the session-per-request template, <br>  all downloaded instances will be disconnected while the user is waiting.  Hibernate allows you to connect back <br>  objects and save modifications.  This pattern is called <i>session-per-request-with-disconnected</i> objects.  Automatic versioning is used to isolate concurrently running queries. <br></li><li>  <b>Extended session</b> <br>  Session <i>Session</i> can be disconnected from the underlying JDBC connection after the DB transaction is committed, and reconnected when a new client request arises.  This pattern is called <i>session-to-dialogue</i> , which makes the reattachment of objects unnecessary.  Automatic versioning is used to isolate parallel modifications, and the session cannot be flushed automatically, only explicitly. <br></li></ul><br>  <i>Session-to-request-with-disconnected-objects</i> and <i>session-to-dialogue</i> have their pros and cons. <br><br><a name="2_5"></a><h3>  2.5.  Object identity </h3><br>  An application can simultaneously access the same persistent state (a string in a database) in two different sessions.  However, an instance of a persistent class is never split between two different sessions.  Two different notions of identity take place and come into play: DB-identity and JVM-identity. <br><br><a name="e_2_1"></a>  <b>Example 2.1.</b>  <b>DB identity</b> <br><pre><code class="java hljs">foo.getId().equals( bar.getId() )</code> </pre> <br><br><a name="e_2_2"></a>  <b>Example 2.2.</b>  <b>JVM Identity</b> <br><pre> <code class="java hljs">foo==bar</code> </pre><br><br>  For objects attached to the same Session session, two identity concepts are equivalent, and JVM identity is guaranteed by the Hibernate database identity.  An application can simultaneously access a business object with the same database identity in two different sessions; meanwhile, it will be represented by two different instances of Java objects, in terms of JVM identity.  Conflict resolution is performed by optimistic strategy and automatic versioning during flush / commit. <br><br>  This approach places the responsibility for managing concurrency on Hibernate and the database.  It also provides better scalability, since expensive locks are not needed to guarantee identity in a single-threaded unit of work (single-threaded unit of work).  There is no need for the application to synchronize on any business object while it is running in one thread.  Although not recommended, within an Session session, an application can safely use the == operator to compare objects. <br><br>  However, an application using the == operator outside a session can introduce some problems.  If you add two detached instances of an object to the same Set, they will probably have the same database identity, that is, they represent the same row in the table.  It is not at all guaranteed that they will have the same JVM identity, being able to be detached.  Override the equals () and hashCode () methods in persistent classes so that they have their own definition of object equivalence.  Do not use the identity database to implement the equality test.  Instead, use a business key that is a combination of unique, immutable attributes.  The database identifier may change if the object changes from the transient state to the persistent state.  If a transient instance is found with the detached instance in the same Set'e - changing the hashcode will violate the Set'a contract.  Attributes for a business key may be less robust than basic keys.  You only need to guarantee stability as long as the objects are in the same Set.  This is not a Hibernate problem, as it relates to the implementation of object identity and equivalence in Java. <br><br><a name="2_6"></a><h3>  2.6.  General issues </h3><br>  Both <i>session-per-session-user</i> and <i>session-per-application</i> anti-patterns are susceptible to the following issues.  Some of these problems may also occur in the recommended patterns, so first make sure that you understand the implications before making any design decisions: <br><ul><li>  Session <i>Session is</i> not thread safe.  Entities working in parallel, such as HTTP requests, session bins, or Swing workers, will lead to race conditions if a session is divided between threads.  If you store your Hibernate session in your <i>javax.servlet.http.HttpSession</i> (discussed later), you need to consider the problem of synchronized access to your <i>HttpSession</i> ;  otherwise, a user clicking the Refresh button too quickly will use the same session in two threads running in parallel. </li><li>  The exception thrown by Hibernate means that you have to rollback your transaction and close the session immediately (discussed in more detail in the following chapters).  If your session is restricted by the application, you must stop the application.  Rolling back a transaction does not roll back your business objects to the state they were at when the transaction started.  This means that the state in the database and the state of the objects have been out of sync.  Usually, this is not a problem because exceptions are not recoverable, and you still need to start over after a rollback. </li><li>  Session caches each object that is in the persistent state (that is, it is monitored and checked for changes by Hibernate).  If you leave it for a long time, or simply load too much data, it will grow many times, until you get an <i>OutOfMemoryException</i> .  There is a solution to call <i>clear ()</i> and <i>evict ()</i> to manage the session session cache, but you should consider alternative ways of handling large amounts of data, such as stored procedures.  Java is not a suitable tool for this kind of operation.  Some solutions are shown in <a href="http://habrahabr.ru/post/269029/">Chapter 4, Batch Processing</a> .  A session that remains open during the user's session also means a high probability of the appearance of ‚Äústale‚Äù data. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/269485/">https://habr.com/ru/post/269485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269473/index.html">Using gitlab continuous integration for deployment</a></li>
<li><a href="../269475/index.html">CQRS, UI, based on tasks, Event sources ... ah</a></li>
<li><a href="../269477/index.html">Why I bet on Elixir</a></li>
<li><a href="../269479/index.html">Conveniently create Composition Root using Autofac</a></li>
<li><a href="../269481/index.html">I am writing a CMS for PHP. Part 2</a></li>
<li><a href="../269487/index.html">The digest of interesting materials for the mobile developer # 126 (October 19-25)</a></li>
<li><a href="../269489/index.html">How to make friends AWS Lambda and PostgreSQL</a></li>
<li><a href="../269491/index.html">Android 6.0: Doze Mode, App Standby, Runtime Permissions. Everything every developer needs to know</a></li>
<li><a href="../269493/index.html">Taming of the Shrew. We connect a single number to several mobile</a></li>
<li><a href="../269495/index.html">Extreme economy fonts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>