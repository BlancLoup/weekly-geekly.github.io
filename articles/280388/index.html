<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding multithreading in RxJava</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When describing the benefits of RxJava, they always mention the convenience of organizing a multi-threaded application by means of RxJava. How to use ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding multithreading in RxJava</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2f8/0f7/e8c/2f80f7e8c93546d6bd15be252fc7ed10.png"><br>  When describing the benefits of RxJava, they always mention the convenience of organizing a multi-threaded application by means of RxJava.  How to use the subscribeOn and observeOn operators can be found in almost every article on the basics of RxJava.  For example, <a href="http://tomstechnicalblog.blogspot.ru/2016/02/rxjava-understanding-observeon-and.html">there are</a> well described cases when using the subscribeOn methods and when obserOn.  However, in practice, one often encounters problems that require a deeper understanding of what the subscribeOn and observeOn methods do.  In this article I would like to consider a number of issues that sometimes arise when using these operators. <br><a name="habracut"></a><br>  You can study the nuances of RxJava in several ways: by documentation (which is very detailed), by source code or in practice.  I chose the latter method.  To do this, I sketched a couple of tests, according to which I could better understand asynchronous reactive programming. <br><br>  First, to check the work of the flow change, I used the following code: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSchedulersTemplate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observable.Transformer&lt;String, String&gt; transformer)</span></span></span><span class="hljs-function"> </span></span>{ Observable&lt;String&gt; obs = Observable .create(subscriber -&gt; { logThread(<span class="hljs-string"><span class="hljs-string">"Inside observable"</span></span>); subscriber.onNext(<span class="hljs-string"><span class="hljs-string">"Hello from observable"</span></span>); subscriber.onCompleted(); }) .doOnNext(s -&gt; logThread(<span class="hljs-string"><span class="hljs-string">"Before transform"</span></span>)) .compose(transformer) .doOnNext(s -&gt; logThread(<span class="hljs-string"><span class="hljs-string">"After transform"</span></span>)); TestSubscriber&lt;String&gt; subscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestSubscriber&lt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscriber&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ logThread(<span class="hljs-string"><span class="hljs-string">"In onComplete"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String o)</span></span></span><span class="hljs-function"> </span></span>{ logThread(<span class="hljs-string"><span class="hljs-string">"In onNext"</span></span>); } }); obs.subscribe(subscriber); subscriber.awaitTerminalEvent(); }</code> </pre> <br></div></div><br>  Let's check how this code works without any transformations: <br><pre> <code class="java hljs"> testSchedulersTemplate(stringObservable -&gt; stringObservable);</code> </pre><br>  Result: <br>  Inside observable: main <br>  Before transform: main <br>  After transform: main <br>  Inside doOnNext: main <br>  In onNext: main <br>  In onComplete: main <br><br>  As expected, no change of flow. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  1. ObserveOn and SubscribeOn </h3><br>  <b>SubscribeOn</b> <br>  How to understand from the documentation <a href="http://reactivex.io/documentation/operators/subscribeon.html">reactivex.io/documentation/operators/subscribeon.html</a> <br>  With this operator, you can specify the Scheduler in which the Observable process will run. <br>  Checking: <br><pre> <code class="java hljs">testSchedulersTemplate(stringObservable -&gt; stringObservable.subscribeOn(Schedulers.io()));</code> </pre><br>  Result: <br>  Inside observable: RxCachedThreadScheduler-1 <br>  Before transform: RxCachedThreadScheduler-1 <br>  After transform: RxCachedThreadScheduler-1 <br>  Inside doOnNext: RxCachedThreadScheduler-1 <br>  In onNext: RxCachedThreadScheduler-1 <br>  In onComplete: RxCachedThreadScheduler-1 <br><br>  Beginning with the execution of the Observable content and until the result was obtained, all methods were executed in the stream created by Schedulers.io (). <br><br>  <b>Observeon</b> <br>  The documentation for this method <a href="http://reactivex.io/documentation/operators/observeon.html">says</a> that the use of this operator causes subsequent operations on the ‚Äúradiated‚Äù data to be performed using the Scheduler passed to this method. <br><br>  Checking: <br><pre> <code class="java hljs">testSchedulersTemplate(stringObservable -&gt; stringObservable.observeOn(Schedulers.io()));</code> </pre><br>  Result: <br>  Inside observable: main <br>  Before transform: main <br>  After transform: RxCachedThreadScheduler-1 <br>  Inside doOnNext: RxCachedThreadScheduler-1 <br>  In onNext: RxCachedThreadScheduler-1 <br>  In onComplete: RxCachedThreadScheduler-1 <br><br>  As expected, from the moment the observeOn method is applied, the stream in which the data is processed will be changed to the one that the specified Scheduler will allocate to it. <br><br>  Let's combine the use of subscribeOn and observeOn: <br><pre> <code class="java hljs">testSchedulersTemplate(stringObservable -&gt; stringObservable .subscribeOn(Schedulers.computation()) .observeOn(Schedulers.io()));</code> </pre><br>  Result: <br>  Inside observable: RxComputationThreadPool-3 <br>  Before transform: RxComputationThreadPool-3 <br>  After transform: RxCachedThreadScheduler-1 <br>  Inside doOnNext: RxCachedThreadScheduler-1 <br>  In onNext: RxCachedThreadScheduler-1 <br>  In onComplete: RxCachedThreadScheduler-1 <br><br>  The methods performed before applying the observeOn operator were performed in the Scheduler specified in subscribeOn, and after in the scheduler specified in observeOn. <br><br>  By combining these two methods, you can achieve asynchronous downloading of data from the Internet and display them on the screen in the main application stream. <br><br>  But what happens if you apply these methods several times? <br>  To begin, call observeOn several times: <br><pre> <code class="java hljs">testSchedulersTemplate(stringObservable -&gt; stringObservable .observeOn(Schedulers.computation()) .doOnNext(str -&gt; logThread(<span class="hljs-string"><span class="hljs-string">"Between two observeOn"</span></span>)) .observeOn(Schedulers.io()));</code> </pre><br>  Inside observable: main <br>  Before transform: main <br>  Between two observeOn: RxComputationThreadPool-3 <br>  After transform: RxCachedThreadScheduler-1 <br>  Inside doOnNext: RxCachedThreadScheduler-1 <br>  In onNext: RxCachedThreadScheduler-1 <br>  In onComplete: RxCachedThreadScheduler-1 <br><br>  No surprises.  After using observeOn, the elements are processed using the specified Scheduler. <br><br>  Now call subscribeOn several times. <br><pre> <code class="java hljs">testSchedulersTemplate(stringObservable -&gt; stringObservable .subscribeOn(Schedulers.computation()) .doOnNext(str -&gt; logThread(<span class="hljs-string"><span class="hljs-string">"Between two observeOn"</span></span>)) .subscribeOn(Schedulers.io()));</code> </pre><br>  Result: <br>  Inside observable: RxComputationThreadPool-1 <br>  Before transform: RxComputationThreadPool-1 <br>  Between two observeOn: RxComputationThreadPool-1 <br>  After transform: RxComputationThreadPool-1 <br>  Inside doOnNext: RxComputationThreadPool-1 <br>  In onNext: RxComputationThreadPool-1 <br>  In onComplete: RxComputationThreadPool-1 <br><br>  As you can see, the use of the second subscribeOn has not led to any changes.  But is it completely useless? <br><br>  Add a statement between calls to subscribeOn: <br><pre> <code class="java hljs">.lift((Observable.Operator&lt;String, String&gt;) subscriber -&gt; { logThread(<span class="hljs-string"><span class="hljs-string">"Inside lift"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> subscriber; })</code> </pre><br>  Get the first message in the log: <br>  Inside lift: RxCachedThreadScheduler-1 <br><br>  RxCachedThreadScheduler-1 is the one that was obtained from Schedulers.io () specified in the second call to subscribeOn. <br><br>  lift () is an operator with which you can transform a subscription. <br>  You can schematically describe the subscription process as follows: <br>  User subscribes to observable by passing subscription. <br>  This subscription is delivered to the root observable, and it can be converted with the help of operators. <br>  Subscription is passed to observable, sent onNext, onComplete, onError. <br>  Transformations are performed on the generated elements. <br>  The converted elements fall into the onNext of the original subscriber. <br>  Thus, when a subscription is delivered to observable, you can change the stream using subscribeOn.  And when elements are delivered from observable to subscription - it is affected by observeOn. <br>  In order to illustrate this, consider the code: <br><pre> <code class="java hljs">Observable.create(subscriber -&gt; { ... }) .map(val-&gt; val*<span class="hljs-number"><span class="hljs-number">2</span></span>) .subscribe(val -&gt; Log.d(TAG, ‚ÄúonNext ‚Äú + val));</code> </pre><br>  The subscriber created in the last line is passed to the Observable created with Observable.create ().  Inside the map statement, the lift statement is called, where Operation is passed, which decorates Subscriber during the subscription.  When the Observable emits data, it falls into the decorated Subscriber.  Decorated Subscriber modifies the data and sends it to the original Subscriber. <br>  Without a Scheduler change, the entire process will be executed in the thread in which the subscribe method is called.  Further, while Subscriber is being decorated, with the help of subscribeOn you can change the stream in which the next decoration will be performed.  In the call () method of the OnSubscribe interface, the latest Scheduler specified in SubscribeOn will be used.  After the data has been radiated, the Scheduler is already changing using onserveOn. <br><img src="https://habrastorage.org/files/dff/b9a/12e/dffb9a12e15348209709cdb430409ac9.png"><br><h3>  2. Perform tasks in parallel. </h3><br>  Consider the following case: <br>  It is necessary to download various information from the server, then compile it and display it on the screen.  At the same time, to speed up the process, it is worth loading data in parallel (if there is such an opportunity).  If we did not have RxJava, then this task would require considerable effort.  But with reactive programming, this task is trivial. <br><br>  We will perform three tasks, each of which waits for 1 second, and then sends a message in a subscription.  Then, using the combineLatest operator, all messages will be merged and transferred to the subscription. <br><br>  For verification, we will use the following code: <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">template</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Observable.Transformer&lt;String, String&gt; transformer, Observable.Transformer&lt;String, String&gt; firstObsTransformer, Observable.Transformer&lt;String, String&gt; secondObsTransformer, Observable.Transformer&lt;String, String&gt; thirdObsTransformer)</span></span></span><span class="hljs-function"> </span></span>{ Observable&lt;String&gt; obs = Observable.combineLatest(createObservable(<span class="hljs-string"><span class="hljs-string">"Observable1"</span></span>, firstObsTransformer), createObservable(<span class="hljs-string"><span class="hljs-string">"Observable2"</span></span>, secondObsTransformer), createObservable(<span class="hljs-string"><span class="hljs-string">"Observable3"</span></span>, thirdObsTransformer), (s, s2, s3) -&gt; { logThread(<span class="hljs-string"><span class="hljs-string">"Inside combining result"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s + s2 + s3; }) .doOnNext(s -&gt; logThread(<span class="hljs-string"><span class="hljs-string">"Before transform"</span></span>)) .compose(transformer) .doOnNext(s -&gt; logThread(<span class="hljs-string"><span class="hljs-string">"After tranform"</span></span>)); TestSubscriber&lt;String&gt; subscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestSubscriber&lt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscriber&lt;String&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ logThread(<span class="hljs-string"><span class="hljs-string">"In onComplete"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String o)</span></span></span><span class="hljs-function"> </span></span>{ logThread(<span class="hljs-string"><span class="hljs-string">"In onNext"</span></span>); } }); obs.subscribe(subscriber); subscriber.awaitTerminalEvent(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Observable&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createObservable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String name, Observable.Transformer&lt;String, String&gt; transformer)</span></span></span><span class="hljs-function"> </span></span>{ Observable&lt;String&gt; result = Observable.create(subscriber -&gt; { logThread(<span class="hljs-string"><span class="hljs-string">"Inside "</span></span> + name); sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); subscriber.onNext(name); subscriber.onCompleted(); }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transformer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.compose(transformer); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br></div></div><br>  To begin, run the test without any transformations: <br><pre> <code class="java hljs">template(stringObservable -&gt; stringObservable, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br>  Result: <br>  Inside Observable1: main <br>  Inside Observable2: main <br>  Inside Observable3: main <br>  Inside combining result: main <br>  Before transform: main <br>  After tranform: main <br>  In onNext: main <br>  In onComplete: main <br><br>  As you can see, everything is performed in one thread.  Our three tasks are performed sequentially. <br><br>  Add subscribeOn and observeOn for observable, obtained using the zip function. <br><pre> <code class="java hljs">template(stringObservable -&gt; stringObservable.subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()), <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br>  Result: <br>  Inside Observable1: RxCachedThreadScheduler-1 <br>  Inside Observable2: RxCachedThreadScheduler-1 <br>  Inside Observable3: RxCachedThreadScheduler-1 <br>  Inside combining result: RxCachedThreadScheduler-1 <br>  Before transform: RxCachedThreadScheduler-1 <br>  After tranform: RxNewThreadScheduler-1 <br>  In onNext: RxNewThreadScheduler-1 <br>  In onComplete: RxNewThreadScheduler-1 <br><br>  Everything is as it was described in the previous part of the article about subscribeOn and observeOn. <br><br>  Now we will carry out each of the tasks in our thread.  For this it is enough to specify Scheduler.io (), since  inside it contains a pool of threads, optimal for loading data. <br><pre> <code class="java hljs">Observable.Transformer&lt;String, String&gt; ioTransformer = stringObservable -&gt; stringObservable.subscribeOn(Schedulers.io()); template(stringObservable -&gt; stringObservable.subscribeOn(Schedulers.newThread()) .observeOn(Schedulers.computation()), ioTransformer, ioTransformer, ioTransformer);</code> </pre><br>  Result: <br>  Inside Observable1: RxCachedThreadScheduler-1 <br>  Inside Observable2: RxCachedThreadScheduler-2 <br>  Inside Observable3: RxCachedThreadScheduler-3 <br>  Inside combining result: RxCachedThreadScheduler-3 <br>  Before transform: RxCachedThreadScheduler-3 <br>  After tranform: RxComputationThreadPool-3 <br>  In onNext: RxComputationThreadPool-3 <br>  In onComplete: RxComputationThreadPool-3 <br><br>  We achieved what we wanted - our three tasks were performed in parallel. <br><h3>  3. Operators with Schedulers. </h3><br>  In the previous chapter, the delay () operator would be great for emulating long tasks, but the problem is that this operator is not as simple as it might seem at first glance. <br>  There are a number of operators that require specifying a Scheduler for their work.  Moreover, there are overloaded versions of them, which use computation () as the Scheduler.  delay () is an example of such an operator: <br><pre> <code class="java hljs">TestSubscriber&lt;Integer&gt; subscriber = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TestSubscriber&lt;&gt;(); Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>).delay(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.SECONDS).subscribe(subscriber); subscriber.awaitTerminalEvent(); Logger.d(<span class="hljs-string"><span class="hljs-string">"LastSeenThread: "</span></span> + subscriber.getLastSeenThread().getName());</code> </pre><br>  Although we did not specify any Scheduler, the result will be as follows: <br>  LastSeenThread: RxComputationThreadPool-1 <br><br>  In order to avoid the use of computation scheduler, the third parameter is enough to pass the required scheduler: <br>  .delay (1, TimeUnit.SECONDS, Schedulers.immediate ()) <br><br>  Note: Schedulers.immediate () - performs the task in the same thread in which the previous task was performed. <br><br>  Result: <br>  LastSeenThread: main <br><br>  In addition to delay (), there are other operators that can themselves change Scheduler: interval (), timer (), some overloads buffer (), debounce (), skip (), take (), timeout (), and some others. <br><br><h3>  4. Subjects. </h3><br>  When using Subjects, it is worth considering that by default the chain of changes to the data sent to the onNext subject will be executed in the same thread in which the onNext () method was called.  Until the operator observeOn occurs in the chain of transformations. <br>  But apply subscribeOn so simply will not work. <br><br>  Consider the following code: <br><pre> <code class="java hljs"> BehaviorSubject&lt;Object&gt; subject = BehaviorSubject.create(); subject .doOnNext(obj -&gt; Logger.logThread(<span class="hljs-string"><span class="hljs-string">"doOnNext"</span></span>)) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.newThread()) .subscribe(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subscriber&lt;Object&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Logger.logThread(<span class="hljs-string"><span class="hljs-string">"onComplete"</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object o)</span></span></span><span class="hljs-function"> </span></span>{ Logger.logThread(<span class="hljs-string"><span class="hljs-string">"onNext"</span></span>); } }); subject.onNext(<span class="hljs-string"><span class="hljs-string">"str"</span></span>); Handler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Handler(); handler.postDelayed(() -&gt; subject.onNext(<span class="hljs-string"><span class="hljs-string">"str"</span></span>), <span class="hljs-number"><span class="hljs-number">1000</span></span>); handler.postDelayed(() -&gt; subject.onNext(<span class="hljs-string"><span class="hljs-string">"str"</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>);</code> </pre><br>  Both observeOn and subscribeOn are indicated here, but the result will be as follows: <br>  doOnNext: RxCachedThreadScheduler-1 <br>  onNext: RxNewThreadScheduler-1 <br>  doOnNext: main <br>  onNext: RxNewThreadScheduler-1 <br>  doOnNext: main <br>  onNext: RxNewThreadScheduler-1 <br><br>  Those.  when we subscribe to subject, it immediately returns the value and it is processed by the stream from Shedulers.io (), but when the next message arrives in subject, the stream in which onNext () was called is used. <br><br>  Therefore, if you, after receiving the object from subject, start some kind of long operation, then you must explicitly put observeOn between them. <br><br><h4>  5. Backpressure </h4><br>  In this article, it is impossible not to mention such a concept as backpressure.  MissingBackpressureException - an error that spoiled my nerves quite a bit.  I will not retell here what can be read in the official RxJava wiki: <a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure">github.com/ReactiveX/RxJava/wiki/Backpressure</a> .  But if you are actively using RxJava, then you should definitely read about backpressure. <br>  When you have in an application there is some data producer in one stream and some consumer in another, then you should take into account the situation when the consumer will not have time to process the data.  In such a situation, you will be helped by the operators described in the link provided. <br><br><h4>  Conclusion </h4><br>  RxJava makes it very convenient to manage the execution of tasks in different threads.  But when using it, it is worth knowing very well what exactly subscribeOn, observeOn do, as well as how different operators behave. <br>  You should carefully study the documentation for the operators that you use - they indicate in which Scheduler the statement is executed.  It is also worth being careful with the Subject.  And do not forget about backpressure. <br>  It is also worth considering one of the tips that Ben Christensen (@benjchristensen) once gave - one of the main authors of RxJava: <br><blockquote>  ‚ÄúIt can be asynchronously delivered, even though it can be synchronized.‚Äù </blockquote><br><blockquote>  ‚ÄúFor the subscriber, it makes sense to assume that the data is delivered asynchronously, even in cases where it can be delivered synchronously.‚Äù </blockquote><br>  Link to the source from the article: <a href="https://github.com/HotIceCream/GrokkingRxSchedulers">github.com/HotIceCream/GrokkingRxSchedulers</a> </div><p>Source: <a href="https://habr.com/ru/post/280388/">https://habr.com/ru/post/280388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../280378/index.html">man! (Go => D) .concurrency</a></li>
<li><a href="../280380/index.html">We solve the problem of interception and substitution of DNS queries. DNSCrypt in Yandex Browser</a></li>
<li><a href="../280382/index.html">Yii framework code parsing</a></li>
<li><a href="../280384/index.html">Million files and one laptop</a></li>
<li><a href="../280386/index.html">Flume - manage data streams. Part 1</a></li>
<li><a href="../280390/index.html">SaaS solutions to protect any device anywhere: why it‚Äôs simpler and cheaper + implementation example</a></li>
<li><a href="../280394/index.html">How to develop 1C: ERP (and not only)</a></li>
<li><a href="../280396/index.html">About type conversion in arithmetic expressions in C ++ and C #</a></li>
<li><a href="../280400/index.html">Playtests: fears and opportunities</a></li>
<li><a href="../280402/index.html">Installing Bitrix24 on IIS server using MSSQL and AD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>