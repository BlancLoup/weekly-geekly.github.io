<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We download the history of correspondence with all users of VKontakte using Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For linguistic research, I needed the corpus of direct speech generated by one person. I decided that for the beginning it was most convenient to use ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We download the history of correspondence with all users of VKontakte using Python</h1><div class="post__text post__text-html js-mediator-article">  For linguistic research, I needed the corpus of direct speech generated by one person.  I decided that for the beginning it was most convenient to use my own correspondence in the VC.  This article is about how to download all the messages you have ever sent to your friends using the Python program and the VKontakte API.  To work with the API, we will use the <a href="">vk</a> library. <a name="habracut"></a><br><br>  To work with the site, you need to create an application and log in using a token.  This process is nothing complicated and is described <a href="http://pikabu.ru/story/api_vkontakte_dlya_python_3961240">here</a> and <a href="https://habrahabr.ru/sandbox/84639/">here</a> . <br><br>  So, the token is received.  We import the necessary libraries (we will need time and re later), connect to our application and get started. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re session = vk.Session(access_token=<span class="hljs-string"><span class="hljs-string">'your_token'</span></span>) vkapi = vk.API(session)</code> </pre> <br>  Since we want to receive correspondence with all friends, let's start by getting a list of friends.  Further processing of the complete list of friends can be quite long, so for testing you can write the id of several friends manually. <br><br><pre> <code class="python hljs">friends = vkapi(<span class="hljs-string"><span class="hljs-string">'friends.get'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#       # friends = [1111111, 2222222, 33333333] #   </span></span></code> </pre> <br>  Having a list of friends, you can immediately start downloading dialogs with them, but I want to process only those dialogues that contain more than 200 messages, since short conversations with unfamiliar people are not very interesting for me.  Therefore, we write a function that returns the "caps" of the dialogs. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_dialogs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_id)</span></span></span><span class="hljs-function">:</span></span> dialogs = vkapi(<span class="hljs-string"><span class="hljs-string">'messages.getDialogs'</span></span>, user_id=user_id) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dialogs</code> </pre> <br>  This function returns the "header" of the dialogue with the user, whose id is equal to the specified user_id.  The result of her work looks like this: <br><br> <code>[96, {'title': ' ... ', 'body': '', 'mid': 333333, 'read_state': 1, 'uid': 111111, 'date': 1490182267, 'fwd_messages': [{'date': 1490173134, 'body': ',      ,     .', 'uid': 222222}], 'out': 0}]</code> <br> <br>  The resulting list contains the number of messages (96) and the data of the last message in the dialogue.  Now we have everything you need to download the necessary dialogues. <br><br>  The main disadvantage is that VKontakte allows you to make a maximum of about three requests per second, so after each request you need to wait some time.  For this we need the time library.  The smallest waiting time that I was able to deliver in order not to get a refusal after several operations was 0.3 seconds. <br><br>  Another difficulty is that in one request you can download a maximum of 200 messages.  With this, too, will have to fight.  Let's write a function. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_history</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(friends, sleep_time=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> all_history = [] i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> friend <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> friends: friend_dialog = get_dialogs(friend) time.sleep(sleep_time) dialog_len = friend_dialog[<span class="hljs-number"><span class="hljs-number">0</span></span>] friend_history = [] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dialog_len &gt; <span class="hljs-number"><span class="hljs-number">200</span></span>: resid = dialog_len offset = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> resid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: friend_history += vkapi(<span class="hljs-string"><span class="hljs-string">'messages.getHistory'</span></span>, user_id=friend, count=<span class="hljs-number"><span class="hljs-number">200</span></span>, offset=offset) time.sleep(sleep_time) resid -= <span class="hljs-number"><span class="hljs-number">200</span></span> offset += <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> resid &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: print(<span class="hljs-string"><span class="hljs-string">'--processing'</span></span>, friend, <span class="hljs-string"><span class="hljs-string">':'</span></span>, resid, <span class="hljs-string"><span class="hljs-string">'of'</span></span>, dialog_len, <span class="hljs-string"><span class="hljs-string">'messages left'</span></span>) all_history += friend_history i +=<span class="hljs-number"><span class="hljs-number">1</span></span> print(<span class="hljs-string"><span class="hljs-string">'processed'</span></span>, i, <span class="hljs-string"><span class="hljs-string">'friends of'</span></span>, len(friends)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> all_history</code> </pre> <br>  We will understand what is happening here. <br><br>  We go through the list of friends and get a dialogue with each of them.  Consider the length of the dialogue.  If the dialog is shorter than 200 messages, just go to the next friend, if longer, then download the first 200 messages (count argument), add them to the message history for this friend and calculate how many more messages are left to download (resid).  As long as the remainder is greater than 0, with each iteration, we increase the offset argument, which allows you to set the indent in the number of messages from the end of the dialog, by 200. <br><br>  Because of the need to wait after each request, the program works for quite a long time, so I added the output of a small report on the current step, in order to understand what is being processed and how much is left. <br><br>  NB: The messages.get method has an out argument, with which you can ask the server to send outgoing messages only.  I decided not to use it and select the messages I needed after downloading for the following reasons: a) the file will still have to be cleaned, since  the server gives each message in the form of a dictionary containing a lot of technical information and b) the messages of the interlocutors may also be of interest for my research. <br><br>  Each downloaded message is a dictionary and looks like this: <br> <code>{'read_state': 1, 'date': 1354794668, 'body': ' !&lt;br&gt;      .', 'uid': 111111, 'mid': 222222, 'from_id': 111111, 'out': 1}</code> <br> <br>  Then it remains only to clear the result and save it to a file.  This part of the work no longer applies to the interaction with the VK API, so I will not dwell on it in detail.  And what is there to tell - just select the necessary elements (body) for the desired user and with the help of re we remove line breaks that are marked with the <code>&lt;br&gt;</code> tag.  Save everything to a file. <br><br>  The complete program code looks like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> vk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re session = vk.Session(access_token=<span class="hljs-string"><span class="hljs-string">'your_token'</span></span>) vkapi = vk.API(session) SELF_ID = <span class="hljs-number"><span class="hljs-number">111111</span></span> SLEEP_TIME = <span class="hljs-number"><span class="hljs-number">0.3</span></span> friends = vkapi(<span class="hljs-string"><span class="hljs-string">'friends.get'</span></span>) <span class="hljs-comment"><span class="hljs-comment">#        def get_dialogs(user_id): dialogs = vkapi('messages.getDialogs', user_id=user_id) return dialogs def get_history(friends, sleep_time=0.3): all_history = [] i = 0 for friend in friends: friend_dialog = get_dialogs(friend) time.sleep(sleep_time) dialog_len = friend_dialog[0] friend_history = [] if dialog_len &gt; 200: resid = dialog_len offset = 0 while resid &gt; 0: friend_history += vkapi('messages.getHistory', user_id=friend, count=200, offset=offset) time.sleep(sleep_time) resid -= 200 offset += 200 if resid &gt; 0: print('--processing', friend, ':', resid, 'of', dialog_len, 'messages left') all_history += friend_history i +=1 print('processed', i, 'friends of', len(friends)) return all_history def get_messages_for_user(data, user_id): self_messages = [] for dialog in data: if type(dialog) == dict: if dialog['uid'] == user_id and dialog['from_id'] == user_id: m_text = re.sub("&lt;br&gt;", " ", dialog['body']) self_messages.append(m_text) print('Extracted', len(self_messages), 'messages in total') return self_messages def save_to_file(data, file_name='output.txt'): with open(file_name, 'w', encoding='utf-8') as f: print(data, file=f) if __name__ == '__main__': all_history = get_history(friends, SLEEP_TIME) save_to_file(all_history, 'raw.txt') self_messages = get_messages_for_user(all_history, SELF_ID) save_to_file(self_messages, 'sm_corpus.txt')</span></span></code> </pre> <br>  At the time of launching the program, I had 879 friends in the VC.  It took about 25 minutes to process them.  The file with the raw result had a volume of 74MB.  After selecting the text of only my messages - 15MB.  The total number of messages in the received package is about 150,000, and their text takes 3,707 pages (in the Word document). <br><br>  I hope my article will be useful for someone.  All methods that can be used to access the VK API are described in detail in the <a href="https://vk.com/dev/methods">section for</a> VK <a href="https://vk.com/dev/methods">developers</a> . </div><p>Source: <a href="https://habr.com/ru/post/325368/">https://habr.com/ru/post/325368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325358/index.html">Why do you need containerd and why it was separated from Docker</a></li>
<li><a href="../325360/index.html">Comparing OpenMP on different platforms</a></li>
<li><a href="../325362/index.html">Do not stay in the cold on April 1st - make a backup</a></li>
<li><a href="../325364/index.html">Making a spell checker on phonetic algorithms with your own hands</a></li>
<li><a href="../325366/index.html">Intel processors will triple</a></li>
<li><a href="../325370/index.html">HTTP / 2 Server Push to Go 1.8</a></li>
<li><a href="../325372/index.html">CLion 2017.1 release: C ++ 14, C ++ 17, disassembler code in debugger, Catch, MSVC and much more</a></li>
<li><a href="../325374/index.html">Python Junior Meetup # 2</a></li>
<li><a href="../325376/index.html">Reactive applications with Model-View-Intent. Part 1: Model</a></li>
<li><a href="../325378/index.html">Moscow Python Meetup ‚Ññ44</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>