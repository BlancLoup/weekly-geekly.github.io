<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing FEM calculator in less than 180 lines of code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nowadays, FEM is probably the most common method for solving a wide range of applied engineering problems. Historically, it appeared from mechanics, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing FEM calculator in less than 180 lines of code</h1><div class="post__text post__text-html js-mediator-article">  Nowadays, <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D1%2585_%25D1%258D%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2">FEM</a> is probably the most common method for solving a wide range of applied engineering problems.  Historically, it appeared from mechanics, but was subsequently applied to all kinds of non-mechanical tasks. <br><br>  Today there is a wide variety of software packages, such as <strong>ANSYS</strong> , <strong>Abaqus</strong> , <strong>Patran</strong> , <strong>Cosmos</strong> , etc.  These software packages allow you to solve problems of structural mechanics, fluid mechanics, thermodynamics, electrodynamics, and many others.  The implementation of the method itself, as a rule, is considered rather complicated and voluminous. <br><br>  Here I want to show that at present, using modern tools, writing the simplest FEM calculator from scratch for a two-dimensional problem of a plane-stressed state is not something very complicated and cumbersome.  I chose this type of problem because it was the first successful example of the application of the finite element method.  And of course it is the easiest to implement.  I am going to use a linear, three-node element, since it is the only flat element in which case no numerical integration is required, as will be shown below.  For elements of a higher order, with the exception of the integration operation (which is not quite trivial, but its implementation is quite interesting), the idea is absolutely the same. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Picture to attract attention: <br><img src="https://habrastorage.org/files/56f/6e4/ba6/56f6e4ba6700419dba05e0947b99ed43.png"><br><a name="habracut"></a><br>  Historically, the first practical application of FEM was in the field of mechanics, which significantly affected the terminology and the first interpretations of the method.  In the simplest case, the essence of the method can be described as follows: the continuum is replaced by an equivalent hinge system, and the solution of statically indefinable systems is a well-known and studied problem of mechanics.  This simplified, engineering interpretation has contributed to the widespread dissemination of the method, but strictly speaking, this understanding of the method is incorrect.  The exact mathematical substantiation of the method was given much later than the first successful applications of the method, but this made it possible to expand the field of application for a larger range of tasks, not only from the field of mechanics. <br><br>  I am not going to describe the method in detail, there is a lot of literature about it, instead I will focus on the implementation of the method.  Minimum knowledge of mechanics, or the same strength of materials, will be required.  I will also be happy if reviews from people who are not related to mechanics, if at least the idea was clear.  The implementation of the method will be in C ++, however, I will not use any strongly specific features of this language and I hope that the code will be understood by people who do not know this language. <br><br>  Since this is just an example of the implementation of the method, so as not to complicate and leave everything in the most simple form to understand, I will prefer brevity at the expense of many programming principles.  This is not an example of writing good, maintained and reliable code; it is an example of the implementation of the FEM.  So there will be many simplifications to concentrate on the main goal. <br><br><h1>  <font color="#ff5e23">Input data</font> </h1><br>  Before proceeding to the method itself, let's find out in what form we will represent the input data.  The object under consideration should be divided into a large number of small elements, in our case - triangles.  Thus, we replace the continuous medium with a set of nodes and finite elements that form a grid.  The figure below shows an example of a grid with numbered nodes and elements. <br><br><img src="https://habrastorage.org/files/c22/f6a/91f/c22f6a91f9b04a3ea773ee8b8b365472.png"><br><br>  In the figure we see nine nodes and eight elements.  To describe the grid, you need two lists: <br><br><ul><li>  A list of nodes that defines the coordinates of each node. </li><li>  List of items. </li></ul><br>  In the list of elements, each element is defined by the set of indexes of the nodes that form the element.  In our case, we only have triangular elements, so we will use only three indexes for each element. <br>  As an example, for the grid shown above, we will have the following lists: <br><br>  List of nodes: <br><pre><code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span> 31<span class="hljs-selector-class"><span class="hljs-selector-class">.500000</span></span> 15<span class="hljs-selector-class"><span class="hljs-selector-class">.516667</span></span> 31<span class="hljs-selector-class"><span class="hljs-selector-class">.500000</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span> 19<span class="hljs-selector-class"><span class="hljs-selector-class">.489759</span></span> 18<span class="hljs-selector-class"><span class="hljs-selector-class">.804134</span></span> 23<span class="hljs-selector-class"><span class="hljs-selector-class">.248226</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span> 20<span class="hljs-selector-class"><span class="hljs-selector-class">.479981</span></span> 11<span class="hljs-selector-class"><span class="hljs-selector-class">.365822</span></span> 27<span class="hljs-selector-class"><span class="hljs-selector-class">.516667</span></span> 19<span class="hljs-selector-class"><span class="hljs-selector-class">.500000</span></span> 27<span class="hljs-selector-class"><span class="hljs-selector-class">.516667</span></span> 11<span class="hljs-selector-class"><span class="hljs-selector-class">.365822</span></span> 27<span class="hljs-selector-class"><span class="hljs-selector-class">.516667</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.000000</span></span></code> </pre> <br>  List of items: <br><pre> <code class="hljs">1 3 2 2 3 4 4 6 7 4 3 6 7 6 8 3 5 6 6 5 9 6 9 8</code> </pre><br>  It is worth noting that there are several ways to specify the same element.  Node indices can be listed clockwise or counterclockwise.  The counterclockwise enumeration is usually used, so we will assume that all elements are defined in this way. <br><br>  Let's create some input file with a complete description of the task.  To avoid confusion and not complicate, it is better to use indexing, which starts from zero, and not from one, because in C / C ++ arrays are indexed from zero.  For the first test input file, we will create the simplest possible grid: <br><br><img src="https://habrastorage.org/files/5d7/20f/3f5/5d720f3f5c274f3e87b5be7a01bf7117.png"><br><br>  Let the first line be a description of the properties of the material.  For example, for steel, the Poisson's ratio is ŒΩ = 0.3 and the Young's modulus is E = 2000 MPa: <br><br><pre> <code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> 2000</code> </pre> <br>  Then follows a line with the number of nodes and then the list of nodes: <br><pre> <code class="hljs css">4 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span></code> </pre><br>  Then follows a line with the number of elements, then a list of elements: <br><pre> <code class="hljs">2 0 1 2 1 3 2</code> </pre><br>  Now, we need to specify constraints, or as they say, conditions on the border of the first kind.  As such boundary conditions, we will fix the displacements of the nodes.  It is possible to fix movements along the axes independently of each other, i.e.  we can prohibit movement along the x axis or along the y axis or both at once.  In general, you can specify some initial displacement, however, we restrict ourselves to only zero initial displacement.  Thus, we will have a list of nodes with a given type of movement restrictions.  The type of restriction will be indicated by the number: <br><ul><li>  1 - movement in the direction of the x axis is prohibited </li><li>  2 - movement in the direction of the y axis is prohibited </li><li>  3 - moving in both, x and y directions is prohibited </li></ul><br>  The first line defines the number of restrictions: <br><pre> <code class="hljs">2 0 3 1 2</code> </pre><br>  Then, we have to set the load.  We will work only with the nodal forces.  Strictly speaking, the nodal forces should not be viewed as forces in the general sense of the word; I will talk about this later, but for now let's think of them simply as forces acting on a node.  We need a list with indexes of nodes and corresponding force vectors.  The first line defines the number of applied forces: <br><br><pre> <code class="hljs css">2 2 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 3 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span></code> </pre><br>  It is easy to see that the task in question is a square-shaped body, the bottom of which is fixed, and tensile forces act on the upper edge. <br><br><img src="https://habrastorage.org/files/ed8/d86/e21/ed8d86e2151e4861a7a6411ecd51dc0d.png"><br><br>  Full input file: <br><pre> <code class="hljs css">0<span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> 2000 4 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 2 0 1 2 1 3 2 2 0 3 1 2 2 2 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 3 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span></code> </pre><br><br><h1>  <font color="#ff5e23"><b>Eigen</b> - Mathematical Library</font> </h1><br>  Before I start writing the code, I would like to talk about the mathematical library - <a href="http://eigen.tuxfamily.org/"><b>Eigen</b></a> .  It is a mature, reliable and efficient library that has a very clean and expressive API.  There are many compile-time optimizations in it, the library is able to perform explicit vectoring and supports SSE 2/3/4, ARM and NEON instructions.  As for me, this library is remarkable at least in that it allows you to implement complex mathematical calculations in a brief and expressive way. <br>  I would like to make a brief description of the part of the Eigen API, which we will use below.  Readers who are familiar with this library may skip this section. <br><br>  There are two types of matrices: dense and sparse.  We will use both types.  In the case of a dense matrix, all elements are in memory, in the order of the indices, both column-major (default) and raw-major placement are supported.  This type of matrix is ‚Äã‚Äãgood for relatively small matrices or matrices with a small number of zero elements.  Sparse matrices are good for storing large matrices with a small number of non-zero elements.  We will use a sparse matrix for the global stiffness matrix. <br><br><h3>  Dense matrices </h3><br>  To use dense matrices, we will need to include the <em>&lt;Eigen / Dense&gt;</em> header.  There are two main types of dense matrices: with fixed and with dynamic size.  A fixed-size matrix is ‚Äã‚Äãa matrix whose size is known at compile time.  In the case of a matrix of dynamic size, its size can be specified at the stage of code execution, moreover, the size of the dynamic matrix can even be changed on the fly.  Of course, you need to give preference to matrices with a fixed size wherever possible.  Memory for dynamic matrices is allocated on the heap, and the unknown size of the matrix limits the optimizations that the compiler can do.  Fixed matrices can be allocated on the stack, the compiler can expand loops and much more.  It should be noted that a mixed type is also possible, when the number of rows in the matrix is ‚Äã‚Äãfixed, but the number of columns is dynamic, or vice versa. <br><br>  Fixed-size matrices can be defined as follows: <br><br><pre> <code class="hljs cpp">Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>&gt; m;</code> </pre> <br><br>  Where m is the float matrix c of fixed sizes of 3 √ó 3. You can also use the following predefined types: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix2i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix3i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix4i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix2f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix3f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix4f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix2d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix3d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix4d</span></span></code> </pre><br><br>  There are a few more predefined types, these are basic.  The number indicates the dimension of the square matrix and the letter indicates the type of the matrix element: i is an integer, f is a single-precision floating-point number, d is a double-precision floating-point number. <br><br>  For vectors there is no separate type, vectors are the same matrices.  The column vector (sometimes in the literature there are row vectors, you have to specify), you can declare as follows: <br><br><pre> <code class="hljs cpp">Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; v;</code> </pre> <br><br>  Or you can use one of the predefined types (the notation is the same as for matrices): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector2i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector3i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector4i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector2f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector3f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector4f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector2d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector3d</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector4d</span></span></code> </pre><br><br>  For quick reference, I wrote the following example: <br><br><pre> <code class="hljs lua">#include &lt;iostream&gt; int main() { //Fixed size <span class="hljs-number"><span class="hljs-number">3</span></span>x3 matrix of floats Eigen::Matrix3f A; A &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Matrix A:"</span></span> &lt;&lt; std::endl &lt;&lt; A &lt;&lt; std::endl; //Access to matrix element [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]: std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A[1, 1]:"</span></span> &lt;&lt; std::endl &lt;&lt; A(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; std::endl; //Fixed size <span class="hljs-number"><span class="hljs-number">3</span></span> vector of floats Eigen::Vector3f B; B &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Vector B:"</span></span> &lt;&lt; std::endl &lt;&lt; B &lt;&lt; std::endl; //Access to vector element [<span class="hljs-number"><span class="hljs-number">1</span></span>]: std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"B[1]:"</span></span> &lt;&lt; std::endl &lt;&lt; B(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; std::endl; //Multiplication of vector <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> matrix Eigen::Vector3f C = A * B; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"C = A * B:"</span></span> &lt;&lt; std::endl &lt;&lt; C &lt;&lt; std::endl; //Dynamic size matrix of floats Eigen::MatrixXf D; D.resize(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); //Let matrix D be an identity matrix: D.setIdentity(); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Matrix D:"</span></span> &lt;&lt; std::endl &lt;&lt; D &lt;&lt; std::endl; //Multiplication of matrix <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> matrix Eigen::MatrixXf E = A * D; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"E = A * D:"</span></span> &lt;&lt; std::endl &lt;&lt; E &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Conclusion: <br><br><pre> <code class="hljs markdown">Matrix A: 1 0 1 2 5 0 1 1 2 A[1, 1]: 5 Vector B: 1 0 1 B[1]: 0 C = A <span class="hljs-bullet"><span class="hljs-bullet">* B: 2 2 3 Matrix D: 1 0 0 0 1 0 0 0 1 E = A *</span></span> D: 1 0 1 2 5 0 1 1 2</code> </pre><br><br>  For more information, it is better to consult the <a href="http://eigen.tuxfamily.org/dox/GettingStarted.html">documentation</a> . <br><br><h3>  Sparse matrix </h3><br>  Sparse matrix is ‚Äã‚Äãa bit more complex type of matrix.  The basic idea is not to keep the entire matrix in memory as it is, but to store only non-zero elements.  Quite often in practical problems there are large matrices with a small number of nonzero elements.  When assembling the global stiffness matrix in the FEM model, the number of nonzero elements can be less than 0.1% of the total number of elements. <br><br>  For modern FEM packages, it‚Äôs not a problem to solve a problem with hundreds of thousands of nodes, and on a completely ordinary modern PC.  If we try to allocate space for storing the global stiffness matrix, we will encounter the following problem: <br><br><img src="https://habrastorage.org/files/1f4/c71/c67/1f4c71c6722841de8395d5dd7c120679.png"><br><br>  The size of the memory required to store the matrix is ‚Äã‚Äãhuge!  A thin matrix would require 10,000 times less memory. <br><br>  Sparse matrices use memory more efficiently because they store only nonzero elements.  Sparse matrices can be represented in two ways: compressed and uncompressed.  In uncompressed form, it is easy to add or remove an element from the matrix, but this type of representation is not optimal in terms of memory usage.  Eigen, when working with a sparse matrix, uses a kind of compressed representation, somewhat more optimized for the dynamic addition / removal of elements.  Eigen is also able to convert such a matrix into a compressed form, moreover, it does this transparently, it is not necessary to do this explicitly.  Most algorithms require a compressed matrix view, and the use of any of these algorithms automatically converts the matrix into a compressed form.  Conversely, adding / removing an item automatically converts the matrix into an optimized view. <br><br>  How can we define a matrix?  A good way to do this is to use the so-called <i>Triplets</i> .  This is a data structure, and this is a template class, which is a single element of the matrix in combination with indices determining its position in the matrix.  We can specify a sparse matrix directly from the <i>triplets</i> vector. <br><br>  For example, we have the following sparse matrix: <br><br><pre> <code class="hljs">0 3 0 0 0 22 0 0 0 0 0 5 0 1 0 0 0 0 0 0 0 0 14 0 8</code> </pre><br><br>  The first thing we need to do is include the appropriate Eigen library header: <em>&lt;Eigen / Sparse&gt;</em> .  Then, we declare an empty sparse matrix of dimension 5x5.  Next, we define the <i>triplets</i> vector and fill it with values.  The <i>triplet</i> 's constructor takes the following arguments: i-index, j-index, value. <br><br><pre> <code class="hljs rust">#include &lt;Eigen/Sparse&gt; #include &lt;iostream&gt; int main() { Eigen::SparseMatrix&lt;int&gt; A(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); std::vector&lt; Eigen::Triplet&lt;int&gt; &gt; triplets; triplets.push_back(Eigen::Triplet&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); triplets.push_back(Eigen::Triplet&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>)); triplets.push_back(Eigen::Triplet&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); triplets.push_back(Eigen::Triplet&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)); triplets.push_back(Eigen::Triplet&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>)); triplets.push_back(Eigen::Triplet&lt;int&gt;(<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)); A.setFromTriplets(triplets.begin(), triplets.end()); A.insert(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); std::cout &lt;&lt; A; A.makeCompressed(); std::cout &lt;&lt; std::endl &lt;&lt; A; }</code> </pre><br><br>  The output will be as follows: <br><br><pre> <code class="hljs pgsql">Nonzero entries: (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">22</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) (_,_) (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) (_,_) (_,_) (<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) (_,_) (_,_) (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) (_,_) (_,_) (<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) (_,_) (_,_) <span class="hljs-keyword"><span class="hljs-keyword">Outer</span></span> pointers: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> $ <span class="hljs-keyword"><span class="hljs-keyword">Inner</span></span> non zeros: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> $ <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> Nonzero entries: (<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">22</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) (<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Outer</span></span> pointers: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> $ <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span></code> </pre><br><br><h1>  <font color="#ff5e23">Data structures</font> </h1><br><br>  To store the data we are going to read from the input file, as well as intermediate data, we must declare our structures.  The simplest data structure describing the final element is shown below.  It consists of an array of three elements that store the indexes of the nodes forming the final element, as well as the matrix B. This matrix is ‚Äã‚Äãcalled the gradient matrix and we will return to it later.  The CalculateStiffnessMatrix method will also be described below. <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Element</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateStiffnessMatrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Eigen::Matrix3f&amp; D, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Eigen::Triplet&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &gt;&amp; triplets)</span></span></span></span>; Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>&gt; B; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nodesIds[<span class="hljs-number"><span class="hljs-number">3</span></span>]; };</code> </pre><br>  Another simple structure that we need is a structure for describing attachments.  This is a simple structure consisting of an enumerated type, which determines the type of restriction, and the index of the node on which the restriction is imposed. <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Constraint</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span></span> { UX = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, UY = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, UXY = UX | UY }; int node; Type <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br><br>  To keep things simple, let's define some global variables.  Creating any global objects is always a bad idea, but for this example it‚Äôs perfectly acceptable.  We will need the following global variables: <br><br><ul><li>  Number of nodes </li><li>  Vector with x-coordinate of nodes </li><li>  Vector with y-coordinate of nodes </li><li>  Elements Vector </li><li>  Pinning vector </li><li>  Load vector </li></ul><br>  In the code, we define them as follows: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nodesCount; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> noadsCount; Eigen::VectorXf nodesX; Eigen::VectorXf nodesY; Eigen::VectorXf loads; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; Element &gt; elements; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; Constraint &gt; constraints;</code> </pre><br><br><h1>  <font color="#ff5e23">Read input file</font> </h1><br>  Before reading something like something, we need to know where to read and where to write the output.  At the beginning of the <em>main</em> function, check the number of input arguments, note that the first argument is always the path to the executable file.  Thus, we should have three arguments, even if the second is the path to the input file, and the third is the path to the file with the output.  To work with I / O, for a particular case the most convenient way is to use file streams from the standard library. <br><br>  The first thing we do is create streams for I / O: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( argc != <span class="hljs-number"><span class="hljs-number">3</span></span> ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"usage: "</span></span> &lt;&lt; argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt; <span class="hljs-string"><span class="hljs-string">" &lt;input file&gt; &lt;output file&gt;\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">infile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ofstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">outfile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span></span>;</code> </pre><br><br>  In the first line of the input file are the properties of the material, read them: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> poissonRatio, youngModulus; <span class="hljs-attribute"><span class="hljs-attribute">infile</span></span> &gt;&gt; poissonRatio &gt;&gt; youngModulus;</code> </pre><br><br>  This is enough to build an elastic matrix of an isotropic material for a plane-stressed state, which is defined as follows: <br><br><img src="https://habrastorage.org/files/f17/959/063/f17959063f334ecaa70668c0686012c9.png"><br><br><img src="https://habrastorage.org/files/4a5/754/34f/4a575434f89a4aa4ac49d23b065c9d0b.png"><br><br>  Where did these expressions come from?  They are easily obtained from Hooke‚Äôs law in a general form; indeed, we can find an expression for the matrix D from the following relations: <br><br><img src="https://habrastorage.org/files/52e/2af/208/52e2af2087a54933bb5bb24b26feb4f4.png"><br><br>  It should be noted that the plane-stressed state means that œÉ <sub>Z</sub> is zero, but not Œµ <sub>Z.</sub>  A plane-stressed model is well suited for solving a number of engineering problems, where flat structures are considered and all forces act in the plane.  At a time when calculations of volumetric problems were too expensive, many tasks could be reduced to flat ones, while sacrificing accuracy. <br><br>  In a plane-stressed state, nothing prevents the body from deforming in the direction normal to its plane; therefore, the deformation Œµ <sub>Z</sub> is generally not equal to zero.  It does not appear in the equations above, but can be easily obtained from the following relationship, given that the stress œÉ <sub>Z</sub> is zero: <br><img src="https://habrastorage.org/files/165/634/ba0/165634ba0c554552af84882ced81a8ab.png"><br><br>  We have all the initial data to set the elastic matrix, let's do it: <br><pre> <code class="hljs go">Eigen::Matrix3f D; D &lt;&lt; <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, poissonRatio, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, poissonRatio, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - poissonRatio) / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>; D *= youngModulus / (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - pow(poissonRatio, <span class="hljs-number"><span class="hljs-number">2.0f</span></span>));</code> </pre><br>  Next, we read the list with the coordinates of the nodes.  First we read the number of nodes, then we set the size of the dynamic vectors x and y.  Next, we just read the coordinates of the nodes in the loop, line by line. <br><pre> <code class="hljs matlab">infile &gt;&gt; nodesCount; nodesX.resize(nodesCount); nodesY.resize(nodesCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; nodesCount; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { infile &gt;&gt; nodesX[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] &gt;&gt; nodesY[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; }</code> </pre><br>  Then, we read the list of items.  All the same, read the number of elements, and then the indexes of the nodes for each element: <br><pre> <code class="hljs matlab">int elementCount; infile &gt;&gt; elementCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; elementCount; ++<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>) { Element element; infile &gt;&gt; element.nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; element.nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; element.nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]; elements.push_back(element); }</code> </pre><br>  Next, read the list of posts.  All the same: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> constraintCount; infile &gt;&gt; constraintCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constraintCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">Constraint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; infile &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span>.node &gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = static_cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">Constraint</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>&gt;(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>); constraints.push_back(<span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span>); }</code> </pre><br><br>  You may have noticed <em>static_cast</em> , it is needed to convert an <em>int</em> type, to the previously declared enumerated type for assignments. <br><br>  Finally, you need to read the list of loads.  There is one feature associated with the load, because of which we will represent the actual load in the form of a vector of dimension of double the number of nodes.  The reason why we do this will be explained later.  The figure below illustrates this load vector: <br><br><img src="https://habrastorage.org/files/9e5/89e/302/9e589e3020ac4c14b986f06b91b388e9.png"><br><br>  Thus, for each node, we have two elements in the load vector that represent the x and y components of the force.  Thus, the x-component of the effort in a certain node will be stored in the element with the id = 2 * node_id + 0 index, and the y-component of the force for this node will be stored in the element with the id = 2 * node_id + 1 index. <br><br>  First, we set the size of the vector of applied efforts twice as large as the number of nodes, then zero the vector.  We read the number of external forces and read their values ‚Äã‚Äãline by line: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadsCount; loads.resize(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesCount); loads.setZero(); infile &gt;&gt; loadsCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; loadsCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> node; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; infile &gt;&gt; node &gt;&gt; x &gt;&gt; y; loads[<span class="hljs-number"><span class="hljs-number">2</span></span> * node + <span class="hljs-number"><span class="hljs-number">0</span></span>] = x; loads[<span class="hljs-number"><span class="hljs-number">2</span></span> * node + <span class="hljs-number"><span class="hljs-number">1</span></span>] = y; }</code> </pre><br><br><h1>  <font color="#ff5e23">Calculation of the global stiffness matrix</font> </h1><br>  We consider a geometrically linear system with infinitesimal displacements.  Moreover, we assume that the deformation occurs elastically, i.e.  deformations are a linear function of stress (Hooke's law).      ,         .  ,   ,        : <br><br><img src="https://habrastorage.org/files/00e/8d1/87f/00e8d187f47940e28720a6a002bd524d.png"><br><br> :  ‚Äî  ; Œ¥ ‚Äî  ; R ‚Äî  ,     .       ,         ,     . <br><br>  ,        : <br><br><img src="https://habrastorage.org/files/a52/fc1/a5f/a52fc1a5fa7b459e82bd36682b645a3b.png"><br><br><img src="https://habrastorage.org/files/0f5/37e/e09/0f537ee0952b4dd39822ad6a63c14ae0.png"><br><br> : u <sub>i</sub>  v <sub>i</sub> ‚Äî u-  v-  i- . <br><br>   : <br><br><img src="https://habrastorage.org/files/29c/9d1/85b/29c9d185ba124a85bb800f357d9b5545.png"><br><br><img src="https://habrastorage.org/files/584/71c/1a6/58471c1a66214febbd0b40db9b05be65.png"><br><br> : R <sub>xi</sub>  R <sub>yi</sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the x-component and the y-component of the external force applied to the i-th node. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we see, each element of the displacement vector and load vector is a two-dimensional vector. Instead, we can define these vectors as follows: </font></font><br><br><img src="https://habrastorage.org/files/a98/a6e/513/a98a6e5136c84b7da2875d948c7188f7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is actually the same, but it simplifies the representation of these vectors in the code. This is an explanation of why we previously set the load vector in such a peculiar way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to build a stiffness matrix? The essence of the global stiffness matrix is ‚Äã‚Äãa superposition of the stiffness matrices of each element. If we consider one element separately from the others, then we can determine the same stiffness matrix, but only for this element. This matrix defines the relationship between node movements and nodal forces. For example, for a 3-node element: </font></font><br><br><img src="https://habrastorage.org/files/276/200/7ea/2762007ea6db47a68fe00765314cc9ce.png"><br><br><img src="https://habrastorage.org/files/b12/588/83b/b1258883bb29478a8cff7fd691dbac45.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where: [k]</font></font><sup></sup> ‚Äî   e- ; [Œ¥] <sup></sup> ‚Äî    - ; [F] <sup></sup> ‚Äî    - ; i, j, m ‚Äî   . <br><br>  ,        ?  ,    - ,               .     ,            ,      ,   ‚Äî . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The sum of all the nodal forces at each node is equal to the sum of the external forces at that node, this follows from the equilibrium principle. Despite the fact that this statement may seem quite logical and fair, in fact, everything is a bit more complicated. Such a formulation is not accurate, because the nodal forces are not forces in the general sense of the word, and the fulfillment of the equilibrium conditions is not an obvious condition for them. Despite the fact that the statement is still true, it uses a mechanical principle, which limits the application of the method. There is a more rigorous, mathematical justification of the FEM from the standpoint of minimizing potential energy, which makes it possible to extend the method to a wider range of problems.</font></font><br><br>   ,          ,    .   ,   ,      ,         .         ,   ,     ,     (     ),      ,    . <br><br>       , -   .         ‚Äî .  ,   ,   : <br><br><img src="https://habrastorage.org/files/8e7/ab8/7f0/8e7ab87f041841258af623fe24e5ad41.png"><br><br>     : <br><br><img src="https://habrastorage.org/files/06b/e95/a05/06be95a05f3040fdb9542a3b729b58fc.png"><br><br>     ,    <i>triplets</i> .  ,                : <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt; triplets; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Element&gt;::iterator it = elements.begin(); it != elements.end(); ++it) { it-&gt;CalculateStiffnessMatrix(D, triplets); }</code> </pre><br><br>  <em>std::vector&lt;Eigen::Triplet&lt;float&gt; &gt;</em> ‚Äî  <i>triplets</i> ; <em>CalculateStiffnessMatrix</em> ‚Äî   ,    <i>triplets</i> . <br><br>    ,          <i>triplets</i> : <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::SparseMatrix</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">float</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">globalK</span></span>(2 * <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesCount</span></span>, 2 * <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesCount</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">globalK</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setFromTriplets</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">triplets</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.begin</span></span>(), <span class="hljs-selector-tag"><span class="hljs-selector-tag">triplets</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.end</span></span>());</code> </pre><br><br><h1> <font color="#ff5e23">    </font> </h1><br>  ,      ()   ,       . <br><br><h2>   </h2><br>            .    ,         : <br><br><img src="https://habrastorage.org/files/20c/9d7/264/20c9d726438e4a5c817ad359bb0258d6.png"><br><br>  [N]      <em>(, )</em> .     .   , <em>u</em>  <em>v</em>   ,   ,     : <br><br><img src="https://habrastorage.org/files/c3f/381/250/c3f3812504aa42398ff9c71be2441f8b.png"><br><br>      : <br><br><img src="https://habrastorage.org/files/2fe/b95/145/2feb9514507e4f68ab90d392c58495a2.png"><br><img src="https://habrastorage.org/files/7eb/c1e/039/7ebc1e039d2541d399a9017a646ce8e5.png"><br><br>    ?  ,    .   -,  ,    .        : <br><br><img src="https://habrastorage.org/files/9e6/640/d3c/9e6640d3cb194a64a56fd133248b3ab1.png"><br><br>   <em>f</em>   ,        : <br><br><img src="https://habrastorage.org/files/68a/f98/3e0/68af983e07f241f3a65de7dab3dce92d.png"><br><br>    : <br><br><img src="https://habrastorage.org/files/13c/d0d/d9d/13cd0dd9daea4295a38d94dea5dced51.png"><br><br>    ,         : <br><br><img src="https://habrastorage.org/files/01d/a7e/1d5/01da7e1d517c4b318678e4fcd8aa8c47.png"><br><br>   <br><br><img src="https://habrastorage.org/files/674/543/b17/674543b1761e484c9e8f49a7380185d3.png"><br><br> ,   : <br><br><img src="https://habrastorage.org/files/58b/173/8fc/58b1738fc2964f599e7b186fa31fff31.png"><br><br>   ,   , : <br><br><img src="https://habrastorage.org/files/1d6/128/b5e/1d6128b5e1a1464fb0c2821472b3255e.png"><br><br><img src="https://habrastorage.org/files/19c/080/cc2/19c080cc2af44ad4a34221b01e4035dc.png"><br><br> ,     : <br><br><img src="https://habrastorage.org/files/77f/83f/c7d/77f83fc7d6f741d091e1303d38461a1d.png"><br><br><h2>     </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knowing the displacement field, we can find the strain field on the relations of the theory of elasticity: </font></font><br><br><img src="https://habrastorage.org/files/06f/8fd/4ec/06f8fd4ec71b4bf8b3cb1af0073eae0b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can replace </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in the form of functions: </font></font><br><img src="https://habrastorage.org/files/14c/4b5/8d0/14c4b58d04a74afcb6f411d769ac2674.png"><br><br><img src="https://habrastorage.org/files/d0e/3a6/bad/d0e3a6bad6c4472495655c70ed6a5d8f.png"><br><br><img src="https://habrastorage.org/files/943/393/d28/943393d28c8b4c45829c42027bd2cc30.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Or we can write the same in combined form: </font></font><br><br><img src="https://habrastorage.org/files/8c3/0c5/cc7/8c30c5cc7f7d4f38a30b0da9dedc1261.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The matrix on the right side, commonly referred to as a matrix </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the so-called gradient matrix. </font></font><br><br><img src="https://habrastorage.org/files/530/a88/079/530a88079ca54c3a92a89390000689e7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To find the matrix </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we must find all partial derivatives of the functions of the form: </font></font><br><br><img src="https://habrastorage.org/files/c8b/fcc/2eb/c8bfcc2ebca142a8bc4fa2aa3298c55b.png"><br><br><img src="https://habrastorage.org/files/657/df3/8f0/657df38f0f354fe38c7122c90070d09c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of a linear element, we see that the partial derivatives of the functions of the form are in fact constants, which will save us a lot of effort, as will be shown later. Multiplying the row vector with constants by the inverse matrix C we get:</font></font><br><br><img src="https://habrastorage.org/files/7ec/db3/28f/7ecdb328f10642dba6e937f2cc428f6a.png"><br><br><img src="https://habrastorage.org/files/a9a/bd2/15f/a9abd215f06f4f0395ce25b9d88642d6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we can calculate the B matrix. </font><font style="vertical-align: inherit;">To build the matrix C, we first define the coordinate vectors of the nodes:</font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector3f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span> &lt;&lt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesX</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodesIds[0]</span></span>], <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesX</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodesIds[1]</span></span>], <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesX</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodesIds[2]</span></span>]; <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span> &lt;&lt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesY</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodesIds[0]</span></span>], <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesY</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodesIds[1]</span></span>], <span class="hljs-selector-tag"><span class="hljs-selector-tag">nodesY</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[nodesIds[2]</span></span>];</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then, we can build a matrix C of three rows: </font></font><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Matrix3f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span> &lt;&lt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">Eigen</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Vector3f(1.0f</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0f</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">x</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">y</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Then we compute the inverse matrix C and collect the matrix B: </font></font><br><br><pre> <code class="hljs matlab">Eigen::Matrix3f IC = C.inverse(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { B(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); B(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; B(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; B(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); B(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); B(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); }</code> </pre><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transition to stress </font></font></h2><br>     ,            D: <br><br><img src="https://habrastorage.org/files/d4d/5a8/c4e/d4d5a8c4e1e94d79b34cfc0c66ae0565.png"><br><br>  ,       , : <br><br><img src="https://habrastorage.org/files/f1d/e23/8e8/f1de238e8bf642e2a41821b4a46bf902.png"><br><br>   ,  ,       .    . ,     ,     .    ,        .  ,        ,         . <br><br><h2>    </h2><br>  ,     ,      . ,         : d[Œ¥] <sup>e</sup> <br><br>         ,   .  ,      ,            ,         .  ,         ,     ,    . <br><br>    ,     : <br><br><img src="https://habrastorage.org/files/257/c3d/467/257c3d4672b74d10b83926a09b018170.png"><br><br>         -  : <br><br><img src="https://habrastorage.org/files/c9d/4eb/398/c9d4eb398e9e47a19be39a8ec89bf8ec.png"><br><br>  Or: <br><br><img src="https://habrastorage.org/files/71e/fd6/fce/71efd6fce59644e6ad062ea53d93e7fe.png"><br><br>    ,  : <br><br><img src="https://habrastorage.org/files/f72/77c/cff/f7277ccffcc74321b6b5d4425703d0eb.png"><br><br>    ,              : <br><br><img src="https://habrastorage.org/files/c32/4d4/2f2/c324d42f2fb149dd93f575ea11ef0ba8.png"><br><br> ,          ,         : <br><br><img src="https://habrastorage.org/files/268/3b7/04d/2683b704d3c441cd985935f6b76b1467.png"><br><br>      ,      .   ,           ,  ,      : <br><br><img src="https://habrastorage.org/files/544/976/dbb/544976dbb1464d819fdd215286c2a285.png"><br><br>   ,    ,    .     ,    : <br><br><img src="https://habrastorage.org/files/1f7/e80/238/1f7e802385714d9b92a7577cd43c77fe.png"><br><br>  A ‚Äî  , t ‚Äî  .   ,          : <br><br><img src="https://habrastorage.org/files/719/29e/11b/71929e11bd504bcbb7b3290f57a6b32c.png"><br><br>   ,         : <br><br><pre> <code class="hljs cpp">Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>&gt; K = B.transpose() * D * B * C.determinant() / <span class="hljs-number"><span class="hljs-number">2.0f</span></span>;</code> </pre> <br><br>    ,       . ,      : ,  <sup>2</sup> .   ,       ,    ,     .    ,        .    ,          . <br><br>  <em>CalculateStiffnessMatrix</em> : <br><br><pre> <code class="hljs matlab">void Element::CalculateStiffnessMatrix(const Eigen::Matrix3f&amp; D, std::vector&lt;Eigen::Triplet&lt;float&gt; &gt;&amp; triplets) { Eigen::Vector3f x, y; x &lt;&lt; nodesX[nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]], nodesX[nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>]], nodesX[nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; y &lt;&lt; nodesY[nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]], nodesY[nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>]], nodesY[nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; Eigen::Matrix3f C; C &lt;&lt; Eigen::Vector3f(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f), x, y; Eigen::Matrix3f IC = C.inverse(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { B(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); B(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; B(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; B(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); B(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); B(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>); } Eigen::Matrix&lt;float, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>&gt; K = B.transpose() * D * B * C.determinant() / <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) { Eigen::Triplet&lt;float&gt; trplt11(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] + <span class="hljs-number"><span class="hljs-number">0</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>)); Eigen::Triplet&lt;float&gt; trplt12(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)); Eigen::Triplet&lt;float&gt; trplt21(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] + <span class="hljs-number"><span class="hljs-number">0</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>)); Eigen::Triplet&lt;float&gt; trplt22(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)); triplets.push_back(trplt11); triplets.push_back(trplt12); triplets.push_back(trplt21); triplets.push_back(trplt22); } } }</code> </pre> <br><br>   ,    ,   <i>Triplets</i> .  <i>Triplet</i>      ,        .   , ,       ,   ‚Äî   ,   ‚Äî  . <br><br><h1> <font color="#ff5e23"> </font> </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The resulting system of linear equations cannot be solved until we specify the fixings. Purely from a mechanical point of view, an unsecured system can make any large displacements, and under the action of external forces, it can even go into motion. Mathematically, this will lead to the fact that the resulting SLAE is not linearly independent, and therefore does not have a unique solution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moves of some nodes must be set to zero or to some predetermined value. In the simplest case, let's consider only the fixing of the nodes, without initial displacements. In fact, this means that we remove some equations from the system. But changing the number of equations of the system on the fly is not a trivial task. Instead, you can use the following trick.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's say we have the following system of equations: </font></font><br><br><img src="https://habrastorage.org/files/7e1/0cd/909/7e10cd9090e147b1821a22c13d91f21d.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To fix a node, the corresponding matrix element must be set to 1, and all elements in the row and column containing this element must be set to zero. There should also be no external forces acting on the fixed node in the direction in which the restriction is valid. An equation with this node will explicitly give a zero offset for this node, and the zeros in the corresponding column will exclude this offset from other equations. Let's say we want to fix the zero node in the direction of the x axis, and fix the first node in the direction of the y axis:</font></font><br><br><img src="https://habrastorage.org/files/863/6d2/d4d/8636d2d4d2b644beb80632b43a9ce60e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To perform this operation, we first define the indices of the equations that we are going to exclude from the SLAE. </font><font style="vertical-align: inherit;">To do this, we loop through the list of assignments and collect the vector of indices. </font><font style="vertical-align: inherit;">Then, going through all the nonzero elements of the stiffness matrix, we call the function </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetConstraints</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The following is the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ApplyConstraints</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyConstraints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Eigen::SparseMatrix&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&amp; K, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Constraint&gt;&amp; constraints)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indicesToConstraint; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Constraint&gt;::const_iterator it = constraints.begin(); it != constraints.end(); ++it) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;type &amp; Constraint::UX) { indicesToConstraint.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;node + <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;type &amp; Constraint::UY) { indicesToConstraint.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;node + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; K.outerSize(); ++k) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::InnerIterator it(K, k); it; ++it) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::iterator idit = indicesToConstraint.begin(); idit != indicesToConstraint.end(); ++idit) { SetConstraints(it, *idit); } } } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetConstraints</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">checks whether an element of the stiffness matrix is ‚Äã‚Äãpart of the excluded equation, and if so, it sets it equal to zero or one, depending on whether the element is on the diagonal or not:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> SetConstraints(Eigen::SparseMatrix&lt;<span class="hljs-type"><span class="hljs-type">float</span></span>&gt;::InnerIterator&amp; it, <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>() == <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> || it.col() == <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>) { it.valueRef() = it.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>() == it.col() ? <span class="hljs-number"><span class="hljs-number">1.0</span></span>f : <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; } }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Further, we simply call </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ApplyConstraints</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and pass as its arguments a global stiffness matrix and a vector of constraints:</font></font><br><br><pre> <code class="hljs lisp">ApplyConstraints(<span class="hljs-name"><span class="hljs-name">globalK</span></span>, constraints)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br><h1> <font color="#ff5e23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SLAE solution and output</font></font></font> </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eigen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">has various sparse linear equations solvers available, we will use </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SimplicialLDLT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is a fast </font></font><abbr title="Direct solver -      , ..  ,           "><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direct</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solver. </font><font style="vertical-align: inherit;">For demonstration purposes, we will derive the initial stiffness matrix and load vector, and then output the result of the solution, the displacement vector.</font></font><br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Global stiffness matrix:\n"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Eigen::SparseMatrixBase&lt;Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt;&amp; &gt; (globalK) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Loads vector:"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; loads &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; Eigen::SimplicialLDLT&lt;Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt; solver(globalK); Eigen::VectorXf displacements = solver.solve(loads); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Displacements vector:"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span> &lt;&lt; displacements &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; outfile &lt;&lt; displacements &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Of course, the matrix output makes sense only for our test example, which contains only two elements. </font></font><br><br><h1> <font color="#ff5e23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analysis of the result</font></font></font> </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As we have seen before, we can move from displacements to deformations and further to stresses: </font></font><br><br><img src="https://habrastorage.org/files/f1d/e23/8e8/f1de238e8bf642e2a41821b4a46bf902.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, we obtain a stress vector, which in theory of elasticity is generally a second-rank symmetric tensor: </font></font><br><br><img src="https://habrastorage.org/files/823/a0f/b51/823a0fb518cd42e48004f5718272d0e5.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you know, the tensor elements directly depend on the coordinate system, however the physical state itself is of course independent. Therefore, for analysis, it is better to proceed as an invariant value, best of all, to a scalar one. Such an invariant is the </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B8%25D0%25B7%25D0%25B5%25D1%2581,_%25D0%25A0%25D0%25B8%25D1%2585%25D0%25B0%25D1%2580%25D0%25B4_%25D0%25AD%25D0%25B4%25D0%25BB%25D0%25B5%25D1%2580_%25D1%2584%25D0%25BE%25D0%25BD"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von Mises</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> stresses </font><font style="vertical-align: inherit;">:</font></font><br><br><img src="https://habrastorage.org/files/071/6f8/0c5/0716f80c56c44400bd9d1bba943218a4.gif"><br><br>   ,     - ,           .    ,    ,        ,       . <br><br>        ,        : <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Stresses:"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Element&gt;::iterator it = elements.begin(); it != elements.end(); ++it) { Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; delta; delta &lt;&lt; displacements.segment&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]), displacements.segment&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>]), displacements.segment&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]); Eigen::Vector3f sigma = D * it-&gt;B * delta; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sigma_mises = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(sigma[<span class="hljs-number"><span class="hljs-number">0</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">0</span></span>] - sigma[<span class="hljs-number"><span class="hljs-number">0</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">1</span></span>] + sigma[<span class="hljs-number"><span class="hljs-number">1</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">3.0f</span></span> * sigma[<span class="hljs-number"><span class="hljs-number">2</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; sigma_mises &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; outfile &lt;&lt; sigma_mises &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br><br>          . ,        : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Global</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">stiffness</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">matrix</span></span>: 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1483<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span> 0 0 714<span class="hljs-selector-class"><span class="hljs-selector-class">.286</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> 0 0 0 1 0 0 0 0 0 0 0 0 1483<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1098</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.9</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-329</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.67</span></span> 0 0 714<span class="hljs-selector-class"><span class="hljs-selector-class">.286</span></span> 0 0 1483<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> 0 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-1098</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.9</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> 1483<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span> 714<span class="hljs-selector-class"><span class="hljs-selector-class">.286</span></span> 0 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-329</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.67</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-384</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.615</span></span> 714<span class="hljs-selector-class"><span class="hljs-selector-class">.286</span></span> 1483<span class="hljs-selector-class"><span class="hljs-selector-class">.52</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Loads</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vector</span></span>: 0 0 0 0 0 1 0 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">Deformations</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">vector</span></span>: 0 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0003</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-5</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.27106e-011</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.001</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0003</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.001</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Stresses</span></span>: 2 2</code> </pre><br><br>  ,     ,        .     ,     .   x-,       0.0003,   0.3       y-,   <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%258D%25D1%2584%25D1%2584%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582_%25D0%259F%25D1%2583%25D0%25B0%25D1%2581%25D1%2581%25D0%25BE%25D0%25BD%25D0%25B0"> </a> .      ,      . <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre> <code class="hljs mel">#include &lt;Eigen/Dense&gt; #include &lt;Eigen/Sparse&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; #include &lt;<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; struct Element { void CalculateStiffnessMatrix(const Eigen::Matrix3f&amp; D, std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt;&amp; triplets); Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>&gt; B; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nodesIds[<span class="hljs-number"><span class="hljs-number">3</span></span>]; }; struct Constraint { enum Type { UX = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, UY = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, UXY = UX | UY }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> node; Type type; }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nodesCount; Eigen::VectorXf nodesX; Eigen::VectorXf nodesY; Eigen::VectorXf loads; std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt; Element &gt; elements; std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt; Constraint &gt; constraints; void Element::CalculateStiffnessMatrix(const Eigen::Matrix3f&amp; D, std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt;&amp; triplets) { Eigen::Vector3f x, y; x &lt;&lt; nodesX[nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]], nodesX[nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>]], nodesX[nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; y &lt;&lt; nodesY[nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]], nodesY[nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>]], nodesY[nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]]; Eigen::Matrix3f C; C &lt;&lt; Eigen::Vector3f(<span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, <span class="hljs-number"><span class="hljs-number">1.0</span></span>f), x, y; Eigen::Matrix3f IC = C.inverse(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { B(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">0</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">1</span></span>, i); B(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">1</span></span>) = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; B(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">0</span></span>) = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; B(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">1</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">2</span></span>, i); B(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">0</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">2</span></span>, i); B(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">1</span></span>) = IC(<span class="hljs-number"><span class="hljs-number">1</span></span>, i); } Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>&gt; K = B.transpose() * D * B * C.determinant() / <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; j++) { Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; trplt11(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[i] + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[j] + <span class="hljs-number"><span class="hljs-number">0</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * j + <span class="hljs-number"><span class="hljs-number">0</span></span>)); Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; trplt12(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[i] + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[j] + <span class="hljs-number"><span class="hljs-number">1</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * j + <span class="hljs-number"><span class="hljs-number">1</span></span>)); Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; trplt21(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[j] + <span class="hljs-number"><span class="hljs-number">0</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * j + <span class="hljs-number"><span class="hljs-number">0</span></span>)); Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; trplt22(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[i] + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesIds[j] + <span class="hljs-number"><span class="hljs-number">1</span></span>, K(<span class="hljs-number"><span class="hljs-number">2</span></span> * i + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * j + <span class="hljs-number"><span class="hljs-number">1</span></span>)); triplets.push_back(trplt11); triplets.push_back(trplt12); triplets.push_back(trplt21); triplets.push_back(trplt22); } } } void SetConstraints(Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::InnerIterator&amp; it, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it.row() == index || it.col() == index) { it.valueRef() = it.row() == it.col() ? <span class="hljs-number"><span class="hljs-number">1.0</span></span>f : <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; } } void ApplyConstraints(Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;&amp; K, const std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Constraint&gt;&amp; constraints) { std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; indicesToConstraint; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Constraint&gt;::const_iterator it = constraints.begin(); it != constraints.end(); ++it) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;type &amp; Constraint::UX) { indicesToConstraint.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;node + <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it-&gt;type &amp; Constraint::UY) { indicesToConstraint.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;node + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; K.outerSize(); ++k) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::InnerIterator it(K, k); it; ++it) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::iterator idit = indicesToConstraint.begin(); idit != indicesToConstraint.end(); ++idit) { SetConstraints(it, *idit); } } } } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argc, char *argv[]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( argc != <span class="hljs-number"><span class="hljs-number">3</span></span> ) { std::cout&lt;&lt;<span class="hljs-string"><span class="hljs-string">"usage: "</span></span>&lt;&lt; argv[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;&lt;<span class="hljs-string"><span class="hljs-string">" &lt;input file&gt; &lt;output file&gt;\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } std::ifstream infile(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]); std::ofstream outfile(argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> poissonRatio, youngModulus; infile &gt;&gt; poissonRatio &gt;&gt; youngModulus; Eigen::Matrix3f D; D &lt;&lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, poissonRatio, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, poissonRatio, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, (<span class="hljs-number"><span class="hljs-number">1.0</span></span>f - poissonRatio) / <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; D *= youngModulus / (<span class="hljs-number"><span class="hljs-number">1.0</span></span>f - <span class="hljs-keyword"><span class="hljs-keyword">pow</span></span>(poissonRatio, <span class="hljs-number"><span class="hljs-number">2.0</span></span>f)); infile &gt;&gt; nodesCount; nodesX.resize(nodesCount); nodesY.resize(nodesCount); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; nodesCount; ++i) { infile &gt;&gt; nodesX[i] &gt;&gt; nodesY[i]; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementCount; infile &gt;&gt; elementCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; elementCount; ++i) { Element element; infile &gt;&gt; element.nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>] &gt;&gt; element.nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt;&gt; element.nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]; elements.push_back(element); } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> constraintCount; infile &gt;&gt; constraintCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constraintCount; ++i) { Constraint constraint; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type; infile &gt;&gt; constraint.node &gt;&gt; type; constraint.type = static_cast&lt;Constraint::Type&gt;(type); constraints.push_back(constraint); } loads.resize(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesCount); loads.setZero(); infile &gt;&gt; loadsCount; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> loadsCount; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; loadsCount; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> node; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y; infile &gt;&gt; node &gt;&gt; x &gt;&gt; y; loads[<span class="hljs-number"><span class="hljs-number">2</span></span> * node + <span class="hljs-number"><span class="hljs-number">0</span></span>] = x; loads[<span class="hljs-number"><span class="hljs-number">2</span></span> * node + <span class="hljs-number"><span class="hljs-number">1</span></span>] = y; } std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Eigen::Triplet&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt; triplets; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Element&gt;::iterator it = elements.begin(); it != elements.end(); ++it) { it-&gt;CalculateStiffnessMatrix(D, triplets); } Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; globalK(<span class="hljs-number"><span class="hljs-number">2</span></span> * nodesCount, <span class="hljs-number"><span class="hljs-number">2</span></span> * nodesCount); globalK.setFromTriplets(triplets.begin(), triplets.end()); ApplyConstraints(globalK, constraints); Eigen::SimplicialLDLT&lt;Eigen::SparseMatrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; &gt; solver(globalK); Eigen::VectorXf displacements = solver.solve(loads); outfile &lt;&lt; displacements &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (std::<span class="hljs-keyword"><span class="hljs-keyword">vector</span></span>&lt;Element&gt;::iterator it = elements.begin(); it != elements.end(); ++it) { Eigen::Matrix&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>&gt; delta; delta &lt;&lt; displacements.segment&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;nodesIds[<span class="hljs-number"><span class="hljs-number">0</span></span>]), displacements.segment&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;nodesIds[<span class="hljs-number"><span class="hljs-number">1</span></span>]), displacements.segment&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span> * it-&gt;nodesIds[<span class="hljs-number"><span class="hljs-number">2</span></span>]); Eigen::Vector3f sigma = D * it-&gt;B * delta; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sigma_mises = <span class="hljs-keyword"><span class="hljs-keyword">sqrt</span></span>(sigma[<span class="hljs-number"><span class="hljs-number">0</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">0</span></span>] - sigma[<span class="hljs-number"><span class="hljs-number">0</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">1</span></span>] + sigma[<span class="hljs-number"><span class="hljs-number">1</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">3.0</span></span>f * sigma[<span class="hljs-number"><span class="hljs-number">2</span></span>] * sigma[<span class="hljs-number"><span class="hljs-number">2</span></span>]); outfile &lt;&lt; sigma_mises &lt;&lt; std::endl; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br><br>   <a href="http://sourceforge.net/projects/cloc/">cloc</a> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- C++ 1 37 0 171 -------------------------------------------------------------------------------</span></span></code> </pre> <br><br>  ,   ‚Äî 171  . <br><br><h1>  <font color="#ff5e23">Some pictures</font> </h1><br>    ,   <a href="https://github.com/podgorskiy/MinimalFem/blob/master/scripts/PostProcess.py"></a>  python,         .  ,          <strong>PIL</strong> ,         . <strong>Abaqus</strong>       ,      ,     . <br><br>  : <br><br><img src="https://habrastorage.org/files/6d8/270/4f6/6d82704f653848cb8966976597b9ebec.png"><br><br>    ,      <strong>Abaqus</strong> .     <strong>Abaqus</strong> '     <a href="https://github.com/podgorskiy/MinimalFem/blob/master/scripts/convertor.py"></a> .          . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we see a strip with a hole, the bottom of which is fixed, and a tensile force is applied to the upper edge: </font></font><br><img src="https://habrastorage.org/files/acc/817/525/acc8175259664fbbbed65540776e10d0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstract structural element, just for beauty. The bottom of the structure is fixed, and a concentrated force is applied on the upper protruding part, which I have already drawn on top of the picture: </font></font><br><img src="https://habrastorage.org/files/7c5/660/9d1/7c56609d1579495cb89be06b6f1df55e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another example with a strip with a hole, this time only a quarter of the structure is considered due to symmetry. The left border is fixed along the x axis, the lower one along the y axis. The maximum voltage received: 3.05152. This value, despite the coarseness of the grid (and perhaps because of it), is quite close to the theoretical value - 3. </font></font><br><img src="https://habrastorage.org/files/787/e99/ad8/787e99ad84e940e4876933a935df91e7.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same problem, but solved in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abaqus</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">As you can see, the maximum voltage is 3.052, which fully coincides with our result. </font><font style="vertical-align: inherit;">Such an exact coincidence, in principle, is not surprising, since in practice, it is difficult for a triangular element to do something in some way, so that the result is different. </font><font style="vertical-align: inherit;">For elements of a higher order, unfortunately, such a 100% coincidence did not work out for me, which can be explained by different implementation of numerical integration. </font></font><br><img src="https://habrastorage.org/files/ac7/784/f35/ac7784f356794940b137bb48c38ee605.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All source code, including examples, is available on </font></font><a href="https://github.com/podgorskiy/MinimalFem"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1> <font color="#ff5e23"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What's left overs</font></font></font> </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Honestly, behind the scenes there are quite a lot. </font><font style="vertical-align: inherit;">But the article turned out to be inflated, and so I think this can be stopped. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not included (but wanted):</font></font><br><ul><li>   .   ,       .         .       ,      (  2-  4- ),     .      ,     (    ). </li><li>       . </li><li>       ,    . </li><li>  - ,         .  ,   . </li><li>     ,    ,         . </li><li>  ,      ,     ,     . </li></ul><br><br>  ,     ,     ,   MATLAB      ,          ++. ,        ,   , ..    .     ,  ,          . <br><br> PS  ,   ,   . </div><p>Source: <a href="https://habr.com/ru/post/271723/">https://habr.com/ru/post/271723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271711/index.html">Features (traits) in Perl 6 - metadata along with a symbol</a></li>
<li><a href="../271713/index.html">"Darknet Weekdays" - video materials for training on information security</a></li>
<li><a href="../271717/index.html">Social engineering first hand</a></li>
<li><a href="../271719/index.html">Spring MVC / Security, REST, Hibernate, Liquibase run in two lines</a></li>
<li><a href="../271721/index.html">Biometrics: Time Attendance + Fujitsu PalmSecure</a></li>
<li><a href="../271725/index.html">Yandex announces its own weather forecasting technology Meteum. Accurate to home</a></li>
<li><a href="../271727/index.html">Draw, draw, draw: Inkscape 0.92 coming soon</a></li>
<li><a href="../271729/index.html">PythonDigest - issue number 100 and other great news</a></li>
<li><a href="../271731/index.html">OOP in 1C do it yourself. How to simulate your classes and objects, and why it is needed</a></li>
<li><a href="../271733/index.html">Why would a developer scoff at his own code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>