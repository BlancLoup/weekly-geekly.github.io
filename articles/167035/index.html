<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Translation SDL Game Framework Series. Part 2 - SDL Coordinates and Bliting</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Taking the first lesson as a basis, we will delve into the world of SDL surfaces. As I said, SDL surfaces are mostly images stored in memory. Imagine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Translation SDL Game Framework Series. Part 2 - SDL Coordinates and Bliting</h1><div class="post__text post__text-html js-mediator-article">  Taking the <a href="http://habrahabr.ru/post/166875/">first lesson</a> as a basis, we will delve into the world of <i>SDL</i> surfaces.  As I said, <i>SDL</i> surfaces are mostly images stored in memory.  Imagine that we have an empty window of 320x240 pixels.  In the <i>SDL</i> coordinate system, the window is represented as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/72b/7f1/c7a72b7f149f89f3d154c2cc0ae7b3d7.png"><br><a name="habracut"></a><br>  This coordinate system is different from the one you are used to (I'm talking about Cartesian).  But the main difference between these systems is that the <i>Y</i> coordinate ‚Äúgrows‚Äù down.  Understanding the <i>SDL</i> coordinate system is important in order to properly draw the images on the screen, so take a good look. <br><br>  Since we already have a prepared and customized surface ( <i>Surf_Display</i> ), we just need to find a way to draw images.  This method is called blitching (from the English. <i>Blitting</i> - moving a group of bits from one place to another, in our case means transferring the image (or part of it) over the other), i.e.  a kind of overlay.  But before we can do this, we must also find a way to load these images into memory.  <i>SDL</i> offers a simple function to implement your plans - <i>SDL_LoadBMP</i> (note: <i>SDL_LoadBMP</i> only allows uploading images in <i>* .BMP</i> format, as its name suggests. To upload images of other formats, <i>SDL_image</i> must be connected to the project, as comrade rightly <a href="http://habrahabr.ru/post/166875/">noted in the comments</a> <a href="https://habrahabr.ru/users/alrusdi/" class="user_link">alrusdi</a> in the first lesson, and use the <i>IMG_Load</i> function).  Sample code might look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre><code class="cpp hljs">SDL_Surface* Surf_Temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((Surf_Temp = SDL_LoadBMP(<span class="hljs-string"><span class="hljs-string">"mypicture.bmp"</span></span>)) == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//! }</span></span></code> </pre> <br></div></div><br>  Everything is quite simple here, <i>SDL_LoadBMP</i> accepts just one argument as a parameter - the path to the file you want to load, and it returns the surface containing the specified image.  If the function returns <i>NULL</i> , then either the file was not found, or it was damaged, or other, more complex errors occurred.  Unfortunately, to the detriment of efficiency, this method does not provide full coverage of various loading errors.  Very often the loaded image does not correspond to the pixel format of the surface into which we load it.  Thus, during display, there may be a loss of performance, image colors, etc.  (It is important that the prepared surface and the loaded image match each other in all respects, that is, (exaggerating) the size of the box would fit the size of the load).  Fortunately, <i>SDL</i> has a quick and painless workaround to this problem - <i>SDL_DisplayFormat</i> .  This function adjusts the already loaded image, and returns a new surface suitable for the format displayed. <br>  Now you need to open the project created in the previous lesson and add two files: <i>CSurface.h</i> and <i>CSurface.cpp</i> .  Open <i>CSurface.h</i> and add the following: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL/SDL.h&gt; class CSurface { public: CSurface(); public: static SDL_Surface* OnLoad(char* File); }; #endif</span></span></span></span></code> </pre><br></div></div><br>  Thus, we have created a simple <i>OnLoad</i> function that will load the surface for us.  Now open <i>CSurface.cpp</i> and add: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CSurface.h"</span></span></span><span class="hljs-meta"> CSurface::CSurface() { } SDL_Surface* CSurface::OnLoad(char* File) { SDL_Surface* Surf_Temp = NULL; SDL_Surface* Surf_Return = NULL; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Temp = SDL_LoadBMP(File)) == NULL) { return NULL; } Surf_Return = SDL_DisplayFormat(Surf_Temp); SDL_FreeSurface(Surf_Temp); return Surf_Return; }</span></span></code> </pre><br></div></div><br>  So, a couple of things you should pay attention to: <br>  1. Always reset your pointers before using them in any way (NULL or ‚Äú0‚Äù does not matter).  This will help avoid tuevuyuchi most different problems and errors; <br>  2. Remember that <i>SDL_DisplayFormat</i> returns a new surface based on the old one, so do not forget to release the resources occupied by that old surface.  Otherwise, we will observe the surface "wandering" in memory as it pleases. <br>  Now we have a way to load surfaces into memory, but we also need a way to map them to other surfaces.  As well as for loading images, <i>SDL</i> has a function for this: <i>SDL_BlitSurface</i> .  It may not be as easy to use as <i>SDL_LoadBMP</i> , but don't be scared.  Open <i>CSurface.h</i> and add the following function prototype: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL/SDL.h&gt; class CSurface { public: CSurface(); public: static SDL_Surface* OnLoad(char* File); static bool OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y); }; #endif</span></span></span></span></code> </pre><br></div></div><br>  Open <i>CSurface.cpp again</i> and add the following: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CSurface.h"</span></span></span><span class="hljs-meta"> CSurface::CSurface() { } SDL_Surface* CSurface::OnLoad(char* File) { SDL_Surface* Surf_Temp = NULL; SDL_Surface* Surf_Return = NULL; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Temp = SDL_LoadBMP(File)) == NULL) { return NULL; } Surf_Return = SDL_DisplayFormat(Surf_Temp); SDL_FreeSurface(Surf_Temp); return Surf_Return; } bool CSurface::OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(Surf_Dest == NULL || Surf_Src == NULL) { return false; } SDL_Rect DestR; DestR.x = X; DestR.y = Y; SDL_BlitSurface(Surf_Src, NULL, Surf_Dest, &amp;DestR); return true; }</span></span></code> </pre><br></div></div><br>  First of all, let's take a look at the arguments that are passed to the <i>OnDraw</i> function.  We see two surfaces, and two variables of type <i>int</i> .  The first surface is taken as the base (remember the board in the first lesson?), I.e.  the one to which we will display everything in the future.  Accordingly, the second surface is the one that we will impose on the base (and here are our stickers).  Basically, we just place <i>Surf_Src</i> on top of <i>Surf_Dest</i> , that's the whole secret.  <i>X</i> and <i>Y</i> are variables that denote the coordinates of a place on the surface of <i>Surf_Dest</i> to which we will map <i>Surf_Src</i> . <br>  At the beginning of the function, we must make sure that we have surfaces, otherwise we return <b>false</b> .  Next, we create a variable of type <i>SDL_Rect</i> .  This is the <i>SDL</i> structure, which consists of four properties: <i>X</i> , <i>Y</i> , <i>W</i> , <i>H.</i>  Of course you have already guessed that it sets the parameters of the displayed region of the surface.  So far we are only interested in the coordinates of the place in which we will display the rectangle, and we don‚Äôt give a damn about its size.  So, then we assign the coordinates passed to the <i>X</i> , <i>Y</i> function to the structure of the displayed region.  If you are wondering what the <i>NULL</i> parameter was in the <i>SDL_BlitSurface</i> (yes, the author, we are interested!), This is another parameter of the type <i>SDL_Rect</i> .  We will come back to this later. <br>  Later came!  I think that no one will be offended if we analyze the <i>SDL_BlitSurface</i> signature a little earlier.  Briefly I will explain: we do not always need to display the entire surface on top of another, there are many cases when you need to select some part of the image (for example, we have a tileset (from the English tileset - a set of images, just a lot of pictures collected in one image) and you need to choose from it a certain square with a texture or character, etc.).  And so <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDL_BlitSurface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect)</span></span></span></span>;</code> </pre><br>  takes as parameters in order, from left to right: <br><ul><li>  surface to be applied; </li><li>  Parameters of the region for displaying the overlaid surface (i.e. which part of it will be displayed) </li><li>  surface on which we will impose; </li><li>  well, and, accordingly, the parameters of the region of the base surface, which will impose. </li></ul><br>  I think now everything has become more or less transparent and understandable. <br>  At the end of the function, we draw the configured surfaces and return <b>true</b> . <br><br>  Now, to make sure everything works, let's create a test surface.  Open <i>CApp.h</i> , and add a new surface, and include the <i>CSurface.h</i> header file we <i>created</i> : <br><br><div class="spoiler">  <b class="spoiler_title">CApp.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CAPP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CAPP_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL/SDL.h&gt; #include "CSurface.h" class CApp { private: bool Running; SDL_Surface* Surf_Display; SDL_Surface* Surf_Test; public: CApp(); int OnExecute(); public: bool OnInit(); void OnEvent(SDL_Event* Event); void OnLoop(); void OnRender(); void OnCleanup(); }; #endif</span></span></span></span></code> </pre><br></div></div><br>  Also in the constructor, do not forget to zero our surfaces first: <br><br><div class="spoiler">  <b class="spoiler_title">CApp.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">CApp::CApp() { Surf_Test = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Surf_Display = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; Running = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br>  And remember to clean! <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnCleanup.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> void CApp::OnCleanup() { SDL_FreeSurface(Surf_Test); SDL_FreeSurface(Surf_Display); SDL_Quit(); }</span></span></code> </pre><br></div></div><br>  It is time to download something already.  Open <i>CApp_OnInit.cpp</i> and bring it to this view: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnInit.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> bool CApp::OnInit() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Display = SDL_SetVideoMode(640, 480, 32, SDL_HWSURFACE | SDL_DOUBLEBUF)) == NULL) { return false; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((Surf_Test = CSurface::OnLoad(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"myimage.bmp"</span></span></span><span class="hljs-meta">)) == NULL) { return false; } return true; }</span></span></code> </pre><br></div></div><br>  Make sure you actually have a file <i>called myimage.bmp</i> .  If not, download or draw it yourself and put it in the directory with the executable file of your game.  Open <i>CApp_OnRender.cpp</i> and add the following: <br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnRender.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> void CApp::OnRender() { CSurface::OnDraw(Surf_Display, Surf_Test, 0, 0); SDL_Flip(Surf_Display); }</span></span></code> </pre><br></div></div><br>  Notice the new <i>SDL_Flip</i> feature.  It updates the buffer and displays the <i>Surf_Display</i> to the screen.  This is called double buffering.  It prepares the created surfaces first in memory, and then displays the prepared ones on the screen.  If we didn‚Äôt use it, we‚Äôd see a flickering screen.  Remember the <i>SDL_DOUBLEBUF</i> flag we specified when creating the surface?  This is exactly what turns on double buffering. <br>  Now you can compile the project and make sure that everything works correctly.  You should see the image in the upper left corner of the window.  If so, congratulations, you are one step closer to the real game.  If not, make sure that you have <i>myimage.bmp</i> in the same folder as the executable file, and also that it opens normally in the graphics viewer.  That's what happened with me: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f0/e15/ed6/2f0e15ed61dc930af3505ab03b167c49.png"><br><br>  (And yes, I have a little <s>cleverly</s> modified the code and uploaded my avatar in <i>* .PNG</i> format using <i>IMG_Load</i> . I advise you to experiment with this function too, and with others too. Dare and everything will work out for you!).  If you <code>deprecated conversion from string constant to 'char*' -wwrite-strings</code> a message that you want to change the signature of the <i>OnLoad (char * File)</i> function to <i>OnLoad (const char * File)</i> in <i>CSurface.h</i> and accordingly in <i>CSurface.cpp</i> . <br><br>  Let's move on!  We excused ourselves by finally displaying our first image in the window, but very often we only need to display a part of it, as an example ‚Äî the tilesets listed below: <br><br><div class="spoiler">  <b class="spoiler_title">Tilesets</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/d5a/74d/4ce/d5a74d4ce0a3d8bfc71903a966767a2a.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/850/62f/e56/85062fe5683f1d70d20b1145b38dd3ed.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/da6/3da/aa4/da63daaa470a4e315970d2b1cf8a03e6.gif"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/69f/be0/214/69fbe02144e5b9cbeb2574c17c30cdc8.png"><br></div></div><br>  Those.  With just one image, we only need to draw a part of it.  Open <i>CSurface.h</i> , and add the following code: <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CSURFACE_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;SDL/SDL.h&gt; class CSurface { public: CSurface(); public: static SDL_Surface* OnLoad(char* File); static bool OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y); static bool OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, int X, int Y, int X2, int Y2, int W, int H); }; #endif</span></span></span></span></code> </pre><br></div></div><br>  Open <i>CSurface.cpp</i> , and add the following function <b>(Important, we add the second <i>OnDraw</i> function, and do not replace the existing one! Are you aware of the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B3%25D1%2580%25D1%2583%25D0%25B7%25D0%25BA%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2586%25D0%25B5%25D0%25B4%25D1%2583%25D1%2580_%25D0%25B8_%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D0%25B9">function overloading</a> ?)</b> : <br><br><div class="spoiler">  <b class="spoiler_title">CSurface.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CSurface::OnDraw(SDL_Surface* Surf_Dest, SDL_Surface* Surf_Src, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Y2, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> W, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> H) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Surf_Dest == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || Surf_Src == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } SDL_Rect DestR; DestR.x = X; DestR.y = Y; SDL_Rect SrcR; SrcR.x = X2; SrcR.y = Y2; SrcR.w = W; SrcR.h = H; SDL_BlitSurface(Surf_Src, &amp;SrcR, Surf_Dest, &amp;DestR); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br></div></div><br>  See, this is basically the same function as before, except we added another <i>SDL_Rect</i> .  This region allows you to specify which pixels from the overlay surface to copy to the main one.  Now, along with the coordinates, we also indicate the remaining two parameters - the width and height of <i>0, 0, 50, 50</i> and as a result we get the displayed region in the form of a square 50x50 pixels. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47d/cdc/3c7/47dcdc3c72455823d5b0b1489cd899e1.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">CApp_OnRender.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CApp.h"</span></span></span><span class="hljs-meta"> void CApp::OnRender() { CSurface::OnDraw(Surf_Display, Surf_Test, 0, 0); CSurface::OnDraw(Surf_Display, Surf_Test, 100, 100, 0, 0, 50, 50); SDL_Flip(Surf_Display); }</span></span></code> </pre><br></div></div><br>  And here is a piece of my avatar with an indent of 100 pixels from the top and left edge of the screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e80/24d/aaa/e8024daaafd7603cbfc542f0303070fe.png"><br><br>  Links to source code: <br><ul><li>  <a href="">Win32</a> </li><li>  <a href="">* nix</a> </li></ul><br><br>  Links to all lessons: <br><ul><li>  <a href="http://habrahabr.ru/post/166875/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/166875/">Part 1 - The Basics of SDL</a> </li><li>  Developing a game framework.  Part 2 - Coordinates and Mapping </li><li>  <a href="http://habrahabr.ru/post/167245/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/167245/">Part 3 - Events</a> </li><li>  <a href="http://habrahabr.ru/post/167443/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/167443/">Part 4 - Tic-Tac-Toe</a> </li><li>  <a href="http://habrahabr.ru/post/169197/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/169197/">Part 5 - Animation</a> </li><li>  <a href="http://habrahabr.ru/post/169295/">Developing a game framework.</a>  <a href="http://habrahabr.ru/post/169295/">Part 6 - Entities</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/167035/">https://habr.com/ru/post/167035/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167025/index.html">Google first disclosed user data to Russian government agencies</a></li>
<li><a href="../167027/index.html">Android Evolution, statistics, facts</a></li>
<li><a href="../167029/index.html">Yandeks.Kartinki: the path of the interface solution from idea to implementation</a></li>
<li><a href="../167031/index.html">Arduino: configuration using DHCP</a></li>
<li><a href="../167033/index.html">Overflow of the call stack of JavaScript, SetTimeout and reduced performance of AJAX</a></li>
<li><a href="../167037/index.html">Small crib on Cisco CSS 11500</a></li>
<li><a href="../167039/index.html">Incorrect work of the standard search for Windows operating systems</a></li>
<li><a href="../167041/index.html">Breaking matches, or Alice in the land of mathematical errors</a></li>
<li><a href="../167043/index.html">How to create a 3D panorama of the battle of Borodino</a></li>
<li><a href="../167045/index.html">Kiev. Saturday. Habrare</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>