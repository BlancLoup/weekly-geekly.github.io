<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study the blockchain in practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You are reading this article because, like me, you watch the increasing popularity of cryptocurrency with keen interest. And you want to understand ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study the blockchain in practice</h1><div class="post__text post__text-html js-mediator-article">  You are reading this article because, like me, you watch the increasing popularity of cryptocurrency with keen interest.  And you want to understand how blockchain works - the technology that underlies it. <br><br>  But to understand the blockchain is not so easy, at least in my experience.  I pored over abstruse videos, pushed through tutorials, and with growing annoyance noted the lack of illustrative examples. <br><br>  I prefer to study in the process.  In this scenario, I have to work on the topic immediately at the code level, which helps to consolidate the skill.  If you follow my example, by the end of the article you will have a functioning blockchain and a clear understanding of how this all works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/59/d4/79/59d479e1ed4da475699339.jpeg"><br><a name="habracut"></a><br><h3>  But for starters ... </h3><br>  Let me remind you that a blockchain is an unchangeable, consistent chain of entries called blocks.  They can include transactions, files, and, in principle, any other kind of data.  The main thing here is that they are connected to each other by means of hashes. <br><br>  If you do not quite understand what a hash is, go <a href="https://learncryptography.com/hash-functions/what-are-hash-functions">here</a> . <br><br>  Who is this guide intended for?  For those who can read and write simple Python code without any problems and in general terms how HTTP requests work - we will communicate with our blockchain via HTTP. <br><br>  What will be needed for work?  Make sure you have <a href="https://www.python.org/downloads/">Python 3.6+ installed</a> (along with pip).  You will also need to install Flask and the excellent Requests library: <br><br><pre><code class="python hljs">pip install Flask==<span class="hljs-number"><span class="hljs-number">0.12</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> requests==<span class="hljs-number"><span class="hljs-number">2.18</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span></code> </pre> <br>  Oh yeah, you also need an HTTP client, for example, <a href="https://www.getpostman.com/">Postman</a> or cURL.  Anybody here will do. <br><br>  Where can I see what happens in the end?  Source code is available <a href="https://github.com/dvf/blockchain">here</a> . <br><br><h3>  Step One: Making the Blockchain </h3><br>  Open your favorite text or graphics editor, for example I like <a href="https://www.jetbrains.com/pycharm/">PyCharm</a> .  Create a new file called blockchain.py.  We will work only in this file, and if you get confused, you can always peek into the <a href="https://github.com/dvf/blockchain">source code</a> . <br><br>  <b>Blockchain view</b> <br><br>  First, we create a new class, the constructor of which will create the original empty list (where our blockchain will be stored) and one more for transactions.  This is how the class structure looks like: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.chain = [] self.current_transactions = [] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># Creates a new Block and adds it to the chain pass def new_transaction(self): # Adds a new transaction to the list of transactions pass @staticmethod def hash(block): # Hashes a Block pass @property def last_block(self): # Returns the last Block in the chain pass</span></span></code> </pre> <br><br>  The <i>Blockchain</i> class is responsible for managing the chain.  Transactions will be stored here, as well as some auxiliary methods for adding new blocks to the chain.  Let's write out these methods. <br><br>  <b>What does a block look like?</b> <br><br>  Each block contains an index, a timestamp (in Unix), a list of transactions, a proof, and a hash of the previous block. <br><br>  Here is an example of how a separate block can look like: <br><br><pre> <code class="python hljs">block = { <span class="hljs-string"><span class="hljs-string">'index'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'timestamp'</span></span>: <span class="hljs-number"><span class="hljs-number">1506057125.900785</span></span>, <span class="hljs-string"><span class="hljs-string">'transactions'</span></span>: [ { <span class="hljs-string"><span class="hljs-string">'sender'</span></span>: <span class="hljs-string"><span class="hljs-string">"8527147fe1f5426f9dd545de4b27ee00"</span></span>, <span class="hljs-string"><span class="hljs-string">'recipient'</span></span>: <span class="hljs-string"><span class="hljs-string">"a77f5cdfa2934df3954a5c7c7da5df1f"</span></span>, <span class="hljs-string"><span class="hljs-string">'amount'</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, } ], <span class="hljs-string"><span class="hljs-string">'proof'</span></span>: <span class="hljs-number"><span class="hljs-number">324984774000</span></span>, <span class="hljs-string"><span class="hljs-string">'previous_hash'</span></span>: <span class="hljs-string"><span class="hljs-string">"2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"</span></span> }</code> </pre> <br>  Now the idea of ‚Äã‚Äãthe chain should be obvious - each block includes a preceding hash.  This is very important: this is how the immutability of the chain is ensured: if a hacker damages a block, absolutely all subsequent ones will contain invalid hashes. <br><br>  Clear?  If not, stop and give yourself time to assimilate this information - it is the basic principle of the blockchain. <br><br>  <b>Add transactions to the block</b> <br><br>  We need to somehow add new transactions to the block.  The <i>new_transaction ()</i> method is responsible for <i>this</i> ; it works quite simply: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, sender, recipient, amount)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction """</span></span> self.current_transactions.append({ <span class="hljs-string"><span class="hljs-string">'sender'</span></span>: sender, <span class="hljs-string"><span class="hljs-string">'recipient'</span></span>: recipient, <span class="hljs-string"><span class="hljs-string">'amount'</span></span>: amount, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.last_block[<span class="hljs-string"><span class="hljs-string">'index'</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  When <i>new_transaction ()</i> adds a new transaction to the list, it returns the index of the block where it was recorded to the next one with which mining will be done.  Later it will come in handy to the next user who adds the transaction. <br><br>  In addition to creating a genesis block in the constructor, we will also <i>write down the new_block ()</i> , <i>new_transaction (),</i> and <i>hash ()</i> methods: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.current_transactions = [] self.chain = [] <span class="hljs-comment"><span class="hljs-comment"># Create the genesis block self.new_block(previous_hash=1, proof=100) def new_block(self, proof, previous_hash=None): """ Create a new Block in the Blockchain :param proof: &lt;int&gt; The proof given by the Proof of Work algorithm :param previous_hash: (Optional) &lt;str&gt; Hash of previous Block :return: &lt;dict&gt; New Block """ block = { 'index': len(self.chain) + 1, 'timestamp': time(), 'transactions': self.current_transactions, 'proof': proof, 'previous_hash': previous_hash or self.hash(self.chain[-1]), } # Reset the current list of transactions self.current_transactions = [] self.chain.append(block) return block def new_transaction(self, sender, recipient, amount): """ Creates a new transaction to go into the next mined Block :param sender: &lt;str&gt; Address of the Sender :param recipient: &lt;str&gt; Address of the Recipient :param amount: &lt;int&gt; Amount :return: &lt;int&gt; The index of the Block that will hold this transaction """ self.current_transactions.append({ 'sender': sender, 'recipient': recipient, 'amount': amount, }) return self.last_block['index'] + 1 @property def last_block(self): return self.chain[-1] @staticmethod def hash(block): """ Creates a SHA-256 hash of a Block :param block: &lt;dict&gt; Block :return: &lt;str&gt; """ # We must make sure that the Dictionary is Ordered, or we'll have inconsistent hashes block_string = json.dumps(block, sort_keys=True).encode() return hashlib.sha256(block_string).hexdigest()</span></span></code> </pre> <br>  The above code probably doesn‚Äôt need any explanations - I added comments and dokstrings here and there to make it clearer.  With the introduction of the blockchain, we are almost done.  But now you must be wondering how the process of creating, embedding and mining blocks takes place. <br><br>  <b>We deal with the proof of work</b> <br><br>  The proof of work algorithm is used to create new blocks in the blockchain (this process is also called mining).  The goal of the proof of work is to calculate the desired value to solve the equation.  This value should be difficult to calculate (from a mathematical point of view), but easy to check for any member of the system.  This is the main idea of ‚Äã‚Äãthe proof of work. <br><br>  To make it clearer, let's consider a very simple example. <br><br>  Suppose a hash of some number X multiplied by another Y should end with 0. Accordingly, hash (x * y) = ac23dc ... 0.  For this simplified example, we set x = 5. We set all this in Python: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sha256 x = <span class="hljs-number"><span class="hljs-number">5</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment"># We don't know what y should be yet... while sha256(f'{x*y}'.encode()).hexdigest()[-1] != "0": y += 1 print(f'The solution is y = {y}')</span></span></code> </pre> <br>  The correct answer is here: y = 21;  it is with this value that the hash with 0 at the end is obtained <br><br><pre> <code class="python hljs">hash(<span class="hljs-number"><span class="hljs-number">5</span></span> * <span class="hljs-number"><span class="hljs-number">21</span></span>) = <span class="hljs-number"><span class="hljs-number">1253e9373</span></span>e..<span class="hljs-number"><span class="hljs-number">.5e3600155</span></span>e860</code> </pre> <br>  In Bitcoin, the proof of work algorithm is called <a href="https://en.wikipedia.org/wiki/Hashcash">HashCash</a> and is not particularly different from the simple example above.  This is the equation that the miners are trying to solve in order to create a new block.  In general, the complexity is determined by how many characters you need to calculate in a given sequence.  For the correct answer miners receive remuneration in the form of one coin - during the transaction. <br><br>  Check their solution for the system is not difficult. <br><br>  <b>We write a simple proof of work</b> <br><br>  Now let's write a similar algorithm for our blockchain.  Conditions take in the spirit of the above example: <br><br>  <i>Find the number p, which, when hashed with the proof of the previous block, gives a hash with four zeros at the beginning.</i> <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid4 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proof_of_work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, last_proof)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Simple Proof of Work Algorithm: - Find a number p' such that hash(pp') contains leading 4 zeroes, where p is the previous p' - p is the previous proof, and p' is the new proof :param last_proof: &lt;int&gt; :return: &lt;int&gt; """</span></span> proof = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> self.valid_proof(last_proof, proof) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>: proof += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> proof @staticmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valid_proof</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(last_proof, proof)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Validates the Proof: Does hash(last_proof, proof) contain 4 leading zeroes? :param last_proof: &lt;int&gt; Previous Proof :param proof: &lt;int&gt; Current Proof :return: &lt;bool&gt; True if correct, False if not. """</span></span> guess = <span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{last_proof}</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{proof}</span></span></span><span class="hljs-string">'</span></span>.encode() guess_hash = hashlib.sha256(guess).hexdigest() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> guess_hash[:<span class="hljs-number"><span class="hljs-number">4</span></span>] == <span class="hljs-string"><span class="hljs-string">"0000"</span></span></code> </pre> <br>  We can vary the complexity of this task by changing the number of zeros at the beginning.  But four is enough.  You can see for yourself that a single additional zero significantly slows down the process of finding a solution. <br><br>  The work on the class is almost complete and now we are ready to begin interacting with it using HTTP requests. <br><br><h3>  Step Two: Blockchain as an API </h3><br>  Here we will use Python Flask, a microframe that facilitates the process of correlating end points with Python functions, which allows us to communicate with the blockchain over the Web using HTTP requests. <br><br>  We create three methods: <br><br><ul><li>  <i>/ transactions / new</i> to create a new transaction in a block </li><li>  <i>/ mine</i> for mining a new block on the server </li><li>  <i>/ chain</i> to return the full blockchain chain. </li></ul><br>  <b>Customize Flask</b> <br><br>  Our "server" will generate a single network node in the blockchain system.  Let's write some sample code: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> textwrap <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dedent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid4 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> ... <span class="hljs-comment"><span class="hljs-comment"># Instantiate our Node app = Flask(__name__) # Generate a globally unique address for this node node_identifier = str(uuid4()).replace('-', '') # Instantiate the Blockchain blockchain = Blockchain() @app.route('/mine', methods=['GET']) def mine(): return "We'll mine a new Block" @app.route('/transactions/new', methods=['POST']) def new_transaction(): return "We'll add a new transaction" @app.route('/chain', methods=['GET']) def full_chain(): response = { 'chain': blockchain.chain, 'length': len(blockchain.chain), } return jsonify(response), 200 if __name__ == '__main__': app.run(host='0.0.0.0', port=5000)</span></span></code> </pre> <br>  A brief explanation of what we added: <br><br>  Line 15: Instantiate a node.  Read more about Flask <a href="http://flask.pocoo.org/docs/0.12/quickstart/">here</a> . <br>  Line 18: Create an arbitrary name for the node. <br>  Line 21: Instantiates the <i>Blockchain</i> class. <br>  Lines 24-26: Creates a <i>/ mine</i> endpoint, i.e. a GET request. <br>  Lines 28-30: Creates an endpoint for <i>/ transactions / new</i> , that is, a POST request, since that is where we will send the data. <br>  Lines 32-38: Creates an endpoint <i>/ chain</i> , which returns the whole blockchain. <br>  Lines 40-41: Starts the server on port 5000. <br><br>  <b>End point for transactions</b> <br><br>  Here's what the transaction request will look like.  This is what the user sends to the server: <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"sender"</span></span>: <span class="hljs-string"><span class="hljs-string">"my address"</span></span>, <span class="hljs-string"><span class="hljs-string">"recipient"</span></span>: <span class="hljs-string"><span class="hljs-string">"someone else's address"</span></span>, <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br>  We already have a class method for adding a transaction to the block, so everything is easy further.  Let's write a function to add a transaction: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> textwrap <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dedent <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid4 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask, jsonify, request ... @app.route(<span class="hljs-string"><span class="hljs-string">'/transactions/new'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'POST'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> values = request.get_json() <span class="hljs-comment"><span class="hljs-comment"># Check that the required fields are in the POST'ed data required = ['sender', 'recipient', 'amount'] if not all(k in values for k in required): return 'Missing values', 400 # Create a new Transaction index = blockchain.new_transaction(values['sender'], values['recipient'], values['amount']) response = {'message': f'Transaction will be added to Block {index}'} return jsonify(response), 201</span></span></code> </pre> <br>  <b>Mining destination</b> <br><br>  It is at this end point that all the magic is created, but there is nothing particularly difficult in it.  She should do three things: <br><br><ol><li>  Calculate proof of work </li><li>  To issue a miner (that is, us) a reward, adding a transaction, during which we receive one coin </li><li>  Embed a new block in the chain </li></ol><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hashlib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> uuid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> uuid4 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask, jsonify, request ... @app.route(<span class="hljs-string"><span class="hljs-string">'/mine'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'GET'</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># We run the proof of work algorithm to get the next proof... last_block = blockchain.last_block last_proof = last_block['proof'] proof = blockchain.proof_of_work(last_proof) # We must receive a reward for finding the proof. # The sender is "0" to signify that this node has mined a new coin. blockchain.new_transaction( sender="0", recipient=node_identifier, amount=1, ) # Forge the new Block by adding it to the chain block = blockchain.new_block(proof) response = { 'message': "New Block Forged", 'index': block['index'], 'transactions': block['transactions'], 'proof': block['proof'], 'previous_hash': block['previous_hash'], } return jsonify(response), 200</span></span></code> </pre><br>  Please note that the node address is specified as the recipient of the created block.  Most of what we do here comes down to interacting with the methods of our <i>Blockchain</i> class.  Upon completion of this step, the main work is completed, you can start a dialogue. <br><br><h3>  Step Three: Dialogue with the blockchain </h3><br>  To interact with the API within the system, you can use the good old cURL or Postman. <br><br>  We start the server: <br><br><pre> <code class="python hljs">$ python blockchain.py * Running on http://<span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">5000</span></span>/ (Press CTRL+C to quit)</code> </pre> <br>  Let's try to create a block by sending a GET request to localhost: 5000 / mine: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d4/79/59d479e19d32c558832019.png"></div><br>  Now we create a new transaction by sending a POST request containing its structure to the address <a href="http://localhost/">localhost</a> : 5000 / transactions / new: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d4/79/59d479e1a3e8c894537526.png"></div><br>  If you're not working with Postman, here's how to formulate a similar query in cURL: <br><br><pre> <code class="python hljs">$ curl -X POST -H <span class="hljs-string"><span class="hljs-string">"Content-Type: application/json"</span></span> -d <span class="hljs-string"><span class="hljs-string">'{ "sender": "d4ee26eee15148ee92c6cd394edd974e", "recipient": "someone-other-address", "amount": 5 }'</span></span> <span class="hljs-string"><span class="hljs-string">"http://localhost:5000/transactions/new"</span></span></code> </pre> <br>  I restarted the server and created two more blocks in order to get three in the end.  Let's examine the resulting chain through a query localhost: 5000 / chain: <br><br><pre> <code class="python hljs">{ <span class="hljs-string"><span class="hljs-string">"chain"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"previous_hash"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"proof"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1506280650.770839</span></span>, <span class="hljs-string"><span class="hljs-string">"transactions"</span></span>: [] }, { <span class="hljs-string"><span class="hljs-string">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"previous_hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"c099bc...bfb7"</span></span>, <span class="hljs-string"><span class="hljs-string">"proof"</span></span>: <span class="hljs-number"><span class="hljs-number">35293</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1506280664.717925</span></span>, <span class="hljs-string"><span class="hljs-string">"transactions"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"recipient"</span></span>: <span class="hljs-string"><span class="hljs-string">"8bbcb347e0634905b0cac7955bae152b"</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> } ] }, { <span class="hljs-string"><span class="hljs-string">"index"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"previous_hash"</span></span>: <span class="hljs-string"><span class="hljs-string">"eff91a...10f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"proof"</span></span>: <span class="hljs-number"><span class="hljs-number">35089</span></span>, <span class="hljs-string"><span class="hljs-string">"timestamp"</span></span>: <span class="hljs-number"><span class="hljs-number">1506280666.1086972</span></span>, <span class="hljs-string"><span class="hljs-string">"transactions"</span></span>: [ { <span class="hljs-string"><span class="hljs-string">"amount"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"recipient"</span></span>: <span class="hljs-string"><span class="hljs-string">"8bbcb347e0634905b0cac7955bae152b"</span></span>, <span class="hljs-string"><span class="hljs-string">"sender"</span></span>: <span class="hljs-string"><span class="hljs-string">"0"</span></span> } ] } ], <span class="hljs-string"><span class="hljs-string">"length"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre> <br><h3>  Step Four: Consensus </h3><br>  All this is very cool.  We have a simple blockchain, which allows you to make transactions and create new blocks.  But the blockchain only makes sense if it is decentralized.  And if we make it decentralized, how can we guarantee that the same chain will be displayed everywhere?  This is called the problem of consensus.  If we want the system to have more than one node, we will have to introduce a consensus algorithm. <br><br>  <b>Recognize new nodes</b> <br><br>  Before implementing the algorithm of consensus, we need to do something so that each node in the system knows about the existence of its neighbors.  Each node in the system must have a registry of all other nodes.  So you need additional endpoints: <br><br><ol><li>  <i>/ nodes / register</i> , which will accept the list of new nodes in the URL format </li><li>  <i>/ nodes / resolve</i> to implement a consensus algorithm that will resolve conflicts and keep track of the correct chain in the node. </li></ol><br>  We need to correct the blockchain constructor and provide a method for registering nodes: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> urllib.parse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urlparse ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> ... self.nodes = set() ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register_node</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, address)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Add a new node to the list of nodes :param address: &lt;str&gt; Address of node. Eg. 'http://192.168.0.5:5000' :return: None """</span></span> parsed_url = urlparse(address) self.nodes.add(parsed_url.netloc)</code> </pre><br>  Notice: we used <i>set ()</i> to store the list of nodes.  This is a simple way to ensure that adding new nodes will be respected indempotency - that is, no matter how many times we add any particular node, it will be counted only once. <br><br>  <b>Implement a consensus algorithm</b> <br><br>  As I already mentioned, a conflict occurs when the chain of one node is different from the chain of another.  To eliminate it, we introduce the following rule: the prerogative is always for the chain that is longer.  In other words, the longest chain in the system is considered as actual.  Using this algorithm, we reach a consensus among all the nodes of the system: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">... </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blockchain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class"> ... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid_chain</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(self, chain)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Determine if a given blockchain is valid :param chain: &lt;list&gt; A blockchain :return: &lt;bool&gt; True if valid, False if not """</span></span> last_block = chain[<span class="hljs-number"><span class="hljs-number">0</span></span>] current_index = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> current_index &lt; len(chain): block = chain[current_index] print(<span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{last_block}</span></span></span><span class="hljs-string">'</span></span>) print(<span class="hljs-string"><span class="hljs-string">f'</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{block}</span></span></span><span class="hljs-string">'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"\n-----------\n"</span></span>) <span class="hljs-comment"><span class="hljs-comment"># Check that the hash of the block is correct if block['previous_hash'] != self.hash(last_block): return False # Check that the Proof of Work is correct if not self.valid_proof(last_block['proof'], block['proof']): return False last_block = block current_index += 1 return True def resolve_conflicts(self): """ This is our Consensus Algorithm, it resolves conflicts by replacing our chain with the longest one in the network. :return: &lt;bool&gt; True if our chain was replaced, False if not """ neighbours = self.nodes new_chain = None # We're only looking for chains longer than ours max_length = len(self.chain) # Grab and verify the chains from all the nodes in our network for node in neighbours: response = requests.get(f'http://{node}/chain') if response.status_code == 200: length = response.json()['length'] chain = response.json()['chain'] # Check if the length is longer and the chain is valid if length &gt; max_length and self.valid_chain(chain): max_length = length new_chain = chain # Replace our chain if we discovered a new, valid chain longer than ours if new_chain: self.chain = new_chain return True return False</span></span></code> </pre> <br>  The first method <i>valid_chain ()</i> is responsible for checking the chains for validity, passing each block and verifying both the hash and the proof. <br><br>  <i>resolve_conflicts ()</i> is a method that <i>processes</i> all neighboring nodes: downloads their chains and checks them in the manner described above.  If a valid chain is found longer than ours, a replacement is made. <br><br>  Let's enter into our API two endpoints, one to add neighbors, and the other to resolve conflicts: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route('/nodes/register', methods=['POST']) def register_nodes(): values = request.get_json() nodes = values.get('nodes') if nodes is None: return "Error: Please supply a valid list of nodes", 400 for node in nodes: blockchain.register_node(node) response = { 'message': 'New nodes have been added', 'total_nodes': list(blockchain.nodes), } return jsonify(response), 201 @app.route('/nodes/resolve', methods=['GET']) def consensus(): replaced = blockchain.resolve_conflicts() if replaced: response = { 'message': 'Our chain was replaced', 'new_chain': blockchain.chain } else: response = { 'message': 'Our chain is authoritative', 'chain': blockchain.chain } return jsonify(response), 200</span></span></code> </pre> <br>  At this stage, if you want, you can attract other machines and build different nodes for your system.  Or achieve the same using different ports on the same machine.  I created a new node on another port on the same machine, and allowed the original node to recognize it.  Thus, it turned out two sites: localhost: 5000 and localhost: 5001. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d4/79/59d479e16c324017600180.png"></div><br>  In node number two, I added more blocks so that the chain turned out to be definitely longer.  Then I called GET <i>/ nodes / resolve</i> in the first node - and the consensus algorithm replaced its chain with the chain of the second. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d4/79/59d479e163afc393862588.png"></div><br>  Well that's all.  Now gather your friends and test your blockchain together. <br><br>  I hope this material will inspire you with new ideas.  Personally, I watch the development of cryptocurrency with great enthusiasm: I am sure that the blockchain will turn our ideas about the economy, government and storage of information. <br><br>  In the future, I plan to release the second part of the article, where we will add the transaction validation mechanism to the blockchain and talk about how all this can be used in products. </div><p>Source: <a href="https://habr.com/ru/post/339280/">https://habr.com/ru/post/339280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339270/index.html">Wi-Fi is over: calculate offenders wireless</a></li>
<li><a href="../339272/index.html">Why do I need the flexibility of Python if I am forbidden to use it?</a></li>
<li><a href="../339274/index.html">Trillion Markets, or have time to do in 10 years</a></li>
<li><a href="../339276/index.html">How to accept payments in a mobile application: tokenization, NFC, optical scanning and other buns in one SDK</a></li>
<li><a href="../339278/index.html">Technical composition of process diagrams</a></li>
<li><a href="../339282/index.html">It's time to kill C #</a></li>
<li><a href="../339284/index.html">Uneducated youth. Business response</a></li>
<li><a href="../339286/index.html">When reboot time matters or why IBM uses CRIU on mainframes</a></li>
<li><a href="../339288/index.html">Monaco cryptocurrency rate increased by 695% due to a transaction that did not exist</a></li>
<li><a href="../339290/index.html">PhosAgro: data center for four months</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>