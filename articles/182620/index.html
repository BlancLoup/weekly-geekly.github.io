<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exploring JavaScript Generators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I started writing on node.js, I hated two things: all the popular template engines and a huge number of callbacks. I voluntarily used callbacks b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exploring JavaScript Generators</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/b14/d85/91b/b14d8591b17039f086a546686c015e1b.png"><br><br>  When I started writing on node.js, I hated two things: all the popular template engines and a huge number of callbacks.  I voluntarily used callbacks because I understood all the power of event-oriented servers, but since then <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dharmony:generators">generators</a> have appeared in JavaScript, and I look forward to the day when they will be implemented. <br><br>  And this day comes.  Today, generators <a href="http://wingolog.org/archives/2013/05/08/generators-in-v8">are available in V8</a> and SpiderMonkey, implementation follows specification updates - this is the dawn of a new era! <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As long as the V8 hides behind the command line flag, new Harmony features, such as generators, will take some time.  Before they are available in all browsers, we can go ahead and learn to write asynchronous code with generators.  Let's try these approaches early on. <br><br>  You can use them today by downloading the <a href="http://nodejs.org/dist/v0.11.2/">unstable version of node 0.11</a> , which will be the next stable version.  When running node, pass the <code>--harmony</code> or <code>--harmony-generators</code> flag. <br><br>  So how do you use generators to rescue from callback hell?  Generator functions can pause execution with the help of the <code>yield</code> operator, and transfer the result in or out when they are resumed or suspended.  In this way, we can make a ‚Äúpause‚Äù when the function waits for the result of another function without passing a callback into it. <br><br>  Isn't it fun when I try to explain language constructs in our language?  How about diving into the code? <br><br><h4>  Generator basics </h4><br>  Let's look at a primitive generator before we dive into an asynchronous world.  Generators are declared as <code>function*</code> expressions: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; }</code> </pre><br>  The following is an example of a call: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gen = foo(<span class="hljs-number"><span class="hljs-number">5</span></span>); gen.next(); <span class="hljs-comment"><span class="hljs-comment">// { value: 6, done: false } gen.next(); // { value: null, done: false } gen.send(8); // { value: 13, done: true }</span></span></code> </pre><br>  If I took notes in class, I would write: <br><br><ul><li>  <code>yield</code> allowed in all expressions. </li><li>  A generator call is identical to a normal function, but it creates a generator object.  You need to call <code>next</code> or <code>send</code> to resume the generator.  <code>send</code> used when you want to send a value back to it.  <code>gen.next()</code> equivalent to <code>gen.send(null)</code> .  There is also a <code>gen.throw</code> that throws an exception inside the generator. </li><li>  Generator methods do not return a pure initial value, but an object with two parameters: <code>value</code> and <code>done</code> .  Thanks to <code>done</code> it becomes clear when the generator is finished, either with a <code>return</code> , or a simple end of the function, instead of the inconvenient exception <code>StopIteration</code> , which was in the old API. </li></ul><br><h4>  Asynchronous Solution # 1: Suspend </h4><br>  What to do with the code in which callback hell?  Well, if we can arbitrarily suspend the execution of a function.  We can turn our asynchronous callback code back into a synchronous-looking code with sugar crumbs. <br><br>  Question: what is sugar? <br><br>  The first solution is suggested in the <a href="https://github.com/jmar777/suspend">suspend</a> library.  It is very simple.  Only <a href="">16 lines of code</a> , seriously. <br><br>  This is how our code with this library looks like: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suspend = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'suspend'</span></span>), fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); suspend(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resume</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> fs.readFile(__filename, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, resume); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data[<span class="hljs-number"><span class="hljs-number">0</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">1</span></span>]); })();</code> </pre><br>  The <code>suspend</code> function passes your generator inside a normal function that starts the generator.  It passes the <code>resume</code> function to the generator, the <code>resume</code> function must be used as a callback for all asynchronous calls, it resumes the generator with arguments containing the error and value flags. <br><br>  Dance <code>resume</code> and generator are interesting, but there are some drawbacks.  First, the backward array of two elements is inconvenient, even with destructuring ( <code>var [err, res] = yield foo(resume)</code> ).  I would like to return only the value, and throw the error as an exception, if any.  The library actually supports this, but as an option, I think this should be the default. <br><br>  Secondly, it is inconvenient to always explicitly transfer resume, moreover, it is not suitable when you wait until the function above completes.  And I still have to add a <code>callback</code> and call it at the end of the function, as is usually done in the node. <br><br>  Finally, you cannot use more complex execution threads, for example with multiple concurrent calls.  <a href="https://github.com/jmar777/suspend">README claims</a> that other execution flow control libraries are already solving this problem, and you should use <code>suspend</code> along with one of them, but I would prefer to see a flow control library that includes generator support. <br><br>  <i>Update from the author:</i> <a href="https://twitter.com/kriskowal">kriskowal</a> suggested <a href="https://gist.github.com/creationix/5544019">this gist</a> written by <a href="https://twitter.com/creationix">creationix</a> , an improved stand-alone generator handler for callback-based code is implemented there.  It is very cool to throw errors by default. <br><br><h4>  Asynchronous solution number 2: Promises </h4><br>  A more interesting way to control asynchronous execution flow is to use <a href="http://promises-aplus.github.io/promises-spec/">promises</a> .  A promise is an object that represents a future value, and you can provide promises to the calling flow of a program that represents asynchronous behavior. <br><br>  I will not explain the promises here, since it will take too long and, moreover, there is already a <a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">good explanation</a> .  Recently, emphasis has been placed on defining behavior and API promises for interaction between libraries, but the idea is rather simple. <br><br>  I am going to use the <a href="https://github.com/kriskowal/q">Q</a> library for promises, because it already has preliminary support from generators, and is also quite mature.  <a href="http://taskjs.org/">task.js</a> was an early implementation of this idea, but it had a non-standard promises implementation. <br><br>  Let's take a step back and look at a real life example.  We too often use simple examples.  This code creates a message, then gets it back, and receives a message with the same tags ( <code>client</code> is an instance of redis): <br><br><pre> <code class="javascript hljs">client.hmset(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-string"><span class="hljs-string">'20130605'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'g3n3rat0rs r0ck'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tags</span></span>: <span class="hljs-string"><span class="hljs-string">'js,node'</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; client.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, post</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tags = post.tags.split(<span class="hljs-string"><span class="hljs-string">','</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> posts = []; tags.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tag</span></span></span><span class="hljs-function">) </span></span>{ client.hgetall(<span class="hljs-string"><span class="hljs-string">'post::tag::'</span></span> + tag, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, taggedPost</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(err) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; posts.push(taggedPost); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(posts.length == tags.length) { <span class="hljs-comment"><span class="hljs-comment">//  -  post  taggedPosts client.quit(); } }); }); }); });</span></span></code> </pre><br>  See how this example is ugly!  Callbacks quickly press the code to the right side of our screen.  In addition, to request all tags, we must manually manage each request and check when they are all ready. <br><br>  Let's bring this code to <a href="https://github.com/kriskowal/q">Q</a> promises. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db = { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: Q.nbind(client.get, client), <span class="hljs-attr"><span class="hljs-attr">set</span></span>: Q.nbind(client.set, client), <span class="hljs-attr"><span class="hljs-attr">hmset</span></span>: Q.nbind(client.hmset, client), <span class="hljs-attr"><span class="hljs-attr">hgetall</span></span>: Q.nbind(client.hgetall, client) }; db.hmset(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-string"><span class="hljs-string">'20130605'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'g3n3rat0rs r0ck'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tags</span></span>: <span class="hljs-string"><span class="hljs-string">'js,node'</span></span> }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">post</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tags = post.tags.split(<span class="hljs-string"><span class="hljs-string">','</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Q.all(tags.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::tag::'</span></span> + tag); })).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">taggedPosts</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  -  post  taggedPosts client.quit(); }); }).done();</span></span></code> </pre><br>  We had to wrap the redis functions, and thus turned the callback-based into promise-based, it's simple.  As soon as we receive promises, you call <code>then</code> and wait for the result of the asynchronous operations.  Much more detail is explained in <a href="http://promises-aplus.github.io/promises-spec/">the promises / A + specification</a> . <br><br>  <code>Q</code> implements several additional methods, such as <code>all</code> , it takes an array of promises and waits until each one of them completes.  In addition, there is <code>done</code> , which says that your asynchronous process has ended and any unhandled errors should be thrown.  According to the promises / A + specification, all exceptions should be converted to errors and passed to the error handler.  Thus, you can be sure that all errors will be thrown if they do not have a handler.  (If something is not clear, please <a href="http://domenic.me/2012/10/14/youre-missing-the-point-of-promises/">read this article</a> from Dominic.) <br><br>  Notice how deep the final promise is.  This is because we first need access to the <code>post</code> , and then to <code>taggedPosts</code> .  It feels callback-style code, it's annoying. <br><br>  And now is the time to evaluate the power of generators: <br><br><pre> <code class="javascript hljs">Q.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db.hmset(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">date</span></span>: <span class="hljs-string"><span class="hljs-string">'20130605'</span></span>, <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">'g3n3rat0rs r0ck'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tags</span></span>: <span class="hljs-string"><span class="hljs-string">'js,node'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> post = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tags = post.tags.split(<span class="hljs-string"><span class="hljs-string">','</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taggedPosts = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> Q.all(tags.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::tag::'</span></span> + tag); })); <span class="hljs-comment"><span class="hljs-comment">//  -  post  taggedPosts client.quit(); })().done();</span></span></code> </pre><br>  Isn't that amazing?  How does this actually happen? <br><br>  <code>Q.async</code> takes a generator and returns a function that controls it, like the suspend library.  However, the key difference here is that the generator gives (yields) promises.  Q accepts each promise and connects the generator with it, does resume when the promise is completed, and sends the result back. <br><br>  We should not control the awkward function <code>resume</code> - promises to handle it completely, and we get the advantage of <a href="http://promises-aplus.github.io/promises-spec/">promises</a> . <br><br>  One of the advantages is that we can use different Q promises when necessary, for example <code>Q.all</code> , which runs several asynchronous operations in parallel.  Thus, you can easily combine similar Q promises and implicit promises in generators to create complex execution threads that look very clean. <br><br>  Also note that we have no nesting problem at all.  Since <code>post</code> and <code>taggedPosts</code> remain in the same scope, we no longer care about breaking the chain of scope into <code>then</code> , which is incredibly pleasing. <br><br>  Error handling is very tricky, and you really need to understand how promises work before using them in generators.  Errors and exceptions in promises are always passed to the error handling function, and never throw exceptions. <br><br>  Any <code>async</code> generator is a promise, with no exceptions.  You can manage errors using error callback: <code>someGenerator().then(null, function(err) { ... })</code> . <br><br>  However, there is a special behavior of generator promises, which is that any errors from promises thrown into the generator using the special method <code>gen.throw</code> will be thrown by an exception from the point where the generator was suspended.  This means that you can use <code>try/catch</code> to handle errors in the generator: <br><br><pre> <code class="javascript hljs">Q.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> post = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tags = post.tags.split(<span class="hljs-string"><span class="hljs-string">','</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> taggedPosts = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> Q.all(tags.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::tag::'</span></span> + tag); })); <span class="hljs-comment"><span class="hljs-comment">//  -  post  taggedPosts } catch(e) { console.log(e); } client.quit(); })();</span></span></code> </pre><br>  This works exactly as you expect: errors from any <code>db.hgetall</code> call will be handled in the <code>catch</code> handler, even if it is an error in a deep promise inside <code>Q.all</code> .  Without <code>try/catch</code> exception will be passed to the caller's promise error handler (if there is no caller, the error will be suppressed). <br><br>  Think about it - <b>we can set exception handlers using try / catch for asynchronous code.</b>  The dynamic scope of the error handler will be correct;  any unhandled errors that occur while the <code>try</code> block is being executed will be passed to <code>catch</code> .  You can use <code>finally</code> to create confident ‚Äúcleanup‚Äù code at startup even for an error, without the presence of an error handler. <br><br>  In addition, use <code>done</code> whenever you use promises ‚Äî by default, you can get thrown errors instead of quiet ignoring, which happens too often with asynchronous code.  The way to use <code>Q.async</code> , as a rule, looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getTaggedPosts = Q.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> post = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db.hgetall(<span class="hljs-string"><span class="hljs-string">'blog::post'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tags = post.tags.split(<span class="hljs-string"><span class="hljs-string">','</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Q.all(tags.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">tag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.hget(<span class="hljs-string"><span class="hljs-string">'blog::tag::'</span></span> + tag); })); });</code> </pre><br>  The above is the library code that simply creates promises and does not handle errors.  You call it like this: <br><br><pre> <code class="javascript hljs">Q.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tagged = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getTaggedPosts(); <span class="hljs-comment"><span class="hljs-comment">//  -   tagged })().done();</span></span></code> </pre><br>  This is the top level code.  As stated earlier, the <code>done</code> method is guaranteed to throw an error for any unhandled error as an exception.  I believe that this approach is common, but you need to call an extra method.  <code>getTaggedPosts</code> will be used by promise-generating functions.  The code above is simply a top level code that is filled with promises. <br><br>  I suggested Q.spawn in the <a href="https://github.com/kriskowal/q/pull/306">pull request</a> , and these changes already hit Q!  This allows you to do a simple run of code that uses promises, even easier: <br><br><pre> <code class="javascript hljs">Q.spawn(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tagged = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getTaggedPosts(); <span class="hljs-comment"><span class="hljs-comment">//  -   tagged });</span></span></code> </pre><br>  <code>spawn</code> takes a generator, immediately starts it, and automatically forwards all unprocessed errors.  This is exactly equivalent to <code>Q.done(Q.async(function*() { ... })())</code> . <br><br><h4>  Other approaches </h4><br>  Our promised-based generator code begins to take shape.  Together with grains of sugar, we can remove a lot of excess baggage associated with asynchronous workflow. <br><br>  After some time working with generators, I outlined several approaches. <br><br><h5>  Not worth it </h5><br>  If you have a short function that needs to wait only one promise, it is not worth creating a generator. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> getKey = Q.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> r.get(dbkey(key)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(x, <span class="hljs-number"><span class="hljs-number">10</span></span>); });</code> </pre><br>  Use this code: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getKey</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r.get(dbkey(key)).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(x, <span class="hljs-number"><span class="hljs-number">10</span></span>); }); }</code> </pre><br>  I think the latest version looks cleaner. <br><br><h5>  spawnMap </h5><br>  This is what I did often: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> Q.all(keys.map(Q.async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dateKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> lookupDate(dateKey); obj[date] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getPosts(date); })));</code> </pre><br>  It may be useful to have a <code>spawnMap</code> that performs <code>Q.all(arr.map(Q.async(...)))</code> for you. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> spawnMap(keys, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dateKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> lookupDate(dateKey); obj[date] = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> getPosts(date); })));</code> </pre><br>  This is similar to the <code>map</code> method from the <a href="https://github.com/caolan/async">async</a> library. <br><br><h5>  asyncCallback </h5><br>  The last thing I noticed: there are times when I want to create a <code>Q.async</code> function and make it forward all errors.  This happens with normal callbacks from different libraries, such as express: <code>app.get('/url', function() { ... })</code> . <br><br>  I cannot convert the above callback to the <code>Q.async</code> function, because then all the errors will be quietly suppressed, I also cannot use the <code>Q.spawn</code> because it is not executed immediately.  Perhaps something like <code>asyncCallback</code> would be good: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gen</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Q.async(gen).apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>).done(); }; } app.get(<span class="hljs-string"><span class="hljs-string">'/project/:name'</span></span>, asyncCallback(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">*(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counts = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db.getCounts(req.params.name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> post = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> db.recentPost(); res.render(<span class="hljs-string"><span class="hljs-string">'project.html'</span></span>, { <span class="hljs-attr"><span class="hljs-attr">counts</span></span>: counts, <span class="hljs-attr"><span class="hljs-attr">post</span></span>: post }); }));</code> </pre><br><h4>  As a summary </h4><br>  When I researched the generators, I really hoped that they would help with asynchronous code.  And, as it turned out, they really do it, although you need to understand how promises work in order to effectively combine them with generators.  Creating promises makes implicit even more implicit, so I would not recommend you use async or spawn until you understand the whole promise. <br><br>  Now we have a concise and incredibly powerful way to encode asynchronous behavior and we can use it for something more than just doing operations to work with the FS more beautiful.  In fact, we have a great way to write short, distributed code that can run on different processors, or even machines, while remaining synchronous. <br><br>  <i>Update from the author:</i> read my next article, <a href="http://jlongster.com/A-Closer-Look-at-Generators-Without-Promises">A look at generators without Promise</a> . </div><p>Source: <a href="https://habr.com/ru/post/182620/">https://habr.com/ru/post/182620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182606/index.html">Photos of workplaces habrazhiteli</a></li>
<li><a href="../182608/index.html">Real-Time UIKit Inspector (Reveal App)</a></li>
<li><a href="../182610/index.html">Threads, locks, and condition variables in C ++ 11 [Part 1]</a></li>
<li><a href="../182612/index.html">Silicone Skeleton - Silex tuned</a></li>
<li><a href="../182614/index.html">Qt Graphics Framework - the dark side. Part 1</a></li>
<li><a href="../182622/index.html">Video: New software development and testing offers for MSDN subscribers and other Windows Azure news</a></li>
<li><a href="../182626/index.html">Threads, locks, and condition variables in C ++ 11 [Part 2]</a></li>
<li><a href="../182628/index.html">Node.js: JavaScript Are you it?</a></li>
<li><a href="../182630/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ60 (June 1 - 8, 2013)</a></li>
<li><a href="../182632/index.html">Configuring via scripts instead of XML and JSON using the example of a realtime multiplayer game</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>