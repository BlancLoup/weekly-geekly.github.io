<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Playing Encrypted On-the-Fly Encrypted Files on iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of developing an application on the Sencha Touch framework for the iOS platform, it was necessary to implement the playback of local vi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Playing Encrypted On-the-Fly Encrypted Files on iOS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f03/dd1/7a3/f03dd17a365e41c4a588b2e11cada875.jpg" alt="image"><br><br>  In the process of developing an application on the Sencha Touch framework for the iOS platform, it was necessary to implement the playback of local video and audio files that must be encrypted on the server before downloading to the mobile device‚Äôs memory.  An additional condition was the ban on creating a decrypted version of the file on the disk, thus it became necessary to decrypt and read the data in RAM.  Therefore, the standard plug-in from Cordova to play local media files did not fit, although I didn‚Äôt have development experience on Objective-C, I decided to create my own, with the required functionality. <br><a name="habracut"></a><br>  The search for a solution led to the <a href="https://developer.apple.com/reference/avfoundation/avurlasset">AVURLAsset</a> class of the <a href="https://developer.apple.com/reference/avfoundation/avurlasset">AVFoundation</a> framework, which initializes the media object for the AVPlayer component.  To load an AVURLAsset resource, it uses its own resourceLoader object of the AVAssetResourceLoader class, this object works via AVAssetResourceLoaderDelegate, in which you need to define two methods: <br><br><pre><code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)resourceLoader:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoader</span></span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoadingRequest</span></span> *)loadingRequest; - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)resourceLoader:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoader</span></span> *)resourceLoader didCancelLoadingRequest:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoadingRequest</span></span> *)loadingRequest;</code> </pre> <br>  The first is used at the beginning and during the boot process, and the second is called when the boot process is canceled.  If an unknown resource loading scheme is specified, the resourceLoader will use the methods defined by the developer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, having defined the first method, it is possible to transfer decrypted data in the form of NSData. <br><br>  An example implementation of the method of loading data via AVAssetResourceLoaderDelegate: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)resourceLoader:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoader</span></span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoadingRequest</span></span> *)loadingRequest { loadingRequest.contentInformationRequest.contentType = (__bridge <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kUTTypeQuickTimeMovie; loadingRequest.contentInformationRequest.contentLength = movieLength; loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; [loadingRequest.dataRequest respondWithData:[decryptedData subdataWithRange:<span class="hljs-built_in"><span class="hljs-built_in">NSMakeRange</span></span>((<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)loadingRequest.dataRequest.requestedOffset, loadingRequest.dataRequest.requestedLength)]]; [loadingRequest finishLoading]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; }</code> </pre> <br>  In this code, decryptedData contains the result of decrypting the data that was downloaded from an encrypted file. <br><br>  Below I described an example of player initialization: <br><br>  Fake path to the local file, the important point is the custom scheme "encryptedfile: //": <br><br><pre> <code class="objectivec hljs">resourceURL = [<span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span> URLWithString:[<span class="hljs-string"><span class="hljs-string">@"encryptedfile://"</span></span> stringByAppendingString:fake-path-to-file]];</code> </pre> <br>  The real encrypted file is opened using NSFileHandle: <br><br><pre> <code class="objectivec hljs">fileHandle = [<span class="hljs-built_in"><span class="hljs-built_in">NSFileHandle</span></span> fileHandleForReadingFromURL:resourceURL error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>];</code> </pre> <br>  Below we initialize the player and delegate our own resourceLoader: <br><br><pre> <code class="objectivec hljs">assetPlayer = [<span class="hljs-built_in"><span class="hljs-built_in">AVURLAsset</span></span> assetWithURL:resourceURL]; [assetPlayer.resourceLoader setDelegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> queue:dispatch_get_main_queue()]; itemPlayer = [<span class="hljs-built_in"><span class="hljs-built_in">AVPlayerItem</span></span> playerItemWithAsset:assetPlayer]; avPlayer = [<span class="hljs-built_in"><span class="hljs-built_in">AVPlayer</span></span> playerWithPlayerItem:itemPlayer];</code> </pre> <br>  Next, create a controller for the player: <br><br><pre> <code class="objectivec hljs">controller = [[<span class="hljs-built_in"><span class="hljs-built_in">AVPlayerViewController</span></span> alloc] init]; [[<span class="hljs-built_in"><span class="hljs-built_in">AVAudioSession</span></span> sharedInstance] setCategory:<span class="hljs-built_in"><span class="hljs-built_in">AVAudioSessionCategoryPlayback</span></span> error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; controller.player = avPlayer; controller.player.actionAtItemEnd = <span class="hljs-built_in"><span class="hljs-built_in">AVPlayerActionAtItemEndNone</span></span>; [avPlayer play];</code> </pre> <br>  In essence, this code is fully working, but another problem remains - the memory limitation on mobile devices.  We cannot load the decrypted data of a large video file into RAM. <br><br>  So I decided to encrypt the source files in blocks, in my case 16 megabytes in order to be able to access any necessary block without decrypting the entire file. <br><br>  I modified the method of the resourceLoader object, which is called when the resource is loaded: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)resourceLoader:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoader</span></span> *)resourceLoader shouldWaitForLoadingOfRequestedResource:(<span class="hljs-built_in"><span class="hljs-built_in">AVAssetResourceLoadingRequest</span></span> *)loadingRequest { loadingRequest.contentInformationRequest.contentType = (__bridge <span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)kUTTypeQuickTimeMovie; loadingRequest.contentInformationRequest.contentLength = movieLength; loadingRequest.contentInformationRequest.byteRangeAccessSupported = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(chunkMode){ <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> offset = (<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)loadingRequest.dataRequest.requestedOffset; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(currentOffset != offset){ currentOffset = offset; <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> requestedBlock = floor(currentOffset/blockSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(currentBlockIndex != requestedBlock){ currentBlockIndex = requestedBlock; <span class="hljs-comment"><span class="hljs-comment">// Loading other block of data decryptedData = [self getDataFromFile:currentBlockIndex]; } } if(currentOffset &gt; blockSize*currentBlockIndex){ offset = currentOffset - blockSize*currentBlockIndex; } else { offset = 0; } NSUInteger maxLength = [decryptedData length] - offset; if(loadingRequest.dataRequest.requestedLength &lt; maxLength &amp;&amp; loadingRequest.dataRequest.requestedLength &lt;= [decryptedData length]){ maxLength = loadingRequest.dataRequest.requestedLength; } [loadingRequest.dataRequest respondWithData:[decryptedData subdataWithRange:NSMakeRange(offset, maxLength)]]; } else { [loadingRequest.dataRequest respondWithData:[decryptedData subdataWithRange:NSMakeRange((NSUInteger)loadingRequest.dataRequest.requestedOffset, loadingRequest.dataRequest.requestedLength)]]; } [loadingRequest finishLoading]; return YES; }</span></span></code> </pre> <br>  In the code, the chunkMode parameter indicates that the file was encrypted in blocks and you need to check the requestedOffset and requestedLength parameters to load the necessary block from the file and to decrypt it.  The getDataFromFile function is responsible for this: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSMutableData</span></span> *) getDataFromFile:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>) index { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fileHandle){ [fileHandle seekToFileOffset:index*chunksInBlock*chunkSize]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableData</span></span> dataWithData:[AESCrypt decryptData:[fileHandle readDataOfLength:chunksInBlock*chunkSize] password:PASSWORD chunkSize:blockSize iv:IV]]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }</code> </pre> <br>  In my case, I use the AES-128 CBC algorithm for encryption, and the AEScrypt-ObjC library for decryption. <br><br>  I added one method to decrypt the necessary blocks from an encrypted file (more universal, since in this particular case the size of the necessary block is always equal to the size of the encrypted block): <br><br><div class="spoiler">  <b class="spoiler_title">DecryptData method</b> <div class="spoiler_text"><pre> <code class="objectivec hljs">+ (<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>*) decryptData:(<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>*)data password:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)password chunkSize:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)chunkSize { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> decryptData:data password:password chunkSize:chunkSize offsetBlock:<span class="hljs-number"><span class="hljs-number">0</span></span> countBlock:<span class="hljs-number"><span class="hljs-number">0</span></span> iv:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; } + (<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>*) decryptData:(<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>*)data password:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)password chunkSize:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)chunkSize iv: (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) iv { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> decryptData:data password:password chunkSize:chunkSize offsetBlock:<span class="hljs-number"><span class="hljs-number">0</span></span> countBlock:<span class="hljs-number"><span class="hljs-number">0</span></span> iv:iv]; } + (<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>*) decryptData:(<span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>*)data password:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)password chunkSize:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)chunkSize offsetBlock:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)offsetBlock countBlock:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)countBlock iv: (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) iv { <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> length = [data length]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (chunkSize &gt; length) { chunkSize = floor(length/<span class="hljs-number"><span class="hljs-number">16</span></span>)*<span class="hljs-number"><span class="hljs-number">16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(countBlock &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ length = (offsetBlock+countBlock)*chunkSize; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length &gt; [data length]){ length = [data length]; } <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> offset = offsetBlock * chunkSize; <span class="hljs-built_in"><span class="hljs-built_in">NSMutableData</span></span> *decryptedData = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableData</span></span> alloc]; <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>* encryptedPartOfData; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> thisChunkSize = length - offset &gt; chunkSize ? chunkSize : length - offset; <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>* partOfData = [data subdataWithRange:<span class="hljs-built_in"><span class="hljs-built_in">NSMakeRange</span></span>(offset, thisChunkSize)]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(iv == <span class="hljs-literal"><span class="hljs-literal">nil</span></span>){ encryptedPartOfData = [partOfData decryptedAES256DataUsingKey:[[password dataUsingEncoding:<span class="hljs-built_in"><span class="hljs-built_in">NSUTF8StringEncoding</span></span>] SHA256Hash] error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { encryptedPartOfData = [partOfData decryptedAES256DataUsingKey:[password dataUsingEncoding:<span class="hljs-built_in"><span class="hljs-built_in">NSUTF8StringEncoding</span></span>] initializationVector:iv error:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; } [decryptedData appendData:encryptedPartOfData]; offset += thisChunkSize; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (offset &lt; length); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> decryptedData; }</code> </pre> <br></div></div><br>  As a result, we got a plugin that can play large encrypted files without creating the original version of the file on the device disk.  At the same time, the use of the device‚Äôs RAM has decreased, which is also an important advantage. <br><br>  Useful links: <br><br>  <a href="https://github.com/Gurpartap/AESCrypt-ObjC">AEScrypt-ObjC Library</a> <br>  <a href="https://habrahabr.ru/post/249605/">Article on Habr√©, which helped to understand the principles of AVAssetResourceLoaderDelegate</a> </div><p>Source: <a href="https://habr.com/ru/post/319732/">https://habr.com/ru/post/319732/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319722/index.html">jl-sql: SQL queries by JSON logs on the command line</a></li>
<li><a href="../319724/index.html">How npm became the most popular package manager in the world</a></li>
<li><a href="../319726/index.html">Not OK, Google! Or, how to talk with Google AdWords support</a></li>
<li><a href="../319728/index.html">MIT launched Moral Machine: an experiment to study how unmanned vehicles should be delivered</a></li>
<li><a href="../319730/index.html">Verification of the finite state machine</a></li>
<li><a href="../319734/index.html">Interview with Eddie Willems (G Data Software AG): Smart Security and the ‚ÄúInternet of Troubles‚Äù</a></li>
<li><a href="../319736/index.html">ARC CrossCompilation</a></li>
<li><a href="../319738/index.html">CES 2017 exhibition: payment, e-commerce and fintech trends</a></li>
<li><a href="../319740/index.html">Research trends in the behavior of retail customers</a></li>
<li><a href="../319744/index.html">QR codes - security issues: have we not rushed?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>