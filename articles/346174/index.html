<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Analyzing local functions in C # 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Adding local functions in C # was originally unnecessary for me. After reading the article in the blog SergeyT , I realized that this feature is reall...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Analyzing local functions in C # 7</h1><div class="post__text post__text-html js-mediator-article">  Adding local functions in C # was originally unnecessary for me.  After reading the article in the blog <a href="https://habrahabr.ru/users/sergeyt/" class="user_link">SergeyT</a> , I realized that this feature is really needed.  So, who doubts the need for local functions and who still does not know what it is, go for knowledge! <br><br>  <b>Local Functions</b> is a new feature in C # 7 that allows you to define a function within another function. <br><a name="habracut"></a><br><h3>  When to use local functions? </h3><br>  The basic idea of ‚Äã‚Äãlocal functions is very similar to anonymous methods: in some cases the creation of a named function is too expensive in terms of cognitive load on the reader.  Sometimes functionality, in its essence, is local to another function, and there is no reason to contaminate the ‚Äúexternal‚Äù scope with a separate named entity. <br><br>  You might think that this possibility is redundant, because the same behavior can be achieved with anonymous delegates or lambda expressions.  But it's not always the case.  Anonymous functions have certain limitations, and their performance characteristics may not be suitable for your scripts. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Usage example 1: prerequisites in iterator blocks </h3><br>  Here is a simple function that reads a file in rows.  Do you know when ArgumentNullException will be thrown? <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLineByLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(fileName)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> File.ReadAllLines(fileName)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line; } } <span class="hljs-comment"><span class="hljs-comment">// When the error will happen? string fileName = null; // Here? var query = ReadLineByLine(fileName).Select(x =&gt; $"\t{x}").Where(l =&gt; l.Length &gt; 10); // Or here? ProcessQuery(query);</span></span></code> </pre> <br>  Methods with a <b>yield return</b> in the body are special.  They are called <a href="https://msdn.microsoft.com/en-us/library/65zzykke%2528v%3Dvs.100%2529.aspx%3Ff%3D255%26MSPPError%3D-2147217396">iterator blocks</a> , and they are lazy.  This means that the execution of these methods occurs ‚Äúon demand‚Äù, and the first block of code in them will be executed only when the client of the method calls <b>MoveNext</b> on the resulting iterator.  In our case, this means that the error will occur only in the <b>ProcessQuery</b> method, because all LINQ operators are also lazy. <br><br>  Obviously, this behavior is undesirable because the <b>ProcessQuery</b> method <b>will</b> not have sufficient information about the context <b>ArgumentNullException</b> .  Therefore, it would be nice to throw an exception immediately - when the client calls <b>ReadLineByLine</b> , but not when the client processes the result. <br><br>  To solve this problem, we need to extract the validation logic into a separate method.  This is a good candidate for an anonymous function, but anonymous delegates and lambda expressions do not support iterator blocks (*): <br><br>  (*) Lambda expressions in VB.NET can have an iterator block. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLineByLine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(fileName)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ReadLineByLineImpl(); <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadLineByLineImpl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> File.ReadAllLines(fileName)) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line; } } }</code> </pre><br><br><h3>  Usage example 2: prerequisites in asynchronous methods </h3><br>  Asynchronous methods have a similar problem with exception handling: any exception created by a method marked with the <b>async keyword</b> appears in the returned task: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAllTextAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(fileName)) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(fileName)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> File.ReadAllTextAsync(fileName); Log(<span class="hljs-string"><span class="hljs-string">$"Read </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{result.Length}</span></span></span><span class="hljs-string"> lines from '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fileName}</span></span></span><span class="hljs-string">'"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fileName = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// No exceptions var task = GetAllTextAsync(fileName); // The following line will throw var lines = await task;</span></span></code> </pre><br>  You might think that when an error occurs there is not much difference.  But this is far from the truth.  A faulted task means that the method itself could not accomplish what it was supposed to do.  A faulty task means that the problem lies in the method itself or in one of the blocks on which the method depends. <br><br>  Verifying reliable preconditions is especially important when the resulting task is passed through the system.  In this case, it would be very difficult to understand when and what went wrong.  Local function can solve this problem: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAllTextAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Eager argument validation if (string.IsNullOrEmpty(fileName)) throw new ArgumentNullException(nameof(fileName)); return GetAllTextAsync(); async Task&lt;string&gt; GetAllTextAsync() { var result = await File.ReadAllTextAsync(fileName); Log($"Read {result.Length} lines from '{fileName}'"); return result; } }</span></span></code> </pre><br><br><h3>  Usage example 3: local function with iterator blocks </h3><br>  I was very annoyed that you cannot use iterators inside lambda expressions.  Here is a simple example: if you want to get all the fields in a type hierarchy (including private), you need to go through the inheritance hierarchy manually.  But the traversal logic is specific to a particular method and should be maximally ‚Äúlocalized‚Äù: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FieldInfo[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAllDeclaredFields</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TraverseBaseTypeAndSelf(type) .SelectMany(t =&gt; t.GetFields(flags)) .ToArray(); <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;Type&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TraverseBaseTypeAndSelf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> t; t = t.BaseType; } } }</code> </pre><br><br><h3>  Usage example 4: recursive anonymous method </h3><br>  Anonymous functions by default cannot refer to themselves.  To circumvent this restriction, you must declare a local variable with a delegate type, and then capture this local variable inside a lambda expression or an anonymous delegate: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Type&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseTypesAndSelf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { Action&lt;List&lt;Type&gt;, Type&gt; addBaseType = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; addBaseType = (lst, t) =&gt; { lst.Add(t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.BaseType != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { addBaseType(lst, t.BaseType); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Type&gt;(); addBaseType(result, type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  This approach is not very readable, and the following solution with a local function seems more natural: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;Type&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BaseTypesAndSelf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AddBaseType(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Type&gt;(), type); <span class="hljs-function"><span class="hljs-function">List&lt;Type&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBaseType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;Type&gt; lst, Type t</span></span></span><span class="hljs-function">)</span></span> { lst.Add(t); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t.BaseType != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { AddBaseType(lst, t.BaseType); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lst; } }</code> </pre><br><br><h3>  Usage example 5: when allocation issues matter </h3><br>  If you have ever worked on a performance-critical application, then you know that anonymous methods are not cheap: <br><ul><li>  Overhead for calling a delegate (very small, but they exist). </li><li>  <b>Allocation of 2 objects</b> in the managed heap, if the lambda expression captures a local variable or method argument (one for the closure instance and the other for the delegate itself). </li><li>  <b>Allocation of 1 object</b> in a managed heap, if the lambda expression captures the instance fields of the object. </li><li>  <b>The absence of allocations</b> will be only if the lambda expression does not capture anything or operates only with static members. </li></ul><br>  But the allocation model for local functions is significantly different. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { PrintTheArg(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintTheArg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(arg); } }</code> </pre><br>  If a local function captures a local variable or argument, then the C # compiler generates a special closure structure, creates its instance and passes it by reference to the generated static method: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> c__DisplayClass0_0 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Closure instantiation var c__DisplayClass0_ = new c__DisplayClass0_0() { arg = arg }; // Method invocation with a closure passed by ref Foo_g__PrintTheArg0_0(ref c__DisplayClass0_); } internal static void Foo_g__PrintTheArg0_0(ref c__DisplayClass0_0 ptr) { Console.WriteLine(ptr.arg); }</span></span></code> </pre><br>  (The compiler generates names with invalid characters, such as &lt;and&gt;. To improve readability, I changed the names and simplified the code a bit.) <br><br>  A local function can capture an instance state, local variables (***), or arguments.  No allocation will take place in the managed heap. <br>  (***) Local variables used in a local function must be defined (definitely assigned) at the place where the local function is declared. <br><br>  There are several cases when an object will be created on a managed heap: <br><br>  1. The local function is explicitly or implicitly converted to a delegate. <br>  <b>Delegate allocation will occur</b> if a local function captures the fields of an instance or static field, but does not capture local variables or arguments. <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Just a delegate allocation Action a = EmptyFunction; return; void EmptyFunction() { } }</span></span></code> </pre><br>  The closure and the delegate will be allocated if the local function captures local / arguments <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Baz</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Local function captures an enclosing variable. // The compiler will instantiate a closure and a delegate Action a = EmptyFunction; return; void EmptyFunction() { Console.WriteLine(arg); } }</span></span></code> </pre><br><br>  2. A local function captures a local variable / argument, and an anonymous function captures a variable / argument from the same scope. <br>  This case is more subtle. <br><br>  The C # compiler generates a separate closure type for each lexical scope (method arguments and top-level local variables are in the same top-level scope).  In the following case, the compiler will generate two types of closures: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DifferentScopes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local = <span class="hljs-number"><span class="hljs-number">42</span></span>; Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a = () =&gt; local; Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; b = () =&gt; local; } Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; c = () =&gt; arg; }</code> </pre><br>  Two different lambda expressions use the same type of closure if they capture variables from the same scope.  The generated methods for <b>a</b> and <b>b</b> lambda expressions are in the same type of closure: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">c__DisplayClass0_0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DifferentScopes_b__0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Body of the lambda 'a' return this.local; } internal int DifferentScopes_b__1() { // Body of the lambda 'a' return this.local; } } private sealed class c__DisplayClass0_1 { public int arg; internal int DifferentScopes_b__2() { // Body of the lambda 'c' return this.arg; } } public void DifferentScopes(int arg) { var closure1 = new c__DisplayClass0_0 { local = 42 }; var closure2 = new c__DisplayClass0_1() { arg = arg }; var a = new Func&lt;int&gt;(closure1.DifferentScopes_b__0); var b = new Func&lt;int&gt;(closure1.DifferentScopes_b__1); var c = new Func&lt;int&gt;(closure2.DifferentScopes_b__2); }</span></span></code> </pre><br>  In some cases, this behavior can cause some very serious memory problems.  Here is an example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; func; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitCapture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VeryExpensiveObject(); Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; a = () =&gt; o.GetHashCode(); Console.WriteLine(a()); Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; b = () =&gt; arg; func = b; }</code> </pre><br>  It seems that the variable <b>o</b> should be available for garbage collection immediately after calling delegate <b>a ()</b> .  But this is not the case, since two lambda expressions use the same type of closure: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">c__DisplayClass1_0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> VeryExpensiveObject o; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitCapture_b__0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.o.GetHashCode(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitCapture_b__1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; func; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitCapture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c__DisplayClass1_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> c__DisplayClass1_0() { arg = arg, o = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> VeryExpensiveObject() }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(c__DisplayClass1_.ImplicitCapture_b__0); Console.WriteLine(func()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(c__DisplayClass1_.ImplicitCapture_b__1); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.func = b; }</code> </pre><br>  This means that <b>the lifetime of the closure instance is tied to the lifetime of the func field</b> : the closure remains alive as long as the delegate is accessible from the application code.  This can extend the lifetime of <b>VeryExpensiveObject</b> , which is essentially a kind of memory leak. <br><br>  A similar problem occurs when a local function and a lambda expression capture variables from the same scope.  Even if they capture different variables, the type of closure will be common, causing the object to be allocated on the managed heap: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitAllocation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arg == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-comment"><span class="hljs-comment">// This code is effectively unreachable Func&lt;int&gt; a = () =&gt; arg; } int local = 42; return Local(); int Local() =&gt; local; }</span></span></code> </pre><br>  It will be converted by the compiler to: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">c__DisplayClass0_0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitAllocation_b__0</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.arg; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitAllocation_g__Local1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.local; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ImplicitAllocation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c__DisplayClass0_ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> c__DisplayClass0_0 { arg = arg }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c__DisplayClass0_.arg == <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.MaxValue) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(c__DisplayClass0_.ImplicitAllocation_b__0); } c__DisplayClass0_.local = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c__DisplayClass0_.ImplicitAllocation_g__Local1(); }</code> </pre><br>  As you can see, all local variables from the upper scope are now becoming part of the closure class, which creates a closure object, even when the local function and lambda expression captures different variables. <br><br><h3>  Local Functions 101 </h3><br>  The following is a list of the most important aspects of local functions in C #: <br><ul><li>  Local functions can define iterator blocks. </li><li>  Local functions are useful for immediate (eager) checking of preconditions in asynchronous methods and iterator blocks. </li><li>  Local functions can be recursive. </li><li>  Local functions do not allocate on the heap, unless they are converted to delegates. </li><li>  Local functions are slightly more efficient than anonymous functions due to the lack of overhead for delegate calls (****). </li><li>  Local functions can be declared after the return statement, which allows us to separate the main logic of the method from the auxiliary one. </li><li>  Local functions can "hide" a function with the same name declared in the outer scope. </li><li>  Local functions can be <b>asynchronous</b> and / or <b>unsafe</b> (unsafe);  other modifiers are not allowed. </li><li>  Local functions cannot have attributes. </li><li>  Local functions are not very friendly to the IDE: there is no ‚Äúrefactoring for allocating local methods‚Äù (R # 2017.3 already supports this feature. - note), and if the code with the local function does not compile, you will get a lot of underscores. in IDE. </li></ul><br>  (****) Here are the results of the microbenchmark: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">42</span></span>; [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DelegateInvocation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; fn = () =&gt; n == <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LocalFunctionInvocation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; n == <span class="hljs-number"><span class="hljs-number">42</span></span>; }</code> </pre><br><table><tbody><tr><td>  Method <br></td><td>  Mean <br></td><td>  Error <br></td><td>  Stddev <br></td></tr><tr><td>  DelegateInvocation <br></td><td>  1.5041 ns <br></td><td>  0.0060 ns <br></td><td>  0.0053 ns <br></td></tr><tr><td>  LocalFunctionInvocation <br></td><td>  0.9298 ns <br></td><td>  0.0063 ns <br></td><td>  0.0052 ns <br></td></tr></tbody></table><br>  To get these numbers, you need to manually "decompile" a local function into a regular function.  The reason for this is simple: a function as simple as ‚Äúfn‚Äù will be inline (runtime) and the test will not show the actual cost of the call.  To get these numbers, I used a static function marked with the <b>NoInlining</b> attribute (unfortunately, you cannot use attributes with local functions). </div><p>Source: <a href="https://habr.com/ru/post/346174/">https://habr.com/ru/post/346174/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346164/index.html">Specter and Meltdown</a></li>
<li><a href="../346166/index.html">Choosing a reliable database in a high load project</a></li>
<li><a href="../346168/index.html">Top 10 universities in Europe to study IT</a></li>
<li><a href="../346170/index.html">Divide users by role in FeathersJs</a></li>
<li><a href="../346172/index.html">Moving to Japan</a></li>
<li><a href="../346176/index.html">Defer: from Go to PHP</a></li>
<li><a href="../346178/index.html">640 KB is really enough for everyone</a></li>
<li><a href="../346180/index.html">Algorithm Paccos. Understandable article on consensus in a distributed system</a></li>
<li><a href="../346184/index.html">Bioinformatic Pipeline with Docker</a></li>
<li><a href="../346186/index.html">Practice writing tests. Yandex lecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>