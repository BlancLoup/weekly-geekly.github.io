<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monitoring and Configuring Linux Network Stack: Getting Data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at how packets are received on computers running the Linux kernel, as well as analyze the monitoring and configuration o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monitoring and Configuring Linux Network Stack: Getting Data</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/87c/247/7b4/87c2477b48ca450ebaf422832db71333.jpg"><br><br>  In this article, we will look at how packets are received on computers running the Linux kernel, as well as analyze the monitoring and configuration of each component of the network stack as packets move from the network to user space applications.  Here you will find a lot of source code, because without a deep understanding of the processes you will not be able to configure and monitor the Linux network stack. <br><br>  We also recommend that you read the <a href="http://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/">illustrated guide on the same topic</a> , there are explanatory diagrams and additional information. <br><a name="habracut"></a><br>  <b>Content</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. <a href="https://habr.com/ru/company/mailru/blog/314168/">General advice on monitoring and configuring the Linux network stack</a> <br>  2. <a href="https://habr.com/ru/company/mailru/blog/314168/">Overview of issues</a> <br>  3. <a href="https://habr.com/ru/company/mailru/blog/314168/">Detailed analysis</a> <br>  3.1.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Network device driver</a> <br>  3.2.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Softirq</a> <br>  3.3.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Linux Networking Subsystem</a> <br>  3.4.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Receive Packet Steering (RPS) mechanism</a> <br>  3.5.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Receive Flow Steering (RFS) mechanism</a> <br>  3.6.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Accelerated Receive Flow Steering (aRFS) hardware accelerated control</a> <br>  3.7.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Raising (moving up) the network stack using netif_receive_skb</a> <br>  3.8.  <a href="https://habr.com/ru/company/mailru/blog/314168/">netif_receive_skb</a> <br>  3.9.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Log level logging</a> <br>  3.10.  <a href="https://habr.com/ru/company/mailru/blog/314168/">Additional Information</a> <br>  4. <a href="https://habr.com/ru/company/mailru/blog/314168/">Conclusion</a> <br><br><a name="1"></a><h1>  1. General advice on monitoring and configuring the network stack in Linux </h1><br>  The network stack is complex and there is no universal solution for all occasions.  If productivity and correctness are critical for you or your business when working with a network, then you will have to invest a lot of time, effort and money in understanding how the different parts of the system interact with each other. <br><br>  Ideally, you should measure packet loss at each level of the network stack.  In this case, you need to choose which components need to be configured.  It is at this moment, as it seems to me, many surrender.  This assumption is based on the fact that the sysctl settings or the / proc values ‚Äã‚Äãcan be used repeatedly and en masse.  In some cases, the system is likely to be so permeated with interconnections and filled with nuances that if you wish to implement useful monitoring or perform tuning, you will have to deal with the functioning of the system at a low level.  Otherwise, just use the default settings.  This may be sufficient until further optimization is needed (and attachments to keep track of these settings). <br><br>  Many of the example settings in this article are used solely as illustrations, and are not a recommendation for or against the use as a specific configuration or default settings.  So before applying each setting, first think about what you need to monitor in order to identify a significant change. <br><br>  It is dangerous to apply network settings by connecting to the machine remotely.  You can easily block your access or even drop the network management system altogether.  Do not apply the settings on the working machines, first run them in, if possible, on the new ones, and then apply them in production. <br><br><a name="2"></a><h1>  2. Overview of issues </h1><br>  You may want to have on hand a copy of the device‚Äôs data sheet.  This article will discuss the Intel I350 controller, controlled by the igb driver.  Download the specification <a href="http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf">from here</a> . <br>  The high-level path that the packet passes from arriving to the receiving socket buffer looks like this: <br><br><ol><li>  The driver is loaded and initialized. </li><li>  The packet comes from the network to the network card. </li><li>  The packet is copied (via DMA) to the kernel's circular memory buffer. </li><li>  A hardware interrupt is generated so that the system knows about the appearance of the packet in memory. </li><li>  The driver calls <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/napi">NAPI</a> to start a poll loop, if it has not already started. </li><li>  On each CPU of the system, ksoftirqd processes are running.  They are registered at boot time.  These processes pull packets out of the ring buffer by calling the NAPI poll function registered by the device driver during initialization. </li><li>  Clears (unmapped) those memory areas in the ring buffer to which network data was written. </li><li>  Data sent directly to memory (DMA) is transmitted for further processing to the network layer in the form of 'skb'. </li><li>  If packet management is enabled, or if there are multiple receive queues in the network card, the incoming network data frames are distributed across multiple system CPUs. </li><li>  Network data frames are transferred from the queue to the protocol layers. </li><li>  Protocol levels process data. </li><li>  Data is added to receive buffers attached to sockets by protocol levels. </li></ol><br>  Next we look at the whole stream in detail.  As a protocol layer, IP and UDP levels will be considered.  Most of the information is true for other protocol levels. <br><br><a name="3"></a><h1>  3. Detailed analysis </h1><br>  We will consider the Linux kernel version 3.13.0.  Also throughout the article uses code examples and links to GitHub. <br><br>  It is very important to understand exactly how packets are received by the kernel  We will have to carefully read and understand the work of the network driver, so that later it would be easier to understand the description of the work of the network stack. <br><br>  Igb will be considered as a network driver.  It is used in a fairly common server network card, Intel I350.  So let's start by analyzing the work of this driver. <br><br><a name="4"></a><h2>  3.1.  Network device driver </h2><br><h4>  Initialization </h4><br>  The driver registers an initialization function that is called by the kernel when the driver loads.  Registration is done using the module_init macro. <br>  You can find the igb initialization function (igb_init_module) and register it with module_init in <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> .  It's pretty simple: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * igb_init_module ‚Äì  (routine)   * * igb_init_module ‚Äî   ,    . *       PCI. **/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_init_module</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; pr_info(<span class="hljs-string"><span class="hljs-string">"%s - version %s\n"</span></span>, igb_driver_string, igb_driver_version); pr_info(<span class="hljs-string"><span class="hljs-string">"%s\n"</span></span>, igb_copyright); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> ret = pci_register_driver(&amp;igb_driver); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } module_init(igb_init_module);</code> </pre> <br>  As we will see, the main part of the initialization work of the device occurs when pci_register_driver is called. <br><br><h4>  PCI initialization </h4><br>  The Intel I350 network card is a device with a <a href="https://ru.wikipedia.org/wiki/PCI_Express">PCI express</a> interface. <br><br>  PCI devices identify themselves using a series of registers in <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D1%2584%25D0%25B8%25D0%25B3%25D1%2583%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25BE_PCI">the PCI configuration space</a> . <br><br>  When the device driver is compiled, the macro MODULE_DEVICE_TABLE (from <a href="">include / module.h</a> ) is used to export the table of identifiers of PCI devices that the driver can control.  Below we will see that the table is also registered as part of the structure. <br><br>  This table is used by the kernel to determine which driver to load to control the device.  Thus, the operating system understands which device is connected and which driver allows you to interact with it. <br><br>  You can find the table and identifiers of the PCI devices for the igb driver, respectively, here <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> and here <a href="">drivers / net / ethernet / intel / igb / e1000_hw.h</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DEFINE_PCI_DEVICE_TABLE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(igb_pci_tbl)</span></span></span><span class="hljs-function"> </span></span>= { { PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_1GBPS) }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_SGMII) }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I211_COPPER), board_82575 }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER), board_82575 }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_FIBER), board_82575 }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES), board_82575 }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SGMII), board_82575 }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER_FLASHLESS), board_82575 }, { PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES_FLASHLESS), board_82575 }, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }; MODULE_DEVICE_TABLE(pci, igb_pci_tbl);</code> </pre> <br>  As we saw above, pci_register_driver is called by the initialization driver function. <br><br>  This function registers the structure of pointers.  Most of them are function pointers, but the table of identifiers of a PC device is also registered.  The kernel uses driver-registered functions to launch a PCI device. <br><br>  From <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pci_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igb_driver</span></span></span><span class="hljs-class"> = {</span></span> .name = igb_driver_name, .id_table = igb_pci_tbl, .probe = igb_probe, .remove = igb_remove, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> };</code> </pre> <br><h4>  PCI Probe </h4><br>  When a device is identified by its PCI ID, the kernel can select the appropriate driver.  Each driver registers the probe-function in the PCI kernel system.  The kernel calls this function for those devices for which drivers have not yet claimed.  When one of the drivers claims the device, the others are no longer polled.  Most drivers contain a lot of code that runs to prepare the device for use.  Procedures performed vary greatly depending on the driver. <br><br>  Here are some typical procedures: <br><br><ol><li>  Turn on the PCI device. </li><li>  Querying areas of memory and <a href="http://wiki.osdev.org/I/O_Ports">I / O ports</a> . </li><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258F%25D0%25BC%25D0%25BE%25D0%25B9_%25D0%25B4%25D0%25BE%25D1%2581%25D1%2582%25D1%2583%25D0%25BF_%25D0%25BA_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">DMA</a> Mask Setup </li><li>  The driver-supported ethtool functions are registered (to be described below). </li><li>  Watchdog timers are running (for example, the e1000e has a timer that checks if the hardware is stuck). </li><li>  Other procedures specific to this device.  For example, bypassing or enabling hardware frills, and the like. </li><li>  Creating, initializing, and registering a struct net_device_ops structure.  It contains pointers to various functions needed to open the device, send data to the network, configure the MAC address, and so on. </li><li>  Creating, initializing, and registering a high-level struct net_device structure representing a network device. </li></ol><br>  Let's go over some of these procedures for the igb driver and the <a href="">igb_probe</a> function. <br><br><h4>  A quick look at PCI initialization </h4><br>  The code below from the igb_probe function performs the basic PCI configuration.  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs">err = pci_enable_device_mem(pdev); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = dma_set_mask_and_coherent(&amp;pdev-&gt;dev, DMA_BIT_MASK(<span class="hljs-number"><span class="hljs-number">64</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> err = pci_request_selected_regions(pdev, pci_select_bars(pdev, IORESOURCE_MEM), igb_driver_name); pci_enable_pcie_error_reporting(pdev); pci_set_master(pdev); pci_save_state(pdev);</code> </pre> <br>  Initially, the device is initialized using pci_enable_device_mem.  If the device is in sleep mode, it wakes up, memory sources are activated, and so on. <br><br>  Then the DMA mask is configured.  Our device can read and write to 64-bit memory addresses, so dma_set_mask_and_coherent is called using DMA_BIT_MASK (64). <br><br>  By calling pci_request_selected_regions, memory areas are reserved.  The <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/PCI/pcieaer-howto.txt">PCI Express Advanced Error Reporting service starts</a> if its driver is loaded.  Using the pci_set_master call activates the DMA, and the PCI configuration space is saved using the pci_save_state call. <br><br>  Fuh. <br><br><h4>  Additional information about the PCI driver for Linux </h4><br>  A full review of the work of a PCI device is beyond the scope of this article, but you can read these materials: <br><br><ul><li>  <a href="http://free-electrons.com/doc/pci-drivers.pdf">free-electrons.com/doc/pci-drivers.pdf</a> </li><li>  <a href="http://wiki.osdev.org/PCI">wiki.osdev.org/PCI</a> </li><li>  <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/PCI/pci.txt">github.com/torvalds/linux/blob/v3.13/Documentation/PCI/pci.txt</a> </li></ul><br><h4>  Network Device Initialization </h4><br>  The igb_probe function does the important work of initializing the network device.  In addition to the procedures specific to PCI, it also performs more general operations for networking and operating a network device: <br><br><ol><li>  Registers a struct net_device_ops. </li><li>  Logs ethtool operations. </li><li>  Receives the default MAC address from the network card. </li><li>  Set the net_device property flags. </li><li>  And does much more. </li></ol><br>  We will need all this later, so let's take a quick run. <br><br><h4>  struct net_device_ops </h4><br>  struct net_device_ops contains function pointers to many important operations required by the network subsystem to control the device.  We will mention this structure more than once in the article. <br><br>  The net_device_ops structure is attached to a struct net_device in igb_probe.  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct pci_device_id *ent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> netdev-&gt;netdev_ops = &amp;igb_netdev_ops;</code> </pre> <br>  In the same file, function pointers are stored that are stored in the net_device_ops structure.  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_device_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igb_netdev_ops</span></span></span><span class="hljs-class"> = {</span></span> .ndo_open = igb_open, .ndo_stop = igb_close, .ndo_start_xmit = igb_xmit_frame, .ndo_get_stats64 = igb_get_stats64, .ndo_set_rx_mode = igb_set_rx_mode, .ndo_set_mac_address = igb_set_mac, .ndo_change_mtu = igb_change_mtu, .ndo_do_ioctl = igb_ioctl, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span></code> </pre> <br>  As you can see, the struct has several interesting fields, for example, ndo_open, ndo_stop, ndo_start_xmit and ndo_get_stats64, which contain the addresses of the functions implemented by the igb driver.  Some of them will be discussed later. <br><br><h4>  Register ethtool </h4><br>  <a href="https://www.kernel.org/pub/software/network/ethtool/">ethtool</a> is a command-line program.  With it, you can get and configure various drivers and hardware options.  Under Ubuntu, this program can be installed like this: apt-get install ethtool. <br><br>  Typically, ethtool is used to collect detailed statistics from network devices.  Other uses will be described below. <br><br>  The program communicates with the drivers using the <a href="http://man7.org/linux/man-pages/man2/ioctl.2.html">ioctl</a> system call.  The device driver registers a series of functions performed for ethtool operations, and the kernel provides glue. <br><br>  When ethtool calls ioctl, the kernel finds the ethtool structure registered by the appropriate driver and performs the registered functions.  Implementing the ethtool driver function can do anything ‚Äî from changing a simple software flag in the driver to controlling how the physical NIC equipment works by writing registers to the device. <br><br>  The igb driver using igb_set_ethtool_ops calls logs ethtool operations on igb_probe: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct pci_dev *pdev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct pci_device_id *ent)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> igb_set_ethtool_ops(netdev);</code> </pre> <br>  The entire ethtool code of the igb driver along with the igb_set_ethtool_ops function can be found in the file <a href="">drivers / net / ethernet / intel / igb / igb_ethtool.c</a> . <br><br>  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_ethtool.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_set_ethtool_ops</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct net_device *netdev)</span></span></span><span class="hljs-function"> </span></span>{ SET_ETHTOOL_OPS(netdev, &amp;igb_ethtool_ops); }</code> </pre> <br>  In addition, you can find the igb_ethtool_ops structure with the ethtool functions supported in the appropriate fields supported by the igb driver. <br><br>  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_ethtool.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ethtool_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igb_ethtool_ops</span></span></span><span class="hljs-class"> = {</span></span> .get_settings = igb_get_settings, .set_settings = igb_set_settings, .get_drvinfo = igb_get_drvinfo, .get_regs_len = igb_get_regs_len, .get_regs = igb_get_regs, <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span></code> </pre> <br>  Each driver, at its discretion, decides which ethtool functions are relevant and which need to be implemented.  Unfortunately, not all drivers implement all ethtool functions. <br><br>  The function get_ethtool_stats is quite interesting, which (if it is implemented) creates detailed statistical counters that are tracked either by the software driver or by the device itself. <br><br>  In the dedicated monitoring part we will look at how to use ethtool to get these statistics. <br><br><h4>  IRQ </h4><br>  When a data frame is stored in memory using DMA, how does the network card inform the system that the data is ready for processing? <br><br>  Typically, the card generates an <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">interrupt</a> , indicating the arrival of data.  There are three common types of interrupts: MSI-X, MSI and Legacy IRQ.  Soon we will consider them.  The interrupt generated when writing data to memory is quite simple, but if a lot of frames arrive, a large amount of IRQ is generated.  The more interrupts, the less CPU time available for servicing higher-level tasks, such as user processes. <br><br>  <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/napi">New Api (NAPI)</a> was created as a mechanism to reduce the number of interrupts generated by network devices as packets arrive.  But still, NAPI cannot completely save us from interruptions.  We will find out later why. <br><br><h4>  NAPI </h4><br>  For a number of important features, <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/napi">NAPI</a> is different from the legacy data collection method.  It allows the device driver to register the poll function called by the NAPI subsystem to collect a data frame. <br><br>  The algorithm for using NAPI network device drivers is as follows: <br><br><ol><li>  The driver includes NAPI, but initially it is in an inactive state. </li><li>  A packet arrives and the network card directly sends it to memory. </li><li>  The network card generates the IRQ by running the interrupt handler in the driver. </li><li>  The driver wakes up the NAPI subsystem using SoftIRQ (for more details, see below).  That begins to collect packets, causing the poll function registered by the driver in a separate thread of execution. </li><li>  The driver should disable the subsequent generation of interrupts by the network card.  This is necessary in order to allow the NAPI subsystem to process packets without interference from the device. </li><li>  When all work is done, the NAPI subsystem turns off and the device generates interrupts again. </li><li>  The cycle is repeated starting from point 2. </li></ol><br>  This method of collecting data frames has reduced the load compared to the legacy method, since many frames can be simultaneously accepted without the need to simultaneously generate an IRQ for each of them. <br><br>  The device driver implements the poll function and registers it with NAPI by calling netif_napi_add.  The driver also sets the weight.  Most drivers hardcode value 64. Why him, we will see further. <br><br>  Usually, drivers register their NAPI poll functions during driver initialization. <br><br><h4>  NAPI initialization in igb driver </h4><br>  The igb driver does this with a long call chain: <br><br><ol><li>  igb_probe calls igb_sw_init. </li><li>  igb_sw_init calls igb_init_interrupt_scheme. </li><li>  igb_init_interrupt_scheme calls igb_alloc_q_vectors. </li><li>  igb_alloc_q_vectors calls igb_alloc_q_vector. </li><li>  igb_alloc_q_vector calls netif_napi_add. </li></ol><br>  The result is a series of high-level operations: <br><br><ol><li>  If <a href="https://ru.wikipedia.org/wiki/Message_Signaled_Interrupts">MSI-X is</a> supported, then it is enabled by calling pci_enable_msix. </li><li>  Calculated and initialized various settings;  for example, the number of transmit and receive queues that the device and driver will use to send and receive packets. </li><li>  igb_alloc_q_vector is called once for each transmit and receive queue created. </li><li>  Each time igb_alloc_q_vector is called, netif_napi_add is also called to register the poll function for a specific queue.  When the poll function is called to collect packets, it will be given an instance of struct napi_struct. </li></ol><br>  Let's take a look at igb_alloc_q_vector to understand how a callback poll and its private data are registered. <br><br>  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_alloc_q_vector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct igb_adapter *adapter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> txr_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> txr_idx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rxr_count, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rxr_idx)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    q_vector   (rings) */</span></span> q_vector = kzalloc(size, GFP_KERNEL); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!q_vector) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; <span class="hljs-comment"><span class="hljs-comment">/*  NAPI */</span></span> netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span></code> </pre> <br>  The above is the location code in memory of the receive queue and registration of the igb_poll function using the NAPI subsystem.  We get the reference to the struct napi_struct associated with this newly created receive queue (&amp; q_vector-&gt; napi).  When it comes time to collect packets from the queue and the NAPI subsystem will be called igb_poll, this link will be passed to it. <br><br>  We will understand the importance of the described algorithm when we study the data flow from the driver to the network stack. <br><br><h4>  Download (bring up) network device </h4><br>  Remember the net_device_ops structure that registered the set of functions for booting a network device, sending packets, setting up a MAC address, and so on? <br><br>  When the network device is loaded (for example, using ifconfig eth0 up), the function that is attached to the ndo_open field of the net_device_ops structure is called. <br><br>  The ndo_open function usually does the following: <br><br><ol><li>  Allocates memory for receive and transmit queues. </li><li>  Includes NAPI. </li><li>  Register an interrupt handler. </li><li>  Enables hardware interrupts. </li><li>  And much more. </li></ol><br>  In the case of the igb driver, igb_open calls the function attached to the ndo_open field of the net_device_ops structure. <br><br><h4>  Preparing to receive data from the network </h4><br>  Most modern network cards use DMA to write data directly to memory, from which the operating system can extract it for further processing.  The structure most often used for this is similar to a queue created on the basis of a ring buffer. <br><br>  First, the device driver must, together with the OS, reserve in memory the area that will be used by the network card.  Next, the card is informed about the allocation of memory, where later incoming data will be recorded, which can be taken and processed using the network subsystem. <br><br>  It looks simple, but what if the packet rate is so high that one CPU does not have time to process them?  The data structure is based on a fixed-size memory area, so packets will be dropped. <br><br>  In this case, <a href="https://en.wikipedia.org/wiki/Network_interface_controller">Receive Side Scaling (RSS)</a> , a multi-queue system, can help. <br><br>  Some devices can simultaneously write incoming packets to several different areas of memory.  Each area serves a separate queue.  This allows the OS to use multiple CPUs for parallel processing of incoming data at the hardware level.  But not all network cards can do this. <br><br>  Intel I350 - is able.  We see evidence of this skill in the igb driver.  One of the first things that it does after loading is the function call <a href="">igb_setup_all_rx_resources</a> .  This function calls once for each reception queue another function - igb_setup_rx_resources, which organizes the DMA memory into which the network card will write incoming data. <br><br>  If you are interested in details, read <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/DMA-API-HOWTO.txt">github.com/torvalds/linux/blob/v3.13/Documentation/DMA-API-HOWTO.txt</a> . <br><br>  Using ethtool, you can customize the number and size of receive queues.  Changing these parameters can significantly affect the ratio of processed and dropped frames. <br><br>  To determine which queue to send data to, the network card uses a hash function in the header fields (source, destination, port, and so on). <br><br>  Some network cards allow you to adjust the weight of the receive queues, so that you can send more traffic to specific queues. <br>  Less common is the ability to customize the hash function itself.  If you can customize it, you can direct a specific flow to a specific queue, or even drop packets at the hardware level. <br>  Below we will look at how the hash function is configured. <br><br><h4>  Enable NAPI </h4><br>  When the network device is loaded, the driver usually includes NAPI.  We have already seen how drivers using NAPI register poll functions.  Normally, NAPI does not turn on until the device is booted. <br><br>  Turn it on is pretty simple.  A call to napi_enable signals the struct napi_struct that NAPI is enabled.  As noted above, after enabling NAPI is in an inactive state. <br><br>  In the case of the igb driver, NAPI is enabled for each q_vector initialized after the driver is loaded, or when the counter or queue size is changed using ethtool. <br><br>  Taken from <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; adapter-&gt;num_q_vectors; i++) napi_enable(&amp;(adapter-&gt;q_vector[i]-&gt;napi));</code> </pre> <br><h4>  Register Interrupt Handler </h4><br>  After NAPI is enabled, you must register an interrupt handler.  A device can generate interrupts in various ways: MSI-X, MSI, and Legacy interrupts.  Therefore, the code may be different, depending on the supported methods. <br><br>  The driver must determine which method is supported by this device and register the corresponding handler function that is executed when an interrupt is received. <br><br>  Some drivers, including igb, try to register a handler for each method, in case of failure, go to the next untested one. <br><br>  It is preferable to use MSI-X interrupts, especially for network cards that support multiple receive queues.  The reason is that each queue is assigned its own hardware interrupt, which can be processed by a specific CPU (using irqbalance or modifying / proc / irq / IRQ_NUMBER / smp_affinity).  As we will soon see, the interrupt and the packet are processed by the same CPU.  Thus, incoming packets will be processed by different CPUs across the entire network stack, starting at the hardware interrupt level. <br><br>  If MSI-X is not available, then the driver uses MSI (if supported), which still has advantages over legacy interrupts.  Read more about this in the English <a href="https://en.wikipedia.org/wiki/Message_Signaled_Interrupts">Wikipedia</a> . <br><br>  In the igb driver, MSI-X, MSI, and Legacy interrupt handlers are functions of igb_msix_ring, igb_intr_msi, igb_intr, respectively. <br><br>  The driver code that tries each method can be found in <a href="">drivers / net / ethernet / intel / igb / igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_request_irq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct igb_adapter *adapter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">netdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">adapter</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">netdev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pci_dev</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">adapter</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pdev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> err = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adapter-&gt;msix_entries) { err = igb_request_msix(adapter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> request_done; <span class="hljs-comment"><span class="hljs-comment">/*   MSI */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (adapter-&gt;flags &amp; IGB_FLAG_HAS_MSI) { err = request_irq(pdev-&gt;irq, igb_intr_msi, <span class="hljs-number"><span class="hljs-number">0</span></span>, netdev-&gt;name, adapter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!err) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> request_done; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } err = request_irq(pdev-&gt;irq, igb_intr, IRQF_SHARED, netdev-&gt;name, adapter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) dev_err(&amp;pdev-&gt;dev, <span class="hljs-string"><span class="hljs-string">"Error %d getting interrupt\n"</span></span>, err); request_done: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err; }</code> </pre> <br>  As you can see, the driver first tries to use the igb_request_msix handler for MSI-X interrupts; if it fails, it goes to MSI.  To register the MSI handler igb_intr_msi, request_irq is used.  If this does not work either, the driver proceeds to legacy interrupts.  To register igb_intr, request_irq is used again. <br><br>    igb  ,        ,         . <br><br><h4>   </h4><br>       .        .      ,   igb    __igb_open,      igb_irq_enable. <br><br>         : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_irq_enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct igb_adapter *adapter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> wr32(E1000_IMS, IMS_ENABLE_MASK | E1000_IMS_DRSTA); wr32(E1000_IAM, IMS_ENABLE_MASK | E1000_IMS_DRSTA); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>    .      , ,  ,     ,     .          . <br><br>           . <br><br><h4>    </h4><br>     ,     .    . <br><br><h4>  ethtool -S </h4><br>  ethtool  Ubuntu  : sudo apt-get install ethtool. <br>    ,   -S    ,    . <br><br>    (,  )   `ethtool -S`. <br><br><pre> <code class="bash hljs">$ sudo ethtool -S eth0 NIC statistics: rx_packets: 597028087 tx_packets: 5924278060 rx_bytes: 112643393747 tx_bytes: 990080156714 rx_broadcast: 96 tx_broadcast: 116 rx_multicast: 20294528 ....</code> </pre> <br>     .   ,       .  ,    <b></b>      ,   . <br><br>  ,     ‚Äúdrop‚Äù, ‚Äúbuffer‚Äù, ‚Äúmiss‚Äù   .      .   ,       (,    ),         .     ,       ,    .  ,  ethtool,   . <br><br><h4>  sysfs </h4><br> sysfs    ,       ,     . <br><br>        , , eth0,  cat  . <br><br>         sysfs: <br><br><pre> <code class="bash hljs">$ cat /sys/class/net/eth0/statistics/rx_dropped 2</code> </pre> <br>      : collisions, rx_dropped, rx_errors, rx_missed_errors   . <br><br>  ,   ,      ,         .   ,           ,   ‚Äî  . <br><br>      ,     ,   ,       . <br><br><h4>  /proc/net/dev </h4><br>     /proc/net/dev,        . <br><br>  /proc/net/dev,      : <br><br><pre> <code class="bash hljs">$ cat /proc/net/dev Inter-| Receive | Transmit face |bytes packets errs drop fifo frame compressed multicast|bytes packets errs drop fifo colls carrier compressed eth0: 110346752214 597737500 0 2 0 0 0 20963860 990024805984 6066582604 0 0 0 0 0 0 lo: 428349463836 1579868535 0 0 0 0 0 0 428349463836 1579868535 0 0 0 0 0 0</code> </pre> <br>      ,         sysfs.       . <br><br>     ,      ,     .        , ,      ,      ,   FIFO. <br><br><h4>    </h4><br><h4>      </h4><br>            RSS ( ),     ethtool      ( , RX-channels). <br><br>      : <br><br><pre> <code class="bash hljs">$ sudo ethtool -l eth0 Channel parameters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth0: Pre-set maximums: RX: 0 TX: 0 Other: 0 Combined: 8 Current hardware settings: RX: 0 TX: 0 Other: 0 Combined: 4</code> </pre> <br>       (   )   . <br><br> <b>:</b>       . <br><br> , ,       : <br><br><pre> <code class="bash hljs">$ sudo ethtool -l eth0 Channel parameters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth0: Cannot get device channel parameters : Operation not supported</code> </pre> <br>  ,      ethtool get_channels.             ,    RSS,       . <br><br><h4>     </h4><br>  ,         ,        sudo ethtool -L. <br><br> <b>:</b>         , ‚Äî     ‚Äî      . <br><br>   ethtool -L  8  : <br><br><pre> <code class="bash hljs">$ sudo ethtool -L eth0 combined 8</code> </pre> <br>             ,     8  : <br><br><pre> <code class="bash hljs">$ sudo ethtool -L eth0 rx 8</code> </pre> <br> <b>:</b>           ,       .        . <br><br><h4>     </h4><br>           .     , ,  , ethtool    .            . ,        ,             . <br><br>         ethtool ‚Äìg: <br><br><pre> <code class="bash hljs">$ sudo ethtool -g eth0 Ring parameters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth0: Pre-set maximums: RX: 4096 RX Mini: 0 RX Jumbo: 0 TX: 4096 Current hardware settings: RX: 512 RX Mini: 0 RX Jumbo: 0 TX: 512</code> </pre> <br>   ,    4096    ,      512. <br><br>      4096: <br><br><pre> <code class="bash hljs">$ sudo ethtool -G eth0 rx 4096</code> </pre> <br> <b>:</b>           ,       .        . <br><br><h4>      </h4><br>               . <br><br>   , : <br><br><ul><li>       (flow indirection). </li><li>     get_rxfh_indir_size  get_rxfh_indir  ethtool. </li><li>       ethtool,     -x  -X,        (indirection table). </li></ul><br>      : <br><br><pre> <code class="bash hljs">$ sudo ethtool -x eth0 RX flow <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> indirection table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth3 with 2 RX ring(s): 0: 0 1 0 1 0 1 0 1 8: 0 1 0 1 0 1 0 1 16: 0 1 0 1 0 1 0 1 24: 0 1 0 1 0 1 0 1</code> </pre> <br>          ‚Äî 0  1.    2     0,     3 ‚Äî   1. <br><br> :        : <br><br><pre> <code class="bash hljs">$ sudo ethtool -X eth0 equal 2</code> </pre> <br>      ,   ,     ( ,  CPU),           ethtool ‚ÄìX: <br><br><pre> <code class="bash hljs">$ sudo ethtool -X eth0 weight 6 2</code> </pre> <br>   0   6,   1 ‚Äî  2.  ,       0. <br><br>    ,       ,     . <br><br><h4>        </h4><br>   ethtool   ,      ,   RSS. <br><br> C  ethtool -n ,        UPD: <br><br><pre> <code class="cpp hljs">$ sudo ethtool -n eth0 rx-flow-hash udp4 UDP over IPV4 flows use these fields <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> computing Hash flow key: IP SA IP DA</code> </pre> <br>    eth0,    UDP-   IPv4   .       : <br><br><pre> <code class="bash hljs">$ sudo ethtool -N eth0 rx-flow-hash udp4 sdfn</code> </pre> <br>  sdfn  .         ethtool man. <br><br>     ,   ntuple            . <br><br><h4>  ntuple     </h4><br>      ¬´ ntuple¬ª (ntuple filtering).    ( ethtool)  ,              . ,  ,  TCP-,    ,    1. <br><br>    Intel     <a href="http://www.intel.com/content/www/us/en/ethernet-products/ethernet-flow-director-video.html">Intel Ethernet Flow Director</a> .      . <br><br>    ,  ntuple ‚Äî     , Accelerated Receive Flow Steering (aRFS).     ntuple,      . aRFS   . <br><br>     ,         (data locality)      (hit rates)   CPU    . ,    -,    80: <br><br><ul><li>    CPU 2. </li><li>  IRQ        CPU. </li><li> TCP-   80 ¬´¬ª   ntuple    CPU 2. </li><li>      80   CPU,          . </li><li>       ,          . </li></ul><br>   ,  ntuple     ethtool,      ,       .    : <br><br><pre> <code class="bash hljs">$ sudo ethtool -k eth0 Offload parameters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth0: ... ntuple-filters: off receive-hashing: on</code> </pre> <br>  , ntuple-filters   off. <br><br>  ntuple-: <br><br><pre> <code class="bash hljs">$ sudo ethtool -K eth0 ntuple on</code> </pre> <br>     ,   ,    : <br><br><pre> <code class="bash hljs">$ sudo ethtool -u eth0 40 RX rings available Total 0 rules</code> </pre> <br>      .          ethtool.  ,   TCP-,    80,    2: <br><br><pre> <code class="bash hljs">$ sudo ethtool -U eth0 flow-type tcp4 dst-port 80 action 2</code> </pre> <br>  ntuple           .          - IP-.       man ethtool. <br><br>       ntuple-       ethtool -S [device name]. ,    Intel fdir_match  fdir_miss       .            . <br><br><a name="5"></a><h2>  3.2. SoftIRQ </h2><br>       ,       SoftIRQ   Linux. <br><br><h4>   SoftIRQ? </h4><br>        ,  .   ,               .    ,     .          ,            . <br><br>  ,            .   SoftIRQ. <br><br>  SoftIRQ        (   CPU),    -,    SoftIRQ-.   -     ksoftirqd/0    ,      SoftIRQ,   CPU 0. <br><br>   (,    )    SoftIRQ    open_softirq.   ,         SoftIRQ-.       ,   SoftIRQ. <br><br><h4> ksoftirqd </h4><br>  SoftIRQ       ,   ksoftirqd        . <br><br>     <a href="">kernel/softirq.c</a> , ,    ksoftirqd: <br><br><pre> <code class="bash hljs">static struct smp_hotplug_thread softirq_threads = { .store = &amp;ksoftirqd, .thread_should_run = ksoftirqd_should_run, .thread_fn = run_ksoftirqd, .thread_comm = <span class="hljs-string"><span class="hljs-string">"ksoftirqd/%u"</span></span>, }; static __init int spawn_ksoftirqd(void) { register_cpu_notifier(&amp;cpu_nfb); BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads)); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> 0; } early_initcall(spawn_ksoftirqd);</code> </pre> <br>     struct smp_hotplug_thread,    : ksoftirqd_should_run  run_ksoftirqd. <br><br>    <a href="">kernel/smpboot.c</a>   -,    (event loop). <br><br>   kernel/smpboot.c   ksoftirqd_should_run,  ,    SoftIRQ.  ,   run_ksoftirqd,     ,    __do_softirq. <br><br><h4> __do_softirq </h4><br>  __do_softirq    : <br><br><ul><li>   SoftIRQ. </li><li>     SoftIRQ. </li><li>    SoftIRQ. </li><li>     SoftIRQ (      open_softirq). </li></ul><br>         CPU   softirq  si,       CPU,     . <br><br><h4>  Monitoring </h4><br><h4> /proc/softirqs </h4><br>  softirq   ,     /proc/softirqs.       ,     SoftIRQ   . <br><br>  /proc/softirqs,    SoftIRQ: <br><br><pre> <code class="bash hljs">$ cat /proc/softirqs CPU0 CPU1 CPU2 CPU3 HI: 0 0 0 0 TIMER: 2831512516 1337085411 1103326083 1423923272 NET_TX: 15774435 779806 733217 749512 NET_RX: 1671622615 1257853535 2088429526 2674732223 BLOCK: 1800253852 1466177 1791366 634534 BLOCK_IOPOLL: 0 0 0 0 TASKLET: 25 0 0 0 SCHED: 2642378225 1711756029 629040543 682215771 HRTIMER: 2547911 2046898 1558136 1521176 RCU: 2056528783 4231862865 3545088730 844379888</code> </pre> <br>     ,            (NET_RX).  ,   CPU    ,   .   ,         Receive Packet Steering / Receive Flow Steering.  ,        :           NET_RX,     .   SoftIRQ NET_RX       ,    . <br><br>  ,  ,      ,       /proc/softirqs. <br><br>       ,         . <br><br><a name="6"></a><h2>  3.3.     Linux </h2><br>        SoftIRQ,      .          . <br><br><h4>     </h4><br>    (netdev)    net_dev_init.      . <br><br><h4>   struct softnet_data </h4><br> net_dev_init    struct softnet_data   CPU  .            : <br><br><ul><li>   NAPI,     CPU. </li><li> Backlog   . </li><li>   (processing weight). </li><li>   <a href="https://en.wikipedia.org/wiki/Large_receive_offload">receive offload</a> . </li><li>     ( <a href="https://lwn.net/Articles/362339/">Receive packet steering</a> ). </li><li>  And much more. </li></ul><br><h4>   SoftIRQ </h4><br> net_dev_init   SoftIRQ   ,          .   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __<span class="hljs-function"><span class="hljs-function">init </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">net_dev_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> open_softirq(NET_TX_SOFTIRQ, net_tx_action); open_softirq(NET_RX_SOFTIRQ, net_rx_action); <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  ,     ¬´¬ª ( )  net_rx_action,   SoftIRQ NET_RX_SOFTIRQ. <br><br><h4>   </h4><br> -   ! <br><br>  ,       ,        DMA.        (,    MSI-X,     ,     ). <br><br><h4>   </h4><br>     ,              .   ,           . <br><br>        MSI-X.    ,      . <br><br>   <a href="">drivers/net/ethernet/intel/igb/igb_main.c</a> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> irqreturn_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_msix_ring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igb_q_vector</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">q_vector</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ITR,    . */</span></span> igb_write_itr(q_vector); napi_schedule(&amp;q_vector-&gt;napi); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IRQ_HANDLED; }</code> </pre> <br>    ,         . <br><br><ol><li>  igb_write_itr     .        .       ‚ÄúInterrupt Throttling‚Äù (   ¬´ ¬ª, Interrupt Coalescing),     CPU.   ,  ethtool      IRQ. </li><li>  napi_schedule,    NAPI,     .  ,      SoftIRQ,    .     ,     . </li></ol><br>    ,    .    ,       . <br><br><h4> NAPI  napi_schedule </h4><br>  ,    napi_schedule    . <br><br>   , NAPI            ,      .  ,   poll  (bootstrapped)    .  , NAPI ,      ,     .         NAPI .      ,  NAPI   ,     ,   . <br><br>  poll ,      napi_schedule.   -,    ,      __napi_schedule. <br><br>   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * __napi_schedule ‚Äì   * @n:    * *       */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> __napi_schedule(struct napi_struct *n) { <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flags; local_irq_save(flags); ____napi_schedule(&amp;__get_cpu_var(softnet_data), n); local_irq_restore(flags); } EXPORT_SYMBOL(__napi_schedule);</code> </pre> <br>       softnet_data,    CPU,  __get_cpu_var.     ____napi_schedule       struct napi_struct.    . <br><br>    ____napi_schedule,   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    IRQ */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ____napi_schedule(struct softnet_data *sd, struct napi_struct *napi) { list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list); __raise_softirq_irqoff(NET_RX_SOFTIRQ); }</code> </pre> <br>      : <br><br><ol><li>  struct napi_struct,      ,   poll_list,    softnet_data,    CPU. </li><li> __raise_softirq_irqoff    SoftIRQ NET_RX_SOFTIRQ.     net_rx_action,       ,     . </li></ol><br>    , SoftIRQ - net_rx_action      NAPI poll. <br><br><h4>   CPU     </h4><br>  ,     ,         SoftIRQ,  ,    CPU. <br><br>    IRQ-   ,  SoftIRQ-      CPU,   IRQ-.   ,  CPU    IRQ:   CPU         ,       SoftIRQ  NAPI. <br><br>   ,       ( <a href="https://lwn.net/Articles/362339/">Receive Packet Steering</a> )       CPU    . <br><br><h4>     </h4><br><h4>    </h4><br> :          .         NAPI.         . <br><br>  /proc/interrupts,     : <br><br><pre> <code class="bash hljs">$ cat /proc/interrupts CPU0 CPU1 CPU2 CPU3 0: 46 0 0 0 IR-IO-APIC-edge timer 1: 3 0 0 0 IR-IO-APIC-edge i8042 30: 3361234770 0 0 0 IR-IO-APIC-fasteoi aacraid 64: 0 0 0 0 DMAR_MSI-edge dmar0 65: 1 0 0 0 IR-PCI-MSI-edge eth0 66: 863649703 0 0 0 IR-PCI-MSI-edge eth0-TxRx-0 67: 986285573 0 0 0 IR-PCI-MSI-edge eth0-TxRx-1 68: 45 0 0 0 IR-PCI-MSI-edge eth0-TxRx-2 69: 394 0 0 0 IR-PCI-MSI-edge eth0-TxRx-3 NMI: 9729927 4008190 3068645 3375402 Non-maskable interrupts LOC: 2913290785 1585321306 1495872829 1803524526 Local timer interrupts</code> </pre> <br>    /proc/interrupts,            .   ,          CPU.      ,   ,    <b> </b>  ,      ,               NAPI.  ,    (interrupt coalescing)    ,    .    ,        . <br><br>          ,    /proc/softirqs      /proc.  We will discuss this below. <br><br><h4>     </h4><br><h4>   </h4><br>   <a href="https://en.wikipedia.org/wiki/Interrupt_coalescing"></a>       CPU,          . <br><br>    ¬´ <a href="https://en.wikipedia.org/wiki/Interrupt_storm"> </a> ¬ª      ,    .           ,    CPU.      :     ,     CPU. <br><br>   ,    igb, e1000        InterruptThrottleRate.       generic   ethtool. <br><br>     IRQ: <br><br><pre> <code class="bash hljs">$ sudo ethtool -c eth0 Coalesce parameters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth0: Adaptive RX: off TX: off stats-block-usecs: 0 sample-interval: 0 pkt-rate-low: 0 pkt-rate-high: 0 ...</code> </pre> <br> ethtool  generic-    .  ,         .      ,  ,     .      ethtool: ¬´,    ,   ¬ª. <br><br>      ¬´   /¬ª (adaptive RX/TX IRQ coalescing).     .     ,        ,   -  (bookkeeping) (       igb). <br><br>              ,        . <br><br>     : <br><br><pre> <code class="bash hljs">$ sudo ethtool -C eth0 adaptive-rx on</code> </pre> <br>   ethtool -C    .     : <br><br><ul><li> rx-usecs:         ,  . </li><li> rx-frames:   ,     . </li><li> rx-usecs-irq:    ,    ,  . </li><li> rx-frames-irq:   ,     ,    . </li></ul><br>      . <br><br> <b></b> ,          .        . <br><br>  ,       ,   .    <a href="">include/uapi/linux/ethtool.h</a>      ,  ethtool (  ,        ). <br><br> <b>:</b>         .      ,    ,        .         . <br><br><h4>   IRQ </h4><br>     RSS,       ,        CPU     . <br><br>     CPU.        ,       . <br><br>      IRQ,   ,    irqbalance.       CPU,      .  irqbalance,   --banirq   IRQBALANCE_BANNED_CPUS,  irqbalance ,           CPU. <br><br>    /proc/interrupts            . ,    /proc/irq/IRQ_NUMBER/smp_affinity,    ,  CPU    .        ,   ,  CPU    . <br><br> :   IRQ 8  CPU 0: <br><br><pre> <code class="bash hljs">$ sudo bash -c <span class="hljs-string"><span class="hljs-string">'echo 1 &gt; /proc/irq/8/smp_affinity'</span></span></code> </pre> <br><h4>     </h4><br>  SoftIRQ- ,   SoftIRQ    ,  net_rx_action      . <br><br>      net_rx_action,  ,   ,     . <br><br><h4>   net_rx_action </h4><br> net_rx_action     ,       DMA. <br><br>      NAPI,     CPU,       . <br><br>          NAPI- poll.     : <br><br><ol><li>    (work budget) (  ), </li><li>     . </li></ol><br>   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!list_empty(&amp;sd-&gt;poll_list)) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">napi_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> work, weight; <span class="hljs-comment"><span class="hljs-comment">/*    SoftIRQ -  *      ,    *     1.5/. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(budget &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span> || time_after_eq(jiffies, time_limit))) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> softnet_break;</code> </pre> <br>           CPU. budget ‚Äî    ,       NAPI-,    CPU. <br><br>    ,           IRQ. ,   CPU,     ,      SoftIRQ.       CPU       . <br><br>     ,      ,    ,    CPU   NAPI-.       CPU ¬´¬ª      . <br><br>     CPU   ,    net_rx_action budget,   CPU   .       CPU (  sitime  si  top   ),    ,      . <br><br> <b>:</b> CPU      <a href="http://elinux.org/Kernel_Timer_Systems">jiffies</a> ,     . <br><br><h4> NAPI- poll  weight </h4><br> ,        poll  netif_napi_add.    ,  igb   : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  NAPI */</span></span> netif_napi_add(adapter-&gt;netdev, &amp;q_vector-&gt;napi, igb_poll, <span class="hljs-number"><span class="hljs-number">64</span></span>);</code> </pre> <br>   NAPI-,      64.  ,        net_rx_action. <br><br>   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="bash hljs">weight = n-&gt;weight; work = 0; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) { work = n-&gt;poll(n, weight); trace_napi_poll(n); } WARN_ON_ONCE(work &gt; weight); budget -= work;</code> </pre> <br>   ,    NAPI,      poll,     NAPI (   igb_poll). <br><br>  poll    .     work,      budget. <br><br>  Assume: <br><ol><li>       64 (    Linux 3.13.0    ), </li><li>    budget   300. </li></ol><br>   <b></b>  , : <br><br><ol><li>  igb_poll     5  (   ,     ,    ), </li><li>     2 jiffies. </li></ol><br><h4>   NAPI     </h4><br>      ,     NAPI   .     NAPI. <br><br><ul><li>    poll     (64),  <b> </b>   NAPI.     net_rx_action. </li><li>    poll <b></b>    ,    NAPI. NAPI       IRQ,      napi_schedule. </li></ul><br>  ,  net_rx_action     . ,    poll, ,     . <br><br><h4>   net_rx_action </h4><br>   net_rx_action   ,       NAPI.   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*      NAPI,   *    .       * ¬´¬ª  NAPI, , ,  *       . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(work == weight)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(napi_disable_pending(n))) { local_irq_enable(); napi_complete(n); local_irq_disable(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n-&gt;gro_list) { <span class="hljs-comment"><span class="hljs-comment">/*     *  HZ &lt; 1000,   . */</span></span> local_irq_enable(); napi_gro_flush(n, HZ &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>); local_irq_disable(); } list_move_tail(&amp;n-&gt;poll_list, &amp;sd-&gt;poll_list); } }</code> </pre> <br>     ,  net_rx_action   : <br><br><ol><li>      (,     ifconfig eth0 down). </li><li>   <b></b> ,  ,    generic receive offload (GRO).    ( <a href="http://www.makelinux.net/books/lkd2/ch10lev1sec2">timer tick rate</a> ) &gt;= 1000,      GRO,   ,  .     GRO. NAPI-      CPU,         NAPI-. </li></ol><br>          poll,   .   ,              . <br><br><h4>       </h4><br>    net_rx_action  , : <br><br><ul><li>  poll,    CPU,    NAPI- (!list_empty(&amp;sd-&gt;poll_list)), </li><li>    &lt;= 0, </li><li>        jiffies. </li></ul><br>       <br><br><pre> <code class="bash hljs"> /*    SoftIRQ - . *      ,    *     1.5/. */ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(budget &lt;= 0 || time_after_eq(jiffies, time_limit))) goto softnet_break;</code> </pre> <br>    label softnet_break,   - .   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">softnet_break: sd-&gt;time_squeeze++; __raise_softirq_irqoff(NET_RX_SOFTIRQ); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out;</code> </pre> <br>     struct softnet_data   SoftIRQ NET_RX_SOFTIRQ.  time_squeeze ‚Äî   ,   net_rx_action  ,          ,     .   <b></b>        .    . NET_RX_SOFTIRQ ,       .    ,        ,     ,      CPU. <br><br>     (label) out.     out    ,     NAPI-  ,    ,   ,    NAPI,  net_rx_action  . <br><br>      net_rx_action,   out   :  net_rps_action_and_irq_enable.      ( <a href="https://lwn.net/Articles/362339/">Receive Packet Steering</a> ),      CPU,      . <br><br>     RPS.   ,      net_rx_action,    ¬´¬ª NAPI- poll,    . <br><br><h4> NAPI- poll </h4><br> ,     ,        .       ,     ,        . <br><br>   igb   ? <br><br><h4> igb_poll </h4><br> -     igb_poll.    .   <a href="">drivers/net/ethernet/intel/igb/igb_main.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * igb_poll ‚Äì NAPI Rx polling callback * @napi:   (polling) NAPI * @budget:   ,    **/</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">igb_poll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct napi_struct *napi, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> budget)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igb_q_vector</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">q_vector</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">container_of</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">napi</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igb_q_vector</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">napi</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> clean_complete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> CONFIG_IGB_DCA </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (q_vector-&gt;adapter-&gt;flags &amp; IGB_FLAG_DCA_ENABLED) igb_update_dca(q_vector); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ... */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (q_vector-&gt;rx.ring) clean_complete &amp;= igb_clean_rx_irq(q_vector, budget); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     ,      */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!clean_complete) return budget; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      ,     */</span></span></span><span class="hljs-meta"> napi_complete(napi); igb_ring_irq_enable(q_vector); return 0; }</span></span></code> </pre> <br>     : <br><br><ul><li>          ( <a href="https://lwn.net/Articles/247493/">Direct Cache Access (DCA)</a> ),   CPU ¬´¬ª,       RX-.         .    . </li><li>    igb_clean_rx_irq,   .  About this below. </li><li>   clean_complete,  ,    ,   .  ,    (   64). net_rx_action  NAPI-    poll. </li><li>      NAPI   napi_complete,    igb_ring_irq_enable   .      NAPI. </li></ul><br>  ,  igb_clean_rx_irq      . <br><br><h4> igb_clean_rx_irq </h4><br>  igb_clean_rx_irq ‚Äî  ,      ,    budget    . <br><br>      : <br><br><ol><li>       ,     .    IGB_RX_BUFFER_WRITE (16)  . </li><li>          skb. </li><li> ,   ‚ÄúEnd of Packet‚Äù.  ,   .              skb.     ,      . </li><li>    (layout)   . </li><li>   skb-&gt;len     . </li><li>  skb  ,  ,  , VLAN id   .      .       ,   csum_error.       ,     UDP  TCP,  skb   CHECKSUM_UNNECESSARY.     ,      .       eth_type_trans     skb. </li><li>  skb         napi_gro_receive. </li><li>     . </li><li>      ,       . </li></ol><br>   ,       . <br><br>      ,   . -, ,     SoftIRQ  . -,   Generic Receive Offloading (GRO).  ,     napi_gro_receive,        . <br><br><h4>     </h4><br><h4> /proc/net/softnet_stat </h4><br><br>      ,        net_rx_action,    ,    ,          SoftIRQ.       struct softnet_data,   CPU.     /proc/net/softnet_stat,  ,  ,   .           . <br><br>  Linux 3.13.0  ,       /proc/net/softnet_stat    .   <a href="">net/core/net-procfs.c</a> : <br><br><pre> <code class="cpp hljs">seq_printf(seq, <span class="hljs-string"><span class="hljs-string">"%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\n"</span></span>, sd-&gt;processed, sd-&gt;dropped, sd-&gt;time_squeeze, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/* was fastroute */</span></span> sd-&gt;cpu_collision, sd-&gt;received_rps, flow_limit_count);</code> </pre> <br>            .      ,       .   squeeze_time   net_rx_action,  ,      . <br><br>  /proc/net/softnet_stat,      : <br><br><pre> <code class="bash hljs">$ cat /proc/net/softnet_stat 6dcad223 00000000 00000001 00000000 00000000 00000000 00000000 00000000 00000000 00000000 6f0e1565 00000000 00000002 00000000 00000000 00000000 00000000 00000000 00000000 00000000 660774ec 00000000 00000003 00000000 00000000 00000000 00000000 00000000 00000000 00000000 61c99331 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 6794b1b3 00000000 00000005 00000000 00000000 00000000 00000000 00000000 00000000 00000000 6488cb92 00000000 00000001 00000000 00000000 00000000 00000000 00000000 00000000 00000000</code> </pre> <br>    /proc/net/softnet_stat: <br><br><ul><li>   /proc/net/softnet_stat   struct softnet_data,     CPU. </li><li>         . </li><li>  , sd-&gt;processed, ‚Äî     .       ,     Ethernet (Ethernet bonding).        ,    sd-&gt;processed           . </li><li>  , sd-&gt;dropped, ‚Äî            .  We will talk about this below. </li><li>  , sd-&gt;time_squeeze, ‚Äî   ,   net_rx_action  -       ,    .   ,     budget. </li><li>      0. </li><li>  , sd-&gt;cpu_collision, ‚Äî   ,          .      ,       . </li><li>  , sd-&gt;received_rps, ‚Äî   ,   <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt"> </a>  CPU   . </li><li>  , flow_limit_count, ‚Äî   ,      (flow limit).   ‚Äî       ( <a href="https://lwn.net/Articles/362339">Receive Packet Steering</a> ),    . </li></ul><br>          ,    ,         .      . <br><br><h4>     </h4><br><h4>   net_rx_action </h4><br>   net_rx_action  ,         NAPI-,   CPU.      sysctl   net.core.netdev_budget. <br><br> :       600. <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.netdev_budget=600</code> </pre> <br>        /etc/sysctl.conf ,     .  Linux 3.13.0    300. <br><br><h4>  Generic Receive Offloading (GRO) </h4><br> Generic Receive Offloading (GRO) ‚Äî     ,   <a href="https://en.wikipedia.org/wiki/Large_receive_offload">Large Receive Offloading</a> (LRO). <br><br>     ,    ,    ,    ¬´ ¬ª .      CPU. ,      ,         .        ,      ,    .       .        ,        . <br><br>       .  -       ,             .    LRO      . <br> GRO    LRO,      . <br><br> :   -  tcpdump       ,        GRO   .    , tap'      ,   GRO. <br><br><h4>   GRO   ethtool </h4><br> ethtool    ,   GRO,     . <br><br>  : <br><br><pre> <code class="bash hljs">$ ethtool -k eth0 | grep generic-receive-offload generic-receive-offload: on</code> </pre> <br>     generic-receive-offload.  GRO: <br><br><pre> <code class="bash hljs">$ sudo ethtool -K eth0 gro on</code> </pre> <br> <b>:</b>           ,       .        . <br><br><h4> napi_gro_receive </h4><br>  napi_gro_receive      GRO ( GRO )        .       dev_gro_receive. <br><br><h4> dev_gro_receive </h4><br>    ,   GRO.  ,     :    offload-,        ,   GRO.    ,        ,     <a href="https://en.wikipedia.org/wiki/Traffic_flow_%2528computer_networking%2529"> </a> ,     ,        ,      GRO. , TCP-  ,  /      . <br><br>   ,   ,   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">list_for_each_entry_rcu(ptype, head, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptype-&gt;type != type || !ptype-&gt;callbacks.gro_receive) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; skb_set_network_header(skb, skb_gro_offset(skb)); skb_reset_mac_len(skb); NAPI_GRO_CB(skb)-&gt;same_flow = <span class="hljs-number"><span class="hljs-number">0</span></span>; NAPI_GRO_CB(skb)-&gt;flush = <span class="hljs-number"><span class="hljs-number">0</span></span>; NAPI_GRO_CB(skb)-&gt;<span class="hljs-built_in"><span class="hljs-built_in">free</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; pp = ptype-&gt;callbacks.gro_receive(&amp;napi-&gt;gro_list, skb); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> <br>    ,     GRO-,     .     napi_gro_complete,   callback gro_complete   ,         netif_receive_skb. <br><br>    <a href="">net/core/dev.c</a> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pp) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk_buff</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nskb</span></span></span><span class="hljs-class"> = *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pp</span></span></span><span class="hljs-class">;</span></span> *pp = nskb-&gt;next; nskb-&gt;next = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; napi_gro_complete(nskb); napi-&gt;gro_count--; }</code> </pre> <br>         ,  napi_gro_receive  . <br><br>          MAX_GRO_SKBS (8) GRO-,    gro_list NAPI-  CPU   . <br><br>    <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NAPI_GRO_CB(skb)-&gt;flush || napi-&gt;gro_count &gt;= MAX_GRO_SKBS) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> normal; napi-&gt;gro_count++; NAPI_GRO_CB(skb)-&gt;count = <span class="hljs-number"><span class="hljs-number">1</span></span>; NAPI_GRO_CB(skb)-&gt;age = jiffies; skb_shinfo(skb)-&gt;gso_size = skb_gro_len(skb); skb-&gt;next = napi-&gt;gro_list; napi-&gt;gro_list = skb; ret = GRO_HELD;</code> </pre> <br>    GRO    Linux. <br><br><h4> napi_skb_finish </h4><br>   dev_gro_receive  napi_skb_finish,    ,     ,         netif_receive_skb (  GRO     MAX_GRO_SKBS). <br><br>         (Receive Packet Steering (RPS)). <br><br><a name="7"></a><h2>  3.4.     Receive Packet Steering (RPS) </h2><br> ,   ,      NAPI- poll?    NAPI    SoftIRQ,     CPU.  ,  CPU,      ,     SoftIRQ- . <br><br>  ,       CPU       poll. <br><br>    ( Intel I350)      .  ,          ,    .          NAPI-.         CPU. <br><br>    Receive Side Scaling (RSS). <br><br> <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt">Receive Packet Steering (RPS)</a> ‚Äî    RSS.     ,        ,        .   ,     ,  RPS       ,   DMA- . <br><br>  ,  CPU           poll,           ,    ,     CPU   . <br><br> RPS     ,  ,  CPU   .       (backlog)      .    backlog  <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt"> </a> (IPI),   ,     . /proc/net/softnet_stat    ,    softnet_data  IPI ( received_rps). <br><br> , netif_receive_skb          RPS    CPU. <br><br><h4>  RPS </h4><br>      RPS    ( Ubuntu    3.13.0),     , ,  CPU         . <br><br>         <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt">  </a> .  ,      : <br><br><pre> <code class="bash hljs">/sys/class/net/DEVICE_NAME/queues/QUEUE/rps_cpus</code> </pre> <br> ,  eth0    0     /sys/class/net/eth0/queues/rx-0/rps_cpus  , ,  CPU      0 eth0.    <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt"></a> ,     RPS  . <br><br> <b>:</b>  RPS      CPU,     ,     CPU     SoftIRQ `NET_RX`,   `si`  `sitime`     CPU.    ¬´¬ª  ¬´¬ª,  ,    RPS  . <br><br><a name="8"></a><h2>  3.5.     (Receive Flow Steering (RFS)) </h2><br> Receive flow steering (RFS)    RPS. RPS       CPU,               CPU.      ,      RFS,          CPU. <br><br><h4>  RFS </h4><br>  RFS ,     . RFS   -  .     sysctl  net.core.rps_sock_flow_entries. <br><br>       RFS: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.rps_sock_flow_entries=32768</code> </pre> <br>         .     rps_flow_cnt   . <br><br> :     2048  eth0   0: <br><br><pre> <code class="bash hljs">$ sudo bash -c <span class="hljs-string"><span class="hljs-string">'echo 2048 &gt; /sys/class/net/eth0/queues/rx-0/rps_flow_cnt'</span></span></code> </pre> <br><a name="9"></a><h2>  3.6.      (Accelerated Receive Flow Steering (aRFS)) </h2><br>  RFS   .       ,     CPU  .       ,   .       ndo_rx_flow_steer,    aRFS. <br><br><h4>  aRFS </h4><br> ,     .     : <br><br><ol><li>    RPS. </li><li>    RFS. </li><li>      CONFIG_RFS_ACCEL.  ,   Ubuntu 3.13.0. </li><li>      ntuple,   . ,   ,    ethtool. </li><li>   IRQ  ,         CPU,    . </li></ol><br>     , aRFS        ,    CPU,     .        ntuple   . <br><br><a name="10"></a><h2>  3.7.  (moving up)     netif_receive_skb </h2><br>    ,    netif_receive_skb,    .     (   ): <br><br><ul><li> napi_skb_finish ‚Äî        GRO-,  </li><li> napi_gro_complete ‚Äî      ,    ,  </li></ul><br> <b>:</b> netif_receive_skb         SoftIRQ.   top      sitime  si. <br><br> netif_receive_skb    sysctl  ,             ,     backlog-.    ,        ,      RPS ( backlog-,   CPU).    ,         .   RPS            CPU,    . <br><br><h4> :      </h4><br>       sysctl  net.core.netdev_tstamp_prequeue. <br><br>     : <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.netdev_tstamp_prequeue=0</code> </pre> <br>     1.       . <br><br><a name="11"></a><h2>  3.8. netif_receive_skb </h2><br>    ,  netif_receive_skb   ,    ,   RPS.     ,  RPS . <br><br><h4>  RPS ( ) </h4><br>     __netif_receive_skb,   -  (bookkeeping),    __netif_receive_skb_core,        . <br><br>   ,   __netif_receive_skb_core,        RPS,       __netif_receive_skb_core. <br><br><h4>   RPS </h4><br>       , netif_receive_skb     , backlog-  CPU  .      get_rps_cpu.   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">cpu = get_rps_cpu(skb-&gt;dev, skb, &amp;rflow); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpu &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { ret = enqueue_to_backlog(skb, cpu, &amp;rflow-&gt;last_qtail); rcu_read_unlock(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br> get_rps_cpu      RFS  aRFS,  ,    enqueue_to_backlog    backlog  CPU. <br><br><h4> enqueue_to_backlog </h4><br>        softnet_data  CPU,    input_pkt_queue.     input_pkt_queue   CPU.   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">qlen = skb_queue_len(&amp;sd-&gt;input_pkt_queue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) {</code> </pre> <br>    input_pkt_queue   netdev_max_backlog.     ,   <b></b> .    ,    ,   <b></b> .        softnet_data.  ,     CPU,        .        /proc/net/softnet_stat. <br><br> enqueue_to_backlog       RPS,    netif_rx.     <b></b> netif_rx,  netif_receive_skb.     RPS      netif_rx,   backlog'      ,     . <br><br> <b>:</b>   .    netif_receive_skb   <b></b>  RPS,   netdev_max_backlog    ,        input_pkt_queue. <br><br> ,  input_pkt_queue        ( ),       .    ,    : <br><br><ul><li>   : ,   NAPI   CPU.  , ,       IPI.  ,  IPI   ,    ____napi_schedule    NAPI.      . </li><li>    ,     ,    . </li></ul><br> -  goto   ,    .   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skb_queue_len(&amp;sd-&gt;input_pkt_queue)) { enqueue: __skb_queue_tail(&amp;sd-&gt;input_pkt_queue, skb); input_queue_tail_incr_save(sd, qtail); rps_unlock(sd); local_irq_restore(flags); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NET_RX_SUCCESS; } <span class="hljs-comment"><span class="hljs-comment">/* Schedule NAPI for backlog device * We can use non atomic operation since we own the queue lock */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!__test_and_set_bit(NAPI_STATE_SCHED, &amp;sd-&gt;backlog.state)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!rps_ipi_queued(sd)) ____napi_schedule(sd, &amp;sd-&gt;backlog); } <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> enqueue;</code> </pre> <br><h4>   </h4><br> RPS        CPU,             .         ,   backlog.           . <br><br>  if  <a href="">net/core/dev.c</a>   skb_flow_limit   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qlen &lt;= netdev_max_backlog &amp;&amp; !skb_flow_limit(skb, qlen)) {</code> </pre> <br>  ,           <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/scaling.txt"></a> .    .        ( RPS). <br><br><h4>      input_pkt_queue    </h4><br> .    /proc/net/softnet_stat.  dropped ‚Äî  ,           input_pkt_queue CPU. <br><br><h4>  Customization </h4><br><h4>  netdev_max_backlog    </h4><br>     ,     . <br><br>    RPS     netif_rx,       enqueue_to_backlog    netdev_max_backlog. <br><br> :  backlog  3000: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.netdev_max_backlog=3000</code> </pre> <br>     1000. <br><br><h4>   NAPI  backlog  poll </h4><br>    NAPI  backlog'    net.core.dev_weight sysctl.   ,        poll backlog' (.    net.core.netdev_budget). <br><br> :   backlog'   poll: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.dev_weight=600</code> </pre> <br>     64. <br><br> ,   backlog'    SoftIRQ       poll.        ,     . <br><br><h4>       -   </h4><br>     : <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.flow_limit_table_len=8192</code> </pre> <br>     4096. <br><br>        .      ,     . <br><br>         /proc/sys/net/core/flow_limit_cpu_bitmap,   RPS,  ,   CPU   . <br><br><h4>  NAPI backlog- </h4><br> Backlog-  CPU  NAPI  ,    .   poll,       SoftIRQ.      ,    weight. <br><br>  NAPI      . <br><br>   net_dev_init  <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">sd-&gt;backlog.poll = process_backlog; sd-&gt;backlog.weight = weight_p; sd-&gt;backlog.gro_list = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; sd-&gt;backlog.gro_count = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br> NAPI-c backlog'        weight:      .      . <br><br><h4> process_backlog </h4><br>  process_backlog ‚Äî  ,    ,    (    )       backlog'    . <br><br>      backlog-    __netif_receive_skb.     ,       RPS.  , __netif_receive_skb       __netif_receive_skb_core,      . <br><br> process_backlog      NAPI,    : NAPI ,     .     ____napi_schedule  enqueue_to_backlog,   . <br><br>    ,   net_rx_action ( )    (   net.core.netdev_budget,  ). <br><br><h4> __netif_receive_skb_core    packet taps     </h4><br> __netif_receive_skb_core         .     ,   - packet taps,     .  ‚Äì   AF_PACKET,     <a href="http://www.tcpdump.org/manpages/pcap.3pcap.html">libpcap</a> . <br><br>    tap,     ,     . <br><br><h4>   packet tap </h4><br>     .   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pt_prev) ret = deliver_skb(skb, pt_prev, orig_dev); pt_prev = ptype; } }</code> </pre> <br>   ,     pcap,  <a href="">net/packet/af_packet.c</a> . <br><br><h4>     </h4><br>  ,    , __netif_receive_skb_core     .               (deliver functions),     . <br><br>     __netif_receive_skb_core  <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs">type = skb-&gt;protocol; list_for_each_entry_rcu(ptype, &amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK], <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptype-&gt;type == type &amp;&amp; (ptype-&gt;dev == null_or_dev || ptype-&gt;dev == skb-&gt;dev || ptype-&gt;dev == orig_dev)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pt_prev) ret = deliver_skb(skb, pt_prev, orig_dev); pt_prev = ptype; } }</code> </pre> <br>   ptype_base   -   <a href="">net/core/dev.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_head</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ptype_base</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PTYPE_HASH_SIZE</span></span></span><span class="hljs-class">] __</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">read_mostly</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>          -,    ptype_head: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> struct list_head *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ptype_head</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct packet_type *pt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pt-&gt;type == htons(ETH_P_ALL)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ptype_all; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ptype_base[ntohs(pt-&gt;type) &amp; PTYPE_HASH_MASK]; }</code> </pre> <br>       dev_add_pack.          . <br>   ,          . <br><br><a name="12"></a><h2>  3.9.    </h2><br>  ,      .        IP,          . <br><br><h4>   IP </h4><br>   IP     - ptype_base,        ,         . <br><br>     inet_init,   <a href="">net/ipv4/af_inet.c</a> : <br><br><pre> <code class="cpp hljs">dev_add_pack(&amp;ip_packet_type);     IP-,   &lt;a href=<span class="hljs-string"><span class="hljs-string">"https://github.com/torvalds/linux/blob/v3.13/net/ipv4/af_inet.c#L1673-L1676"</span></span>&gt;net/ipv4/af_inet.c&lt;/a&gt;: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> struct packet_type ip_packet_type __read_mostly = { .type = cpu_to_be16(ETH_P_IP), .func = ip_rcv, };</code> </pre> <br> __netif_receive_skb_core  deliver_skb (     ),   func (   ‚Äì ip_rcv). <br><br><h4> ip_rcv </h4><br>     ip_rcv  .      ,     ,     . <br><br> ip_rcv     ip_rcv_finish  <a href="https://ru.wikipedia.org/wiki/Netfilter">netfilter</a> .   ,    <a href="https://ru.wikipedia.org/wiki/Iptables">iptables</a> ,        IP,   ,     . <br><br> ,    netfilter   ip_rcv  <a href="">net/ipv4/ip_input.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ip_rcv_finish);</code> </pre> <br><h4> netfilter  iptables </h4><br>         netfilter, iptables  conntrack. <br><br>  : NF_HOOK_THRESH ,   -          IP,     netfilter  ,   ,  iptables  conntrack. <br><br> :      netfilter  iptables,    ,        SoftIRQ,        . ,     ,       . <br><br><h4> ip_rcv_finish </h4><br>  ,  netfilter       ,    ,  ip_rcv_finish. ,      netfilter'. <br><br> ip_rcv_finish   .      ,     dst_entry   .         early_demux     ,  ,     . <br><br> early_demux ‚Äî  <a href="https://patchwork.ozlabs.org/patch/280718/"></a> ,            dst_entry.   ,    dst_entry   . <br><br>    ,   <a href="">net/ipv4/ip_input.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sysctl_ip_early_demux &amp;&amp; !skb_dst(skb) &amp;&amp; skb-&gt;sk == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_protocol</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ipprot</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> protocol = iph-&gt;protocol; ipprot = rcu_dereference(inet_protos[protocol]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ipprot &amp;&amp; ipprot-&gt;early_demux) { ipprot-&gt;early_demux(skb); <span class="hljs-comment"><span class="hljs-comment">/*   iph, skb-&gt;head   */</span></span> iph = ip_hdr(skb); } }</code> </pre> <br>  ,    sysctl_ip_early_demux.    early_demux.       ,          . <br><br>         (     ),       ,  dst_entry    . <br><br>       ,     dst_input(skb). ,   ,        dst_entry,   . <br><br>     ‚Äî  ,      ip_local_deliver        dst_entry. <br><br><h4>  early demux  IP </h4><br>   early_demux: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.ipv4.ip_early_demux=0</code> </pre> <br>     1; early_demux . <br><br>     sysctl <a href="https://patchwork.ozlabs.org/patch/166441/">  5%   </a>   early_demux. <br><br><h4> ip_local_deliver </h4><br>       IP: <br><br><ol><li>   ip_rcv    (bookkeeping). </li><li>   netfilter   ,     callback',    . </li><li> ip_rcv_finish ‚Äî  callback,         . </li></ol><br>    ip_local_deliver    .   <a href="">net/ipv4/ip_input.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *  IP-     . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ip_local_deliver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct sk_buff *skb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* *  IP-. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ip_is_fragment(ip_hdr(skb))) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, ip_local_deliver_finish); }</code> </pre> <br>  ,  netfilter     ,  ip_local_deliver_finish. ,      netfilter'. <br><br><h4> ip_local_deliver_finish </h4><br> ip_local_deliver_finish    ,       net_protocol   ,    handler   . <br><br>         . <br><br><h4>     IP </h4><br>  /proc/net/snmp,      IP: <br><br><pre> <code class="bash hljs">$ cat /proc/net/snmp Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates Ip: 1 64 25922988125 0 0 15771700 0 0 25898327616 22789396404 12987882 51 1 10129840 2196520 1 0 0 0 ...</code> </pre> <br>        .    IP.            . <br><br>    IP     ,    -.   enum-     /proc/net/snmp,   ,    <a href="">include/uapi/linux/snmp.h</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { IPSTATS_MIB_NUM = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*    ,     - */</span></span> IPSTATS_MIB_INPKTS, <span class="hljs-comment"><span class="hljs-comment">/* InReceives */</span></span> IPSTATS_MIB_INOCTETS, <span class="hljs-comment"><span class="hljs-comment">/* InOctets */</span></span> IPSTATS_MIB_INDELIVERS, <span class="hljs-comment"><span class="hljs-comment">/* InDelivers */</span></span> IPSTATS_MIB_OUTFORWDATAGRAMS, <span class="hljs-comment"><span class="hljs-comment">/* OutForwDatagrams */</span></span> IPSTATS_MIB_OUTPKTS, <span class="hljs-comment"><span class="hljs-comment">/* OutRequests */</span></span> IPSTATS_MIB_OUTOCTETS, <span class="hljs-comment"><span class="hljs-comment">/* OutOctets */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span></code> </pre> <br>  /proc/net/netstat,      IP: <br><br><pre> <code class="bash hljs">$ cat /proc/net/netstat | grep IpExt IpExt: InNoRoutes InTruncatedPkts InMcastPkts OutMcastPkts InBcastPkts OutBcastPkts InOctets OutOctets InMcastOctets OutMcastOctets InBcastOctets OutBcastOctets InCsumErrors InNoECTPkts InECT0Pktsu InCEPkts IpExt: 0 0 0 0 277959 0 14568040307695 32991309088496 0 0 58649349 0 0 0 0 0</code> </pre> <br>   /proc/net/snmp,      IpExt. <br><br>   : <br><br><ul><li> InReceives:   IP-,  ip_rcv    . </li><li> InHdrErrors:   IP-   .      ,   ,      IP   . </li><li> InAddrErrors:   IP-,    . </li><li> ForwDatagrams:   IP-,    (forwarded). </li><li> InUnknownProtos:   IP-     ,   . </li><li> InDiscards:   IP-,      ,         . </li><li> InDelivers:   IP-,       . ,      ,       IP. </li><li> InCsumErrors:   IP-    . </li></ul><br>         IP.       ,         .      ,           IP,  ,   . <br><br><h4>      </h4><br>    UDP,    TCP        ,     UDP. <br><br>  net/ipv4/af_inet.c    ,   -    UDP, TCP  ICMP    IP.   <a href="">net/ipv4/af_inet.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcp_protocol</span></span></span><span class="hljs-class"> = {</span></span> .early_demux = tcp_v4_early_demux, .handler = tcp_v4_rcv, .err_handler = tcp_v4_err, .no_policy = <span class="hljs-number"><span class="hljs-number">1</span></span>, .netns_ok = <span class="hljs-number"><span class="hljs-number">1</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udp_protocol</span></span></span><span class="hljs-class"> = {</span></span> .early_demux = udp_v4_early_demux, .handler = udp_rcv, .err_handler = udp_err, .no_policy = <span class="hljs-number"><span class="hljs-number">1</span></span>, .netns_ok = <span class="hljs-number"><span class="hljs-number">1</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">icmp_protocol</span></span></span><span class="hljs-class"> = {</span></span> .handler = icmp_rcv, .err_handler = icmp_err, .no_policy = <span class="hljs-number"><span class="hljs-number">1</span></span>, .netns_ok = <span class="hljs-number"><span class="hljs-number">1</span></span>, };</code> </pre> <br>         inet.   <a href="">net/ipv4/af_inet.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *    . */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inet_add_protocol(&amp;icmp_protocol, IPPROTO_ICMP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) pr_crit(<span class="hljs-string"><span class="hljs-string">"%s: Cannot add ICMP protocol\n"</span></span>, __func__); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) pr_crit(<span class="hljs-string"><span class="hljs-string">"%s: Cannot add UDP protocol\n"</span></span>, __func__); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inet_add_protocol(&amp;tcp_protocol, IPPROTO_TCP) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) pr_crit(<span class="hljs-string"><span class="hljs-string">"%s: Cannot add TCP protocol\n"</span></span>, __func__);</code> </pre> <br>    UDP.    ,  handler  UDP  udp_rcv.      UPD,      IP. <br><br><h4>   UDP </h4><br>    UDP   : <a href="">net/ipv4/udp.c</a> . <br><br><h4> udp_rcv </h4><br>   udp_rcv    ,      __udp4_lib_rcv    . <br><br><h4> __udp4_lib_rcv </h4><br>  __udp4_lib_rcv        UDP,  UDP-,      .       . <br><br> ,   ,    IP,   ,    dst_entry     ,        (   ‚Äî UDP). <br><br>      dst_entry,   __udp4_lib_rcv     : <br><br><pre> <code class="cpp hljs">sk = skb_steal_sock(skb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sk) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dst_entry</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dst</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_dst</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (unlikely(sk-&gt;sk_rx_dst != dst)) udp_sk_rx_dst_set(sk, dst); ret = udp_queue_rcv_skb(sk, skb); sock_put(sk); <span class="hljs-comment"><span class="hljs-comment">/*   &gt; 0    , *     ‚Äìprotocol  0 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ret; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {</code> </pre> <br>    early_demux     ,      __udp4_lib_lookup_skb. <br><br>         : <br><br><pre> <code class="cpp hljs">ret = udp_queue_rcv_skb(sk, skb); sock_put(sk);</code> </pre> <br>      ,    : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  .   ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (udp_lib_checksum_complete(skb)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> csum_error; UDP_INC_STATS_BH(net, UDP_MIB_NOPORTS, proto == IPPROTO_UDPLITE); icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* * .   UDP-  ,  *   .  . */</span></span> kfree_skb(skb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><h4> udp_queue_rcv_skb </h4><br>   : <br><br><ol><li> ,   ,   , <a href="https://tools.ietf.org/html/rfc3948"></a> .  ,      -  . </li><li> ,     UDP-Lite    . </li><li>  UDP-        . </li></ol><br> -      .        .   <a href="">net/ipv4/udp.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sk_rcvqueues_full(sk, skb, sk-&gt;sk_rcvbuf)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> drop;</code> </pre> <br><h4> sk_rcvqueues_full </h4><br>  sk_rcvqueues_full   backlog'  sk_rmem_alloc ,  ,        sk_rcvbuf   (sk-&gt;sk_rcvbuf   ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* *      backlog-. *    skb truesize, *       . */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sk_rcvqueues_full</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sock *sk, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sk_buff *skb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> limit)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> qsize = sk-&gt;sk_backlog.len + atomic_read(&amp;sk-&gt;sk_rmem_alloc); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> qsize &gt; limit; }</code> </pre> <br>     ,     . <br><br><h4> :     </h4><br>  sk-&gt;sk_rcvbuf (   sk_rcvqueues_full)        sysctl net.core.rmem_max. <br><br>     : <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.rmem_max=8388608</code> </pre> <br> sk-&gt;sk_rcvbuf    net.core.rmem_default,       sysctl. <br><br>       : <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.core.rmem_default=8388608</code> </pre> <br>     sk-&gt;sk_rcvbuf,   <a href="http://www.manpagez.com/man/2/setsockopt/">setsockopt</a>      SO_RCVBUF.   setsockopt   net.core.rmem_max. <br><br>     net.core.rmem_max,  setsockopt   SO_RCVBUFFORCE.  ,    ,   CAP_NET_ADMIN. <br><br>  sk-&gt;sk_rmem_alloc     skb_set_owner_r,     .         UDP. <br><br>  sk-&gt;sk_backlog.len     sk_add_backlog. <br><br><h4> udp_queue_rcv_skb </h4><br>          .   <a href="">net/ipv4/udp.c</a> : <br><br><pre> <code class="bash hljs">bh_lock_sock(sk); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sock_owned_by_user(sk)) rc = __udp_queue_rcv_skb(sk, skb); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sk_add_backlog(sk, skb, sk-&gt;sk_rcvbuf)) { bh_unlock_sock(sk); goto drop; } bh_unlock_sock(sk); <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> rc;</code> </pre> <br>  ,             .  <b></b> ,            __udp_queue_rcv_skb.  <b></b> ,     backlog-    sk_add_backlog. <br><br>       backlog',         release_sock  . <br><br><h4> __udp_queue_rcv_skb </h4><br>  __udp_queue_rcv_skb         sock_queue_rcv_skb.         ,  __udp_queue_rcv_skb   . <br><br>   <a href="">net/ipv4/udp.c</a> : <br><br><pre> <code class="cpp hljs">rc = sock_queue_rcv_skb(sk, skb); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> is_udplite = IS_UDPLITE(sk); <span class="hljs-comment"><span class="hljs-comment">/*  ,   ENOMEM   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rc == -ENOMEM) UDP_INC_STATS_BH(sock_net(sk), UDP_MIB_RCVBUFERRORS,is_udplite); UDP_INC_STATS_BH(sock_net(sk), UDP_MIB_INERRORS, is_udplite); kfree_skb(skb); trace_udp_fail_queue_rcv_skb(rc, sk); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h4>     UDP </h4><br>          UDP: <br><br><ul><li> /proc/net/snmp </li><li> /proc/net/udp </li></ul><br><h4> /proc/net/snmp </h4><br>  /proc/net/snmp,      UDP. <br><br><pre> <code class="bash hljs">$ cat /proc/net/snmp | grep Udp\: Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors Udp: 16314 0 0 17161 0 0</code> </pre> <br>      IP,     ,       ,   ,      . <br><br> InDatagrams: , : <br><br><ul><li> recvmsg       . </li><li> UDP-     . </li></ul><br> NoPorts: ,  UDP-    ,      . <br><br> InErrors: , : <br><br><ul><li>    , </li><li>   , </li><li>  sk_add_backlog    . </li></ul><br> OutDatagrams: ,  UDP-   ,    IP   . <br><br> RcvbufErrors: ,  sock_queue_rcv_skb     ;  ,  sk-&gt;sk_rmem_alloc    sk-&gt;sk_rcvbuf. <br><br> SndbufErrors: , : <br><br><ul><li>   IP       , </li><li>    , </li><li>     . </li></ul><br> InCsumErrors: ,      UDP.  ,    ,    , InCsumErrors    InErrors. ,  InErrors ‚Äî InCsumErros     . <br><br><h4> /proc/net/udp </h4><br>  /proc/net/udp,      UDP. <br><br><pre> <code class="bash hljs">$ cat /proc/net/udp sl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode ref pointer drops 515: 00000000:B346 00000000:0000 07 00000000:00000000 00:00000000 00000000 104 0 7518 2 0000000000000000 0 558: 00000000:0371 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 7408 2 0000000000000000 0 588: 0100007F:038F 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 7511 2 0000000000000000 0 769: 00000000:0044 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 7673 2 0000000000000000 0 812: 00000000:006F 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 7407 2 0000000000000000 0</code> </pre> <br>         : <br><br><ul><li> sl: -   . </li><li> local_address:       ,  :. </li><li> rem_address:       ,  :. </li><li> st:  .  ,    UDP,   ,    TCP.   , 7 ‚Äî  TCP_CLOSE. </li><li> tx_queue:         UDP. </li><li> rx_queue:         UDP. </li><li> tr, tm-&gt;when, retrnsmt:       UDP. </li><li> uid:   ,   . </li><li> timeout:     UDP. </li><li> inode:    (inode number),   .     ,      .  /proc/[pid]/fd,   symlink'  socket[:inode]. </li><li> ref:      . </li><li> pointer:  struct sock   . </li><li> drops:   ,    . </li></ul><br>        <a href="">net/ipv4/udp.c</a> . <br><br><h4>      </h4><br>          sock_queue_rcv.      ,     : <br><br><ol><li>       ,      .  ,       . </li><li> sk_filter     Berkeley Packet Filter,   . </li><li> sk_rmem_schedule  ,       ,   . </li><li>     skb_set_owner_r     .  sk-&gt;sk_rmem_alloc. </li><li>    __skb_queue_tail    . </li><li> ,       sk_data_ready   ,     . </li></ol><br>           ,    .       . <br><br><a name="13"></a><h2>  3.10.  Additional Information </h2><br>      ,       . <br><br><h4>    </h4><br>   ,         .  sysctl  ,   RPS       .      ,  RPS   .       . <br><br>   ,      ,       . <br><br>  <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/timestamping.txt">    </a>   ,    <a href="https://github.com/torvalds/linux/tree/v3.13/Documentation/networking/timestamping">-   </a> ! <br><br> ,         : <br><br><pre> <code class="bash hljs">$ sudo ethtool -T eth0 Time stamping parameters <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> eth0: Capabilities: software-transmit (SOF_TIMESTAMPING_TX_SOFTWARE) software-receive (SOF_TIMESTAMPING_RX_SOFTWARE) software-system-clock (SOF_TIMESTAMPING_SOFTWARE) PTP Hardware Clock: none Hardware Transmit Timestamp Modes: none Hardware Receive Filter Modes: none</code> </pre> <br>  ,        ,      .   ,         . <br><br><h4>        </h4><br>    ,  SO_BUSY_POLL.         ,       . <br><br>  :    ,      .  igb  3.13.0   .  ixgbe ‚Äî .     ,    ndo_busy_poll  struct net_device_ops ( ),    SO_BUSY_POLL. <br><br>  Intel <a href="http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/open-source-kernel-enhancements-paper.pdf"> </a> ,       . <br><br>       ,                    .         ,       . <br><br>     sysctl  net.core.busy_poll ‚Äî     poll  select         ( ). <br><br>     ,     CPU   . <br><br><h4> Netpoll:         </h4><br>  Linux             ,   . API     Netpoll.    ,   <a href="http://sysprogs.com/VisualKernel/kgdboe/launch/">kgdb</a>  <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/networking/netconsole.txt">netconsole</a> . <br><br> Netpoll   .      ndo_poll_controller      struct net_device_ops,    probe. <br><br>           ,     Netpoll,  ,      . <br><br>      __netif_receive_skb_core  <a href="">net/dev/core.c</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> __netif_receive_skb_core(struct sk_buff *skb, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> pfmemalloc) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      NAPI,  netpoll */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (netpoll_receive_skb(skb)) <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> out; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br>  Netpoll         Linux,       . <br><br>  Netpoll API    struct netpoll    netpoll_setup.        ,  API     . <br><br>     Netpoll API,    <a href="">netconsole</a> ,   Netpoll API, <a href="">'include/linux/netpoll.h`</a>  <a href="http://people.redhat.com/~jmoyer/netpoll-linux_kongress-2005.pdf">  </a> . <br><br><h4> SO_INCOMING_CPU </h4><br>  SO_INCOMING_CPU   Linux    3.19,    ,    . <br><br>  ,  CPU      ,   getsockopt   SO_INCOMING_CPU.           ,    CPU.           CPU. <br><br>   ,    ,  : <a href="https://patchwork.ozlabs.org/patch/408257/">patchwork.ozlabs.org/patch/408257</a> . <br><br><h4>  DMA </h4><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258F%25D0%25BC%25D0%25BE%25D0%25B9_%25D0%25B4%25D0%25BE%25D1%2581%25D1%2582%25D1%2583%25D0%25BF_%25D0%25BA_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">DMA</a> ‚Äî   ,   CPU    ,     .      DMA   ,   ,       CPU. <br><br>  Linux     DMA,      .        <a href="https://github.com/torvalds/linux/blob/v3.13/Documentation/dmaengine.txt">  </a> . <br><br>     DMA,          ‚Äî <a href="https://en.wikipedia.org/wiki/I/O_Acceleration_Technology">Intel IOAT DMA engine</a> . <br><br><h4>   I/O Intel (Intel's I/O Acceleration Technology (IOAT)) </h4><br>     <a href="http://www.intel.com/content/www/us/en/wireless-network/accel-technology.html">Intel I/O AT</a> ,      .    ‚Äî    DMA.     dmesg  ioatdma  ,         .  DMA    ,    ‚Äî   TCP. <br><br>   Intel IOAT    Linux 2.6.18,   3.13.11.10    -  <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/%3Fid%3D77873803363c9e831fc1d1e6895c084279090c22">,  </a> .     3.13.11.10      ioatdma. ,     . <br><br><h4>     (Direct cache access (DCA)) </h4><br>   ,   <a href="http://www.intel.com/content/www/us/en/wireless-network/accel-technology.html"> Intel I/O AT</a> ‚Äî Direct Cache Access (DCA). <br><br>     (  )       CPU.     .    igb     <a href="">igb_update_dca</a> ,   <a href="">igb_update_rx_dca</a> .  igb  DCA       . <br><br>   DCA,      BIOS, ,    dca         . <br><br><h4>   IOAT DMA </h4><br> ,     ,    ioatdma,         sysfs. <br>      memcpy  DMA-: <br><br><pre> <code class="bash hljs">$ cat /sys/class/dma/dma0chan0/memcpy_count 123205655</code> </pre> <br>    ,   DMA-: <br><br><pre> <code class="bash hljs">$ cat /sys/class/dma/dma0chan0/bytes_transferred 131791916307</code> </pre> <br><h4>   IOAT DMA </h4><br>  IOAT DMA   ,       ‚Äî copybreak.    ,            DMA     . <br><br>  copybreak   DMA: <br><br><pre> <code class="bash hljs">$ sudo sysctl -w net.ipv4.tcp_dma_copybreak=2048</code> </pre> <br>     4096. <br><br><a name="14"></a><h1> 4.  </h1><br>   Linux  .             (     ).        sysctl.conf,   ,        .        . <br><br>           ,   .    ,      ,    ,    . <br><br>  ,    . </div><p>Source: <a href="https://habr.com/ru/post/314168/">https://habr.com/ru/post/314168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314150/index.html">Hackers stole a billion rubles from four banks with the help of a bot</a></li>
<li><a href="../314152/index.html">What to tell about the company to get feedback from the developers (checklist)</a></li>
<li><a href="../314156/index.html">Enums + Associated Values ‚Äã‚Äã= Swift</a></li>
<li><a href="../314160/index.html">‚ÄúKeep your hand on the pulse and look around‚Äù - an interview about AI with Intento co-founder Gregory Sapunov</a></li>
<li><a href="../314166/index.html">No - hacking servers! Tips for verification and protection</a></li>
<li><a href="../314170/index.html">I'm technilid What to do?</a></li>
<li><a href="../314172/index.html">JavaScript and SEO in 2016</a></li>
<li><a href="../314174/index.html">Viral video research. How to create? How to promote?</a></li>
<li><a href="../314178/index.html">Human support, or how does the technical support service hosting provider FASTVPS</a></li>
<li><a href="../314180/index.html">Adding an avatar, cropping a photo on a mobile device and a desktop on JavaScript and PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>