<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pragmatic approach to performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Is premature optimization expensive to hell? Or does the ‚Äúlater correct‚Äù approach turn programmers from ‚Äúspecialists‚Äù into the despised by everyone ‚Äús...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pragmatic approach to performance</h1><div class="post__text post__text-html js-mediator-article">  Is premature optimization expensive to hell?  Or does the ‚Äúlater correct‚Äù approach turn programmers from ‚Äúspecialists‚Äù into the despised by everyone ‚Äúschool‚Äù? <br><br>  These questions do not have clear answers, however, in this article I will try to describe my own approach to performance.  What do I do to ensure that my systems work at a decent speed, but do not violate other requirements, such as modularity, maintainability and flexibility. <br><a name="habracut"></a><br><h1>  1. Time programmer - the end resource </h1><br>  If you are writing a large program, then some parts of the code will not work as fast as possible theoretical speed.  Sorry, paraphrase.  If you are writing a large program, then no part of the code will work as fast as possible theoretical speed.  Yes, I think it is worth realizing that any line of your code can be changed to work a little faster. <br><br>  Writing a fast program is not always necessary to achieve maximum performance.  You need acceptable performance where it matters.  If you spend three weeks optimizing a piece of code that is called once a year, then you could spend these three working weeks on something more meaningful.  If you spent them on something really important, then you could seriously improve the speed of drawing the game. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is always not enough time to add all the new features, fix all the bugs and optimize the whole code.  So the goal should be maximum performance for minimum effort. <br><br><h1>  2. Do not underestimate the power of simplicity. </h1><br>  Simple solutions are easier to implement than complex ones.  But this is only the tip of the iceberg.  The real charms of simple solutions appear over time.  A simple solution is easier to understand, easier to debug, easier to implement, easier to port, easier to profile, easier to optimize, easier to parallelize, and easier to replace.  Over time, all these advantages accumulate. <br><br>  Using a simple solution can save time, even if it is slower than a complex solution, because  In general, your program will work faster because you will spend the time saved to optimize other parts of it.  Those parts that are really important. <br><br>  I use complex solutions only then, of the year it is in fact justified.  For example, when a complex solution is much faster than a simple one (or a factor of 2, or something else), and when it is in the system, where it really matters (which consumes a significant percentage of processor time). <br><br>  Of course, simplicity is visible only for a specific person.  I find that arrays are simple.  I find the POD data types are simple.  I think the blobs are simple.  I do not think that classes with 12 levels of inheritance are simple.  I do not think that classes based on 8 different policies are simple.  I do not think that geometric algebra is simple. <br><br><h1>  3. Take everything from a chance to design a system. </h1><br>  Some people think that not engaging in ‚Äúpremature optimization‚Äù means developing a system without paying any attention to performance.  You need to blind something first, and then fix it when you are engaged in ‚Äúoptimization‚Äù. <br><br>  With this approach, I completely disagree.  And not because I love productivity for the sake of productivity, but from purely pragmatic interests. <br><br>  When you design a system, you have in your head a complete picture of how its various parts will dock, what requirements are imposed on them and how often certain functions will be called.  At this stage, not so much effort is needed to think a little more about how fast the system will work and how you organize the data structures so that it works as fast as possible. <br><br>  Conversely, if you build a system without regard to performance, and will be busy fixing it later, things may turn out to be much more complicated.  If you need to reorganize the basic data structures or enter support for multi-trading, it may turn out that you rewrite the entire system from scratch.  Only the system will already be in operation, and you will be limited to the published API and links to other systems.  In addition, you can not prevent breakage of projects that use the system.  And since by the time it takes several months as you (or someone else) wrote the code, you will have to start to remember and understand all the thoughts that went into it.  And all minor corrections and corrections that were made at the time of writing are likely to be lost.  And you will start debugging with an updated bag of bugs. <br><br>  So, following our general line ‚Äúgreater performance for less effort,‚Äù you can immediately notice that you should consider performance problems from the outset.  Just because it requires less effort than subsequent correction. <br><br>  Needless to be prudent.  Performance improvements are easier to introduce initially, but we cannot know exactly how much they will affect the system as a whole.  Later, after profiling, more effort will be needed, but we will know better what to focus on.  In general, as elsewhere in life - it is important to maintain a balance. <br><br>  When I design a system, I make a rough sketch of how often code sections are called per unit of time, and formulate design requirements: <br><ul><li>  1-10.  Performance is not important.  Do anything </li><li>  100. Make sure it is <a href="http://ru.wikipedia.org/wiki/%25C2%25ABO%25C2%25BB_%25D0%25B1%25D0%25BE%25D0%25BB%25D1%258C%25D1%2588%25D0%25BE%25D0%25B5_%25D0%25B8_%25C2%25ABo%25C2%25BB_%25D0%25BC%25D0%25B0%25D0%25BB%25D0%25BE%25D0%25B5">O (n)</a> , data oriented and can be cached. </li><li>  1000. Use multitrading </li><li>  10,000. Think about what you are doing. </li></ul><br>  There are also a few recommendations that I try to follow when writing new systems: <br><ul><li>  Static data add to permanent memory blocks </li><li>  Add dynamic data in adjacent memory locations </li><li>  Save memory </li><li>  Arrays are better than complex data structures </li><li>  Access memory linearly (simplifies caching) </li><li>  Make sure that the functions are executed in O (n) time. </li><li>  Avoid updates like "do nothing" - better watch for active objects </li><li>  If the system works with many objects - provide parallel access to data. </li></ul><br>  To date, I have written a lot of systems in such a ‚Äústyle‚Äù, and I do not need to make an effort to follow these recommendations.  And I made sure that by following them, I get decent basic performance.  These recommendations are among the most important and easily achievable points for increasing productivity: algorithm complexity, memory access and concurrency;  and most importantly, they provide significant performance gains with relatively little effort. <br><br>  Of course, it is not always possible to follow all the recommendations.  For example, some algorithms really take more than O (n) time.  But I know for sure that if I deviated from these recommendations, I need to slow down and think about whether I‚Äôll hurt performance. <br><br><h1>  4. Use top-down profiling to look for bottlenecks. </h1><br>  No matter how good your original architecture is, your code will slow down in unexpected places.  People will use your system in the craziest ways and find bottlenecks where you could not have imagined.  So there you have in the error code.  Some errors do not lead to the collapse of the system, but simply adversely affect performance.  And these will be mistakes that you couldn‚Äôt know in principle. <br><br>  To understand where your program is actually wasting time, the top-down profiler will be an invaluable tool.  We explicitly set the profiled parts of our code and transfer live data to an external tool over the network, which can visualize them in various ways: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12d/b9b/e55/12db9be555991925cb437a6d78432b22.jpg"><br>  <i>Screenshot of (old) BitSquid Profiler</i> <br><br>  Top-down profiling will tell you where to focus your optimization efforts.  Do you use 60% of your animation time and 0.5% of your interface time?  Get into animation, it will work, and the interface and penny is not worth it. <br><br>  Profiling from top to bottom, you can narrow and narrow segments of the code being profiled until you get to the performance problem - exactly the place where time is really spent. <br><br>  I use basic recommendations to achieve good baseline performance on all systems, and then I dig using top-down profiling to find a system that requires additional optimization efforts. <br><br><h1>  5. Use bottom-up profiling to search for low-level optimization goals. </h1><br>  In general, I find that top-down profiling with well-defined code segments is more useful than bottom-up profiling. <br><br>  But bottom-up profiling still has usage scenarios.  It is good for finding hot spots ‚Äî functions that are called from various parts of the program and which you can skip when profiling from top to bottom.  These hot spots can be good targets for low-level, instruction-by-instruction optimization.  Or their presence suggests that something is done incorrectly. <br><br>  For example, if the strcmp () function is displayed as a hot spot, then your program behaves very badly, and you should urgently put it in a corner and deprive the sweet tooth. <br><br>  A frequently occurring hot spot of our code is lua_Vexecute ().  What is not surprising.  This is the main function of the Lua VM, a large switch that runs most of the Lua code.  But this tells us that a low-level platform-specific optimization of this function can give a noticeable performance gain. <br><br><h1>  6. Avoid synthetic tests. </h1><br>  I do not do a lot of synthetic tests such as running the code in a loop 10,000 times and measuring the execution time. <br><br>  If I do a part in which I cannot immediately understand whether the code will be faster after the changes, I would rather use real game data.  Otherwise, I cannot be sure that I am not engaged in optimization for data that does not occur in real life. <br><br>  Testing 500 instances of the same entity that lose the same animation will differ from testing the same location, but with 50 different units, all of which have different animations.  Data access models will be completely different.  Optimization affecting only one case will not matter in the other. <br><br><h1>  7. Optimization is gardening </h1><br>  Programmers optimize the engine.  Script writers stuff things into it.  So it was, is and will be.  And this is good. <br><br>  Optimization is not an isolated process that happens in a strictly limited period of time.  This is part of the whole cycle: development, implementation and development.  Optimization is a non-stop dialogue between programmers and screenwriters about what should be in the engine. <br><br>  Improving the performance is the same as taking care of a garden: see that everything is good, weed weeds, figure out how to make plant life better. <br><br>  The task of the writers to drop the engine.  And the task of programmers is to raise it back, much more powerful.  And in the process of this confrontation, there is the point at which the game shines most clearly. <br><br><hr><br>  <i>Translated <a rel="author" href="https://plus.google.com/107862204079203068843%3Frel%3Dauthor">unconnected</a> .</i> <i><br></i>  <i>Original <a href="http://bitsquid.blogspot.com/2011/12/pragmatic-approach-to-performance.html">A Pragmatic Approach to Performance</a></i> <i><br><br></i>  <i>Happy New Year!</i>  <i>Write a lot of good and fast programs!</i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/135484/">https://habr.com/ru/post/135484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../135475/index.html">UserAndLINUX v11.12 magazine has been released</a></li>
<li><a href="../135476/index.html">New Year's domain infographics</a></li>
<li><a href="../135477/index.html">Olympiad FUPM MIPT programming for schoolchildren</a></li>
<li><a href="../135481/index.html">Image Loader. Closing topic</a></li>
<li><a href="../135483/index.html">Microsoft Virtual Academy opens</a></li>
<li><a href="../135486/index.html">Rating task managers used in web studios and online agencies of Russia</a></li>
<li><a href="../135487/index.html">Stop a project plan crash - you are an expert</a></li>
<li><a href="../135488/index.html">Created a social network for cleaning robots and their owners</a></li>
<li><a href="../135489/index.html">IdeaCentre B520 - 3D All-in-One Gaming Pack</a></li>
<li><a href="../135490/index.html">BOOL or BOOLEAN - that is the question?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>