<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Measuring the distance to the object and its speed</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I did not see the technology that I am going to introduce to you in the methods I found for determining the distance to an object in an image. It is n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Measuring the distance to the object and its speed</h1><div class="post__text post__text-html js-mediator-article">  I did not see the technology that I am going to introduce to you in the methods I found for determining the distance to an object in an image.  It is neither universal nor complex, its essence lies in the fact that the visible field (we will assume that we use a video camera) is calibrated with a ruler and then the coordinate of the object in the image is compared with the mark on the ruler.  That is, the measurement is conducted on a single line or axis.  But we do not need to keep a mark on the ruler for each pixel; the algorithm for calibration needs only to know the ruler size in pixels and in meters, as well as the pixel coordinate, which is the actual center of the ruler.  The obvious limitation - works only on flat surfaces. <br><br>  In addition to the method itself, the article describes its implementation in Python using the OpenCV library, and also discusses the features of receiving images from webcams in Linux using the video4linux2 API. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/8ee/ce8/126/8eece812645f43b934d24e5081f18a35.jpg" title="Distance measurement program window"></div><br><a name="habracut"></a><br>  In practice, it was necessary to measure the distance to the car and its speed on any straight stretch of road.  I used a long tape measure, stretched it to the side of the road, in the middle of the canvas, then set up the camera so that the entire tape measure just entered the camera's field of vision and was aligned with the X axis of the image.  The next step was to put something bright in the middle of the roulette, fix the camera so that it did not move away, and write down the coordinates of the pixel of this middle. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All calculations are reduced to a single formula: <br>  <i>l = L * K / (W / x - 1 + K)</i> , where <br>  <i>l</i> - the desired distance to the object, m; <br>  <i>L</i> - the length of the "line", m; <br>  <i>W</i> - the length of the "ruler" in pixels, usually the same as the width of the image; <br>  <i>x</i> - the coordinate of the object in the image; <br>  <i>K = (W - M) / M</i> is the coefficient reflecting the tilt of the camera, here <i>M</i> is the coordinate of the middle of the ‚Äúruler‚Äù. <br><br>  In the derivation of this formula, the school knowledge of trigonometry was very useful to me. <br><br>  The plot of this function is shown in the figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/e3a/aed/dc7/e3aaeddc76f8f330560a8ca9a4ccaa2d.jpg" title="Graph of the function L = 10, K = 0.3, W = 640"></div><br>  The greater the tilt of the camera, the steeper the graph.  In the boundary case, when the camera axis is perpendicular to the ‚Äúruler‚Äù plane ( <i>M = W / 2</i> ), the graph becomes a straight line. <br><br>  But the article would be too short, if this were the point.  Therefore, I decided to make a <a href="">demo program</a> that would connect to the webcam of the computer and monitor some object, calculating the distance to it and its speed.  As a programming language, I chose Python, a language with a very large number of advantages, to build a graphical user interface I chose the Tkinter framework that comes with Python, so it does not need to be installed separately.  OpenCV is good for tracking an object, I use version 2.2, but in the repository of the current version of ubuntu (10.10) there is only version 2.1, and their API has changed slightly for the better and the program under version 2.1 will not work.  In principle, it would be possible to build the entire program on OpenCV, placing the functions of a graphical interface and image capture on it, but I wanted to separate it from the main part of the program, so that it would be possible to replace this library with something else or simply remove it by turning off tracking. .  I started to recycle the old program, deleting everything unnecessary, and to my surprise there were only a few lines left from the program with direct calculation of distance and speed, which in principle was logical, since the program does not use the graphical interface in the original, follows the car according to another algorithm and and instead of a webcam, a megapixel network camera with an RTSP connection is used. <br><br>  As for obtaining images from the webcam, then not everything is so simple.  Under Windows, the program uses DirectX to connect to the camera via the <a href="http://videocapture.sourceforge.net/">VideoCapture</a> library, everything is quite simple here.  But under Linux there are very few intelligible articles about the use of webcams from Python, and those examples that exist usually do not work due to some regular API change.  In the past, I used ffmpeg for these purposes and the program was in C, but ffmpeg is a bit ‚Äúon the wheel of a cannon‚Äù, and I didn‚Äôt want to burden the end program with additional dependencies.  It was possible to use OpenCV, which also uses ffmpeg, but the way to write its own video4linux2 API wrapper for Python was chosen. <br><br>  The source codes were taken from the page of some <a href="http://staff.science.uva.nl/~bterwijn/Projects/V4L2/">science department</a> .  Of these, I quickly deleted everything unnecessary for my purpose, eventually leaving two edited files: <code>V4L2.cpp</code> and <code>V4L2.h</code>  This is actually the minimum required API for connecting to the webcam.  During the work on the Python wrapper, I found out that the video4linux2 devices can be accessed in three ways: READ, MMAP and STREAM, but only the MMAP method works with my webcams.  As it turned out, other examples of programs that did not work for me, used the READ method. <br><br>  It also implies that the webcam gives the image in YUYV format (YUV422), it differs from RGB in that it has 2 times less color information.  In YUYV, two pixels are encoded in 4 bytes, and in RGB, six, hence the saving in one and a half times.  Y is the brightness component, for each pixel it has its own.  U and V are the color difference components that define the color of a pixel, and so every two pixels use the same U and V. If you represent the stream of bytes from the webcam in this notation, it will look like YUYV YUYV YUYV YUYV YUYV YUYV 12 pixels.  You can figure out in which format your webcam works with the help of a VLC player, open an exciting device with it and then request information about the codec, it should be as in the figure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/425/346/55c/42534655ca1a80e3ce1da4c2d4f793f6.jpg" title="VLC player window with codec information"></div><br>  Here is the source code of the library for accessing the webcam: <br> <font color="grey"><code>main_v4l2.cpp</code></font> <br> <pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"V4L2.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstring&gt; #include &lt;iostream&gt; using namespace std; extern "C" { // Specify the video device here V4L2 v4l2("/dev/video0"); unsigned char *rgbFrame; float clamp(float num) { if (num &lt; 0) num = 0; if (num &gt; 255) num = 255; return num; } // Convert between YUV and RGB colorspaces void yuv2rgb(unsigned char y, unsigned char u, unsigned char v, unsigned char &amp;r, unsigned char &amp;g, unsigned char &amp;b) { float C = y - 16; float D = u - 128; float E = v - 128; r = (char)clamp(C + ( 1.402 * E )) ; g = (char)clamp(C - ( 0.344136 * D + 0.714136 * E )) ; b = (char)clamp(C + ( 1.772 * D )) ; } unsigned char *getFrame() { unsigned char *frame = (unsigned char *)v4l2.getFrame(); int i = 0, k = 0; unsigned char Y, U, V, R, G, B; for (i=0;i&lt;640*480*2;i+=4) { Y = frame[i]; U = frame[i+1]; V = frame[i+3]; yuv2rgb(Y, U, V, R, G, B); rgbFrame[k] = R; k++; rgbFrame[k] = G; k++; rgbFrame[k] = B; k++; Y = frame[i+2]; yuv2rgb(Y, U, V, R, G, B); rgbFrame[k] = R; k++; rgbFrame[k] = G; k++; rgbFrame[k] = B; k++; } return rgbFrame; } void stopCapture() { v4l2.freeBuffers(); } // Call this before using the device void openDevice() { // set format struct v4l2_format fmt; CLEAR(fmt); fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; // Adjust resolution fmt.fmt.pix.width = 640; fmt.fmt.pix.height = 480; fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV; if (!v4l2.set(fmt)) { fprintf(stderr, "device does not support used settings.\n"); } v4l2.initBuffers(); v4l2.startCapture(); rgbFrame = (unsigned char *)malloc(640*480*3); } }</span></span></span></span></code> </pre><br>  The algorithm is quite understandable - first open the device whose name is specified first ("/ dev / video0"), and then for each <code>getFrame</code> request we read the frame from the webcam, convert it to RGB format and give the link to the frame to the one who requested it.  I also provide a <code>Makefile</code> to quickly compile this library, if you need it. <br><br>  And here is the wrapper for this library for Python: <br> <font color="grey"><code>v4l2.py</code></font> <br> <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ctypes <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time lib = cdll.LoadLibrary(<span class="hljs-string"><span class="hljs-string">"linux/libv4l2.so"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VideoDevice</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> lib.openDevice() lib.getFrame.restype = c_void_p <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> buf = lib.getFrame() frame = (c_char * (<span class="hljs-number"><span class="hljs-number">640</span></span>*<span class="hljs-number"><span class="hljs-number">480</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span>)).from_address(buf) img = Image.frombuffer(<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">640</span></span>, <span class="hljs-number"><span class="hljs-number">480</span></span>), frame, <span class="hljs-string"><span class="hljs-string">'raw'</span></span>, <span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> img, time.time()</code> </pre><br>  As you can see absolutely nothing complicated.  The library is connected using the ctypes module.  There were no problems in writing the wrapper, except for the line: <br><br><pre> <code class="python hljs">frame = (c_char * (<span class="hljs-number"><span class="hljs-number">640</span></span>*<span class="hljs-number"><span class="hljs-number">480</span></span>*<span class="hljs-number"><span class="hljs-number">3</span></span>)).from_address(buf)</code> </pre><br>  To which I did not immediately come.  The fact is that if you read data from <code>getFrame()</code> as <code>c_char_p</code> , ctypes will interpret the data as a string with a zero ending, that is, as soon as zero is encountered in the byte stream, the reading will stop.  The same design allows you to clearly define how many bytes should be counted.  In our case, this is always a fixed value - 640 * 480 * 3. <br><br>  I will not give here the source code for getting the image in Windows, but it also does not differ in any complexity and is located in the archive in the <code>windows</code> folder with the name <code>directx.py</code> . <br><br>  And I‚Äôll give better the source code of the object tracking class, which, I remind, is written using OpenCV.  I took the example of <code>lkdemo.py</code> , supplied with OpenCV, as a basis, and again simplified it for our needs, modifying it in a class: <br> <font color="grey"><code>tracker.py</code></font> <br> <pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tracker</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"Simple object tracking class"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.grey = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.point = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.WIN_SIZE = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"Tell which object to track"</span></span> <span class="hljs-comment"><span class="hljs-comment"># It needs to be an array for the optical flow calculation self.point = [(x, y)] def takeImage(self, img): "Loads and processes next frame" # Convert it to IPL Image frame = cv.CreateImageHeader(img.size, 8, 3) cv.SetData(frame, img.tostring()) if self.grey is None: # create the images we need self.grey = cv.CreateImage (cv.GetSize (frame), 8, 1) self.prev_grey = cv.CreateImage (cv.GetSize (frame), 8, 1) self.pyramid = cv.CreateImage (cv.GetSize (frame), 8, 1) self.prev_pyramid = cv.CreateImage (cv.GetSize (frame), 8, 1) cv.CvtColor (frame, self.grey, cv.CV_BGR2GRAY) if self.point: # calculate the optical flow new_point, status, something = cv.CalcOpticalFlowPyrLK ( self.prev_grey, self.grey, self.prev_pyramid, self.pyramid, self.point, (self.WIN_SIZE, self.WIN_SIZE), 3, (cv.CV_TERMCRIT_ITER|cv.CV_TERMCRIT_EPS, 20, 0.03), 0) # If the point is still alive if status[0]: self.point = new_point else: self.point = None # swapping self.prev_grey, self.grey = self.grey, self.prev_grey self.prev_pyramid, self.pyramid = self.pyramid, self.prev_pyramid</span></span></code> </pre><br>  First we have to tell him which point we want to follow, for this is the <code>target</code> method.  Then we give it frame by frame using the <code>takeImage</code> method, it in turn converts the image frame into a format that it understands, creates the image necessary for the algorithm, converts the frame from color to grayscale and then feeds all of the <code>CalcOpticalFlowPyrLK</code> functions that <code>CalcOpticalFlowPyrLK</code> optical stream pyramidal method of Lucas-Canada.  At the output of this function, we get new coordinates of the point we are following.  If the point is lost, then <code>status[0]</code> will be zero.  Optical flow can be calculated not only for one point.  Run the <code>lkdemo.py</code> program with the webcam and see how well it handles a lot of points. <br><br>  I‚Äôll say more about converting images from the Python Imaging Library into the OpenCV format, the fact is that OpenCV for color images uses a different order of color components - BGR, for full conversion you would have to add <code>cv.CvtColor(frame, frame, cv.CV_BGR2RGB)</code> , but most of the tracking algorithms are absolutely still confused with your color components or not, our example generally uses only black and white images.  Therefore, this line can not be included in the code. <br><br>  I also do not cite the source code of the class in the article for directly calculating the distance, since there is only the simplest mathematics.  It is located in the file <code>distance_measure.py</code> . <br><br>  It remains only to show the source code of the main script, which forms the graphical interface and loads all other modules. <br> <font color="grey"><code>main.py</code></font> <br> <pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> distance_measure <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Calculator <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> webcam <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> WebCam <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tracker <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Tracker <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> Tkinter <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ImageTk <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PILImageTk <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GUIFramework</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Frame)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"This is the GUI"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self,master=None)</span></span></span><span class="hljs-function">:</span></span> Frame.__init__(self,master) self.grid(padx=<span class="hljs-number"><span class="hljs-number">10</span></span>,pady=<span class="hljs-number"><span class="hljs-number">10</span></span>) self.distanceLabel = Label(self, text=<span class="hljs-string"><span class="hljs-string">'Distance ='</span></span>) self.distanceLabel.grid(row=<span class="hljs-number"><span class="hljs-number">0</span></span>, column=<span class="hljs-number"><span class="hljs-number">0</span></span>) self.speedLabel = Label(self, text=<span class="hljs-string"><span class="hljs-string">'Speed ='</span></span>) self.speedLabel.grid(row=<span class="hljs-number"><span class="hljs-number">0</span></span>, column=<span class="hljs-number"><span class="hljs-number">1</span></span>) self.imageLabel = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.cameraImage = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.webcam = WebCam() <span class="hljs-comment"><span class="hljs-comment"># M = 510, L = 0.5, W = 640 self.dist_calculator = Calculator(500, 0.5, 640, 1) self.tracker = Tracker() self.after(100, self.drawImage) def updateMeasure(self, x): (distance, speed) = self.dist_calculator.calculate(x, time.time()) self.distanceLabel.config(text = 'Distance = '+str(distance)) # If you want get km/h instead of m/s just multiply # m/s value by 3.6 #speed *= 3.6 self.speedLabel.config(text = 'Speed = '+str(speed) + ' m/s') def imgClicked(self, event): """ On left mouse button click calculate distance and tell tracker which object to track """ self.updateMeasure(event.x) self.tracker.target(event.x, event.y) def drawImage(self): "Load and display the image" img, timestamp = self.webcam.getImage() # Pass image to tracker self.tracker.takeImage(img) if self.tracker.point: pt = self.tracker.point[0] self.updateMeasure(pt[0]) # Draw rectangle around tracked point img.paste((128, 255, 128), (int(pt[0])-2, int(pt[1])-2, int(pt[0])+2, int(pt[1])+2)) self.cameraImage = PILImageTk.PhotoImage(img) if not self.imageLabel: self.imageLabel = Label(self, image = self.cameraImage) self.imageLabel.bind("&lt;Button-1&gt;", self.imgClicked) self.imageLabel.grid(row=1, column=0, columnspan=2) else: self.imageLabel.config(image = self.cameraImage) # 30 FPS refresh rate self.after(1000/30, self.drawImage) if __name__ == '__main__': guiFrame = GUIFramework() guiFrame.mainloop()</span></span></code> </pre><br>  As I said above, I chose the Tkinter library to create a graphical interface, I worked with other toolkits, such as GTK, QT and, of course, wxPython, but they needed to be installed additionally, while Tkinter works right away and it is quite is easy to use, however, a complex interface on it, of course, cannot be created, but its capabilities are more than enough for the task.  In class initialization, I create a grid <code>grid</code> to position other widgets in it: two text fields and one image.  With Tkinter, I didn‚Äôt even have to separately create streams for downloading images from a webcam, because there is an <code>after</code> method that allows you to perform the specified function after a certain period of time.  You can update the text and image with the <code>Label</code> method <code>config</code> .  Very simple!  Handling a mouse click event with the <code>bind</code> method is translated to the <code>imgClicked</code> method. <br><br>  The image and its timestamp are <code>self.webcam.getImage</code> by the <code>self.webcam.getImage</code> function.  The webcam module just simply loads the appropriate module for working with the webcam, depending on which operating system the program is running under. <br><br>  Once again I will provide a link to the archive with the program - <a href="">distance-measure</a> . <br>  Required packages for ubuntu: python, python-imaging, python-imaging-tk, opencv version 2.2, and build-essential to compile the V4L2 wrapper. <br>  The program runs through: <br> <code>python main.py</code> <br>  To start tracking an object, you need to click on it. <br><br>  That's all. <br><br><h4>  useful links </h4><br><ul><li>  <a href="http://opencv.willowgarage.com/wiki/">Opencv wiki</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Optical_flow">Optical flow</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/V4L2">Video4Linux2</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/YUV">YUV color model</a> </li><li>  <a href="http://www.russianlutheran.org/python/summary/summary.htm">Tkinter Short Review</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/115661/">https://habr.com/ru/post/115661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115653/index.html">Notification of JavaScript errors in the address bar</a></li>
<li><a href="../115654/index.html">Opera 11.10 beta 1 - the first fish</a></li>
<li><a href="../115655/index.html">Two more ways to make stereo photos. Fast and free</a></li>
<li><a href="../115657/index.html">Website creation by means of maven</a></li>
<li><a href="../115658/index.html">Automatic notification of readers about the news using VKontakte. Part 2</a></li>
<li><a href="../115663/index.html">Google fights AdWords' replica ads</a></li>
<li><a href="../115665/index.html">PHP 5.3.6 release</a></li>
<li><a href="../115666/index.html">Firefox 4 may be released next week.</a></li>
<li><a href="../115668/index.html">Cheers, Blackberry Playbook in Russia !!! Have questions?</a></li>
<li><a href="../115669/index.html">Information danger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>