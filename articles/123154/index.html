<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Million Concurrent Connections on Node.js</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL; DR: 


- Node.js v0.8 allows you to handle 1 million simultaneous HTTP Comet connections to the Intel Core i7 Quad / 16 Gb RAM with almost no addi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Million Concurrent Connections on Node.js</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/9b1/772/d42/9b1772d4272f590fc657153a60a01f2a.png"><br><br><h2>  TL; DR: </h2><br><ul><li>  Node.js v0.8 allows you to handle 1 million simultaneous HTTP Comet connections to the Intel Core i7 Quad / 16 Gb RAM with almost no additional settings. </li><li>  A little more than 10 Kb of memory is spent per connection (4.1 Kb Javascript Heap + 2.2 Kb Node.js Native + 3.8 Kb Kernel) .. </li><li>  V8 Garbage Collector is not designed to manage&gt; ~ 500Mb of memory.  If you exceed, you need to switch to an alternative garbage collection mode, otherwise the server ‚Äúresponsiveness‚Äù will be greatly reduced. </li><li>  Such an experience can (and should be!) Cost-effectively repeat itself (see under the cut). </li></ul><br><a name="habracut"></a><br><h2>  Introduction </h2><br>  In foreign blogs, several tests of the maximum number of simultaneous connections were considered, from the classic <a href="http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-1">A Million User Comet Applicaction with Mochiweb / Erlang</a> , to the very recent <a href="http://blog.caustik.com/2012/04/10/node-js-w250k-concurrent-connections/">Node.js w / 250k concurrent connections</a> .  What I would like to achieve in my test is recurrence.  So that others can repeat without any problems and get their test results.  All the code that was used in the tests is laid out on github: <a href="https://github.com/ashtuchkin/node-millenium">server</a> and <a href="https://github.com/ashtuchkin/ec2-fleet">client</a> , welcome. <br><br><h3>  Server </h3><br><h4>  1. Iron </h4><br>  Of course, you need a Dedicated Server to conduct such tests.  Order it from your favorite host or use an existing one.  I used <a href="http://www.hetzner.de/hosting/produkte_rootserver/ex4">Hetzner EX4</a> (Core i7-2600 Quad, 16Gb RAM), it is quite cheap and powerful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  2. Operating system </h4><br>  I am using Ubuntu 12.04 LTS.  Perhaps my test can be used in other Linux-s, with minor changes.  Most likely this is not a ride on other OS.  There is a lot of talk on the network about setting up Linux for a large number of connections.  What pleases, almost none of this is needed: <br><br><pre><code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta">#/etc/security/limits.conf #     (    </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta"> ). * - nofile 1048576</span></span></code> </pre> <br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta">#/etc/sysctl.conf # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  netfilter/iptables,     : net.ipv4.netfilter.ip_conntrack_max = 1048576</span></span></code> </pre><br><br><h4>  3. Code for Node.js </h4><br>  All tests use Node.js v0.8.3. <br>  We use the standard <a href="http://nodejs.org/api/cluster.html">cluster</a> module to distribute the load on several processes (by the number of cores).  Disable <a href="http://en.wikipedia.org/wiki/Nagle%2527s_algorithm">the Nagle algorithm</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Server.js () var cluster = require('cluster'); var config = { numWorkers: require('os').cpus().length, }; cluster.setupMaster({ exec: "worker.js" }); // Fork workers as needed. for (var i = 0; i &lt; config.numWorkers; i++) cluster.fork()</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Worker.js () var server = require('http').createServer(); var config = {...}; server.on('connection', function(socket) { socket.setNoDelay(); //   . }); var connections = 0; server.on('request', function(req, res) { connections++; //   ''  20  // = 50     1   var pingInterval = setInterval(function() { res.write('ping'); }, 20*1000); res.writeHead(200); res.write("Welcome!"); res.on('close', function() { connections--; clearInterval(pingInterval); pingInterval = undefined; }); }); server.listen(config.port);</span></span></code> </pre><br><br>  For the convenience of monitoring what is happening, I added tracking and displaying of a variety of system parameters in the terminal, as well as their logging.  You can run this miracle of interactivity on your server as follows: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/ashtuchkin/node-millenium.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> node-millenium <span class="hljs-comment"><span class="hljs-comment">#     8888. node server.js</span></span></code> </pre><br><br>  We get a picture similar to this: <br><img src="http://habrastorage.org/storage2/89f/353/017/89f3530177044739b4dfc7f79395bded.png"><br><br>  Here it is necessary to note the following: <br><ol><li>  The percentages of CPU utilization are everywhere given based on the number of cores.  Those.  on a 4-core processor, the maximum load is 400%. </li><li>  The 'used' memory does not include buf + cache.  Those.  should be used + free + (buf + cache) = total memory on the server. </li><li>  For each process, its pid, processor load share (user + sys), RSS memory, number of connections, heapUsed / heapTotal according to os.memoryUsage () readings, three dimensions of the process ‚Äúresponsiveness‚Äù (ticks, see below) are displayed. </li></ol><br>  What is this ‚Äúresponsiveness‚Äù of the process?  Conventionally, this is how long it will take to wait for an event before the Event Loop Node.js will process it.  This parameter is fundamental in applications that count on at least some real-time, but it is quite difficult to calculate. <br><br>  We will measure it as follows: <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Node.js      10     . var ticks = []; setInterval(function() { ticks.push(Date.now()); }, 10); //    . setInterval(function() { // 1.    : ticks[i] = ticks[i+1]-ticks[i] // 2.     ticks   (tick-avg), 90-    (tick-max). // 3.         . ticks.length=0; }, 1000);</span></span></code> </pre><br>  I want to separately note that the measurement interval of 10 ms was chosen as the balance between the error and add.  system load.  If 10/10 / 10ms is displayed, this does not mean that Node.js spends 10 ms to process each event.  This means that with a measurement grid of 10 ms, the Event Loop is free every time and is ready to process any incoming event at once, which means that the average event processing time is much lower.  If the Garbage Collector comes into action, or long operations, then we will instantly see and fix it. <br><br>  The log is in the CSV format, where once per second all aggregate statistics of the system are noted (see the list on the <a href="">github</a> ). <br><br><h3>  Customers </h3><br>  Oddly enough, it was more difficult to provide the necessary load than to create a server.  The fact is that a TCP connection is uniquely identified by a four [source ip, source port, dest ip, dest port], so from one machine to one server port you can create no more than 64 thousand simultaneous connections (by the number of source ports).  It would be possible to create 16 network interfaces with different IP, as described <a href="http://www.metabrew.com/article/a-million-user-comet-application-with-mochiweb-part-3">here</a> , but it is difficult when the machine is hosted. <br><br>  As a result, it was decided to use Amazon EC2 Micro Instances at 2 cents per hour.  It was found out that such a machine, due to limitations on the processor and, especially, memory, stably holds about 25 thousand connections.  Thus, 40 running instances will provide us with 1 million connections and will cost $ 0.8 per hour.  It is quite acceptable. <br><br>  Separately, it must be said that by default, Amazon will not allow you to raise more than ~ 20 instances in one region.  You can either make a request to increase this limit, or raise instances in several regions.  I chose the latter. <br><br>  First, I set up one machine and copied it 40 times using the Custom AMI creation mechanism ‚Äî this is easy to do via the web interface.  However, it turned out to be too difficult to maintain and uncontrollable, so I switched to another mechanism: <a href="http://alestic.com/2009/06/ec2-user-data-scripts">User Data</a> and <a href="https://help.ubuntu.com/community/CloudInit">Cloud Init</a> . <br><br>  In short, it works like this: Ubuntu standard images are used (they are different in each region) and the script is specified as a parameter when the instance starts.  It is executed on the instance immediately after it is raised.  In this script, I install Node.js on a bare system, write the necessary files, and launch the node that listens to a specific port.  Further, on this port you can find out the server status, as well as give it commands, for example, how many connections to establish with which ip address.  The time from the team to the working "drone" is about 2 minutes. <br><br>  What is nice - <a href="">the client code</a> can be edited before each instance is launched. <br><br>  You can try it yourself using the <a href="https://github.com/ashtuchkin/ec2-fleet/">ec2-fleet</a> project and the following commands: <br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/ashtuchkin/ec2-fleet.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ec2-fleet <span class="hljs-comment"><span class="hljs-comment">#     npm install #    accessKeyId, accessKeySecret     Amazon. # https://portal.aws.amazon.com/gp/aws/securityCredentials # ,        (  ) # !         Security Group 'default'   # TCP  8889  source 0.0.0.0/0 -       . nano aws-config.json # , , 10    . #     . ,     . ./aws.js start 10 #      (  top).     . ./aws.js status #   (,     ,   ) ./aws.js set host &lt;ip&gt; #     1000  ./aws.js set n 1000 #    - 25000  ./aws.js set n 25000 #     .    . ./aws.js set restart 1 #      .  -  . ./aws.js stop all</span></span></code> </pre><br><br><h2>  Tests </h2><br>  Well, let's start testing.  Here and in the following tests we will make 1 million connections, 50 thousand messages per second at all.  Node.js version v0.8.3.  Processing will be carried out in 8 processes ("workers") by the number of server cores. <br><br><h3>  node server.js </h3><br>  In the first test, we will run node.js without additional flags, in the standard configuration itself.  Begin the first test (all pictures are clickable): <br> <a href=""><img src="http://habrastorage.org/storage2/cfd/7ea/0d4/cfd7ea0d44f43c243b821b7fd38a02bb.png"></a> <br><br>  On all charts, the black dotted line indicates the number of connections, with a maximum value of 1 million. Horizontally, seconds from the beginning of the test, vertical lines mark the minutes.  The memory graphs show: Total - the total number of used memory (recall, testing was conducted on a server with a total memory of 16 Gb), Total netto - an increase in Total compared to the first second (was entered because some more my projects, in total they occupy ~ 1.3 Gb), RSS mem, JS Heap Total, JS Heap Used - the total value of RSS (link), JS Heap Total, JS Heap Used of all processes node.js. <br><br>  Visually, the size of the gray area indicates the amount of memory allocated by the kernel, the yellow area indicates the node.js native structures, and the green area indicates JS Heap. <br><br>  As you can see, Total netto at the peak is 10 Gb and is stable.  After the experiment, all the parameters are returned to almost the original values ‚Äã‚Äãexcept for the node.js native structures.  We return to them below. <br><br>  CPU load on the same test: <br> <a href=""><img src="http://habrastorage.org/storage2/cfc/ffb/edd/cfcffbedd332247ecbc21b9f9edb16b0.png"></a> <br><br>  Everything is easier here - 8 cores = 800%.  Total - total load, CPU (practically coincides with Total) - total load of processes node.js, User, Sys - total load in User mode and the core, respectively.  The lines are smoothed by a moving average of 10 seconds. <br><br>  This chart, to be honest, disappointed me.  The download is too big, and it is not clear what it is spent on.  Receiving connections was normal, about 5-7 thousand connections per second, apparently, this scenario is well optimized.  However, a much greater load is created by detachment, especially in large batches (on the graph for about 3 minutes, 800% of the load when I tried to break 400 thousand connections at once). <br><br>  Let's see how the Event Loop behaves: <br> <a href=""><img src="http://habrastorage.org/storage2/902/f19/99e/902f1999eff4769635cb4ae97605108f.png"></a> <br><br>  This graph shows the average values ‚Äã‚Äãof tick-avg for 8 workers (unfortunately, the tick-max could not be restored because of the bug).  Scale logarithmic to reflect large fluctuations.  The yellow line shows the moving average for 20 seconds. <br>  As you can see, on average, with 1 million connections to the Event Loop, it is possible to get access only 10 times per second (yellow line ~ 100 ms).  It is simply no good.  When 400 thousand connections are disconnected, the average event processing time increases to 400 ms. <br><br>  After using Google for its intended purpose and conducting several experiments on a smaller scale, it was found out that the main part of the load is caused by the Garbage Collector, who often tries to collect extra memory using the ‚Äúheavy‚Äù Mark &amp; ‚Äã‚ÄãSweep algorithm (there are two of them in the V8 - there is also ‚Äúlightweight‚Äù Scavenge) .  Responsibility for this behavior lies somewhere on the border between Node.js and V8, and is associated with the Idle Notification mechanism.  In short, this is a signal to V8 that the work is not being done now and there is time to clean up the garbage that Node.js is abusing, especially if JS HeapTotal&gt; 128Mb. <br><br><h3>  node --nouse-idle-notification server.js </h3><br>  Fortunately, we can turn off this signal by adding the "--nouse-idle-notification" flag.  Let's see what it will give us in the second test: <br> <a href=""><img src="http://habrastorage.org/storage2/508/340/6bc/5083406bc625302148798ca5aa629090.png"></a> <br><br>  First, it can be noted that the memory consumption increased by 1 GB (10%) and stabilized approximately 5 minutes after the last connection, which is generally not bad.  Also, the "sawtooth" character of the chart is visible.  Why? <br><br>  Let's look at the graph of memory consumption of one worker in a simplified test: <br> <a href=""><img src="http://habrastorage.org/storage2/db5/0ba/a62/db50baa62678d20addca42d380e564fe.png"></a> <br><br>  Now it is clear - about every 5 minutes garbage is collected in each worker, forming a ‚Äúsaw‚Äù in the graph of the total memory. <br><br>  We look at the processor and Event Loop: <br> <a href=""><img src="http://habrastorage.org/storage2/908/210/7cf/9082107cf4605c508df3c2321c77a6a8.png"></a> <br> <a href=""><img src="http://habrastorage.org/storage2/73f/d47/c76/73fd47c76c3ab91c18734658b28117be.png"></a> <br><br>  Well, so much better!  1 million connections load from 2 to 3 cores out of 8. <br><br>  Now let's see if the Garbage Collector does well without IdleNotification in the third test: <br> <a href=""><img src="http://habrastorage.org/storage2/e90/270/2bc/e902702bcfa8c7f86edfcea9729c41ba.png"></a> <br><br>  From this graph, it can be seen firstly that the yellow area (Node.js native structures) still did not leak, but was being reused.  Secondly, garbage collection could be better. <br><br><h3>  node --nouse-idle-notification --expose-gc server.js </h3><br>  Well, take the garbage collection in your hands.  Run node.js with the "--expose-gc" flag and call gc ();  once a minute in the fourth test: <br> <a href=""><img src="http://habrastorage.org/storage2/126/ed6/e86/126ed6e86d923f804526cbdecc7c9e24.png"></a> <br> <a href=""><img src="http://habrastorage.org/storage2/63a/0c0/71b/63a0c071bf228d5a6f53865cd9f7c481.png"></a> <br> <a href=""><img src="http://habrastorage.org/storage2/9d2/f24/94b/9d2f2494bae81f70f8194883e2a7b7a3.png"></a> <br><br>  Well, not bad.  Memory is released quite quickly, the processor is under control, but once a minute we have bursts of tick-avg.  I think this is a good compromise. <br><br><h2>  What's next? </h2><br><br>  First, it is necessary to confirm the results by independent testing.  I did everything to make it easy.  Please, if you have a good machine idle, try to make my own way - this is very interesting. <br><br>  Secondly, it is clear that this benchmark is far from reality.  As an interesting real-world application, it would be good to build an analogue of a jabber-server and test it on the same volumes. <br>  In any case, I hope that the current framework will help the Node.js and V8 developers in further optimization. <br><br>  Thirdly, you need to conduct more experiments to clarify: <br><ul><li>  What does enable / disable the Nagle algorithm (socket.setNoDelay ())? </li><li>  One message in 20 seconds per connection is quite small.  How many messages per second can the server handle?  Perhaps this will be a limitation on real projects. </li><li>  You can more accurately determine the kernel's memory allocation for sockets using / proc / sockstat. </li><li>  Why is the yellow area not released (Node.js native)?  What is it?  How can this be fixed? </li><li>  Why closing sockets loads the processor much more than opening them? </li><li>  Try playing with the kernel settings for TCP, and also turn off the netfilter / conntrack / iptables module, maybe it will have a positive effect on the memory. </li><li>  Using the method with 40 AWS instances, try to load servers with other technologies - Erlang, Java NIO, Twisted, etc.  Compare features. </li><li>  How fast is interprocess communication going?  Is it possible to transmit an open descriptor between processes, grouping them into rooms, to localize the interaction between clients?  This will greatly help in a real project. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/123154/">https://habr.com/ru/post/123154/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123142/index.html">USB dongle support in Thinstation</a></li>
<li><a href="../123143/index.html">10 ways to improve your programming skills</a></li>
<li><a href="../123145/index.html">Overview of the SPI bus and development of the driver of the slave SPI device for embedded Linux (Part one, overview)</a></li>
<li><a href="../123151/index.html">Calculate Linux 11.6</a></li>
<li><a href="../123152/index.html">The problem with updating statistics of active installations on the Android Market</a></li>
<li><a href="../123156/index.html">Thunderbolt cable - what's inside?</a></li>
<li><a href="../123157/index.html">How to distribute invites on Google+</a></li>
<li><a href="../123159/index.html">Hiccuper - Reviews on everything in the world</a></li>
<li><a href="../123160/index.html">Google+ for Android</a></li>
<li><a href="../123161/index.html">New Gmail Design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>