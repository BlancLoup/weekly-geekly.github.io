<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 2</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <br>  Lecture 8: "Model of network security" <a href="https://habr.com/company/ua-hosting/blog/418229/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/423155/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/423423/">Part 3</a> <br>  Lecture 9: "Web Application Security" <a href="https://habr.com/company/ua-hosting/blog/424289/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/424295/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/424297/">Part 3</a> <br>  Lecture 10: "Symbolic execution" <a href="https://habr.com/company/ua-hosting/blog/425557/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425561/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/425559/">Part 3</a> <br>  Lecture 11: "Ur / Web programming language" <a href="https://habr.com/company/ua-hosting/blog/425997/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/425999/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/426001/">Part 3</a> <br>  Lecture 12: "Network Security" <a href="https://habr.com/company/ua-hosting/blog/426325/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427087/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427093/">Part 3</a> <br>  Lecture 13: "Network Protocols" <a href="https://habr.com/company/ua-hosting/blog/427763/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427771/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427779/">Part 3</a> <br>  Lecture 14: "SSL and HTTPS" <a href="https://habr.com/company/ua-hosting/blog/427783/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/427785/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/427787/">Part 3</a> <br>  Lecture 15: "Medical Software" <a href="https://habr.com/company/ua-hosting/blog/428652/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/428654/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/428656/">Part 3</a> <br>  Lecture 16: "Attacks through the side channel" <a href="https://habr.com/company/ua-hosting/blog/429390/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/429392/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/429394/">Part 3</a> <a name="habracut"></a><br><br>  <b>Audience:</b> how to determine x and y first? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Professor:</b> for this you have to look at the exhibitor in the binary representation.  Suppose I try to calculate the value of c <sup>1011010</sup> , the degree may consist of a larger number of bits.  If we want to do a repeated squaring, then we need to look at the lowest bit - here it is 0. <br><br><img src="https://habrastorage.org/webt/w_/6d/9i/w_6d9ilu4jpxs9k9sa-myz5wlog.jpeg"><br><br>  Thus, we have the equality c <sup>1011010</sup> = (c <sup>101101</sup> ) <sup>2</sup> <br><br>  Next, we need to calculate c <sup>101101</sup> , here we cannot use this rule, because it is not 2x - it will be x plus 1. Therefore, we write this equality: <br><br>  c <sup>101101</sup> = (c <sup>10110</sup> ) <sup>2</sup> c, because this prefix is ‚Äã‚Äã101101 = 10110 + 1. <br><br>  Therefore, we multiply the square by c, so we use it for re-squaring. <br><br>  For sliding windows, we need to capture more bits from the lower end.  If you want to do a ‚Äúsliding window‚Äù trick here instead of extracting one from here, then with this huge table we can take 3 bits at a time, clinging to c7.  If we take the first 3 bits of the degree, we get c <sup>101101</sup> = (c <sup>101</sup> ) <sup>8</sup> c <sup>101</sup> . <br><br>  In this case, we really have the same amount of calculations for (c <sup>101</sup> ) <sup>8</sup> , but you can see the value of c <sup>101</sup> in the table.  And the part in the form (c <sup>101</sup> ) <sup>8</sup> says that you are going to use the ‚Äúsliding windows‚Äù to calculate its value. <br><br><img src="https://habrastorage.org/webt/zw/ok/iz/zwokizdxzsucmo17lyvarjp0m1o.jpeg"><br><br>  This saves a lot of time, as it allows you to use pre-multiplied values.  10 years ago, it was believed that a table of values ‚Äã‚Äãup to 32 degrees is the optimal plan in terms of computational efficiency, because there is some kind of compromise, right?  You spend time creating this table, but it should not be too large if you are not going to use some records often.  Suppose if you create a table of values ‚Äã‚Äãup to c <sup>500</sup> degrees, but you are not going to use exponents with a value greater than 128, then you just waste your time. <br><br>  <b>Audience:</b> Is there a reason not to create such a giant table in advance?  That is, to calculate the values ‚Äã‚Äãof a limited number of degrees that can be dispensed with in calculations? <br><br>  <b>Professor:</b> if you do not want to make volume calculations in advance ... well, there are two things here.  One is that then you must have a code to check whether the required entry is filled in the table or not, and this will probably reduce the accuracy of prediction of the branches of the CPU process.  In this case, in general, the processor will work more slowly, because it will have to check whether there is a necessary entry in the table.  The second thing, which is somewhat annoying, may be the leakage of table entries through various side channels, namely through cache access patterns.  So if you have some other process running on the same processor, you can see which cache addresses are being removed from the cache or are slowing down because someone has access to the c <sup>3</sup> entry or the c <sup>31</sup> entry.  And the more this table becomes, the easier it is to determine which exponent bits are used when creating the RSA key. <br><br>  This giant table is able to tell which cache address was lost for the processor, that is, indicates that the encryption process should have access to this entry in the table.  In turn, this tells you that a given sequence of bits appears in the exponent of your secret key.  Therefore, I assume that mathematically you can fill this table as much as you need, but in practice you do not want it to turn out to be gigantic in size.  In addition, you will not be able to effectively use huge table entries.  It is much more useful to use the records of a relatively small table again, for example, to calculate c <sup>7,</sup> you can use the value c <sup>3</sup> twice and so on. <br><br>  So, this is what RSA optimization is about by means of re-squaring and ‚Äúsliding window‚Äù.  I don‚Äôt know if they are still using this ‚Äúsliding window‚Äù size, but in any case it speeds up the calculation process, because otherwise you would have to square each bit of the exponent and then multiply by each bit.  Therefore, if you have a 500-bit exponent, then you would have to perform 500 squaring and about 256 multiplications per c.  With the ‚Äúsliding windows‚Äù you will still have to make 512 squaring, because you cannot avoid it, but the number of multiplications by c will decrease from 256 to about 32 by using records from the table. <br><br>  This is the general optimization plan, which speeds up the calculation process by about one and a half times.  This is a fairly simple optimization.  There are two clever tricks with numbers to make the multiplication process more efficient. <br><br>  The first is the Montgomery transformation, in a second we will see why this is especially important for us.  This optimization is trying to solve for us the problem, which is that each time we multiply, we get a number that continues to grow and grow.  In particular, both in the ‚Äúsliding windows‚Äù and in the repeated quadration, you actually multiplied 2 numbers together when you raised c to the power of y. <br><br>  The problem is that if the input data c <sup>x</sup> and c <sup>y</sup> for multiplication was the size of, say, 512 bits each, then the size of the multiplication result will be 1000 bits.  After that, you take this 1000-bit result and again multiply it by something like 512 bits, it becomes 1500, 2000, 2500 bits in size and everything grows and grows. <br><br>  However, you do not want this, because multiplication increases the order of the multiplied numbers.  Because of this, we have to keep the size of our number as small as possible, mostly equal to 512 bits, because all these calculations are mod p or mod q. <br><br>  We can reduce this number, let's say we want to calculate (((c <sup>x</sup> ) <sup>2</sup> ) <sup>2</sup> ) <sup>2</sup> .  What you could do is, for example, calculate cx modulo p, then square it again modulo p and square again modulo p.  This method is relatively good, as it allows us to keep the size of our number within 512 bits, that is, as little as we can get.  This is good in the sense of reducing the size of the numbers that we need to multiply, but in fact the operation with this module p significantly increases the cost of the calculation. <br><br><img src="https://habrastorage.org/webt/j2/8z/p2/j28zp2waavtrlhxb_agi5dedmh8.jpeg"><br><br>  Because the way you get mod p is to divide.  And division is worse than multiplication.  I will not list the algorithms for division, but this is very slow.  Usually you try to avoid division operations as much as possible, because this is not simple programming.  The fact is that you need to use some approximation algorithms, Newton's methods, and the like, and all this will slow down the computation process. <br><br>  Multiplication is much more profitable, but using mod p or mod q operations to reduce the size of numbers is more expensive than multiplication.  I will show you how to avoid this and how to do quick calculations using the Montgomery transform. <br><br>  The basic idea is to represent the integers you are going to multiply in the form of the Montgomery transform.  In fact, it is very easy.  To do this, we simply multiply our number and by some magical value R. In a second I will tell you what it is.  But let's first find out what happens here when we choose an arbitrary value of R. <br><br>  So, we take 2 numbers, a and b, and convert them into a Montgomery representation, multiplying each by R. Then the product of a and b in the Montgomery transformation will look like this: <br><br>  ab &lt;-&gt; (aR) (bR) / R = abR <br><br>  That is, you multiply aR by bR and get the product ab by R squared.  Now we have two R's, which is a bit annoying, but you can divide it by R. As a result, we get the product of ab by R. It's a little unclear why we needed to multiply this number once more.  Let's first find out if this is correct, and then we will understand why it will be faster. <br>  This is correct in the sense that it is very easy.  If you want to multiply some numbers, then they need to be multiplied by this value of R and get the Montgomery transform.  Each time we multiply these 2 numbers, we have to divide them by R, and then look at the resulting form of a transformation of the form abR.  Then, when we finish squaring, multiplication, and all these things, we will return to the normal, usual form of the result, simply dividing by R for the last time. <br><br><img src="https://habrastorage.org/webt/mi/jh/jo/mijhjogewp0y5aant8x9lk61gpg.jpeg"><br><br>  Now consider how to choose the most appropriate number for R to make division by R a very fast operation.  And the great thing here is that if the division into R is very fast, when it is a small number, and we don‚Äôt have to do this mod q too often.  In particular, aR, let's say, will also be about 500 bits in size, because all of this is in fact mod p or mod q.  Thus, aR is 500 bits, bR will also be 500 bits, so the product (aR) (bR) will be 1000 bits.  R will also be a convenient 500-bit number, the size of p.  And if we can make the division operation fast enough, then the result of ab will also be approximately a 500-bit number, so that we can multiply without the need to do additional division.  The division into R is much more profitable and gives us the result of small size, which avoids the use of mod p in most situations. <br><br>  So, what is this strange number R that I‚Äôm talking about all the time?  It has a value of 2 to 512 degrees: <br><br>  R = <sup>2,512</sup> <br><br>  It will be 1 and a bunch of zeros, so it‚Äôs easy to multiply by such a number, because it will be enough just to add a bunch of zeros to the result.  The division can also be simple if the low-order bits of the result are zero.  So if you have a value from a pile of bits, accompanied by 512 zeros, then dividing it by 2 to 512 degrees will be very simple - you just drop zeros on the right side, and this is a completely correct division operation. <br><br>  A minor problem is that we don‚Äôt actually have zeros on the right side when you do this multiplication.  We have real 512-bit numbers using all 512 bits. <br><br>  The product (aR) to (bR) is also a real number on the order of 1000 bits, so we cannot just discard the lower bits.  But a reasonable approach is based on the fact that the only thing that worries us is the mod p value.  Thus, you can always add several p to this value without changing its equivalent mod p.  As a result, we can add multiple p values ‚Äã‚Äãso that all low bits become zeros.  Let's look at some simple examples.  I am not going to write out 512 bits on the blackboard, but I will give only a short example. <br><br>  Suppose that in our situation R = 2 <sup>4</sup> = 10000. This is a much smaller size than is found in reality.  Let's see how this Montgomery transformation will work.  We will try to calculate mod q, where q = 7.  In binary form, q = 7 is (111). <br><br>  Suppose further that we have produced some multiplication (aR) (bR), and in the binary representation the result is 11010, that is, this will be the value of the product (aR) (bR).  How do we divide it by R? <br><br>  Obviously, not all four low bits are zeros, so we cannot just separate them, but we can add multiples of q.  In particular, we can add 2 times in q, with 2q = 1110 in binary representation.  As a result of the addition, we get 101000, I hope I did everything right. <br><br><img src="https://habrastorage.org/webt/yy/vp/8f/yyvp8ffoelgybgl_ntariqw3uvi.jpeg"><br><br>  So we got the sum (aR) (bR) + 2q.  In fact, we do not care about + 2q, because all we care about is the value of mod q.  Now we are closer to the goal, because we have three zeros on the right.  Now we can add some more q.  Let's say this time it will be 8q, which will be 111000. Add up our lines again and get 1100000. Now we have the original (aR) (bR) + 2q + 8q = 1100000. Finally, we can very easily divide this thing by R, simply dropping four low zeros. <br><br><img src="https://habrastorage.org/webt/r_/vd/n-/r_vdn-ktqvqa5oojy35pnml5hsm.jpeg"><br><br>  <b>Audience: the</b> product (aR) (bR) will always end with 1024 zeros? <br><br>  <b>Professor:</b> No, and I will explain what the confusion may be.  Let's say the number a is 512 bits, we multiplied it by R and got a 1000-bit number.  In this case, you are right, aR is a number in which high bits are a, and low bits are all zeros.  But then we do mod q to make it smaller.  Therefore, the size of 1024 bits in the general case is an accident, since this number has these low zeros only at the first conversion, but after you do several multiplications, it will be arbitrary bits. <br><br>  In order not to mislead you, I had to write mod q here after aR and after bR ‚Äî so I add it ‚Äî and calculate this mod q as soon as you do the conversion to reduce the value. <br><br><img src="https://habrastorage.org/webt/nc/en/7o/ncen7oailgwdxhdlosl-fmds1oo.jpeg"><br><br>  The initial transformation is quite laborious, or at least as expensive as normal modulation during multiplication.  It's cool that you pay this price once when you do a Montgomery transform, and then, instead of converting it back at every step of the calculation, you just keep it in the form of a Montgomery representation. <br>  Remember that for a exponentiation that has 512 bits, you have to do more than 500 multiplications, because we have to do at least 500 squaring and some more actions.  So you do mod q twice and then get a lot of simple division operations if you stay in this form of representing numbers.  And at the end you divide by R to return to this form ab. <br><br>  So, instead of doing mod q q 500 times for each multiplication step, you do mod q twice and then continue to do these divisions of R with minimal cost. <br>  Audience: when you add multiples of q, and then divide by R, do we get a remainder? <br>  Professor: mod q actually means the remainder when you divide by q.  Simply put, x + yq mod q = x.  In this case, there is another useful feature - this is that all modules are prime numbers.  This is as true as the fact that if you have (x + yq / R) mod q, then it is x / R mod q. <br><br><img src="https://habrastorage.org/webt/pk/s_/mq/pks_mqcl8worhpd4rrek3pamwzy.jpeg"><br><br>  The reason for considering this is that in modular arithmetic there are no real division operations, it is just an invert.  In fact, this means that if we have (x + yq) multiplied by the inverted R calculated by the mod q, then it is equal to the sum of two products: the product x by the inverted R by mod q and the product yq by the inverted R mod q.  And the last term is reduced, because it is something multiplied by q. <br><br><img src="https://habrastorage.org/webt/vg/ky/iz/vgkyizet0a_ne58agxvlks8ommk.jpeg"><br><br>  For things like summation of 2q, 8q, and so on, there is a formula that speeds up the calculation process.  I did this gradually, first calculating 2q, then 8q, and so on, but in the lecture materials there is a complete formula that I can use, I just don‚Äôt want to waste time writing it on the blackboard.  It allows you to calculate how many times the q value you need to add, so that all the low-order bits turn into 0. Then it turns out that in order to make a division by R, you just need to calculate this magic multiple of q, add it, then drop the low zero bits, and it will return your number to 512 bits no matter what size of result you got. <br><br>  But there is one subtlety.  The only reason we talk about this is something funny happening here that allows us to find out information about timings.  In particular, although we divided it into R, we still know that the result will be about 512 bits.  But it can still be more than q, because q is not a 512-bit number, it can be a little less than R. <br><br>  So it may be that after we do this profitable division by R, we may need to subtract q again, because we get something small, but still not small enough.  So there is a chance that after this division we may have to subtract q again.  And this subtraction can be used as part of an attack, because the subtraction operation adds computation time. <br><br><img src="https://habrastorage.org/webt/js/3b/bq/js3bbqk4o3wsvylxkgaatijeh_k.jpeg"><br><br>  And someone found out - not these guys, but someone in a previous work - that there is a chance to do something called extra reduction, or an additional reduction.  This probability depends on a particular value, which is raised to a power.  So, if you calculate xd mod q, the likelihood of an additional reduction at some point in time for computing this value will be x mod q divided by 2R.  I will separate this expression from the rest of the calculations. <br><br><img src="https://habrastorage.org/webt/it/si/iw/itsiiweom0jn8nlm8tyidksk3ty.jpeg"><br><br>  Depending on whether the value of x mod q is large or small, you will have more or less of these additional cuts.  And all this happens at the decryption stage, because when decrypting the server will calculate cd. <br><br><img src="https://habrastorage.org/webt/ty/b3/ig/tyb3igh49ab4o2u8pgvydckrzh8.jpeg"><br><br>  This suggests that extra reduction will be proportional to how close X or, in this case, s, to the value of q. <br><br><img src="https://habrastorage.org/webt/6k/bd/4s/6kbd4spmlvgepzklkfxrm4ebso0.jpeg"><br><br>  This is dangerous because the attacker must select the input data c, and the number of extra reduction will be proportional to how close c to one of the factors is q.  It‚Äôs as if you can tell if you‚Äôve approached a q value or overshot.  In this case, a situation suddenly arises when there is no extra reduction, probably because X mod q is very small, and X = q + Œ≠, and this is a very small value.  This is part of the attack in the method of determining the timings, which we will talk about in a second.  I have no evidence that this is true, but, in any case, these additional reductions of extra reduction work just like this. <br><br>  <b>Audience:</b> What happens if you do not make this additional reduction? <br><br>  <b>Professor:</b> what happens if you do not do this extra reduction?    ,  , ,        .  ,             . ,               ,        extra reduction, , ,     .       ,    . ,     ,      mod q.       , , ,   .  ,      mod q  ,  ,      . <br><br>  ,    . ,    - ,   .  ‚Äî         ,       . ,  -  ,   extra reduction  . <br><br> ,    .  ,   OpenSSL,      ,  .  ,          mod q    .    ,         ,       . <br><br> ,     ,     ,      , a  b.    ‚Äî 512- .     ,      32-  ,      ,    64-  ?       ? <br><br><img src="https://habrastorage.org/webt/ir/qp/p3/irqpp3-qwmtd5ny6id59a12tw3w.jpeg"><br><br>  -    ?  ,     ,    a  b             . <br><br>     , ,    512  ,    64- ,      32- .    a     : a <sub>1</sub>  a <sub>0</sub> ,  a <sub>0</sub>    ,  a <sub>1</sub> ‚Äî  .      b ‚Äì     b <sub>1</sub>  b <sub>0</sub> . <br><br>     ab      3- :       a <sub>1</sub> b <sub>1</sub> ,        a <sub>0</sub> b <sub>0</sub> ,     a <sub>1</sub> b <sub>0</sub> + a <sub>0</sub> b <sub>1</sub> .         . <br><br><img src="https://habrastorage.org/webt/9d/sd/dz/9dsddzqrr7zvczt8rh0noqpyuh8.jpeg"><br><br> 55:00  <br><br>  <a href="https://habr.com/company/ua-hosting/blog/429394/">MIT course "Computer Systems Security".</a> <a href="https://habr.com/company/ua-hosting/blog/429394/"> 16: ¬´   ¬ª,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3v5Von-oNUg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until December for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/429392/">https://habr.com/ru/post/429392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429382/index.html">From Alibaba to Pyaterochka: who and how uses face recognition in business</a></li>
<li><a href="../429384/index.html">Components of electric bike: motor</a></li>
<li><a href="../429386/index.html">Provider AT & T has become the largest copyright holder and will begin to disconnect users accused of piracy</a></li>
<li><a href="../429388/index.html">How to make a redesign of the site and not to make problems: 4 important steps</a></li>
<li><a href="../429390/index.html">MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 1</a></li>
<li><a href="../429394/index.html">MIT course "Computer Systems Security". Lecture 16: "Attacks through the side channel", part 3</a></li>
<li><a href="../429396/index.html">How to test an application when interacting with an API using SoapUI</a></li>
<li><a href="../429400/index.html">Seals vs neural network 2. Or run SqueezeNet v.1.1 on Raspberry Zero in realtime (almost)</a></li>
<li><a href="../429402/index.html">ML.NET 0.7 (Machine Learning .NET)</a></li>
<li><a href="../429404/index.html">8 s ¬Ω ways to prioritize functionality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>