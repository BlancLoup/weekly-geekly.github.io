<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write software for generating music card data. Part one: parse the MIDI file</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In my articles about the transition to the Russian microcontroller K1986BE92QI I have repeatedly talked about the generation of sound b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write software for generating music card data. Part one: parse the MIDI file</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In my articles about the transition to the Russian microcontroller K1986BE92QI I have repeatedly talked about the generation of sound by means of a microcontroller.  Then I had the task to reproduce the data.  To create this data itself, obtained from MIDI files, very exotic methods were used, for example, as in this <a href="http://habrahabr.ru/post/256621/">article</a> .  Yes, such methods have the right to life if you need to obtain data for reproduction a couple of times in your life.  But since I often encounter tasks, when the controller needs to get a rather complex sound, or the sound is just an additional option, the task to convert MIDI files in such exotic ways becomes very nontrivial.  In this small series of articles, I set for myself the task to create (and in one thing and tell in detail about the creation process) a universal program for converting MIDI files to a format acceptable for the microcontroller, as well as generating all the initialization data necessary for the microcontroller. <br><br><img src="https://habrastorage.org/files/254/45c/fef/25445cfeff3647b08648c5df29c78e56.PNG"><br><br>  The result of this article will be the implementation of the main functionality of the program: the creation of arrays of note-duration created from a MIDI file.  Who is interested - I ask under the cat. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Article structure </h4><br><ol><li>  Development of requirements for the program. </li><li>  Determination of the method of implementation. </li><li>  General information about MIDI. </li><li>  Headline </li><li>  MIDI file block. </li><li>  Developments. </li><li>  Parsing the data. </li><li>  Conclusion </li></ol><br><br><h4>  Developing program requirements </h4><br>  As mentioned above, the main task of our program will be to convert data from MIDI format to our own.  In other words, we are not faced with the task of taking into account the strength of keystrokes, the use of rare instruments, or the use of effects provided by the MIDI standard.  We must ignore all this and similar unnecessary information.  At the end of the program, we must get the Nth number of arrays, in each of which only one key will play at the current time (this is necessary to simplify the program in the microcontroller).  In other words, we should get a list of arrays with polyphony of one note. <br><br><h4>  Determining how to implement </h4><br>  In a previous article, we already wrote a program that implemented similar functionality based on data already processed by another program in a specific form.  The program was written in Pascal ABC, because at that time the task was reduced to processing the lines of the txt file, no more.  Now we are writing a program from scratch, suggesting working with pure MIDI data.  Also, in the future we plan to expand it to a full-fledged initialization data generator.  So this time the program will be written in the graphical environment of Visual Studio in C #.  We do not need a lot of computer resources, and beautiful syntax and the possibility of easy reading of the program, contributing to easy support, will not interfere. <br><br><h4>  MIDI Overview </h4><br>  Many are familiar with the MIDI format, or at least have heard about it.  In this format it is convenient to store, for example, notes of musical works, with the ability to listen to them.  For this purpose, most often, MIDI is used in the modern world.  But once they tried to cram a lot of additional functions into it.  So what does a MIDI file consist of? <br><br><img src="https://habrastorage.org/files/bcb/3a4/f74/bcb3a4f747ab4f7db7ec5289720b5e91.PNG"><br><br>  As can be seen from the figure, a MIDI file consists of: <ul><li>  The header of the file (it starts with the four characters that make up the word MThd). </li><li>  File blocks (starting with MTrk characters). </li></ul>  First, let's look at the MIDI file header (MThd). <br><br><h4>  Headline </h4><br><img src="https://habrastorage.org/files/251/237/ca7/251237ca7b8043ce884810d1508e28c5.PNG">  Let us analyze what the header of the MIDI file consists of. <br><br><ul><li>  Standard Values.  The header contains cells whose values ‚Äã‚Äãare the same for all MIDI files. <ol><li>  Caption caption "MThd".  This parameter allows you to unequivocally say that we have a header block. </li><li>  The size of the individual file parameters in the header block.  Since there are always 3 individual parameters in the header, each of which occupies 2 bytes - the total length of the header block (excluding the ‚ÄúMThd‚Äù inscription and four bytes of the size itself) is 6 bytes. </li></ol></li><li>  Individual parameters. <ol><li>  MIDI file format.  In fact, MIDI file formats are only 2: <b>0</b> and <b>1</b> .  There is also a format <i>2</i> , but for all my nine-year work with sound, in real life I never had a chance to encounter a MIDI file in this format.  This parameter shows how events are packed (in our case, pressing / releasing keys).  If the format is <b>0</b> , then we know for sure that all the useful information about all channels (up to 16 channels) is located in one single MTrk block.  If we have format <b>1</b> , then each channel has its own MTrk block.  Our program will be able to work with both formats. </li><li>  The number of MIDI file blocks (MTrk).  Here we can see how many blocks are contained in our MIDI file.  This parameter is relevant only for format <b>1</b> .  For in the format <b>0</b> block is always 1. </li><li>  MIDI file time format.  And here things are very interesting.  The fact is that in the MIDI file the score goes not in seconds, but in ticks.  And there is a <b>musical way</b> , when the value of our parameter shows how many ‚Äúticks‚Äù are in the musical quarter and <b>absolute</b> , showing the number of ‚Äúticks‚Äù in the SMPTE block.  Yet again.  Most often the first method occurs.  The second, all the same, is exotic.  Therefore, we will not take into account the existence of an absolute way of counting time and will operate only with <b>music</b> . </li></ol></li></ul><br>  Now, knowing the structure of the MIDI file header, we can read it.  But first you need to understand one thing.  The data in the MIDI file (which is more than one byte in length) is presented in <b>big-endian</b> format.  This means that if we have a cell consisting of two bytes, then the first byte is the high byte, and the second byte is the low byte.  Unusually, but the format is not young, and you can forgive him. <br><br>  So, read the title. <br><br><ol><li>  To work, we need to create a Windows Forms application (WPF is unnecessary here, but if you want, nobody forbids it). </li><li>  Inside the form, we will create a button and richTextBox (for me they have the names button1 and richTextBox1, respectively), as well as a window for opening the openFileDialog file (I, again, have the name openFileDialogMIDI). </li><li>  Create an event associated with a button click, in which we will clear the richTextBox from old data.  We also get the path to the MIDI file and pass it to the function that will open it.  ( <i>openMIDIFile</i> ) <br><div class="spoiler">  <b class="spoiler_title">Event ID</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">button1_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { richTextBox1.Clear(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openFileDialogMIDI.ShowDialog() == DialogResult.OK) <span class="hljs-comment"><span class="hljs-comment">//     . { openMIDIFile(openFileDialogMIDI.FileName); //    . } }</span></span></code> </pre> </div></div></li><li>  Since a MIDI file has an unusual data presentation format (big-endian), it will be easier to create a class in which we would define methods for comfortable work with a MIDI file. <div class="spoiler">  <b class="spoiler_title">Code of the method for creating your own stream of work with MIDI files.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//        MIDI. public class MIDIReaderFile { public BinaryReader BinaryReaderMIDIFile; //  .       MIDI . public MIDIReaderFile(Stream input) //         . { BinaryReaderMIDIFile = new BinaryReader(input); //           . } public UInt32 ReadUInt32BigEndian() //  4    "   "     . { UInt32 bufferData = 0; //   = 0. for (int IndexByte = 3; IndexByte &gt;= 0; IndexByte--) //     . bufferData |= (UInt32)((UInt32)BinaryReaderMIDIFile.ReadByte()) &lt;&lt; 8 * IndexByte; //  . return bufferData; } public UInt16 ReadUInt16BigEndian() //  2    "   "     . { UInt16 bufferData = 0; //   = 0. for (int IndexByte = 1; IndexByte &gt;= 0; IndexByte--) //     . bufferData |= (UInt16)((UInt16)BinaryReaderMIDIFile.ReadByte() &lt;&lt; 8 * IndexByte); //  . return bufferData; } public string ReadStringOf4byte() //      4 . { return Encoding.Default.GetString(BinaryReaderMIDIFile.ReadBytes(4)); //  4        4- . } public byte ReadByte() //  1 . { return BinaryReaderMIDIFile.ReadByte(); } public byte[] ReadBytes(int count) //  count . { return BinaryReaderMIDIFile.ReadBytes(count); } }</span></span></code> </pre> <br></div></div></li><li>  Next, create a structure in which we store MIDI data. <br><div class="spoiler">  <b class="spoiler_title">MThd block structure.</b> <div class="spoiler_text"><pre> <code class="bash hljs">// :    MIDI . // :      MIDI . public struct MIDIheaderStruct { public string nameSection; //  .   <span class="hljs-string"><span class="hljs-string">"MThd"</span></span>. public UInt32 lengthSection; //  , 4 .   0x6; public UInt16 mode; //  MIDI : 0, 1  2. public UInt16 channels; //  . public UInt16 settingTime; //  . }</code> </pre> </div></div></li><li>  Now we will create a method that will read our structure from the stream and return it. <div class="spoiler">  <b class="spoiler_title">Read the title.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :    MIDI . // :  FileStream . //   -    MIDIheaderStruct. public MIDIheaderStruct CopyHeaderOfMIDIFile(MIDIReaderFile MIDIFile) { MIDIheaderStruct ST = new MIDIheaderStruct(); //     . ST.nameSection = MIDIFile.ReadStringOf4byte(); //   . ST.lengthSection = MIDIFile.ReadUInt32BigEndian(); //  4   .     0x6 ST.mode = MIDIFile.ReadUInt16BigEndian(); //  2   MIDI.   0, 1  2. ST.channels = MIDIFile.ReadUInt16BigEndian(); //  2     MIDI . ST.settingTime = MIDIFile.ReadUInt16BigEndian(); //  2   . return ST; //   . }</span></span></code> </pre> </div></div></li><li>  Now let's write the function that the event of pressing the button to open the file causes.  We will supplement this function.  In the meantime, its main task is to open the file and, reading its values, output the individual parameters obtained. <div class="spoiler">  <b class="spoiler_title">The code for the open file function.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :    . // :   . //  :  . true - , false - . public bool openMIDIFile(string pathToFile) { FileStream fileStream = new FileStream(pathToFile, FileMode.Open, FileAccess.Read); //     . MIDIReaderFile MIDIFile = new MIDIReaderFile(fileStream); //      MIDI   . .      . MIDIheaderStruct HeaderMIDIStruct = CopyHeaderOfMIDIFile(MIDIFile); //  . MIDIMTrkStruct[] MTrkStruct = new MIDIMTrkStruct[HeaderMIDIStruct.channels]; //    MTrkStruct. richTextBox1.Text += " : " + HeaderMIDIStruct.channels.ToString() + "\n"; //  . richTextBox1.Text += " : " + HeaderMIDIStruct.settingTime.ToString() + "\n"; richTextBox1.Text += " MIDI: " + HeaderMIDIStruct.mode.ToString() + "\n"; return true; }</span></span></code> </pre> </div></div></li></ol>  Please pay attention to the string creating an array of structures MTrkStruct.  As mentioned above, there is a cell in the file header that indicates how many more blocks, in addition to the header block, are contained in the MIDI file.  Immediately after reading the header, we can create an array of structures of information blocks of a MIDI file.  This structure will be discussed further.  After selecting the MIDI file, we will see the following. <img src="https://habrastorage.org/files/d80/be9/e9e/d80be9e9e7bd4c71a9d962bfcfd91443.PNG"><br><br><h4>  MIDI file block </h4><br>  Having considered the file header, we can proceed to the consideration of the block structure. <br><br><img src="https://habrastorage.org/files/5c9/7fb/000/5c97fb00062c4535aafc0372e008a381.PNG"><br><br>  The block consists of: <br><ol><li>  The four characters that make up the word MTrk.  This is a pointer to what is in front of us a MIDI block. </li><li>  The length of the block, written using four bytes.  The block length does not include the first 8 bytes (MTrk + 4 bytes of length). </li></ol><br><h4>  Developments. </h4>  Here we come to the most interesting.  It is in the events contains all the information we need.  MIDI events are of four types. <ol><li>  <b>Events of the first level.</b> <br><br><img src="https://habrastorage.org/files/87d/8aa/46c/87d8aa46c8a040ad8e17192ef57f2272.PNG"><br><br>  In MIDI files, it is assumed that there are 16 channels.  The location where the channel number is marked is nnnn.  0 = first channel, 1 = second, and so on.  Thus, the lower 4 bits are allocated for the channel number.  On each channel, the Nth number of notes can be pressed.  Depending on how much you can play a device that reads a MIDI file.  Channel number for us has no role, because we have in those.  The task clearly states that on each channel at the current moment in time no more than one key should be included.  In other words, we will carry out breaking in channels.  From the first level commands we will use 0x8n (release the note), 0x9n (pick up the note), 0xBn (to refer to the second level message, which will be discussed later) and 0xA (change the power of the keystroke). </li><li>  <b>Second level events.</b>  These events are the first-level event 0xBn + event number (of which there are about a hundred) + the parameter of this event (if there is no parameter, then 0 is transmitted). <br><br><img src="https://habrastorage.org/files/d89/15f/0b8/d8915f0b865c42118c0f3be65e6fd65a.PNG"><br><br>  We will not use second level commands.  But we now know how to ignore them. </li><li>  <b>Third level events.</b>  Third level events are 3 events of the second.  The first two events we specify the number of the desired command, and in the third - its parameter. <br><br><img src="https://habrastorage.org/files/740/130/7e3/7401307e3ba248b8a6d75553009ef7a3.PNG"><br><br>  We do not use third level commands either.  And the method of ignoring them coincides with the method of ignoring commands of the second level (in fact, we ignore 3 commands of the second). </li><li>  <b>SysEx events.</b>  These are exclusive messages.  There are no piano works (or other classical instruments) in MIDI files of scores.  When writing a program, we will assume that such messages do not exist.  The message structure looks like this. <br><br><img src="https://habrastorage.org/files/3f3/c12/012/3f3c12012ee94760b718f51aca811fad.PNG"><br></li></ol><br>  Now, knowing what events exist, we could begin to read them, but ... At what point in time do they appear?  And here everything is as follows.  Before each event of the first / second level (the third is not considered, since I have never come across such a MIDI file for the entire time of testing musical works) there is an n-th number of bytes describing the time elapsed since the last MIDI event.  If the byte of the time data is the last, then its most significant byte is set to 0. If not, then 1. Consider an example. <br><br><img src="https://habrastorage.org/files/add/8b5/9ec/add8b59ecc954af4a3fd71b309dd21e8.PNG"><br><br>  The flag is set to 0 (7th bit = 0).  Therefore this byte is the last and only one.  Further, without paying attention to the senior category, we look at the remained number.  It is 0 =&gt; event 0 occurred at zero second.  Now consider event 1. Here, the most significant byte is set to 1 =&gt; not the last byte.  We keep the value remaining if we cross out the most significant digit.  We get 1. We look at the next byte.  There, the flag = 0 and the rest = 0. Now we consider how much time has actually passed.  Since each byte can carry as little as 7 bytes of information, we have (1 &lt;&lt; 7) | (0 &lt;&lt; 0) = 0x100 timer ticks.  In the same way, we can consider the time before the event 2. There we passed 0x10 ticks. <br><br>  It is worth noting that if the event 0 is, for example, a command to take a key, we ignore event 1, and event 2 is a command to release the key, then we need to take into account that the time for pressing the key = 0x100 + 0x10.  For the countdown comes from the last event.  Even if we ignore it. <br><br>  Armed with all the information we receive, we can begin to write code. <br><ul><li>  We will create a structure in which we will store the block header, as well as a list with read notes. <br><div class="spoiler">  <b class="spoiler_title">Block structure</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :     MIDI . // :      MIDI . public struct MIDIMTrkStruct { public string nameSection; //  .   "MTrk". public UInt32 lengthSection; //  , 4 . public ArrayList arrayNoteStruct; //       . }</span></span></code> </pre> <br><br></div></div></li><li>  A structure is also required to store the read key press / release / change events. <br><div class="spoiler">  <b class="spoiler_title">The structure of the notes.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :   /     . public struct noteStruct { public byte roomNotes; //  . public UInt32 noteTime; //    . public byte dynamicsNote; //  / . public byte channelNote; //  . public bool flagNote; //   (true)    (false). }</span></span></code> </pre> <br><br></div></div></li><li>  Now we will write a function that reads the data, determines whether they are needed to create the array and adds the necessary ones to the array, indicating the real time from zero. <div class="spoiler">  <b class="spoiler_title">Block read function.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :   MTrk (  )  MIDI . // :    MIDI . // :      . public MIDIMTrkStruct CopyMIDIMTrkSection(MIDIReaderFile MIDIFile) { MIDIMTrkStruct ST = new MIDIMTrkStruct(); //     MIDI . ST.arrayNoteStruct = new ArrayList(); //         . noteStruct bufferSTNote = new noteStruct(); //      ( ,     arrayNoteStruct). ST.nameSection = MIDIFile.ReadStringOf4byte(); //   . ST.lengthSection = MIDIFile.ReadUInt32BigEndian(); // 4    . UInt32 LoopIndex = ST.lengthSection; //    .   ,     = 0. UInt32 realTime = 0; //    . while (LoopIndex != 0) //     . { //     .     8-   ( ). byte loopount = 0; //   . byte buffer; //    . UInt32 bufferTime = 0; //    . do { buffer = MIDIFile.ReadByte(); //  . loopount++; // ,   . bufferTime &lt;&lt;= 7; //   7      (.. 1    ). bufferTime |= (byte)(buffer &amp; (0x7F)); //      . } while ((buffer &amp; (1&lt;&lt;7)) != 0); // ,       (  = 0). realTime += bufferTime; //   . buffer = MIDIFile.ReadByte(); loopount++; //  -, ,   . //    -, ... if (buffer == 0xFF) { buffer = MIDIFile.ReadByte(); //   -. buffer = MIDIFile.ReadByte(); //  . loopount+=2; for (int loop = 0; loop &lt; buffer; loop++) MIDIFile.ReadByte(); LoopIndex = LoopIndex - loopount - buffer; //     . } //   -,  ,      . else switch ((byte)buffer &amp; 0xF0) //    4- . { //    . case 0x80: //  . bufferSTNote.channelNote = (byte)(buffer &amp; 0x0F); //   . bufferSTNote.flagNote = false; //   . bufferSTNote.roomNotes = MIDIFile.ReadByte(); //   . bufferSTNote.dynamicsNote = MIDIFile.ReadByte(); //   . bufferSTNote.noteTime = realTime; //    . ST.arrayNoteStruct.Add(bufferSTNote); //   . LoopIndex = LoopIndex - loopount - 2; //  . break; case 0x90: //  . bufferSTNote.channelNote = (byte)(buffer &amp; 0x0F); //   . bufferSTNote.flagNote = true; //  . bufferSTNote.roomNotes = MIDIFile.ReadByte(); //   . bufferSTNote.dynamicsNote = MIDIFile.ReadByte(); //   . bufferSTNote.noteTime = realTime; //    . ST.arrayNoteStruct.Add(bufferSTNote); //   . LoopIndex = LoopIndex - loopount - 2; //  . break; case 0xA0: //    . bufferSTNote.channelNote = (byte)(buffer &amp; 0x0F); //   . bufferSTNote.flagNote = true; //  . bufferSTNote.roomNotes = MIDIFile.ReadByte(); //   . bufferSTNote.dynamicsNote = MIDIFile.ReadByte(); //    . bufferSTNote.noteTime = realTime; //    . ST.arrayNoteStruct.Add(bufferSTNote); //   . LoopIndex = LoopIndex - loopount - 2; //  . break; //  2-  . case 0xB0: byte buffer2level = MIDIFile.ReadByte(); //   . switch (buffer2level) //    . { default: //     ( ). MIDIFile.ReadByte(); //   -  . LoopIndex = LoopIndex - loopount - 2; //  . break; } break; //       . case 0xC0: //    . MIDIFile.ReadByte(); //   . LoopIndex = LoopIndex - loopount - 1; //  . break; case 0xD0: //  . MIDIFile.ReadByte(); //   . LoopIndex = LoopIndex - loopount - 1; //  . break; case 0xE0: //   . MIDIFile.ReadBytes(2); //   . LoopIndex = LoopIndex - loopount - 2; //  . break; } } return ST; //   . }</span></span></code> </pre> </div></div></li><li>    .   ,  ,           .             . <br><div class="spoiler"> <b class="spoiler_title">     .</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :  : /. // :   ,       ;  . public ArrayList reateNotesArray(MIDIMTrkStruct[] arrayST, int arrayCount) { ArrayList arrayChannelNote = new ArrayList(); //  . for (int indexBlock = 0; indexBlock &lt; arrayCount; indexBlock++) //     MIDI. { for (int eventArray = 0; eventArray &lt; arrayST[indexBlock].arrayNoteStruct.Count; eventArray++) //       . { noteStruct bufferNoteST = (noteStruct)arrayST[indexBlock].arrayNoteStruct[eventArray]; //   . if (bufferNoteST.flagNote == true) //   . { byte indexChennelNoteWrite = 0; while (true) //    . { if (indexChennelNoteWrite&lt;arrayChannelNote.Count) //        . { channelNote bufferChannel = (channelNote)arrayChannelNote[indexChennelNoteWrite]; //     . if (bufferChannel.ToWriteaNewNote(bufferNoteST.roomNotes, bufferNoteST.noteTime) == true) break; //     - . } else //      -       . { channelNote noteNambeChannelBuffer = new channelNote(); //     . noteNambeChannelBuffer.ToWriteaNewNote(bufferNoteST.roomNotes, bufferNoteST.noteTime);//     - . arrayChannelNote.Add(noteNambeChannelBuffer); //     . break; //  . } indexChennelNoteWrite++; //     -  . } } else //    . { byte indexChennelNoteWrite = 0; while (true) //    . { channelNote bufferChannel = (channelNote)arrayChannelNote[indexChennelNoteWrite]; //     . if (bufferChannel.EntryEndNotes(bufferNoteST.roomNotes, bufferNoteST.noteTime) == true) break;//     - . indexChennelNoteWrite++; //     -  . } } } } return arrayChannelNote; }</span></span></code> </pre> </div></div></li><li>       richTextBox. <div class="spoiler"> <b class="spoiler_title"> .</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//     richTextBox1. public void outData(ArrayList Data) { for (int loop = 0; loop&lt;Data.Count; loop++) //    . { channelNote buffer = (channelNote)Data[loop]; //    . //     . richTextBox1.Text += "uint16_t channel" + loop.ToString() + "[" + buffer.arrayNoteChannel.Count.ToString() + "][2] = {"; for (int loop1 = 0; loop1 &lt; buffer.arrayNoteChannel.Count; loop1++) { channelNote.noteInChannelNote DataD = (channelNote.noteInChannelNote)buffer.arrayNoteChannel[loop1]; richTextBox1.Text += DataD.roomNotes.ToString() + "," + DataD.noteTime.ToString(); if (loop1 != (buffer.arrayNoteChannel.Count - 1)) richTextBox1.Text += ", \t"; } richTextBox1.Text += "};\n\n"; } }</span></span></code> </pre> </div></div></li><li>              .     . <div class="spoiler"> <b class="spoiler_title">  MIDI .</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// :    . // :   . //  :  . true - , false - . public bool openMIDIFile(string pathToFile) { FileStream fileStream = new FileStream(pathToFile, FileMode.Open, FileAccess.Read); //     . MIDIReaderFile MIDIFile = new MIDIReaderFile(fileStream); //      MIDI   . .      . MIDIheaderStruct HeaderMIDIStruct = CopyHeaderOfMIDIFile(MIDIFile); //  . MIDIMTrkStruct[] MTrkStruct = new MIDIMTrkStruct[HeaderMIDIStruct.channels]; //    MTrkStruct. richTextBox1.Text += " : " + HeaderMIDIStruct.channels.ToString() + "\n"; //  . richTextBox1.Text += " : " + HeaderMIDIStruct.settingTime.ToString() + "\n"; richTextBox1.Text += " MIDI: " + HeaderMIDIStruct.mode.ToString() + "\n"; for (int loop = 0; loop&lt;HeaderMIDIStruct.channels; loop++) MTrkStruct[loop] = CopyMIDIMTrkSection(MIDIFile); //   MIDI . outData(reateNotesArray(MTrkStruct, HeaderMIDIStruct.channels)); //   /. return true; }</span></span></code> </pre> </div></div></li></ul><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we are with you and have mastered the basic information about the structure of a MIDI file, also having backed up our knowledge in practice, having obtained a working program. </font><font style="vertical-align: inherit;">In the next articles, we will continue to increase its functionality and as a result we will obtain a lightweight tool for preparing data for audio playback on the microcontroller. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project file can be downloaded </font></font><a href="https://cloud.mail.ru/public/Dybd/rrDKPwuVs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h4>  Sources used </h4><br><font style="vertical-align: inherit;"></font><a href="http://www.muzoborudovanie.ru/articles/midi/midi1.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This series of articles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which has been written not one year since 2003, </font><font style="vertical-align: inherit;">helped greatly in mastering MIDI </font><font style="vertical-align: inherit;">.</font></font></div><p>Source: <a href="https://habr.com/ru/post/271693/">https://habr.com/ru/post/271693/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271681/index.html">Young hackers 414s</a></li>
<li><a href="../271683/index.html">Come November 26th to Visual Studio Workshop</a></li>
<li><a href="../271685/index.html">Spreadsheets under the hood</a></li>
<li><a href="../271687/index.html">Httplug - abstraction from HTTP client for PHP</a></li>
<li><a href="../271689/index.html">Developing your own solution: risks and responsibilities</a></li>
<li><a href="../271695/index.html">Developer Economics Tenth Study</a></li>
<li><a href="../271697/index.html">Machine Learning Hackathon: Come. To train a model. To win</a></li>
<li><a href="../271699/index.html">Professional test on the knowledge of the realities of the market for customized development and digital communications</a></li>
<li><a href="../271701/index.html">Design prototypes of cells in the same XIB with UITableView</a></li>
<li><a href="../271703/index.html">How sometimes bad code and antipattern solve</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>