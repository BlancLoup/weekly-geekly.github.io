<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mutational analysis, or how to test tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tests do not happen much - everyone knows that. Memes about unit and integration testing are no longer very fun. And we still do not know whether it i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mutational analysis, or how to test tests</h1><div class="post__text post__text-html js-mediator-article">  Tests do not happen much - everyone knows that.  Memes about unit and integration testing are no longer very fun.  And we still do not know whether it is possible to rely on the results of passing tests, and what percentage of coverage will allow not to let bugs into production.  If the fatal changes in the code skip tests without affecting their result, the solution suggests itself - you need to test the tests! <br><br><img src="https://habrastorage.org/webt/6w/kv/4n/6wkv4nyll_4lnom-dlicndmsuhu.png"><br><br>  On the approach to the automation of this task was the report of Mark Langovoy on <a href="http://frontendconf.ru/">Frontend Conf</a> .  Video and article are short, and ideas are very working - you need to take note. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-1820HwCJUA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>About the speaker:</strong> Mark Langovoy ( <a href="https://habr.com/users/marklangovoi/" class="user_link">marklangovoi</a> ) works in Yandex in the <a href="https://habr.com/company/yandex/blog/305956/">Yandex.Tolok</a> project.  This is a crowdsourcing platform for quickly marking a large amount of data.  Customers upload data that, for example, needs to be prepared for use in machine learning algorithms, and set a price, and the other side, the performers, can complete tasks and earn money. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In his free time, Mark develops the Krasnodar development community Krasnodar Dev Days - one of the 19 <a href="http://frontendconf.ru/frontendconf/moscow/2018/communities.html">IT communities</a> whose activists we invited to Frontend Conf in Moscow. <br><br><h2>  Testing <br></h2><br>  There are different types of automated testing. <br><img src="https://habrastorage.org/webt/xv/dl/of/xvdlofex2xlqouaertrnrkq804c.png"><br><br>  In the course of popular <strong>unit testing,</strong> we write tests for small parts (modules) of an application.  They are easy to write, but sometimes during integration with other modules they may not behave exactly as we expected. <br><br>  To avoid this, we can write <strong>integration tests</strong> that will check the work of our modules together. <br><img src="https://habrastorage.org/webt/ri/6k/gy/ri6kgykpne6mwcobow5wqwhphmq.png"><br><br>  They are a bit more complicated, so today we will focus on unit testing. <br><br><h2>  Unit testing <br></h2><br>  Any project that wants at least some minimal stability deals with writing unit tests. <br><br>  Consider an example. <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Signal</span></span></span><span class="hljs-class"> </span></span>{ on(callback) { ... } off(callback) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callbackIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.indexOf(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callbackIndex === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = [ ...this.listeners.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, callbackIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>), ...this.listeners.slice(callbackIndex) ]; } trigger() { ... } }</code> </pre> <br>  There is a Signal class - this is the Event Emitter, which has an on method for the subscription and an off method for deleting the subscription - check if the callback is contained in the array of subscribers, then we delete it.  And, of course, there is a trigger method that will call signed callbacks. <br><br>  We have a simple test for this example that calls the on and off methods and then the trigger to verify that the callback was not called after the unsubscribe. <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">'off method should remove listener'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> signal = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Signal(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wasCalled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callback = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { wasCalled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; signal.on(callback); signal.off(callback); signal.trigger(); expect(wasCalled).toBeFalsy(); });</code> </pre><br><h3>  Quality assessment criteria <br></h3><br>  What are the criteria for assessing the quality of such a test? <br><br>  <strong>Code coverage</strong> is the most popular and well-known criterion that shows how many percent of the lines of code were executed when the test was launched. <br><img src="https://habrastorage.org/webt/8q/i8/om/8qi8om5vmjpwbthvc31xspmwtcu.png"><br><br>  You can have 70%, 80% or all of 90% of Code coverage, but does this mean that when you build a new build for production, everything will be fine, or something may go wrong? <br><br>  Let's return to our example. <br><br>  Friday night, you're tired, finish another feature.  And then you come across this code, which was written by your colleague.  Something in him seemed complicated and scary to you. <br><br><pre> <code class="javascript hljs"> ...this.listeners.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, callbackIndex - <span class="hljs-number"><span class="hljs-number">1</span></span>), ...this.listeners.slice(callbackIndex)</code> </pre><br>  You decided that you can probably just clear the array: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Signal</span></span></span><span class="hljs-class"> </span></span>{ ... off(callback) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> callbackIndex = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners.indexOf(callback); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (callbackIndex === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listeners = []; } ... }</code> </pre><br>  I made a commit, put together a project and sent it in production.  Tests have passed - why not?  And he went to rest in a bar. <br><br><img src="https://habrastorage.org/webt/zv/ds/pb/zvdspbqun8lcjabukmbkna-eivo.png"><br><br>  But suddenly, late at night, the bell rings, they scream into the phone that everything is falling, people cannot use the product, and in general - business is losing money!  You burn, you face dismissal. <br><br><img src="https://habrastorage.org/webt/5q/ac/4x/5qac4xp9819iwt9dwwue9rfvan8.png"><br><br>  How to deal with this?  What to do with the tests?  How to catch such primitive stupid mistakes?  Who will test the tests? <br><br>  Of course, you can hire an army of QA-engineers - let our application sit and just click. <br><br><img src="https://habrastorage.org/webt/5n/7s/rd/5n7srdm7g3tk0iiakgj3oft8zum.png"><br><br>  Or hire a QA automator.  They can get the job of writing tests - why write by yourself, if there are special people for this? <br><br>  But in fact it is expensive, so today we will talk about mutational analysis or mutational testing. <br><br><h2>  Mutation Testing <br></h2><br>  This is a way to automate the process of testing our tests.  Its goal is to identify ineffective and incomplete tests, that is, in essence, this is <strong>testing of tests</strong> . <br><br>  The idea is to change pieces of code, run tests on them, and if the tests did not fall, then they are incomplete. <br><br>  Changes are made using certain operations - <strong>mutators</strong> .  They replace, for example, plus by minus, multiply by divide, and other similar operations.  Mutators can change pieces of code, replace conditions in a while, reset arrays instead of adding an element to an array. <br><img src="https://habrastorage.org/webt/mu/xh/nb/muxhnbcmixwyzkp3xwoa5t0zywi.png"><br><br>  As a result of the application of mutations to the source code, it mutates and becomes a <strong>mutant</strong> . <br><br>  Mutants are divided into two categories: <br><br><ol><li>  <strong>The dead</strong> - those in which we were able to identify deviations, that is, in which at least one test fell. </li><li>  <strong>The survivors</strong> are the ones who ran away from us and got the bug before production. </li></ol><br>  For quality assessment, there is the <strong>MSI (Mutation Score Indicator)</strong> metric - the percentage ratio between killed and surviving mutants.  The greater the difference between code coverage tests and MSI, the worse the relevance of our tests reflects the percentage of code coverage. <br><br>  It was a bit of theory, and now consider how it can be used in JavaScript. <br><br><h3>  Javascript solution <br></h3><br>  In JavaScript, there is only one actively developing tool for mutation testing - this is <a href="https://stryker-mutator.io/">Stryker</a> .  This tool was named after the character X-man William Stryker - the creator of "Weapons X" and a fighter with all the mutants. <br><br><img src="https://habrastorage.org/webt/6w/kv/4n/6wkv4nyll_4lnom-dlicndmsuhu.png"><br><br>  Stryker is not a test runner, like Karma or Jest;  neither is it a framework for tests like Mocha or Jasmine.  This is a framework for mutational testing that complements your current infrastructure. <br><br><h3>  Plugin system <br></h3><br>  Stryker is very flexible, fully built on the plugin system, most of which are written by the developers of Stryker. <br><img src="https://habrastorage.org/webt/j3/2r/-n/j32r-ns1i8trfuitelgg3y_dpqu.png"><br><br>  There are plugins for running tests on Jest, Karma and Mocha.  There is integration with the Mocha frameworks (stryker-mocha-framework) Jasmine (stryker-jasmine) and ready-made sets of mutators for JavaScript, TypeScript and even for Vue: <br><br><ul><li>  stryker-javascript-mutator; </li><li>  stryker-typescript; </li><li>  stryker-vue-mutator. </li></ul><br>  Mutators for React are included in the stryker-javascript-mutator.  In addition, you can always write your mutators. <br><br>  If you need to convert the code before launch, you can use plugins for Webpack, Babel or TypeScript. <br><img src="https://habrastorage.org/webt/6f/qi/b3/6fqib3tsj-cjmqcnmpiyc45rmc4.png"><br><br>  This is all relatively simple. <br><br><h3>  Configuration <br></h3><br>  Configuration will not be difficult: you only need to specify in the JSON-config which test runner (and / or test framework, and / or transpiler) you use, and also install the appropriate plug-ins from npm. <br><br>  A simple console utility <strong>stryker-cli</strong> can do all this for you in question-answer mode.  She will ask you what you are using and will configure it yourself. <br><br><h3>  How it works <br></h3><br>  The life cycle is simple and consists of the following steps: <br><br><ul><li>  Reading and analyzing the config.  Stryker loads the config and analyzes it for various plugins, settings, exclusion of files, etc. </li><li>  Loading plugins according to config. </li><li>  Running tests on the source code in order to check whether the tests are relevant now (all of a sudden they are already broken). </li><li>  If everything is good, a set of mutants is generated for the files that we have allowed to mutate. </li><li>  Run tests on mutants. </li></ul><br><img src="https://habrastorage.org/webt/6v/ww/yn/6vwwynfb_hq570upwyur0zrp5fq.png"><br><br>  The above is an example of running Stryker: <br><br><ul><li>  Stryker runs; </li><li>  reads the config; </li><li>  loads the necessary dependencies; </li><li>  finds files that will mutate; </li><li>  runs tests on the source code; </li><li>  creates 152 mutants; </li><li>  runs tests in 8 threads (in this case, based on the number of CPU cores). </li></ul><br>  This is not a fast process, so it is better to do it on any CI / CD servers. <br><br>  After passing all the tests, Stryker gives a brief report on the files with the number of created, killed and surviving mutants, as well as the percentage of the ratio of killed mutants to survivors (MSI) and mutators that were applied. <br><br>  These are potential problems that are not foreseen in our tests. <br><br><h3>  Summarize <br></h3><br>  <strong>Mutation testing is useful and interesting</strong> .  It can find problems in the early stages of testing, and without the participation of people.  It will reduce the time it takes to test the pull request, for example, because qualified developers will not have to spend time checking the pull request, which already has potential problems.  Or save production if you decide to prepare a new release on Friday night. <br><br>  Stryker is a flexible multithreaded mutation testing tool.  It is actively developing, but still damp, still has not reached the major version.  For example, during the preparation of this report, its developers finally made it possible for Babel in the plugin to specify the configuration file and fix the Jest integration.  This is an open source <a href="https://github.com/stryker-mutator">project</a> that can be helped to grow. <br><br><div class="spoiler">  <b class="spoiler_title">Questions and Answers</b> <div class="spoiler_text">  <em>- How to test mutation tests?</em>  <em>Surely, there is also an error.</em>  <em>In the first sample with unit testing, it covered 90%.</em>  <em>It would seem that all is well, but cases still slipped when everything fell and was on fire.</em>  <em>Accordingly, why should there be a feeling that everything is fine, after covering these tests with mutation tests?</em> <br><br>  ‚ÄúI‚Äôm not saying that mutation testing is a silver bullet and will cure everything.‚Äù  Naturally, there may be some border insane cases or the absence of some kind of mutator.  First of all, typical errors are easily caught.  For example, you put a check on age, set it to &lt;18 (it was necessary &lt;=), and in the test I forgot to make a border case check.  You made another comparison with the mutator, and as a result the test fell (or did not fall), and you understand that everything is good or bad.  Such things are quickly caught.  This is a way to simply finish the tests correctly, to find the lost moments. <br><br>  <em>- Often you have a situation "zadepil and left"?</em>  <em>I think this is wrong.</em> <br><br>  - No, but I think that in many projects such things still exist.  Naturally, this is not true.  Many people believe that Code coverage helps to check everything, you can safely leave and not worry - but this is not so. <br><br>  <em>- I'll tell you right away what the problem is.</em>  <em>We have a lot of any reducers and other things that we mutationally test, and there are a lot of them.</em>  <em>All this is growing, and it turns out that for each pull request, mutation testing is started, which takes a lot of time.</em>  <em>Is it possible to run only on what has changed?</em> <br><br>  - I think you can customize it yourself.  For example, on the developer‚Äôs side, when he pushes, commit, you can make a <a href="https://github.com/okonet/lint-staged">lint-staged</a> plugin that will only run files that have changed.  On CI / CD this is also possible.  In our case, the project is very large and old, and we practice spot checking.  We do not check everything, because it will take a week, there will be hundreds of thousands of mutations.  I would recommend doing spot checks, or organizing a selective launch process myself.  I did not see a complete tool for such integration. <br><br>  <em>- Is the completeness of all possible mutations provided for a specific code fragment?</em>  <em>If not, how exactly are the mutations chosen?</em> <br><br>  - I personally did not check it, but I didn‚Äôt meet any problems with it.  Stryker must generate all possible mutations for the same code fragment. <br><br>  <em>- I want to ask about snapshots.</em>  <em>I have a unit test that tests the logic, including the layout of the snapshot react component.</em>  <em>Naturally, if I change any logical construction, I immediately change the layout.</em>  <em>This is the expected behavior, isn't it?</em> <br><br>  - Yes, that's their point, that you manually update snapshots yourself. <br><br>  <em>- So you somehow ignore snapshots in this report?</em> <br><br>  - Most likely, snapshots need to be pre-updated, and then run mutation testing, otherwise there will be a bunch of garbage from Stryker. <br><br>  <em>- Question about CI-servers.</em>  <em>For just unit-tests, there are reporters - under GitLab, for anything you like, which show the percentage of successful passing of tests, and you can configure whether it is fay or not.</em>  <em>And what about Stryker?</em>  <em>It simply displays a sign in the console, but what next to do with it?</em> <br><br>  - They have an HTML-reporter, you can make your reporters, everything is flexibly customized.  Perhaps there are some specific tools, but since we are still engaged in point mutation testing, I have not found any specific integrations with TeamCity and similar CI / CD tools. <br><br>  <em>- How much mutational tests increase support in general of tests that you have?</em>  <em>That is, tests are a pain, and tests must be rewritten when the code is rewritten, etc. Sometimes it is easier to rewrite the code than tests.</em>  <em>And then I also have mutation tests.</em>  <em>How expensive is it for a business?</em> <br><br>  ‚ÄúFirst, I‚Äôll probably correct that rewriting code for the sake of tests is wrong.  The code should be easy to test.  As for what needs to be added, this is again important for business, so that the tests are as complete and effective as possible.  If they are not complete, it means that there may be a bug that will bring losses.  Naturally, you can only test the most important parts of the business. <br><br>  <em>‚ÄúNevertheless ‚Äî how much more expensive does it get when mutation tests appear, than if they were not there.‚Äù</em> <br><br>  ‚ÄúIt's as expensive as bad tests are now.‚Äù  If now the tests are written poorly, then you have to write a lot.  Mutation testing will find cases that are not covered by tests. <br><br>  <em>- There are many Vorning on the slide with the results of the Stryker check, they are critical or not critical.</em>  <em>How to handle false positives?</em> <br><br>  - A subtle question is what is considered false.  I asked the guys in our team that they had something interesting out of such mistakes.  There was an example about the text of the error.  Stryker reported that the tests did not respond to the fact that the error text has changed.  It seems to be a joint, but minor. <br><br>  <em>- So you see such errors and skip non-critical ones in manual mode?</em> <br><br>  - We have a spot check, so yes. <br><br>  <em>- I have a practical question.</em>  <em>When you implemented it, what percentage of tests did you have?</em> <br><br>  - We did not implement the entire project, but there were minor problems on the new project.  Therefore, I can not say the exact figures, but in general, the approach has definitely improved the situation. <br></div></div><br><blockquote>  You can watch other front-end speeches on our <a href="https://www.youtube.com/c/FrontendChannel">youtube channel</a> , all thematic reports from all our conferences gradually get there.  Or subscribe to the <a href="http://eepurl.com/bb99tn">newsletter</a> , and we will keep you updated on all new materials and news of future conferences. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/421141/">https://habr.com/ru/post/421141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../421131/index.html">Critical 1Cloud Server Vulnerability</a></li>
<li><a href="../421133/index.html">LINK. Paper keyboard. Very large buttons</a></li>
<li><a href="../421135/index.html">Au / Ni / MgO: heat transfer at the nanometer level</a></li>
<li><a href="../421137/index.html">How Headless Chrome Works</a></li>
<li><a href="../421139/index.html">Frontend Conf - with user care</a></li>
<li><a href="../421143/index.html">Mini-review of Aurora Labs S-Titanium Pro, a metal 3D printer</a></li>
<li><a href="../421147/index.html">Monsters after the holidays: AMD Threadripper 2990WX 32-Core and 2950X 16-Core</a></li>
<li><a href="../421149/index.html">Some words about gradients</a></li>
<li><a href="../421153/index.html">24-core CPU, and I can not type an email (part 2)</a></li>
<li><a href="../421155/index.html">3D printing in 2018: the most interesting in the industry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>