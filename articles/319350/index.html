<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Competitiveness: Asynchrony</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We still managed to reach the third part and got to the most interesting part - the organization of asynchronous calculations. 


 In the last two art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Competitiveness: Asynchrony</h1><div class="post__text post__text-html js-mediator-article"><p>  We still managed to reach the third part and got to the most interesting part - the organization of asynchronous calculations. </p><br><p>  In the last two articles, we looked at the abstraction of <a href="https://habrahabr.ru/post/318374/">concurrently running code</a> and the <a href="https://habrahabr.ru/post/318786/">cooperative execution of</a> task handlers. </p><br><p>  Now let's see how you can control the flow of execution (control flow) in the case of processing asynchronous tasks. </p><br><ul><li>  <a href="https://habrahabr.ru/post/318374/">Parallelism</a> (part 1) <br><br><ul><li>  <a href="https://habrahabr.ru/post/318374/">Streams: scheduling, sleep</a> </li><li>  <a href="https://habrahabr.ru/post/318374/">Synchronization</a> : <a href="https://habrahabr.ru/post/318374/">Spinlock, semaphores</a> , <a href="https://habrahabr.ru/post/318374/">memory barriers</a> </li><li>  <a href="https://habrahabr.ru/post/318374/">Atomicity: TAS, CAS</a> </li></ul><br></li><li>  <a href="https://habrahabr.ru/post/318786/">Cooperativeness</a> (part 2) <br><br><ul><li>  <a href="https://habrahabr.ru/post/318786/">Coroutines</a> </li><li>  <a href="https://habrahabr.ru/post/318786/">Actors</a> </li></ul><br></li><li>  <b>Asynchrony</b> (part 3, current) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/ru/post/319350/">Event loop</a> <ul><li>  <a href="https://habr.com/ru/post/319350/">select</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/319350/">Callbacks</a> </li><li>  <a href="https://habr.com/ru/post/319350/">Async monad</a> </li><li>  <a href="https://habr.com/ru/post/319350/">Promises (promises)</a> </li><li>  <a href="https://habr.com/ru/post/319350/">async / await - promises + corutines</a> </li></ul><br></li></ul><a name="habracut"></a><br><h1 id="asinhronnost">  Asynchrony </h1><br><p>  Synchronous operations are operations in which we get the result as a result of blocking the <a href="https://habrahabr.ru/post/318374/">thread of</a> execution.  For simple computational operations (addition / multiplication of numbers) is the only way to perform them, for I / O operations, one of them, while we say, for example, <i>‚Äútry to read something from a file in 100ms‚Äù</i> , and if for reading there is nothing - the execution thread will be blocked for these 100ms. </p><br><p> In some cases, this is permissible (for example, if we make a simple console application, or some utility whose purpose is to work out everything), but in some cases it is not.  For example, if we get stuck in the stream in which the UI is processed, our application will hang.  There is no need to go far for examples - if the javascript on the site makes <code>while(true);</code>  , then any other event handlers for the page will stop being called and have to close it.  The same thing, if you start calculating something under Android in UI event handlers (whose code is called in the UI thread), this will cause the ‚Äúapplication does not respond, close?‚Äù Window (similar windows are called by <a href="https://en.wikipedia.org/wiki/Watchdog_timer">watchdog timer).</a> which is reset when execution returns to the UI system). </p><br><p>  Asynchronous operations are operations in which we <b>ask to perform a</b> certain operation and can in some way monitor the process / result of its execution.  When it will be completed is unknown, but we can continue to do other things. </p><br><h2 id="event-loop">  Event loop </h2><br><p>  <b>An event loop</b> is an infinite loop that takes <b>events</b> from a queue and somehow processes them.  And in some intervals - it looks, if there have been any <b>IO-events</b> , or if any <b>timers</b> have <b>expired</b> - then it adds an event about it to the queue in order to process it later. </p><br><p>  Let's go back to the browser example.  The whole page works in one <b>event loop</b> , loaded with a <b>javascript</b> page is added to the <b>queue</b> to be executed.  If any <b>UI events</b> occur on the page (click on the button, move the mouse, etc.), the code of their handlers is added to the <b>queue</b> .  Handlers are executed sequentially, there is no parallelism, while any code is running - everyone else is waiting.  If any code calls any special function, like <code>setTimeout(function() { alert(42) }, 5000)</code> , it will create a timer somewhere outside the loop, after which the function code with <code>alert(42)</code> will be added to the <b>queue</b> <code>alert(42)</code> . </p><br><p>  <b>Chip:</b> if someone in the queue before the execution of the handler will calculate something for a long time, then the timer handler will obviously execute later than in five seconds. </p><br><p>  <b>The second trick:</b> even if we ask, for example, 1 millisecond of waiting, it can go much more, because  the implementation of the <b>event loop</b> can look: ‚Äúyeah, the queue is empty, the nearest timer after 1ms, we will wait for IO events 1ms‚Äù, and when we call select, the implementation of the operating system can look: ‚Äúyeah, there are no events like that, for your time all the same, I am making a context switch, while there is an opportunity ‚Äù, and there all the other streams have used all the time available to them and we have flown by. </p><br><h3 id="select">  select </h3><br><p>  Low-level asynchronous IO events are implemented using <a href="https://en.wikipedia.org/wiki/Select_(Unix)">select</a> variations.  We have some file descriptors (which can be either files, or network sockets, or something else (in fact, in Linux, anything can be a file (or vice versa, a file can be anything))). </p><br><p>  And we can call some synchronous function, passing it a lot of descriptors, from which we expect input, or we want to write something, which will block the stream until: </p><br><ol><li>  One or more of the descriptors we transmitted will not be ready for the operation we want. </li><li>  There was no waiting time (if it was specified). </li></ol><br><p>  As a result of this procedure, we get a set of files ready for reading / writing. </p><br><h2 id="callbacks">  Callbacks </h2><br><p>  The easiest way to get the results of an asynchronous operation is to do this ‚Äî when you create it, pass references to the functions that will be called during any progress of the execution / readiness of the result. </p><br><p>  This is a rather low-level approach, and often the inability to write functions ‚Äúin a column‚Äù along with the abuse of anonymous functions leads to a ‚Äúcallback hell‚Äù (a situation where we have four to ten levels of nesting of functions to handle successive operations): </p><br><pre> <code class="hljs lua">//  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, callback)</span></span></span></span> { anotherAsync(a, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b)</span></span></span></span> { asyncAgain(b, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span></span> { andAgain(b, c, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span></span> { lastAsync(d, callback); }); }); }); } //  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someAsync2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, callback)</span></span></span></span> { var b; anotherAsync(a, handleAnother); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleAnother</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_b)</span></span></span></span> { b = _b; asyncAgain(b, handleAgain); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleAgain</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span></span> { andAgain(b, c, handleAnd); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleAnd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span></span> { lastAsync(d, callback); } }</code> </pre> <br><h2 id="async-monad">  Async monad </h2><br><p>  We, programmers, like to abstract and generalize to hide various complexities / routines.  Therefore, there is, among other things, an abstraction over asynchronous computing. </p><br><p>  What is <b>‚Äúcalculation‚Äù</b> ?  This is the process of <b>converting A to B.</b>  We will write synchronous calculations as <b>A ‚Üí B.</b> </p><br><p>  What is an <b>"asynchronous value"</b> ?  This promise will provide us with some future <b>T</b> value (which may be a successful outcome, or an error).  We will designate it as <b>Async [T]</b> . </p><br><p>  Then the <b>‚Äúasynchronous operation‚Äù</b> will look like <code>A ‚Üí Async[T]</code> , where <b>A</b> is any arguments necessary to start the operation (for example, this may be the URL to which we want to make a GET request). </p><br><p>  How to work with <b>Async [T]</b> ?  Let him have a <b>run</b> method that accepts a <b>callback</b> that will be called when the data becomes available: <code>Async[T].run : (T ‚Üí ()) ‚Üí ()</code> (accepts a function that accepts <b>T</b> , does not return anything). </p><br><p>  Well, now add the most important thing - the ability to <b>continue</b> an asynchronous operation.  If we have <b>Async [A]</b> , then obviously, when <b>A</b> becomes available, we can create <b>Async [B]</b> and wait for its result.  The function for such a continuation will look like this: </p><br><p> <code>Async[A].then : (A ‚Üí Async[B]) ‚Üí Async[B]</code> </p> <br><p>  Those.  if we can create <b>Async [B]</b> from a certain <b>A</b> , as well as we have <b>Async [A]</b> , who will ever provide us with <b>A</b> , there is no problem to provide <b>Async [B]</b> right away, because <b>B</b> we can still get through some that time and in the end everything will converge. </p><br><div class="spoiler">  <b class="spoiler_title">The realization of this good</b> <div class="spoiler_text"><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(starter)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.run = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback)</span></span></span><span class="hljs-function"> </span></span>{ starter(callback); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runParent = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.run; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.then = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback)</span></span></span><span class="hljs-function"> </span></span>{ runParent(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{ f(x).run(callback); }); }); }; }</code> </pre> </div></div><br><p>  And then that our synthetic example becomes higher: </p><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherAsync(a).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> asyncAgain(b).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> andAgain(b, c); }).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lastAsync(d); }); }); }</code> </pre> <br><p>  But more interesting.  Explicitly distinguish between the type of asynchronous value and error / result.  Now we always have <b>Async [E + R]</b> (plus this is a type-sum, one of two).  And then we can, for example, introduce the <code>Async[E + R].success : (R ‚Üí Async[E + N]) ‚Üí Async[E + N]</code> .  Note that <b>E is</b> left untouched. </p><br><p>  We can only implement this method so that it performs the function passed to it only if it receives a successful result (that is, receives <b>R</b> , not <b>E</b> ) and runs the next asynchronous operation, otherwise the result of the asynchronous operation continues to be "erroneous." </p><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.success = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Async(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callback)</span></span></span><span class="hljs-function"> </span></span>{ runParent(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.isError()) callback(x); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> f(x).run(callback); }); }); };</code> </pre> <br><p>  Now, if we chain asynchronous operations using the <b>success</b> method, we will process only the successful development branch of events, and any error will slip through all the subsequent handlers and go straight to the callback passed to <b>run</b> . </p><br><p>  We have just abstracted the flow of execution and introduced <b>exceptions</b> into our abstraction.  If you play a little more, you can think of the <b>failure</b> method, which can convert the error to another error, or return a <b>successful result</b> . </p><br><h2 id="promisy-promises-obeschaniya">  Promises (promises) </h2><br><p>  There is a standard that describes the <a href="https://promisesaplus.com/">Thenable</a> interface.  It works almost identically to what was described above, but in <b>Promises / A +</b> there is no concept of <b>starting</b> an asynchronous operation.  If we have at the hands of <b>Thenable</b> , then already somewhere something is being done and all we can do is to subscribe to the result of the execution.  And there is one <b>then</b> method that accepts two optional functions for processing a successful / failed branch, and not different methods. </p><br><p>  Here, too, the taste and color, both approaches have pros and cons. </p><br><h2 id="asyncawait--promisy--korutiny">  async / await - promises + corutines </h2><br><p>  To use promises, we need to use lambda functions in unbelievable quantities.  Which can be quite visually noisy and uncomfortable.  Is it possible to do this somehow better? </p><br><p>  There is. </p><br><p>  We have <a href="https://habrahabr.ru/post/318786/">Korutin</a> who can have a lot of entry points.  And this is what we need.  Let us have a korutina, which gives out <b>Async [E + R]</b> , and the resulting <b>R</b> is fed inside it, or the exception <b>E is</b> raised.  And then Zen begins: </p><br><pre> <code class="hljs cs">function someAsync*(a) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anotherAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">), c</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">asyncAgain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b</span></span></span><span class="hljs-function">), d</span></span> = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">andAgain</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">b, c</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lastAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">d</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Then we need an ‚Äúexecutor‚Äù of such kindness, which will accept this quorutine, to get exits from it, if they are <b>Asyncs</b> ‚Äî to execute them, if by other Qorutines ‚Äî to recursively execute them, considering the result of the last <b>yield</b> . </p><br><p>  And <b>async / await</b> is when we <b>yield</b> renaming to <b>await</b> , and before declaring the function, we write <b>async</b> .  Well, and sometimes (in the case of Python, for example), you can see <b>asynchronous generators</b> , in which both <b>yield</b> and <b>await are available</b> .  Then they behave like the same Korutin, but operations with it become asynchronous, because between the return / acceptance she is waiting for the results of her internal asynchronous operations. </p><br><hr><br><p>  Well, on this my series of articles ends, I hope they were useful to someone and did not confuse even more. </p></div><p>Source: <a href="https://habr.com/ru/post/319350/">https://habr.com/ru/post/319350/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319340/index.html">Get an investment of up to $ 100,000 and launch joint projects with the leaders of the advertising industry</a></li>
<li><a href="../319342/index.html">Higher education and IT - current realities and perspectives, opinions and experience of experts</a></li>
<li><a href="../319344/index.html">Automation of business processes. Ad-hoc changes on the example of life. Part 3</a></li>
<li><a href="../319346/index.html">LexikFormFilterBundle, create filter forms even faster</a></li>
<li><a href="../319348/index.html">Overview of cross-platform solutions for mobile application development</a></li>
<li><a href="../319352/index.html">VoIP telephony. Asterisk. Non-standard approach to everything. Part 1</a></li>
<li><a href="../319354/index.html">Data center infrastructure: what awaits us in the new year. Trends and opinions</a></li>
<li><a href="../319356/index.html">Religious compilation. Dogma technician</a></li>
<li><a href="../319358/index.html">PropTypes - type checking in React</a></li>
<li><a href="../319360/index.html">Viber vulnerability, allowing to listen to someone else's conversation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>