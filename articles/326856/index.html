<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make your C ++ code cross-platform?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhaps someone, after reading the title, asks: ‚ÄúWhy do something with your code? After all, C ++ is a cross-platform language! ‚Äù In general, this is ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make your C ++ code cross-platform?</h1><div class="post__text post__text-html js-mediator-article">  Perhaps someone, after reading the title, asks: ‚ÄúWhy do something with your code?  After all, C ++ is a cross-platform language! ‚Äù  In general, this is so ... but only now there are no strings on the specific capabilities of the compiler and the target platform ... <br><br>  In real life, developers who solve a specific task for a specific platform rarely ask themselves: ‚ÄúIs this exactly what corresponds to the Standard C ++?  What if this is an extension of my compiler. ‚Äù  They write code, run the build, and repair the places their compiler has cursed. <br><br>  As a result, we get an application that, to some extent, is ‚Äúsharpened‚Äù for a specific compiler (and even for its specific version!) And the target OS.  Moreover, due to the scarcity of the standard C ++ library, some things are simply impossible to write without using the specific API of the system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So it was with us in Tenzor.  We wrote on MS Visual Studio 2010. Our products were 32-bit Windows applications.  And, of course, the code was permeated with all sorts of ties to the technology from Microsoft.  Once we decided that it was time to explore new horizons: it was time to teach VLSI to work under Linux and other operating systems, it was time to try to switch to another hardware (POWER). <br><br>  In this series of articles, I will tell you how we made our products real cross-platform applications;  how they made them work on Linux, MacOS, and even on iOS and Android;  how they launched their applications on a variety of hardware architectures (x86-64, POWER, ARM, and others);  as taught to work on big-endian machines. <br><img src="https://habrastorage.org/files/061/63c/d9b/06163cd9b2474cc4bb5b9e4a2258e022.png"><br><a name="habracut"></a><br>  The basis of all our products is our own framework ‚ÄúVLSI Platform‚Äù (hereinafter referred to as ‚ÄúPlatform‚Äù), which is comparable in scale to Qt.  The platform has almost everything a developer needs: from simple functions of fast number-to-string conversion to a powerful fault-tolerant application server. <br><br>  On the basis of the Platform, our developers implement their products (even mobile applications) that solve all sorts of business problems.  We wanted to free their code (hereinafter, we will call their code ‚Äúapplied‚Äù) from all sorts of strings on the target software and hardware platform, hiding all the specifics in the depths of our framework. <br><br>  The VLSI platform is written in C ++, but this does not limit the application programmer to choose a language, in addition to C ++, JavaScript, Python, SQL can be used. <br><br>  Our company is actively developing its products, so it was necessary to "repair the train at full speed" :) <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UZq4sZz56qM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  It was necessary to work in such a way that the rest of the developers would not suffer from our activities and would continue to develop their functionality under Windows on MSVC with comfort.  This requirement has greatly affected many technical solutions and has greatly complicated the work. <br><br>  In order for the reader to form an idea of ‚Äã‚Äãthe scale of the work, I will give some figures: <br><br><ul><li>  The code size of our framework is ~ 2 million lines </li><li>  The volume of the ‚Äúapplication‚Äù code (code based on the VLSI platform that solves specific business problems) is difficult to estimate, but it is several times larger than the volume of the Platform </li><li>  Over a thousand programmers in ten development centers </li></ul><br>  The boring entry is over.  Now let's get closer to the case and consider the problems we faced. <br><br><h2>  Using the operating system API </h2><br>  As mentioned above, the standard C ++ library is very poor; it does not include many of the necessary features everywhere.  For example, in C ++ 11 there is no functionality for working with the network ... That is, as soon as we wanted to make the simplest HTTP request, we have to ... write a non-platform code! <br><br>  The situation is even more aggravated if you are not using the latest version of the compiler, as we did - in MSVS 2010 disgusting support for C ++ 11, there is no huge part of the innovations in the core language and in the standard library. <br><br>  But, fortunately, such problems are solved quite easily.  There are several ways: <br><br><ul><li>  We write our class, with several platform-specific implementations based on the target system API calls.  During the assembly, ifdef preprocessor directives choose the appropriate implementation. </li><li>  We use cross-platform libraries - there are many ready-made cross-platform libraries (again, using platform-specific implementations within themselves), which greatly facilitate our task.  For example, to implement an HTTP client, we took cURL. </li></ul><br><h2>  Features of compiler implementations </h2><br>  Every program has bugs.  And the compiler is also no exception.  Therefore, even the code that is 100% compliant with the Standard may not be compiled on any compiler. <br><br>  Also, almost all compiler developers consider it their duty to add features not provided by the Standard to their offspring, and thus provoke programmers to write intolerable code. <br><br>  What we get in the end?  Code that is clearly written according to the Standard may not be compiled on any compiler;  code that compiles and runs on one compiler may not build up or make money wrong on the other ... <br><br>  You can list many problems of this class.  Here is one of them: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception( <span class="hljs-string"><span class="hljs-string">"-   "</span></span> ); <span class="hljs-comment"><span class="hljs-comment">//    MSVC++,       </span></span></code> </pre> <br>  This code will be assembled in MSVC ++, since they have an additional constructor defined: <br><br><pre> <code class="cpp hljs">exception( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* msg ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span>;</code> </pre> <br>  Unfortunately, there are no general methods for solving such problems.  In these cases, only the experience gained in studying the tools used in the work, and a good knowledge of the Standard C ++, helps. <br><br>  In subsequent articles, I will return to this issue, describe in detail the most common problems and propose methods for solving them. <br><br><h2>  Indefinite behavior </h2><br>  In C ++ Standard, there is an interesting term ‚Äúundefined behavior‚Äù (undefined behavior).  Here is his definition from Wikipedia: <br><blockquote>  Undefined behavior (English undefined behavior, in some sources unpredictable behavior [1] [2]) is a property of some programming languages ‚Äã‚Äã(most noticeable in C), software libraries and hardware in certain marginal situations to produce a result that depends on the implementation of the compiler ( , microcircuits) and random factors like memory conditions or triggered interrupts.  In other words, the specification does not define the behavior of the language (libraries, microchips) in any possible situations, but says: ‚Äúunder condition A, the result of operation B is not defined‚Äù.  Allowing such a situation in the program is considered an error;  even if the program is successfully executed on some compiler, it will not be cross-platform and may fail on another machine, in another OS or with different compiler settings. </blockquote><br><img src="https://habrastorage.org/files/d1f/50e/b84/d1f50eb84efb4720b63255541765b8be.png"><br><br>  If you allow an undefined behavior in your program, this does not mean that it will fall or produce any errors in the console.  Such a program may well work as expected.  But any change in the compiler settings, switching to another compiler or to another version of the compiler, or even modifying any code snippet can change the behavior of the program and break everything! <br><br>  Many situations with undefined behavior on one particular compiler give consistently identical behavior, and your carefully tested application will work like a Swiss watch.  But as soon as we change the environment (for example, we try to run a program compiled by another compiler), these bugs begin to assert themselves and completely break the program. <br><br>  The classic example of undefined behavior is going beyond the array on the stack.  Below is a simplified code snippet from one of our applications with this problem.  This bug did not manifest itself under Windows for several years and "shot" only after porting under Linux: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeFunction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> hex[<span class="hljs-number"><span class="hljs-number">9</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// some code hex[9] = 0; //      return hex; }</span></span></code> </pre> <br>  Apparently, MSVS leveled the buffer on the stack, adding several bytes after it, and when overwriting someone else's memory, we got to an empty, unused space.  And in GCC, the problem began to manifest itself in an interesting way - the program fell far from this code, in another function (apparently, GCC zainlaynil this function, and she began to rewrite the local variables of another function). <br><br>  There are more elegant, elusive situations with UB.  For example, you can step on a very interesting rake when using std :: sort: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &gt; v = some_func(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( v.begin(), v.end(), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s2 ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( s1.empty() ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1 &lt; s2; } );</code> </pre> <br>  It would seem, where can there be UB?  And the whole thing in the "bad" comparator. <br>  The comparator should return true if s1 needs to be put before s2.  Consider what our comparator will issue if it receives two empty lines at the input: <br><br>  s1 = ""; <br>  s2 = ""; <br>  cmp (s1, s2) == true =&gt; s1 should be in front of s2 <br>  cmp (s2, s1) == true =&gt; s2 should be in front of s1 <br><br>  Thus, there are situations where the comparator contradicts itself, that is, does not set strict weak ordering (link to <a href="https://en.wikipedia.org/wiki/Weak_ordering">en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a> ).  Therefore, we violated the std :: sort requirements on the arguments and got unspecified behavior. <br><br>  And this is not a sham example.  Such a problem we caught while upgrading to Linux.  The comparator with a similar error worked for many years under Windows and ... began to crash the application with SIGSEGV under Linux (i686).  Interestingly, the bug behaves differently, even on different Linux distributions (with different GCCs on board): somewhere the application crashes, somewhere hangs, somewhere it simply sorts not as expected. <br><br>  Often situations with undefined behavior can be caught with static analyzers (including those built into the compiler).  Therefore, in the build settings, you should always set the maximum warning level.  And in order not to lose the useful warning in the crowd of warnings of the ‚Äúunused variable‚Äù type, it is useful to clean up the code once and then turn on the assembly option ‚Äútreat warnings as errors‚Äù in order to prevent the appearance of new unsung warnings. <br><br><h2>  Data models </h2><br>  Standard C ++ does not give any hard guarantees about the representation of data types in computer memory;  it sets only some relationships (for example, sizeof (char) &lt;= sizeof (short) &lt;= sizeof (int) &lt;= sizeof (long) &lt;= sizeof (long long)) and provides ways to determine the characteristics of types. <br><br>  Different systems may differ significantly in the way types are represented.  The dimensions of the base types are specified by the data model.  The data model should be understood as the ratios of the types of dimensions adopted within the framework of the development environment.  The table below lists the popular data models and shows the corresponding dimensions of the main types of C ++. <br><br><img src="https://habrastorage.org/files/540/085/594/5400855940e34eecb3566e62756fc528.png"><br>  In the overwhelming majority of cases, when choosing a data type, a programmer needs guarantees about its size.  But in practice, developers are often simply tied to the size of the basic types in the system on which they work.  And again, when switching to a different software or hardware platform, we get surprises: some code stops gathering, some starts to work differently or stops working at all. <br><br>  For example, the hash function below will produce different results on the same data when running on different platforms: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* buf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; ++i ) res = res * buf[i] + buf[i] + i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br>  Most of these problems are solved by using types with a guaranteed size: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int8_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">int16_t</span></span>  . . <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> some_hash( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; ++i ) res = res * buf[i] + buf[i] + i; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><h2>  Char </h2><br>  I guess not many developers wondered if char was a sign.  And if such a question arose, the majority opened their favorite development environment, wrote a small test program and got the answer ... true only for their system. <br><br>  In fact, Standard C ++ does not stipulate char charity.  Because of this, there are compiler implementations in which char is signed, but there are those where char is unsigned.  And this is another reason due to which your program may refuse to work after building for another system. <br><br>  For example, this code works as expected on Linux x86-64, but does not work on Linux POWER (when building in GCC with default parameters): <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_ascii</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  To get rid of uncertainty, it is enough to add an explicit cast to the desired type: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_ascii</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt;( s ) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  in our example, it is possible to completely rewrite the code for bit operations: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_ascii</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s &amp; <span class="hljs-number"><span class="hljs-number">0x80</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><h2>  String representation </h2><br>  Standard C ++ does not regulate some aspects in any way, and each compiler solves these issues at its discretion. <br><br>  For example, there are no guarantees as string constants will be represented in memory. <br>  The MSVS compiler encodes string constants in Windows-1251, and GCC encodes UTF-8 by default. <br><br>  Because of such differences, the same code will produce different results: strlen ("Habr") in the program compiled on MSVS will produce 4;  in the GCC - 8. <br><br>  The same problems will come in data input and output.  For example, our test program can save and read data in some text files: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readstr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ifstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"file.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getline( f, s ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writestr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; s )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">ofstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"file.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; f.write( s.c_str(), s.size() ); }</code> </pre> <br>  Everything will work fine as long as these files are written and read by applications compiled in the same environment.  But what will happen if this file writes a Windows application, and reads the application under Linux? .. We get ‚Äúkrakozyabry‚Äù :) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6ba/3c4/869/6ba3c4869fee4ad7bc25e0c637269a35.png"></div><br>  How to be in such cases?  The general principle of possible solutions is to choose some kind of unified way of representing strings in the program's memory and to do explicit encoding / decoding of strings during input / output.  Many developers use UTF-8 encoding in their programs.  And this is a very good decision. <br><br>  But, as I mentioned above, we ‚Äúrepaired the train at full speed,‚Äù and we could not break some of the invariants on which our code relied (it was developed taking into account that the string encoding is Windows-1251): <br><br><ul><li>  fixed width of characters - random access to a character by its index is possible </li><li>  there is the possibility of writing string constants in Russian in the code </li></ul><br>  In UTF-8 encoding, characters can be represented by different numbers of bytes, which is why it does not satisfy the first requirement.  The second requirement in the case of UTF-8 is not met, for example, in MSVC 2010, where string constants are encoded in Windows-1251.  Therefore, we had to abandon UTF-8, and we decided ... to completely abstract away from the encoding in which the strings are presented, and switched to ‚Äúwide strings‚Äù (wide strings). <br><br>  This solution almost completely satisfied our requirements: <br><br><ul><li>  On almost all UNIX systems, the ‚Äúwide strings‚Äù are represented by UTF-32 encoding, that is, the width of characters in it is fixed and coincides with the size of an element of type wchar_t </li><li>  On Windows, UTF-16 is used.  This encoding is somewhat more complicated, since some characters can be represented by surrogate pairs.  But, fortunately, all that is in Windows-1251, on which our Windows-based application was running, is represented by two-byte sequences.  Therefore, at the initial stage, we did not support the surrogate pairs at all and made an assumption that under Windows all characters fit into one wchar_t element. </li><li>  In C ++, you can set "wide" string constants, for example, L "Hello, habr!".  In this case, the compiler itself takes care of the conversion of this line from the encoding of the source file to the encoding in which wchar_t is represented on the target system. </li></ul><br>  In addition, when using "wide lines" we got a number of advantages: <br><br><ul><li>  In standard C and C ++ libraries there are many functions and classes for working with ‚Äúwide strings‚Äù - there is no need to write your own analogs of the functions strlen, strstr, classes std :: string, std :: stringstream, etc. </li><li>  Many third-party libraries support "wide strings" (for example, BOOST) </li><li>  Most WinAPI can work with ‚Äúwide strings‚Äù </li></ul><br>  On all the platforms we need, "wide characters" are represented by Unicode.  Due to this, our applications are no longer limited to Latin and Cyrillic, they support all languages ‚Äã‚Äãof the world. <br><br>  In fact, dealing with encodings was the most difficult part of porting our products.  You can tell a lot more about it - let's leave it for the next articles :) <br><br><h2>  OS file system features </h2><br>  The Windows file system has several differences from the majority of UNIX-like file systems: <br><br><ol><li>  It is case-insensitive. </li><li>  It allows you to use the "\" symbol as a path delimiter. </li></ol><br>  What does this lead to?  You can name your header file ‚ÄúFiLe.H‚Äù, and in the code write ‚Äú#include &lt;myfolder \ file.h&gt;‚Äù.  On Windows, this code will compile, and on Linux you will get an error that the file named ‚Äúmyfolder \ file.h‚Äù was not found. <br><br>  But, fortunately, to avoid such problems is very simple - it is enough to accept the rules for naming files (for example, to name all the files in lower case) and stick to them, and always use ‚Äú/‚Äù as path delimiters (Windows also supports it). <br><br>  In order to completely eliminate annoying errors, we hung a simple hook on our git repositories, which checks the compliance of the include directives with these rules. <br><br>  Also, features of the file system affect the application itself.  For example, <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> root_path = get_some_path(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path = root_path + <span class="hljs-string"><span class="hljs-string">'\\'</span></span> + fname;</code> </pre> <br>  If you have code that ‚Äúglues‚Äù the paths through normal string concatenation operations and uses ‚Äú\‚Äù as delimiters, then it will break, since under some OS the separator will be perceived as part of the file name. <br><br>  Of course, you can use '/', but in Windows it looks ugly, and in general there are no guarantees that there will not be an OS that will use some other separator. <br><br>  To solve this problem, we use the library boost :: filesystem.  It allows you to correctly form the path for the current system: <br><br><pre> <code class="cpp hljs">boost::filesystem::path root_path = get_some_path(); boost::filesystem::path path = root_path / fname;</code> </pre> <br><h2>  Conclusion </h2><br>  Developing cross-platform C ++ software is not a trivial task.  It is probably impossible to write a program that will work on various software and hardware platforms without any additional effort.  And it is impossible to develop a large program in C ++, which will correctly assemble on any compiler for any OS and for any hardware, despite the fact that C ++ is a cross-platform language.  But if you adhere to a number of rules that I briefly stated in the article, then you will be able to write code that will run on all the platforms you need.  Yes, and transfer this program under the new OS or hardware will not be so difficult. <br><br>  Total to write cross-platform code you need: <br><br><ul><li>  It is good to know the Standard C ++, to understand what is allowed in it, and what is an extension of a particular compiler or even leads to undefined behavior. <br><br></li><li>  Abandon the use of the system's API in code by encapsulating platform-specific code in some classes or using ready-made cross-platform libraries. <br><br></li><li>  To take into account possible differences in typing, not to be tied to the properties of the basic types, which are not guaranteed by the Standard C ++.  To do this, you can use types with fixed dimensions from the standard C ++ library. <br><br></li><li>  Decide on the format of the lines in the program memory.  There may be many options.  For example, use UTF-8, as is done in many programs, or even go to the "wide" lines, abstracting from the format of the representation of lines at all. <br><br></li><li>  Consider the features of file systems on different operating systems (both in code, in #include directives, and in the logic of the program itself). </li></ul><br>  <b>Author: Alexey Konovalov</b> </div><p>Source: <a href="https://habr.com/ru/post/326856/">https://habr.com/ru/post/326856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326840/index.html">Mustached shooter with a polygonal belly. Part two</a></li>
<li><a href="../326846/index.html">A simple error in coding does not mean a non-fearful error.</a></li>
<li><a href="../326848/index.html">Android application performance</a></li>
<li><a href="../326852/index.html">Cooking Physically Based Rendering + Image-based Lighting. Theory + practice. Step by step</a></li>
<li><a href="../326854/index.html">TypeScript to Slack</a></li>
<li><a href="../326860/index.html">Machine Learning Boot Camp IV. Fourth. Secret. Your</a></li>
<li><a href="../326862/index.html">Banks and money through science fiction</a></li>
<li><a href="../326866/index.html">Breaking can not be pardoned, or what awaits hackers on PHDays VII</a></li>
<li><a href="../326868/index.html">Embedding Apple Music in an iOS application</a></li>
<li><a href="../326870/index.html">VMware vSAN 6.6 ‚îÄ new release features</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>