<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast calculation of accurate 3D distance map using CUDA technology</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Distance Map is an object that allows you to quickly get the distance from a given point to a certain surface. Usually it is a matrix of distance valu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast calculation of accurate 3D distance map using CUDA technology</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/104/3f9/01e/1043f901e901fbce59a9064646acbcf2.png" align="right">  Distance Map is an object that allows you to quickly get the distance from a given point to a certain surface.  Usually it is a matrix of distance values ‚Äã‚Äãfor nodes with a fixed step.  It is often used in games to determine ‚Äúhitting‚Äù a player or object, and for optimization problems of combining objects: arrange objects as close as possible to each other, but so that they do not overlap.  In the first case, the quality of the distance map (that is, the accuracy of the values ‚Äã‚Äãin the nodes) does not play a big role.  In the second, life may depend on it (in a number of applications related to neurosurgery).  In this article I will tell you how you can quite accurately calculate the map of distances in a reasonable time. <br><a name="habracut"></a><br><h5>  Main objects </h5><br>  Suppose we have some surface S given by a set of voxels.  The coordinates of the voxels will be calculated on a regular grid (i.e., the steps for X, Y, and Z are the same). <br><br>  It is required to calculate the distance map M [X, Y, Z] for all voxels that lie in a cube containing a surface;  M [x, y, z] = d ((x, y, z), S) = min (d ((x, y, z), (S <sub>n</sub> x, S <sub>n</sub> y, S <sub>n</sub> z)) = sqrt (min ((xS <sub>n</sub> x) <sup>2</sup> + (yS <sub>n</sub> y) <sup>2</sup> + (zS <sub>n</sub> z) <sup>2</sup> )). The last equality is true only for a regular grid, the rest should be obvious. <br><br><h5>  Where does the data come from </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/266/2a8/c3e/2662a8c3ec053e5f7b1dbb417eeddb61.png" align="right"><br>  For our task, the data comes from the <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B3%25D0%25BD%25D0%25B8%25D1%2582%25D0%25BD%25D0%25BE-%25D1%2580%25D0%25B5%25D0%25B7%25D0%25BE%25D0%25BD%25D0%25B0%25D0%25BD%25D1%2581%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25BE%25D0%25BC%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D1%258F">MRI</a> .  Let me remind you that we work with 3D images, so that the entire 3D image is a set of flat pictures for different slices in Z, which I, of course, cannot imagine everything here;  they are slightly smaller than the X and Y resolution. The typical tomography size is about 625x625x592 voxels. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/075/881/da7/075881da78831a8c3a48a4907756bece.png" align="left"><br>  As a result of quite tricky transformations, the boundary of the surface of the head is highlighted.  The very essence of these transformations is reduced to a variety of filters that remove the "noise" and the function that defines the actual boundary by gradient.  There is nothing new here, about such things was told in the subject ‚ÄúImage Processing‚Äù, <a href="http://habrahabr.ru/blogs/image_processing/114489/">in particular</a> .  Actually, the boundary is the target set, to which we will calculate distances and build a map. <br><br><h5>  Brute force </h5><br>  Let us estimate to begin with, why not fill the distance map with the values ‚Äã‚Äã‚Äúby definition‚Äù - the minimums of the distances to the points of the border.  Total points of the map: X * Y * Z, surface points of order max (X, Y, Z) <sup>2</sup> .  Recall the size of the source data and get something about 592 * 625 <sup>4</sup> arithmetic logic operations.  The calculator will tell you that this is more than 90,000 billion.  To put it mildly, a bit too much, let's postpone until a direct search. <br><br><h5>  Dynamic programming </h5><br>  This suggests the use of data presented in a three-dimensional array;  you can somehow calculate the value at each point using its neighbors, and of course we are not the first to do this.  Somewhat repels the fact that keeping in memory a structure of size 592 * 625 * 625 * sizeof (float), which is about 1 Gigabyte, is somewhat resource-intensive.  Well, okay, let's forget for now that tomography can be removed with a double resolution (8 more times more) - 640Kbyte has long been missing. <br><br>  The most trivial method of filling (city-block), similar to the <a href="http://habrahabr.ru/blogs/algorithm/113108/">algorithm for traversing the maze</a> , works out in a matter of seconds, but the maximum error on the three-dimensional grid can be 42 grid steps for the maximum calculated distance of 50 steps.  How bad is it?  Complete failure. <br><br>  A single algorithm from the class ( <a href="http://www.merl.com/papers/docs/TR99-26.pdf">central point</a> ) gives almost satisfactory accuracy (an error of no more than 0.7 grid steps), but minutes are running. <br><br>  We tried to find a compromise by implementing the chessboard distance (described in the same article as the central point), but the final accuracy could not be arranged, and the time of its work was tens of seconds. <br><br> <a href=""><img align="right" src="https://habrastorage.org/getpro/habr/post_images/8e4/bb0/96f/8e4bb096f2e3f161d6960011c6e1bd5b.png"></a>  A picture is a link to a full-sized one, but even on the preview you can see ‚Äústrange‚Äù behavior far enough from the surface points, and especially if you need to cheat more internal objects.  On the left is the chessboard, and on the right is what was obtained by brute force.  And once again I remind you that for those who look only at the pictures - we are talking about 3D images, so strange ‚Äúpunctures‚Äù inside are explainable - they are caused by proximity to the surface on the next or previous slides in Z. In general, failure. <br><br><h5>  Brute force again </h5><br>  Yes, the word CUDA in the picture as if hints.  Maybe 90000 billion - not so much, but maybe this number can be somehow reduced, without loss of accuracy.  In any case, the middle-end video card copes with primitive computational operations 80-120 times faster than a processor of a similar class.  Let's try. <br><br>  Yes, brute force has a significant advantage - there is no need to keep the entire distance map in memory, and as a result - linear scalability. <br><br><h5>  Brute force reduction </h5><br>  Thesis: it makes no sense for each point to check the distance to each point of the border.  In fact, the distance map is obliged to ensure good accuracy only in the immediate vicinity of the border, rather distant points can not be considered at all, and the intermediate ones can be marked with an approximate distance. <br><br>  The criterion of correctness is absolute accuracy near the border (at a distance of 10 (GUARANTEED_DIST) grid steps), good accuracy at a distance of 36 (TARGET_MAX_DIST) steps, and visual adequacy (without artifacts - why confuse surgeons).  The numbers 10 and 36 came directly from our problem (we generally have the values ‚Äã‚Äãin millimeters and the millimeter grid). <br><br><h5>  Cubic index </h5><br>  For each point I would like to determine how accurately its value should be calculated.  It is obvious that the size of such a structure will coincide with the size of the original image, and this is a lot and will be considered for a long time. <br><br>  We will merge points into ‚Äúcubes‚Äù.  Let the die size be 32 (CUBE_SIZE), then the index will have dimensions of 20 x 20 x 19. <br><br>  Mark the cube as the "best" point lying in it.  If at least one point requires an exact calculation, we count the whole cube for sure.  In the worst case, we do not count at all. <br><br>  How to quickly mark the cubes?  Let's start with the points of the border: add to each of them an offset of GUARANTEED_DIST in all 27 directions ((-1,0,1) x (-1,0,1) x (-1,0,1)), we get the index of the corresponding die, by dividing by 32 (CUBE_SIZE), and mark it as ‚Äúexact‚Äù - because it contains at least one point that requires accurate calculation.  Task: explain why this is enough, and all cubes containing points for accurate calculation will be marked correctly. <br><br>  Just in case, the rather trivial code that it executes is: <br><br><blockquote><code><font color="black"><font color="#0000ff">for</font> (size_t t = 0; t &lt; borderLength; t++) <br> { <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> dz = -1; dz &lt;= 1; dz++) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> dy = -1; dy &lt;= 1; dy++) <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> dx = -1; dx &lt;= 1; dx++) <br> { <br> <font color="#0000ff">float</font> x = border[t].X + ( <font color="#0000ff">float</font> )dx * GUARANTEED_DIST; <br> <font color="#0000ff">float</font> y = border[t].Y + ( <font color="#0000ff">float</font> )dy * GUARANTEED_DIST; <br> <font color="#0000ff">float</font> z = border[t].Z + ( <font color="#0000ff">float</font> )dz * GUARANTEED_DIST; <br> <font color="#0000ff">if</font> (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; z &gt;= 0) <br> { <br> size_t px = round(x / CUBE_SIZE); <br> size_t py = round(y / CUBE_SIZE); <br> size_t pz = round(z / CUBE_SIZE); <br> size_t idx = px + dim_X * (py + skip_Y * pz); <br> <font color="#0000ff">if</font> (idx &lt; dim_X * dim_Y * dim_Z) <br> { <br> markedIdx[idx] = <font color="#0000ff">true</font> ; <br> } <br> } <br> } <br> }</font> <br></code> </blockquote><br><br>  On practical data, this idea allowed to reduce the order of ‚Äúall‚Äù enumeration by 4-5 times.  Anyway, it turns out a lot, but the idea with the cubes will still come in handy. <br><br><h5>  Cubic container </h5><br>  In fact, it makes no sense to calculate the distance to all points of the boundary; it suffices to calculate it only for the nearest points;  and now we know how to organize such a structure. <br><br>  Scatter all voxels of the S boundary into cubes (we will forget about index cubes from the present moment; we have built them, understood how to use them, and now we don‚Äôt work with them anymore).  In each cube we will put those points of the boundary that are reachable (lie at a distance of TARGET_MAX_DIST and less).  To do this, it is enough to calculate the center of the cube, and postpone the distance sqrt (3) / 2 * CUBE_SIZE (this is the diagonal of the cube) + TARGET_MAX_DIST.  If a point is reachable from the top of the cube or from any point on the side, then it is reachable from its inside. <br><br>  I think it makes no sense to give the code, it is very similar to the previous one.  And the correctness of the idea is also obvious, but one essential point remains: in fact, we ‚Äúmultiply‚Äù points of the border, the number of which can increase up to 27 times with a reasonable TARGET_MAX_DIST (smaller cube size) and even more times different. <br><br>  Optimization: <br><ul><li>  The first (forced) - the size of the cube is chosen so that the total number of ‚Äúmultiplied‚Äù points is not greater than the maximum memory size for them (we took 512 megabytes).  Pick up the size of the cube can be quickly (a little math). </li><li>  The second (reasonable) is to use indexes on the initial and final placement of points for each die, these indexes can intersect, and due to their correct calculation, you can save another 2 times in terms of memory size. </li></ul><br>  I deliberately will not give exact algorithms for both points (what if you implement them better and become our competitors?;)), There are more words than ideas. <br><br>  In general, the cubes reduce the brute force order by X / CUBE_SIZE * Y / CUBE_SIZE * Z / CUBE_SIZE times, but we must remember that reducing the size of the die will require significantly more memory, and the threshold value for our images turned out to be around 24-32. <br><br>  Thus, the task has been reduced to about 100-200 billion material operations.  Theoretically, it is computable on a video card in tens of seconds. <br><br><h5>  CUDA Core </h5><br>  It turned out so simple and beautiful that I will not be too lazy to show it: <br><br><blockquote> <code><font color="black">__global__ <font color="#0000ff">void</font> minimumDistanceCUDA( <font color="#008000">/*out*/</font> <font color="#0000ff">float</font> *result, <br> <font color="#008000">/*in*/</font> <font color="#0000ff">float</font> *work_points, <br> <font color="#008000">/*in*/</font> <font color="#0000ff">int</font> *work_indexes, <br> <font color="#008000">/*in*/</font> <font color="#0000ff">float</font> *new_border) <br> { <br> __shared__ <font color="#0000ff">float</font> sMins[MAX_THREADS]; <font color="#008000">// max threads count</font> <br> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> i = blockIdx.x; i &lt; BLOCK_SIZE_DIST; i += gridDim.x) <br> { <br> sMins[threadIdx.x] = TARGET_MAX_DIST*TARGET_MAX_DIST; <br> <br> <font color="#0000ff">int</font> startIdx = work_indexes[2*i]; <br> <font color="#0000ff">int</font> endIdx  = work_indexes[2*i+1]; <br> <br> <font color="#0000ff">float</font> x = work_points[3*i]; <br> <font color="#0000ff">float</font> y = work_points[3*i+1]; <br> <font color="#0000ff">float</font> z = work_points[3*i+2]; <br> <br> <font color="#008000">// main computational entry</font> <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j = startIdx + threadIdx.x; j &lt; endIdx; j += blockDim.x) <br> { <br> <font color="#0000ff">float</font> dist = (x - new_border[3*j] )*(x - new_border[3*j] ) <br> + (y - new_border[3*j+1])*(y - new_border[3*j+1]) <br> + (z - new_border[3*j+2])*(z - new_border[3*j+2]); <br> <font color="#0000ff">if</font> (dist &lt; sMins[threadIdx.x]) <br> sMins[threadIdx.x] = dist; <br> } <br> <br> __syncthreads(); <br> <br> <font color="#0000ff">if</font> (threadIdx.x == 0) <br> { <br> <font color="#0000ff">float</font> min = sMins[0]; <br> <font color="#0000ff">for</font> ( <font color="#0000ff">int</font> j = 1; j &lt; blockDim.x; j++) <br> { <br> <font color="#0000ff">if</font> (sMins[j] &lt; min) <br> min = sMins[j]; <br> } <br> result[i] = sqrt(min); <br> } <br> <br> __syncthreads(); <br> } <br> } <br></font></code> </blockquote><br><br>  We load the block of coordinates of the distance map points for enumeration (work_points), the corresponding starting and ending indices for enumerating the boundary points (work_indexes) and the border optimized by the algorithm with ‚Äúcubes‚Äù (new_border).  The results are taken in single real accuracy. <br><br>  Actually, the kernel code itself, which is pleasantly very understandable, even without the subtleties of CUDA.  Its main feature is the use of variables gridDim.x and threadIdx.x denoting the indices of the current thread from the set of running threads on the video card - they all do the same thing, but with different points, and then the results are synchronized and accurately recorded. <br><br>  It remains only to correctly organize the calculation of work_points on the CPU (but it's so easy!) And start the calculator: <br><blockquote> <code><font color="black"><font color="#0000ff">#define</font> GRID       512 <font color="#008000">// calculation grid size</font> <br> <font color="#0000ff">#define</font> THREADS     96 <font color="#008000">// &lt;= MAX_THREADS, optimal for this task</font> <br> minimumDistanceCUDA&lt;&lt;&lt;GRID, THREADS&gt;&gt;&gt;(dist_result_cuda, work_points_cuda, work_indexes_cuda, new_border_cuda);</font> <br></code> </blockquote><br>  On the Core Duo E8400 and the GTX460 video card, the average tomography is processed <b>within a minute</b> , the memory consumption is limited to 512 MB.  The allocation of CPU time is about 20 percent on the CPU and file operations, and the remaining 80 on the calculation of the minima on the video card. <br><br>  And here is what the picture looks like with the ‚Äúdeafening‚Äù of distant points: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/228/581/799/228581799ba3e3ccf07a6e1bf8274750.png"><br><br>  Somehow, I hope something useful to you.  A big request, do not copy the pictures and do not re-publish without my permission (I am the author of the method, although it is difficult to call it ‚Äúmethod‚Äù). <br><br>  Have a good day! </div><p>Source: <a href="https://habr.com/ru/post/119603/">https://habr.com/ru/post/119603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119594/index.html">At what age did you write your first project?</a></li>
<li><a href="../119597/index.html">2GIS descended on Moscow</a></li>
<li><a href="../119599/index.html">A quick alternative to the Android emulator</a></li>
<li><a href="../119600/index.html">How much money do startups give?</a></li>
<li><a href="../119602/index.html">Mac Defender. Threat to Apple users</a></li>
<li><a href="../119604/index.html">Github rejects internationalization</a></li>
<li><a href="../119607/index.html">kedDroid - S03E03. Video review software for Android</a></li>
<li><a href="../119608/index.html">Rasterization of vector fonts</a></li>
<li><a href="../119609/index.html">Cable marking</a></li>
<li><a href="../119610/index.html">Electronic signature: "works" or not?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>