<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microservice madness will be held in 2018</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It was with such a thesis made by Dave Kerr, whose article gathered 90 comments a month, provoked heated discussions on Reddit and Hacker News , and w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microservice madness will be held in 2018</h1><div class="post__text post__text-html js-mediator-article">  It was with such a thesis made by Dave Kerr, whose <a href="http://www.dwmkerr.com/the-death-of-microservice-madness-in-2018/">article</a> gathered 90 comments a month, provoked heated discussions on <a href="https://www.reddit.com/r/programming/comments/7pxriw/the_death_of_microservice_madness_in_2018/">Reddit</a> and <a href="https://news.ycombinator.com/item%3Fid%3D16200007">Hacker News</a> , and we were so interested that we decided to urgently translate it.  Taking this opportunity, let us take an interest: do you want the reprint of Sam Newman‚Äôs founding book ‚Äú <a href="https://www.piter.com/product_by_id/51778339">Creating Microservices</a> ‚Äù, which was last published here in 2016, or does Mr. Kerr‚Äôs skepticism seem reasonable to you? <br><br>  Read and comment! <br><a name="habracut"></a><br>  In the past couple of years, the topic of microservices has become very popular.  ‚ÄúFanaticism‚Äù of microservice lovers is reduced to something like this syllogism: <br><blockquote>  In Netflix, the devops practice is fine.  Netfix is ‚Äã‚Äãa microservice.  Therefore: if I become a microservice, I‚Äôll succeed in devops. </blockquote>  There are examples when microservice patterns were introduced at the cost of tremendous efforts, and their supporters did not quite understand what the costs of this work were, and whether microservices are great in solving this particular problem. <br><br>  Here I will describe in detail what microservices are, why this paradigm is so attractive, and what are the main challenges that it poses to you. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the final, I will formulate a few simple questions, which are probably worth answering myself, thinking - are microservices suitable for you? <br><br><img src="https://habrastorage.org/webt/q3/no/sp/q3nospyvvpmxtktofe9sf0cpv6u.png"><br><br>  <b>What are microservices, and why are they so popular?</b> <br><br>  Let's start with the basics.  Here's how to implement a hypothetical video sharing platform: first as a monolith (a single large structure), and then as microservices: <br><br><img src="https://habrastorage.org/webt/98/ya/fp/98yafp4gof8n6vdmpjplinrbwvk.png"><br><br>  The difference is that in the first case we have one big structure, and in the second - a set of small specific services.  Each service plays a specific role. <br>  If to draw the scheme <i>with such detailing</i> - it is, of course, attractive.  Potential merits: <br><br>  <b>Independent development</b> : small independent components can be created by small independent teams.  The group can modify the changes in the ‚ÄúDownload‚Äù service without interfering with the development of the ‚ÄúRecode‚Äù service - or even without knowing about it.  The time required to familiarize with the component is significantly reduced, and it is easier to develop new features. <br><br>  <b>Independent deployment</b> : Each individual component can be deployed independently of the others.  Thus, new features can be rolled out faster, with less risk.  If we modify or fix the Streaming Video component, we can deploy it as needed, and we do not need to deploy other components. <br><br>  <b>Independent Scalability</b> : All components can be scaled independently of each other.  In the hot season, when new shows are coming out, the Download component can be enhanced to cope with the increased load, and this does not require building up all the other components.  Elastic scaling, it turns out, is not so difficult to implement, the cost of development is reduced. <br><br>  <b>Reuse</b> : Each component has a small specific function.  Thus, they are easy to adapt for use in other systems, services, or products.  Thus, the ‚Äútranscoding‚Äù component can be used in business elements or even turned into a new component of business logic, possibly providing transcoding options for other groups. <br><br>  With such an approximation, the superiority of microservices over the monolith seems obvious.  So, what's the matter - why is this paradigm most recently in favor?  Where was she before? <br><br>  <b>If they are so cool, why hasn't anyone done it before?</b> <br><br>  There are two answers to this question.  First: <i>engaged</i> - as far as our technical capabilities allowed.  Second, only the latest technological breakthroughs allowed to bring microservice technology to a new level. <br><br>  When I began to write the answer to this question, I got a <i>long</i> explanation, so I decided to put it in a separate article and publish it later.  At this stage, I will not describe the paths from one program to many, I will not dwell on ESB and service-oriented architecture, component design, limited contexts, etc. <br><br>  Those who are interested can read about this path separately.  I would prefer to say that, one way or another, we did it earlier, but thanks to the recent surge in popularity of container technologies (in particular, Docker) and orchestration (for example, Kubernetes, Mesos, Consul, etc.), this pattern has become much easier to implement. from a technical point of view. <br>  So, if we take for granted that we can really build a microservice system, then we should carefully consider: is it necessary?  Theoretically, in the most general terms, the benefits are clear, and what are the challenges? <br><br>  <b>What is the problem with microservices?</b> <br><br>  If microservices are so great, so what's the deal?  These are some of the major issues that I see. <br><br>  <i><b>The task of the developer is complicated</b></i> <br><br>  For the developer, everything can be seriously complicated.  If a programmer wants to develop a whole <i>sequence</i> , or a feature that potentially covers a multitude of services, then he will have to run them all on one machine, or connect to them.  Often it is much more difficult than taking and running a single program. <br><br>  This problem is partially solved with the help of appropriate tools, but as the number of services in the system increases, it will be harder for the developer to run the entire system. <br><br>  <i><b>The tasks of the operators are complicated</b></i> <br><br>  For teams that do not develop services, but support them, the increase in complexity can be explosive.  It is necessary to manage not several services, but several dozens, hundreds or thousands.  More services, more communication paths, more potential points of failure. <br><br>  <i><b>Devops tasks are complicated</b></i> <br><br>  It is possible that someone jarred over that in the two previous points exploitation and support are treated separately, especially considering how popular the practice of devops is today (by the way, I use it with both hands).  Doesn't devops solve these problems? <br><br>  The problem is that in many organizations, operation and support are still performed by different teams, and it is in such an organization that the transition to microservices is likely to be slowed down. <br><br>  For organizations already practicing devops, everything is also complicated.  Being a developer and an operator at the same time is already difficult (but it is necessary to write good programs), but if you also need to understand the nuances of container orchestration systems, especially systems that are rapidly developing, it is extremely difficult.  Here I come to the next item. <br><br>  <i><b>Need serious experience</b></i> <br><br>  If such work is done by experts, the result can be great.  But imagine an organization where, even when operating a single monolith system, everything is not going smoothly.  Name at least one reason why things can get better if the company increases the number of systems, and hence the complexity of their operation? <br><br>  Yes, with effective automation, monitoring, orchestration, etc.  all this is possible.  But the problem is usually not in technology, but in the shortage of people who can use it effectively.  Such skill sets are very much in demand today, and it is difficult to find a good specialist. <br><br>  <i><b>In real systems, the boundaries between components are often fuzzy.</b></i> <br><br>  In all the examples in which the advantages of microservices were demonstrated, we talked about independent components.  However, they are often simply not independent.  On paper, some subject areas may seem clearly delineated, but if you go deeper, in particular, it turns out that the problem is more complicated than you thought. <br><br>  Here everything can become <i>quite</i> difficult.  If the boundaries of components in your system are not clearly defined, then what happens is: although, theoretically, services can be deployed independently of each other, in practice it turns out that they are interdependent and therefore you have to deploy a set of services as a group. <br><br>  This means that you have to manage the agreed versions of the services, that is, services whose reliability has been proven, interactions have been verified.  But in this case, we are no longer talking about an independently deployable system, since developing a new feature requires carefully orchestrating the simultaneous deployment of multiple services. <br><br>  <i><b>Often ignored are state related complications.</b></i> <br><br>  In the previous example, I mentioned that to deploy features, you may need to simultaneously roll out multiple versions of different services as a single group.  It is suggesting that this problem is resolved if you use sensible deployment techniques, for example, blue / green deployment options (which is done with little effort on most orchestration platforms), or when several versions of the service are used in parallel ‚Äî the consuming channels themselves determine which version use. <br><br>  Such techniques allow you to remove a lot of problems if the services do not save state.  But, to be honest, it is easy to work with such services.  In fact, if you are working with stateless services, it is better not to contact the microservice configuration at all and immediately try a serverless model. <br><br>  In fact, many services require <i>maintaining state</i> .  Continuing the example with our video sharing platform, an example of such a service could be a subscription.  New versions of the subscription service can store information in a subscription database in a different configuration.  If you operate both services in parallel, then two schemes work simultaneously in your system.  If you are implementing a green / blue deployment, and other services depend on the data provided in this new configuration, then you need to update them at the same time.  If the subscription service cannot be deployed and you have to roll back, then you may need to roll back all dependent services, which can lead to avalanche-like consequences. <br><br>  Again, it suggests that when using NoSQL databases, such problems with schemas disappear - but this is not the case.  Databases that do not impose a specific schema do not generate schema-free systems ‚Äî simply the management of such a schema is usually implemented at the application level, and not at the database level.  The key problem in this case is to understand the configuration of your data as it develops.  From her nowhere to go. <br><br>  <b>Communication difficulties are often ignored.</b> <br><br>  When building a vast network of interdependent services, it is likely that it will be necessary to provide active communication between them.  Here a few more problems arise.  First, the number of potential points of failure increases significantly.  It should be borne in mind that some network calls will not go through, and this means that when one service calls another, it must be programmed for a minimum number of attempts. <br>  Now, when the service can potentially cause many other services, we find ourselves in a difficult situation. <br><br>  Suppose a user uploads a new video to our video platform.  We need to start the download service, transfer the data to the transcoding service, update the subscriptions, update the recommendations, etc.  All these calls require orchestration to one degree or another, and if the call doesn‚Äôt pass, you need to try again. <br><br>  Such a retry logic can become difficult to manage.  Synchronous operations are often not feasible, because there are too many potential points of failure.  In this case, it is most reasonable to organize communication using asynchronous patterns.  The most difficult thing in this case is that a system with asynchronous communication, by definition, requires building a system with state preservation.  As I mentioned in the previous paragraph, it is very difficult to manage systems with state saving and with distributed states. <br><br>  If the communication between the services of the microservice system is carried out with the help of message queues, we, in essence, have a large database (message queue or broker) ‚Äúgluing together‚Äù these services.  Again, at first glance, such a system may not seem problematic, but later it comes around to you.  A service in version X can record a message in a specific format, and other services that depend on this message will also need to be updated if the sending service changes the details of the message it sends. <br>  You can write such services that can process messages in many different formats, but it will be hard to manage such services.  In this case, when deploying new versions of services, situations are possible when different services try to process messages from the same queue, perhaps even transmitted by different versions of the sending service.  Then there may be complex borderline cases.  In order to avoid them, it may be easier to allow only certain versions of messages to exist: that is, deploy a set of versions of a certain set of services as a consistent whole and ensure that outdated versions of messages will be discarded first. <br><br>  Here, again, you can make sure that in practice, independent deployment is not so easy to organize, if you look at the details. <br><br>  <b>Versioning can be tricky</b> <br><br>  To partially eliminate the above problems, you need to very carefully manage the versioning.  Again, it often seems that if you stick to a standard like semserver, then this problem is solved.  No, not solved.  It is reasonable to stick to Semserver, but you still have to keep track of the versions of services and APIs, and see which ones can interact. <br><br>  Such problems can very quickly become very complicated, and reach a point where you yourself will not be able to imagine which services normally interact with each other. <br>  It is notorious how difficult it is to manage dependencies in a system consisting of Java modules, C libraries, etc.  Difficulties with conflicts between independent components consumed by a specific object are solved very hard. <br><br>  They are complex, even if the dependencies are static - and they can be patched, updated, edited, etc .;  but, if the dependencies themselves are living services, then they probably already cannot be simply updated;  you will have to drive a lot of versions at once (the attendant difficulties are described above), or to stop the system until it is completely updated and fixed again. <br><br>  <b>Distributed transactions</b> <br><br>  In situations where it is necessary to preserve the integrity of transactions within the entire operation, microservices can become a real headache.  It is difficult to work with the distributed state, orchestration of many small modules, each of which may fail, is still a task. <br><br>  You can try to get around this problem by making the operations idempotent, with the possibility of retries, etc., in many cases it will work.  But scenarios are possible when we need to implement only two outcomes of a transaction - ‚Äúsucceeded‚Äù or ‚Äúfailed‚Äù, and not to provide an intermediate state.  The price of such a maneuver or an attempt to implement such a system using microservices can be very high. <br><br>  <b>Microservices can be disguised monolith</b> <br><br>  Yes, single services and components can be deployed separately, but in most cases it will be necessary to use any orchestration platform, for example, Kubernetes.  If you use a managed service, for example, GKE from Google or EKS from Amazon, then complex cluster management will be largely automated. <br><br>  However, if you manage the cluster yourself, then you are dealing with a large, complex system, failures in which are unacceptable.  Yes, a separate service may have all the advantages described above, but it will be necessary to manage the cluster very carefully.  Deploying such a system can be difficult, updating is difficult, recovering from a failure is difficult, and so on. <br>  Often, the fundamental advantages go nowhere, but it is important not to simplify the system and not to underestimate the additional difficulties associated with managing another large and complex system.  Yes, managed services may be useful, but many of them have just appeared (for example, Amazon EKS appeared only at the end of 2017). <br><br>  <b>Finally: do not confuse microservices with architecture</b> <br><br>  I specifically tried not to use the words in the article with the letter ‚Äúa‚Äù.  But my friend <a href="https://twitter.com/zoltanarvai">Zoltan</a> , who read this article (we co-authored it), noticed a very important thing. <br>  Microservice architecture does not exist.  Microservices is just another implementation principle for components, nothing more, nothing less.  The presence or absence of microservices in the system does not mean that its architectural problems have been solved. <br><br>  In many respects, microservices are more concerned with packaging and operation, and not with system design as such.  When engineering such systems, one of the most important tasks is to properly distinguish the components. <br><br>  Regardless of what size your services are, whether they are packed in Docker containers or not - it is always important to think about how to fold the system out of the elements.  There is no single answer, there are always many options. </div><p>Source: <a href="https://habr.com/ru/post/348740/">https://habr.com/ru/post/348740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348730/index.html">GeekBrains begins training information security specialists</a></li>
<li><a href="../348732/index.html">History of hacking one MLM company</a></li>
<li><a href="../348734/index.html">Interview upside down</a></li>
<li><a href="../348736/index.html">DM.Mobile Trade: what puzzles were solved by our Android developers in the new release and why</a></li>
<li><a href="../348738/index.html">Crash Course on Assemblers</a></li>
<li><a href="../348744/index.html">Web development as an incentive or in pursuit of a dream</a></li>
<li><a href="../348746/index.html">Issue # 10: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../348748/index.html">Programming Training: Finger Painting and Killing Zombies</a></li>
<li><a href="../348750/index.html">Open lesson on the topic ‚ÄúAudit of advertising campaigns in Yandex. Direct ¬ª</a></li>
<li><a href="../348752/index.html">How the virtual infrastructure will develop: 4 main trends</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>