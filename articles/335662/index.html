<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitmap way to display tile cards</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Technique automatically select the desired tile from the tile card. 

 At first this article was an answer to a question on TIGSource , but it seemed ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitmap way to display tile cards</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/cd2/40e/5ec/cd240e5ec6b2c65c2715e1438f075b06.png"><br><br>  Technique automatically select the desired tile from the tile card. <br><br>  At first this article was an answer to a <a href="http://forums.tigsource.com/index.php%3Ftopic%3D9859.0">question on TIGSource</a> , but it seemed to me that it was worth expanding it a bit and publishing it separately. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Task: we generated a beautiful platform level and want to be able to automatically place tiles on it, taking into account the neighbors, so that they look correct. <br><br><h2>  Tiles according to their neighbors </h2><br>  Tiles in Super Mario do not take into account their neighbors: the stone block always looks the same, both as a separate fragment and as part of a wall. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f2/743/cd6/5f2743cd6749f084c1b2c914f89baa8b.gif"><br><br>  It is quite suitable for many games, but when creating a more harmonious design it may seem unnatural.  Tiles that take into account their neighbors solve this problem by matching their appearance with neighboring tiles. <br><a name="habracut"></a><br><h2>  Single bit map </h2><br>  Imagine that with some cunning technicians we created a platform level scheme consisting of only stone blocks and the ‚Äúair‚Äù between them.  The level can be represented as a one-bit image, in which the state of each pixel is determined by a single bit (1 is a stone block, 0 is ‚Äúair‚Äù).  Here is an enlarged example of a part of this level with grid lines added: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f82/164/01a/f8216401af6d9115cbac550a58b64c44.png" width="420" height="420"><br><br><h2>  A set of tiles (tileset) </h2><br>  A tileset is a collection of graphic images that can be used to populate a map.  Mario Taylset is quite limited, it consists of several types of blocks and ‚Äúdecorations‚Äù, but our set will contain many images for each type of tiles: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8eb/978/929/8eb978929454cd25ae1ef54997dd6d8a.png" width="480" height="48"><br><br><h2>  We estimate neighbors </h2><br>  To determine which tile should be at a specific point in the map, we need to examine the immediate neighbors of this point (for the time being we ignore the neighbors along the diagonal).  In order not to write large constructions from if / else-if to handle all possible combinations of neighbors, we use a system that assigns values ‚Äã‚Äãin each direction. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/844/b97/5ae/844b975ae0a4decb5cd95cb81ba1a2ce.png" width="184" height="184"><br><br>  The value for each point is found by examining its neighbors and adding values ‚Äã‚Äãfor those of them that have a stone.  For example, if the neighbor in the studied point is above filled with a stone, then it is assigned the value 1. If the neighbors are filled with the stone above and below, then the point is assigned the value 1 + 4, that is, 5. <br><br>  You can see that the assigned values ‚Äã‚Äãof the directions are the same as the values ‚Äã‚Äãin the positions in binary numbers, and this is not surprising: both types of values ‚Äã‚Äãare ways of representing possible combinations of four positions, each of which can be in ‚Äúon‚Äù or ‚Äúoff‚Äù states ( stone or "air"). <br><br>  Here is a map segment with all the tiles filled.  You can try to manually calculate the value for a pair of tiles in order to understand how this works. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae7/e0b/586/ae7e0b586cc2683151b413b1eb61318f.png" width="420" height="420"><br><br><h2>  Adding tiles </h2><br>  The layout of the tileset shown in the image is not accidental: it is arranged so that each tile corresponds to the tile of the map to which a value should be assigned.  Assigning values ‚Äã‚Äãto all points of the map, we simply look for the value in the tileset and place the appropriate tile at this point: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c0d/84d/9fe/c0d84d9fedde772488d4813fb67fa5cf.png" width="420" height="420"><br><br>  Fine! <br><br><h2>  Moving on </h2><br><h3>  Part one: get rid of the "air" </h3><br>  The above example works well for platforms hanging in the air, but in fact does not fully handle two types of tiles. <br><br>  Imagine that instead of a platformer, we are working on a two-dimensional strategy from the top, in which there are two types of tiles - grass and water.  In this case, the tile image will be present at each point of the map, there will be no empty places in it, as in the platformer.  This means that to determine the appropriate tile, each point on the map must have a value generated from its neighbors. <br><br>  We can use exactly the same system of assessing neighbors, as before, but we need a way to determine, when studying a point, whether it is grass or water.  This is very simple to implement - you just need to add one more value to the point itself, using the same pattern ‚Äú2 to the power n‚Äù from other values: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/263/1fd/e9d/2631fde9de3ccbc3bdbfc21837c9935a.png" width="184" height="184"><br><br>  Let's decide that if there is water, we will add to the value of the point, and if there is grass, we will not.  That is, the grass tile, surrounded on all sides by grass, will have a value of 0. The grass tile with water above and to the right is 1 + 8 = 9. The water tile, surrounded on all sides by grass, will have a value of 16. Water tile, surrounded from all sides with water, has the value 1 + 2 + 4 + 8 + 16 = 31 <br><br><h3>  Part Two: Adding Variability </h3><br>  How to ensure the treatment of other types of relief? <br><br>  Suppose there are three types of relief in the game from the top view: water, grass, and forest.  We are already processing the boundaries of water and grass, now we need to learn how to handle the boundaries of water and forest, as well as grass and forest. <br><br>  Previously, we had two variants of tiles for each adjacent position (grass or water), so we used the <strong>binary</strong> system of calculation.  Now there are already three options, so we need to use a <strong>ternary</strong> system.  It is necessary to change the system of assessment of neighbors to fit the new system of calculus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e65/bcf/372/e65bcf3720fbc4800b0c29a06067295b.png" width="184" height="184"><br><br>  In the binary system, the pattern ‚Äú2 to the power n‚Äù was used, in the new one we will use the pattern ‚Äú3 to the power n‚Äù. <br><br>  In the ternary system, each position has three possible states: grass, water, forest, or 0, 1, 2. When there is grass at the current point, we ignore the value (multiply it by 0).  When water is at a point, we add the set value (multiply it by 1).  In the case of a forest, we add a double value (multiply it by 2). <br><br>  That is, in the case of the forest tile, to the top and to the right of which there is water, the forest below, and the grass to the left: 81 * 3 + 1 * 2 + 3 * 1 + 9 * 3 + 27 * 0 = 275 <br><br>  As you can see, at this stage, to cover all combinations of a map with three types of relief, you need to draw 324 tile images.  When working manually, it would take a lot of time.  I highly recommend to study at least partially automated ways to create such a multitude of combinations. <br><br>  Of course, in the same way the system can be expanded to more types of terrain, but the number of tile images will increase significantly.  Therefore, I recommend imposing restrictions on which tiles can coexist with each other.  For example, if forest and water tiles can never border each other, then in the above example you will need several hundred less tile images. </div><p>Source: <a href="https://habr.com/ru/post/335662/">https://habr.com/ru/post/335662/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335652/index.html">Intel Optane SSD: features and benefits</a></li>
<li><a href="../335654/index.html">Datacenter: the stages of big life</a></li>
<li><a href="../335656/index.html">SpaceX will deliver the HPE supercomputer to the ISS. How does this speed up a mission to mars?</a></li>
<li><a href="../335658/index.html">Coco Framework - blockchain on a large scale</a></li>
<li><a href="../335660/index.html">Detailed guide to creating and deploying chat on Tornado + Telegram</a></li>
<li><a href="../335664/index.html">"300 million books per kilometer": IBM extends the life of magnetic tape</a></li>
<li><a href="../335666/index.html">10 steps to solve problems in programming</a></li>
<li><a href="../335668/index.html">Visualization of latent semantic analysis results using Python tools</a></li>
<li><a href="../335670/index.html">The future of contact centers: omni-channel and customer experience</a></li>
<li><a href="../335672/index.html">The book "Theory and practice of programming languages. Textbook for universities. 2nd ed. Standard 3rd generation "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>