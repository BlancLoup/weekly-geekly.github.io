<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automatic reorganization of arrays in the memory of the graphics accelerator</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What are we talking about 
 In this post I would like to describe a part of the runtime system (RTS - RunTime System hereinafter) of the DVMH compiler...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automatic reorganization of arrays in the memory of the graphics accelerator</h1><div class="post__text post__text-html js-mediator-article"><h1>  What are we talking about </h1><br>  In this post I would like to describe a part of the runtime system (RTS - RunTime System hereinafter) of the <a href="http://dvm-system.org/ru/">DVMH</a> compiler.  The considered part, as can be seen from the title, relates to the processing of user arrays on the GPU, namely, their automatic transformation or reorganization in the memory of the accelerator.  These transformations are done for efficient access to the GPU memory in computational cycles.  What is DVMH, how to adjust to the calculations and why it is done automatically - described below. <br><a name="habracut"></a><br><br><h1>  What is DVMH </h1><br>  Since this post is devoted to the review of algorithms for the transformation of arrays, I will describe only briefly what DVMH is, as it will be needed to describe the principles of operation.  We need to start with a DVM (Distribute Virtual Memory) system - with a system that is designed to develop programs for clusters containing accelerators in nodes (GPU Nvidia and Intel Xeon Phi) and multi-core processors.  With this system, you can easily parallelize large sequential programs that work primarily with structural grids or structural data types, and also easily display a program on a cluster, in the nodes of which there can be devices of different architectures.  DVM-system includes: <br><ul><li>  Compilers from C programming languages ‚Äã‚Äã(and in the future C ++, with some limitations, of course) and Fortran C-DVMH and Fortran-DVMH.  We will call generically DVMH languages ‚Äã‚Äãand compilers.  DVMH is an extension of the considered programming languages ‚Äã‚Äãby pragmas or special comments that are not visible to standard compilers (by analogy, for example, with OpenMP, OpenACC).  Thus, it is enough for a programmer to place a small number of directives indicating how the data is distributed and how calculations are displayed on the distributed data in the computational cycles.  After that, the user receives both a sequential program and a parallel program.  The resulting program can be run on a cluster on a different number of nodes, on one or several GPUs within one node, and also, for example, use multi-core processors, graphics accelerators and Intel Xeon Phi accelerators at once (if all this is present on the server in question).  More details can be found <a href="http://dvm-system.org/ru/">here;</a> </li><li>  Lib-DVMH support library or RTSH run-time system (H means heterogeneous, this letter in the name of many components appeared after the system was expanded to support GPU and Xeon Phi).  With the help of this system, the entire user program setup is performed while the program is running; </li><li>  Debugging tools and debugging tools for the effectiveness of DVMH programs (currently only for Fortran-DVMH programs). </li></ul><br>  The main goal of creating such a system is to simplify the user‚Äôs life by paralleling existing programs and simplify the writing of new parallel programs.  DVMH compilers translate the resulting program with DVMH directives into a program using MPI, OpenMP and CUDA and RTSH calls.  Thus, a user program can be easily parallelized with the help of calculation distribution directives (almost similar to OpenMP or OpenACC) and data distribution directives.  Moreover, this program continues to be consistent, which is important for its further development and support.  It is still easier to write a ‚Äúgood‚Äù sequential program and place directives in the DVMH compiler in such a program, than doing manual parallelization. <br><br><h1>  Concurrency levels </h1><br>  After a brief introduction and introduction to the course of the matter, let us consider how the source program (namely, computational cycles) is mapped to different levels of parallelism inside the RTSH.  Currently, in order to achieve a large computing power, a large number of threads are used within a single device, instead of increasing the frequency of operation of each of the threads.  This in turn leads to the need to study not only the standard (MPI of course) interaction of processes between nodes, but also the emergence of heterogeneous architectures, and with them various parallel languages, both high-level and low-level.  And all this makes life difficult for the end user.  And in order to achieve high application performance, it is necessary to use all the capabilities of a specific computing cluster. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At the moment, you can imagine two levels of parallelism - between nodes and within a node.  Inside the node can be used one or more GPU, as well as multi-core processors.  Intel Xeon Phi in this scheme is considered as a separate node containing a multi-core processor.  Below is a generalized diagram of a computing cluster on which DVMH programs can be mapped: <br><img src="https://habrastorage.org/files/6bf/03b/f04/6bf03bf046ff41eda90baff89b3ca4ec.png" alt="image"><br>  Naturally, the question arises of balancing the loading of devices (the mechanism of which is in DVMH), but this is already beyond the scope of this post.  All further considerations will affect a single GPU within a single node.  The following transformations are performed on all GPUs on which the DVMH program runs, independently. <br><br><h1>  What is data reorganization necessary for? </h1><br>  Finally, after a protracted entry, we come to the question of the reorganization itself.  What is all this for?  But for what.  Consider some kind of computational cycle: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ARRAY[Z][Y][X][<span class="hljs-number"><span class="hljs-number">5</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> I = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; Z; ++I) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> J = <span class="hljs-number"><span class="hljs-number">1</span></span>; J &lt; Y; ++J) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> K = <span class="hljs-number"><span class="hljs-number">1</span></span>; K &lt; X; ++K) ARRAY[K][J][I][<span class="hljs-number"><span class="hljs-number">4</span></span>] = Func(ARRAY[K][J][I][<span class="hljs-number"><span class="hljs-number">2</span></span>], ARRAY[K][J][I][<span class="hljs-number"><span class="hljs-number">5</span></span>]);</code> </pre> <br>  We have a four-dimensional array, where the first (fastest) measurement, for example, contains 5 physical quantities, and the rest are coordinates in the space of the computational domain.  In the program, the array was declared so that the first (close-in-memory) dimension consists of these 5 elements so that the processor cache works well in computational cycles.  In this example, you need access to 2, 4 and 5 fast measurement elements at each iteration of three cycles.  It is also worth noting that there is no cycle for this measurement.  And by virtue of, for example, the different nature of these quantities, the calculations for each of the 5 elements will also differ. <br><br>  Thus, it is possible to execute parallel cycles for I, J, K. For this example, each element of the ARRAY array will be somehow mapped onto a parallel loop, for example, like this: <br><pre> <code class="java hljs">#pragma dvm array distribute[block][block][block][*] <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> ARRAY[Z][Y][X][<span class="hljs-number"><span class="hljs-number">5</span></span>]; #<span class="hljs-function"><span class="hljs-function">pragma dvm </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([I][J][K] on ARRAY[I][J][K][*])</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> I = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; Z; ++I)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> J = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; J &lt; Y; ++J)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> K = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; K &lt; X; ++K)</span></span></span><span class="hljs-function"> ARRAY[K][J][I][4] </span></span>= Func(ARRAY[K][J][I][<span class="hljs-number"><span class="hljs-number">2</span></span>], ARRAY[K][J][I][<span class="hljs-number"><span class="hljs-number">5</span></span>]);</code> </pre><br>  That is, a data distribution appears, in relation to which the calculations are distributed.  The above DVMH directives suggest that the array should be distributed in three dimensions in equal blocks, and the fourth (fastest) should be propagated.  This record allows you to display an array on the processor grid specified when the DVMH program was started.  The following directive says that it is necessary to perform a round (I, J, K) in accordance with the rule of distribution of the array ARRAY.  Thus, the PARALLEL directive sets the display of the loop turns on the array elements.  At run time, the RTSH knows how the arrays are located and how to organize the calculations. <br><br>  This cycle, namely the entire space of the turns, can be displayed both on the OpenMP thread and on the CUDA thread, because all three cycles have no dependencies.  We are interested in mapping on CUDA architecture.  Everyone knows that the CUDA block contains three dimensions - x, y, z.  The very first is the fastest.  Fast measurement is displayed on the warp'y CUDA-block.  Why should all this be mentioned?  Because the global GPU memory (GDDR5) is a bottleneck in any computing.  And the memory is arranged in such a way that the fastest access is carried out by one warp only if all the loaded elements lie in a row.  For the above cycle, there are 6 options for mapping the space of turns (I, J, K) to the CUDA block (x, y, z), but none of them allows you to effectively access the ARRAY array. <br><br>  What does it come from?  If you look at the description of the array, you can see that the first dimension contains 5 elements and there is no cycle for it.  Thus, the elements of the second fast measurement lie at a distance of 40 bytes (5 elements of the double type), which leads to an increase in the number of transactions to the GPU memory (instead of 1 transaction, one warp can do up to 32 transactions).  All this leads to an overload of the memory bus and a decrease in performance. <br><br>  To solve the problem, in this case, it is enough to swap the first and second measurements, that is, to transpose the two-dimensional matrix of X * 5 Y * Z times or perform Y * Z independent transpositions.  But what does swapping array measurements mean?  The following problems may occur: <br><ul><li>  It is necessary to add additional cycles to the code that perform this conversion; </li><li>  If you rearrange the measurements in the program code, you will have to correct the entire program, since the calculations in all cycles will become incorrect if you rearrange the measurements of the array at one point of the program.  And if the program is large, then you can make a lot of mistakes; </li><li>  It is not clear what effect of the permutation will be obtained and how the permutation will affect another cycle.  It is quite possible that you need a new permutation or the return of the array to its initial state </li><li>  Create two versions of the program, since this cycle will cease to run efficiently on the CPU. </li></ul><br><br><h1>  Implement various permutations in the RTSH </h1><br>  To solve the problems described in RTSH, an automatic array transformation mechanism was invented, which allows the user‚Äôs DVMH program to be significantly accelerated (several times) in case of unsuccessful access to the GPU memory (compared to its execution without using this feature).  Before considering the types of transformation and their implementation on CUDA, I will list some of the undeniable advantages of our approach: <br><ul><li>  The user has one DVMH program, he focuses on writing an algorithm; </li><li>  This mode can be enabled during compilation of a DVMH program by specifying just one DVMH option to the -autoTfm compiler.  Thus, the user can try both modes without any changes to the program and evaluate the acceleration; </li><li>  This transformation is performed in the "on demand" mode.  This means that in the case of a change in the order of measurements of the array before the computational cycle, the inverse permutation will not be performed after the calculations, since it is quite possible that this arrangement of the array will be beneficial for the next cycle; </li><li>  Significant acceleration of the program (up to 6 times) compared with the same program, performed without the use of this option. </li></ul><br><h5>  1. Swap the array measurements that are physically adjacent. </h5><br>  The example described above fits this type of conversion.  In this case, it is necessary to transpose the two-dimensional plane, which can be located on any adjacent two dimensions of the array.  If it is necessary to transpose the first two dimensions, then a well-described matrix transposition algorithm using shared memory is suitable: <br><pre> <code class="java hljs">__shared__ T temp[BLOCK_DIM][BLOCK_DIM + <span class="hljs-number"><span class="hljs-number">1</span></span>]; CudaSizeType x1Index = (blockIdx.x + pX) * blockDim.x + threadIdx.x; CudaSizeType y1Index = (blockIdx.y + pY) * blockDim.y + threadIdx.y; CudaSizeType x2Index = (blockIdx.y + pY) * blockDim.y + threadIdx.x; CudaSizeType y2Index = (blockIdx.x + pX) * blockDim.x + threadIdx.y; CudaSizeType zIndex = blockIdx.z + pZ; CudaSizeType zAdd = zIndex * dimX * dimY; CudaSizeType idx1 = x1Index + y1Index * dimX + zAdd; CudaSizeType idx2 = x2Index + y2Index * dimY + zAdd; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x1Index &lt; dimX) &amp;&amp; (y1Index &lt; dimY)) { temp[threadIdx.y][threadIdx.x] = inputMatrix[idx1]; } __syncthreads(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x2Index &lt; dimY) &amp;&amp; (y2Index &lt; dimX)) { outputMatrix[idx2] = temp[threadIdx.x][threadIdx.y]; }</code> </pre><br>  In the case of a square matrix, you can perform the transposition of the so-called "in place", for which you do not need to allocate additional memory on the GPU. <br><br><h5>  2. Swap the array measurements that are not physically adjacent. </h5><br>  This type includes permutations of any two dimensions of the array.  It is necessary to distinguish two types of such permutations: the first is to change any measurement with the first and change any measurements between them, and neither is the first (fastest) one.  This separation should be clear, since the elements of the fastest measurement lie in a row and access to them should also be possible in a row.  To do this, you can use shared memory: <br><pre> <code class="java hljs">__shared__ T temp[BLOCK_DIM][BLOCK_DIM + <span class="hljs-number"><span class="hljs-number">1</span></span>]; CudaSizeType x1Index = (blockIdx.x + pX) * blockDim.x + threadIdx.x; CudaSizeType y1Index = (blockIdx.y + pY) * blockDim.y + threadIdx.y; CudaSizeType x2Index = (blockIdx.y + pY) * blockDim.y + threadIdx.x; CudaSizeType y2Index = (blockIdx.x + pX) * blockDim.x + threadIdx.y; CudaSizeType zIndex = blockIdx.z + pZ; CudaSizeType zAdd = zIndex * dimX * dimB * dimY; CudaSizeType idx1 = x1Index + y1Index * dimX * dimB + zAdd; CudaSizeType idx2 = x2Index + y2Index * dimY * dimB + zAdd; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (CudaSizeType k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; dimB; k++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) __syncthreads(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x1Index &lt; dimX) &amp;&amp; (y1Index &lt; dimY)) { temp[threadIdx.y][threadIdx.x] = inputMatrix[idx1 + k * dimX]; } __syncthreads(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x2Index &lt; dimY) &amp;&amp; (y2Index &lt; dimX)) { outputMatrix[idx2 + k * dimY] = temp[threadIdx.x][threadIdx.y]; } }</code> </pre><br>  If you need to perform a permutation of any other measurements among themselves, then the shared memory is not needed, since access to the fast measurement of the array will be performed ‚Äúcorrectly‚Äù (the neighboring threads will work with the neighboring cells in the GPU memory). <br><br><h5>  3. Perform diagonalization of the array. </h5><br>  This type of permutation is non-standard and is necessary for parallel execution of loops with regular data dependency.  This permutation provides ‚Äúcorrect‚Äù access when processing a loop in which there are dependencies.  Consider an example of such a cycle: <br><pre> <code class="java hljs">#<span class="hljs-function"><span class="hljs-function">pragma dvm </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parallel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([ii][j][i] on A[i][j][ii])</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">across</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ii = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; ii &lt; K - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; ii++)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(j = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; j &lt; M - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; j++)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i &lt; N - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; i++)</span></span></span><span class="hljs-function"> A[i][j][ii] </span></span>= A[i + <span class="hljs-number"><span class="hljs-number">1</span></span>][j][ii] + A[i][j + <span class="hljs-number"><span class="hljs-number">1</span></span>][ii] + A[i][j][ii + <span class="hljs-number"><span class="hljs-number">1</span></span>] + A[i - <span class="hljs-number"><span class="hljs-number">1</span></span>][j][ii] + A[i][j - <span class="hljs-number"><span class="hljs-number">1</span></span>][ii] + A[i][j][ii - <span class="hljs-number"><span class="hljs-number">1</span></span>];</code> </pre><br>  In this case, there is a dependency on all three dimensions of the cycle or three dimensions of array A. To tell the DVMH compiler that there is a regular dependency in this cycle (dependent elements can be expressed by the formula a * x + b, where a and b are constants), there is an ACROSS specification.  In this cycle there are direct and inverse dependencies.  The space of turns of this cycle form a parallelepiped (and in the particular case - a three-dimensional cube).  The planes of this parallelepiped, rotated at 45 degrees relative to each face, can be carried out in parallel, while the planes themselves can be performed sequentially.  Because of this, access to the diagonal elements of the first two fastest measurements of the array A appears. And in order to increase the performance of the GPU, it is necessary to perform a diagonal transformation of the array.  In the simple case, the transformation of one plane looks like this: <br><img src="https://habrastorage.org/files/6e1/7ff/648/6e17ff648b714a939d024b604c088183.jpg" alt="image"><br>  You can perform this transformation as fast as matrix transposition.  To do this, you must use shared memory.  Only unlike matrix transposition, the processed block will not be square, but in the form of a parallelogram, so that when reading and writing efficiently use the memory bandwidth of the GPU (only the first band is shown for diagonalization, since all the others are broken down in a similar way): <br><img src="https://habrastorage.org/files/ad6/32c/8ae/ad632c8ae5c74ec2aaf67956a286fb35.jpg" alt="image"><br>  The following diagonalization types have been implemented (Rx and Ry are the sizes of the diagonalizable rectangle): <br><ul><li>  Parallel to the secondary diagonal and Rx == Ry; </li><li>  Parallel to the secondary diagonal and Rx &lt;Ry; </li><li>  Parallel to the secondary diagonal and Rx&gt; Ry; </li><li>  Parallel to the main diagonal and Rx == Ry; </li><li>  Parallel to the main diagonal and Rx &lt;Ry; </li><li>  Parallel to the main diagonal and Rx&gt; Ry. </li></ul><br>  The common core for diagonalization is as follows: <br><pre> <code class="java hljs">__shared__ T data[BLOCK_DIM][BLOCK_DIM + <span class="hljs-number"><span class="hljs-number">1</span></span>]; __shared__ IndexType sharedIdx[BLOCK_DIM][BLOCK_DIM + <span class="hljs-number"><span class="hljs-number">1</span></span>]; __shared__ bool conditions[BLOCK_DIM][BLOCK_DIM + <span class="hljs-number"><span class="hljs-number">1</span></span>]; bool condition; IndexType shift; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> revX, revY; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (slash == <span class="hljs-number"><span class="hljs-number">0</span></span>) { shift = -threadIdx.y; revX = BLOCK_DIM - <span class="hljs-number"><span class="hljs-number">1</span></span> - threadIdx.x; revY = BLOCK_DIM - <span class="hljs-number"><span class="hljs-number">1</span></span> - threadIdx.y; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { shift = threadIdx.y - BLOCK_DIM; revX = threadIdx.x; revY = threadIdx.y; } IndexType x = (IndexType)blockIdx.x * blockDim.x + threadIdx.x + shift; IndexType y = (IndexType)blockIdx.y * blockDim.y + threadIdx.y; IndexType z = (IndexType)blockIdx.z * blockDim.z + threadIdx.z; dvmh_convert_XY&lt;IndexType, slash, cmp_X_Y&gt;(x, y, Rx, Ry, sharedIdx[threadIdx.y][threadIdx.x]); condition = (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= x &amp;&amp; <span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= y &amp;&amp; x &lt; Rx &amp;&amp; y &lt; Ry); conditions[threadIdx.y][threadIdx.x] = condition; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (back == <span class="hljs-number"><span class="hljs-number">1</span></span>) __syncthreads(); #<span class="hljs-function"><span class="hljs-function">pragma unroll </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> zz = z; zz &lt; z + manyZ; ++zz)</span></span></span><span class="hljs-function"> </span></span>{ IndexType normIdx = x + Rx * (y + Ry * zz); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (back == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition &amp;&amp; zz &lt; Rz) data[threadIdx.y][threadIdx.x] = src[normIdx]; __syncthreads(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditions[revX][revY] &amp;&amp; zz &lt; Rz) dst[sharedIdx[revX][revY] + zz * Rx * Ry] = data[revX][revY]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditions[revX][revY] &amp;&amp; zz &lt; Rz) data[revX][revY] = src[sharedIdx[revX][revY] + zz * Rx * Ry]; __syncthreads(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condition &amp;&amp; zz &lt; Rz) dst[normIdx] = data[threadIdx.y][threadIdx.x]; } }</code> </pre><br>  In this case, it is necessary to transfer the condition value and the calculated coordinate in the diagonal representation with the help of dvmh_convert_XY to other threads, because unlike transposition, it is not possible here to unambiguously calculate both coordinates (where to read and where to write). <br><br>  Total.  What permutations are implemented: <br><ol><li>  Rearrange two adjacent array dimensions; </li><li>  Rearrange two non-adjacent array dimensions; </li><li>  Digalization of two adjacent fastest array measurements; </li><li>  [Planned] Digonization of any two fastest array measurements (diagonalizable measurement becomes the fastest); </li><li>  Copying the clipping from the diagonalized array (for example, to update the ‚Äúshadow‚Äù edges in the case of an account on several GPUs); </li></ol><br><h1>  Performance evaluation </h1><br>  To demonstrate the effectiveness of the approach, I will cite some graphs showing the performance of the permutations themselves and give the results of two programs - LU decomposition for the gas hydrodynamics problem and a synthetic test that implements the method of sequential upper relaxation for solving the 3-dimensional Dirichlet problem.  All tests were run on GPU GTX Titan and Nvidia CUDA ToolKit 7.0 and Intel Xeon E5 1660 v2 processor with Intel compiler version 15. <br><br>  We will compare all the implemented transformations with the usual copy core, since the reorganization of arrays is a copying of one memory section to another according to a certain rule.  The copy kernel looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">__global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyGPU</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *src, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dist, unsigned elems)</span></span></span><span class="hljs-function"> </span></span>{ unsigned idx = blockIdx.x * blockDim.x + threadIdx.x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(idx &lt; elems) dist[idx] = src[idx]; }</code> </pre><br>  I will give the conversion speed only for algorithms that use shared memory, as in this case there is an additional overhead of synchronization inside the CUDA block, as well as access to shared memory (L1 cache), because of which the performance of such copying will be lower than with any other permutations.  We take the copyGPU copying speed as 100%, since in this case the overhead is minimal and this core allows getting almost peak memory bandwidth of the GPU. <br><br>  The first graph shows how much slower the transformation (transposition) and the diagonalization of the two-dimensional matrix were performed.  The size of the matrix varies from a few megabytes to one gigabyte.  From the graph it can be seen that on two-dimensional matrices the performance drop is 20-25% relative to the copyGPU core.  You can also see that the diagonalization is performed by 5% longer, since the diagonalization algorithm is somewhat more complicated than matrix transposition: <br><img src="https://habrastorage.org/files/b06/3f2/757/b063f27579ff4672a820fe71c90265cc.jpg" alt="image"><br><br>  The second graph shows how much slower the transformation (transposition) and the diagonalization of the three-dimensional matrix were performed.  The dimensions of the matrices were taken in two types: four-dimensional N * N * N * 5 and arbitrary X * Y * Z.  Matrix sizes range from 10 megabytes to 500 megabytes.  On small matrices, the conversion speed drops by 40%, while on large matrices, the transformation speed reaches 90%, and the diagonalization speed, 80% of the copy speed: <br><img src="https://habrastorage.org/files/5db/759/46c/5db75946c7984602808b6300bc39f34e.jpg" alt="image"><br><br>  The third graph shows the execution time of a synthetic test that implements the symmetrical upper relaxation method.  The computational cycle of this method contains dependencies in all three dimensions (this cycle is described in C language above).  The graph shows the execution times of the same DVMH program (written in Fortran, the source code is attached at the end of the article), using 6 threads of Xeon E5 and on the GPU using diagonalization and without.  In this case, the diagonalization must be done only once before the iterative calculations. <br><img src="https://habrastorage.org/files/b78/e9d/14e/b78e9d14e0ae45b7a831fef842096862.jpg" alt="image"><br><br>  The fourth graph shows the acceleration of an application that solves a synthetic system of nonlinear partial differential equations (3-D Navier-Stokes equations for compressible fluid or gas) using the symmetric sequential upper relaxation method (SSOR algorithm, LU problem).  This test is part of the standard <a href="http://www.nas.nasa.gov/publications/npb.html">NASA</a> test suite (latest available version 3.3.1).  In this set, the source codes of all tests of successive versions are available, as well as MPI and OpenMP. <br><br>  The graph shows the acceleration of the program with respect to the serial version, performed on one Xeon E5 core, performed on 6 threads of Xeon E5, and on the GPU in two modes.  In this program, it is necessary to do diagonalization only for two cycles, and then return the array to its original state, that is, at each iteration for ‚Äúbad‚Äù cycles, all the required arrays are diagonalized, and after execution it occurs from the diagonalization.  It is also worth noting that in this program about 2500 thousand lines of Fortran 90 style (without hyphenation, the code at the end of the article is attached).  125 DVMH-directives are added to it, which allow you to execute this program both on a cluster, on a single node on different devices, and in sequential mode. <br><img src="https://habrastorage.org/files/47f/b93/077/47fb9307723f455e857a4ef3b6214fce.jpg" alt="image"><br>  This program is well optimized at the level of sequential code (this is evident from the 8-fold acceleration on 6 Xeon E5 cores), which is well reflected not only on the GPU architecture, but also on multi-core processors.  The DVMH compiler allows using the -Minfo option to see the number of registers required by the CUDA cores corresponding to each displayed cycle (this information is taken from the Nvidia compiler).  In this case, you need about 160 registers per thread (out of 255 available) for each of the three main computational cycles, and the number of operations to access global memory is approximately 10: 1.  Thus, the acceleration from the use of reorganization is not so great, but it is still there and on a large task it is 1.5 times as compared with the same program executed without this option.  Also, this test is performed 3 times faster on the GPU than on the 6 CPU cores. <br><br><h1>  Conclusion </h1><br>  In this post, an approach was considered to automatically reorganize data on the GPU in the support system for DVMH programs.  In this case, we are talking about the full automation of this process.  RTSH has all the information during program execution that is necessary to determine the type of reorganization.  This approach allows you to get a good acceleration on those programs where you can not write a "good" sequential program, while displaying the cycles of which access to the global memory of the GPU was carried out in the best way.  When performing transformations, up to 90% of the performance of global GPU memory (which is approximately 240 GB / s for GTX Titan) is achieved relative to the fastest memory copy core inside the device. <br><br><h3>  Links </h3><br>  1) <a href="http://dvm-system.org/ru/">DVM-system</a> <br>  2) <a href="https://drive.google.com/file/d/0BwkVJGSs_ksSY0xkSjFRWW82MTA/view%3Fusp%3Dsharing">Source code LU and SOR on Fotran-DVMH</a> <br>  3) <a href="http://www.nas.nasa.gov/publications/npb.html">NASA tests</a> </div><p>Source: <a href="https://habr.com/ru/post/261535/">https://habr.com/ru/post/261535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261525/index.html">How to control response time or how fast your website loads?</a></li>
<li><a href="../261527/index.html">Mobile app design: why we work in @ 1x</a></li>
<li><a href="../261529/index.html">How to replace a homogeneous background with a transparent imagemagick</a></li>
<li><a href="../261531/index.html">Push notifications via Telegram</a></li>
<li><a href="../261533/index.html">Implementing the infrastructure of the Internet of things for a smart office - the experience of Microsoft Technology Center</a></li>
<li><a href="../261537/index.html">Manage dependencies in iOS applications correctly: Typhoon modularity</a></li>
<li><a href="../261539/index.html">Alt key for mouse gestures, as well as various important fixes in Vivaldi 1.0.212.3</a></li>
<li><a href="../261541/index.html">Expanding the functionality of the "notebook"</a></li>
<li><a href="../261543/index.html">We continue to expand the functionality of the browser Vivaldi</a></li>
<li><a href="../261547/index.html">Announcement Joker 2015 University Day: Celebration on student street</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>