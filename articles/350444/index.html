<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implement java promises</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to all. Today I want to talk about how I wrote the implementation of the mechanism of promises for my JS engine. As you know, not so long ago...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implement java promises</h1><div class="post__text post__text-html js-mediator-article">  Good day to all.  Today I want to talk about how I wrote the implementation of the mechanism of promises for my JS engine.  As you know, not so long ago came the new standard ECMA Script 6, and the concept of promises looks quite interesting, and also where a lot of web developers already apply.  Therefore, for any modern JS engine, this is definitely a must-have thing. <br>  Warning: the article is quite a lot of code.  The code does not claim beauty and high quality, since the whole project was written by one person and is still in beta.  The purpose of this story is to show how everything works under the hood.  In addition, after a small adaptation, this code can be used to create pure Java projects, without looking at JavaScript. <br><br>  The first thing it cost to start writing code is to learn how things <b>should</b> work in the end.  The architecture of the resulting module was largely determined by the process. <br><a name="habracut"></a><br><h3>  What is a Promise? </h3><br>  Promise is a special object that, when created, is in the <i>pending</i> state (let it be a constant equal to 0). <br><br>  Next, the object starts to execute the function that was passed to its constructor during creation.  If the function was not passed - following the ES6 standard, we must throw an exception <i>argument is not a function</i> .  However, in our Java implementation, you can not throw anything, and create an object "as is" (just add additional logic later, I will tell about it later). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, the constructor accepts the function.  In our engine, this is an object of class Function that implements the call method.  This method allows you to call a function, taking as input the execution context, a vector with arguments, and a boolean parameter that defines the call mode (call as a constructor or normal mode). <br><br>  Further, this function is recorded in the field of our object and then can be called. <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PENDING = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FULFILLED = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> REJECTED = <span class="hljs-number"><span class="hljs-number">2</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> state = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Function func;</code> </pre> <br>  At the same time, here we will create constants for our two remaining states, and an int field that stores the current state of the object. <br><br>  So, according to the standard, in the course of its execution, our function can call one of two functions (which are passed to it as the first two arguments, so we should set their names in the signature of the function).  Usually use something like resolve and reject for simplicity. <br><br>  These are normal functions from the point of view of JavaScript, and therefore Function objects from the point of view of our engine.  Add fields for them: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Function onFulfilled = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Function onRejected = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><br>  These functions can be called at any time by our main working function, which means they should be in its scope.  In addition, after working, they must change the state of our object to <i>fulfilled</i> and <i>rejected</i> , respectively.  Our functions do not know anything about promises (and should not know).  Therefore, we need to create a kind of wrapper that will know about them and will be able to initiate a state transition. <br><br>  We also need the setState () method for our object (with additional checks: for example, we have no right to change the state if it is already <i>fulfilled</i> or <i>rejected</i> ). <br><br>  Let's do the constructor of our object: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function f)</span></span></span><span class="hljs-function"> </span></span>{ func = f; onFulfilled = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Promise.FULFILLED); onRejected = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Promise.REJECTED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Vector&lt;JSValue&gt; args = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;JSValue&gt;(); args.add(onFulfilled); args.add(onRejected); func.call(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, args, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre><br>  Here, it seems, everything is clear.  If the function is transferred, we must call it immediately.  If not, then for the time being we are not doing anything (and our object maintains the <i>pending</i> state). <br><br>  Now about the installation of these handlers themselves (after all, in the main function we only declare their names as formal parameters).  There are three options for this standard: Promise.then (resolve, reject), Promise.then (resolve) (equivalent to Promise.then (resolve, null)), and Promise.catch (reject) (equivalent to Promise.then (null, reject )). <br><br>  As for the then function: it is obvious that it is best to implement in detail the method with two arguments, and the remaining two to do as ‚Äúshortcuts‚Äù to it.  So do: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function f1, Function f2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == Promise.FULFILLED || state == Promise.REJECTED) { onFulfilled = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f1, Promise.FULFILLED); onRejected = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f2, Promise.REJECTED); onFulfilled.call(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;JSValue&gt;(), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... onFulfilled = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f1, Promise.FULFILLED); onRejected = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f2, Promise.REJECTED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (func != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { String name1 = func.getParamsCount() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? func.getParamName(<span class="hljs-number"><span class="hljs-number">0</span></span>) : <span class="hljs-string"><span class="hljs-string">"resolve"</span></span>; String name2 = func.getParamsCount() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? func.getParamName(<span class="hljs-number"><span class="hljs-number">1</span></span>) : <span class="hljs-string"><span class="hljs-string">"reject"</span></span>; func.injectVar(name1, onFulfilled); func.injectVar(name2, onRejected); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f1 != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) has_handler = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f2 != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) has_error_handler = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  At the end, we return the link to ourselves: this is necessary for the subsequent implementation of the chasing of promises. <br><br>  What kind of block do we have at the beginning of the method, you ask?  But the fact is that our handler could have been executed even before we called then for the first time (this happens, and this is completely normal).  In this case, we must call the necessary handler from the passed to the method immediately. <br><br>  In the place of the dot then there will be another code, about it a bit later. <br><br>  Next is the installation of our handlers in the required fields. <br><br>  And then the most interesting.  Suppose our work function runs for a long time (a request over the network, or just setTimeout for a learning example).  In this case, it will essentially be executed, but will create a series of objects (timer, network XmlHttpRequest interface, etc.) that will execute some code later.  And these objects have access to the scope of our function! <br><br>  Therefore, it may not be too late to add the necessary variables to its scope (and if it is too late, the code will be executed at the beginning of the method).  To do this, we create a new method in the Function class: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name, JSValue value)</span></span></span><span class="hljs-function"> </span></span>{ body.scope.put(name, value); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String name)</span></span></span><span class="hljs-function"> </span></span>{ body.scope.remove(name); }</code> </pre><br>  We don‚Äôt actually need the second method: it was created purely for the sake of completeness. <br><br>  Now it's time to implement shortcuts: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> then(f, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_catch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function f)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> then(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, f); }</code> </pre><br>  catch is a reserved word in java, so we had to add an underscore. <br><br>  Now we will describe the setState method.  In the first approximation, it will look like this: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = value; }</code> </pre><br>  Great, now we can change the state of our handlers - more precisely, of the wrappers over them.  We are going to wrap: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromiseHandleWrapper</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PromiseHandleWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Promise p, Function func, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.promise = p; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.func = func; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.to_state = type; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSObject context, Vector&lt;JSValue&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> as_constr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call(context, args); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSObject context, Vector&lt;JSValue&gt; args)</span></span></span><span class="hljs-function"> </span></span>{ JSValue result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (func != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Block b = getCaller(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { b = func.getParentBlock(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (b.parent_block != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { b = b.parent_block; } } func.setCaller(b); result = func.call(context, args, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = Undefined.getInstance(); } promise.setResult(result); promise.setState(to_state); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.getResult(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSError </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func.getError(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Promise promise; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Function func; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  We have two types of wrappers, but one class.  And the type is responsible for the integer field to_state.  Seems not bad :) <br><br>  The wrapper has links to both its function and its own promise.  It is very important. <br><br>  With the constructor, everything is clear, let's look at the call method, which overrides the method of the Function class.  For our JS interpreter - wrappers are the same functions, that is, objects with the same interface that can be called, get their values, and so on. <br><br>  First, we need to forward the Caller object to the function, which we received when we called the wrapper - this is necessary at least for the correct ascent of exceptions. <br><br>  Next, we call our function and save the result of its execution in the field.  At the same time, we set it to the object of the promise, for which we will create another setResult method there: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setResult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSValue value)</span></span></span><span class="hljs-function"> </span></span>{ result = value; }</code> </pre><br>  We will not talk about the last line yet: it is necessary for chasing.  In the most trivial case, the same value that we just received and transferred will be returned there. <br><br>  The important point: the working function may call resolve or reject before we call the then or catch method (or we may not call them at all).  So that at the same time we do not have an exception, right when creating a promise, we create two "default" wrappers that do not have handler functions.  When called, they will only change the state of our promise (and then when called then it will be taken into account). <br><br><h3>  Cheyming promises </h3><br>  In short, cheining is the ability to write things like p.then (f1, f2) .then (f3, f4) .catch (f5). <br>  That is why our then and _catch methods return a Promise object. <br><br>  The first thing that the standard tells us is that the then method, in the presence of an existing handler, must create a new promise and add it to the chain.  Since our promises should be equal to each other - let us not have any main promise storing a linear list, and each promise will store only a link to the following (initially it is null): <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function f1, Function f2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == Promise.FULFILLED || state == Promise.REJECTED) { onFulfilled = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f1, Promise.FULFILLED); onRejected = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f2, Promise.REJECTED); onFulfilled.call(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;JSValue&gt;(), <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (has_handler || has_error_handler) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> next.then(f1, f2); } Promise p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); p.then(f1, f2); next = p; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; } onFulfilled = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f1, Promise.FULFILLED); onRejected = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseHandleWrapper(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, f2, Promise.REJECTED); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (func != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { String name1 = func.getParamsCount() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? func.getParamName(<span class="hljs-number"><span class="hljs-number">0</span></span>) : <span class="hljs-string"><span class="hljs-string">"resolve"</span></span>; String name2 = func.getParamsCount() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> ? func.getParamName(<span class="hljs-number"><span class="hljs-number">1</span></span>) : <span class="hljs-string"><span class="hljs-string">"reject"</span></span>; func.injectVar(name1, onFulfilled); func.injectVar(name2, onRejected); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f1 != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) has_handler = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f1 != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) has_error_handler = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Promise next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><br>  This is our missing block: if we already have the next promise, we hand over the call to him and exit (and he, if necessary, will hand it over to the next one, and so on).  And if it is not there, we create and assign handlers to it, which we have received into the method, after which we return it.  It's simple. <br><br>  Now we will finalize the setState method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = value; Vector&lt;JSValue&gt; args = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;JSValue&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) args.add(result); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == Promise.FULFILLED &amp;&amp; next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onFulfilled.getError() == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; result <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Promise) { ((Promise)result).then(next.onFulfilled, next.onRejected); next = (Promise)result; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = next.onFulfilled.call(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, args, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { args = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector&lt;JSValue&gt;(); args.add(onFulfilled.getError().getValue()); result = next.onRejected.call(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, args, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == Promise.REJECTED &amp;&amp; !has_error_handler &amp;&amp; next != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { result = next.onRejected.call(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, args, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } }</code> </pre><br>  Firstly, the standard says that we are obliged to transfer the result of the previous work to the next promise handler (this is the basic meaning of the scheduling - assign an operation, then assign the second, and make the second accept the result at the start). <br><br>  Secondly - errors are processed in a special way.  If the successful result is passed along the chain (changing) to the end, then the error that occurred in the handler code is transmitted only one step, until the next onrejected, or it pops up if the end of the chain is reached. <br><br>  Thirdly, functions can return a new promise.  In this case, we are obliged to replace our next, if it is already set, on it (by transferring the available handlers).  This, again, allows you to combine a chain of instant execution and asynchronous handlers, which return Promise themselves. <br><br>  The above code addresses all of these scripts. <br><br><h3>  First tests </h3><br><pre> <code class="java hljs"> JSParser jp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSParser(<span class="hljs-string"><span class="hljs-string">"function cbk(str) { \"Promise fulfilled: \" + str } function f(resolve, reject) { setTimeout(function() { resolve(\"OK\") }, 1500) }"</span></span>); System.out.println(); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk(str) { \"Promise fulfilled: \" + str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function f(resolve, reject) { setTimeout(function() { resolve(\"OK\") }, 1500) }"</span></span>); System.out.println(); Expression exp = Expression.create(jp.getHead()); exp.eval(); jsparser.Function f = (jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"f"</span></span>, exp); f.setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); jsparser.Promise p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> jsparser.Promise(f); p.then((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"cbk"</span></span>, exp));</code> </pre><br>  So far, we are managing everything from Java code.  Nevertheless, everything is already working: in a second and a half we will see the inscription ‚ÄúPromise fulfilled: OK‚Äù on the console.  By the way, our resolve and reject functions, being called from the working function of promise, without changing, can take an arbitrary number of arguments.  Very convenient.  In this example, we passed the string "OK". <br><br>  A small note: the promises created during the process of the process of chasing do not have working functions in principle.  They immediately call handlers when the state of the previous promise changes. <br><br>  The example is more complicated: <br><br><pre> <code class="java hljs"> JSParser jp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSParser(<span class="hljs-string"><span class="hljs-string">"function cbk1(str) { \"Promise 1 fulfilled: \" + str; return str } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function cbk2(str) { setTimeout(str =&gt; { \"Promise 2 fulfilled: \" + str }, 1000); throw \"ERROR\" } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function cbk3(str) { \"Promise 3 fulfilled: \" + str; return str } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function err(str) { \"An error has occured: \" + str } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function f(resolve, reject) { setTimeout(function() { resolve(\"OK\") }, 300) }"</span></span>); System.out.println(); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk1(str) { \"Promise 1 fulfilled: \" + str; return str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk2(str) { setTimeout(str =&gt; { \"Promise 2 fulfilled: \" + str }, 1000); throw \"ERROR\" }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk3(str) { \"Promise 3 fulfilled: \" + str; return str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function err(str) { \"An error has occured: \" + str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function f(resolve, reject) { setTimeout(function() { resolve(\"OK\") }, 300) }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"(new Promise(f)).then(cbk1).then(cbk2).then(cbk3, err)"</span></span>); System.out.println(); Expression exp = Expression.create(jp.getHead()); ((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"f"</span></span>, exp)).setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); ((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"cbk2"</span></span>, exp)).setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); exp.eval(); jsparser.Function f = (jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"f"</span></span>, exp); f.setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); jsparser.Promise p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> jsparser.Promise(f); p.then((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"cbk1"</span></span>, exp)) .then((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"cbk2"</span></span>, exp)) .then((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"cbk3"</span></span>, exp), (jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"err"</span></span>, exp));</code> </pre><br>  By calling this example, we get the following output: <br><br> <code>{} <br> "Promise 1 fulfilled: OK" <br> "OK" <br> "An error has occured: ERROR" <br> undefined <br> "Promise 2 fulfilled: OK" <br></code> <br>  The first curly braces are the object of promise that our call chain then returned to us as a result of the cheining.  In the cbk1 function, we returned ‚ÄúOK‚Äù - and this value was transferred to cbk2, which we see in the last line.  Inside cbk2, we throw an error with the value ‚ÄúERROR‚Äù - therefore cbk3 is not executed here, but err is executed (as it should be when an error occurs in the previous promise handler in the chain).  But this code is executed instantly, but the output of cbk2 is carried out through an auxiliary function hung on the timer.  It has access to the str variable, as it should, but its output is because of this below.  If you execute this example in Chrome 49, we get exactly the same output with one exception: the str variable is not visible in the anonymous function passed to setTimeout.  This is a feature of the behavior of the switch functions in Chrome (and perhaps so necessary by the standard, here I find it difficult to say what is the matter).  If you change the switch function to the usual one, the output will become identical. <br><br><h3>  Forwarding in javascript </h3><br>  But that is not all.  Our ultimate goal is for new features to be able to use JS code executed by our interpreter.  However, this is a matter of technology. <br><br>  Create a constructor: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromiseC</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PromiseC</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ items.put(<span class="hljs-string"><span class="hljs-string">"prototype"</span></span>, PromiseProto.getInstance()); PromiseProto.getInstance().set(<span class="hljs-string"><span class="hljs-string">"constructor"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSObject context, Vector&lt;JSValue&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> as_constr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> call(context, args); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSObject context, Vector&lt;JSValue&gt; args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"Function"</span></span>)) { JSError e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSError(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Type error: argument is not a function"</span></span>, getCaller().getStack()); getCaller().error = e; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise((Function)args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } }</code> </pre><br>  And a prototype object with a set of necessary methods: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PromiseProto</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JSObject</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thenFunction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSObject context, Vector&lt;JSValue&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> as_constr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.size() == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"Function"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Promise)context).then((Function)args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"Function"</span></span>) &amp;&amp; args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"Function"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Promise)context).then((Function)args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>), (Function)args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.size() &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"null"</span></span>) &amp;&amp; args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"Function"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Promise)context)._catch((Function)args.get(<span class="hljs-number"><span class="hljs-number">1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">catchFunction</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> JSValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSObject context, Vector&lt;JSValue&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">boolean</span></span></span></span><span class="hljs-function"><span class="hljs-params"> as_constr)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.size() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>).getType().equals(<span class="hljs-string"><span class="hljs-string">"Function"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((Promise)context)._catch((Function)args.get(<span class="hljs-number"><span class="hljs-number">0</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> context; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PromiseProto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ items.put(<span class="hljs-string"><span class="hljs-string">"then"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> thenFunction()); items.put(<span class="hljs-string"><span class="hljs-string">"catch"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> catchFunction()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> PromiseProto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (instance == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PromiseProto(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(JSString str, JSValue value)</span></span></span><span class="hljs-function"> </span></span>{ set(str.getValue(), value); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, JSValue value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str.equals(<span class="hljs-string"><span class="hljs-string">"constructor"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.set(str, value); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; Set keys = items.keySet(); Iterator it = keys.iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (it.hasNext()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result += <span class="hljs-string"><span class="hljs-string">", "</span></span>; String str = (String)it.next(); result += str + <span class="hljs-string"><span class="hljs-string">": "</span></span> + items.get(str).toString(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"{"</span></span> + result + <span class="hljs-string"><span class="hljs-string">"}"</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String type = <span class="hljs-string"><span class="hljs-string">"Object"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PromiseProto instance = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; }</code> </pre><br>  Do not forget to add one line to Promise constructor at the very beginning, so that everything works: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Promise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function f)</span></span></span><span class="hljs-function"> </span></span>{ items.put(<span class="hljs-string"><span class="hljs-string">"__proto__"</span></span>, PromiseProto.getInstance()); ... }</code> </pre><br>  And change our test a bit: <br><br><pre> <code class="java hljs"> JSParser jp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JSParser(<span class="hljs-string"><span class="hljs-string">"function cbk1(str) { \"Promise 1 fulfilled: \" + str; return str } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function cbk2(str) { setTimeout(str =&gt; { \"Promise 2 fulfilled: \" + str }, 1000); throw \"ERROR\" } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function cbk3(str) { \"Promise 3 fulfilled: \" + str; return str } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function err(str) { \"An error has occured: \" + str } "</span></span> + <span class="hljs-string"><span class="hljs-string">"function f(resolve, reject) { setTimeout(function() { resolve(\"OK\") }, 300) }; "</span></span> + <span class="hljs-string"><span class="hljs-string">"(new Promise(f)).then(cbk1).then(cbk2).then(cbk3, err)"</span></span>); System.out.println(); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk1(str) { \"Promise 1 fulfilled: \" + str; return str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk2(str) { setTimeout(str =&gt; { \"Promise 2 fulfilled: \" + str }, 1000); throw \"ERROR\" }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function cbk3(str) { \"Promise 3 fulfilled: \" + str; return str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function err(str) { \"An error has occured: \" + str }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"function f(resolve, reject) { setTimeout(function() { resolve(\"OK\") }, 300) }"</span></span>); System.out.println(<span class="hljs-string"><span class="hljs-string">"(new Promise(f)).then(cbk1).then(cbk2).then(cbk3, err)"</span></span>); System.out.println(); Expression exp = Expression.create(jp.getHead()); ((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"f"</span></span>, exp)).setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); ((jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"cbk2"</span></span>, exp)).setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); exp.eval(); jsparser.Function f = (jsparser.Function)Expression.getVar(<span class="hljs-string"><span class="hljs-string">"f"</span></span>, exp); f.setSilent(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre><br>  The output should not change. <br><br>  That's all!  Everything works fine, you can write additional unit tests and look for possible errors. <br><br>  How to adapt this mechanism for Java?  Very simple.  Create a class similar to our Function, which does something in the operate method.  And we already wrap it in our wrapper.  In any case, there are many wonderful patterns on this subject that can be played with. <br><br>  I hope this article was useful to someone.  I will definitely lay out the sources of the engine as soon as I bring them to mind and add the missing functionality.  Have a good day! </div><p>Source: <a href="https://habr.com/ru/post/350444/">https://habr.com/ru/post/350444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350434/index.html">Reasoning on the game design of VR games</a></li>
<li><a href="../350436/index.html">FastTrack Training. "Network Basics". "Basics of a wireless LAN". Part two. Eddie Martin December 2012</a></li>
<li><a href="../350438/index.html">Validation of strings with validate.it.js</a></li>
<li><a href="../350440/index.html">Gini coefficient. From economics to machine learning</a></li>
<li><a href="../350442/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ304 (February 26 - March 4, 2018)</a></li>
<li><a href="../350446/index.html">Container Run Environments (container runtimes) Part 1: Introduction to Container Run Environments</a></li>
<li><a href="../350448/index.html">RegExp Unicode Property Escapes in JavaScript: Portrait Strokes</a></li>
<li><a href="../350452/index.html">Load testing "non-HTTP". Part 2 Gatling</a></li>
<li><a href="../350454/index.html">Surprisingly simple messaging with Spring Cloud Stream</a></li>
<li><a href="../350456/index.html">Digital events in Moscow from March 5 to 11</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>