<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Win the Android Camera2 API with RxJava2 (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of the article , in which I show how using RxJava2 helps build logic over an asynchronous API. As such an interface, I chose t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Win the Android Camera2 API with RxJava2 (part 2)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/342/d66/230/342d6623018f4d7b8d0392137429a5ba.jpg" alt="image"><br><br>  This is the second part of the <a href="https://habrahabr.ru/company/badoo/blog/330080/">article</a> , in which I show how using RxJava2 helps build logic over an asynchronous API.  As such an interface, I chose the Android Camera2 API (and did not regret it!).  This API is not only asynchronous, but also fraught with unobvious implementation features that are not described anywhere.  So the article will be of double benefit to the reader. <br><br>  Who is this post for?  I hope that the reader is an experienced, but still an inquisitive Android developer.  Basic knowledge of reactive programming (a <a href="https://habrahabr.ru/company/badoo/blog/328434/">good introduction is here</a> ) and understanding of Marble Diagrams are highly desirable.  The post will be useful to those who want to penetrate the reactive approach, as well as those who plan to use the Camera2 API in their projects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Project sources can be <a href="https://github.com/ArkadyGamza/Camera2API_rxJava2">found on GitHub</a> . <br><br>  Reading the <a href="https://habrahabr.ru/company/badoo/blog/330080/">first part is</a> required! <br><a name="habracut"></a><br><h2>  Formulation of the problem </h2><br>  At the end of the first part, I promised that I would reveal the question of waiting for autofocus / auto exposure. <br><br>  Let me remind you, the chain of operators looked like this: <br><br><pre><code class="java hljs">Observable.combineLatest(previewObservable, mOnShutterClick, (captureSessionData, o) -&gt; captureSessionData) .firstElement().toObservable() .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::waitForAf) .flatMap(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::waitForAe) .flatMap(captureSessionData -&gt; captureStillPicture(captureSessionData.session)) .subscribe(__ -&gt; {}, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::onError)</code> </pre> <br>  So, what do we want from the <code>waitForAe</code> and <code>waitForAf</code> ?  In order for the autofocus / auto exposure processes to start, and upon their completion we would receive a notification of readiness for the image. <br><br>  For this, both methods need to return <code>Observable</code> , which emits an event when the camera reports that the convergence process has triggered (in order not to repeat the words ‚Äúautofocus‚Äù and ‚Äúauto exposure‚Äù, then I will use the word ‚Äúconvergence‚Äù).  But how to start and control this process? <br><br><h2>  Those unobvious features of the Camera2 API pipeline </h2><br>  At first I thought that it was enough to call the <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.html"><code>capture</code></a> with the necessary flags and wait for the <code>CaptureCallback</code> call <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.CaptureCallback.html"><code>onCaptureCompleted</code></a> . <br><br>  It seems logical: they launched a request, waited for execution - it means that the request is executed.  And this code even went into production. <br><br>  But then we noticed that on some devices in very dark conditions, even when the flash is triggered, the photos are out of focus and darkened.  At the same time, the system camera worked perfectly, although it took much more time to prepare for the snapshot.  I began to suspect that in my case, autofocus did not have time to focus by the time of <code>onCaptureCompleted</code> . <br><br>  To check my thesis, I added a delay per second - and the pictures began to turn out!  It is clear that I could not be satisfied with this decision, and I began to look for how you can really understand that autofocus worked and you can continue.  Documentation on this topic could not be found, and I had to turn to the system camera sorts, since they are available as part of the <a href="https://source.android.com/">Android Open Source Project</a> .  The code turned out to be extremely unreadable and confusing, I had to add logging and analyze the camera logs when shooting in the dark.  And I found that after capture with the necessary flags, the system camera calls <a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.html"><code>setRepeatingRequest</code></a> to continue the preview and waits until the onCaptureCompleted comes with a certain set of flags in <code>TotalCaptureResult</code> .  The right answer could come in a few <code>onCaptureCompleted</code> ! <br><br>  When I realized this feature, the behavior of the Camera2 API seemed logical.  But how much effort it took to find this information!  Well, now you can go to the description of the solution. <br><br>  So, our action plan: <br><br><ul><li>  call capture with flags that start the convergence process; </li><li>  call <code>setRepeatingRequest</code> to continue the preview; </li><li>  receive notifications from both methods; </li><li>  waiting in the <code>onCaptureCompleted</code> notification <code>onCaptureCompleted</code> evidence that the convergence process has been completed. </li></ul><br>  Go! <br><br><h2>  Checkboxes </h2><br>  Create a <code>ConvergeWaiter</code> class with the following fields: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CaptureRequest.Key&lt;Integer&gt; mRequestTriggerKey; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mRequestTriggerStartValue;</code> </pre> <br>  This is the key and value of the flag that will trigger the necessary convergence process when you call <code>capture</code> . <br><br>  For autofocus, these will be <code>CaptureRequest.CONTROL_AF_TRIGGER</code> and <code>CameraMetadata.CONTROL_AF_TRIGGER_START</code> respectively.  For auto exposure - <code>CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER</code> and <code>CameraMetadata.CONTROL_AE_PRECAPTURE_TRIGGER_START</code> respectively. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CaptureResult.Key&lt;Integer&gt; mResultStateKey; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; mResultReadyStates;</code> </pre><br>  This is the key and the set of expected flag values ‚Äã‚Äãfrom the <code>onCaptureCompleted</code> result.  When we see one of the expected key values, we can assume that the convergence process is complete. <br><br>  For autofocus, the key value is <code>CaptureResult.CONTROL_AF_STATE</code> , a list of values: <br><br><pre> <code class="java hljs">CaptureResult.CONTROL_AF_STATE_INACTIVE, CaptureResult.CONTROL_AF_STATE_PASSIVE_FOCUSED, CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED, CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED;</code> </pre><br>  for auto exposure, the key value is <code>CaptureResult.CONTROL_AE_STATE</code> , a list of values: <br><br><pre> <code class="java hljs">CaptureResult.CONTROL_AE_STATE_INACTIVE, CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED, CaptureResult.CONTROL_AE_STATE_CONVERGED, CaptureResult.CONTROL_AE_STATE_LOCKED.</code> </pre><br>  Do not ask me how I found out!  Now we can create <code>ConvergeWaiter</code> instances for autofocus and exposure, for this we will make a factory: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Factory</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; afReadyStates = Collections.unmodifiableList(       Arrays.asList(           CaptureResult.CONTROL_AF_STATE_INACTIVE,           CaptureResult.CONTROL_AF_STATE_PASSIVE_FOCUSED,           CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED,           CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED       )   );   <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Integer&gt; aeReadyStates = Collections.unmodifiableList(       Arrays.asList(           CaptureResult.CONTROL_AE_STATE_INACTIVE,           CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED,           CaptureResult.CONTROL_AE_STATE_CONVERGED,           CaptureResult.CONTROL_AE_STATE_LOCKED       )   );   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ConvergeWaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAutoFocusConvergeWaiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConvergeWaiter(           CaptureRequest.CONTROL_AF_TRIGGER,           CameraMetadata.CONTROL_AF_TRIGGER_START,           CaptureResult.CONTROL_AF_STATE,           afReadyStates       );   }   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ConvergeWaiter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAutoExposureConvergeWaiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConvergeWaiter(           CaptureRequest.CONTROL_AE_PRECAPTURE_TRIGGER,           CameraMetadata.CONTROL_AE_PRECAPTURE_TRIGGER_START,           CaptureResult.CONTROL_AE_STATE,           aeReadyStates       );   } }</code> </pre><br><h2>  <code>capture</code> / <code>setRepeatingRequest</code> </h2><br>  To call <code>capture</code> / <code>setRepeatingRequest</code> we need: <br><br><ul><li>  previously opened <code>CameraCaptureSession</code> , which is available in <code>CaptureSessionData</code> ; <br></li><li>  <code>CaptureRequest</code> we will create using <code>CaptureRequest.Builder.</code> <br></li></ul><br>  Create a method <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Single&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForConverge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureSessionData captureResultParams, @NonNull CaptureRequest.Builder builder)</span></span></span></span></code> </pre> <br>  In the second parameter, we will pass the <code>builder</code> configured for the preview.  Therefore, <code>CaptureRequest</code> for previews can be created immediately by calling <code>CaptureRequest previewRequest = builder.build();</code> <br><br>  To create a <code>CaptureRequest</code> to run the convergence procedure, add a flag to the <code>builder</code> that will start the necessary convergence process: <br><br><pre> <code class="java hljs">builder.set(mRequestTriggerKey, mRequestTriggerStartValue); CaptureRequest triggerRequest = builder.build();</code> </pre><br>  And we will use our methods to get <code>Observable</code> from the methods of <code>capture</code> / <code>setRepeatingRequest</code> : <br><br><pre> <code class="java hljs">Observable&lt;CaptureSessionData&gt; triggerObservable = CameraRxWrapper.fromCapture(captureResultParams.session, triggerRequest); Observable&lt;CaptureSessionData&gt; previewObservable = CameraRxWrapper.fromSetRepeatingRequest(captureResultParams.session, previewRequest);</code> </pre> <br><h2>  Chaining operators </h2><br>  Now we can form a jet stream in which there will be events from both Observable using the <code>merge</code> operator. <br><br><img src="https://habrastorage.org/webt/yc/jw/te/ycjwteqdugrmbgj1z2b-s1p7wyu.png"><br><br><pre> <code class="java hljs">Observable&lt;CaptureSessionData&gt; convergeObservable = Observable   .merge(previewObservable, triggerObservable)</code> </pre><br>  The resulting <code>convergeObservable</code> will emit events with the results of the <code>onCaptureCompleted</code> calls. <br><br>  We need to wait until the <code>CaptureResult</code> passed to this method contains the expected value of the flag.  To do this, create a function that takes <code>CaptureResult</code> and returns <code>true</code> if it has the expected flag value: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isStateReady</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureResult result)</span></span></span><span class="hljs-function"> </span></span>{   Integer aeState = result.get(mResultStateKey);   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aeState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || mResultReadyStates.contains(aeState); }</code> </pre><br>  Checking for <code>null</code> needed for the crooked implementations of the Camera2 API, so as not to hang forever. <br><br>  Now we can use the <code>filter</code> operator to wait for the event for which <code>isStateReady</code> is executed: <br><img src="https://habrastorage.org/webt/jh/lg/ok/jhlgokcox8zfk56rskhldfw8j_a.png"><br><br><pre> <code class="java hljs">    .filter(resultParams -&gt; isStateReady(resultParams.result))</code> </pre><br>  We are interested only in the first such event, therefore we add <br><br><pre> <code class="java hljs">    .first(captureResultParams);</code> </pre><br>  Fully reactive stream looks like this: <br><br><pre> <code class="java hljs">Single&lt;CaptureSessionData&gt; convergeSingle = Observable .merge(previewObservable, triggerObservable) .filter(resultParams -&gt; isStateReady(resultParams.result)) .first(captureResultParams);</code> </pre><br>  In case the convergence process takes too long or something goes wrong, we introduce a timeout: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> TIMEOUT_SECONDS = <span class="hljs-number"><span class="hljs-number">3</span></span>; Single&lt;CaptureSessionData&gt; timeOutSingle = Single   .just(captureResultParams)   .delay(TIMEOUT_SECONDS, TimeUnit.SECONDS, AndroidSchedulers.mainThread());</code> </pre><br>  The <code>delay</code> operator reissues events with a specified delay.  By default, it does this in a stream belonging to the computation scheduler, so we drop it into Main Thread using the last parameter. <br><br>  Now let's combine <code>convergeSingle</code> and <code>timeOutSingle</code> , and whoever is the first to emit an event, he won: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Single   .merge(convergeSingle, timeOutSingle)   .firstElement()   .toSingle();</code> </pre><br>  Full function code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-function">Single&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForConverge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureSessionData captureResultParams, @NonNull CaptureRequest.Builder builder)</span></span></span><span class="hljs-function"> </span></span>{ CaptureRequest previewRequest = builder.build(); builder.set(mRequestTriggerKey, mRequestTriggerStartValue); CaptureRequest triggerRequest = builder.build(); Observable&lt;CaptureSessionData&gt; triggerObservable = CameraRxWrapper.fromCapture(captureResultParams.session, triggerRequest); Observable&lt;CaptureSessionData&gt; previewObservable = CameraRxWrapper.fromSetRepeatingRequest(captureResultParams.session, previewRequest); Single&lt;CaptureSessionData&gt; convergeSingle = Observable .merge(previewObservable, triggerObservable) .filter(resultParams -&gt; isStateReady(resultParams.result)) .first(captureResultParams); Single&lt;CaptureSessionData&gt; timeOutSingle = Single .just(captureResultParams) .delay(TIMEOUT_SECONDS, TimeUnit.SECONDS, AndroidSchedulers.mainThread()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Single .merge(convergeSingle, timeOutSingle) .firstElement() .toSingle(); }</code> </pre><br><h2>  <code>waitForAf</code> / <code>waitForAe</code> </h2><br>  The main part of the work is done, it remains only to create instances: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConvergeWaiter mAutoFocusConvergeWaiter = ConvergeWaiter.Factory.createAutoFocusConvergeWaiter(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ConvergeWaiter mAutoExposureConvergeWaiter = ConvergeWaiter.Factory.createAutoExposureConvergeWaiter();</code> </pre><br>  and use them: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Observable&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForAf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureSessionData captureResultParams)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable       .fromCallable(() -&gt; createPreviewBuilder(captureResultParams.session, mSurface))       .flatMap(           previewBuilder -&gt; mAutoFocusConvergeWaiter               .waitForConverge(captureResultParams, previewBuilder)               .toObservable()       ); } <span class="hljs-meta"><span class="hljs-meta">@NonNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Observable&lt;CaptureSessionData&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForAe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull CaptureSessionData captureResultParams)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable       .fromCallable(() -&gt; createPreviewBuilder(captureResultParams.session, mSurface))       .flatMap(           previewBuilder -&gt; mAutoExposureConvergeWaiter               .waitForConverge(captureResultParams, previewBuilder)               .toObservable()       ); }</code> </pre><br>  The main point here is the use of the <code>fromCallable</code> operator.  It may be tempting to use the operator <code>just</code> .  For example: <br><br><pre> <code class="java hljs">just(createPreviewBuilder(captureResultParams.session, mSurface)).</code> </pre> <br>  But in this case, the <code>createPreviewBuilder</code> function will be called right at the time of the <code>waitForAf</code> call, and we want it to be called only when a subscription to our <code>Observable</code> appears. <br><br><h2>  Conclusion </h2><br>  As you know, the most valuable part of any article on Habr√© is comments!  Therefore, I urge you to actively share your thoughts, comments, valuable knowledge and links to more successful implementations in the comments. <br><br>  Project sources can be <a href="https://github.com/ArkadyGamza/Camera2API_rxJava2">found on GitHub</a> .  Pulrequests welcome! </div><p>Source: <a href="https://habr.com/ru/post/352318/">https://habr.com/ru/post/352318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352308/index.html">Lecture by Andrei Bezrukov on the digital economy, global challenges and what it is like to be a spy</a></li>
<li><a href="../352310/index.html">Development of elevator movement algorithm</a></li>
<li><a href="../352312/index.html">You don't need autotest developers.</a></li>
<li><a href="../352314/index.html">Went out for bread - bought a house: augmented reality as the future of banking</a></li>
<li><a href="../352316/index.html">We invite you to the All-Russian Student Olympiad in the direction of "Information Security" in the MEPI</a></li>
<li><a href="../352320/index.html">Event digest for HR-specialists in the field of IT for April 2018</a></li>
<li><a href="../352322/index.html">Detect integer constant expressions in the macro [along with Linus]</a></li>
<li><a href="../352324/index.html">The Internet of Things as a catalyst for digital transformation</a></li>
<li><a href="../352326/index.html">JPoint 2018 plans</a></li>
<li><a href="../352328/index.html">The main criteria for SEO and AEO in the future - understanding and credibility</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>