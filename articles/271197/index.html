<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nim Tutorial (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note from the translator  This translation was made based on a comment from the user stas3k , in which he suggested that frol translate two parts of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nim Tutorial (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">Note from the translator</b> <div class="spoiler_text">  This translation was made based on a <a href="http://habrahabr.ru/post/258119/">comment</a> from the user <a href="https://habrahabr.ru/users/stas3k/" class="user_link">stas3k</a> , in which he suggested that <a href="https://habrahabr.ru/users/frol/" class="user_link">frol</a> translate two parts of the ‚ÄúNim Tutorial‚Äù.  I was interested in it and I translated them on my own, to the best of my understanding.  If anyone finds mistakes (they probably are there - in the end, the eye has already completely blinked), report in a personal, I will rule. <br></div></div><br><h2>  Introduction </h2><br><blockquote>  ‚ÄúDer Mensch ist doch ein Augentier - sch√∂ne Dinge w√ºnsch ich mir.‚Äù </blockquote>  <em>(Quote from the Rammstein group's Morgenstern song. An approximate translation: ‚ÄúBut man is a big-eyed beast - I need a lot of beautiful things.‚Äù)</em> <br><br>  This is a tutorial on the <em>Nim</em> programming language <em>.</em>  It is assumed that you are familiar with basic programming concepts, such as variables, types or commands, but deep knowledge is not necessary.  A large number of examples of the complex nuances of the language, you can find in the official manual.  All code examples in this document follow <em>the Nim style guide.</em> <br><a name="habracut"></a><br><h2>  First program </h2><br>  Let's start with the modified program ¬´hello world¬ª: <br><br><pre><code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#   echo("What's your name? ") var name: string = readLine(stdin) echo("Hi, ", name, "!")</span></span></code> </pre> <br>  Save this code to the <code>greetings.nim</code> file.  Now compile and run it: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">nim compile --run greetings.nim</code> </pre><br>  The <code>--run</code> causes Nim to automatically run the file after compilation.  You can pass arguments to your program via the command line by adding them after the file name: <br><br><pre> <code class="bash hljs">nim compile --run greetings.nim arg1 arg2</code> </pre><br>  Frequently used commands and keys have abbreviations, so you can write like this: <br><br><pre> <code class="bash hljs">nim c -r greetings.nim</code> </pre><br>  To compile the release version, use the following command: <br><br><pre> <code class="bash hljs">nim c -d:release greetings.nim</code> </pre><br>  By default, the Nim compiler generates many runtime checks to simplify debugging.  The <code>-d:release</code> switch disables these checks and enables optimization. <br><br>  What the program does should be fairly obvious, but I will explain the syntax: commands written without indentation are executed when the program starts.  With indentation, Nim groups commands.  Indents are made only by spaces, tabs are not allowed. <br><br>  String literals are enclosed in double quotes.  The <code>var</code> command declares a new variable with the name <code>name</code> and type <code>string</code> , after which it is assigned the value returned by the <code>readLine</code> procedure.  Because the compiler knows that <code>readLine</code> returns a string, you can omit the type in the declaration (this is called local type inference).  So this option will also work: <br><br><pre> <code class="bash hljs">var name = readLine(stdin)</code> </pre><br>  Note that this is almost the only form of type inference that is present in Nim: it is a good compromise between brevity and readability. <br><br>  The ‚Äúhello world‚Äù program contains some identifiers that are already known to the compiler: <code>echo</code> , <code>readLine</code> , etc.  These built-in commands are declared in the <code>system</code> module, which is implicitly imported by any other module. <br><br><h2>  Lexical elements </h2><br>  Consider the lexical elements of Nim in more detail.  Like other programming languages, Nim consists of literals, identifiers, keywords, comments, operators, and punctuation. <br><br><h3>  String and character literals </h3><br>  String literals are enclosed in double quotes;  character - in single.  Special characters are escaped with a backslash <code>\</code> : <code>\n</code> means a line break, <code>\t</code> means a tab, and so on.  There are also raw string literals: <br><br><pre> <code class="ruby hljs">r<span class="hljs-string"><span class="hljs-string">"C:\program files\nim"</span></span></code> </pre><br>  In raw literals, backslash is not an escape character. <br><br>  The third and last way to write string literals is <em>long string literals.</em>  They are framed by triple quotes: <code>""" ... """</code> , may contain a newline and <code>\</code> are not a escape character in them.  They are very useful, for example, to include HTML fragments in the code. <br><br><h3>  Comments </h3><br>  A comment can be anywhere outside of a string or character literal and starts with a <code>#</code> .  Documenting comments begin with <code>##</code> : <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># . var myVariable: int ##  </span></span></code> </pre><br>  The documenting comments are tokens, are included in the syntax tree and, therefore, can only be in certain places in the input file!  This allows for easier documentation generators. <br><br>  You can also use the <code>discard</code> command with <em>long string literals</em> to create block comments: <br><br><pre> <code class="ruby hljs">discard <span class="hljs-string"><span class="hljs-string">""</span></span><span class="hljs-string"><span class="hljs-string">"        Nim  -   . yes("</span></span>May I ask a pointless question?<span class="hljs-string"><span class="hljs-string">") "</span></span><span class="hljs-string"><span class="hljs-string">""</span></span></code> </pre><br><h3>  Numbers </h3><br>  Numeric literals are written in the same way as in most other languages.  To improve readability, it is allowed to beat the digits with underscores: <code>1_000_000</code> (one million).  Numbers containing a period (or <code>e</code> , or <code>E</code> ) are considered floating point literals: <code>1.0e9</code> (one billion).  Hexadecimal literals begin with the prefix <code>0x</code> , binary ones from <code>0b</code> , and octal ones from <code>0o</code> .  Leading zero <strong>does not</strong> make the number octal. <br><br><h2>  <code>var</code> command </h2><br>  The <code>var</code> command declares a new local or global variable: <br><br><pre> <code class="ruby hljs">var x, <span class="hljs-symbol"><span class="hljs-symbol">y:</span></span> int <span class="hljs-comment"><span class="hljs-comment">#  x  y,   `int`</span></span></code> </pre><br>  Using the indents after the <code>var</code> keyword, you can list the whole variable section: <br><br><pre> <code class="ruby hljs">var x, <span class="hljs-symbol"><span class="hljs-symbol">y:</span></span> int <span class="hljs-comment"><span class="hljs-comment">#     a, b, c: string</span></span></code> </pre><br><h2>  Assignment command </h2><br>  The assignment command assigns a new value to a variable or, more generally, a storage location: <br><br><pre> <code class="ruby hljs">var x = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> <span class="hljs-comment"><span class="hljs-comment">#    `x`     x = "xyz" #    `x`</span></span></code> </pre><br>  <code>=</code> is <em>an assignment operator.</em>  It cannot be overloaded, rewritten or banned, but this may change in future versions of Nim.  You can declare several variables with one assignment statement and they all get the same value: <br><br><pre> <code class="ruby hljs">var x, y = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">#   `x`  `y`  3 echo "x ", x #  "x 3" echo "y ", y #  "y 3" x = 42 #   `x`  42,   `y` echo "x ", x #  "x 42" echo "y ", y #  "y 3"</span></span></code> </pre><br>  Note that declaring several variables with one assignment, which calls a procedure, can give an unexpected result: the compiler <em>will expand the</em> assignment and eventually call the procedure several times.  If the result of the procedure depends on the side effects, your variables can get different values!  To avoid this, use only constant values. <br><br><h2>  Constants </h2><br>  Constants are characters associated with a value.  The value of a constant cannot change.  The compiler must be able to evaluate the expression in a constant declaration at compile time: <br><br><pre> <code class="ruby hljs">const x = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> <span class="hljs-comment"><span class="hljs-comment">#  x   "abc"</span></span></code> </pre><br>  Using the indents after the <code>const</code> keyword, you can list the whole section of constants: <br><br><pre> <code class="ruby hljs">const x = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment"># ,     y = 2 z = y + 5 #  </span></span></code> </pre><br><h2>  <code>let</code> command </h2><br>  The <code>let</code> command works something like <code>var</code> , but declares <em>one-time assignment</em> variables <em>:</em> after initialization, their value cannot be changed. <br><br><pre> <code class="ruby hljs">let x = <span class="hljs-string"><span class="hljs-string">"abc"</span></span> <span class="hljs-comment"><span class="hljs-comment">#    `x`     x = "xyz" #  :  `x`</span></span></code> </pre><br>  The difference between <code>let</code> and <code>const</code> following: <code>let</code> enter a variable that cannot be reassigned, and <code>const</code> means "forcefully compile at compile time and put the result in the data section": <br><br><pre> <code class="ruby hljs">const input = readLine(stdin) <span class="hljs-comment"><span class="hljs-comment"># :   </span></span></code> </pre><br><pre> <code class="ruby hljs">let input = readLine(stdin) <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br><h2>  Flow control commands </h2><br>  The welcome program contains three commands that are executed sequentially.  But only the most primitive programs can work this way, the more complex ones need more cycles and branching. <br><br><h3>  <code>if</code> command </h3><br>  The <code>if</code> command is one of the ways to organize the execution thread branch: <br><br><pre> <code class="ruby hljs">let name = readLine(stdin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> name == <span class="hljs-string"><span class="hljs-string">""</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"Poor soul, you lost your name?"</span></span>) elif name == <span class="hljs-string"><span class="hljs-string">"name"</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"Very funny, your name is name."</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> echo(<span class="hljs-string"><span class="hljs-string">"Hi, "</span></span>, name, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)</code> </pre><br>  Elif branches can be zero or more, the <code>else</code> branch is not required.  The <code>elif</code> keyword is an abbreviation for <code>else if</code> , so as not to make unnecessary indents.  ( <code>""</code> is an empty string, it does not contain characters.) <br><br><h3>  <code>case</code> command </h3><br>  Another branching method is implemented by the <code>case</code> command.  It divides the execution thread into several branches: <br><br><pre> <code class="ruby hljs">let name = readLine(stdin) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> name of <span class="hljs-string"><span class="hljs-string">""</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"Poor soul, you lost your name?"</span></span>) of <span class="hljs-string"><span class="hljs-string">"name"</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"Very funny, your name is name."</span></span>) of <span class="hljs-string"><span class="hljs-string">"Dave"</span></span>, <span class="hljs-string"><span class="hljs-string">"Frank"</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"Cool name!"</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> echo(<span class="hljs-string"><span class="hljs-string">"Hi, "</span></span>, name, <span class="hljs-string"><span class="hljs-string">"!"</span></span>)</code> </pre><br>  As you can see, a comma-separated list of values ‚Äã‚Äãcan be used as an argument for <code>of</code> . <br><br>  The <code>case</code> command can work with integers, other enumerated types and strings.  (What enumerated types will be discussed later.) For integer numbers and enumerated types, you can use value ranges: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     : from strutils import parseInt echo("A number please: ") let n = parseInt(readLine(stdin)) case n of 0..2, 4..7: echo("The number is in the set: {0, 1, 2, 4, 5, 6, 7}") of 3, 8: echo("The number is 3 or 8")</span></span></code> </pre><br>  However, the code above will not compile.  The reason is that you need to cover <em>all the</em> values ‚Äã‚Äãthat <code>n</code> can take, and the code only processes <code>0..8</code> values.  Since it is not too practical to list all possible integers (although this is possible due to the notation of ranges), we will correct this by telling the compiler that for all other values ‚Äã‚Äãyou don‚Äôt need to do anything: <br><br><pre> <code class="ruby hljs">... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n of <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>..<span class="hljs-number"><span class="hljs-number">7</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"The number is in the set: {0, 1, 2, 4, 5, 6, 7}"</span></span>) of <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"The number is 3 or 8"</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> discard</code> </pre><br>  An empty <code>discard</code> command is a command to <em>do nothing.</em>  The compiler knows that the <code>case</code> command with the <code>else</code> section covers all possible options and, thus, the error disappears.  Please note that it is impossible to cover all string values: this is why in the case of strings, the <code>else</code> branch is required. <br><br>  In general, the <code>case</code> command is used for ranges of types or enumerations, where it helps that the compiler checks the coverage of all possible values. <br><br><h3>  <code>while</code> command </h3><br>  The <code>while</code> command is a simple loop: <br><br><pre> <code class="ruby hljs">echo(<span class="hljs-string"><span class="hljs-string">"What's your name? "</span></span>) var name = readLine(stdin) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> name == <span class="hljs-string"><span class="hljs-string">""</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"Please tell me your name: "</span></span>) name = readLine(stdin) <span class="hljs-comment"><span class="hljs-comment"># `var` ,      </span></span></code> </pre><br>  In the example, the <code>while</code> used to ask the user for his name until he presses ENTER (that is, he does not enter an empty string). <br><br><h3>  For command </h3><br>  The <code>for</code> command implements a loop through all the elements of the iterator.  Here is an example of using the built-in <code>countup</code> iterator: <br><br><pre> <code class="ruby hljs">echo(<span class="hljs-string"><span class="hljs-string">"  : "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> countup(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): echo($i) <span class="hljs-comment"><span class="hljs-comment"># --&gt;   1 2 3 4 5 6 7 8 9 10   </span></span></code> </pre><br>  The built-in operator <code>$</code> converts an integer ( <code>int</code> ) and many other types to a string.  The variable <code>i</code> implicitly declared as a <code>for</code> loop and is of type <code>int</code> , since <code>countup</code> returns this type.  <code>i</code> passes by the values ‚Äã‚Äã1, 2, .., 10. Each value is output using <code>echo</code> .  This code does the same thing: <br><br><pre> <code class="ruby hljs">echo(<span class="hljs-string"><span class="hljs-string">"  10: "</span></span>) var i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>: echo($i) inc(i) <span class="hljs-comment"><span class="hljs-comment">#  i  1 # --&gt;   1 2 3 4 5 6 7 8 9 10   </span></span></code> </pre><br>  The countdown is implemented as simply (but not so often needed): <br><br><pre> <code class="ruby hljs">echo(<span class="hljs-string"><span class="hljs-string">"  10  1: "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> countdown(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>): echo($i) <span class="hljs-comment"><span class="hljs-comment"># --&gt;   10 9 8 7 6 5 4 3 2 1   </span></span></code> </pre><br>  Since counting with increasing is often used in programs, Nim has an iterator <code>..</code> that does the same thing as <code>countup</code> : <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>: ...</code> </pre><br><h3>  Scopes and the <code>block</code> command </h3><br>  Flow control commands have a feature that has not yet been discussed: they open up a new scope.  This means that in the following example, <code>x</code> not available outside the loop: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-symbol"><span class="hljs-symbol">false:</span></span> var x = <span class="hljs-string"><span class="hljs-string">"hi"</span></span> echo(x) <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre><br>  The <code>while</code> ( <code>for</code> ) command creates an implicit block.  Identifiers are visible only inside the block in which they were declared.  The <code>block</code> command can be used to open a new block explicitly: <br><br><pre> <code class="ruby hljs">block <span class="hljs-symbol"><span class="hljs-symbol">myblock:</span></span> var x = <span class="hljs-string"><span class="hljs-string">"hi"</span></span> echo(x) <span class="hljs-comment"><span class="hljs-comment">#   </span></span></code> </pre><br>  <em>The</em> block <em>label</em> ( <code>myblock</code> in the example) is optional. <br><br><h3>  <code>break</code> command </h3><br>  You can exit the block ahead of time with the <code>break</code> command.  This command can interrupt a block of <code>while</code> , <code>for</code> or <code>block</code> commands.  It exits the nearest block if the block label is not set, from which you need to exit: <br><br><pre> <code class="ruby hljs">block <span class="hljs-symbol"><span class="hljs-symbol">myblock:</span></span> echo(<span class="hljs-string"><span class="hljs-string">"  "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-symbol"><span class="hljs-symbol">true:</span></span> echo(<span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,    echo("    ") block myblock2: echo("  ") while true: echo("") break myblock2 #   ( ) echo("    ")</span></span></code> </pre><br><h3>  <code>continue</code> command </h3><br>  As in many other programming languages, the <code>continue</code> command immediately proceeds to the next iteration: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-symbol"><span class="hljs-symbol">true:</span></span> let x = readLine(stdin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-string"><span class="hljs-string">""</span></span>: continue echo(x)</code> </pre><br><h3>  <code>when</code> command </h3><br>  Example: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">when</span></span> system.hostOS == <span class="hljs-string"><span class="hljs-string">"windows"</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"running on Windows!"</span></span>) elif system.hostOS == <span class="hljs-string"><span class="hljs-string">"linux"</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"running on Linux!"</span></span>) elif system.hostOS == <span class="hljs-string"><span class="hljs-string">"macosx"</span></span>: echo(<span class="hljs-string"><span class="hljs-string">"running on Mac OS X!"</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> echo(<span class="hljs-string"><span class="hljs-string">"unknown operating system"</span></span>)</code> </pre><br>  The <code>when</code> command is almost identical to the <code>if</code> command, but there are some differences: <br><ul><li>  each condition must be a constant expression, since it is computed by the compiler; </li><li>  commands inside a branch do not open a new scope; </li><li>  the compiler checks the syntax and generates code <em>only</em> for commands belonging to the branch according to the first condition, which returns <code>true</code> . </li></ul><br>  The <code>when</code> command is useful for writing platform-specific code, by analogy with the <code>#ifdef</code> language's <code>#ifdef</code> construct. <br><blockquote>  <strong>Note</strong> : To comment out a large piece of code, it is often more convenient to use the <code>when false:</code> construct instead of comments.  It can be made repeatedly invested. </blockquote><br><h2>  Commands and indents </h2><br>  Now that we‚Äôve covered the basic flow control commands, let's go back to the Nim indent rules. <br><br>  In Nim there is a distinction between <em>simple</em> and <em>complex commands.</em>  <em>Simple commands,</em> such as assignment, procedure call, or <code>return</code> command, cannot contain other commands.  <em>Complex commands</em> such as <code>if</code> , <code>when</code> , <code>for</code> , <code>while</code> may contain other commands.  To avoid ambiguity, complex commands are always indented, but simple ones are not: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#      : if x: x = false #     if: if x: if y: y = false else: y = true #  ,      : if x: x = false y = false</span></span></code> </pre><br>  Parts of commands that usually result in some value are called <em>expressions.</em>  To improve readability, they may contain indents in certain places: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> thisIsaLongCondition() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> thisIsAnotherLongCondition(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>): x = <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  In short, indents in expressions are allowed after statements, after opening parentheses and after commas. <br><br>  Using parentheses and semicolons ( <code>;</code> ) you can use commands where only expressions are allowed: <br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  fac(4)   : const fac4 = (var x = 1; for i in 1..4: x *= i; x)</span></span></code> </pre><br><h2>  Procedures </h2><br>  To create new commands, such as <code>echo</code> and <code>readLine</code> from the examples, we need the concept of <em>procedures.</em>  (In some languages, they are called <em>methods</em> or <em>functions.)</em> In Nim, new procedures are defined using the <code>proc</code> keyword: <br><br><pre> <code class="ruby hljs">proc yes(<span class="hljs-symbol"><span class="hljs-symbol">question:</span></span> string): bool = echo(question, <span class="hljs-string"><span class="hljs-string">" (y/n)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-symbol"><span class="hljs-symbol">true:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> readLine(stdin) of <span class="hljs-string"><span class="hljs-string">"y"</span></span>, <span class="hljs-string"><span class="hljs-string">"Y"</span></span>, <span class="hljs-string"><span class="hljs-string">"yes"</span></span>, <span class="hljs-string"><span class="hljs-string">"Yes"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> of <span class="hljs-string"><span class="hljs-string">"n"</span></span>, <span class="hljs-string"><span class="hljs-string">"N"</span></span>, <span class="hljs-string"><span class="hljs-string">"no"</span></span>, <span class="hljs-string"><span class="hljs-string">"No"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> echo(<span class="hljs-string"><span class="hljs-string">"Please be clear: yes or no"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> yes(<span class="hljs-string"><span class="hljs-string">"Should I delete all your important files?"</span></span>): echo(<span class="hljs-string"><span class="hljs-string">"I'm sorry Dave, I'm afraid I can't do that."</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> echo(<span class="hljs-string"><span class="hljs-string">"I think you know what the problem is just as well as I do."</span></span>)</code> </pre><br>  This example shows a procedure called <code>yes</code> , which asks the user a question and returns <code>true</code> if he answered ‚Äúyes‚Äù, and <code>false</code> if he answered ‚Äúno‚Äù.  The <code>return</code> command causes an immediate exit from the procedure (and, accordingly, a <code>while</code> ).  Syntax <code>(question: string): bool</code> means that the procedure expects to receive a parameter named <code>question</code> and type <code>string</code> and returns a value of type <code>bool</code> .  <code>bool</code> is a built-in type: the only values ‚Äã‚Äãit can take are <code>true</code> and <code>false</code> .  Conditions in <code>if</code> or <code>while</code> commands must be of type <code>bool</code> . <br><br>  A bit of terminology: in the example, the <code>question</code> formally called a <em>parameter,</em> and <code>"Should I..."</code> is the <em>argument that</em> is passed in this parameter. <br><br><h3>  Result variable </h3><br>  In any procedure that returns a value, the <code>result</code> variable is implicitly declared, which is the return value.  The <code>return</code> command with no arguments is just a shorthand for <code>return result</code> .  The <code>result</code> variable is always returned when exiting the procedure, even if there was no <code>return</code> command. <br><br><pre> <code class="ruby hljs">proc sumTillNegative(<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> varargs[int]): int = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result = result + i echo sumTillNegative() <span class="hljs-comment"><span class="hljs-comment">#  0 echo sumTillNegative(3, 4, 5) #  12 echo sumTillNegative(3, 4 , -1 , 6) #  7</span></span></code> </pre><br>  At the time the function starts, the <code>result</code> variable is always already declared, so trying to declare it again, for example, using <code>var result</code> , will cause its normal variable to be shaded with the same name.  The variable <code>result</code> always initialized with the default value for its type.  Therefore, the reference data types will have a value of <code>nil</code> , so if necessary they will have to be initialized manually. <br><br><h3>  Options </h3><br>  In the procedure body, the parameters are constants.  Since they cannot be changed by default, this allows the compiler to realize the transfer of parameters in the most efficient way.  If a variable variable is needed inside a procedure, it should be declared in the body of the procedure using <code>var</code> .  Parameter name shading is possible and sometimes used: <br><br><pre> <code class="ruby hljs">proc printSeq(<span class="hljs-symbol"><span class="hljs-symbol">s:</span></span> seq, <span class="hljs-symbol"><span class="hljs-symbol">nprinted:</span></span> int = -<span class="hljs-number"><span class="hljs-number">1</span></span>) = var nprinted = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nprinted == -<span class="hljs-number"><span class="hljs-number">1</span></span>: s.len <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> min(nprinted, s.len) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> .. &lt;<span class="hljs-symbol"><span class="hljs-symbol">nprinted:</span></span> echo s[i]</code> </pre><br>  If the procedure needs to modify the argument to pass to the caller, you can use the <code>var</code> parameter: <br><br><pre> <code class="ruby hljs">proc divmod(a, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> int; res, <span class="hljs-symbol"><span class="hljs-symbol">remainder:</span></span> var int) = res = a div b <span class="hljs-comment"><span class="hljs-comment">#   remainder = a mod b #    var x, y: int echo(x) divmod(8, 5, x, y) #  x  y echo(y)</span></span></code> </pre><br>  In the example, <code>res</code> and <code>remainder</code> are <em><code>var</code> parameters.</em>  Such parameters can be modified by the procedure and the changes will be visible to the caller.  Note that in the example above, instead of the <code>var</code> parameters, it would be better to return a tuple. <br><br><h3>  <code>discard</code> command </h3><br>  To call a procedure that returns a value and ignore the result of calling it, <strong>you must</strong> use the <code>discard</code> command.  In Nim, you cannot simply take and drop the returned value: <br><br><pre> <code class="ruby hljs">discard yes(<span class="hljs-string"><span class="hljs-string">"    ?"</span></span>)</code> </pre><br>  The returned value can be ignored implicitly if the callable procedure or iterator was declared with the discardable <code>discardable</code> : <br><br><pre> <code class="ruby hljs">proc p(x, <span class="hljs-symbol"><span class="hljs-symbol">y:</span></span> int): int {.discardable.} = <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y p(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  </span></span></code> </pre><br>  The <code>discard</code> command can also be used to create a block of comments, as described in the <strong>Comments</strong> section. <br><br><h3>  Named Arguments </h3><br>  It happens that the procedure has many parameters and it is difficult to remember in what order they go.  This is especially true for procedures that construct complex data types.  In such cases, the procedure arguments can be named to make it clearer which argument corresponds to which parameter: <br><br><pre> <code class="ruby hljs">proc createWindow(x, y, width, <span class="hljs-symbol"><span class="hljs-symbol">height:</span></span> int; <span class="hljs-symbol"><span class="hljs-symbol">title:</span></span> string; <span class="hljs-symbol"><span class="hljs-symbol">show:</span></span> bool): Window = ... var w = createWindow(show = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, title = <span class="hljs-string"><span class="hljs-string">"My Application"</span></span>, x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, height = <span class="hljs-number"><span class="hljs-number">600</span></span>, width = <span class="hljs-number"><span class="hljs-number">800</span></span>)</code> </pre><br>  Now that we have used named arguments to call <code>createWindow</code> , the order of the arguments no longer matters.  Named arguments can be mixed with unnamed ones, but this degrades readability: <br><br><pre> <code class="ruby hljs">var w = createWindow(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, title = <span class="hljs-string"><span class="hljs-string">"My Application"</span></span>, height = <span class="hljs-number"><span class="hljs-number">600</span></span>, width = <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)</code> </pre><br>  The compiler checks that each parameter takes exactly one argument. <br><br><h3>  Default values </h3><br>  To make <code>createWindow</code> easier to use, it must provide <em>default values,</em> that is, those values ‚Äã‚Äãthat will be used as arguments, if the caller does not specify them: <br><br><pre> <code class="ruby hljs">proc createWindow(x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, width = <span class="hljs-number"><span class="hljs-number">500</span></span>, height = <span class="hljs-number"><span class="hljs-number">700</span></span>, title = <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>, show = <span class="hljs-literal"><span class="hljs-literal">true</span></span>): Window = ... var w = createWindow(title = <span class="hljs-string"><span class="hljs-string">"My Application"</span></span>, height = <span class="hljs-number"><span class="hljs-number">600</span></span>, width = <span class="hljs-number"><span class="hljs-number">800</span></span>)</code> </pre><br>  Now, when calling <code>createWindow</code> you need to specify only those values ‚Äã‚Äãthat differ from the default values. <br><br>  Note that for parameters with default values, type inference works, so there is no need to write, for example, <code>title: string = "unknown"</code> . <br><br><h3>  Overloaded procedures </h3><br>  Nim makes it possible to overload procedures by analogy with C ++: <br><br><pre> <code class="ruby hljs">proc toString(<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> int): string = ... proc toString(<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> bool): string = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> result = <span class="hljs-string"><span class="hljs-string">"true"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">else:</span></span> result = <span class="hljs-string"><span class="hljs-string">"false"</span></span> echo(toString(<span class="hljs-number"><span class="hljs-number">13</span></span>)) <span class="hljs-comment"><span class="hljs-comment">#   toString(x: int) echo(toString(true)) #   toString(x: bool)</span></span></code> </pre><br>  (Remember that Nim's <code>toString</code> is usually implemented with the <code>$</code> operator.) The compiler will choose the most appropriate procedure for calling <code>toString</code> .  How exactly the algorithm for selecting overloaded procedures works will not be discussed here (this issue will soon be dealt with in the manual).  However, it does not lead to unpleasant surprises and is based on a rather simple unification algorithm.  Ambiguous calls result in an error message. <br><br><h3>  Operators </h3><br>  The Nim library makes heavy use of overloading - one of the reasons for this is that every operator like <code>+</code> is just an overloaded procedure.  Parser allows you to use operators in <em>infix</em> <code>(a + b)</code> or <em>prefix notation</em> <code>(+ a)</code> .  The infix operator always takes two arguments, and the prefix operator always takes one.  Postfix operators are forbidden, since they can lead to ambiguity: <code>a @ @ b</code> means <code>(a) @ (@b)</code> or <code>(a@) @ (b)</code> ?  Since there are no postfix operators in Nim, this expression will always mean <code>(a) @ (@b)</code> . <br><br>  In addition to several built-in keyword statements, such as <code>and</code> , <code>or</code> and <code>not</code> , operators always consist of the following characters: <code>+ - * \ / &lt; &gt; = @ $ ~ &amp; % ! ? ^ . |</code> <code>+ - * \ / &lt; &gt; = @ $ ~ &amp; % ! ? ^ . |</code> <br><br>  User-defined operators are allowed.  Nothing prevents you from defining your own <code>@!?+~</code> Operator, but readability may suffer. <br><br>  The operator‚Äôs priority is determined by its first character.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Details can be found in the manual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To define an operator, enclose it in apostrophes:</font></font><br><br><pre> <code class="ruby hljs">proc <span class="hljs-string"><span class="hljs-string">`$`</span></span> (<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> myDataType): string = ... <span class="hljs-comment"><span class="hljs-comment">#   $     myDataType,   $, #      </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This notation can also be used to call an operator as a procedure: </font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">`==`</span></span>( <span class="hljs-string"><span class="hljs-string">`+`</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-number"><span class="hljs-number">7</span></span>): echo(<span class="hljs-string"><span class="hljs-string">"True"</span></span>)</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advance announcements </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each variable, procedure, etc. </font><font style="vertical-align: inherit;">must be declared before it can be used. </font><font style="vertical-align: inherit;">(The reason is that it is difficult to come up with a better solution for a language that supports metaprogramming to the same extent that Nim supports it.) However, this cannot be done in mutually recursive procedures:</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  : proc even(n: int): bool proc even(n: int): bool proc odd(n: int): bool = assert(n &gt;= 0) # ,        if n == 0: false else: n == 1 or even(n-1) proc even(n: int): bool = assert(n &gt;= 0) # ,        if n == 1: false else: n == 0 or odd(n-1)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It </font></font><code>odd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depends on </font></font><code>even</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and vice versa. </font><font style="vertical-align: inherit;">Thus, the </font></font><code>even</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compiler must meet before it is fully defined. </font><font style="vertical-align: inherit;">The syntax for such a preliminary declaration is simple: just skip the </font></font><code>=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">body of the procedure. </font></font><code>assert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adds boundary conditions and will be described later in the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modules</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> section </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In future versions of the language, the requirements for preliminary announcements will be less stringent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The example also shows how the body of an operator can consist of a single expression whose value is returned implicitly.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Iterators </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's go back to the boring example with the calculation: </font></font><br><br><pre> <code class="ruby hljs">echo(<span class="hljs-string"><span class="hljs-string">"  : "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> countup(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): echo($i)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is it possible to write a procedure </font></font><code>countup</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for use in such a loop?</font></font> Let's try: <br><br><pre> <code class="ruby hljs">proc countup(a, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> int): int = var res = a <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> res &lt;= <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res inc(res)</code> </pre><br> ,   .   ,       ,  <strong></strong>  <strong></strong>    .   <em>¬´</em>  <em>¬ª</em>   <code>yield</code> .       <code>proc</code>  <code>iterator</code>    ‚Äì   : <br><br><pre> <code class="ruby hljs">iterator countup(a, <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> int): int = var res = a <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> res &lt;= <span class="hljs-symbol"><span class="hljs-symbol">b:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> res inc(res)</code> </pre><br>     ,     : <br><ul><li>        <code>for</code> ; </li><li>      <code>return</code> ,       <code>yield</code> ; </li><li>      <code>result</code> ; </li><li>    ; </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iterators cannot be declared previously, since the compiler must be able to inline (inline) an iterator (this restriction will be removed in future versions of the compiler). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, you can also use an iterator </font></font><code>closure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that has a different set of constraints. </font><font style="vertical-align: inherit;">For details, see the </font></font><a href="http://nim-lang.org/docs/manual.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">first class iterators</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> documentation </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Iterators can have the same names and parameters as procedures: they have their own namespace. </font><font style="vertical-align: inherit;">Therefore, there is a common practice for wrapping iterators into procedures with the same names that accumulate the result of an iterator and return it as a sequence, as </font></font><code>split</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from a module </font></font><code>strutils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Base types </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This section describes in detail the basic built-in types and operations that are available to them. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Boolean values </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The logical type in Nim is called </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and consists of two predefined values </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Conditions in the commands </font></font><code>while</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>elif</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>when</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must have a type </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For type </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined operators </font></font><code>not</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>xor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&lt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&gt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>!=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Operators </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perform abbreviated calculations.</font></font> Example: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> p != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p.name != <span class="hljs-string"><span class="hljs-string">"xyz"</span></span>: <span class="hljs-comment"><span class="hljs-comment"># p.name  ,  p == nil p = p.next</span></span></code> </pre><br><h3>  Characters </h3><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The character</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type in Nim is called </font></font><code>char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Its size is one byte. </font><font style="vertical-align: inherit;">Thus, it cannot be a UTF-8 character, only part of it. </font><font style="vertical-align: inherit;">The reason for this is efficiency: in the overwhelming majority of cases, ready-made programs will correctly process data in UTF-8, since UTF-8 was designed specifically for this. </font><font style="vertical-align: inherit;">Character literals are enclosed in single quotes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbols can be compared using operators </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&lt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>&gt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The operator </font></font><code>$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">converts </font></font><code>char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>string</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Characters cannot be mixed with integers; </font><font style="vertical-align: inherit;">To obtain the numerical value of a symbol, use the procedure </font></font><code>ord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Conversion from a numerical value to a symbol is performed using a procedure </font></font><code>chr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Strings </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String values ‚Äã‚Äãin Nim are </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutable</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so the operation of adding a substring to a string is quite efficient. Lines in Nim end with zero at the same time and contain a length field. The length of the string can be obtained by an inline procedure </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; length never takes into account the terminating zero. Access to the trailing zero does not cause an error and often leads to simplification of the code:</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s[i] == <span class="hljs-string"><span class="hljs-string">'a'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> s[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] == <span class="hljs-string"><span class="hljs-string">'b'</span></span>: <span class="hljs-comment"><span class="hljs-comment">#   ,  i &lt; len(s)! ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The assignment operator for strings copies the string. You can use the operator </font></font><code>&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to concatenate strings and </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to add a substring. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String comparisons are done in lexicographical order. Any comparison operators are allowed. By convention, all strings are UTF-8 strings, but this is not necessary. For example, when reading lines from binary files, they are rather a sequence of bytes. Operation </font></font><code>s[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means the </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-th </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">character</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (and not the </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-th </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unicode character) of the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> string </font></font><code>s</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String variables are initialized by a special value called </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, most string operations cannot work with</font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(this raises an exception) for performance reasons. </font><font style="vertical-align: inherit;">Instead </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of an empty value, use an empty string </font></font><code>""</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But it </font></font><code>""</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creates a string object in the heap, so here you need to look for a compromise between memory and performance.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Whole numbers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nim has the following built-in integer types: </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>int8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>int16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>int64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>uint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>uint8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>uint16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>uint32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>uint64</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The default is an integer type </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Integer literals can have a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suffix</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> denoting their belonging to one or another integer type:</font></font><br><br><pre> <code class="ruby hljs">let x = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment"># x   int y = 0'i8 # y   int8 z = 0'i64 # z   int64 u = 0'u # u   uint</span></span></code> </pre><br>        ,   ,    <code>int</code>   . <br><br>   <code>+</code> , <code>-</code> , <code>*</code> , <code>div</code> , <code>mod</code> , <code>&lt;</code> , <code>&lt;=</code> , <code>==</code> , <code>!=</code> , <code>&gt;</code>  <code>&gt;=</code>    .  <code>and</code> , <code>or</code> , <code>xor</code>  <code>not</code>         .        <code>shl</code> ,    ‚Äì    <code>shr</code> .          .       . <br><br>     ,       . <br><br>      ,     . ,       ,   <code>EOutOfRange</code> (       ). <br><br><h3>     </h3><br> Nim        : <code>float</code> , <code>float32</code>  <code>float64</code> . <br><br>     <code>float</code> .    <code>float</code>    64 . <br><br>        ,            : <br><br><pre> <code class="ruby hljs">var x = <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment"># x   float y = 0.0'f32 # y   float32 z = 0.0'f64 # z   float64</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Major operators </font></font><code>+</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>-</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>/</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&lt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>==</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>!=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>&gt;=</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined for floating point numbers and correspond to the IEEE standard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic type conversion in expressions with different types of floating point types is performed: smaller types are converted to larger ones. </font><font style="vertical-align: inherit;">Integer types are not automatically converted to floating point types and vice versa. </font><font style="vertical-align: inherit;">For such transformations, the </font></font><code>toInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">procedures can be used </font></font><code>toFloat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Type conversion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conversion between base types in Nim is done by using the type as a function: </font></font><br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> int32 = <span class="hljs-number"><span class="hljs-number">1</span></span>.int32 <span class="hljs-comment"><span class="hljs-comment">#  ,   int32(1) y: int8 = int8('a') # 'a' == 97'i8 z: float = 2.5 # int(2.5)   2 sum: int = int(x) + int(y) + int(z) # sum == 100</span></span></code> </pre><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Internal Type Representation </font></font></h2><br>   ,      <code>$</code>      ,          <code>echo</code> .   <code>$</code>        ,    ,       . <br><br>         ,         <code>$</code> .       <code>repr</code> ,            .   ,          <code>$</code>  <code>repr</code> : <br><br><pre> <code class="ruby hljs">var myBool = <span class="hljs-literal"><span class="hljs-literal">true</span></span> myCharacter = <span class="hljs-string"><span class="hljs-string">'n'</span></span> myString = <span class="hljs-string"><span class="hljs-string">"nim"</span></span> myInteger = <span class="hljs-number"><span class="hljs-number">42</span></span> myFloat = <span class="hljs-number"><span class="hljs-number">3.14</span></span> echo($myBool, <span class="hljs-string"><span class="hljs-string">":"</span></span>, repr(myBool)) <span class="hljs-comment"><span class="hljs-comment"># --&gt; true:true echo($myCharacter, ":", repr(myCharacter)) # --&gt; n:'n' echo($myString, ":", repr(myString)) # --&gt; nim:0x10fa8c050"nim" echo($myInteger, ":", repr(myInteger)) # --&gt; 42:42 echo($myFloat, ":", repr(myFloat)) # --&gt; 3.1400000000000001e+00:3.1400000000000001e+00</span></span></code> </pre><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New types in Nim can be defined using the command </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="ruby hljs">type biggestInt = int64 <span class="hljs-comment"><span class="hljs-comment">#  , ,    biggestFloat = float64 #    , ,   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enumerations and object types cannot be defined on the fly, only in a command </font></font><code>type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transfers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A variable relating to the type of enumeration may take only a limited set of values. </font><font style="vertical-align: inherit;">This set consists of ordered characters. </font><font style="vertical-align: inherit;">Each character is internally mapped to an integer value. </font><font style="vertical-align: inherit;">The first character corresponds to the number 0, the second to the number 1, and so on.</font></font> Example: <br><br><pre> <code class="ruby hljs">type Direction = enum north, east, south, west var x = south <span class="hljs-comment"><span class="hljs-comment"># `x`   `Direction`;   `south` echo($x) #  "south"  `stdout`</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For enumerations can be used any comparison operators. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the avoidance of transfers symbols can be classified: </font></font><code>Direction.south</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The operator </font></font><code>$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can convert any value of the enumeration into its name, and the procedure </font></font><code>ord</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into the corresponding integer value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For better interaction with other programming languages, integer values ‚Äã‚Äãcan be explicitly assigned to enumeration characters. </font><font style="vertical-align: inherit;">However, in any case, they should be in ascending order. </font><font style="vertical-align: inherit;">A character that has not been explicitly assigned a numerical value is assigned the value of the previous character plus 1. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicitly numbered enumerations may contain omissions:</font></font><br><br><pre> <code class="ruby hljs">type MyEnum = enum a = <span class="hljs-number"><span class="hljs-number">2</span></span>, b = <span class="hljs-number"><span class="hljs-number">4</span></span>, c = <span class="hljs-number"><span class="hljs-number">89</span></span></code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Enumerated types </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transfers without breaks, integer types </font></font><code>char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>bool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(and their sub-bands) - they are called enumerated types. </font><font style="vertical-align: inherit;">For enumerated types, there are several special operations:</font></font><br><table><tbody><tr><th>  Operation </th><th>  Comment </th></tr><tr><td> <code>ord(x)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns an integer that is used to represent the value </font></font><code>x</code> </td></tr><tr><td> <code>inc(x)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">increases </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by 1</font></font></td></tr><tr><td> <code>inc(x, n)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">increases </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- integer</font></font></td></tr><tr><td> <code>dec(x)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decreases </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by 1</font></font></td></tr><tr><td> <code>dec(x, n)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decreases </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- integer</font></font></td></tr><tr><td> <code>succ(x)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the next </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">item</font></font></td></tr><tr><td> <code>succ(x, n)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">th item following</font></font><code>x</code> </td></tr><tr><td> <code>pred(x)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> returns the predecessor </font></font><code>x</code> </td></tr><tr><td> <code>pred(x, n)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">th th predecessor</font></font><code>x</code> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operation </font></font><code>inc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>succ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be executed with an error, throws an exception </font></font><code>EOutOfRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>EOverflow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">(Unless, of course, the code is compiled with exceptions checks enabled.)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ranges </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This type is a range of values ‚Äã‚Äãof an integer type or enumeration (base type). </font></font> Example: <br><br><pre> <code class="ruby hljs">type Subrange = range[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span>]</code> </pre><br> <code>Subrange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a range </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that can contain values ‚Äã‚Äãfrom 0 to 5. Assigning any other values ‚Äã‚Äãto a type variable </font></font><code>Subrange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will result in a compilation error or runtime. </font><font style="vertical-align: inherit;">The assignment of a base type to one of its ranges (and vice versa) is permitted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module </font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defines an important type </font></font><code>Natural</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as </font></font><code>range[0..high(int)]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>high</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the maximum allowed value). </font><font style="vertical-align: inherit;">Other programming languages ‚Äã‚Äãforce unsigned integers to use natural numbers. </font><font style="vertical-align: inherit;">This is often </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wrong</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : you should not be forced to use unsigned arithmetic only for the reason that numbers cannot be negative. </font><font style="vertical-align: inherit;">The </font></font><code>Natural</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nim language </font><font style="vertical-align: inherit;">type </font><font style="vertical-align: inherit;">avoids this common programming error.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The sets </font></font></h3><br>  <code>set</code>    .          ,  : <ul><li> <code>int8-int16</code> </li> <li> <code>uint8/byte-uint16</code> </li> <li> <code>char</code> </li> <li> <code>enum</code> </li> </ul>  .   ,       .        : <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">s:</span></span> set[int64] <span class="hljs-comment"><span class="hljs-comment"># Error: set is too large</span></span></code> </pre><br>        : <code>{}</code>   .          .         (  ): <br><br><pre> <code class="ruby hljs">type CharSet = set[char] var <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> CharSet x = {<span class="hljs-string"><span class="hljs-string">'a'</span></span>..<span class="hljs-string"><span class="hljs-string">'z'</span></span>, <span class="hljs-string"><span class="hljs-string">'0'</span></span>..<span class="hljs-string"><span class="hljs-string">'9'</span></span>} <span class="hljs-comment"><span class="hljs-comment">#   ,    # 'a'  'z'    '0'  '9'</span></span></code> </pre><br>     : <br><table><tbody><tr><th>  Operation </th><th>  Description </th></tr><tr><td> <code>A + B</code> </td> <td>    </td></tr><tr><td> <code>A * B</code> </td> <td>    </td></tr><tr><td> <code>A - B</code> </td> <td>    ( <code>A</code>   <code>B</code> ) </td></tr><tr><td> <code>A == B</code> </td> <td>   </td></tr><tr><td> <code>A &lt;= B</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subset ratio ( </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a subset </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or equivalent </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></td></tr><tr><td> <code>A &lt; B</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strict subset relation ( </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a subset </font></font><code>B</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></td></tr><tr><td> <code>e in A</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">belonging to a set ( </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains an element </font></font><code>e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></td></tr><tr><td> <code>e notin A</code> </td> <td> <code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not contain an element </font></font><code>e</code> </td></tr><tr><td> <code>contains(A, e)</code> </td> <td> <code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contains an element </font></font><code>e</code> </td></tr><tr><td> <code>card(A)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">power </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(number of elements in </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></td></tr><tr><td> <code>incl(A, elem)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the same as </font></font><code>A = A + {elem}</code> </td></tr><tr><td> <code>excl(A, elem)</code> </td> <td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the same as </font></font><code>A = A - {elem}</code> </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sets are often used for procedure flags. </font><font style="vertical-align: inherit;">This is a more transparent (and type-safe) solution than the definition of integer constants that need to be combined with an operation </font></font><code>or</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arrays </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An array is a simple fixed-size container. All its elements are of the same type. As an array index, any enumerated type can be used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An array can be created using </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="ruby hljs">type IntArray = array[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span>, int] <span class="hljs-comment"><span class="hljs-comment">#   ,   0  5 var x: IntArray x = [1, 2, 3, 4, 5, 6] for i in low(x)..high(x): echo(x[i])</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notation is </font></font><code>x[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to gain access to the </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-th element </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When accessing the elements of an array, the boundaries are always checked (either at compile time or at run time). This check can be disabled by pragmas or by calling the compiler with the key </font></font><code>--bound_checks:off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays are value types, like other Nim types. The assignment statement copies the contents of the entire array. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The built-in procedure </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the length of the array. </font></font><code>low(a)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the smallest possible array index </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and the </font></font><code>high(a)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">largest possible index.</font></font><br><br><pre> <code class="ruby hljs">type Direction = enum north, east, south, west BlinkLights = enum off, on, slowBlink, mediumBlink, fastBlink LevelSetting = array[north..west, BlinkLights] var <span class="hljs-symbol"><span class="hljs-symbol">level:</span></span> LevelSetting level[north] = on level[south] = slowBlink level[east] = fastBlink echo repr(level) <span class="hljs-comment"><span class="hljs-comment"># --&gt; [on, fastBlink, slowBlink, off] echo low(level) # --&gt; north echo len(level) # --&gt; 4 echo high(level) # --&gt; west</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The syntax for nested arrays (plural dimension) in other languages ‚Äã‚Äãis to add additional square brackets, since usually each dimension must be of the same type as the others. In Nim, you can use different dimensions with different index types, so the nesting syntax is somewhat different. Based on the previous example, where </font></font><code>level</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined as an array of enumerations indexed by another enum, we can add the following lines to allow the type of beacon to be divided into levels that can be accessed through their integer index:</font></font><br><br><pre> <code class="ruby hljs">type LightTower = array[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>, LevelSetting] var <span class="hljs-symbol"><span class="hljs-symbol">tower:</span></span> LightTower tower[<span class="hljs-number"><span class="hljs-number">1</span></span>][north] = slowBlink tower[<span class="hljs-number"><span class="hljs-number">1</span></span>][east] = mediumBlink echo len(tower) <span class="hljs-comment"><span class="hljs-comment"># --&gt; 10 echo len(tower[1]) # --&gt; 4 echo repr(tower) # --&gt; [[slowBlink, mediumBlink, ... .... #     -   #tower[north][east] = on #tower[0][1] = on</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that the built-in procedure </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the length of the first level array only. </font><font style="vertical-align: inherit;">To even better show the nested nature </font></font><code>LightTower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, one would not have to write the previous type definition </font></font><code>LevelSetting</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but instead include it directly in the first dimension type:</font></font><br><br><pre> <code class="ruby hljs">type LightTower = array[<span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">10</span></span>, array[north..west, BlinkLights]]</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quite often, arrays start from zero, so there is an abbreviated syntax for specifying a range from zero to the specified index minus one: </font></font><br><br><pre> <code class="ruby hljs">type IntArray = array[<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span>, int] <span class="hljs-comment"><span class="hljs-comment"># ,   0  5 QuickArray = array[6, int] # ,   0  5 var x: IntArray y: QuickArray x = [1, 2, 3, 4, 5, 6] y = x for i in low(x)..high(x): echo(x[i], y[i])</span></span></code> </pre><br><h3>  Sequences </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequences are like arrays, only their length can change during execution (as with strings). </font><font style="vertical-align: inherit;">Since sequences can be resized, they are always heaped and participate in garbage collection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequences are always indexed </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, starting with 0. Operations </font></font><code>len</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>low</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>high</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">applicable to sequences. </font><font style="vertical-align: inherit;">Notation </font></font><code>x[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used to access the </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-th element </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequences can be constructed using an array constructor </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connected to an array-to-sequence conversion operator </font></font><code>@</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Another way to allocate memory for a sequence is to call an inline procedure </font></font><code>newSeq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A sequence can be passed in a parameter </font></font><code>openarray</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br>  Example: <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> seq[int] <span class="hljs-comment"><span class="hljs-comment">#      x = @[1, 2, 3, 4, 5, 6] # @    ,   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sequence variables are initialized by value </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. However, most sequence operations cannot work with </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(this will raise an exception) for reasons related to performance. So as an empty value, it is desirable to use an empty sequence </font></font><code>@[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But it </font></font><code>@[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">creates a sequence object in the heap, so you will need to look for a solution that is acceptable for your particular case. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The command </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used for the sequence can work with one or two variables. If you use a single variable form, the variable will contain the value provided by the sequence. The team </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runs on the results obtained from the </font></font><code>items()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">module </font><font style="vertical-align: inherit;">iterator</font></font><code>system</code> .        ,      ,   ‚Äì .     <code>for</code>     <code>pairs()</code>   <code>system</code> .  Examples: <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> @[<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]: echo($i) <span class="hljs-comment"><span class="hljs-comment"># --&gt; 3 # --&gt; 4 # --&gt; 5 for i, value in @[3, 4, 5]: echo("index: ", $i, ", value:", $value) # --&gt; index: 0, value:3 # --&gt; index: 1, value:4 # --&gt; index: 2, value:5</span></span></code> </pre><br><h3>   </h3><br><blockquote> <strong></strong> :        . </blockquote>  ,       :         .      .           0.     <code>len</code> , <code>low</code>  <code>high</code> .              ,     . <br><br><pre> <code class="ruby hljs">var <span class="hljs-symbol"><span class="hljs-symbol">fruits:</span></span> seq[string] <span class="hljs-comment"><span class="hljs-comment">#    ,  #   'nil' capitals: array[3, string] #      fruits = @[] #     ,  #    'fruits' capitals = ["New York", "London", "Berlin"] #  'capitals'  #     fruits.add("Banana") #  'fruits'  #     fruits.add("Mango") proc openArraySize(oa: openArray[string]): int = oa.len assert openArraySize(fruits) == 2 #    #    assert openArraySize(capitals) == 3 #    </span></span></code> </pre><br>       :     ,           . <br><br><h3>      </h3><br>  <code>varargs</code>   . ,         .       : <br><br><pre> <code class="ruby hljs">proc myWriteln(<span class="hljs-symbol"><span class="hljs-symbol">f:</span></span> File, <span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> varargs[string]) = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items(a): write(f, s) write(f, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) myWriteln(stdout, <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-string"><span class="hljs-string">"def"</span></span>, <span class="hljs-string"><span class="hljs-string">"xyz"</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   : myWriteln(stdout, ["abc", "def", "xyz"])</span></span></code> </pre><br>       ,   <code>varargs</code>    .        : <br><br><pre> <code class="ruby hljs">proc myWriteln(<span class="hljs-symbol"><span class="hljs-symbol">f:</span></span> File, <span class="hljs-symbol"><span class="hljs-symbol">a:</span></span> varargs[string, <span class="hljs-string"><span class="hljs-string">`$`</span></span>]) = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items(a): write(f, s) write(f, <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) myWriteln(stdout, <span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-string"><span class="hljs-string">"abc"</span></span>, <span class="hljs-number"><span class="hljs-number">4.0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   : myWriteln(stdout, [$123, $"abc", $4.0])</span></span></code> </pre><br>    <code>$</code>    ,    <code>a</code> . ,  <code>$</code> ,   ,   . <br><br><h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Syntax slices look similar to range types, but are used in a different context. </font><font style="vertical-align: inherit;">A slice is simply an object of type </font></font><code>Slice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that contains two borders, </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The slice itself is not very useful, but other types of collections define operators that accept objects </font></font><code>Slice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to specify ranges.</font></font><br><br><pre> <code class="ruby hljs"> var a = <span class="hljs-string"><span class="hljs-string">"Nim is a progamming language"</span></span> b = <span class="hljs-string"><span class="hljs-string">"Slices are useless."</span></span> echo a[<span class="hljs-number"><span class="hljs-number">7</span></span>..<span class="hljs-number"><span class="hljs-number">12</span></span>] <span class="hljs-comment"><span class="hljs-comment"># --&gt; 'a prog' b[11..^2] = "useful" echo b # --&gt; 'Slices are useful.'</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous example, slices are used to modify a fragment of a string. </font><font style="vertical-align: inherit;">The slice boundaries can contain any value that is supported by their type, but only the procedure using the slice object determines whether it will accept this value.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tuples (tuples) </font></font></h3><br>           .       <code>()</code> .            .     ,               . <br><br>        .  <code>t.field</code>      .  , <code>t[i]</code>    <code>i</code> -  ( <code>i</code>    ). <br><br><pre> <code class="ruby hljs">type Person = tuple[<span class="hljs-symbol"><span class="hljs-symbol">name:</span></span> string, <span class="hljs-symbol"><span class="hljs-symbol">age:</span></span> int] <span class="hljs-comment"><span class="hljs-comment">#   ,  #      var person: Person person = (name: "Peter", age: 30) #  ,   : person = ("Peter", 30) echo(person.name) # "Peter" echo(person.age) # 30 echo(person[0]) # "Peter" echo(person[1]) # 30 #         . var building: tuple[street: string, number: int] building = ("Rue del Percebe", 13) echo(building.street) #    ,   ! #person = building # --&gt; Error: type mismatch: got (tuple[street: string, number: int]) # but expected 'Person' #   ,       . var teacher: tuple[name: string, age: int] = ("Mark", 42) person = teacher</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although you do not need to declare a type to use a tuple, tuples created with different field names will be considered different objects, even if they have the same field types. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tuples can be unpacked in the process of assigning variables (and only in this case!). This is useful to directly assign the values ‚Äã‚Äãof the tuple fields to individual named variables. As an example, consider a procedure </font></font><code>splitFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from a module </font></font><code>os</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that simultaneously returns a directory, a name, and a path extension. To properly unpack a tuple, you need to use parentheses around the values ‚Äã‚Äãinto which you unpack the tuple, otherwise you will assign the same value to each of these variables!</font></font> Example: <br><br><pre> <code class="ruby hljs">import os let path = <span class="hljs-string"><span class="hljs-string">"usr/local/nimc.html"</span></span> (dir, name, ext) = splitFile(path) baddir, badname, badext = splitFile(path) echo dir <span class="hljs-comment"><span class="hljs-comment">#  usr/local echo name #  nimc echo ext #  .html #        : # `(dir: usr/local, name: nimc, ext: .html)` echo baddir echo badname echo badext</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unpacking tuples works only in blocks </font></font><code>var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>let</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The following code will not compile:</font></font><br><br><pre> <code class="ruby hljs">import os var path = <span class="hljs-string"><span class="hljs-string">"usr/local/nimc.html"</span></span> dir, name, ext = <span class="hljs-string"><span class="hljs-string">""</span></span> (dir, name, ext) = splitFile(path) <span class="hljs-comment"><span class="hljs-comment"># --&gt; Error: '(dir, name, ext)' cannot be assigned to</span></span></code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reference types and pointers </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">References (the same as pointers in other programming languages) are a way to organize many-to-one relationships. This means that different links can point to the same place in memory and modify it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nim distinguishes between traced and untraced links. Untracked links are also called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointers.</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tracked links point to objects on the heap with garbage collection, untracked - on objects for which memory was allocated manually or on objects in other places of memory. Thus, untracked links are unsafe. However, for some low-level operations (access to the "hardware") can not do without them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tracked links are declared by the keyword </font></font><code>ref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and untraceable - by the keyword </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empty subscript-notation </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used to dereference a link, that is, to get the element that the link points to. </font><font style="vertical-align: inherit;">Operators </font></font><code>.</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(access to a tuple / object field) and </font></font><code>[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(array / string / sequence index operator) perform implicit dereferencing for reference types:</font></font><br><br><pre> <code class="ruby hljs">type Node = ref NodeObj NodeObj = object le, <span class="hljs-symbol"><span class="hljs-symbol">ri:</span></span> Node <span class="hljs-symbol"><span class="hljs-symbol">data:</span></span> int var <span class="hljs-symbol"><span class="hljs-symbol">n:</span></span> Node new(n) n.data = <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-comment"><span class="hljs-comment">#    n[].data,     !</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To allocate memory for a new monitored object, a built-in procedure is used </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">To work with untraceable memory, procedures can be used </font></font><code>alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>dealloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>realloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Module documentation </font></font><code>system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains additional information on these issues. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the link does not indicate anything, it matters </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procedural type </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A procedural type is (somewhat abstract) a pointer to a procedure. </font><font style="vertical-align: inherit;">Variables of a procedural type may have a value </font></font><code>nil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nim uses a procedural type to implement functional programming techniques.</font></font><br><br>  Example: <br><br><pre> <code class="ruby hljs">proc echoItem(<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> int) = echo(x) proc forEach(<span class="hljs-symbol"><span class="hljs-symbol">action:</span></span> proc (<span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> int)) = const data = [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items(data): action(d) forEach(echoItem)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A non-obvious problem with procedural types is that procedure call conventions affect type compatibility: procedural types are compatible only when they use the same calling conventions. </font><font style="vertical-align: inherit;">Various calling conventions are listed in the </font></font><a href="http://nim-lang.org/docs/manual.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  Modules </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nim supports program partitioning according to the modular concept. Each module is in a separate file. Modules allow information hiding and separate compilation. They can access the symbols of other modules using the command </font></font><code>import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Only top-level characters marked with an asterisk ( </font></font><code>*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">can be exported </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  A var x*, y: int proc `*` *(a, b: seq[int]): seq[int] = #   : newSeq(result, len(a)) #    : for i in 0..len(a)-1: result[i] = a[i] * b[i] when isMainModule: #    ``*``  : assert(@[1, 2, 3] * @[1, 2, 3] == @[1, 4, 9])</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The module </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exports </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but not </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Top-level commands in the module are executed when the program starts. </font><font style="vertical-align: inherit;">This can be used, for example, to initialize complex data structures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each module has a special magic constant </font></font><code>isMainModule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which is true if the module is compiled as the main file. </font><font style="vertical-align: inherit;">This is very useful for embedding inside the test module, as shown in the previous example. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modules dependent on other modules are allowed, but very undesirable, because in this case the module cannot be reused without its dependencies. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The algorithm for compiling modules is as follows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile the module as usual, recursively following the commands </font></font><code>import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If a loop is detected, import only already parsed characters (exported); </font><font style="vertical-align: inherit;">if an unknown identifier is encountered, then abort the operation.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is best shown by example: </font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  A type T1* = int #  A   ``T1`` import B #    B proc main() = var i = p(3) # ,  B     main()</span></span></code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  B import A # A      !     # ,    A   . proc p*(x: A.T1): A.T1 = #  ,     T1    A result = x + 1</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Module characters </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> be </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qualified</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using syntax </font></font><code>module.symbol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If the character is ambiguous, it must qualify. </font><font style="vertical-align: inherit;">A symbol is ambiguous if it is defined in two (or more) different modules and both modules are imported by the third:</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  A var x*: string</span></span></code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  B var x*: int</span></span></code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  C import A, B write(stdout, x) # : x  write(stdout, Ax) #  :   var x = 4 write(stdout, x) #  :  x  C</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this rule does not apply to procedures or iterators. </font><font style="vertical-align: inherit;">Overload rules apply here:</font></font><br><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  A proc x*(a: int): string = $a</span></span></code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  B proc x*(a: string): string = $a</span></span></code> </pre><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#  C import A, B write(stdout, x(3)) #  :  Ax write(stdout, x("")) #  :  Bx proc x*(a: int): string = nil write(stdout, x(3)) # :  `x` ?</span></span></code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Character exclusion </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Usually, the command </font></font><code>import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes all exported characters. </font><font style="vertical-align: inherit;">This can be changed by specifying exclude characters with qualifier </font></font><code>except</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="ruby hljs">import mymodule except y</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From team </font></font></h3><br>      <code>import</code> ,    .         <code>from import</code> : <br><br><pre> <code class="ruby hljs">from mymodule import x, y, z</code> </pre><br>  <code>from</code>        ,      ,       . <br><br><pre> <code class="ruby hljs">from mymodule import x, y, z x() <span class="hljs-comment"><span class="hljs-comment">#  x  </span></span></code> </pre><br><pre> <code class="ruby hljs">from mymodule import <span class="hljs-literal"><span class="hljs-literal">nil</span></span> mymodule.x() <span class="hljs-comment"><span class="hljs-comment">#   x,       x() #  x      </span></span></code> </pre><br>      ,      ,     . <br><br><pre> <code class="ruby hljs">from mymodule as m import <span class="hljs-literal"><span class="hljs-literal">nil</span></span> mx() <span class="hljs-comment"><span class="hljs-comment"># m    mymodule</span></span></code> </pre><br><h3>  include </h3><br>  <code>include</code>  ,     :       .           : <br><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">include</span></span> fileA, fileB, fileC</code> </pre><br><br> <i>( : <a href="http://habrahabr.ru/post/271361/">¬´   Nim ( 2)¬ª</a> .)</i> </div><p>Source: <a href="https://habr.com/ru/post/271197/">https://habr.com/ru/post/271197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271185/index.html">Upsource 2.5: smart email notification, new Review page design, improvements in IDE plugin and much more</a></li>
<li><a href="../271189/index.html">Using WordPress AJAX Handler</a></li>
<li><a href="../271191/index.html">How to analyze a file for malware?</a></li>
<li><a href="../271193/index.html">"Red Card": what is behind the warning of malware?</a></li>
<li><a href="../271195/index.html">Flexbox for interfaces in all its glory: Implementing Tracks (Part 1)</a></li>
<li><a href="../271199/index.html">Main announcements of the Microsoft Connect conference () and the virtual conference Visual Studio Connect 2015 in Russia on December 4</a></li>
<li><a href="../271201/index.html">Why constantly writing code is so important - how not to become a catfish</a></li>
<li><a href="../271203/index.html">Secure TLS connection using Boost.Asio and OpenSSL under Windows</a></li>
<li><a href="../271207/index.html">How does the video analytics</a></li>
<li><a href="../271211/index.html">Hackers invented a new money theft scheme, stealing 250 million rubles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>