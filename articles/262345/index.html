<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generating and solving a maze using the depth-depth search method</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article we will discuss the simplest in the implementation of the algorithm of generating the "ideal" maze and its application for finding the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generating and solving a maze using the depth-depth search method</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/969/201/28e/96920128e9364d66b7d28258b20e329f.png" alt="image"><br><br>  In this article we will discuss the simplest in the implementation of the algorithm of generating the "ideal" maze and its application for finding the way. <br><br>  We consider an algorithm based on backtracking, which allows you to create labyrinths without cycles, having a single path between two points.  The algorithm is not the fastest, rather demanding of resources, compared with <a href="http://habrahabr.ru/post/176671/">the Euler</a> or Kruskal <a href="http://habrahabr.ru/post/176671/">algorithm</a> , but very simple to implement and allows you to create branched mazes with very long dead-end branches. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Interested - I ask under the cat. <br><a name="habracut"></a><br>  In the Russian-language Internet there is very little information on the algorithms for generating labyrinths, which was the reason for writing this article. <br>  Code samples in the C language, as well as the full source code of the project on GitHub, are available under the GNU GPLv3 license. <br>  Links to English-speaking resources and the project can be found at the end of the article. <br><br><h5>  Algorithm Description </h5><br>  Note: it is assumed that initially each cell has walls on all four sides, which separate it from its neighboring cells. <br><br>  1. Make the starting cell current and mark it as visited. <br>  2. As long as there are unvisited cells. <br>  1. If the current cell has unvisited "neighbors" <br>  1. Push current cell to stack <br>  2. Choose a random cell from the adjacent <br>  3. Remove the wall between the current cell and the selected <br>  4. Make the selected cell current and mark it as visited. <br>  2. Otherwise, if the stack is not empty <br>  1. Pull the cell out of the stack. <br>  2. Make it current <br>  3. Otherwise <br>  1. Select a random unvisited cell, make it current and mark it as visited. <br><br>  You probably noticed that when condition 3 is fulfilled, the finished maze is most likely to have an isolated area. <br>  This condition is included in the algorithm as an exception, in practice, during normal operation of the algorithm and the correct input data, it never holds. <br><br><h5>  Implementation </h5><br>  As mentioned above, it is assumed that at the beginning of the algorithm, all cells are separated by walls. <br><br><h6>  Illustration of the algorithm </h6><br>  0 <img src="https://habrastorage.org/files/ed2/eb4/b56/ed2eb4b5618b46e085279c1c11e380f9.png" alt="image">  &lt;- Initial matrix. <br><br>  one. <img src="https://habrastorage.org/files/663/eee/d16/663eeed16b21499890a583150ba5d220.png" alt="image">  &lt;- Choose the starting point of the starting point. <br><br>  2.1. <img src="https://habrastorage.org/files/2a9/8bc/aff/2a98bcaff2e64e31a77aa1479eb7cd72.png" alt="image">  &lt;- We move to a random unvisited neighbor while there are any. <br><br>  2.2. <img src="https://habrastorage.org/files/67d/9bd/29f/67d9bd29fbac4398801134179116405f.png" alt="image">  &lt;- There are no unvisited neighbors.  Go back through the stack until there are no unvisited neighbors. <br><br>  2.1. <img src="https://habrastorage.org/files/d99/7c0/54e/d997c054ebe44d0e8d5a2d1176492a6c.png" alt="image">  &lt;- Unvisited neighbors are there.  Move to a random unvisited neighbor. <br><br>  2 <img src="https://habrastorage.org/files/f14/df0/76b/f14df076b30b4409aa2b93bb575654d1.png" alt="image">  &lt;- No unvisited cells.  Labyrinth generated. <br><br><h6>  Program code </h6><br>  Getting to the most interesting. <br><br>  We begin to act in order and first generate the initial matrix with which the algorithm will work. <br>  For convenience, let's agree that all cell types are specified in the listing. <br><br><pre><code class="hljs markdown">int maze[<span class="hljs-string"><span class="hljs-string">height</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">width</span></span>]; //  -   for(i = 0; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++){ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">for</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">++){ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">((</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> % </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag"> != </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp;&amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> % </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span></span><span class="xml"><span class="hljs-tag"> != </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">0)</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp;&amp; //    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span></span><span class="xml"><span class="hljs-tag">  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">y</span></span></span></span><span class="xml"><span class="hljs-tag">, (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">height-1</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp;&amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width-1</span></span></span></span><span class="xml"><span class="hljs-tag">)) //        </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">maze</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">CELL;</span></span></span></span><span class="xml"><span class="hljs-tag"> //   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">else</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">maze</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">j</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">WALL;</span></span></span></span><span class="xml"><span class="hljs-tag"> //    </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span></span><span class="xml"><span class="hljs-tag"> } }</span></span></span></span></code> </pre> <br>  Now that all the preparations have been made, we can proceed to the generation. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cell</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-comment"><span class="hljs-comment">//,      unsigned int x; unsigned int y; } cell; typedef struct cellString{ cell* cells; unsigned int size; } cellString;</span></span></code> </pre><br>  Structures will greatly simplify life when exchanging information between functions. <br><br>  The code snippet responsible for generating: <br><br><pre> <code class="hljs ruby">cell startCell = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>} cell currentCell = startCell; cell neighbourCell; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>{ cellString Neighbours = getNeighbours(width, height, maze, startPoint, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Neighbours.size != <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      randNum = randomRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, Neighbours.size-<span class="hljs-number"><span class="hljs-number">1</span></span>); neighbourCell = cellStringNeighbours.cells[randNum]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   push(d.startPoint); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     maze = removeWall(currentCell, neighbourCell, maze); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       currentCell = neighbourCell; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        maze = setMode(d.startPoint, d.maze, VISITED); free(cellStringNeighbours.cells); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(stackSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,     startPoint = pop(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,     ,     cellString cellStringUnvisited = getUnvisitedCells(width, height, maze); randNum = randomRange(<span class="hljs-number"><span class="hljs-number">0</span></span>, cellStringUnvisited.size-<span class="hljs-number"><span class="hljs-number">1</span></span>); currentCell = cellStringUnvisited.cells[randNum]; free(cellStringUnvisited.cells); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(unvisitedCount() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  As you can see, the implementation of the algorithm is simple and abstract from the theory, as they say, ‚Äúeven a child can handle it‚Äù. <br>  In order not to overload the article, the code of the functions used in the above passage, under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">Feature Code</b> <div class="spoiler_text">  The getNeighbours function returns an array of unvisited cell neighbors. <br><br><pre> <code class="hljs markdown">cellString getNeighbours(unsigned int width, unsigned int height, int<span class="hljs-emphasis"><span class="hljs-emphasis">** maze, cell c){ unsigned int i; unsigned int x = cx; unsigned int y = cy; cell up = {x, y - distance}; cell rt = {x + distance, y}; cell dw = {x, y + distance}; cell lt = {x - distance, y}; cell d[4] = {dw, rt, up, lt}; unsigned int size = 0; cellString cells; cells.cells = malloc(4 *</span></span> sizeof(cell)); for(i = 0; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++){ //   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">d</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">]</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.x</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span> 0 &amp;&amp; d[<span class="hljs-string"><span class="hljs-string">i</span></span>].x <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp;&amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">d</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">]</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.y</span></span></span></span><span class="xml"><span class="hljs-tag"> &gt;</span></span></span></span> 0 &amp;&amp; d[<span class="hljs-string"><span class="hljs-string">i</span></span>].y <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span></span><span class="xml"><span class="hljs-tag">){ //      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">unsigned</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mazeCellCurrent</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">maze[d[i].y][d[i].x];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cell</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cellCurrent</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">d[i];</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mazeCellCurrent</span></span></span></span><span class="xml"><span class="hljs-tag"> != </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">WALL</span></span></span></span><span class="xml"><span class="hljs-tag"> &amp;&amp; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mazeCellCurrent</span></span></span></span><span class="xml"><span class="hljs-tag"> != </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">VISITED){</span></span></span></span><span class="xml"><span class="hljs-tag"> //  \  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cells.cells</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span></span><span class="xml"><span class="hljs-tag">] = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">cellCurrent;</span></span></span></span><span class="xml"><span class="hljs-tag"> //  ; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span></span><span class="xml"><span class="hljs-tag">++; } } } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cells.size</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">size;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cells</span></span></span></span><span class="xml"><span class="hljs-tag">;</span></span></span></span></code> </pre><br>  The removeWall function removes the wall between two cells: <br><br><pre> <code class="hljs markdown">mazeMatrix removeWall(cell first, cell second, int** maze){ short int xDiff = second.x - first.x; short int yDiff = second.y - first.y; short int addX, addY; cell target; addX = (xDiff != 0) ? (xDiff / abs(xDiff)) : 0; addY = (yDiff != 0) ? (yDiff / abs(yDiff)) : 0; target.x = first.x + addX; //  target.y = first.y + addY; maze[<span class="hljs-string"><span class="hljs-string">target.y</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">target.x</span></span>] = VISITED; return maze; }</code> </pre><br>  First, the value of the difference between the coordinates of the second and first points is calculated.  Obviously, the value can be either negative, or positive, or 0. <br><br>  It is necessary to find such xy coordinates so that when added together with the coordinates of the first point, the coordinates of the wall are obtained. <br><br>  Since we know for sure that the difference vector between the coordinates of the wall and the first point is either (| 1 |, 0) or (0, | 1 |), we can use this. <br><br>  Thus, the additive for x coordinates at xDiff! = 0 will be xDiff / | xDiff |, at xDiff = 0, zero.  For y, respectively. <br>  Having received additions for x and y, we easily calculate the coordinates of the wall between the first and second cells and assign the cell to these visited coordinates. <br></div></div><br>  So now we have a labyrinth generator that can build intricate mazes, the size of which is limited only by the size of the RAM. <br><br>  As a result, we can get something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Labyrinths.</b>  <b class="spoiler_title">Caution traffic!</b> <div class="spoiler_text">  100x100 <br><img src="https://habrastorage.org/files/3f6/6f3/f93/3f66f3f934694ea59abaaca1dfc173e1.png" alt="image"><br>  500x500 <br><img src="https://habrastorage.org/files/1a4/3a0/26d/1a43a026d15c43ccac0f54266fd8b46c.png" alt="image"><br></div></div><br>  Generation works, now it‚Äôs small: to find a way out in such a labyrinth. <br><br>  There are a few more pathfinding algorithms than generation algorithms, and some of them, if readers are interested, I will cover in the following articles, but for now we will be content with what we have and ‚Äúgo through‚Äù the maze with the same algorithm. <br><br>  And it is still easier to simplify, since we no longer need to remove the walls. <br><br>  Backtracking path search algorithm: <br>  1. Make the starting cell current and mark it as visited. <br>  2. Until the exit is found <br>  1. If the current cell has unvisited "neighbors" <br>  1. Push current cell to stack <br>  2. Choose a random cell from the adjacent <br>  3. Make the selected cell current and mark it as visited. <br>  2. Otherwise, if the stack is not empty <br>  1. Pull the cell out of the stack. <br>  2. Make it current <br>  3. Otherwise there is no way out. <br><br>  The exit point, like the starting point, can be any point of the maze that is not a wall. <br>  Traditionally, the exit should be "pressed" to one of the walls, but in fact it can be anywhere. <br>  All the same, in this case, the ‚Äúentrance‚Äù and ‚Äúexit‚Äù are just two points between which it is necessary to find a path. <br><br>  The criterion for finding the "exit" is very simple: it is enough to compare the coordinates of the current point and the coordinates of the "output": if they are equal, the path between the starting and output points is found. <br><br>  Let's see what happened: <br><br><div class="spoiler">  <b class="spoiler_title">Solved mazes.</b>  <b class="spoiler_title">Traffic!</b> <div class="spoiler_text">  Red is the path, blue is the visited cell. <br>  100x100 <br><img src="https://habrastorage.org/files/65b/bc4/8f0/65bbc48f0f494e80a474cadb69824bb3.png" alt="image"><br><br><img src="https://habrastorage.org/files/b33/fb3/cfe/b33fb3cfeada4f98a9c73dbd6d736e65.png" alt="image"><br>  500x500 <br><img src="https://habrastorage.org/files/c64/c68/7a3/c64c687a3f5b44e8a9280129392a0364.png" alt="image"><br><br><img src="https://habrastorage.org/files/5e0/a33/55a/5e0a3355a7ea4415bb61470f01148d0f.png" alt="image"><br>  80008000 <br><img src="https://habrastorage.org/files/149/38f/843/14938f84303744728f7dd9e635c009e7.png" alt="image"><br><br><img src="https://habrastorage.org/files/7d7/2d4/3cf/7d72d43cf26740d39dc6dc424e6c575f.png" alt="image"><br><br>  80008000 in the original resolution (16000px, 30mb): <br>  <a href="https://yadi.sk/i/YS0ImN-PhoLcZ">yadi.sk/i/YS0ImN-PhoLcZ</a> <br>  <a href="https://yadi.sk/i/YZjzwPu5hoLcd">yadi.sk/i/YZjzwPu5hoLcd</a> <br></div></div><br>  That's all that is needed for the simplest implementation of a random maze generator. <br><br>  For those who are interested, the full source code of the project on GitHub: <a href="https://github.com/mersinvald/maze-generator_offscreen">Maze Generator and Solver (offscreen rendering)</a> <br><br><div class="spoiler">  <b class="spoiler_title">Attention!</b> <div class="spoiler_text">  OSMesa is <b>not supported by</b> some drivers on unix-based, and on Windows is <b>not supported at all</b> , so for those who are not lucky with OS / hardware, I can suggest to get acquainted with the related project: <a href="https://github.com/mersinvald/maze-generator">Maze Generator and Solver</a> <br>  In both projects, the same algorithms are implemented, but the first one draws in memory and displays a sequence of png-images, and the second one on the screen. <br>  Building cd build &amp;&amp; ../configure &amp;&amp; make, if inconvenient, in the src folder there is a QtCreator project file. <br></div></div><br><h5>  Sources </h5><br>  1. <a href="http://www.astrolog.org/labyrnth/algrithm.htm">Walter D. Pullen: Think Labyrinth.</a> <br>  2. <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm">Wikipedia: Maze generation algorithm.</a> </div><p>Source: <a href="https://habr.com/ru/post/262345/">https://habr.com/ru/post/262345/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262333/index.html">Tekla Structures API (Delphi): Connection and Simple Examples</a></li>
<li><a href="../262335/index.html">Garbage collector in Go: solving the problem of responsiveness in Go 1.5</a></li>
<li><a href="../262339/index.html">2 Pi or not 2 Pi - that is the question</a></li>
<li><a href="../262341/index.html">We sign data: HMAC in practice in API and Web-forms</a></li>
<li><a href="../262343/index.html">We recognize Morse codes using Rx.js</a></li>
<li><a href="../262349/index.html">The end is only the beginning.</a></li>
<li><a href="../262351/index.html">Translation of RivetsJS documentation</a></li>
<li><a href="../262357/index.html">Neural interfaces for people (2003-2016). Buy or develop yourself?</a></li>
<li><a href="../262361/index.html">Spring without XML. Part 2</a></li>
<li><a href="../262363/index.html">How do visually impaired programmers program?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>