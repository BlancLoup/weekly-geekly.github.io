<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL indexes - 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have already covered PostgreSQL's indexing mechanism and access methods interface , as well as one of the access methods, the hash index . Now let'...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL indexes - 4</h1><div class="post__text post__text-html js-mediator-article"><br>  We have already covered <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">PostgreSQL's indexing mechanism</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">access methods interface</a> , as well as one of the access methods, the <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash index</a> .  Now let's talk about the most traditional and used index - the B-tree.  The head turned out great, be patient. <br><br><h1>  Btree </h1><br><h2>  Device </h2><br>  The btree index, also known as the B-tree, is suitable for data that can be sorted.  In other words, for the data type, the operators "greater than", "greater than or equal to", "less than", "less than or equal to" and "equal" should be defined.  Notice that the same data can sometimes be sorted in different ways, which <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">brings</a> us <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">back</a> to the concept of a family of operators. <br><a name="habracut"></a><br>  As always, B-tree index records are packed into pages.  In leaf pages, these records contain indexed data (keys) and links to table rows (TIDs);  in the inner pages, each entry refers to the child page of the index and contains the minimum key value in this page. <br><br>  B-trees have several important properties: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  They are balanced, that is, any sheet page separates the same number of inner pages from the root.  Therefore, the search for any value takes the same time. <br></li><li>  They are very branchy, that is, each page (as a rule, 8 KB) contains many (hundreds) TIDs at once.  Due to this, the depth of the B-trees is small;  in practice, up to 4‚Äì5 for very large tables. <br></li><li>  The data in the index is arranged in non-decreasing order (both between the pages and within each page), and the pages of the same level are linked by a bi-directional list.  Therefore, we can get an ordered set of data, simply by going through the list in one direction or the other, without returning to the root each time. <br></li></ul><br>  Here is a schematic example of an index on a single field with integer keys. <br><br><img src="https://habrastorage.org/web/2e4/4f4/003/2e44f400317048c78e4cec04ab45e48e.png"><br><br>  At the very beginning of the file is the metastpage, which refers to the index root.  Below the root are the internal nodes;  the bottom row is leaf pages.  The down arrows symbolize links from leaf nodes to table rows (TIDs). <br><br><h3>  Equality Search </h3><br>  Consider searching for a value in a tree by the condition ‚Äú <em>indexed-field = expression</em> ‚Äù.  Suppose we are interested in key 49. <br><br><img src="https://habrastorage.org/web/9fd/814/c9e/9fd814c9e79443b2a774403a817bf734.png"><br><br>  The search starts from the root node, and we need to determine which of the child nodes to descend.  By knowing the keys in the root node (4, 32, 64), we thereby understand the ranges of values ‚Äã‚Äãin the child nodes.  Since 32 ‚â§ 49 &lt;64, it is necessary to go down to the second child node.  Then the same procedure is repeated recursively until a leaf node is reached, from which the necessary TIDs can already be obtained. <br><br>  In reality, this seemingly simple procedure is complicated by a number of circumstances.  For example, the index may contain non-unique keys and the same values ‚Äã‚Äãmay be quite a lot so that they do not fit on one page.  Continuing our example, it seems that from the internal node we should go down the link that leads from the value 49. But, as can be seen in the picture, we‚Äôll skip one of the keys 49 in the previous leaf page.  Therefore, having found the exact key equality on the inner page, we have to go down one position to the left, and then view the index records of the underlying level from left to right in search of the key of interest. <br><br>  (Another difficulty is caused by the fact that during the search other processes can change the data: the tree can be rebuilt, the pages can be divided into two, etc. All algorithms are designed so that these simultaneous actions do not interfere with each other and do not require unnecessary locks. But we will not go into these details any more.) <br><br><h3>  Inequality search </h3><br>  When searching by the condition ‚Äú <em>indexed-field ‚â§ expression</em> ‚Äù (or ‚Äú <em>indexed-field ‚â• expression</em> ‚Äù), first we find in the index the value by the condition of equality ‚Äú <em>indexed-field = expression</em> ‚Äù (if any), and then we move along the leaf pages to end in the right direction. <br><br>  The figure illustrates this process for the condition n ‚â§ 35: <br><br><img src="https://habrastorage.org/web/35e/62a/f80/35e62af80ca44349b7728ad806226208.png"><br><br>  The operators ‚Äúmore‚Äù and ‚Äúless‚Äù are supported in the same way, it is only necessary to exclude the original value found. <br><br><h3>  Search by range </h3><br>  When searching by the range ‚Äú <em>expression1 ‚â§ indexed-field ‚â§ expression2</em> ‚Äù we find the value by the condition ‚Äú <em>indexed-field = expression1</em> ‚Äù, and then we move through the leaf pages until the condition ‚Äú <em>indexed-field ‚â§ expression2</em> ‚Äù is fulfilled.  Or vice versa: we start from the second expression and move in the other direction until we reach the first. <br><br>  The figure shows the process for condition 23 ‚â§ n ‚â§ 64: <br><br><img src="https://habrastorage.org/web/2d6/b24/d86/2d6b24d86fb24c9ab437cc8155658e58.png"><br><br><h2>  Example </h2><br>  Let's see what the query plans look like by example.  As usual, we use a demo database, and this time we take a table of aircraft.  There are only nine lines in it and the scheduler will not use an index of its own free will, because the entire table is placed in one page.  But we are interested in it because of clarity. <br><br> <code>demo=# select * from aircrafts; <br> aircraft_code |        model        | range <br> ---------------+---------------------+------- <br> 773          | Boeing 777-300      | 11100 <br> 763          | Boeing 767-300      |  7900 <br> SU9          | Sukhoi SuperJet-100 |  3000 <br> 320          | Airbus A320-200    |  5700 <br> 321          | Airbus A321-200    |  5600 <br> 319          | Airbus A319-100    |  6700 <br> 733          | Boeing 737-300      |  4200 <br> CN1          | Cessna 208 Caravan  |  1200 <br> CR2          | Bombardier CRJ-200  |  2700 <br> (9 rows) <br> <br> demo=# create index on aircrafts(range); <br> CREATE INDEX <br> <br> demo=# set enable_seqscan = off; <br> SET <br></code> <br>  (Or explicitly create index on aircrafts using btree (range), but by default it is the B-tree that is built.) <br><br>  Equality Search: <br><br> <code>demo=# explain(costs off) select * from aircrafts where range = 3000; <br> QUERY PLAN <br> --------------------------------------------------- <br> Index Scan using aircrafts_range_idx on aircrafts <br> Index Cond: (range = 3000) <br> (2 rows) <br></code> <br>  Search for inequality: <br><br> <code>demo=# explain(costs off) select * from aircrafts where range &lt; 3000; <br> QUERY PLAN <br> --------------------------------------------------- <br> Index Scan using aircrafts_range_idx on aircrafts <br> Index Cond: (range &lt; 3000) <br> (2 rows) <br></code> <br>  And by range: <br><br> <code>demo=# explain(costs off) select * from aircrafts where range between 3000 and 5000; <br> QUERY PLAN <br> ----------------------------------------------------- <br> Index Scan using aircrafts_range_idx on aircrafts <br> Index Cond: ((range &gt;= 3000) AND (range &lt;= 5000)) <br> (2 rows) <br></code> <br><h2>  Sorting </h2><br>  It is worth emphasizing once again that with any scanning method (index, exclusively index, on a bitmap), the btree access method returns ordered data, which is clearly seen in the figures above. <br><br>  Therefore, if there is an index on the table according to the sorting condition, the optimizer will take into account both possibilities: reference to the table by index and automatic retrieval of sorted data, or sequential reading of the table and subsequent sorting of the result. <br><br><h3>  The sort order </h3><br>  When creating an index, you can explicitly specify the sort order.  For example, an index on the flight range could be created like this: <br><br> <code>demo=# create index on aircrafts(range desc); <br></code> <br>  In this case, to the left in the tree would be greater values, and to the right - smaller values.  Why this may be needed if the indexed values ‚Äã‚Äãcan be passed in one direction or in the other? <br><br>  The reason is multi-column indexes.  Let's create an idea that will show the models of aircraft and conditional division into short, medium and long-haul vessels: <br><br> <code>demo=# create view aircrafts_v as <br> select model, <br> case <br> when range &lt; 4000 then 1 <br> when range &lt; 10000 then 2 <br> else 3 <br> end as class <br> from aircrafts; <br> CREATE VIEW <br> <br> demo=# select * from aircrafts_v; <br> model        | class <br> ---------------------+------- <br> Boeing 777-300      |    3 <br> Boeing 767-300      |    2 <br> Sukhoi SuperJet-100 |    1 <br> Airbus A320-200    |    2 <br> Airbus A321-200    |    2 <br> Airbus A319-100    |    2 <br> Boeing 737-300      |    2 <br> Cessna 208 Caravan  |    1 <br> Bombardier CRJ-200  |    1 <br> (9 rows) <br></code> <br>  And create an index (using an expression): <br><br> <code>demo=# create index on aircrafts( <br> (case when range &lt; 4000 then 1 when range &lt; 10000 then 2 else 3 end), model); <br> CREATE INDEX <br></code> <br>  Now we can use this index to get the data sorted by both columns in ascending order: <br><br> <code>demo=# select class, model from aircrafts_v order by class, model; <br> class |        model <br> -------+--------------------- <br> 1 | Bombardier CRJ-200 <br> 1 | Cessna 208 Caravan <br> 1 | Sukhoi SuperJet-100 <br> 2 | Airbus A319-100 <br> 2 | Airbus A320-200 <br> 2 | Airbus A321-200 <br> 2 | Boeing 737-300 <br> 2 | Boeing 767-300 <br> 3 | Boeing 777-300 <br> (9 rows) <br> <br> demo=# explain(costs off) select class, model from aircrafts_v order by class, model; <br> QUERY PLAN <br> -------------------------------------------------------- <br> Index Scan using aircrafts_case_model_idx on aircrafts <br> (1 row) <br></code> <br>  Similarly, you can execute a query with sorting in descending order: <br> <code><br> demo=# select class, model from aircrafts_v order by class desc, model desc; <br> class |        model <br> -------+--------------------- <br> 3 | Boeing 777-300 <br> 2 | Boeing 767-300 <br> 2 | Boeing 737-300 <br> 2 | Airbus A321-200 <br> 2 | Airbus A320-200 <br> 2 | Airbus A319-100 <br> 1 | Sukhoi SuperJet-100 <br> 1 | Cessna 208 Caravan <br> 1 | Bombardier CRJ-200 <br> (9 rows) <br> <br> demo=# explain(costs off) <br> select class, model from aircrafts_v order by class desc, model desc; <br> QUERY PLAN <br> ----------------------------------------------------------------- <br> Index Scan <strong>Backward</strong> using aircrafts_case_model_idx on aircrafts <br> (1 row) <br></code> <br>  But from this index it is impossible to obtain data sorted by one column in descending order, and the other - in ascending order.  To do this, you will need to sort separately: <br><br> <code>demo=# explain(costs off) <br> select class, model from aircrafts_v order by class <strong>asc</strong> , model <strong>desc</strong> ; <br> QUERY PLAN <br> ------------------------------------------------- <br> Sort <br> Sort Key: (CASE ... END), aircrafts.model DESC <br> -&gt;  Seq Scan on aircrafts <br> (3 rows) <br></code> <br>  (Note that with grief, the scheduler chose to scan the table, even though the enable_seqscan = off setting was made earlier. This is because, in fact, it does not prohibit scanning the table, but only sets it beyond the limit cost - see the plan with ‚Äúcosts on‚Äù. ) <br><br>  In order for such a query to be executed using an index, the index must be constructed and sorted in the necessary order: <br><br> <code>demo=# create index aircrafts_case_asc_model_desc_idx on aircrafts( <br> (case when range &lt; 4000 then 1 when range &lt; 10000 then 2 else 3 end) <strong>asc</strong> , model <strong>desc</strong> ); <br> CREATE INDEX <br> <br> demo=# explain(costs off) <br> select class, model from aircrafts_v order by class <strong>asc</strong> , model <strong>desc</strong> ; <br> QUERY PLAN <br> ----------------------------------------------------------------- <br> Index Scan using aircrafts_case_asc_model_desc_idx on aircrafts <br> (1 row) <br></code> <br><h3>  Column order </h3><br>  Another issue that arises when using multi-column indexes is the order of listing the columns in the index.  In the case of a B-tree, this order is of great importance: the data inside the pages will be sorted first by the first field, then by the second, and so on. <br><br>  The index, which we built by range intervals and models, can be represented as follows: <br><br><img src="https://habrastorage.org/web/90c/71b/c8b/90c71bc8b51441b7b3c0df21b6a8888b.png"><br><br>  Of course, in fact, such a small index will fit into one root page;  in the figure it is artificially distributed over several pages for clarity. <br><br>  From this scheme, it is clear that the search will work effectively with such, for example, predicates, like "class = 3" (search only for the first field) or "class = 3 and model = 'Boeing 777-300'" (search by both fields ). <br><br>  But the search for the predicate ‚Äúmodel = 'Boeing 777-300'‚Äù will be much less effective: starting from the root, we cannot determine which of the child nodes to descend, so we will have to go down to everything.  This does not mean that such an index can not be used in principle - the only question is efficiency.  For example, if we had three classes of airplanes and a lot of models in each class, we would have to look at about a third of the index, and this could be more efficient than a full table scan.  And it could not be. <br><br>  But if you create an index like this: <br><br> <code>demo=# create index on aircrafts( <br> model, (case when range &lt; 4000 then 1 when range &lt; 10000 then 2 else 3 end)); <br> CREATE INDEX <br></code> <br>  then the order of the fields will change: <br><br><img src="https://habrastorage.org/web/458/c5f/d22/458c5fd22e26467d9f0c56e308d8db5f.png"><br><br>  And with this index, the search by the predicate ‚Äúmodel = 'Boeing 777-300'‚Äù will be performed efficiently, but by the predicate ‚Äúclass = 3‚Äù - not. <br><br><h3>  Undefined values </h3><br>  The btree access method indexes null values ‚Äã‚Äãand supports searching by conditions is null and is not null. <br><br>  Take the table of flights, in which there are uncertain values: <br><br> <code>demo=# create index on flights(actual_arrival); <br> CREATE INDEX <br> demo=# explain(costs off) select * from flights where actual_arrival is null; <br> QUERY PLAN <br> ------------------------------------------------------- <br> Bitmap Heap Scan on flights <br> Recheck Cond: (actual_arrival IS NULL) <br> -&gt;  Bitmap Index Scan on flights_actual_arrival_idx <br> Index Cond: (actual_arrival IS NULL) <br> (4 rows) <br></code> <br>  Indefinite values ‚Äã‚Äãare located on one or the other edge of the leaf nodes, depending on how the index was created (nulls first or nulls last).  This is important if the query is involved in sorting: the order in which the undefined values ‚Äã‚Äãare placed in the index and in the sort order must match for the index to be used. <br>  In this example, the orders are the same, so the index can be used: <br><br> <code>demo=# explain(costs off) select * from flights order by actual_arrival <strong>nulls last</strong> ; <br> QUERY PLAN <br> -------------------------------------------------------- <br> Index Scan using flights_actual_arrival_idx on flights <br> (1 row) <br></code> <br>  And here the orders are different, and the optimizer selects a table scan and sort: <br><br> <code>demo=# explain(costs off) select * from flights order by actual_arrival <strong>nulls first</strong> ; <br> QUERY PLAN <br> ---------------------------------------- <br> Sort <br> Sort Key: actual_arrival NULLS FIRST <br> -&gt;  Seq Scan on flights <br> (3 rows) <br></code> <br>  For an index to be used, you must create it so that the undefined values ‚Äã‚Äãgo at the beginning: <br><br> <code>demo=# create index flights_nulls_first_idx on flights(actual_arrival <strong>nulls first</strong> ); <br> CREATE INDEX <br> demo=# explain(costs off) select * from flights order by actual_arrival <strong>nulls first</strong> ; <br> QUERY PLAN <br> ----------------------------------------------------- <br> Index Scan using flights_nulls_first_idx on flights <br> (1 row) <br></code> <br>  The reason for such discrepancies, of course, is that undefined values ‚Äã‚Äãare not sortable: the result of comparing an undefined value with any other value is undefined: <br><br> <code>demo=# \pset null NULL <br> Null display is "NULL". <br> demo=# select null &lt; 42; <br> ?column? <br> ---------- <br> NULL <br> (1 row) <br></code> <br>  This goes against the essence of the B-tree and does not fit into the overall scheme.  But indefinite values ‚Äã‚Äãplay such an important role in databases that they have to make exceptions all the time. <br><br>  The fact that undefined values ‚Äã‚Äãare indexed is the ability to use an index, even if no conditions are imposed on the table at all (since the index is guaranteed to contain information about all the rows in the table).  This may make sense if the query needs to organize the data and the index provides the desired order.  Then the scheduler may prefer index access to save on separate sorting. <br><br><h2>  Properties </h2><br>  Let's look at the properties of the btree access method (requests <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">were cited earlier</a> ). <br><br> <code>amname |    name      | pg_indexam_has_property <br> --------+---------------+------------------------- <br> btree  | can_order    | t <br> btree  | can_unique    | t <br> btree  | can_multi_col | t <br> btree  | can_exclude  | t <br></code> <br>  As we have seen, a B-tree can organize data and maintains uniqueness ‚Äî and this is the only access method that provides such properties.  Multiple column indices are also allowed;  but other methods can do this (although not all).  We‚Äôll talk about support for the limitations of exclude, not without reason, next time. <br><br> <code>name      | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | t <br> index_scan    | t <br> bitmap_scan  | t <br> backward_scan | t <br></code> <br>  The b-tree access method supports both ways of getting values: both index scanning and bitmap scanning.  And, as we have seen, can bypass the tree as "forward", and in the opposite direction. <br><br> <code>name        | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc                | t <br> desc              | f <br> nulls_first        | f <br> nulls_last        | t <br> orderable          | t <br> distance_orderable | f <br> returnable        | t <br> search_array      | t <br> search_nulls      | t <br></code> <br>  The first four properties of this level talk about how the values ‚Äã‚Äãof this particular column are ordered.  In this example, the values ‚Äã‚Äãare sorted in ascending order (asc), and the undefined values ‚Äã‚Äãare at the end (nulls_last).  But, as we have seen, there may be other combinations. <br><br>  The search_array property indicates that the index supports such constructs: <br><br> <code>demo=# explain(costs off) <br> select * from aircrafts where aircraft_code in ('733','763','773'); <br> QUERY PLAN <br> ----------------------------------------------------------------- <br> Index Scan using aircrafts_pkey on aircrafts <br> Index Cond: (aircraft_code = ANY ('{733,763,773}'::bpchar[])) <br> (2 rows) <br></code> <br>  The returnable property indicates support for index scans only - which is logical, because indexed values ‚Äã‚Äãthemselves store indexed values ‚Äã‚Äã(as opposed to a hash index, for example).  It is appropriate to say a few words about the features of the covering indices based on the B-tree. <br><br><h3>  Unique indexes with extra columns </h3><br>  As we said <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">earlier</a> , the covering is an index that contains all the values ‚Äã‚Äãrequired in the query;  at the same time, reference to the table itself is no longer required (almost).  Including the cover may be a unique index. <br><br>  But suppose we want to add to the unique index the additional columns needed in the query.  The values ‚Äã‚Äãof the new composite key may not already be unique, and then you will need to have two indices for almost the same columns: one unique (to support integrity constraints) and one more non-unique (as a cover).  This, of course, is ineffective. <br><br>  In our company, Anastasia Lubennikova <a href="https://habrahabr.ru/users/lubennikovaav/" class="user_link">lubennikovaav</a> refined the btree method so that you can include additional - non-unique - columns in the unique index.  We hope that this patch will be accepted by the community and will be included in PostgreSQL, but this will not happen in version 10. While the patch is available in Postgres Pro Standard 9.5+, and this is how it looks. <br><br>  Take the booking table: <br><br> <code>demo=# \d bookings <br> Table "bookings.bookings" <br> Column    |          Type          | Modifiers <br> --------------+--------------------------+----------- <br> book_ref    | character(6)            | not null <br> book_date    | timestamp with time zone | not null <br> total_amount | numeric(10,2)            | not null <br> Indexes: <br> <strong>"bookings_pkey" PRIMARY KEY, btree (book_ref)</strong> <br> Referenced by: <br> TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref) <br></code> <br>  In it, the primary key (book_ref, reservation code) is supported by the usual btree-index.  Create a new unique index with an additional column: <br><br> <code>demo=# create unique index bookings_pkey2 on bookings(book_ref) <strong>include (book_date)</strong> ; <br> CREATE INDEX <br></code> <br>  Now we will replace the existing index with a new one (in a transaction so that all changes take effect at the same time): <br><br> <code>demo=# begin; <br> BEGIN <br> demo=# alter table bookings drop constraint bookings_pkey cascade; <br> NOTICE:  drop cascades to constraint tickets_book_ref_fkey on table tickets <br> ALTER TABLE <br> demo=# alter table bookings add primary key <strong>using index bookings_pkey2</strong> ; <br> ALTER TABLE <br> demo=# alter table tickets add foreign key (book_ref) references bookings (book_ref); <br> ALTER TABLE <br> demo=# commit; <br> COMMIT <br></code> <br>  Here's what happened: <br><br> <code>demo=# \d bookings <br> Table "bookings.bookings" <br> Column    |          Type          | Modifiers <br> --------------+--------------------------+----------- <br> book_ref    | character(6)            | not null <br> book_date    | timestamp with time zone | not null <br> total_amount | numeric(10,2)            | not null <br> Indexes: <br> <strong>"bookings_pkey2" PRIMARY KEY, btree (book_ref) INCLUDE (book_date)</strong> <br> Referenced by: <br> TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref) <br></code> <br>  Now the same index works as a unique one, and acts as a covering for such, for example, query: <br><br> <code>demo=# explain(costs off) <br> select book_ref, book_date from bookings where book_ref = '059FC4'; <br> QUERY PLAN <br> -------------------------------------------------- <br> Index Only Scan using bookings_pkey2 on bookings <br> Index Cond: (book_ref = '059FC4'::bpchar) <br> (2 rows) <br></code> <br><h2>  Create index </h2><br>  A well-known, but no less important fact from this: it is better to load a large amount of data into a table without indexes, and create the necessary indexes after.  This is not only faster, but the index itself will most likely get smaller. <br><br>  The fact is that when creating a btree-index, a more efficient procedure is used than progressively inserting values ‚Äã‚Äãinto a tree.  Roughly speaking, all the data in the table is sorted and sheet pages of the index are formed;  then internal pages are ‚Äúbuilt up‚Äù on this basis until the whole pyramid converges to the root. <br><br>  The speed of this process depends on the size of available RAM, which is limited by the maintenance_work_mem parameter, so an increase in the value can lead to acceleration.  In the case of unique indexes, in addition to maintenance_work_mem, memory is also allocated with the size of work_mem. <br><br><h2>  Comparison semantics </h2><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">Last time</a> we talked about the fact that PostgreSQL needs to know which hash functions to call for values ‚Äã‚Äãof different types, and that such a correspondence is stored in the hash access method.  In the same way, the system needs to understand how to order values ‚Äã‚Äã- it is necessary for sorting, grouping (sometimes), merge joins, etc. PostgreSQL does not bind to operator names (such as&gt;, &lt;, =), because the user may well define your data type and name the corresponding operators in some other way.  Instead, the names of the operators are determined by the family of operators associated with the btree access method. <br><br>  For example, here are some comparison operators used in the bool_ops family: <br><br> <code>postgres=# select  amop.amopopr::regoperator as opfamily_operator, <br> amop.amopstrategy <br> from    pg_am am, <br> pg_opfamily opf, <br> pg_amop amop <br> where    opf.opfmethod = am.oid <br> and      amop.amopfamily = opf.oid <br> and      am.amname = 'btree' <br> and      opf.opfname = 'bool_ops' <br> order by amopstrategy; <br> <br> opfamily_operator  | amopstrategy <br> ---------------------+-------------- <br> &lt;(boolean,boolean)  |            1 <br> &lt;=(boolean,boolean) |            2 <br> =(boolean,boolean)  |            3 <br> &gt;=(boolean,boolean) |            4 <br> &gt;(boolean,boolean)  |            5 <br> (5 rows) <br></code> <br>  Here we see five comparison operators, but, as was said, should not be guided by their names.  To understand which comparison is implemented by which operator, the concept of <em>strategy</em> is introduced <em>.</em>  For btree, five strategies are defined that define the semantics of operators: <br><ul><li>  1 - less; </li><li>  2 - less or equal; </li><li>  3 equals; </li><li>  4 - more or equal; </li><li>  5 - more. </li></ul><br>  Some families may contain several operators implementing one strategy.  For example, here are some operators in the integer_ops family for strategy 1: <br><br> <code>postgres=# select  amop.amopopr::regoperator as opfamily_operator <br> from    pg_am am, <br> pg_opfamily opf, <br> pg_amop amop <br> where    opf.opfmethod = am.oid <br> and      amop.amopfamily = opf.oid <br> and      am.amname = 'btree' <br> and      opf.opfname = 'integer_ops' <br> and      amop.amopstrategy = 1 <br> order by opfamily_operator; <br> <br> opfamily_operator <br> ---------------------- <br> &lt;(integer,bigint) <br> &lt;(smallint,smallint) <br> &lt;(integer,integer) <br> &lt;(bigint,bigint) <br> &lt;(bigint,integer) <br> &lt;(smallint,integer) <br> &lt;(integer,smallint) <br> &lt;(smallint,bigint) <br> &lt;(bigint,smallint) <br> (9 rows) <br></code> <br>  Due to this, the optimizer has the ability to compare the values ‚Äã‚Äãof different types belonging to the same family without resorting to casting. <br><br><h3>  Index support for new data type </h3><br>  The documentation has <a href="https://postgrespro.ru/docs/postgrespro/9.6/xindex.html">an example of</a> creating a new data type for complex numbers, and a class of operators for sorting values ‚Äã‚Äãof this type.  This example uses the C language, which is absolutely justified when speed is important.  But nothing prevents you from doing the same experiment on pure SQL, just to try and better understand the semantics of the comparison. <br><br>  Create a new composite type with two fields: the real and imaginary parts. <br><br> <code>postgres=# create type complex as (re float, im float); <br> CREATE TYPE <br></code> <br>  You can create a table with a new type field and add some values ‚Äã‚Äãto it: <br><br> <code>postgres=# create table numbers(x complex); <br> CREATE TABLE <br> postgres=# insert into numbers values ((0.0, 10.0)), ((1.0, 3.0)), ((1.0, 1.0)); <br> INSERT 0 3 <br></code> <br>  Now the question arises: how to order complex numbers if, in the mathematical sense, the order relation is not defined for them? <br><br>  As it turns out, comparison operations are already defined for us: <br><br> <code>postgres=# select * from numbers order by x; <br> x <br> -------- <br> (0,10) <br> (1,1) <br> (1,3) <br> (3 rows) <br></code> <br>  By default, the composite type is sorted by component: first, the first fields are compared, then the second, and so on, just like text strings are compared character by character.  But you can define a different order.  For example, complex numbers can be considered as vectors and ordered by modulo (by length), which is calculated as the root of the sum of squares of coordinates (Pythagorean theorem).  To determine this order, create an auxiliary function to calculate the module: <br><br> <code>postgres=# create function modulus(a complex) returns float as $$ <br> select sqrt(a.re*a.re + a.im*a.im); <br> $$ immutable language sql; <br> CREATE FUNCTION <br></code> <br>  And with its help we will methodically define the functions for all five comparison operations: <br><br> <code>postgres=# create function complex_lt(a complex, b complex) returns boolean as $$ <br> select modulus(a) &lt; modulus(b); <br> $$ immutable language sql; <br> CREATE FUNCTION <br> postgres=# create function complex_le(a complex, b complex) returns boolean as $$ <br> select modulus(a) &lt;= modulus(b); <br> $$ immutable language sql; <br> CREATE FUNCTION <br> postgres=# create function complex_eq(a complex, b complex) returns boolean as $$ <br> select modulus(a) = modulus(b); <br> $$ immutable language sql; <br> CREATE FUNCTION <br> postgres=# create function complex_ge(a complex, b complex) returns boolean as $$ <br> select modulus(a) &gt;= modulus(b); <br> $$ immutable language sql; <br> CREATE FUNCTION <br> postgres=# create function complex_gt(a complex, b complex) returns boolean as $$ <br> select modulus(a) &gt; modulus(b); <br> $$ immutable language sql; <br> CREATE FUNCTION <br></code> <br>  And create the appropriate operators.  To show that they are not required to be called "&gt;", "&lt;", and so on, we give them "strange" names. <br><br> <code>postgres=# create operator #&lt;#(leftarg=complex, rightarg=complex, procedure=complex_lt); <br> CREATE OPERATOR <br> postgres=# create operator #&lt;=#(leftarg=complex, rightarg=complex, procedure=complex_le); <br> CREATE OPERATOR <br> postgres=# create operator #=#(leftarg=complex, rightarg=complex, procedure=complex_eq); <br> CREATE OPERATOR <br> postgres=# create operator #&gt;=#(leftarg=complex, rightarg=complex, procedure=complex_ge); <br> CREATE OPERATOR <br> postgres=# create operator #&gt;#(leftarg=complex, rightarg=complex, procedure=complex_gt); <br> CREATE OPERATOR <br></code> <br>  At this stage, you can already compare the numbers: <br><br> <code>postgres=# select (1.0,1.0)::complex #&lt;# (1.0,3.0)::complex; <br> ?column? <br> ---------- <br> t <br> (1 row) <br></code> <br>  In addition to the five operators, the btree access method requires you to define another (redundant but convenient) function: it must return -1, 0 or 1 if the first value is less, equal or greater than the second.  Such an auxiliary function is called <em>support;</em>  other access methods may require the creation of other support functions. <br><br> <code>postgres=# create function complex_cmp(a complex, b complex) returns integer as $$ <br> select case when modulus(a) &lt; modulus(b) then -1 <br> when modulus(a) &gt; modulus(b) then 1 <br> else 0 <br> end; <br> $$ language sql; <br> CREATE FUNCTION <br></code> <br>  Now we are ready to create a class of operators (and the family of the same name will be created automatically): <br><br> <code>postgresx=# create operator class complex_ops <br> default for type complex <br> using btree as <br> operator 1 #&lt;#, <br> operator 2 #&lt;=#, <br> operator 3 #=#, <br> operator 4 #&gt;=#, <br> operator 5 #&gt;#, <br> function 1 complex_cmp(complex,complex); <br> CREATE OPERATOR CLASS <br></code> <br>  Now sorting works as we wanted: <br><br> <code>postgres=# select * from numbers order by x; <br> x <br> -------- <br> (1,1) <br> (1,3) <br> (0,10) <br> (3 rows) <br></code> <br>  And, of course, it will be supported by the btree index. <br><br>  For the sake of completeness, the reference functions can be seen with the following query: <br><br> <code>postgres=# select amp.amprocnum, <br> amp.amproc, <br> amp.amproclefttype::regtype, <br> amp.amprocrighttype::regtype <br> from  pg_opfamily opf, <br> pg_am am, <br> pg_amproc amp <br> where  opf.opfname = 'complex_ops' <br> and    opf.opfmethod = am.oid <br> and    am.amname = 'btree' <br> and    amp.amprocfamily = opf.oid; <br> <br> amprocnum |  amproc    | amproclefttype | amprocrighttype <br> -----------+-------------+----------------+----------------- <br> 1 | complex_cmp | complex        | complex <br> (1 row) <br></code> <br><h2>  Insides </h2><br>  The internal structure of a B-tree can be studied using the pageinspect extension. <br><br> <code>demo=# create extension pageinspect; <br> CREATE EXTENSION <br></code> <br>  Index index: <br><br> <code>demo=# select * from bt_metap('ticket_flights_pkey'); <br> magic  | version | root | level | fastroot | fastlevel <br> --------+---------+------+-------+----------+----------- <br> 340322 |      2 |  164 |    2 |      164 |        2 <br> (1 row) <br></code> <br>  The most interesting thing here is the depth of the index (level): placing the index in two columns for a table with a million rows required only 2 levels (not counting the root). <br><br>  Statistical information about block 164 (root): <br><br> <code>demo=# select type, live_items, dead_items, avg_item_size, page_size, free_size <br> from bt_page_stats('ticket_flights_pkey',164); <br> type | live_items | dead_items | avg_item_size | page_size | free_size <br> ------+------------+------------+---------------+-----------+----------- <br> r    |        33 |          0 |            31 |      8192 |      6984 <br> (1 row) <br></code> <br>  And the data itself in the block (in the data field, which is sacrificed for the width of the screen, is the value of the index key in binary form): <br><br> <code>demo=# select itemoffset, ctid, itemlen, left(data,56) as data <br> from bt_page_items('ticket_flights_pkey',164) limit 5; <br> itemoffset |  ctid  | itemlen |                          data <br> ------------+---------+---------+---------------------------------------------------------- <br> 1 | (3,1)  |      8 | <br> 2 | (163,1) |      32 | 1d 30 30 30 35 34 33 32 33 30 35 37 37 31 00 00 ff 5f 00 <br> 3 | (323,1) |      32 | 1d 30 30 30 35 34 33 32 34 32 33 36 36 32 00 00 4f 78 00 <br> 4 | (482,1) |      32 | 1d 30 30 30 35 34 33 32 35 33 30 38 39 33 00 00 4d 1e 00 <br> 5 | (641,1) |      32 | 1d 30 30 30 35 34 33 32 36 35 35 37 38 35 00 00 2b 09 00 <br> (5 rows) <br></code> <br>  The first element is technical in nature and sets the upper limit of the key value of all elements of the block (implementation detail, about which we did not speak), and the actual data begins with the second element.  It can be seen that the block 163 is the leftmost daughter node, then block 323 and so on.  Which, in turn, can also be studied using the same functions. <br><br>  Further, by a good tradition, it makes sense to read the documentation, the <a href="https://git.postgresql.org/gitweb/%3Fp%3Dpostgresql.git%3Ba%3Dblob%3Bf%3Dsrc/backend/access/nbtree/README%3Bhb%3DHEAD">README</a> and the source code. <br><br>  And one more potentially useful extension: <a href="https://www.postgresql.org/docs/10/static/amcheck.html">amcheck</a> , which will be part of PostgreSQL 10, and for earlier versions you can take it on <a href="https://github.com/petergeoghegan/amcheck">github</a> .  This extension checks the logical consistency of data in B-trees and allows for early detection of damage. <br><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">Continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/330544/">https://habr.com/ru/post/330544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330526/index.html">FabricPool - saving technology for All Flash repositories</a></li>
<li><a href="../330530/index.html">Fast data recovery. How will LRC help us?</a></li>
<li><a href="../330532/index.html">iOS 11: what will be the video in the App Store and how to use it</a></li>
<li><a href="../330536/index.html">We generate arbitrary sequences on the findings of the Raspberry Pi board.</a></li>
<li><a href="../330538/index.html">Innovation Summit: ‚ÄúInnovation at every level‚Äù</a></li>
<li><a href="../330546/index.html">VDS for all the gift and let no one go offended</a></li>
<li><a href="../330550/index.html">What is Zimbra</a></li>
<li><a href="../330552/index.html">What the! do you still want the law? I have them! We block VPN</a></li>
<li><a href="../330556/index.html">Self-education and Hello, world: the problem of introductory courses and not only</a></li>
<li><a href="../330558/index.html">How to get an offer in Badoo on the day of the interview. Part Two, for PHP developer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>