<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js tutorial, part 6: event loop, call stack, timers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, in the sixth part of the translation guide for Node.js, we will talk about the event loop, the call stack, the process.nextTick() function, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js tutorial, part 6: event loop, call stack, timers</h1><div class="post__text post__text-html js-mediator-article"> Today, in the sixth part of the translation guide for Node.js, we will talk about the event loop, the call stack, the <code>process.nextTick()</code> function, and timers.  Understanding these and other Node.js mechanisms is one of the foundations for successful application development for this platform. <br><br> <a href="https://habr.com/company/ruvds/blog/424553/"><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[We advise to read] Other parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habr.com/company/ruvds/blog/422893/">General Information and Getting Started</a> <br>  Part 2: <a href="https://habr.com/company/ruvds/blog/423153/">JavaScript, V8, some design tricks</a> <br>  Part 3: <a href="https://habr.com/company/ruvds/blog/423701/">Hosting, REPL, work with the console, modules</a> <br>  Part 4: <a href="https://habr.com/company/ruvds/blog/423703/">npm, package.json and package-lock.json files</a> <br>  Part 5: <a href="https://habr.com/company/ruvds/blog/423705/">npm and npx</a> <br>  Part 6: <a href="https://habr.com/company/ruvds/blog/424553/">event loop, call stack, timers</a> <br>  Part 7: <a href="https://habr.com/company/ruvds/blog/424555/">Asynchronous Programming</a> <br>  Part 8: <a href="https://habr.com/company/ruvds/blog/424557/">Node.js Guide, part 8: HTTP and WebSocket protocols</a> <br>  Part 9: <a href="https://habr.com/company/ruvds/blog/424969/">Node.js Guide, part 9: working with the file system</a> <br>  Part 10: <a href="https://habr.com/company/ruvds/blog/425667/">Node.js Guide, part 10: standard modules, streams, databases, NODE_ENV</a> <br>  <a href="https://habr.com/company/ruvds/blog/428576/">Full PDF Node.js Manual</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Event cycle</font> </h2><br>  If you want to understand how the JavaScript code is executed, then the Event Loop is one of the most important concepts that you need to understand.  Here we will talk about how JavaScript works in a single-threaded mode, and how the asynchronous functions are handled. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For many years I have been developing in JavaScript, but I cannot say that I fully understood how everything functions, so to speak, ‚Äúunder the hood‚Äù.  The programmer may not know about the intricacies of the internal subsystems of the environment in which he works.  But it is usually useful to have at least a general idea of ‚Äã‚Äãsuch things. <br><br>  The JavaScript code you write is executed in single-threaded mode.  At a time, only one action is performed.  This restriction is, in fact, quite useful.  This greatly simplifies the way programs work, eliminating the need for programmers to solve problems specific to multi-threaded environments. <br><br>  In fact, the JS programmer needs to pay attention only to what actions his code performs, and at the same time try to avoid situations that cause blocking of the main thread.  For example, making network calls in synchronous mode and endless <a href="https://flaviocopes.com/javascript-loops/">loops</a> . <br><br>  Usually in browsers, each open tab has its own event loop.  This allows you to perform the code of each page in an isolated environment and avoid situations where a certain page, in the code of which there is an infinite loop or heavy calculations are performed, can ‚Äúhang‚Äù the entire browser.  The browser supports the operation of a set of simultaneously existing event cycles, used, for example, to handle calls to various APIs.  In addition, its own event loop is used to support <a href="https://flaviocopes.com/web-workers/">web workers</a> . <br><br>  The most important thing that a JavaScript programmer needs to constantly remember is that his code uses its own event loop, so the code must be written so that this event loop does not block. <br><br><h2>  <font color="#3AC1EF">Locking event loop</font> </h2><br>  Any JavaScript code that takes too much time to execute, that is, code that does not return control to an event loop for too long, blocks the execution of any other page code.  This even leads to the blocking of user interface event handling, which is expressed in the fact that the user cannot interact with the page elements and work with it normally, for example, scrolling. <br><br>  Virtually all the basic mechanisms for providing I / O to JavaScript are non-blocking.  This applies to both the browser and Node.js.  Among such mechanisms, for example, are the tools for performing network requests, used in both client and server environments, and tools for working with Node.js files.  There are synchronous ways to perform such operations, but they are used only in special cases.  That is why in JavaScript, traditional callbacks and newer mechanisms ‚Äî promises and async / await constructions ‚Äî are of paramount importance. <br><br><h2>  <font color="#3AC1EF">Call stack</font> </h2><br>  Call Stack in JavaScript is based on the LIFO principle (Last In, First Out - last entered, first out).  The event loop constantly checks the call stack to see if it has a function to perform.  If, when executing the code, it encounters a call to some function, information about it is added to the call stack and the function is executed. <br><br>  If even before you were not interested in the concept of ‚Äúcall stack‚Äù, then you, if you met with error messages that include the stack trace, already imagine what it looks like.  Here, for example, how similar looks in the browser. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e6f/b9d/9fe/e6fb9d9fe2d481ab7178cb5bcb022454.png"></div><br>  <i><font color="#999999">Browser error message</font></i> <br><br>  The browser, when an error occurs, reports a sequence of function calls, information about which is stored in the call stack, which allows detecting the source of the error and understanding which function calls led to the current situation. <br><br>  Now that we have talked in general about the event loop and the call stack, consider an example illustrating the execution of a code snippet, and how this process looks in terms of the event loop and the call stack. <br><br><h2>  <font color="#3AC1EF">Event loop and call stack</font> </h2><br>  Here is the code with which we will experiment: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) bar() baz() } foo()</code> </pre> <br>  If this code is executed, the following will get to the console: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> bar baz</code> </pre> <br>  This result is quite expected.  Namely, when this code is run, the function <code>foo()</code> first called.  Inside this function, we first call the function <code>bar()</code> , and then <code>baz()</code> .  In this case, the call stack during the execution of this code undergoes changes, as shown in the following figure. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/6ea/763/c2e6ea7631946a6d0f141416fbdba077.png"></div><br>  <i><font color="#999999">Changing the state of the call stack when executing the code being examined</font></i> <br><br>  The event loop, at each iteration, checks if there is anything in the call stack, and if so, executes it until the call stack is empty. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Event loop iterations</font></i> <br><br><h2>  <font color="#3AC1EF">Queuing a function</font> </h2><br>  The above example looks quite normal, there is nothing special about it: JavaScript finds the code to be executed and executes it in order.  Let's talk about how to postpone the function until the call stack is cleared.  In order to do this, use this structure: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {}), <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  It allows you to execute the function passed to the <code>setTimeout()</code> function after all the other functions called in the program code are executed. <br><br>  Consider an example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) baz() } foo()</code> </pre> <br>  What this code displays might seem unexpected: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">foo</span></span> baz bar</code> </pre> <br>  When we run this example, the function <code>foo()</code> is called first.  In it, we call <code>setTimeout()</code> , passing this function as the first argument, <code>bar</code> .  Passing <code>0</code> as the second argument, we inform the system that this function should be executed as soon as possible.  Then we call the <code>baz()</code> function. <br><br>  This is what the call stack will now look like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a23/8fd/d45/a238fdd4515c24e61f2e297f3c5b9d17.png"></div><br>  <i><font color="#999999">Changing the state of the call stack during the execution of the code</font></i> <br><br>  Here is the order in which the functions in our program will now be performed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f5/531/45f/0f553145fcf17577ef06f038a33f9dff.png"></div><br>  <i><font color="#999999">Event loop iterations</font></i> <br><br>  Why does everything happen that way? <br><br><h2>  <font color="#3AC1EF">Event queue</font> </h2><br>  When the <code>setTimeout()</code> function is called, the browser or the Node.js platform starts a timer.  After the timer fires (in our case it happens immediately, since we set it to 0), the callback function passed to <code>setTimeout()</code> is put in the Event Queue. <br><br>  In the event queue, if we are talking about the browser, there are also user-initiated events ‚Äî events triggered by mouse clicks on the page elements, events triggered when entering data from the keyboard.  Immediately there are DOM <code>onload</code> handlers like <code>onload</code> , functions that are called when receiving responses to asynchronous requests for loading data.  Here they are waiting for their turn to be processed. <br><br>  The event loop gives priority to what is on the call stack.  First, it performs everything that it manages to find in the stack, and after the stack is empty, it proceeds to process what is in the event queue. <br><br>  We do not need to wait until the function, like <code>setTimeout()</code> , completes, since such functions are provided by the browser and they use their own threads.  So, for example, by setting the timer for 2 seconds with the <code>setTimeout()</code> function, you should not, having stopped the execution of another code, wait for these 2 seconds, since the timer runs outside of your code. <br><br><h2>  <font color="#3AC1EF">ES6 Job Queue</font> </h2><br>  In ECMAScript 2015 (ES6), the concept of a job queue (Job Queue) was introduced, which is used by promises (they also appeared in ES6).  Thanks to the job queue, the result of the asynchronous function can be used as quickly as possible, without having to wait for the call stack to be cleared. <br><br>  If the promise is allowed before the end of the current function, the corresponding code will be executed immediately after the current function completes. <br><br>  I found an interesting analogy for what we are talking about.  This can be compared to a roller coaster in an amusement park.  After you ride the hill and want to do it again, you take a ticket and stand at the tail of the queue.  This is how the event queue works.  But the job queue looks different.  This concept is similar to the discount ticket, which gives you the right to make the next trip immediately after you have completed the previous one. <br><br>  Consider the following example: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> baz = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'baz'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>) setTimeout(bar, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span>   resolve(<span class="hljs-string"><span class="hljs-string">'should be right after baz, before bar'</span></span>) ).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resolve)) baz() } foo()</code> </pre> <br>  Here is what will be displayed after its execution: <br><br><pre> <code class="hljs pgsql">foo baz should be right <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> baz, <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> bar bar</code> </pre> <br>  What can be seen here demonstrates the serious difference between promises (and the async / await design that is based on them) and traditional asynchronous functions, which are organized by <code>setTimeout()</code> or other APIs of the platform used. <br><br><h2>  <font color="#3AC1EF">process.nextTick ()</font> </h2><br>  The <code>process.nextTick()</code> method interacts in a special way with the event loop.  Tick ‚Äã‚Äã(tick) call one full pass of the event cycle.  By passing the function to the <code>process.nextTick()</code> method, we inform the system that this function must be called after the current iteration of the event loop is completed, before the next one begins.  Using this method looks like this: <br><br><pre> <code class="hljs javascript">process.nextTick(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// -  })</span></span></code> </pre> <br>  Suppose the event loop is busy executing the code of the current function.  When this operation completes, the JavaScript engine will execute all functions passed to <code>process.nextTick()</code> during the execution of the previous operation.  Using this mechanism, we strive to ensure that a certain function would be executed asynchronously (after the current function), but as soon as possible, without putting it in a queue. <br><br>  For example, if you use the <code>setTimeout(() =&gt; {}, 0)</code> construct, the function will be executed at the next iteration of the event loop, that is, much later than when using <code>process.nextTick()</code> in the same situation.  This method should be used when you need to ensure that some code is executed at the very beginning of the next iteration of the event loop. <br><br><h2>  <font color="#3AC1EF">setImmediate ()</font> </h2><br>  Another function provided by Node.js for asynchronous code execution is <code>setImmediate()</code> .  Here's how to use it: <br><br><pre> <code class="hljs javascript">setImmediate(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   })</span></span></code> </pre> <br>  The callback function passed to <code>setImmediate()</code> will be executed on the next iteration of the event loop. <br><br>  How <code>setImmediate()</code> differ from <code>setTimeout(() =&gt; {}, 0)</code> (that is, from the timer that should work as soon as possible) and from <code>process.nextTick()</code> ? <br><br>  The function passed to <code>process.nextTick()</code> will run after the current iteration of the event loop is completed.  That is, such a function will always be executed before a function that is scheduled to be executed using <code>setTimeout()</code> or <code>setImmediate()</code> . <br><br>  The call to the <code>setTimeout()</code> function with a 0 ms delay set is very similar to the <code>setImmediate()</code> call.  The order of execution of the functions transferred to them depends on various factors, but in both cases callbacks will be called up at the next iteration of the event loop. <br><br><h2>  <font color="#3AC1EF">Timers</font> </h2><br>  Above, we have already talked about the <code>setTimeout()</code> function, which allows you to schedule calls to the callbacks passed to it.  Let us spend some time describing its features in more detail and consider another function, <code>setInterval()</code> , which is similar to it.  In Node.js, the functions for working with timers are included in the <a href="https://nodejs.org/api/timers.html">timer</a> module, but they can be used without connecting this module in the code, since they are global. <br><br><h3>  <font color="#3AC1EF">SetsetTimeout () function</font> </h3><br>  Recall that when you call the <code>setTimeout()</code> function, it is passed a callback and time, in milliseconds, after which a callback will be called.  Consider an example: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-number"><span class="hljs-number">50</span></span>  }, <span class="hljs-number"><span class="hljs-number">50</span></span>)</code> </pre> <br>  Here we pass <code>setTimeout()</code> new function, which is immediately described, but here you can use the existing function by passing <code>setTimeout()</code> its name and a set of parameters to start it.  It looks like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">firstParam, secondParam</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   } //   2  setTimeout(myFunction, 2000, firstParam, secondParam)</span></span></code> </pre> <br>  The <code>setTimeout()</code> function returns a timer identifier.  Usually it is not used, but it can be saved, and, if necessary, delete the timer, if the scheduled execution of the callback is no longer necessary: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> id = setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      2  }, 2000) //  ,       clearTimeout(id)</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Zero delay</font> </h3><br>  In the previous sections, we used <code>setTimeout()</code> , passing to it as a time after which we had to call a callback, <code>0</code> .  This meant that the callback would be called as soon as possible, but after the completion of the current function: <br><br><pre> <code class="hljs coffeescript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'after '</span></span>) }, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' before '</span></span>)</code> </pre> <br>  This code will output the following: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">after</span></span></code> </pre> <br>  This technique is especially useful in situations where, when performing heavy computational tasks, I would not want to block the main thread, allowing other functions to be performed, breaking up similar tasks into several stages, arranged as <code>setTimeout()</code> calls. <br><br>  If we recall the aforementioned <code>setImmediate()</code> function, then in Node.js it is standard, which is not the case with browsers (it is <a href="https://caniuse.com/">implemented</a> in IE and Edge, not in others). <br><br><h3>  <font color="#3AC1EF">SetsetInterval () function</font> </h3><br>  The <code>setInterval()</code> function is similar to <code>setTimeout()</code> , but there are differences between them.  Instead of once executing the callback passed to it, <code>setInterval()</code> will periodically, at a specified interval, call this callback.  Ideally, this will continue until the programmer explicitly stops this process.  Here is how to use this feature: <br><br><pre> <code class="hljs javascript">setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  The callback passed to the function shown above will be called every 2 seconds.  In order to provide the possibility of stopping this process, you need to get the timer identifier returned by <code>setInterval()</code> and use the <code>clearInterval()</code> command: <br><br><pre> <code class="hljs lisp">const id = setInterval(() =&gt; { //   <span class="hljs-number"><span class="hljs-number">2</span></span>  }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) clearInterval(<span class="hljs-name"><span class="hljs-name">id</span></span>)</code> </pre> <br>  A common technique is to call <code>clearInterval()</code> inside a callback passed to <code>setInterval()</code> when certain conditions are met.  For example, the following code will be run periodically until the <code>App.somethingIWait</code> property takes the value of <code>arrived</code> : <br><br><pre> <code class="hljs lisp">const interval = setInterval(<span class="hljs-name"><span class="hljs-name">function</span></span>() { if (<span class="hljs-name"><span class="hljs-name">App</span></span>.somethingIWait === 'arrived') {   clearInterval(<span class="hljs-name"><span class="hljs-name">interval</span></span>)   //    -  ,   -    } }, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçRecursive setting setTimeout ()</font> </h3><br>  The <code>setInterval()</code> function will call the callback passed to it every <code>n</code> milliseconds, not caring if the callback has completed after its previous call. <br><br>  If each call to this callback always requires the same time, less than <code>n</code> , then there are no problems here. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f0/66d/192/2f066d192a047c90e90f45d69a66002e.png"></div><br>  <i><font color="#999999">Periodically called callback, each session of which takes the same time, within the interval between calls</font></i> <br><br>  It is possible that each time it takes a callback, it takes a different time, which is still less than <code>n</code> .  If, for example, we are talking about performing some network operations, then this situation is quite expected. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/73c/7e7/fb2/73c7e7fb2a0a687c0f84707e5f1e13e1.png"></div><br>  <i><font color="#999999">Periodically called callback, each session of which takes a different time, within the interval between calls</font></i> <br><br>  When using <code>setInterval()</code> , a situation may arise when the execution of a callback takes time longer than <code>n</code> , which leads to the fact that the next call is made before the completion of the previous one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41a/007/220/41a00722099daaf6012792aeeb1ccd93.png"></div><br>  <i><font color="#999999">Periodically called callback, each session of which takes a different time, which sometimes does not fit into the interval between calls</font></i> <br><br>  In order to avoid this situation, you can use the technique of recursive timer setting using <code>setTimeout()</code> .  The point is that the next callback call is scheduled after the completion of its previous call: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    setTimeout(myFunction, 1000) } setTimeout( myFunction() }, 1000)</span></span></code> </pre> <br>  With this approach, you can implement the following scenario: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3dc/4ec/442/3dc4ec4427764f48e8d68e00f409cebd.png"></div><br>  <i><font color="#999999">A recursive setTimeout () call to schedule callback execution.</font></i> <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we talked about the internal mechanisms of Node.js, such as the cycle of events, the call stack, and discussed working with timers that allow you to schedule code execution.  Next time we delve into the topic of asynchronous programming. <br><br>  <b>Dear readers!</b>  Have you encountered situations when you had to use process.nextTick ()? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/424553/">https://habr.com/ru/post/424553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424539/index.html">Java 11: New in String</a></li>
<li><a href="../424541/index.html">The UGJ-2018 story fiasco: how to make a game that nobody would like (do not do that!)</a></li>
<li><a href="../424543/index.html">Java 11 / JDK 11: General Availability</a></li>
<li><a href="../424545/index.html">How to understand that planning a sprint went well?</a></li>
<li><a href="../424551/index.html">Warm and lamp: five balalaika about magnetic recording technology</a></li>
<li><a href="../424555/index.html">Node.js tutorial, part 7: asynchronous programming</a></li>
<li><a href="../424557/index.html">Node.js Part 8 Tutorial: HTTP and WebSocket Protocols</a></li>
<li><a href="../424559/index.html">Big Data resistance 1 or elusive Joe. Internet anonymity, anti-detection, anti-tracking for anti-you and anti-us</a></li>
<li><a href="../424561/index.html">Russian program to create a global satellite Internet network may lose a single investor</a></li>
<li><a href="../424563/index.html">Beeline sends details of conversations to strangers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>