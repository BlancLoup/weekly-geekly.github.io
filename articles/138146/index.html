<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Merge sort without using additional memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I thought for a long time that it was impossible to write a merge array sorting so that it did not use additional memory, but so that the operation ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Merge sort without using additional memory</h1><div class="post__text post__text-html js-mediator-article">  I thought for a long time that it was impossible to write a merge array sorting so that it did not use additional memory, but so that the operation time remained equal to O (N * log (N)).  Therefore, when <a href="http://habrahabr.ru/users/karlicos/" class="user_link">karlicos</a> shared a <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3DC%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0_%25D1%2581%25D0%25BB%25D0%25B8%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC_%25D1%2581_%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5%25D0%25BC_O(1)_%25D0%25B4%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B9_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">link</a> to the description of such an algorithm, it interested me.  A search on the network showed that people know about the algorithm, but no one is particularly interested in it, it is considered difficult and ineffective.  Although, maybe, they mean some kind of ‚Äústable‚Äù version of this algorithm, but nobody still needs an unstable one. <br><br>  But I still decided to try. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Merge in linear time </h2><br><br>  The idea of ‚Äã‚Äãthe algorithm is quite simple.  All we need is to merge the two ordered parts of the same array in <i>O (N)</i> comparisons and exchanges of elements.  This is done like this: <br><ul><li>  Choose the number <i>S‚âàsqrt (N)</i> </li><li>  Divide the array into <i>K</i> pieces of length <i>S.</i>  The rest, not caught in any of the pieces, until we touch </li><li>  The piece in which the boundary between the ordered fragments fell is changed with the last piece.  This will be our clipboard. </li><li>  Sort <i>K-1 the</i> remaining piece in ascending order of the first elements.  Here we need to use an algorithm that is linear in the number of exchanges.  Suitable sorting by selecting the minimum element. </li><li>  We notice two important things.  First, if we have two orders of sorted fragments of length <i>A</i> and <i>B</i> and an exchange buffer whose length is not less than <i>min (A, B)</i> , then we can merge these fragments by spending no more than <i>A + B</i> comparisons and <i>A + B + min (A, B)</i> exchanges.  The order of elements in the clipboard may change.  Secondly, when sorting the array obtained at the previous step from <i>(K-1) * S</i> elements, each element can move no more than <i>S</i> positions to the left, i.e.  will never be left of the previous "piece". </li><li>  Using the clipboard, we sequentially merge pairs of adjacent pieces - <i>[0..S-1]</i> and <i>[S, 2 * S-1]</i> , then <i>[S, 2 * S-1]</i> and <i>[2 * S, 3 * S-1 ]</i> , etc.  From the previous paragraph it follows that as a result we get a sorted array of <i>M = S * (K-1)</i> elements </li><li>  Sort the last <i>R = NM</i> elements of the original array (clipboard + balance) by any algorithm.  They recommend some kind of quadratic algorithm (for the purity of the idea, to avoid recursion), but from a practical point of view, the recursive sorting call is not worse. </li><li>  Merge the sorted array fragments <i>[R..NR-1]</i> and <i>[NR..N-1]</i> , using the fragment <i>[0..R-1]</i> as the clipboard </li><li>  We are looking for an error in the algorithm at the junction of the previous and next items.  If you do not find it, it is explained at the end of the article. </li><li>  Sort the clipboard: R lower array elements were and remain in it, and after sorting they will be in place </li></ul><br>  The description is quite long, but you can understand.  The number of exchanges per merger is about <i>5 * N</i> , the number of comparisons is about <i>6 * N</i> (it depends on the length of the remainder).  For complete sorting, these numbers are multiplied by <i>log (N)</i> , and a lot is obtained. <br><br><h2>  Adaptation algorithm for sorting </h2><br><br>  To make it easier for us, and the algorithm worked more efficiently, we note the following. <br><ul><li>  All the fussing with the clipboard and its subsequent merging with the array is needed only if there really wasn‚Äôt any free space in the array.  If we merge fragments of length <i>A</i> and <i>B</i> , and after them there are at least <i>S</i> cells of unsorted space, then it is enough for us to break the arrays into pieces, sort them out and merge them.  This will work especially well if <i>S = A = B.</i> </li><li>  We must try to ensure that the length of the remainder is zero, and the boundary between the sorted fragments falls exactly on the boundary of pieces of length <i>S.</i>  The easiest way to achieve this is if you choose S to be equal to a power of two, and force <i>A</i> and <i>B</i> to be divided into it. </li><li>  Sorting pieces of arrays requires <i>((A + B) / S) 2/2</i> comparisons.  Subsequent sorting of the clipboard is <i>O (S * log (S))</i> comparisons.  Therefore, it is not necessary to choose <i>S</i> close to <i>sqrt (N)</i> , you can increase it, for example, to <i>N / log (N)</i> . </li></ul><br><br>  Armed with these thoughts, we are writing a program (for now only for an array of type int []).  First we sort and merge fragments with lengths equal to the power of two, and we go strictly from left to right so that there is free space to the right.  When we reach the clipboard, merge the unfused, but sorted fragments.  Sort the clipboard + balance, merge the result with the rest of the array, sort the newly created clipboard - and the array is sorted.  It turns out the <a href="">algorithm is about a hundred lines</a> .  Truth told, that he bulky.  What about efficiency? <br><br>  Honestly, I hoped that he would lose the standard qsort no more than 3 times.  But the comparison in real conditions (on arrays up to 10 <sup>8</sup> in length) showed that, according to the number of comparisons, the algorithm <i>wins</i> qsort by about 10%, and by the total operating time - from 1.2 to 1.3 times!  Perhaps this is due to the fact that the icmp function (comparing two integers at given addresses) is substituted inline - but the code that is inserted turns out pretty awful (I checked). <br><br>  In general, everything is not as bad as they said. <br><br>  And what kind of error was in the description of the algorithm?  The fact is that if an element that, after sorting, must be in one of the first <i>R</i> positions, got into the clipboard or the rest, it will not get into the place.  To correct, you have to keep track of what place the element that was in the cell with the index <i>R</i> came to during the last merge, and make the initial sort of the initial fragment to this point (its length can be somewhat larger than <i>R</i> ). <br><br>  <b>UPD:</b> The algorithm, as I described it here, revealed another error related to "sorting pieces of an array."  If there are many identical elements in the source array, different pieces from the same fragment of the array can have the same first elements.  And if the order in which these pieces go when sorting is disturbed, the result of sorting the entire array may turn out to be incorrect. <br><br>  To combat this effect, when sorting, it is necessary to compare the first elements of the pieces, and if they are the same, compare the last elements.  And sort the pieces lexicographically by these pairs of elements. </div><p>Source: <a href="https://habr.com/ru/post/138146/">https://habr.com/ru/post/138146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138137/index.html">Kazakhstan received the Cyrillic domain ".“ö–ê–ó"</a></li>
<li><a href="../138139/index.html">Knowledge reuse</a></li>
<li><a href="../138141/index.html">Competition for the best name of the project on video surveillance of the presidential elections in Russia</a></li>
<li><a href="../138144/index.html">Console Player .wav for pc-speaker in Linux</a></li>
<li><a href="../138145/index.html">Automate vacation</a></li>
<li><a href="../138147/index.html">Firefox developers have published a roadmap for 2012</a></li>
<li><a href="../138150/index.html">Macros with a variable number of parameters</a></li>
<li><a href="../138151/index.html">How do you feel about the eval function in javascript?</a></li>
<li><a href="../138155/index.html">TOP 10 services provided by freelancers</a></li>
<li><a href="../138156/index.html">Controller for home brewery Mega Brewery. Part II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>