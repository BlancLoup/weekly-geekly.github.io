<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functional programming: there are too many ceremonies in Java and C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have probably heard about functional programming, some have tried to write their own Hello World, and some have even started their own ‚Äúfunctiona...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functional programming: there are too many ceremonies in Java and C #</h1><div class="post__text post__text-html js-mediator-article">  Many have probably heard about functional programming, some have tried to write their own Hello World, and some have even started their own ‚Äúfunctional‚Äù pet-project.  But how many people used functional languages ‚Äã‚Äãin production?  What are the advantages and disadvantages of php?  Does the functional programming paradigm justify the expectations of developers?  These and many other questions were answered by a person who discovered the advantages of a functional approach after 20 years of OOP development. <br><br> <a href="https://habrahabr.ru/p/328042/"><img src="https://habrastorage.org/web/ade/204/681/ade2046811be4b3db1af85e503cce647.jpg"></a> <br><a name="habracut"></a><br>  <i>Vagif Abilov - developer at the Norwegian company Miles.</i>  <i>He actively uses functional programming in real projects that place high demands on speed and scaling.</i> <br><br><h2>  In the PLO, we force ourselves to work within narrow limits in advance. </h2><br>  <b>- Vagif, did you come to functional programming after procedural and object-oriented?</b>  <b>Or was it the first one that was functional?</b>  <b>What was your starting point?</b> <b>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </b>  <b>Vagif Abilov:</b> When I started looking towards functional programming, I already had about 20 years of experience in object-oriented programming.  In the 90s it was C ++, and then, with the advent of .NET, I programmed in C #.  I am a typical backend developer.  Worked with services and, mainly, with projects where scalability and speed was important. <br><br>  We can single out one of the main reasons for which I began to look closely at something else.  If you look at how to write with the help of OOP of this kind of system, then there is a big problem with the so-called <b>shared state</b> or state of public access.  That is, if you have a multi-threaded system, then it should have access to shared data.  Thus, it is necessary to manually manage flows, it is necessary to close the state of the public access from being accidentally broken.  A significant part of human resources is spent just to program it correctly.  Generally speaking, this is not part of the main domain, the main functional. <br><br>  A certain concomitant factor is that it was formulated as the ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25BA%25D0%25BE%25D0%25BD_%25D0%2590%25D0%25BC%25D0%25B4%25D0%25B0%25D0%25BB%25D0%25B0">Amdal law</a> ‚Äù, which establishes the dependence of the performance of a parallel system on the availability of resources for parallel processing.  On a concrete example, it sounds like this: ‚Äúif you have 10 processors, but you only parallelize 40%, then the speed increases 1.56 times‚Äù.  Thus, for parallelization of systems in which a large focus is on restricting access to data from different streams, there are not many possibilities.  At some point this ceased to suit me, and I began to look more at the possibility of solving this with such means that would allow me to get rid of the shared state.  The advantage of many functional languages ‚Äã‚Äãis precisely the fact that by default all data does not mutate in them, they cannot be changed.  This was the first reason why I began to look towards functional programming. <br><br>  Somewhere six years ago I received an invitation to speak at a fairly large international conference NDC.  By that time, I had already started working in hobby projects with OP and presented my F # experience there.  It was a romantic period when the developers of C # came to the reports on functional programming, listened with pleasure, and then asked: ‚Äúwell, where does this apply in real systems?  Is it possible to apply it at all? ‚Äù  Often, the speakers themselves said that in real systems they do not use the FC, but they are going to.  I was about the same condition, that is, I worked in all projects on C #, but for the pleasure I was introduced to F #. <br><br>  My report was called: "Playing functional Conway's game of life", that is, the implementation of Conway's game "Life" using functional programming.  Quite a famous game.  I showed how to write it in F #, I did it and, starting to figure it out, I was surprised myself.  I must say, before that, I found a project to implement this game on C # on CodeProject.  This project consisted of five classes, five properties and methods, there were more than 300 lines of code, while effective.  Even if you remove all the brackets, there are about 100 lines left.  When I wrote Life on F #, I got 14 lines of executable code: seven functions on average two lines (if you think this is the limit, <a href="http://trelford.com/blog/post/140.aspx">look at the code of</a> English programmer Phil Trelfold, who fit the solution to Conway‚Äôs F # game with 140 characters and posted on twitter).  The compactness of the development on F # shocked me.  This is the first thing that impressed me.  Then I started reviewing my code.  I began to think, and where in general in this code says that the decision is made for a <b>two-dimensional board</b> ?  I found that only one function, which calculates the neighbors of the cell, says that it is a 2D board.  If this function is replaced with work with a three-dimensional or even multidimensional whiteboard, then everything will also work. <br><br>  In many functional languages, in particular in F #, there is a so-called <b>type inference</b> : when you do not directly specify the type of your data, the compiler itself determines what to substitute, depending on how you use them.  Because of this, you write immediately generalized code.  If in Java or C # you need to specifically go to generalize your classes, then in F # this is obtained by default.  This gives a very big advantage, which I could see personally when working on various projects. <br><br>  When I finally prepared my report and spoke with him at conferences, I turned to the hall and asked where to start writing the game Conway.  Practically everyone offered with the definition of classes and properties, for example: you must enter the class "Board", "Cell", define the properties "Cells".  That is, everyone is accustomed to starting with the definition of types and their interrelations.  We are so accustomed.  But in fact, the introduction in advance of such a large number of definitions imposes a significant limitation on further work with them.  The third important aspect in the implementation of the game "Life" on F # was that there I did not introduce any type.  Everything was done by setting functions.  This gives complete freedom to how to ‚Äúplay‚Äù with the original data.  I realized that with the PLO, we ‚Äúforce‚Äù ourselves to work in advance within the framework of the definitions that we introduced. <br><br>  I found a tweet suitable for describing this situation when I worked with the presentation of my report.  Some English-speaking programmer wrote: ‚Äú <i>programming in Java is the same as doing Russian literature: you need to define a hundred names before any events occur</i> . <i>‚Äù</i>  This comment well defines the approach of the PLO.  We should describe everything well from the beginning, and only then some events will start to occur, and we will be able to ‚Äústring‚Äù some methods on our definitions.  And, often, our design already limits us. <br><br>  Returning to the original question, I must say that it was an attempt to get away from mutating data that became the starting point for me in the world of functional programming. <br><br><h2>  There are too many "ceremonies" in Java and C # </h2><br>  <b>- In your opinion, should a person who has been engaged in object-oriented programming for a long time get acquainted / switch to functional?</b> <b><br><br></b>  <b>Vagif Abilov: The</b> question of complete transition is a rather pragmatic question.  And to meet, yes, of course it is. <br><br>  If we look at object-oriented languages ‚Äã‚Äãlike Java or C #, then they have undergone quite large changes in recent years.  If I do not confuse anything, in C # version 3.0, when LINQ appeared, lambda expressions appeared, it was already a noticeable move towards the introduction of functional programming elements. <br><br>  There arises the following argument: ‚Äúwhy should I study functional languages ‚Äã‚Äãthemselves, if we can do a lot in C # with elements of functional languages?‚Äù.  At least one of the answers to this goes into the field of data structure variability, since both C # and Java will <b>always</b> remain languages ‚Äã‚Äãwith mutations.  When the data that you define by default is available for change, then whatever elements of functional programming you make, the fundamental essence of these languages ‚Äã‚Äãwill not change that.  In recent versions of C #, you can ‚Äúplay‚Äù with elements of the FP, but, of course, it makes sense to try working with a real functional language, such as <b>Erlang</b> , <b>Haskel,</b> or <b>F #</b> .  I would especially recommend the latter, since this language is very well embedded in .NET.  It is enough to sort out some examples, to see how concise the code is.  This, in my opinion, is a serious argument - compact code.  The more experienced a programmer is, the more he should realize that there are too many ‚Äúceremonies‚Äù in languages ‚Äã‚Äãsuch as Java and C #.  You can avoid them by halving the code, because usually F # programs are twice as compact as C #. <br><br>  <b>- What are the advantages of the OP in comparison with the PLO?</b> <b><br><br></b>  <b>Vagif Abilov:</b> The first, as I said, this lack of data mutation is very important.  In programs that are written in a functional language, there are no variables.  In a sense, they immediately turn out to be "tough." <br><br>  If you look at the object-oriented code, there will be some variables, some data, then they are sent somewhere, and all of this is accessed from many threads.  In functional languages, at first, this is a bit confusing: how can you generally work without introducing variables?  But everything is implemented using the methods of "functional transformations".  This is precisely the foundation of parallelism.  When you receive any data, you do not need to answer the question: ‚Äúis it thread-safe or not thread-safe?  Will it survive access from many streams or not? ‚Äù  You by definition know what will survive.  You don‚Äôt even have to do any tests to check with access from multiple threads. <br><br>  Due to the lack of variables and the fact that you are passing through functional transformations, tests are very simplified.  As a result, logical errors are much more often caught by the compiler.  One of the "good" problems when working with F # is this: I can spend several hours just to make the program compile, but when this happens, it will work without errors.  It is so "lulling" that you start writing less tests.  At first I tried to fight it and wrote as many tests as in C #.  Then I realized that this was not necessary, since most logical errors are caught by the compiler, which is much less ‚Äúforgiving‚Äù than object-oriented language compilers. <br><br>  Perhaps this is the main advantage: parallelism, no mutations, more interaction with the compiler, which is susceptible to logical errors.  In addition, the style of work is changing.  If I work on C #, I often use classical TDD methodology.  With F #, I work in the REPL mode (read-eval-print loop).  Such work is very effective. <br><br>  <b>- Is there anything that is beyond the power of the OP in comparison with the PLO?</b>  <b>What are his weaknesses?</b> <b><br><br></b>  <b>Vagif Abilov:</b> For each task, their means should be used.  As for the advantages of functional languages ‚Äã‚Äãin the development of scalable systems with high speed, this is understandable, well known.  But for me the advantages of functional programming when working with visual interfaces are not obvious.  If your program is single-threaded and comes down to editing forms, then, in general, it will be natural to apply an object-oriented approach here, since forms are easier placed on the data model.  F #, Clojure, Erlang are also used for developing a user interface, but the advantages seem to me unclear. <br><br>  You can also say that, referring to functional languages, the developer can decide that the problems of parallelism and speed will be solved by themselves, but this does not replace the analysis of problems affecting speed.  For example, a developer needs to think about it if he is working with multi-core processors.  The program must be written so that it enjoys the benefits of the processor cache.  Performance can be lost due to the fact that the cache will be constantly updated.  This is, generally speaking, a task that has nothing to do with either functional programming or object-oriented.  In any case, when developing fast scalable projects, it is necessary to understand the internal architecture of the systems on which they will work.  In other words, this is not a ‚Äúsilver bullet‚Äù; one cannot expect that turning to a functional language will immediately solve all these problems. <br><br>  <b>- If you summarize, what tasks does the FI address?</b> <b><br><br></b>  <b>Vagif Abilov:</b> On solving problems that require parallelism, high speed.  In general, the entire back-end can be successfully written in functional languages. <br><br>  <b>- Vagif, what infrastructure (tooling) needs to be assembled for the implementation of the project in the FP language?</b> <b><br><br></b>  <b>Vagif Abilov:</b> Since I work with C # and F #, for me Visual Studio is the most frequently used tool.  But, more and more often I notice that I use other, less ‚Äúheavy‚Äù means.  For example, as for the F # language, if we are talking about .NET-development, that is, Visual Studio Code with the Ionide plugin.  This is a terrific environment for working with F #. <br><br>  I would recommend using editors such as Atom + Ionide, VS Code + Ionide, Paket, Fake.  For tests, there are F # friendly frameworks: FsUnit and the Expecto library, which is very well built into working with functional languages.  And just the other day there was information that the new IDE JetBrains Rider, which is still in beta, will support F #.  This is a remarkable event, because JetBrains are generally practical guys, and they have long discarded when they were asked about supporting F #, citing the complexity of embedding language principles in the Resharper platform (as I understand it, difficulties relate to type injection, which is not in object-oriented languages ).  But the ice has broken, F # has become too important in the .NET environment so that it can be further ignored. <br><br>  If you need to write a web application, then there is a wonderful Suave framework.  It allows a very compact, literally in a few lines, to write a web application or web service.  If we talk about the implementation of microservices, then very well functional languages ‚Äã‚Äãwork together with the model of actors (Actor-model).  I have been developing the F # system for the last one and a half years using Akka.Net, in which this model is implemented. <br><br>  Among other things, the important components will be the providers of types (type providers), which are implemented in F # and allow you to work very effectively with databases.  They replace heavyweight libraries like the Entity Framework. <br><br>  By the way, an interesting example.  There is a SQLProvider library in F # open-source, which is unusual in that it includes seven drivers in one module: MSSQL, Oracle, SQLite, PostgreSQL, MySQL, MsAccess, ODBC.  And all this weighs only 1.3 megabytes.  And the driver for each of the databases is approximately 600 to 800 lines of code.  This, by the way, is about how compactly you can write many things on F #. <br><br>  <b>- Are there big and serious projects on your personal account implemented with the help of functional programming?</b> <b><br><br></b>  <b>Vagif Abilov:</b> Yes.  In a small group over the past year and a half, using F # using Akka.Net, we are writing a system that has high demands for speed and scalability.  This system is being developed for the Norwegian state radio television.  It handles many hundreds of terabytes of files, working with the cloud.  The code is very compact, despite the complexity of the system. <br><br>  <b>- Do you think that the FP will become popular enough to compete with the PLO?</b> <b><br><br></b>  <b>Vagif Abilov:</b> As for competition, functional programming already now successfully competes with object-oriented and in many projects replaces it.  If we talk about quantitative comparison, we must understand what time perspective we are talking about.  Probably, in the next five years, the FP will not reach a comparable number of projects with the PLO for various reasons.  One of them is that it is much easier to start learning programming from object-oriented languages.  Plus, there are a large number of tasks with a user interface, where, as I said, the benefits of the OP are not obvious. <br><br>  It seems to me that large scalable systems will increasingly be written in functional languages.  One of the reasons for this is that Moore's law does not work.  If earlier it was possible just to wait until more powerful processors come out, and everything in itself will become faster, but now this cannot be done.  It is necessary to redo the architecture under the existing speed, knowing and bearing in mind that it will not increase.  This is a very big trump card in favor of functional programming. <br><br>  <b>- What can you advise those who decided to start learning functional programming?</b> <b><br><br></b>  <b>Vagif Abilov:</b> I would advise you not to treat this choice as a serious life step.  I noticed that trying to change the main language of programmers is considered to be some kind of radical step, unlike, for example, changing a database or some kind of framework.  For example, javascript developers change the libraries they use as gloves.  And it does not look like some serious change.  If you have switched from a relational database to a document base, this is in many ways a more serious step than switching from one .NET language to another. <br><br>  I happened to talk once with the guys who wrote the system for one of the customers on F #.  I asked how easy it was to convince the customer that you would be doing a F # project.  They said that the customer did not talk about it.  The contract stated that the system should work under .NET.  In this approach, in fact, there is something.  If you are writing for this operating environment, then my advice is to try as much as possible and more.  Try other languages, libraries and programming models.  From all this will only benefit. <br><br>  <b>- What will be your report at the St. Petersburg DotNext conference in May?</b> <b><br><br></b>  <b>Vagif Abilov:</b> <a href="https://dotnext-piter.ru/talks/typed-or-dynamic-api-both/">My current report</a> will not be directly related to functional programming, but it will, in a sense, be associated with a change of paradigms.  I will talk about how a developer can make an API in such a way that it is equally easy to use by both those who prefer typed programming and those who use dynamic type programming.  As you know, with the advent of .NET 4.0, the opportunity to embed dynamic types in C # (type dynamic) has appeared.  In a sense, I will talk about the need to be prepared for a paradigm shift.  And this brings together my report with the topic of our conversation today. <br><br>  <i>The whole topic of the report of Vagif Abilov, who will speak at our <a href="https://dotnext-piter.ru/">DotNext</a> conference in St. Petersburg on May 20th, sounds like a <a href="https://dotnext-piter.ru/talks/typed-or-dynamic-api-both/">Typed or dynamic API?</a></i>  <i><a href="https://dotnext-piter.ru/talks/typed-or-dynamic-api-both/">Both!</a></i>  <i>We will be glad to see you at this event, where we managed to collect about 30 great speakers from different parts of the world and on the most relevant topics.</i> </div><p>Source: <a href="https://habr.com/ru/post/328042/">https://habr.com/ru/post/328042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328026/index.html">Mobilization without "headache"</a></li>
<li><a href="../328032/index.html">Vector and Citrix will launch virtual machines into space [literally]</a></li>
<li><a href="../328034/index.html">Volitronic can "extend" the law of Moore</a></li>
<li><a href="../328036/index.html">How to use push notifications?</a></li>
<li><a href="../328038/index.html">English for interviews in an IT company: what do you need to start a career?</a></li>
<li><a href="../328044/index.html">Why we chose the new Angular</a></li>
<li><a href="../328046/index.html">Changes in the rules for advertising newsletters in France: the consent to the distribution by e-mail must be received annually</a></li>
<li><a href="../328048/index.html">All-In-One: Proxmox + OpenMediaVault or another idea for a home NAS</a></li>
<li><a href="../328050/index.html">There is no</a></li>
<li><a href="../328052/index.html">Boxing and unboxing - which is faster?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>