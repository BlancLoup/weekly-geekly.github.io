<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of tools for load and performance testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As other brave people say: ‚ÄúFrom dev to prod is just one step‚Äù. Experienced people add that this step is called ‚Äútesting‚Äù, and the most diverse, and w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of tools for load and performance testing</h1><div class="post__text post__text-html js-mediator-article">  As other brave people say: ‚ÄúFrom dev to prod is just one step‚Äù.  Experienced people add that this step is called ‚Äútesting‚Äù, and the most diverse, and we simply have no reason not to believe them. <br><br><img src="https://habrastorage.org/web/f79/adf/c03/f79adfc038144ef1a96859c232398a4b.jpg"><br><br>  <i>The load matters: the driver of this truck <a href="http://www.dailymail.co.uk/news/article-2179893/Worlds-biggest-traffic-fine-Chinese-driver-overloaded-truck-collapsed-bridge-gets-16m.html">managed to</a> bring down the bridge with the weight of its vehicle, the recovery bill was about $ 21.3M.</i>  <i>Fortunately, software testing is cheaper!</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, speaking of testing, you need to understand what and what we are fighting for.  We deliberately limited ourselves and decided today to talk exclusively about load testing and performance testing: topics that are polarly distant from each other are extremely interesting in their most practical terms.  Consider the tools for both, without being tied to any particular stack of technologies, so do not be surprised at the Yandex.Tank and BenchmarkDotNet neighborhood! <br><a name="habracut"></a><br><h2>  Stress Testing </h2><br>  Imagine that you and I wrote a certain service - now you need to understand how much pressure it will take.  The old sad joke of developing high-quality software says that it is better to have software that works guaranteed badly than software that works well, but not <i>guaranteed</i> well: in the first case, we will at least know what we can count on.  Further, if our service is able to scale in one way or another, then you need to understand how scaling turns out to be useful with increasing load and whether it performs the tasks assigned to it by the project. <br><br>  Well, we take and direct the load on our child, while carefully observing the result: we are obviously interested in the situation when the service either begins to respond to requests with an unacceptable delay, or returns incorrect data, or stops altogether giving signs of life for all requests or just for their part. <br><br>  Let's imagine that we wrote some service - for definiteness, we say that a web service, but this is not so important.  To make sure what we can count on with it, we begin to ‚Äúbombard‚Äù it with requests, observing the behavior of both the service itself and the load on the servers where it is spinning.  It‚Äôs good if it‚Äôs clear in advance what requests we need to send to the service (in this case, we can prepare an array of requests in advance, and then send it to our application in one fell swoop).  If the second request depends on the results of the first (a simple example - the user is first authorized, and the next calls to the service include information about the session ID), then the load generator must be able to generate test requests extremely quickly, in real time. <br><br>  Taking into account the circumstances and our knowledge of the test object, we select the tool (s): <br><br><h3>  <a href="http://jmeter.apache.org/">JMeter</a> </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2bf/f5d/687/2bff5d687daae0a3c3ab50b95b4cb38c.svg" width="260" align="left">  Yes, good old JMeter.  For almost twenty years now (!) It has been a frequent choice for many variants and types of load testing: a convenient GUI, platform independence (thanks to Java!), Multithreading support, extensibility, excellent reporting capabilities, support for many protocols for queries.  Thanks to the modular architecture, JMeter can be expanded to the right direction for the user, implementing even very exotic test scenarios - and if none of the plug-ins written by the community in the past time suits us, you can take the API and write your own.  If necessary, with JMeter, you can build, albeit limited, but distributed testing, when the load will be created by several machines at once. <br><br>  One of the convenient features of JMeter is to work in proxy mode: we specify ‚Äú127.0.0.1:8080‚Äù as a proxy in the browser settings and visit the browser with the pages of the site we need, while JMeter saves all our actions and all related requests in the form of a script that You can edit it later as needed - this makes the process of creating HTTP tests much easier. <br><br>  By the way, the latest version (3.2), released in April of this year, learned to give test results to InfluxDB using asynchronous HTTP requests.  True, starting just from version 3.2, JMeter began to require only Java 8, but this is probably not the highest price for progress. <br><br>  The storage of test scripts in JMeter is implemented in XML files, which, as it turned out, creates a lot of problems: they are completely inconvenient to write with your hands (read, you need a GUI to create text), how inconvenient it is to work with such files in version control systems (especially during when you need to do diff).  Competing on the field of load testing products, such as Yandex.Tank or Taurus, have learned how to form test files on the fly and transfer them to JMeter for execution, thus using the power and experience of JMeter, but allowing users to create tests in the form of more readable and easier stored in CVS test scripts. <br><br><h3>  <a href="https://software.microfocus.com/en-us/software/loadrunner/">Loadrunner</a> </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/097/48b/a86/09748ba86870d5015fde053ac49b0623.png" width="260" align="left">  Another very well-known product on the market and in certain circles, the wider distribution of which was prevented by the licensing policy adopted by the manufacturer (by the way, today, after the merger of the Hewlett Packard Enterprise software division with Micro Focus International, the usual name HPE LoadRunner changed to Micro Focus LoadRunner).  Of interest is the logic of creating a test, where several (probably correctly say ‚Äúmany‚Äù) virtual users in parallel do something with the application under test.  This makes it possible not only to assess the ability of the application to process a stream of simultaneous requests, but also to understand how the work of some users who are actively doing something with the service affects the work of others.  In this case we are talking about a wide choice of protocols for interaction with the application under test. <br><br>  HP at one time created a very good set of automation tools for functional and load testing, which, if necessary, are integrated into the software development process, and LoadRunner can integrate with them (in particular, with HP Quality Center, HP QuickTest Professional). <br><br>  Some time ago, the manufacturer decided to turn around to those who are not ready to pay for the license right away, and supplying LoadRunner with a free license (where a limit for 50 virtual users is entered, and a small part of the entire set of supported protocols is prohibited), and the money is taken for further expansion .  It is difficult to say how this will contribute to increasing interest in this, undoubtedly, entertaining tool, if it has such strong competitors. <br><br><h3>  <a href="http://gatling.io/">Gatling</a> </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/efe/d8f/917/efed8f917fef909337ac07b7aebe524b.png" width="260" align="left">  A very powerful and serious tool (not for nothing that it was named after a rapid-fire machine gun), primarily because of the performance and breadth of support for out-of-box protocols.  For example, where load testing with JMeter is slow and painful (alas, the plug-in support for working with web sockets is not very fast, which ideologically conflicts with the speed of the web sockets themselves), Galting will almost certainly create the necessary workload without much difficulty. <br><br>  It should be noted that, unlike JMeter, Gatling does not use the GUI and is generally considered to be a tool for an experienced, ‚Äúcompetent‚Äù audience that can create a test script in the form of a text file. <br><br>  Gatling has some cons for which he is criticized.  Firstly, the documentation could have been better, and secondly, to work with it, it's good to know Scala: Gatling itself, as a testing tool, and test scripts are written in this language.  Thirdly, ‚Äúsometimes‚Äù in the past drastically changed the API, as a result, it was possible to find out that the tests written six months earlier ‚Äúdo not run‚Äù on the new version, or require revision / migration.  Gatling also lacks the ability to do distributed testing, which limits possible applications. <br><br><h3>  <a href="https://tech.yandex.ru/tank/">Yandex.Tank</a> </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2a9/66e/5c2/2a966e5c223c1ade0cde5c50d84a7e81.jpg" width="260" align="left">  In short, Yandex Tank is a wrapper over several load testing utilities (including JMeter), providing a unified interface for configuring, running and generating reports, regardless of which utility is used ‚Äúunder the hood‚Äù. <br><br>  He can monitor the main metrics of the application under test (processor, memory, swap, etc.), system resources (free memory / disk space), can stop the test based on various clear criteria ("if the response time exceeds a specified value", " if the number of errors per unit of time is higher than x ", etc.).  By the way, it can display the main statistical data of the test in real time, which is very useful right during the test. <br><br>  The tank has been used in Yandex itself and in other companies for about 10 years.  They are bombarded with completely different services, with different requirements for the complexity of test scenarios and the level of load.  Almost always, for testing even heavily loaded services, only one load generator is enough.  The tank supports various load generators, both written specifically for it (Phantom, BFG, Pandora), and widely third-party (JMeter).  The modular architecture allows you to write your plug-in under the desired load generator and generally screw almost anything. <br><br>  Why use different load generators?  Phantom is a fast ‚Äúcannon‚Äù in C ++.  One such generator can produce up to hundreds of thousands of requests per second.  But to achieve this speed, it is necessary to generate requests in advance and it is impossible (not possible) to use the data received from the service under test to generate the next request.  In cases when you need to execute a complex script or service uses a non-standard protocol, you should use JMeter, BFG, Pandora. <br><br>  In BFG, unlike Jmeter, there is no GUI, test scripts are written in Python.  This allows you to use any library (and their huge number).  It often happens that bindings are written for the service for Python, then it is convenient to use them when writing load scripts.  <a href="https://github.com/yandex/pandora">Pandora</a> is an experimental gun on GoLang, fast enough and extensible, suitable for tests using the HTTP / 2 protocol and will be used where fast scripts are needed. <br><br>  Inside Yandex, a special service is used to store and display the results of stress tests.  Now its simplified analogue called <a href="https://overload.yandex.net/">Overload</a> is open - it is completely free, it is used, including for testing open libraries ( <a href="https://github.com/vostok-project/core/issues/3">for example</a> ) and holding competitions. <br><br><h3>  <a href="https://gettaurus.org/">Taurus</a> </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8c1/d16/32a/8c1d1632a4d87a5cb8f6832bd3a94547.png" width="260" align="left">  Taurus is another framework for several load testing utilities.  You might like this product, which uses a Yandex.Tank-like approach, but having a slightly different set of features, and, perhaps, a more adequate configuration file format. <br><br>  In general, Taurus works well in a situation where power, say, Gatling is important for creating a test, but there is no desire or opportunity to deal with Gatling (as well as writing scripts for testing on Scala): it‚Äôs enough to describe the test in a much simpler Taurus file format, configure use Gatling as a load creation tool, and all Scala files will be generated automatically.  So to say, ‚Äúautomation automation‚Äù in action! <br><br>  Taurus can be configured to send test statistics to the BlazeMeter.com online service, which will display data in the form of smart graphs and tables.  The approach is not very ordinary, but noteworthy: the report output engine is obviously improving over time, and will gradually display information even more likeably. <br><br><h2>  Performance testing </h2><br>  Testing the performance of a service or application can and should be done not only after the development process is completed, but also during it, just as we do regular unit or regression tests.  Properly organized, regular performance tests allow us to answer a very ‚Äúthin‚Äù question: have the recent changes in the application code led to a deterioration in the performance of the resulting software? <br><br>  It would seem to measure performance - it's that easy!  Twice take the timestamp (preferably with high accuracy), calculate the difference, add-divide, and everything can be optimized.  No matter how wrong!  Although this question sounds simple in words, in fact this kind of measurement is rather difficult to make, and it is generally not always reasonable to compare the results of various measurements.  One of the reasons: to compare the results, the tests must pass over the same source data, which, among other things, implies the re-creation of the test environment during each test run, another reason - the comparison of the subjective perception of the test scenario runtime may be inaccurate. <br>  Another reason is the difficulty of distinguishing the impact on the performance of the whole application of the work of its individual module, the one we are correcting.  Compounding the situation, we specify: it is even more difficult to isolate this influence if a team of more than one developer is working on the code. <br><br>  One of the approaches in such a situation is to thoroughly create a full-fledged test script that repeats work with the services of a real client, and runs it many times, with parallel analysis of server load, where it is being tested (thus, it will be clear how much of the script creates a load on individual test server resources, which can provide additional information on finding places where you should approach performance more seriously) - alas, you cannot always afford this in a real situation, just flow  in that the volumetric test, and even povtoronny 10-20 times more likely to be too long to see him very often, and it's completely kill the idea. <br><br>  The second approach, more suitable for the development process, is to organize a limited in scale, ‚Äúmicro‚Äù or even ‚Äúnano‚Äù testing of individual code points (say, launching one method or one function, but a large number of times ‚Äî that is, rather, benchmarking).  Planning for such testing requires additional efforts on the part of the developer, but the result pays off and general improvement in code performance, and understanding how individual parts of the project behave as you work on them as well as on other parts.  Here, for example, a couple of performance testing tools: <br><br><h3>  <a href="http://openjdk.java.net/projects/code-tools/jmh/">Jmh</a> </h3><br>  JMH (Java Microbenchmark Harness) is a Java snap-in for building, running, and analyzing nano / micro / milli / macro benchmarks written in Java and other languages ‚Äã‚Äãwith the target JVM platform.  A relatively young framework in which developers have tried to take into account all the nuances of the JVM.  One of the most convenient tools from those that are nice to have on hand.  JMH supports the following types of measurements: Throughput (measurement of net performance), AverageTime (measurement of average execution time), SampleTime (percentile of execution time), SingleShotTime (the time to call one method is relevant for measuring the ‚Äúcold‚Äù start of the code being tested). <br><br>  Since we are talking about Java, the framework takes into account including.  and the operation of the JVM caching mechanism, and before launching the benchmark, it executes the test code several times to ‚Äúwarm up‚Äù the Java byte-code cache. <br><br><h3>  <a href="http://benchmarkdotnet.org/">BenchmarkDotNet</a> </h3><br><img src="https://habrastorage.org/web/155/597/6a7/1555976a791a4c88bc82040c0fd79561.png" width="260" align="left">  BenchmarkDotNet takes on routine tasks when compiling benchmarks for .NET projects and provides wide possibilities for formatting results with minimal effort.  As the authors say, there are plenty of feature requests, so BenchmarkDotNet has room to develop. <br><br>  To date, BenchmarkDotNet is a library, primarily for benchmarks, and not for performance tests.  Serious work is under way to ensure that the library could also be used on the CI server for automatic detection of performance regressions, but so far these developments have not been completed. <br><br><h3>  <a href="https://developers.google.com/web/tools/lighthouse/">Google lighthouse</a> </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/af0/7c4/b89/af07c4b89f3fa49c62ef529afb647ac3.png" width="260" align="left">  Frontend performance measurements have always stood somewhat apart: on the one hand, often delays are related to the backend reaction speed, on the other hand, users often judge the entire application by the behavior of the frontend (more precisely, by the speed of its reaction), especially when it comes to the web. <br><br>  In the web frontend with respect to performance measurements, everything now goes towards using the Performance API and measuring exactly the parameters that are relevant to a particular project.  The <a href="https://www.webpagetest.org/">webpagetest.org</a> web service with the Performance API tags and measurements will be a good help - it will allow you to see the picture not from your computer, but from one of the many testing points existing in the world, and assess the impact of the time of receiving and transmitting data via Internet channels to work frontend. <br><br>  This product would be more suitable for checking the pages of the site for compliance with Google‚Äôs recommendations (and best practices in general) for both websites and Progressive Web Apps, if it were not for one of its functions: among the checks there is also a test for the site‚Äôs behavior in case of bad as a web connection, as well as in the complete absence of communication.  This is not very correlated with performance testing as such, however, if you think about it, in some cases a web application is perceived as ‚Äúslow‚Äù not because it prepares data slowly, but because its operating conditions on the user's machine, in its browser, considering its internet connection - alas, not perfect.  Google Lighthouse just allows you to evaluate this effect. <br><br><hr><br>  Yes, the topic of benchmarks and testing is endless.  About each of them can and should write a post, and not one.  However, as we all know, the most interesting thing is not just to read, but to talk, listen, ask around a knowledgeable person who, by virtue of his experience, will warn in advance about the many small and major difficulties lying in the way of mastering this or that technology. <br><br>  Therefore, we are pleased to invite you to attend the Heisenbag 2017 Moscow Conference, which will be held on December 8-9, 2017, where, in particular, the following reports will be presented: <br><br><ul><li>  <a href="https://heisenbug-moscow.ru/talks/2017/msk/3ghfkenywccuws6q0saeyk/">Tester Tools</a> </li><li>  <a href="https://heisenbug-moscow.ru/talks/2017/msk/ik9jansi0gykw2egosq2c/">Testing browser performance of web applications (including javascript, rendering, that's all)</a> </li><li>  <a href="https://heisenbug-moscow.ru/talks/2017/msk/1su57z0to8qimacswsgksu/">Flaky tests (unstable autotest report)</a> </li><li>  <a href="https://heisenbug-moscow.ru/talks/2017/msk/jf8hxzjbaggkaickcqa6i/">TestContainers - integration testing without hassle</a> </li></ul><br>  Details and conditions for participation can be found <a href="https://heisenbug-moscow.ru/">on the conference website</a> . </div><p>Source: <a href="https://habr.com/ru/post/337928/">https://habr.com/ru/post/337928/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337914/index.html">Cloud Fabric: how SDN helps IT more responsive to change</a></li>
<li><a href="../337916/index.html">Unicorn technology companies are revalued by an average of 48%: research by scientists from Stanford</a></li>
<li><a href="../337918/index.html">Transition from a typical data center network to SDN</a></li>
<li><a href="../337922/index.html">Problems of React UI Kit and unified design systems that you did not know about</a></li>
<li><a href="../337924/index.html">Reports from Frontend Mix: optimization of loading sites and design system on BEM and React</a></li>
<li><a href="../337932/index.html">VMworld 2017 Europe Conference. Day 1</a></li>
<li><a href="../337934/index.html">Amazingly useful tool: lsof</a></li>
<li><a href="../337936/index.html">Chief, I want to work from home</a></li>
<li><a href="../337938/index.html">4 reasons to become a Data Engineer</a></li>
<li><a href="../337940/index.html">We write telegrams of a bot parser of vacancies on JS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>