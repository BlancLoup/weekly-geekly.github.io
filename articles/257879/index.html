<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How ‚ÄúRussian hackers‚Äù tried to learn about new sanctions against Russia: we study CVE-2015-1701</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This zero-day vulnerability in Windows became known on April 20, when FireEye and Bloomberg reported an unsuccessful cyber attack on a government depa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How ‚ÄúRussian hackers‚Äù tried to learn about new sanctions against Russia: we study CVE-2015-1701</h1><div class="post__text post__text-html js-mediator-article">  This zero-day vulnerability in Windows became known on April 20, when FireEye and Bloomberg reported an unsuccessful cyber attack on a government department of a foreign country, which had discussed sanctions against Russia with the United States.  He was accused of ‚ÄúRussian hackers‚Äù from the APT28 grouping in FireEye of involvement in the deed, as well as attempts at hacking by the secret services of NATO, the state bodies of Georgia, Poland, and Hungary. <br><br>  The attack was implemented using previously unknown vulnerabilities CVE-2015-3043 in Adobe Flash and CVE-2015-1701 in Windows.  The user was sent via a link to an infected site, where a JavaScript script, using a Flash vulnerability, loaded an executable file into a computer, which, through the CVE-2015-1701 hole in Windows, raised privileges and stole encryption keys. <br><br>  The Adobe company in a matter of hours eliminated the vulnerability in Flash, but Microsoft was in no hurry and released a <a href="https://technet.microsoft.com/library/security/MS15-051">patch</a> just the day before.  In this article we will tell about the main features of this bug. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Valuable gSharedInfo </h4><br>  First, describe some of the structures and mechanisms used to exploit CVE-2015-1701 vulnerabilities.  This time, the <a href="http://www.securitylab.ru/news/472188.php">infamous</a> <code>win32k.sys</code> not without cost, so the first thing to do is to look at the <code>win32k!tagSHAREDINFO</code> , which is answered by the symbol <code>win32k!gSharedInfo</code> , and also on the data type <code>HWND</code> , which is very closely associated with it. <br><br> <a href="http://habrahabr.ru/company/pt/blog/257879/"><img src="https://habrastorage.org/files/2f9/e01/d11/2f9e01d11ae14fb1968afc035b733cd5.png"></a> <br><br>  Our <code>gSharedInfo</code> stores pointers to various window-related structures and, best of all, many of these structures are mapped into user space (put into the user-mode, in our opinion), and the corresponding <code>user32!gSharedInfo</code> symbol has <code>user32!gSharedInfo</code> for some time (or whist, either from the seven) became exported. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/079/786/b9c/079786b9c96a4f16b9fb8552e9854648.png"><br><br>  We are interested in two fields here: <br><br><ul><li>  <code>aheList</code> - points to an array of <code>win32k!_HANDLEENTRY</code> type elements <code>win32k!_HANDLEENTRY</code> ; </li><li>  <code>HeEntrySize</code> - contains the size of the <code>win32k!_HANDLEENTRY</code> . </li></ul><br>  So, the lower 16 bits of the <code>HWND</code> window handle are in fact the index in the <code>gSharedInfo-&gt;aheList</code> .  For example, if we have a <code>window</code> variable that contains the <code>HWND</code> handle: <br><br><img src="https://habrastorage.org/files/a9d/9f0/ff3/a9d9f0ff33f34b489b87b5bba1cd9d94.png"><br><br>  and the same in the core: <br><br><img src="https://habrastorage.org/files/c3f/75f/6b9/c3f75f6b907d4cefb3f5553bda8689b5.png"><br><br>  The <code>wUniq</code> field of the <code>win32k!_HANDLEENTRY</code> contains the top 16 bits of the <code>HWND</code> descriptor and, apparently, serves the simple purpose of separating objects that occupy the same address in a given array at different time intervals.  Thus, if an object is freed and later its place is taken, for example, by a new window with <code>wUniq = 0x12</code> , then according to the old descriptor <code>0x0011024c</code> it will be impossible to access it. <br><br>  The <code>bFlags</code> and <code>bType</code> contain various flags and the type of object addressed by the phead field, respectively.  In more detail possible values ‚Äã‚Äãaccepted by them can be looked in <a href="https://www.reactos.org/wiki/Techwiki:Win32k/HANDLEENTRY">ReactOS</a> . <br><br>  We are only interested in one possible <code>bType</code> value <code>bType</code> : <br><br> <code>TYPE_WINDOW = 1</code> <br> <br>  means that the object is a window, and the <code>phead</code> field addresses the <code>win32k!tagWND</code> . <br><br><img src="https://habrastorage.org/files/1fe/a51/c56/1fea51c567034ff0a995b859bb63f420.png"><br><br>  Here you can note that the user <code>user32!gSharedInfo-&gt;aheList[‚Ä¶].phead</code> stores the address belonging to the kernel.  However, if you wish, you can get the address of its user mapping, but this is another story, so for details I refer you to the <code>HWND</code> window handle and the <code>user32!ValidateHWND</code> procedure that returns the <code>tagWND*</code> , or rather to the <code>user32!HMValidateHandle</code> . <br><br>  The last <code>pOwner</code> field of the <code>win32k!_HANDLEENTRY</code> <code>pOwner</code> structure not considered earlier contains a pointer to <code>win32k!_W32THREAD</code> stream to which the object belongs.  Each thread stores this pointer in <code>win32k!_KTHREAD-&gt;Win32Thread</code> (why not in <code>_ETHREAD</code> ), and also, which is much more important in our case, in <code>TEB!Win32ThreadInfo</code> . <br><br><img src="https://habrastorage.org/files/d78/0bc/129/d780bc129c6a423ca3f44cc05540b3e7.png"><br><br>  Using all this information, we can search for windows belonging to the thread of our process and restore their descriptors.  To do this, find the element <code>user32!gSharedInfo-&gt;aheList[‚Ä¶]</code> , which: <br><br><ul><li>  <code>bType == TYPE_WINDOW</code> ; </li><li>  <code>pOwner == TEB!Win32ThreadInfo</code> . </li></ul><br>  The index of such a structure will be equal to the <code>wUniq</code> 16 bits of the descriptor, and the upper 16 bits will be contained in the <code>wUniq</code> field. <br><br>  Why not just use <code>user32!FindWindow</code> ?  At the moment when we need it, neither the name nor the class will be filled in by the window. <br><br><h4>  KernelCallbackTable </h4><br>  Another concept to be explained is closely related to the <code>PEB!KernelCallbackTable</code> . <br><br><img src="https://habrastorage.org/files/f06/bc6/33f/f06bc633f5584524a9291a9fcd80f209.png"><br><br>  As you can see, there are various callbacks here, but they, of course, not the <code>kernel</code> , but received their name because their client is usually <code>win32k.sys</code> , accessing them when it is necessary to perform an operation in the user space.  The call is made via <code>ntdll!KiUserCallbackDispatcher</code> similar to <a href="http://www.nynaeve.net/%3Fp%3D200">exception scheduling</a> . <br><br>  In the kernel, the mechanism for calling these callbacks is implemented in the function <code>nt!KeUserModeCallback</code> .  The call is made on the kollbek index.  Address resolving by index is done already in <code>ntdll!KiUserCallbackDispatcher</code> . <br><br><h4>  SetWindowLongPtr </h4><br>  Next in line is <code>user32!SetWindowLongPtr</code> , and in fact - its execution in the form of <code>win32k!xxxSetWindowData</code> .  We confine ourselves to only one case of interest - with the <code>GWLP_WNDPROC</code> parameter. <br><br>  <code>win32k!xxxSetWindowData</code> first performs various checks.  For example, is the window owned by the process whose thread is trying to set the <code>WndProc</code> , and also whether this window is already destroyed ( <code>FNID_DELETED_BIT</code> bit). <br><br>  Then the optimization is very important for us. <br><br><img src="https://habrastorage.org/files/277/2e9/377/2772e93778534d4aabf3829d885189f7.png"><br><br>  On the passed <code>WndProc</code> parameter ( <code>value_</code> in the screenshot), <code>MapClientToServerPfn</code> is <code>MapClientToServerPfn</code> .  This simple and extremely useful function maps functions from <code>win32k!gpsi-&gt;apfnClientW</code> and <code>win32k!gpsi-&gt;apfnClientA</code> to the corresponding functions from <code>win32k!gpsi-&gt; aStoCidPfn</code> : <br><br><img src="https://habrastorage.org/files/88b/134/2b6/88b1342b64d84d3fb3cc4ab4136d6597.png"><br><br><img src="https://habrastorage.org/files/d0f/684/a7f/d0f684a7f8ec40bdb67e9efc7ecd487f.png"><br><br><img src="https://habrastorage.org/files/1d9/1e2/5fb/1d91e25fbe80413daf5de5be467d3bd2.png"><br><br>  If such a mapping for the transmitted <code>WndProc</code> possible, then the procedure call can be optimized by referring directly to the implementation of the function in the kernel, for example, <code>win32k!xxxDefWindowProc</code> , without wasting time switching to user mode to call the wrapper, for example, <code>ntdll!NtdllDefWindowProc_A</code> , which <code>user32!DefWindowProcA</code> is an end-to-end export. <br><br>  As you can see from the screenshot, if the mapping is successful, then the <code>WFSERVERSIDEPROC</code> flag is raised at the window, after which the mapped value is entered in its <code>win32k!tagWND-&gt;lpfnWndProc</code> . <br><br>  Thus, if one of the standard procedures is set up through <code>user32!SetWindowLongPtr</code> , then the corresponding procedure from <code>win32k.sys</code> in kernel mode will actually be executed. <br><br><h4>  xxxCreateWindowEx </h4><br>  Now consider creating a window.  Roughly speaking, the <code>win32k!xxxCreateWindowEx</code> procedure is fully responsible for <code>win32k!xxxCreateWindowEx</code> .  First, by calling <code>win32k!HMAllocObject</code> tagWND object is <code>tagWND</code> and information about it is entered into the <code>gSharedInfo-&gt;aheList</code> : <br><br><img src="https://habrastorage.org/files/659/81f/b12/65981fb124904d77ace04a676204281f.png"><br><br>  Then the window attributes are populated.  The whole procedure, even in <code>hex-rays</code> takes a couple of thousand lines, so there is no point or opportunity to dwell on all the actions performed. <br><br><h4>  Operating option </h4><br>  The question arises: what happens if you call <code>SetWindowLongPtr(hwnd, GWLP_WNDPROC, DefWindowProc)</code> on the window at the moment when it is already created, but it still has the <code>lpfnWndProc</code> field.  After all, this field is filled from the class field, in which it is probably already stored mapped by <code>MapClientToServerPfn</code> , if such mapping is possible. <br><br>  Indeed, there is a possibility of calling <code>SetWindowLongPtr</code> to raise the <code>WFSERVERSIDEPROC</code> flag before the <code>WndProc</code> address is filled with the value from the class field.  At the same time, this flag is not reset when the <code>WndProc</code> field is set, as the developers did not anticipate the possibility that it can be installed.  There is only the logic of setting the flag for the window, if the corresponding class flag is raised. <br><br><img src="https://habrastorage.org/files/6a1/193/e96/6a1193e96a6e4acfb6828489cc096ecd.png"><br><br>  However, the probability of setting a flag from a neighboring thread by calling <code>SetWindowLongPtr</code> at run time <code>CreateWindowEx</code> negligible, because you must first find the <code>HWND</code> windows in the <code>user32!gSharedInfo-&gt;aheList</code> , then the <code>user32!SetWindowLongPtr -&gt; ‚Ä¶ -&gt; win32k!xxxSetWindowData</code> chain <code>user32!SetWindowLongPtr -&gt; ‚Ä¶ -&gt; win32k!xxxSetWindowData</code> should work out the call chain what happens initialization of the <code>tagWND</code> fields in <code>win32k!xxxCreateWindowEx</code> .  You can, of course, play with <code>processor affinity</code> and thread priorities.  However, for Windows 7 and earlier versions, there is a simple way. <br><br><h4>  Option for Windows 7 </h4><br>  Despite the enormous size of the <code>win32k!xxxCreateWindowEx</code> , all the information we are interested in fits into several hex-rays lines: <br><br><img src="https://habrastorage.org/files/f8a/eda/f13/f8aedaf133504a57b1b2a66f2d667e98.png"><br><br>  If during the registration of a window class, it had a picture for the normal <code>hIcon</code> icon, but was not specified for the small <code>hIconSm</code> icon, then <code>win32k!xxxCreateWindowEx</code> copies the window, or rather, scales it, the window for filling the <code>win32k!tagCLS-&gt;spicnSm</code> field <code>win32k!tagCLS-&gt;spicnSm</code> .  This action is performed by the <code>win32k!xxxCreateClassSmIcon</code> , which delegates the task to one of the above-described user so-called <code>kernel callbacks</code> : <br><br><img src="https://habrastorage.org/files/40c/50d/61c/40c50d61c8d949b1b81b8ee15a5b19e0.png"><br><br>  Under the 0x36 number in the table goes <code>user32!_ClientCopyImage</code> .  He performs the task. <br><br><img src="https://habrastorage.org/files/d6a/f84/702/d6af8470292b4e268aac42e94883329a.png"><br><br>  After copying the icon in <code>win32k!xxxCreateWindowEx</code> , the <code>WndProc</code> window is immediately filled from the <code>WndProc</code> class.  Then, apparently, if the <code>WFSERVERSIDEPROC</code> flag <code>WFSERVERSIDEPROC</code> raised in the class, it is also raised for the window. <br><br><h4>  results </h4><br>  As a result, we get the following.  First you need to register a class with the usual icon, but without a small one: <br><br><img src="https://habrastorage.org/files/db2/736/7e9/db27367e96df4c7394c124d36f4802a0.png"><br><br><img src="https://habrastorage.org/files/907/d42/684/907d426841a340ae8e4d3e9af6d4ae8e.png"><br><br>  You also need to hook <code>user32!_ClientCopyImage</code> : <br><br><img src="https://habrastorage.org/files/abb/4a1/dc1/abb4a1dc13b04b548d820010ab2ece28.png"><br><br>  It will call <code>SetWindowLongPtr</code> for the newly created window: <br><br><img src="https://habrastorage.org/files/87d/ccd/be5/87dccdbe5b164914859fc2efaf6adaa0.png"><br><br>  After that, at the time of creating the window, the previously installed hook is called. <br><br><img src="https://habrastorage.org/files/a6d/174/ffa/a6d174ffa47749e4baa02074a1f0b9ad.png"><br><br>  The window at this moment is already listed in the table, but not yet initialized. <br><br><img src="https://habrastorage.org/files/9d9/5f8/99e/9d95f899e97b481094c1b296e243265a.png"><br><br><img src="https://habrastorage.org/files/89c/6fa/d02/89c6fad029214bd3a2f9a6b429d8b8e2.png"><br><br>  The hook calls <code>SetWindowLongPtr</code> , which raises the <code>bServerSideWindowProc</code> flag in the appropriate window structure. <br><br><img src="https://habrastorage.org/files/226/b6a/958/226b6a958b9540589e09c7213f844916.png"><br><br>  And on returning from the callback, <code>win32k!xxxCreateWindowEx</code> overwrites <code>lpfnWndProc</code> value from the class field. <br><br><img src="https://habrastorage.org/files/4af/0db/78e/4af0db78e66747e99eb543121cdfe8b3.png"><br><br>  Thus, the window function specified during class registration will be executed in the kernel: <br><br><img src="https://habrastorage.org/files/f04/5b2/348/f045b2348ab242f8a753cc6ab7a716a6.png"><br><br>  Obviously, the simplest thing for which it can be used is the theft of the system token with the subsequent launch of the system shell. <br><br><img src="https://habrastorage.org/files/e5c/e21/21f/e5ce2121f9b148e09994ac491d860fed.png"><br><br><img src="https://habrastorage.org/files/574/b7c/e57/574b7ce572824941bce62eb51ed3e5e7.png"><br><br>  PS A quick inspection of Windows 8.1 showed that in <code>win32k!xxxCreateWindowEx</code> installation of <code>tagWND-&gt;lpfnWndProc</code> and the call to <code>win32k!xxxCreateClassSmIcon</code> are in reverse order compared to earlier versions.  Thus, the <code>user32!_ClientCopyImage</code> hook <code>user32!_ClientCopyImage</code> will not help. <br><br>  There is a possibility that the ‚Äúrace condition‚Äù still exists and may, with some probability, be exploited in the manner described above with two streams.  On this score, nothing more accurate to say now will not work. </div><p>Source: <a href="https://habr.com/ru/post/257879/">https://habr.com/ru/post/257879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257867/index.html">DIY Robot Vacuum Cleaner</a></li>
<li><a href="../257869/index.html">MyBatis and OSGi</a></li>
<li><a href="../257871/index.html">MBLT15: A week before the international mobile conference</a></li>
<li><a href="../257875/index.html">Thoughts on the ideal programming language</a></li>
<li><a href="../257877/index.html">Typical errors and not very</a></li>
<li><a href="../257881/index.html">Analysis of accounts of one (not) reliable email-service</a></li>
<li><a href="../257883/index.html">Comparative analysis of HL7 and openEHR</a></li>
<li><a href="../257885/index.html">Courses on ethical hacking and penetration testing: updated program</a></li>
<li><a href="../257887/index.html">Python nightmares: the implicit `this`</a></li>
<li><a href="../257889/index.html">Fast cross-platform HTML5 application on Framework7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>