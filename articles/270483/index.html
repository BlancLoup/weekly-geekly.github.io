<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to the development of domain-specific languages ‚Äã‚Äã(DSL) using EMFText</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the 5th article of the model-driven development cycle. In previous articles we have already dealt with metamodels , model validation , some no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to the development of domain-specific languages ‚Äã‚Äã(DSL) using EMFText</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/458/a53/cde/458a53cde5a64ad090d2e164d62eb544.jpg"><br>  This is the 5th article of the model-driven development cycle.  In previous articles we have already dealt with <a href="http://habrahabr.ru/company/cit/blog/266433/">metamodels</a> , <a href="http://habrahabr.ru/company/cit/blog/264963/">model validation</a> , some notations for models ( <a href="http://habrahabr.ru/company/cit/blog/267335/">diagrams</a> and <a href="http://habrahabr.ru/company/cit/blog/269291/">tables</a> ).  All this was within the scope of the MOF <a href="http://www.jot.fm/issues/issue_2006_11/article4/">simulation space</a> .  Today we will build a bridge to the EBNF modeling space - let's get acquainted with the textual notation for MOF models. <br><a name="habracut"></a><br><h4>  <font color="#902213"><b>Introduction</b></font> </h4><br>  In general, there is a lot of information on the development of general-purpose programming languages ‚Äã‚Äãand domain-specific languages.  Anyone who is interested in this, probably has a general idea about lexers, parsers, syntax trees, etc.  But we will approach this a bit from the other side.  We will not consider the development of DSL in general, we are only interested in it from the point of view of model-oriented development. <br><br><img src="https://habrastorage.org/files/6fe/497/d89/6fe497d894fd4a91a1057f5f7bf7906a.png"><br><br><blockquote>  <b>Note</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To be honest, the introduction turned out to be some kind of cerebral.  It focuses primarily on model-driven development professionals.  You can scroll through it. </blockquote><br>  In the figure, red, yellow, purple and green colors indicate what is usually considered in the theory of programming languages.  The language grammar is developed in EBNF (or some other language).  Programmers then write the source code according to the grammar.  The source code is fed to the parser, which converts the program text into some internal representation (let's call it abstract semantic graph).  This graph is then used by the interpreter, compiler, editor, or code generator. <br><br>  This is a very simplified and schematic classic of the theory of programming languages.  We will not consider it in too much detail. <br><br>  In parallel with all this, there is another area - model-oriented development, which this cycle of articles is devoted to. <br><br>  In model-oriented development, absolutely everything from the thoughts in the developer‚Äôs head to the source code, unit tests or documentation is treated as a model (this is the main, primary entity).  And the development process is the transformation of some models into others. <br><br><ol><li>  For example, first in the mind of the developer a certain image (model) of the future program appears. </li><li>  Then he transforms this mental image into a UML model. </li><li>  Based on the UML model, it writes the source code (also a model from the point of view of model-oriented development). </li><li>  For source code, it writes unit tests (and this is a model). </li><li>  Writes documentation (everything is a model). </li></ol><br>  Some of these transformations are easy to automate, others are more difficult or impossible in the short term.  But this does not change the essence - there are only models and transformations of models - nothing more (in fact, transformations are also models, but more on that in the next articles). <br><br>  Some models are very similar to each other.  For example, all UML-models are built according to certain rules in a single notation (they have a common metamodel - UML).  Some BPMN or ER models are already different from UML.  But, nevertheless, they are much closer to UML than the source code or thoughts of the programmer. <br><br>  This is due to the fact that UML, BPMN and ER are metamodels built on the basis of a single metametamodel of MOF.  And the grammar (metamodel) of a programming language is built on another metametamodel - EBNF.  The thoughts of the programmer correspond also to some metamodel, which corresponds to some metametamodel, which is currently completely unformalized. <br><br>  Each metametamodel forms its own modeling space, which is quite different from the others. <br><br><blockquote>  <b>Note</b> <br><br>  If you don‚Äôt understand what I‚Äôm talking about, you can read the first article in the cycle about <a href="http://habrahabr.ru/company/cit/blog/264963/">OCL and the metamodel</a> .  As well as an article about <a href="http://www.jot.fm/issues/issue_2006_11/article4/">modeling space</a> . <br></blockquote><br>  If it is necessary to transform models within a single modeling space (for example, MOF), then this is elementary.  There are relevant <a href="http://www.omg.org/spec/QVT/">specifications</a> and tools to which we return in the next article. <br><br>  But if it is necessary to (a) convert the source code into UML, or (b) form unit tests or documentation from BPMN models, then this is somewhat more difficult to do.  To do this, we need a bridge between two modeling spaces.  And here the theory of programming languages ‚Äã‚Äãcomes to the rescue. <br><br>  In this article we will look at the metamodel of one very simple object-oriented language (blue block in the figure), we will describe its grammar (green block in the figure).  We will also generate (in model-oriented development, it is not generally accepted to write code manually with a parser and code generator - a bridge between MOF and EBNF modeling spaces. Also, we will generate an editor for this language, in the future we will not need it, but let it be. <br><br>  For the Eclipse Modeling Framework, there are several tools that can help us with this. <br><br><h5>  <font color="#902213">MOF Model to Text Transformation Language (Acceleo)</font> </h5><br>  This is a template language for generating text from MOF models, described in <a href="http://www.omg.org/spec/MOFM2T/">the OMG specification</a> .  <a href="https://eclipse.org/acceleo/">Acceleo</a> is an implementation of the OMG specification.  The specification has not been updated since 2008, however, Acceleo has been used successfully in many projects.  The language is very simple, maybe you do not need to update anything in it.  We will look at it in one of the following articles in more detail. <br><br>  The advantage of this language is that it makes it quite easy to form text from models.  If you need to quickly form a SQL query from a UML or ER model or unload it from the model in CSV format, then this language is optimal. <br><br>  The main disadvantage is that this bridge is one-sided.  It does not allow parsing the text and turning it back into a model.  You also have to pay a lot of attention to formatting templates (spaces, line breaks) so that the resulting text is correctly formatted.  At the same time the templates themselves are not very readable. <br><br>  By the way, Acceleo is actually a template add-on over OCL.  If you read <a href="http://habrahabr.ru/company/cit/blog/264963/">this article</a> , then to master Acceleo you need to learn a few more constructions. <br><br><h5>  <font color="#902213">EMFText</font> </h5><br>  <a href="http://www.emftext.org/">EMFText</a> is a much more interesting thing than Acceleo.  You describe the metamodel and language syntax.  As a result, you get a bidirectional bridge between the MOF and EBNF modeling spaces.  A parser is automatically generated for you (from text to model), a code generator (from model to text), as well as an editor (with syntax highlighting and auto-completion) and blanks for the compiler, interpreter and debugger of the language. <br><br>  <a href="http://www.emftext.org/index.php/EMFText_Concrete_Syntax_Zoo">There</a> are examples of languages ‚Äã‚Äãimplemented using EMFText. <br><br>  In this article we will use EMFText. <br><br><h5>  <font color="#902213">Xtext</font> </h5><br>  <a href="https://eclipse.org/Xtext/">Xtext</a> is similar in functionality to EMFText.  Differs more active community.  And an approach to the generation of the parser and code generator, which depend on the Xtext runtime libraries.  Unlike EMFText, which is needed only in design-time and not needed in runtime.  For this reason, we use EMFText in our projects, and not Xtext. <br><br><h5>  <font color="#902213">Epsilon Generation Language</font> </h5><br>  An analogue of Acceleo for <a href="https://www.eclipse.org/epsilon/">Epsilon</a> . <br><br><h5>  <font color="#902213">Human Usable Textual Notation</font> </h5><br>  Also worth noting is <a href="http://www.omg.org/spec/HUTN/">OMG HUTN</a> .  This is the textual syntax for serializing MOF models.  You can take it as JSON for MOF models.  For Epsilon there is its <a href="https://www.eclipse.org/epsilon/doc/hutn/">implementation</a> .  However, this thing does not suit us, because we will need to describe an arbitrary syntax, and not just with curly braces. <br><br><h4>  <font color="#902213"><b>Some theory</b></font> </h4><br>  Before moving on to practice, you still need a bit of theory. <br><br><blockquote>  <b>Note</b> <br><br>  This section does not pretend to be complete, nor to accuracy.  Everything is described in a very simplified and schematic way, only so that the following sections are understandable.  If you are interested in the theory of programming languages, it is better to refer to sources that are devoted to this topic. </blockquote><br>  We are building a bridge between the EBNF and MOF simulation spaces.  On one side of the bridge, the source code, on the other, a certain model of the program (for definiteness, we will call it an abstract semantic graph). <br><br>  Usually the abstract semantic graph is hidden from the programmer.  How exactly it is arranged is a question of the implementation of a compiler or interpreter.  Programmers with this graph do not work directly, they work only with source code. <br><br>  In model-oriented development, the abstract semantic graph, on the other hand, plays a key role.  This is not some kind of technical internal structure of the parser, but a model with which the programmer will work.  It is important for the programmer how exactly this model is designed, how comfortable it is. <br><br><blockquote>  <b>Note</b> <br><br>  Of course, when programmers use the reflective capabilities of the language, they work with the program model, not the source code.  But at the same time, they, probably, not understanding this themselves, fall into the field of model-oriented development.  They view the program as a model. </blockquote><br>  The figure schematically shows how the parser and the language code generator work. <br><br><img src="https://habrastorage.org/files/e02/acd/493/e02acd4933b54bfb82df9f919a79bb4f.png"><br><br><h5>  <font color="#902213">Lexical analysis</font> </h5><br>  First, a lexical analysis of the source code is performed, as a result of which the text is divided into a sequence of tokens.  Usually the lexer selects tokens using context-independent regular expressions.  It is for this reason in the languages <br><br><ul><li>  there are reserved words that cannot be used in identifiers so that the lexer can distinguish the keyword from the identifier; </li><li>  text literals are quoted so that the lexer can distinguish them from reserved words or identifiers; </li><li>  identifiers cannot begin or consist entirely of numbers; otherwise, it would be difficult for a lecturer to understand this identifier or a numeric literal. </li></ul><br>  Those.  whenever possible, regular expressions for different types of tokens should not intersect.  Unfortunately, sometimes they still intersect.  Sometimes this is not a problem.  And sometimes this leads to the complication of the grammar of the language - we will face this situation in the next article about the SQL parser. <br><br><h5>  <font color="#902213">Parsing</font> </h5><br>  Then, a sequence of tokens is parsed.  The parser, looking at the grammar of the language, organizes the tokens into a specific syntax tree.  The structure of this tree is identical to the EBNF grammar of the language: <br><br><ul><li>  for the initial non-terminal symbol, the root node of the tree is constructed, </li><li>  for other non-terminal symbols, internal nodes of the tree are built, </li><li>  for terminal symbols (tokens, tokens) leaf tree nodes are built. </li></ul><br><h5>  <font color="#902213">Simplification of a specific syntax tree</font> </h5><br>  It is usually very inconvenient to work with a specific syntax tree, even for very simple languages ‚Äã‚Äãit turns out to be very deep. <br><br>  In one of the following articles, we will probably consider a language for arithmetic expressions.  You will see that the particular syntax tree for such a language resembles the Tower of Pisa. <br><br>  For simple languages, it is enough to remove the extra intermediate floors of the tower.  More complex languages ‚Äã‚Äãrequire more complex simplifications.  As a result, we get an abstract syntax tree. <br><br>  Each tree node will be an object of a certain class.  Although, in general, this is not necessary, we could easily do without classes and objects, by representing the tree, for example, in the form of an XML document.  But we need exactly the object model, because the MOF to which we are moving is object.  If we built a bridge to some modeling space other than MOF, then we would need not an object model of the program, but some other one. <br><br><h5>  <font color="#902213">Semantic analysis</font> </h5><br>  Obviously, the program written in relatively complex language, we can not imagine in the form of a tree.  For example, if this language allows you to declare variables, classes, types, functions, and then refer to them, then by resolving such text links we get an abstract semantic graph. <br><br><h5>  <font color="#902213">Code Generation</font> </h5><br>  Kodogeneration is a reverse parsing process, when a textual representation of a program is formed from some abstract representation of a program (for example, in the form of an abstract semantic graph). <br><br>  There are two approaches to code generation: templates and a universal code generator. <br><br>  When using templates, an approximate text of the future program is written.  For example, the names of classes, variables, functions in this text are replaced by special sequences of characters, instead of which actual names are substituted instead.  Obviously, arbitrary code cannot be generated using templates. <br><br>  A universal code generator accepts a certain program model as an input (for example, an abstract semantic graph), and outputs the corresponding source code at the output.  Thus any code can be generated.  However, implementing a universal code generator is much more difficult than a template.  There may also be difficulties with formatting the result code.  We need either additional annotations in the model containing information about spaces, line breaks, etc.  Or you need a code formatter, which also needs to be written or taken somewhere.  In the version with templates, this is not necessary, you format everything right in the template right in the template. <br><br>  Fortunately, EMFText automatically generates a code generator with the simplest code formatting options. <br><br><h4>  <font color="#902213"><b>Customization</b></font> </h4><br>  As usual, you will need <a href="https://www.eclipse.org/downloads/">Eclipse Modeling Tools</a> .  Install the latest version of <a href="http://www.emftext.org/index.php/EMFText_Download">EMFText</a> from here <a href="http://emftext.org/update_trunk">http://emftext.org/update_trunk</a> . <br><br><h4>  <font color="#902213"><b>Project creation</b></font> </h4><br>  Unlike previous articles, there is no finished project.  Yes, it is not needed, use the project that is created by default (File -&gt; New -&gt; Other ... -&gt; EMFText Project). <br><br><img src="https://habrastorage.org/files/f31/597/4ad/f315974ad47742e5858e62e85a50e971.png"><br><br>  In the metamodel folder, you will see blanks for the language's metamodel (myDSL.ecore) and its grammar (myDSL.cs).  These two files completely describe the language.  Almost everything else is generated from them. <br><br><img src="https://habrastorage.org/files/05c/9d1/2e4/05c9d12e46504e29ae8085bf481b1cd7.png"><br><br>  In this article, we will limit ourselves to this simple demo DSL. <br><br><h4>  <font color="#902213"><b>Metamodel language</b></font> </h4><br>  Metamodel is what language is about.  For example, a Java metamodel will contain metaclasses: a class, a method, a variable, an expression, etc.  You cannot describe something in the language that is not in its metamodel.  For example, in Java 7 metamodel there are no lambda expressions.  Therefore, they are not valid in code that is written under Java 7. <br><br>  The following image shows the metamodel of the demo object-oriented language that EMFText generated for us. <br><br><img src="https://habrastorage.org/files/090/bec/35a/090bec35a59442ae862c720f525319a7.png"><br><blockquote>  <b>Note</b> <br><br>  If you do not understand what is shown in the figure, then you can read <a href="http://habrahabr.ru/company/cit/blog/266433/">an article about the Eclipse Modeling Framework</a> . </blockquote><br>  Our domain-specific language allows us to describe an entity model (EntityModel), which consists of two types of (Type): entities (Entity) and data types (DataType).  Entities can be abstract.  An entity can have three types of properties (Feature) (FeatureKind): attributes (attribute), references (reference) and components (containment).  The properties are very simple, they do not even have multiplicity. <br><br>  In theory, attributes should only refer to data types.  And links and components should only refer to entities.  But in this metamodel at the structural level, this is not limited.  You can easily make a data type an integral part of an entity, or you can specify an entity as an attribute type instead of a data type.  Which is probably not very correct.  This can be corrected in two ways: 1) at the structural level or 2) with the help of additional restrictions. <br><br>  In the first case, for each type of properties a separate metaclass is created (this is how the metametamodel Ecore itself is implemented).  Those.  remove the FeatureKind enumeration, delete the type association, make the Feature metaclass abstract and inherit three metaclasses from it: Attribute, Reference and Containment.  First add the link to DataType, and the second and third - to the Entity. <br><br>  The second method is described in the <a href="http://habrahabr.ru/company/cit/blog/264963/">article about OCL</a> . <br><br>  We will not correct this defect.  Moreover, he will even further help us understand the mechanism for resolving links. <br><br><h4>  <font color="#902213"><b>Launch the language editor</b></font> </h4><br>  So, we have more or less dealt with the metamodel of the demo object-oriented language that EMFText has generated for us.  Before proceeding to the description of the syntax of this language, let's look at an example of source code. <br><br>  To do this, create and run a second instance of Eclipse (Run -&gt; Run Configurations ...): <br><br><img src="https://habrastorage.org/files/092/6e1/08e/0926e108edeb49928e61ec565c3a97b3.png"><br><br>  In the second instance of Eclipse, create a new myDSL project (File -&gt; New -&gt; Other ... -&gt; EMFText myDSL project): <br><br><img src="https://habrastorage.org/files/516/d52/957/516d529574734172a22ee5348eaa9586.png"><br><br>  In the figure below, you see an example of code written in myDSL.  As you can see, our domain-specific language really allows us to describe entities, properties, data types. <br><br>  At the bottom left is the syntactic tree that corresponds to the language's metamodel.  Bottom right properties of one of the nodes of the tree, which also correspond to the metamodel.  If you want to get some other syntax tree (add new types of nodes to it, new properties of nodes), then you need to change the metamodel of the language. <br><br><img src="https://habrastorage.org/files/74b/da7/55f/74bda755fa664df88c8b95512aec8bb6.png"><br><br>  You can see that the editor has syntax highlighting.  Later we will improve it a little. <br><br>  Also, via Ctrl + Space, autocompletion is called, which by default does not work as we would like.  For attributes, only data types should be offered, not entities.  We will fix this later. <br><br><img src="https://habrastorage.org/files/be0/894/5de/be08945deeb645ddb84c47344a001a0a.png"><br><br><h4>  <font color="#902213"><b>Description of the specific syntax</b></font> </h4><br>  Now that you have seen the sample code on the test DSL, let's go back to the syntax description in the file myDSL.cs. <br><br><img src="https://habrastorage.org/files/a1a/d18/675/a1ad1867512d40e4b91518529ce1d4c6.png"><br><br>  Line 1 indicates the file extension of the described DSL. <br><br>  Line 2 indicates the metamodel namespace described by DSL. <br><br>  Line 3 indicates the initial non-terminal grammar symbol and part-time root metaclass of the syntax tree. <br><br>  Line 6 indicates one of the EMFText parameters.  There are hundreds of such order parameters, you can independently get acquainted with them in the <a href="http://www.emftext.org/EMFTextGuide.php">manual</a> . <br><br>  Next come the grammar rules of the language.  You can see that the rule description language is very similar to EBNF.  However, the names of non-terminal symbols on the left side of the rule must match the name of some metaclass from the metamodel of the language.  And the names of (non) terminal symbols in the right part of the rule must match the names of some properties of this metaclass. <br><br>  The multiplicity of symbols in the right part of the rules must correspond to the multiplicity of the corresponding properties in the metamodel. <br><br>  Let's sort the rules in more detail. <br><br>  In line 10, we state that any code on our DSL must begin with the keyword ‚Äúmodel‚Äù, followed by a description of several types.  And, as you should remember, in a metamodel there are two types of entities: entities (Entity) and data types (DataType). <br><br>  Line 11 describes the syntax for the entities.  The description of the entity can begin with the keyword "abstract", in this case the entity property of the same name in the syntactic tree will be set to its true value.  Then, the ‚Äúentity‚Äù keyword must be followed. <br><br>  Then follows the name of the entity, which will be stored in the name property.  In brackets should indicate the type of token for names.  In this case, it is not specified, so the parser will wait for the default token - TEXT.  We will return to tokens a bit later. <br><br>  Then in curly brackets should list the properties (features) of the entity.  This is a non-terminal symbol ‚Äî the grammar for properties has its own rule (line 13), and in the metamodel there is a separate metaclass.  Therefore, there are no square brackets, it is not possible to specify the type of token. <br><br>  Line 12 describes the syntax for data types.  The description of the data type must begin with the keyword "datatype", followed by the type name and a semicolon. <br><br>  Line 13 describes the syntax for the properties of the entities.  A property description can begin with one of three key properties (‚Äúatt‚Äù, ‚Äúref‚Äù or ‚Äúcont‚Äù).  In the syntax tree, depending on the specified keyword, the node's kind property will take one of the values ‚Äã‚Äãof the FeatureKind enumeration. <br><br>  Further, the type of the property, the name of the property and a semicolon should follow.  Moreover, the property type in the code is specified as a character string, but in the syntax tree, the link by name turns into a physical link to the corresponding type.  Thus, when parsing, we get a graph, not a tree.  We will return to link resolution later. <br><br>  In general, what exactly we get when parsing is not a very trivial question.  On the one hand, the resulting structure almost completely duplicates the grammar of the language and, sort of like, this particular syntax tree.  On the other hand, EMFText resolves symbolic links, turning a particular syntax tree into an abstract semantic graph.  It also allows you to fasten post-processors to the parser, with which you can simplify the model. <br><br>  In other words, the parser produces at the output some kind of hybrid of a specific syntax tree and an abstract semantic graph.  For such a simple language is not very important.  But in the next article, when developing a metamodel for SQL, we‚Äôll have to come back to the question ‚Äúwhat metamodel are we doing: concrete or abstract?‚Äù. <br><br><h4>  <font color="#902213"><b>Adding new types of tokens</b></font> </h4><br>  Now let's improve DSL a bit.  In myDSL.cs, after some terminal characters (name and type) there are empty square brackets.  For these characters, the default token TEXT with a pattern is used. <br><br> <code>('A'..'Z'|'a'..'z'|'0'..'9'|'_'|'-')+</code> <br> <br>  This means that entity names can consist entirely of decimal digits or begin with a minus, which is probably not very correct. <br><br><blockquote>  <b>Note</b> <br><br>  Also, entity names cannot contain non-Latin letters, probably, our language support would not be hindered by unicode support. <br><br>  EMFText uses regular ANTLR expressions that support unicode, but do not support character classes.  Therefore, it is necessary to explicitly enumerate the ranges of valid characters.  Let's not bother with it yet. </blockquote><br>  So, let type names begin only with a capital letter of the Latin alphabet and cannot begin with other characters.  And the names of the properties - only with a lowercase letter of the Latin alphabet. <br><br>  To describe new types of tokens, create a TOKENS section (lines 9-16). <br><br><img src="https://habrastorage.org/files/204/9d5/298/2049d52981a64931975b506b1c2e3c13.png"><br><br>  In lines 10-12, fragments of tokens are defined. <br><br>  In lines 14 and 15, tokens are defined, respectively, for type names and property names. <br><br>  In lines 20-22, the tokens expected by the parser are indicated in square brackets. <br><br>  However, there is a problem.  Regular expressions for new tokens intersect with the default token TEXT, about which we get a warning (see the figure above).  What can this lead to? <br><br>  For example, in the source code the entity "Car" is defined.  The name of this entity matches both regular expressions: TEXT and TYPE_NAME.  If the lexer decides that ‚ÄúCar‚Äù is a TYPE_NAME, then everything will be fine.  But if he decides that this is TEXT, then at the next stage of parsing the source code, the parser will produce an error like this: ‚ÄúAfter the keyword‚Äú entity ‚Äùthe token TYPE_NAME is expected, and the token TEXT is indicated‚Äù. <br><br><blockquote>  <b>Note</b> <br><br>  If you do not understand the meaning of the previous paragraph, then look at the picture in the ‚ÄúSome theory‚Äù section above and read the subsections on lexical and syntactic analysis. </blockquote><br>  There are several ways to resolve this uncertainty: <br><br><ol><li>  Rely on EMFText for more specific tokens to assign a higher priority by default.  Those.  first the lexer will search for TYPE_NAME and FEATURE_NAME, and then TEXT. </li><li>  Set priorities for tokens manually. </li><li>  Remove excess tokens. </li><li>  Complicate grammar.  For example, instead of ‚Äúname [TYPE_NAME]‚Äù write ‚Äúname [TYPE_NAME] |  name [TEXT] ". </li></ol><br>  In this case, we do not need the TEXT token, so we will simply remove it.  To do this, in line 7, disable the predefined tokens: TEXT, LINEBREAK and WHITESPACE.  But we still need the last two tokens, so we will define them explicitly in lines 18 and 19. <br><br><img src="https://habrastorage.org/files/d04/1f2/cde/d041f2cde1304ba1bb2090e9cdff58aa.png"><br><br>  Now right-click on the project in the tree on the left and in the pop-up menu that appears, select "Generate All (EMFText)".  After the source code is regenerated, launch a second instance of Eclipse. <br><br>  Now if you write the name of the entity with a lowercase letter, the lexer interprets it as the property name (FEATURE_NAME), and the parser will generate an error that the token TYPE_NAME was expected. <br><br>  If you start the attribute name with the underscore "_", then the lexer will not understand at all what kind of token it is. <br><br><img src="https://habrastorage.org/files/098/453/ebb/098453ebb3424474af575d8616ed93b1.png"><br><br><h4>  <font color="#902213"><b>Syntax highlighting</b></font> </h4><br>  By default, EMFText colors all keywords in purple.  Add a little more colors, for this, create a TOKENSTYLES section (lines 22-27). <br><br><img src="https://habrastorage.org/files/2b7/19d/9bd/2b719d9bd2d9435ea7e1ca5361a24ac2.png"><br><br>  Regenerate the ‚ÄúGeneate All (EMFText)‚Äù source code and launch a second instance of Eclipse. <br><br>  It looks scary, but you get the idea :) Please note that ‚Äúcar‚Äù is painted in blue, not pink.  This is due to the fact that the lexer selects tokens using context-independent regular expressions.  He does not know that there should be the name of the entity, and not the name of the property. <br><br><img src="https://habrastorage.org/files/bab/7b1/196/bab7b11964e1423986f0898542e97fbb.png"><br><br><h4>  <font color="#902213"><b>Link resolution</b></font> </h4><br>  Earlier, I drew your attention to the fact that autocompletion of type names in definitions of properties of entities does not work very well.  For attributes (att), only data types should be offered, and for references (ref) and component parts (cont), only entities should be offered. <br><br>  In the org.emftext.language.myDSL.resource.myDSL project, find the FeatureTypeReferenceResolver class that is responsible for autocompletion and link resolution. <br><br>  The resolve method must look for matching types.  If the resolveFuzzy parameter has a true value, then the method should look for types that roughly fit the specified string (this happens when autocompleting the type name).  Otherwise, the method must search for the type with the specified name. <br><br>  The deResolve method should, for reference in an abstract semantic column, return its textual representation in the source code. <br><br>  Here is one of the implementations for resolving type references: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> org.emftext.language.myDSL.resource.myDSL.analysis; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Consumer; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.function.Predicate; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.stream.Stream; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.eclipse.emf.ecore.EReference; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.eclipse.emf.ecore.util.EcoreUtil; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.DataType; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.Entity; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.EntityModel; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.Feature; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.FeatureKind; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.Type; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.resource.myDSL.IMyDSLReferenceResolveResult; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.emftext.language.myDSL.resource.myDSL.IMyDSLReferenceResolver; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureTypeReferenceResolver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IMyDSLReferenceResolver</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Feature</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Type</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      ,    identifier public void resolve(String identifier, Feature container, EReference reference, int position, boolean resolveFuzzy, final IMyDSLReferenceResolveResult&lt;Type&gt; result) { //        . //    containment-      owner, //      container.getOwner().getOwner() EntityModel model = (EntityModel) EcoreUtil.getRootContainer(container); //       ,    , //    Predicate&lt;Type&gt; isRelevant = container.getKind() == FeatureKind.ATTRIBUTE ? type -&gt; type instanceof DataType : type -&gt; type instanceof Entity; Stream&lt;Type&gt; types = model.getTypes().stream().filter(isRelevant); //            Consumer&lt;Type&gt; addMapping = type -&gt; result.addMapping(type.getName().toString(), type); //        ,   , //          if (resolveFuzzy) { types.filter(type -&gt; type.getName().toUpperCase().startsWith(identifier.toUpperCase())) .forEach(addMapping); } //  (   ),         else { types.filter(type -&gt; type.getName().equals(identifier)) .findFirst() .ifPresent(addMapping); } } //       ( ) public String deResolve(Type element, Feature container, EReference reference) { return element.getName(); } public void setOptions(Map&lt;?, ?&gt; options) { } }</span></span></code> </pre> <br><h4>  <font color="#902213"><b>Code Generation</b></font> </h4><br>  With the parser and the editor in the first approximation figured out.  Only code generation is left. <br><br>  The syntax tree in the lower left corner is available only for viewing.  To be able to edit it, save the file in the xmi format (File -&gt; Save As ...). <br><br>  If an error occurs that the file cannot be opened using MyDSLEditor, then ignore it and rediscover the xmi file.  You will see the same syntax tree, however, it can now be edited. <br><br><img src="https://habrastorage.org/files/cd3/140/cae/cd3140caef2d4c44bb29d9a5397566ae.png"><br><br>  Rename the ‚ÄúCar‚Äù entity to ‚ÄúVehicle‚Äù and set the true value of the ‚ÄúAbstract‚Äù property. <br><br>  Save the xmi file with the myDSL extension.  Close it and open it again: <br><br><img src="https://habrastorage.org/files/415/bb0/654/415bb065429146818e7c76c1daca585b.png"><br><br>  As you can see, our changes to the syntax tree are taken into account!  Those.  Model to text conversion (code generation) works. <br><br>  True, while saving, line breaks and some spaces disappeared. <br><br>  There are three ways to achieve normal formatting of the generated code: <br><br><ol><li>  Modify the metamodel by adding links to each metaclass to the metaclass LayoutInformation from the metamodel <a href="http://www.emftext.org/commons/layout">www.emftext.org/commons/layout</a> .  I personally did not do this, and I have a feeling that this would have to count the number of gaps required, calculate shifts in the text, etc.  - it looks very difficult. </li><li>  Use a separate code formatter.  Probably, this is the best option when generating Java code or something, for which there is already a ready formatter. </li><li>  Add a few annotations to the grammar of the language so that the default code generator will format the code a little better.  This is the easiest option, so do. </li></ol><br>  In lines 30 and 31 added annotations "! 0", "! 1" and "# 1".  These annotations are ignored by the parser; they are intended for the code generator.  The abstract "#N" tells the code generator that it is necessary to insert N spaces in this place.  And the summary "! N" denotes line feed and N tabs. <br><br><img src="https://habrastorage.org/files/56d/9c5/89c/56d9c589cd5140efb9b878ff35672c38.png"><br><br>  Regenerate the ‚ÄúGeneate All (EMFText)‚Äù source code and restart the second instance of Eclipse.  Try to save the model again in text format and make sure that the code is now better formatted. <br><br><h4>  <font color="#902213"><b>Conclusion</b></font> </h4><br>  After reading this article, you need to take a fresh look at software development ‚Äî through the prism of models and model conversions. <br><br>  Models can be represented in different notations (in the form of <a href="http://habrahabr.ru/company/cit/blog/267335/">diagrams</a> , <a href="http://habrahabr.ru/company/cit/blog/269291/">tables</a> , text).  From the point of view of model-driven development, a domain-specific language is just one of the notations for some metamodel. <br><br>  On the other hand, the grammar of a subject-oriented language is a metamodel in the EBNF <a href="http://www.jot.fm/issues/issue_2006_11/article4/">modeling space</a> .  And the source code is a model in this modeling space. <br><br>  A parser is the transformation of a model from an EBNF modeling space into a model in a MOF modeling space or another. <br><br>  A code generator is the inverse transformation of a model from a semantic-oriented modeling space (for example, MOF) into an EBNF modeling space. <br><br>  You also got acquainted with one of the programming language development tools - EMFText. </div><p>Source: <a href="https://habr.com/ru/post/270483/">https://habr.com/ru/post/270483/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270471/index.html">What's new and interesting in IntelliJ IDEA 15</a></li>
<li><a href="../270473/index.html">How to cook DTO?</a></li>
<li><a href="../270475/index.html">Draft Doctrine of Information Security of the Russian Federation</a></li>
<li><a href="../270479/index.html">Methods of treating various errors in Android Studio during project development</a></li>
<li><a href="../270481/index.html">Itseez summer schools on computer vision: how it was</a></li>
<li><a href="../270485/index.html">Unit testing your Ionic application</a></li>
<li><a href="../270487/index.html">Manipulating stock prices with the help of fake news: How not to fall for it</a></li>
<li><a href="../270489/index.html">The tambourine exists. Proven Alloy Software</a></li>
<li><a href="../270491/index.html">Global Day of Code Retreat: free developer training</a></li>
<li><a href="../270493/index.html">5 principles of working with knowledge for the engineer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>