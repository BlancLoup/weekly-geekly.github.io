<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Read and write NFC Tag on MeeGo Harmattan</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post participates in the competition " Smart phones for smart posts " 

 Introduction 
 What is NFC? 
 According to Wikipedia, NFC (Near Field Co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Read and write NFC Tag on MeeGo Harmattan</h1><div class="post__text post__text-html js-mediator-article">  This post participates in the competition " <a href="http://habrahabr.ru/company/Nokia/blog/132522/">Smart phones for smart posts</a> " <br><br><h4><a name="Intro"></a>  Introduction </h4><br><h5>  What is NFC? </h5><br><img src="https://habrastorage.org/storage1/e2fb8428/2f50ab50/0b14d17d/874485a1.gif" align="left">  According to Wikipedia, <i>NFC (Near Field Communication)</i> is a short-range wireless high-frequency communication technology that allows data to be exchanged between devices located at a distance of about 10 centimeters. <br><br>  There are three most popular options for using <i>NFC</i> technology in mobile phones: <br>  card emulation - the phone pretends to be a card, such as a pass or a payment card; <br>  Read mode - the phone reads a passive tag (Tag), for example, for interactive advertising; <br>  P2P mode - two phones communicate and exchange information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We will consider the second method of use, namely reading a passive tag, moreover, we will also learn how to record information on such tags using a phone <br><br><h5>  What a story? </h5><br>  I will talk not only about the methods of working with NFC, but also about the user interface developed by me specifically for this article program.  That is, in the process of reading you will pass the full path of creating an application for working with the NFC Tag for MeeGo Harmattan. <br><br><h4>  Table of contents </h4><br><ul><li>  <a href="https://habr.com/ru/post/133471/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/133471/">Program logic</a> </li><li>  <a href="https://habr.com/ru/post/133471/">Program interface</a> </li><li>  <a href="https://habr.com/ru/post/133471/">We connect all together</a> </li><li>  <a href="https://habr.com/ru/post/133471/">Conclusion</a> </li></ul><br><br><img src="http://qt.nokia.com/qt-in-use/ambassadors/qt_ambassador_logo.png/image_thumb" alt="Qt Ambassador" align="left"><br>  <b>UPDATE:</b> Today, <i>12/20/2011</i> , a letter came that the application was received in <i>Qt Ambassador</i> <br>  <b>UPDATE: The</b> night passed and the project was published in the program: <a href="http://qt.nokia.com/qt-in-use/ambassadors/project%3Fid%3Da0F2000000BDk3REAT">Qt Ambassador Showcase</a> <br><br><a name="habracut"></a><br><br><h5>  What is the NFC Tag? </h5><br><img src="https://habrastorage.org/storage1/f1af7b27/7c0de927/4203a8b2/bc8a8223.jpg" align="left">  <i>NFC Tag</i> is our passive tag.  The picture shows the appearance of how it may look, that is, as a rule, it is a sticker made of thick paper, which has a microchip and an antenna made of foil.  NFC tags are of several types, the type of maximum data size also depends on the type.  I am the proud owner of several Type 2 labels, 192 bytes, brought from <i>Qt Developer Days 2011</i> .  Well, 192 bytes are not thick, but enough for our experiments. <br><br><h4><a name="Backend"></a>  Program logic </h4><br><h5>  Force the application to intercept NFC processing. Tags </h5><br>  So, in order to start processing tags, we need an object of class <i>QNdefManager</i> <br><pre><code class="cpp hljs">NfcManager::NfcManager(QObject *parent) : QObject(parent), m_manager(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QNearFieldManager(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)), m_cachedTarget(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_mode(NfcManager::Read) { connect(m_manager, SIGNAL(targetDetected(QNearFieldTarget*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(targetDetected(QNearFieldTarget*))); connect(m_manager, SIGNAL(targetLost(QNearFieldTarget*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(targetLost(QNearFieldTarget*))); m_manager-&gt;setTargetAccessModes(QNearFieldManager::NdefReadTargetAccess | QNearFieldManager::NdefWriteTargetAccess); }</code> </pre> <br>  Create it in the constructor of our class <i>NfcManager</i> , which we will use to work with NFC.  We definitely need to connect the <i>targetDetected</i> and <i>targetLost signals of</i> this object to our slots, which, in fact, will be the main event handlers for the appearance of a tag in the field of view of the phone.  In the third line of the constructor, we set the read and write mode so that we can not only read but also write tags. <br><br><h5>  Interceptor </h5><br>  Now consider the described slots: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::targetDetected(QNearFieldTarget *target) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_cachedTarget) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_cachedTarget; m_cachedTarget = target; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_mode == Read) readTarget(m_cachedTarget); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_mode == Write) writeTarget(m_cachedTarget); }</code> </pre><br>  When a tag is detected, we just in case save a pointer to an object of type <i>QNearFieldTarget</i> , which is the program interface to the tag itself. <br>  Then there are two conditions and, depending on the mode (read or write), call the appropriate processing methods.  From the point of view of beautiful architecture, this is not the best solution, but I did it intentionally, so as not to complicate the code. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::targetLost(QNearFieldTarget *target) { m_cachedTarget = <span class="hljs-number"><span class="hljs-number">0</span></span>; target-&gt;deleteLater(); }</code> </pre><br>  If you lose a tag, we simply release the resources that are used. <br><br><h5>  Reading </h5><br>  Now consider the tag reading methods: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::readTarget(QNearFieldTarget *target) { connect(target, SIGNAL(error(QNearFieldTarget::Error,QNearFieldTarget::RequestId)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(errorHandler(QNearFieldTarget::Error,QNearFieldTarget::RequestId))); connect(target, SIGNAL(ndefMessageRead(QNdefMessage)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(readRecords(QNdefMessage))); target-&gt;readNdefMessages(); }</code> </pre><br>  Reading takes place in asynchronous mode, so in this method we simply connect the error handling signal and the read completion signal, which will be called only if the reading has occurred without errors. <br>  After that, we simply call the method to read: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::readRecords(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QNdefMessage &amp;message) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; QNdefRecord record = message.at(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Read only first readRecord(record); }</span></span></code> </pre><br>  If the reading was successful, we will get into this slot, where we will get the first record from the list of records present on the tag. <br>  Yes, according to the specification there can be several entries on the tag, but as the documentation says, for <i>Symbian</i> and <i>Harmattan</i> only one entry is read and written. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::readRecord(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QtMobility::QNdefRecord &amp;record) { DataContainer *result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record.isRecordType&lt;QNdefNfcUriRecord&gt;()) { <span class="hljs-function"><span class="hljs-function">QNdefNfcUriRecord </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uriRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(record)</span></span></span></span>; result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UriDataContainer(uriRecord.payload(), uriRecord.uri().toString()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record.isRecordType&lt;QNdefNfcTextRecord&gt;()) { QNdefNfcTextRecord textRecord(record); result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextDataContainer(textRecord.payload(), textRecord.text()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record.isRecordType&lt;NdefNfcSmartPosterRecord&gt;()) { NdefNfcSmartPosterRecord smartPosterRecord(record); result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SmartPosterDataContainer(smartPosterRecord.payload(), smartPosterRecord.uri().toString(), smartPosterRecord.title()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DataContainer(record.payload()); } <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagReadFinished</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span></span>; }</code> </pre><br>  And so, after several transitions on auxiliary methods, we got to the most important method, which turns the information encoded into tags into letters familiar to us. <br>  At the moment, <i>Qt Mobility</i> out of the box only supports two types of entries: links ( <i>Uri</i> ) and text ( <i>Text</i> ), to the third type - <i>Smart Poster,</i> we will return below. <br>  As you can see, the data from the record is immediately placed in a new object, these are simple objects that I specifically created to facilitate the transfer of data in <i>QML</i> <br><br>  At the end, a signal containing the data object is called.  In the future, we will catch this signal in QML. <br><br><h5>  Record </h5><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::setDataForWrite(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;text, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;uri) { m_textForWrite = text; m_uriForWrite = uri; }</code> </pre><br>  This method must be called before attempting to write in order to set new values ‚Äã‚Äãfor Uri and / or Text.  If you do not call it on the tag will be recorded previous data (this approach is useful if you want to write a lot of tags of the same type) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NfcManager::writeTarget(QNearFieldTarget *target) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_textForWrite.isEmpty() &amp;&amp; m_uriForWrite.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; m_cachedTarget = target; QNdefMessage message; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_textForWrite.isEmpty() &amp;&amp; !m_uriForWrite.isEmpty()) { NdefNfcSmartPosterRecord smartPosterRecord; smartPosterRecord.setTitle(m_textForWrite); smartPosterRecord.setUri(QUrl(m_uriForWrite)); message.append(smartPosterRecord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_textForWrite.isEmpty()) { QNdefNfcTextRecord textRecord; textRecord.setText(m_textForWrite); message.append(textRecord); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { QNdefNfcUriRecord uriRecord; uriRecord.setUri(QUrl(m_uriForWrite)); message.append(uriRecord); } connect(target, SIGNAL(error(QNearFieldTarget::Error,QNearFieldTarget::RequestId)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(errorHandler(QNearFieldTarget::Error,QNearFieldTarget::RequestId))); connect(target, SIGNAL(ndefMessagesWritten()), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SIGNAL(tagWriteFinished())); target-&gt;writeNdefMessages(QList&lt;QNdefMessage&gt;() &lt;&lt; message); }</code> </pre><br>  The main writing method is as simple as reading.  In the condition block, we simply select the type of record.  If only Uri or Text is present, then the corresponding type is created, if both fields are filled in, a Smart Poster type record is created. <br>  After that, we re-enable the error handler.  But pay attention, because in the backend we do not need any processing logic to successfully complete the read, we forward the signal to the signal, which we will later catch in QML. <br><br><h5>  Smart Poster, what is it? </h5><br>  So, the Smart Poster is a special kind of NFC recording that can simultaneously contain a link, a text title (in several languages), graphic icons in <i>jpeg</i> or <i>png</i> formats, and even an animated icon in mpeg format. <br>  In addition, there may be two more fields: <br>  <i>Action</i> - tells the phone which application and how to open uriRecord for processing <br>  <i>Size</i> is a simple integer that displays the size of the downloadable content by reference. <br><br><h5>  We write our class for Smart Poster </h5><br>  Below I will tell you how to create your own type of <i>NDEF</i> entry using the example of creating a type for a smart poster entry. <br>  Immediately make a reservation that my type is simplified.  It does not support neither Action nor Size, nor even icons, but it allows you to simultaneously store text and a link. <br><br>  This is the announcement for the class of our Smart Poster: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NdefNfcSmartPosterRecord</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QNdefRecord { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Q_DECLARE_NDEF_RECORD(NdefNfcSmartPosterRecord, QNdefRecord::NfcRtd, <span class="hljs-string"><span class="hljs-string">"Sp"</span></span>, QByteArray()) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTitle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;title, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;locale = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"en"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QUrl &amp;uri)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">QString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">title</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;locale = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"en"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">QUrl </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add icon, action and size fields support private: RecordPart readPart(int &amp;offset) const; }; Q_DECLARE_ISRECORDTYPE_FOR_NDEF_RECORD(NdefNfcSmartPosterRecord, QNdefRecord::NfcRtd, "Sp")</span></span></code> </pre><br>  So, the Qt Mobility developers have already taken care to make it easier for us to live, and have created two special macros that do all the most rough work. <br><br>  Parameters for macros are: class name, record type (for Smart Poster, this is <i>QNdefRecord :: NfcRtd</i> ) and ‚ÄúType Name‚Äù - an abbreviation for recognition in the tag.  And also the last parameter in <i>Q_DECLARE_NDEF_RECORD</i> is the data for the initial initialization of the data, in our case it is an empty byte array. <br><br>  Now look at the implementation of the methods of reading and writing. <br><br>  Simple structure for storing a disassembled part of a record <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RecordPart</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { Uri, Text, Action, Icon, Size, Unknown }; Type type; QString text; QString locale; <span class="hljs-comment"><span class="hljs-comment">// For text type quint8 prefix; // For Uri type RecordPart() : type(Unknown), text(QString()), locale(QString()), prefix(0) { } };</span></span></code> </pre><br><br>  First, consider the methods for reading: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> abbreviations[] = { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"http://www."</span></span>, <span class="hljs-string"><span class="hljs-string">"https://www."</span></span>, <span class="hljs-string"><span class="hljs-string">"http://"</span></span>, <span class="hljs-comment"><span class="hljs-comment">//    "urn:epc:", "urn:nfc:", };</span></span></code> </pre><br>  An array of various prefixes for <i>uri</i> supported by the specification. <br><br><pre> <code class="cpp hljs">QUrl NdefNfcSmartPosterRecord::uri() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray p = payload(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QUrl(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; QString uri; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (offset &lt; p.size()) { RecordPart part = readPart(offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (part.type == RecordPart::Uri) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (part.prefix &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; part.prefix &lt; (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(abbreviations) / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(*abbreviations))) uri = QString(abbreviations[part.prefix]) + part.text; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (uri.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QUrl(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QUrl(uri); }</code> </pre><br>  The uri read method is fairly simple at first glance - we load all the bytes read from the record into <b><i>p</i></b> , and then read the parts in the array until we find the Uri type part (according to the specification it can be only one) <br>  The ‚Äúmagic‚Äù <i>readPart</i> method <i>will</i> be discussed below. <br><br><pre> <code class="cpp hljs">QString NdefNfcSmartPosterRecord::title(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;locale) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray p = payload(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = <span class="hljs-number"><span class="hljs-number">0</span></span>; QMap&lt;QString, QString&gt; title; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (offset &lt; p.size()) { RecordPart part = readPart(offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (part.type == RecordPart::Text) { title.insert(part.locale, part.text); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (title.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (title.contains(locale)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> title.value(locale); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (title.contains(<span class="hljs-string"><span class="hljs-string">"en"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> title.value(<span class="hljs-string"><span class="hljs-string">"en"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> title.constBegin().value(); }</code> </pre><br>  The method for <i>title</i> differs only in that there may be many titles in different languages.  Therefore, we first select them all, and then try to find the right one. <br><br>  All the magic happens in the readPart method, which turns the internal recording format into a simple and clear structure <i>RecordPart</i> <br><pre> <code class="cpp hljs">RecordPart NdefNfcSmartPosterRecord::readPart(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;offset) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { RecordPart result; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QByteArray p = payload(); ..... <span class="hljs-comment"><span class="hljs-comment">//This block has pointer arithmetic, don't edit quint8 typeLength = p[++offset]; quint8 payloadLength = p[++offset]; QString type = QString(p.mid(++offset, typeLength)); offset += typeLength - 1; if (type == "U") { result.type = RecordPart::Uri; result.prefix = p[++offset]; result.text = QString(p.mid(++offset, payloadLength - 1)); offset += payloadLength - 1; } if (type == "T") { result.type = RecordPart::Text; quint8 localeLength = p[++offset]; result.locale = QString(p.mid(++offset, localeLength)); // 5 bytes of locale string offset += localeLength - 1; result.text = QString(p.mid(++offset, payloadLength - 1 - localeLength)); offset += payloadLength - 1 - localeLength; } ..... //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Add handler for icon return result; }</span></span></code> </pre><br>  The title of each block consists of: <br>  <i>1 byte,</i> technical flags, in our simplified class we will not check the integrity, etc., so we just skip this byte; <br>  <i>2 bytes, the</i> length of the string with the "Type Name"; <br>  <i>3 bytes, the</i> length of the main field with information; <br>  <i>4-n bytes, the</i> string with the ‚ÄúType Name‚Äù is a string type identifier, for Text is 'T', for Uri it is 'U'. <br>  Next comes the main data block. <br><br>  For Uri, these are just two fields. <br>  1 byte for the prefix number from the array above and everything else on the body of the link. <br><br>  For Text, these are three fields: <br>  1 byte status field, which contains additional flags and the length of the locale dates. <br>  Locale string, for example, " <i>en</i> " or " <i>ru-RU</i> " <br>  And, actually, the text itself. <br><br>  Note that this method takes the offset from a non-constant link, and modifies it, thus allowing us to go from one record to another in a loop. <br><br>  Now let's talk about recording methods.  For simplicity, consider only <i>setUri</i> .  The method for the title is relatively identical. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> NdefNfcSmartPosterRecord::setUri(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QUrl &amp;uri) { <span class="hljs-comment"><span class="hljs-comment">//Don't edit - pointer arithmetic QByteArray p; int abbrevs = sizeof(abbreviations) / sizeof(*abbreviations); for (int i = 1; i &lt; abbrevs; ++i) { if (uri.toString().startsWith(QLatin1String(abbreviations[i]))) { p[0] = i; p += uri.toString().mid(qstrlen(abbreviations[i])).toUtf8(); } } QByteArray oldPayload = payload(); QByteArray uHeader(4, 0); uHeader[0] = 0b01 + 0b00010000; uHeader[1] = 1; uHeader[2] = p.size(); uHeader[3] = 'U'; if (!oldPayload.isEmpty()) { uHeader[0] = uHeader[0] + 0b10000000; // change MB flag here oldPayload[0] = oldPayload[0] &amp; 0b01111111; } if (oldPayload.isEmpty()) { uHeader[0] = uHeader[0] + 0b10000000 + 0b01000000; } p.prepend(uHeader); p.append(oldPayload); setPayload(p); }</span></span></code> </pre><br>  The complexity of installation methods is that it is necessary to take into account the case when some part of the Smart Poster (for example, Text) is already installed, and now you also need to install Uri.  And this means that we must keep the old payload and add a new one.  It would seem that there is no problem in the concatenation of two <i>QByteArray</i> , but the very first bytes with flags come into play, the fact is that we need to modify the flag of the first part ( <i>MB</i> ) when adding a new one. <br>  This is what this line of code does: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// change MB flag here oldPayload[0] = oldPayload[0] &amp; 0b01111111;</span></span></code> </pre><br>  As you can see, we add a new part before the old one, not after.  This is only because if we added to the end, we‚Äôll search for the flag of the latter part and its modifications ( <i>ME</i> ) <br>  would have to run around the old payload. <br><br>  That's all about the Smart Poster and the NFC in general. <br><br><h4><a name="Frontend"></a>  Program interface </h4><br><h5>  Page and PageStack </h5><br>  The main idea of ‚Äã‚Äãmobile QML applications is switching screens in the queue.  In terms of Qt components, screens are called pages, and the main container is called a window. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.nokia.meego <span class="hljs-number"><span class="hljs-number">1.0</span></span> PageStackWindow { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: appWindow initialPage: mainPage MainPage { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: mainPage } }</code> </pre><br>  <i>main.qml</i> here creates a container-window and specifies the main page as the initialization page. <br><br><pre> <code class="javascript hljs">Page { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: mainPage ..... Header { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: header anchors { <span class="hljs-attr"><span class="hljs-attr">top</span></span>: parent.top right: parent.right left: parent.left } } .....</code> </pre><br>  This is the page description.  By the way, if you noticed, all standard applications from Nokia have a neat color header.  So, there is no standard component for this header, despite the fact that they encourage you to use it everywhere in your <i>UI Guidelines</i> . <br><br>  To navigate between pages, an object of type <i>PageStack is used</i> ; any Page has a pointer to an instance of this class named <i>pageStack</i> .  Thus, to go to a new page we must use the construction <br><pre> <code class="javascript hljs">pageStack.push(Qt.resolvedUrl(<span class="hljs-string"><span class="hljs-string">"NewPage.qml"</span></span>))</code> </pre><br><br>  and to return to the previous one: <br><pre> <code class="javascript hljs">pageStack.pop()</code> </pre><br>  By the way, if for the pop method you set the identifier of a specific page as a parameter, then you can go back not only to the page back, but also to any arbitrary on the stack. <br><br><h5>  Listview </h5><br><img src="http://habrastorage.org/storage1/c4fca9bb/f005dbc6/7de91a58/73b1bd7e.png" align="right">  On the main screen, we can observe a list of actions that can be performed; a similar list is made like this: <br><pre> <code class="javascript hljs">ListView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: actionList .... delegate: ListDelegate { anchors { <span class="hljs-attr"><span class="hljs-attr">left</span></span> : parent.left leftMargin: <span class="hljs-number"><span class="hljs-number">20</span></span> } onClicked: { pageStack.push(Qt.resolvedUrl(model.source)) } MoreIndicator { anchors { <span class="hljs-attr"><span class="hljs-attr">verticalCenter</span></span>: parent.verticalCenter right: parent.right rightMargin: <span class="hljs-number"><span class="hljs-number">30</span></span> } } } model: ListModel { ListElement { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-string"><span class="hljs-string">"Read Tag"</span></span> subtitle: <span class="hljs-string"><span class="hljs-string">""</span></span> source: <span class="hljs-string"><span class="hljs-string">"ReadPage.qml"</span></span> } ...... } }</code> </pre><br>  The <i>ListView</i> element is the actual list itself, which has two key properties. <br>  <i>delegate</i> is the delegate for drawing a single list item and <i>model</i> is the data model for the list. <br>  The <i>com.nokia.extras</i> package contains the <i>ListDelegate</i> component <i>that</i> is already ready to create a simple delegate.  The <i>ListModel</i> element allows you to specify a simple data model.  And <i>ListElement</i> is nothing more than one record of this model. <br><br><h5>  Toolbar </h5><br><img src="http://habrastorage.org/storage1/375f264f/aa8080a1/d6efa6d7/c694093a.png" align="right">  For various actions, the mobile application may also have a <i>Toolbar</i> with icons, my application is simple and the toolbar on the internal pages contains only a back button <br><pre> <code class="javascript hljs">Page { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: readPage ..... tools: ToolBarLayout { ToolIcon { <span class="hljs-attr"><span class="hljs-attr">iconId</span></span>: <span class="hljs-string"><span class="hljs-string">"toolbar-back"</span></span> onClicked: { pageStack.pop() } } } .....</code> </pre><br>  In order to connect the toolbar to the page, it must be assigned to the <i>tools</i> property, which is <i>null</i> by default. <br><br><h5>  Label and TextField </h5><br><img src="http://habrastorage.org/storage1/57e88494/97be8d68/2d9c22fa/4c3ba548.png" align="right">  To display text, you can use the <i>Label</i> component - this is nothing more than a stylized wrapper over a standard <i>Text</i> element. <br><pre> <code class="javascript hljs">Label { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: touchLabel ..... font.pixelSize: <span class="hljs-number"><span class="hljs-number">60</span></span> text: qsTr(<span class="hljs-string"><span class="hljs-string">"Touch a tag"</span></span>) }</code> </pre><br><br><img src="http://habrastorage.org/storage1/8e7fe0d9/f1dfd286/5e52ba1f/7231d73d.png" align="right">  And for the input field, use <i>TextField</i> - this is an advanced wrapper over the standard <i>TextInput</i> <br><pre> <code class="javascript hljs">TextField { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: textEdit ..... placeholderText: qsTr(<span class="hljs-string"><span class="hljs-string">"Text"</span></span>) text: <span class="hljs-string"><span class="hljs-string">"yandex"</span></span> }</code> </pre><br><br><h5>  InfoBanner </h5><br><img src="http://habrastorage.org/storage1/4a8310a7/a53541d7/21d04a16/eb54fe0b.png" align="right">  In case an error occurred while reading / writing the tag, we must somehow inform the user about it and ask to bring the label to the phone again, for this you can use the InfoBanner element <br><pre> <code class="javascript hljs">InfoBanner{ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: errorBanner timerEnabled: <span class="hljs-literal"><span class="hljs-literal">true</span></span> timerShowTime: <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span> topMargin: header.height + <span class="hljs-number"><span class="hljs-number">20</span></span> leftMargin: <span class="hljs-number"><span class="hljs-number">20</span></span> }</code> </pre><br><br><h4><a name="All"></a>  We connect all together </h4><br>  We considered separately all the main QML components that will be required for our application, as well as all the necessary program logic.  It is time to tie both parts together. <br><br><h5>  setContextProperty </h5><br>  In order for our QML code to see our class for managing reading and writing, we need to inform the declarative engine about the existence of an object of this class, so we write in main.cpp: <br><pre> <code class="cpp hljs">NfcManager *nfcManager = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NfcManager(); viewer-&gt;rootContext()-&gt;setContextProperty(<span class="hljs-string"><span class="hljs-string">"NfcManager"</span></span>, nfcManager);</code> </pre><br>  That is, we create an NfcManager object and indicate to the engine that we should have access to it from QML. <br><br>  By the way, in the last <i>QtSDK</i> update, something was broken, and in order for this code to work correctly, you need to use the workaround <a href="https://bugreports.qt.nokia.com/browse/QTSDK-1064">described in the bugtracker</a> . <br><br><h5>  qmlRegisterType </h5><br>  As you, of course, remember after the label has been read, we emit a signal containing the object with the received data.  In order for this object to be available in QML we must register the class of this object in QML <br><pre> <code class="cpp hljs">qmlRegisterType&lt;DataContainer&gt;(); qmlRegisterType&lt;UriDataContainer&gt;(); qmlRegisterType&lt;TextDataContainer&gt;(); qmlRegisterType&lt;SmartPosterDataContainer&gt;();</code> </pre><br>  By inserting this code into <i>main.cpp</i> , we register data classes for all types of data we have. <br>  However, it is forbidden to create such objects directly from QML. <br><br><h5>  Interaction </h5><br>  When a user hits a page to write or read a label, we need to execute the following code: <br><br>  <b>For reading</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagWasRead</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">container</span></span></span><span class="hljs-function">) </span></span>{ NfcManager.stopDetection() readPage.dataContainer = container pageStack.push(Qt.resolvedUrl(<span class="hljs-string"><span class="hljs-string">"ReadResultPage.qml"</span></span>), {<span class="hljs-attr"><span class="hljs-attr">dataContainer</span></span>: readPage.dataContainer}) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ errorBanner.text = string errorBanner.show() } Component.onCompleted: { NfcManager.tagReadFinished.connect(readPage.tagWasRead) NfcManager.accessError.connect(readPage.readError) NfcManager.setReadMode() NfcManager.startDetection() }</code> </pre><br>  The <i>Component.onCompleted</i> method runs when the page is fully created.  In this method, we hook handlers for errors and for a successful result to our signals from NfcManager (note the syntax for connecting a C ++ signal to a QML slot) <br>  After, we set the mode for reading and tell our manager what to expect when the tag is attached. <br><br>  Also note the <i>push</i> call. <br><pre> <code class="javascript hljs">pageStack.push(Qt.resolvedUrl(<span class="hljs-string"><span class="hljs-string">"ReadResultPage.qml"</span></span>), {<span class="hljs-attr"><span class="hljs-attr">dataContainer</span></span>: readPage.dataContainer})</code> </pre><br>  the second parameter allows us to transfer the container with the data to the next page, which will simply process it <br><img src="http://habrastorage.org/storage1/ba364a3c/d1c0474d/a8b051f5/2525fc8d.png" align="right"><br>  example: <br><pre> <code class="javascript hljs">..... Label { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: rawDataLabel width: parent.width font.pixelSize: <span class="hljs-number"><span class="hljs-number">30</span></span> font.family: <span class="hljs-string"><span class="hljs-string">"Courier New"</span></span> text: readPage.dataContainer.rawHexData() wrapMode: Text.WrapAnywhere } .....</code> </pre><br><br>  <b>To record</b> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tagWasWritten</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ..... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ ..... } Component.onCompleted: { NfcManager.tagWriteFinished.connect(writePage.tagWasWritten) NfcManager.accessError.connect(writePage.writeError) NfcManager.setWriteMode() NfcManager.setDataForWrite(writePage.text, writePage.uri) NfcManager.startDetection() }</code> </pre><br>  Very similar, isn't it?  The only difference is the call to the <i>setDataForWrite</i> method, which passes the data for writing. <br><br><h4><a name="Outro"></a>  Conclusion </h4><br>  So we got a simple but functional application for the MeeGo Harmattan platform.  However, with minimal effort you can turn it into an application for Symbian.  As far as I know, some Symbian phones ( <i>C7</i> for example) also have an integrated NFC chip. <br>  I would also like to add that formally on the NFC Tag you can record information in any format that will make it understandable only for your application.  So you can think of many more ways to use this technology. <br><br><h5>  What to read </h5><br>  If you are interested in this topic, I recommend to familiarize yourself with the official specifications of NFC and NDEF.  They can be downloaded on demand absolutely free of charge <a href="http://www.nfc-forum.org/specs/spec_license">from this page</a> . <br>  <i>Qt Connectivity</i> documentation is included in QtSDK, but sometimes, for example, when developing your own QNdefRecord format, it is not enough, then you are welcome to Qt Mobility source code - you can learn a lot of interesting things there. <br>  According to <i>MeeGo, Qt Components</i> also has official documentation in QtSDK, but sometimes it leaves much to be desired, I recommend reading the <i>qt-components-examples</i> code that can be <a href="https://qt.gitorious.org/qt-components/qt-components/trees/master/examples/meego">found here</a> . <br><br><h5>  Additionally </h5><br>  I'm going to continue to develop the app, and this is probably not the last post on the NFC Tag. <br>  To stay updated you can watch the project on <a href="https://gitorious.org/nfctagtool">gitorius</a> <br>  Or subscribe to my blog, the link to which can be found in the profile. <br>  In the near future, I plan to place the app in the <a href="http://store.ovi.com/">Nokia Store</a> , so look for it there. <br>  Now the deb package can be downloaded <a href="">here</a> . <br><br><h5>  Acknowledgments </h5><br>  I express my gratitude for reading the text of the article for errors and misprints for habra users: <br>  <a href="http://habrahabr.ru/users/dreary_eyes/" class="user_link">dreary_eyes</a> and <a href="http://habrahabr.ru/users/tass/" class="user_link">tass</a> . </div><p>Source: <a href="https://habr.com/ru/post/133471/">https://habr.com/ru/post/133471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133466/index.html">Indie Game Music Bundle</a></li>
<li><a href="../133467/index.html">allw.me: your link is in question</a></li>
<li><a href="../133468/index.html">Ubuntu Unity - a bright future against conservatism</a></li>
<li><a href="../133469/index.html">Search engine number one in the world according to google</a></li>
<li><a href="../133470/index.html">Ubuntu slid into fourth place in popularity</a></li>
<li><a href="../133472/index.html">What Linux distributions do you use on desktops?</a></li>
<li><a href="../133473/index.html">We do the private monitor from the old LCD monitor</a></li>
<li><a href="../133475/index.html">Acer Aspire One D255 modding or a long way to passive cooling</a></li>
<li><a href="../133476/index.html">Speed ‚Äã‚ÄãLimit on DIR-320N / RU</a></li>
<li><a href="../133477/index.html">This hacker console</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>