<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt + MVP + QThread. Build your bike</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day everyone! 

 Recently, I faced a rather interesting task, to make the user interface for communicating with one piece of iron. Communication ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt + MVP + QThread. Build your bike</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2de/85d/ad8/2de85dad86c8462985e2aa2d96108263.png" alt="image" align="left"><br>  Good day everyone! <br><br>  Recently, I faced a rather interesting task, to make the user interface for communicating with one piece of iron.  Communication with it was carried out through the COM port.  Since the work was assumed with a real-time system (this is the piece of hardware) in the Windows operating system, in order for the GUI not to slow down, it was decided to put the work with the COM port into a separate thread.  Since the requirements for the system itself were constantly changing, in order to minimize and speed up patches, it was also decided to write using the MVP design pattern.  Qt was chosen as the development environment.  Just because I like this environment and its capabilities.  This is how the Qt + MVP + Qthread bundle turned out.  Who cares what came of it all and for what rake I went, I ask under the cat. <br><a name="habracut"></a><br><h3>  Planning </h3><br>  We have a certain device with which we want to communicate through the COM port.  Moreover, we complicate the task a little, we want to communicate both with the help of commands entered from the keyboard, ‚Äúala-console‚Äù, and in automatic mode, when requests to the device are sent on a timer.  We also need to take a response from the device, process it and display it on the form.  All work on receiving and sending messages to the COM port should be performed in a separate thread.  Plus, it should be possible to send messages to a device connected to a computer from different places in the program.  And it is desirable to still have the opportunity to write tests (hello TDD). <br><br>  On Habr√© already was an article about a bunch of Qt + MVP <a href="http://habrahabr.ru/post/107698/">[1]</a> .  There were also several articles about using threads in Qt <a href="http://habrahabr.ru/post/202312/">[2]</a> , <a href="http://habrahabr.ru/post/203254/">[3]</a> .  In short, the essence of MVP is that the application logic is separated from its appearance, which allows testing this logic separately from the rest of the program, using Unit tests, used in other applications, and also making changes faster to meet changing requirements . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A little about terms: <br>  <b>View</b> - is responsible for the appearance of the program, it will be our form. <br>  <b>Model</b> - is responsible for the logic of the program, our messages will be sent from it to the COM port, and the received reply packet will be understood in it. <br>  <b>Presenter</b> is the link between View and Model. <br>  Briefly on this all, in more detail you can read <a href="https://ru.wikipedia.org/wiki/Model-View-Presenter">here</a> and <a href="http://msdn.microsoft.com/ru-ru/magazine/hh580734.aspx">here</a> .  It's time to get down to the code. <br>  We will write a small application (link to the finished project at the end) and in the course of writing we will implement what is in the article title. <br><br><h3>  Model </h3><br>  I like to start writing programs from logic, not from the interface. <br>  So, we start the work by writing the ModelComPort class. <br>  To begin, we implement the sending of messages to the COM port. <br><br>  Our class should: <br><ol><li>  Automatically detect available COM ports in the system. </li><li>  Connect to the specified COM port at the specified speed. </li><li>  Send messages to the COM port. </li><li>  Decrypt the received message from the COM port. </li></ol><br>  Here is what it will look like: <br><div class="spoiler">  <b class="spoiler_title">ModelComPort.h</b> <div class="spoiler_text"><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ModelComPort { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: ModelComPort(); ~ModelComPort(); //   COM- <span class="hljs-type"><span class="hljs-type">void</span></span> connectToComPort(); //   <span class="hljs-type"><span class="hljs-type">void</span></span> setPortName(QString portName); QString getPortName() const; //   <span class="hljs-type"><span class="hljs-type">void</span></span> setBaudrate(<span class="hljs-type"><span class="hljs-type">int</span></span> baudrate); <span class="hljs-type"><span class="hljs-type">int</span></span> getBaudrate() const; //   COM- QList&lt;QString&gt; getListNamePorts() const; //    <span class="hljs-type"><span class="hljs-type">bool</span></span> isConnect() const; //   COM- <span class="hljs-type"><span class="hljs-type">void</span></span> onCommand(QString command); //    COM- <span class="hljs-type"><span class="hljs-type">void</span></span> response(QByteArray msg); private: //   COM-   <span class="hljs-type"><span class="hljs-type">void</span></span> searchComPorts(); //     <span class="hljs-type"><span class="hljs-type">void</span></span> sendCommand(<span class="hljs-type"><span class="hljs-type">int</span></span> command); private: <span class="hljs-type"><span class="hljs-type">bool</span></span> m_connected; //     COM- QString m_portName; //  COM- QList&lt;QString&gt; m_listPorts; //  COM-   //   <span class="hljs-type"><span class="hljs-type">int</span></span> m_baudrate; <span class="hljs-type"><span class="hljs-type">int</span></span> m_dataBits; <span class="hljs-type"><span class="hljs-type">int</span></span> m_parity; <span class="hljs-type"><span class="hljs-type">int</span></span> m_stopBits; <span class="hljs-type"><span class="hljs-type">int</span></span> m_flowControl; QByteArray m_inBuf; //   ComPortThread thread; //      };</code> </pre> <br></div></div><br>  As you can see, for those properties that are subject to change, we set get and set methods.  Do not pay attention to the object of type ComPortThread, it will be described below. <br><br>  I will not completely bring up the ModelComPort.cpp file, I‚Äôll only focus on some of the nuances: <br><div class="spoiler">  <b class="spoiler_title">Constructor</b> <div class="spoiler_text"><pre> <code class="hljs ruby">ModelComPort::ModelComPort() : m_portName(<span class="hljs-string"><span class="hljs-string">""</span></span>), m_baudrate(QSerialPort::Baud960<span class="hljs-number"><span class="hljs-number">0</span></span>), m_dataBits(QSerialPort::Data8), m_parity(QSerialPort::NoParity), m_stopBits(QSerialPort::OneStop), m_flowControl(QSerialPort::NoFlowControl), m_connected(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { searchComPorts(); }</code> </pre><br></div></div><br>  As you can see, in the constructor, I immediately configure the default communication parameters, as well as determine which COM ports are installed in the system.  I list the names of all available COM ports into an array.  Let me explain why this is done.  The fact is that our form, on which we will continue to display connection parameters, does not know anything about the available COM ports in the system, this is not in its competence.  But, since we have to give the user a choice of which particular COM port to connect to, then in the future we will transfer this list to our form. <br><br>  The method for determining the available COM ports is quite simple: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> ModelComPort::searchComPorts() { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (const QSerialPortInfo &amp;<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>, QSerialPortInfo::availablePorts()) { m_listPorts.append(<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.portName()); } }</code> </pre><br>  Next, we consider the method by which we create a connection: <br><br><div class="spoiler">  <b class="spoiler_title">connectToComPort</b> <div class="spoiler_text"><pre> <code class="hljs ruby">void ModelComPort::connectToComPort() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_connected) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_portName == <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!thread-&gt;isRunning()) { thread.connectCom(m_portName, m_baudrate, m_dataBits, m_dataBits, m_stopBits, m_flowControl); thread.wait(<span class="hljs-number"><span class="hljs-number">500</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thread.isConnect()) { m_connected = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (thread.isConnect()) { thread.disconnectCom(); } m_connected = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre><br></div></div><br>  It's simple.  First we determine whether we already have a connection or not.  This is done so that when you click on the same button, the user can connect to the port and disconnect from it.  That is, for example, when loading we are disabled.  The first click on the connect button connects us, the second click on the connect button disconnects us.  And so in a circle. <br>  Next, we determine whether we know the name of the COM port to which we are connecting.  Then we look, whether the flow which will carry out work with port is started at us.  If the stream is not running, then create it, run it and it is already connected to the COM port.  Here, probably, it is worth staying in more detail.  The fact is that in order to work with a COM port in a separate stream, this thread must create a connection during its operation.  Therefore, we in the ModelComPort class do not create the connection ourselves, but tell the stream that we want to create a connection and pass it the parameters with which we would like to connect. <br>  Next, we give the stream time to create a connection and check whether it was possible to create it.  If all is well, set the flag that we are connected. <br><br>  Finally, we have methods by which we can establish or get the current connection settings, as well as get the current status of our connection. <br><div class="spoiler">  <b class="spoiler_title">The code is very simple</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ModelComPort::setPortName(QString portName) { m_portName = portName; } QString ModelComPort::getPortName() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_portName; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ModelComPort::setBaudrate(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> baudrate) { m_baudrate = baudrate; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ModelComPort::getBaudrate() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_baudrate; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ModelComPort::isConnect() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_connected; }</code> </pre><br></div></div><br>  Since one of the conditions was that commands can be sent either automatically by timer and from the console, then we need a method that will receive a text command from the console, decrypt it and send it to the COM port. <br>  The input method receives a string from the console and sends the corresponding command: <br><pre> <code class="hljs cmake">void ModelComPort::onCommand(QString <span class="hljs-keyword"><span class="hljs-keyword">command</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> == <span class="hljs-string"><span class="hljs-string">"On"</span></span>) { sendommand(<span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">command</span></span> == <span class="hljs-string"><span class="hljs-string">"Off"</span></span>) { sendommand(<span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>); } .... }</code> </pre><br>  All commands we will have is in a separate file and have a three-digit code: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Enum</span></span> Commands { <span class="hljs-attribute"><span class="hljs-attribute">ON</span></span> = <span class="hljs-number"><span class="hljs-number">101</span></span>, OFF = <span class="hljs-number"><span class="hljs-number">102</span></span> .... }</code> </pre><br>  Well, the sendCommand method will form a packet and give it to the stream for sending: <br><div class="spoiler">  <b class="spoiler_title">sendCommand</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> ModelComPort::sendCommand(<span class="hljs-type"><span class="hljs-type">int</span></span> command) { QByteArray buffer; quint8 checkSumm = <span class="hljs-number"><span class="hljs-number">0</span></span>; buffer[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-string"><span class="hljs-string">'#'</span></span>; buffer[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>; buffer[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; checkSumm ^= buffer[<span class="hljs-number"><span class="hljs-number">2</span></span>]; buffer[<span class="hljs-number"><span class="hljs-number">3</span></span>] = command; checkSumm ^= buffer[<span class="hljs-number"><span class="hljs-number">3</span></span>]; buffer[<span class="hljs-number"><span class="hljs-number">4</span></span>] = checkSumm; thread.<span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>(buffer, <span class="hljs-number"><span class="hljs-number">250</span></span>); }</code> </pre><br></div></div><br>  The number 250 in the string thread.transaction (buffer, 250);  This is the wait time in ms to send our package.  If during this time the package could not be sent, we assume that we have no connection with the device and display an error. <br>  We have everything with the ModelComPort class, now we are going to create the PresenterComPort class. <br><br><h3>  Presenter </h3><br>  As mentioned earlier, we have Presenter as an intermediary between View and Model.  That is, it has a dual function.  On the one hand, this class must respond to all user actions performed with the GUI.  On the other hand, it should provide synchronization of all our View and Model.  That is, if we have several View, the general information displayed on them should be the same.  This is, firstly, and secondly, the data entered on our (our) View must be synchronized with the data with which our Model works. <br>  So, look at our Presenter. <br><div class="spoiler">  <b class="spoiler_title">PresenterComPort</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PresenterComPort</span></span></span><span class="hljs-class"> : public </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class"> { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Q_OBJECT</span></span></span><span class="hljs-class"> public: explicit </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PresenterComPort</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QObject</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">parent</span></span></span><span class="hljs-class"> = 0); ~</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PresenterComPort</span></span></span><span class="hljs-class">(); void appendView(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IViewComPort</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">); private slots: //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Com</span></span></span><span class="hljs-class">- void processConnect(); //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Com</span></span></span><span class="hljs-class">- void processNameComPortChanged(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QString</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">portName</span></span></span><span class="hljs-class">); //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Com</span></span></span><span class="hljs-class">- void processBaudratePortChanged(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">baudrate</span></span></span><span class="hljs-class">); //    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">COM</span></span></span><span class="hljs-class">- void onCommand(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QString</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">command</span></span></span><span class="hljs-class">); //    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">COM</span></span></span><span class="hljs-class">- void response(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QByteArray</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">); private: void refreshView() const; void refreshView(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IViewComPort</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">) const; void setPortInfo() const; void setPortInfo(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IViewComPort</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">view</span></span></span><span class="hljs-class">) const; private: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ModelComPort</span></span></span><span class="hljs-class"> *m_model; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">QList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IViewComPort</span></span></span><span class="hljs-class">*&gt; m_viewList; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ComPortThread</span></span></span><span class="hljs-class"> thread; };</span></span></code> </pre><br></div></div><br>  As you can see, there is only one public method here, it is used to bind our (our) View to the Presenter.  In order for us to work with any View as a single object, all our View must be inherited from one interface.  In this case, I use one View and inherit it from the IViewComPort interface.  Details of this implementation can be found here <a href="http://habrahabr.ru/post/107698/">[1]</a> .  Let's take a closer look at the appendView () method. <br><div class="spoiler">  <b class="spoiler_title">appendView</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> PresenterComPort::appendView(IViewComPort *<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) { //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_viewList.contains(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } m_viewList.append(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>); QObject *view_obj = dynamic_cast&lt;QObject*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>); //   COM- QObject::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(view_obj, SIGNAL(processConnect()), this, SLOT(processConnect())); //   COM- QObject::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(view_obj, SIGNAL(processNameComPortChanged(QString)), this, SLOT(processNameComPortChanged(QString))); //    QObject::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(view_obj, SIGNAL(processBaudratePortChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(processBaudratePortChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>))); //    COM- QObject::<span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(view_obj, SIGNAL(onCommand(QString)), this, SLOT(onCommand(QString))); refreshView(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>); setPortInfo(<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>); }</code> </pre><br></div></div><br>  In it, the transmitted View is recorded in the list, and our Presenter connects to the signals that can come from this View.  This is done just so that our Presenter knows about all the changes on the form. <br><br>  I will not talk about all the methods, the code there is not complicated, I‚Äôll dwell on an example of only one method that sets connection parameters to our (our) View.  As I said above, our form does not know what COM ports are in the system, but the user needs to display this information before connecting.  All this makes the method <br><div class="spoiler">  <b class="spoiler_title">setPortInfo</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> PresenterComPort::setPortInfo(IViewComPort *<span class="hljs-keyword"><span class="hljs-keyword">view</span></span>) const { //   COM-   QList&lt;QString&gt; tempList = m_model-&gt;getListNamePorts(); //     COM-   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; tempList.count(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>-&gt;addPortName(tempList.at(i)); } //       <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>-&gt;addBaudrate(<span class="hljs-number"><span class="hljs-number">9600</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>-&gt;addBaudrate(<span class="hljs-number"><span class="hljs-number">34800</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">view</span></span>-&gt;addBaudrate(<span class="hljs-number"><span class="hljs-number">115200</span></span>); }</code> </pre><br></div></div><br>  As you can see from it, we request from our Model a list of all COM ports, and then enter this information on our form. <br>  I fixed the possible connection speeds rigidly, in my work I mostly use the 9600, but just in case I added a couple more. <br>  The rest of the code can be viewed in the project laid out at the end of the article, but then, so, it has already stretched strongly, and there is still a lot to discuss. <br><br><h3>  View </h3><br>  On the form, we will have 2 comboBox for setting the connection settings, one button that will be responsible for connecting / disconnecting to the COM port.  We will also have a console in which we will write commands.  And there will be another LED that will display the current connection status.  If we are connected will turn green. <br><br>  The final form of the form can be seen below. <br><img src="http://habrastorage.org/files/4d7/be6/0de/4d7be60de7c7469dab86a9265cc6094c.png" alt="image"><br><br>  The code of the form of special interest does not represent, we simply send signals when the selected item is changed in each of the ComboBox, the signal when the connection button is pressed, and also emit a signal if Enter is pressed in the console. <br>  All these signals are intercepted by our Presenter, and transmits data to our Model for further processing. <br><br>  It's time to move on to implementing our stream, which will be responsible for working with the COM port. <br>  There are several opinions on how to better organize work with threads in Qt.  Someone creates a stream and puts data into it, someone inherits from Qthread and overrides the run () method.  Each method has its advantages and disadvantages.  In this case, we will follow the second path, inheriting from Qthread. <br><br><h3>  ComPortThread </h3><br>  So, consider our ComPortThread class: <br><div class="spoiler">  <b class="spoiler_title">ComPortThread.h</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ComPortThread : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QThread { Q_OBJECT <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: ComPortThread(QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); ~ComPortThread(); //    COM- <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span>(const QByteArray&amp; request, <span class="hljs-type"><span class="hljs-type">int</span></span> waitTimeout); //   COM- <span class="hljs-type"><span class="hljs-type">void</span></span> connectCom(QString namePort, <span class="hljs-type"><span class="hljs-type">int</span></span> baudRate, <span class="hljs-type"><span class="hljs-type">int</span></span> m_dataBits, <span class="hljs-type"><span class="hljs-type">int</span></span> m_parity, <span class="hljs-type"><span class="hljs-type">int</span></span> m_stopBits, <span class="hljs-type"><span class="hljs-type">int</span></span> m_flowControl); //   COM- <span class="hljs-type"><span class="hljs-type">void</span></span> disconnectCom(); //    <span class="hljs-type"><span class="hljs-type">bool</span></span> isConnect(); signals: //   <span class="hljs-type"><span class="hljs-type">void</span></span> responseMsg(const QByteArray &amp;s); //    COM- <span class="hljs-type"><span class="hljs-type">void</span></span> error(const QString &amp;s); //     <span class="hljs-type"><span class="hljs-type">void</span></span> timeout(const QString &amp;s); protected: //   <span class="hljs-type"><span class="hljs-type">void</span></span> run(); private: <span class="hljs-type"><span class="hljs-type">int</span></span> m_waitTimeout; //        COM- QMutex mutex; QWaitCondition cond; //  COM- QString m_portName; <span class="hljs-type"><span class="hljs-type">int</span></span> m_baudrate; <span class="hljs-type"><span class="hljs-type">int</span></span> m_dataBits; <span class="hljs-type"><span class="hljs-type">int</span></span> m_parity; <span class="hljs-type"><span class="hljs-type">int</span></span> m_stopBits; <span class="hljs-type"><span class="hljs-type">int</span></span> m_flowControl; //   COM- QByteArray m_request; //   <span class="hljs-type"><span class="hljs-type">bool</span></span> m_isConnect; //  <span class="hljs-type"><span class="hljs-type">bool</span></span> m_isDisconnecting; //   <span class="hljs-type"><span class="hljs-type">bool</span></span> m_isConnecting; //   <span class="hljs-type"><span class="hljs-type">bool</span></span> m_isQuit; //     };</code> </pre><br></div></div><br>  As you can see, in it we have connection settings with a COM port that will be transferred to us from the Model, the current state of the COM port (connected or not) and the stage (connection / disconnection). <br><br>  We proceed to the implementation. <br><div class="spoiler">  <b class="spoiler_title">Constructor</b> <div class="spoiler_text"><pre> <code class="hljs php">ComPortThread::ComPortThread(QObject *<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>) : QThread(<span class="hljs-keyword"><span class="hljs-keyword">parent</span></span>), m_waitTimeout(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_isQuit(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>), m_isConnect(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>), m_isDisconnecting(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>), m_isConnecting(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { }</code> </pre><br></div></div><br>  Here I think nothing new for those who have ever worked with synchronous streams, who are not familiar with them, I advise you to consult the Qt documentation. <br>  Go to the connection method: <br><div class="spoiler">  <b class="spoiler_title">connectCom</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> ComPortThread::connectCom(QString namePort, <span class="hljs-type"><span class="hljs-type">int</span></span> baudRate, <span class="hljs-type"><span class="hljs-type">int</span></span> dataBits, <span class="hljs-type"><span class="hljs-type">int</span></span> parity, <span class="hljs-type"><span class="hljs-type">int</span></span> stopBits, <span class="hljs-type"><span class="hljs-type">int</span></span> flowControl) { mutex.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); m_portName = namePort; m_baudrate = baudRate; m_dataBits = dataBits; m_parity = parity; m_stopBits = stopBits; m_flowControl = flowControl; mutex.unlock(); //     -   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isRunning()) { m_isConnecting = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>(); m_isQuit = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   ,   cond.wakeOne(); } }</code> </pre><br></div></div><br>  As you can see, here we do not create the connection as such, here we just check if we have a workflow, if not, we create a new flow and set the intention flag that we want to create a connection. Disconnecting from the COM port is the same expose the intention that we want to disconnect.  All work that will be done by the stream will be in the run () method, which we will override. <br><div class="spoiler">  <b class="spoiler_title">disconnectCom</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> ComPortThread::disconnectCom() { mutex.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); m_isDisconnecting = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; mutex.unlock(); cond.wakeOne(); }</code> </pre><br></div></div><br>  Please note that before changing the variables of the flow, you need to block the flow, and after that you must unlock it.  Well, it is advisable to wake him up if you want your changes to take effect immediately. <br><br>  We turn to the main method in which all the useful work is accomplished. <br><div class="spoiler">  <b class="spoiler_title">run</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> ComPortThread::run() { QSerialPort <span class="hljs-type"><span class="hljs-type">serial</span></span>; //   COM- QString currentPortName = m_portName; //    <span class="hljs-type"><span class="hljs-type">int</span></span> currentWaitTimeout = m_waitTimeout; // ,   COM- QByteArray currentRequest = m_request; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!m_isQuit) { //     COM- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isConnecting) { //   COM- <span class="hljs-type"><span class="hljs-type">serial</span></span>.setPortName(currentPortName); //  COM- <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(QIODevice::ReadWrite)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-type"><span class="hljs-type">serial</span></span>.setBaudRate(m_baudrate) &amp;&amp; <span class="hljs-type"><span class="hljs-type">serial</span></span>.setDataBits((QSerialPort::DataBits)m_dataBits) &amp;&amp; <span class="hljs-type"><span class="hljs-type">serial</span></span>.setParity((QSerialPort::Parity)m_parity) &amp;&amp; <span class="hljs-type"><span class="hljs-type">serial</span></span>.setStopBits((QSerialPort::StopBits)m_stopBits) &amp;&amp; <span class="hljs-type"><span class="hljs-type">serial</span></span>.setFlowControl((QSerialPort::FlowControl)m_flowControl))) { m_isConnect = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; m_isConnecting = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m_isConnect = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; m_isConnecting = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; emit error(tr("Can't open %1, error code %2") .arg(m_portName) .arg(<span class="hljs-type"><span class="hljs-type">serial</span></span>.error())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m_isConnect = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; m_isConnecting = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; emit error(tr("Can't open %1, error code %2") .arg(m_portName) .arg(<span class="hljs-type"><span class="hljs-type">serial</span></span>.error())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_isDisconnecting) { <span class="hljs-type"><span class="hljs-type">serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(); m_isDisconnecting = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; m_request.clear(); m_isQuit = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   COM-  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!currentRequest.isEmpty()) { <span class="hljs-type"><span class="hljs-type">serial</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(currentRequest); //     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">serial</span></span>.waitForBytesWritten(m_waitTimeout)) { //      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">serial</span></span>.waitForReadyRead(currentWaitTimeout)) { //   QByteArray responseFromPort = <span class="hljs-type"><span class="hljs-type">serial</span></span>.readAll(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-type"><span class="hljs-type">serial</span></span>.waitForReadyRead(<span class="hljs-number"><span class="hljs-number">10</span></span>)) { responseFromPort += <span class="hljs-type"><span class="hljs-type">serial</span></span>.readAll(); } //    ,    emit responseMsg(responseFromPort); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //      emit timeout(tr("Wait read response timeout %1") .arg(QTime::currentTime().toString())); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //       emit timeout(tr("Wait write request timeout %1") .arg(QTime::currentTime().toString())); } //    currentRequest.clear(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { mutex.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); //     cond.wait(&amp;mutex); currentWaitTimeout = m_waitTimeout; currentRequest = m_request; mutex.unlock(); } } } }</code> </pre><br></div></div><br>  First of all, we create local variables, in which we will enter information that may change during the work of the stream.  Next, we go into an infinite loop in which our stream will spin until we set the flag that we want to exit. <br>  Turning in the stream, we watch the flags and according to them we make certain actions.  A sort of state machine.  That is, if there is a flag that means that we want to connect to the COM port, we connect, reset this flag and fall asleep until another command follows.  Further, if a command arrives to send a message to the COM port, the thread wakes up, takes the message to be transmitted, and then tries to transmit it within the specified time.  If the transfer failed, then the stream sends a signal to which any external object can subscribe and thus find out that the transfer failed. <br>  If the transfer is successful, the stream waits for a response for the specified time.  If the answer does not come, the thread issues a signal to which any object can again subscribe, so we can find out that our piece of hardware is not responding and deal with it already. <br>  If the answer is received, then the stream again emits a signal that the data is ready, it can be taken and processed. <br><br><h3>  Rake </h3><br>  In general, in words it sounds quite easy, but there are nuances.  The fact is that our Model cannot receive signals.  That is, the package came to us, but Model does not know about it.  On the other hand, Presenter can receive signals (since it is inherited from Qobject), but Presenter does not have access to a stream that works with a COM port.  There are two possible solutions (maybe more, who knows, write in the comments), the first option is to work with the stream in the Presenter.  It seemed to me that it was not a very good idea, because then we would have to carry out the work on packing / unpacking messages to Presenter too, that is, we will have part of the program logic not in our Model, but in Presenter.  I dropped the idea.  The second option is to make the class ComPortThread Singleton.  And our Presenter should subscribe to its signals, and all processing should be carried out in the Model. For this, the ComPortThread class needs to be slightly redone: <br><div class="spoiler">  <b class="spoiler_title">ComPortThread</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComPortThread</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QThread { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ComPortThread* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> QMutex mutex; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_instance) { mutex.lock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_instance) { m_instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComPortThread; } m_refCount++; mutex.unlock(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_instance; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QByteArray&amp; request, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waitTimeout)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connectCom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(QString namePort, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> baudRate, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m_dataBits, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m_parity, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m_stopBits, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> m_flowControl)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">disconnectCom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isConnect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">responseMsg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QByteArray &amp;s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QString &amp;s)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ComPortThread(QObject *parent = <span class="hljs-number"><span class="hljs-number">0</span></span>); ~ComPortThread(); ComPortThread(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ComPortThread&amp;); ComPortThread&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ComPortThread&amp;); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_waitTimeout; QMutex mutex; QWaitCondition cond; QString m_portName; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_baudrate; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_dataBits; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_parity; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_stopBits; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_flowControl; QByteArray m_request; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isConnect; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isDisconnecting; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isConnecting; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isQuit; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ComPortThread* m_instance; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_refCount; };</code> </pre><br></div></div><br>  Hiding constructors and destructor from external access, we implement the method of getting links, and in the ModelComPort and PresenterComPort classes we add the line to the constructors: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">thread</span></span> = ComPortThread::getInstance();</code> </pre><br><br>  Do not forget to add lines to the destructors of these classes: <br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(thread)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">thread</span></span></span><span class="hljs-function">-&gt;</span></span>free(); thread = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The free () method of the thread object counts references to itself, and as soon as there are zero of them, it will allow its deletion.  This is done to protect against deletion of an object to which hanging links are possible.  Accordingly, in all classes where we used the ComPortThread object, we change the object declaration to the pointer declaration and work with the stream through the pointer.  More details can be found in the source. <br><br>  Well, finally we put everything together, the main.cpp file <br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[]</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-function"><span class="hljs-function">QApplication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">argc, argv</span></span></span><span class="hljs-function">)</span></span>; CopterGUI w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CopterGUI; PresenterComPort *presenterComPort = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PresenterComPort(); presenterComPort-&gt;appendView(&amp;w); w.show(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.exec(); }</code> </pre><br></div></div><br><br><h3>  Conclusion </h3><br>  Well, in general, that's all. <br><br>  Interested in your feedback, suggestions, criticism. <br><br>  The volume was quite large, I apologize, I wanted to highlight as many implementation details as possible, if there were any questions left, I will try to answer in the comments.  About errors, please write in a personal. <br><br>  From myself I want to note that this implementation does not pretend to be absolutely correct, it is rather a description of one of the options, how to do it.  This article is the first for me, so please do not kick much.  The project code, as promised, can be found <a href="">here</a> . <br><br>  PS Corrected some minor notes on the code given by the respected <a href="https://habrahabr.ru/users/kulinich/" class="user_link">kulinich</a> and <a href="https://habrahabr.ru/users/semlanik/" class="user_link">semlanik</a> in the comments. <br><br>  PPS In the course of the discussion, thanks to the links <a href="http://blog.debao.me/2013/08/how-to-use-qthread-in-the-right-way-part-1/">Part 1</a> and <a href="http://blog.debao.me/2013/08/how-to-use-qthread-in-the-right-way-part-2/">Part 2</a> , which the respected <a href="https://habrahabr.ru/users/singerofthefall/" class="user_link">Singerofthefall</a> gave, it turned out that the approach to working with streams described in the article may not always meet the expectations of the programmer and work quite differently than expected. <br>  It is safer to use the Qobject.moveToThread () method for working with threads, as advised in the first comments. </div><p>Source: <a href="https://habr.com/ru/post/246445/">https://habr.com/ru/post/246445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../246435/index.html">Typical fixes after upgrading Windows Store applications from version 8 to 8.1</a></li>
<li><a href="../246437/index.html">Solving the traveling salesman problem using the branch and bound method</a></li>
<li><a href="../246439/index.html">Printing machines. The power and support of typography</a></li>
<li><a href="../246441/index.html">Breeze.js + Entity Framework + Angular.js = easy work with database entities directly from the browser</a></li>
<li><a href="../246443/index.html">Attempt to make logical editing form behavior in asp mvc</a></li>
<li><a href="../246447/index.html">A little about how not to protect accounts in Active Directory</a></li>
<li><a href="../246449/index.html">Vulnerabilities of public terminals: how to hack a bike rental and a polyclinic</a></li>
<li><a href="../246451/index.html">Sensomotor coordination (SMK). Professional research / pilot training</a></li>
<li><a href="../246455/index.html">R reference manual</a></li>
<li><a href="../246459/index.html">Interval repetition of foreign words: Anki, LinguaLeo, Memrise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>