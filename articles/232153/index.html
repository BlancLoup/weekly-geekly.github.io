<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating audio plug-ins, part 16</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All posts series: 
 Part 1. Introduction and setup 
 Part 2. Learning Code 
 Part 3. VST and AU 
 Part 4. Digital Distortion 
 Part 5. Presets and GUI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating audio plug-ins, part 16</h1><div class="post__text post__text-html js-mediator-article">  All posts series: <br>  <a href="http://habrahabr.ru/post/224911/">Part 1. Introduction and setup</a> <br>  <a href="http://habrahabr.ru/post/225019/">Part 2. Learning Code</a> <br>  <a href="http://habrahabr.ru/post/225457/">Part 3. VST and AU</a> <br>  <a href="http://habrahabr.ru/post/225751/">Part 4. Digital Distortion</a> <br>  <a href="http://habrahabr.ru/post/225755/">Part 5. Presets and GUI</a> <br>  <a href="http://habrahabr.ru/post/226439/">Part 6. Signal synthesis</a> <br>  <a href="http://habrahabr.ru/post/226573/">Part 7. Receive MIDI Messages</a> <br>  <a href="http://habrahabr.ru/post/226823/">Part 8. Virtual Keyboard</a> <br>  <a href="http://habrahabr.ru/post/227475/">Part 9. Envelopes</a> <br>  <a href="http://habrahabr.ru/post/227601/">Part 10. Refinement GUI</a> <br>  <a href="http://habrahabr.ru/post/227791/">Part 11. Filter</a> <br>  <a href="http://habrahabr.ru/post/227827/">Part 12. Low-frequency oscillator</a> <br>  <a href="http://habrahabr.ru/post/228267/">Part 13. Redesign</a> <br>  <a href="http://habrahabr.ru/post/231513/">Part 14. Polyphony 1</a> <br>  <a href="http://habrahabr.ru/post/231923/">Part 15. Polyphony 2</a> <br>  <a href="http://habrahabr.ru/post/232153/">Part 16. Antialiasing</a> <br><hr><br><br>  To make our SpaceBass sound even better, you need to create an oscillator in which there is less aliasing.  This is an optional improvement.  Without it, the synthesizer will work as before, but with it the sound on the upper octaves will be much better. <br><a name="habracut"></a><br><h3>  Spectrum analysis </h3><br><br>  I would like to show you a very good free plugin: <a href="http://www.voxengo.com/product/span/">Voxengo SPAN</a> .  It can be hung on a track, and it will show the spectrum of the signal passing through it.  At this stage, it‚Äôs too early to write your own test procedures with <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%258B%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B5%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">FFT</a> , so that SPAN will be an indispensable tool for comparing the results of various algorithms for oscillators.  Download and install.  <i>Launch SpaceBass</i> in REAPER and do the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Turn the <i>Mix</i> knob all the way to the left so that only the first oscillator can be heard </li><li>  Choose a <i>square wave</i> for him (square wave) </li><li>  Set cutoff frequency to maximum, resonance to minimum </li><li>  LFO filter at minimum, handle the envelope around the middle </li></ul><br><br>  With such settings, the raw waveform of the first oscillator is audible.  Now hang the SPAN on the same track after the synthesizer.  Pinch the high note (I used the A-sixth octave) and look at the spectrogram in SPAN, it should look something like this: <br><br><img src="https://habrastorage.org/files/dc5/33f/fbd/dc533ffbd5e5408da35d916a4534404d.png"><br><br>  It is very simple to read it: along the x axis is the frequency in hertz, frequencies from 66 Hz to 20 kHz are displayed in this plug-in.  The <i>logarithmic</i> scale, i.e.  the distance between the octaves is always the same - between Before the first octave and Until the second as much as between Before the seventh and eighth.  The frequency ratio of neighboring octaves is two to one.  While signal harmonics are <i>multiplied</i> (or divided) by different integers, the fundamental frequency.  This means that the harmonics are distributed unevenly along the x axis. <br>  The y-axis is the amplitude in decibels.  Thus it is very easy to determine which frequency has what amplitude at the moment. <br>  Depending on the settings, some points may differ on your and my spectrograms, but one thing is certain: something is wrong.  We expected to see the spectrogram of the meander - a series of peaks, the amplitude of which decreases with increasing frequency, and <i>nothing</i> between the peaks.  And we certainly did not expect to see any spectral components below the fundamental frequency (on the left side of the graph).  As you remember, such nonsense is <i>aliasing</i> . <br><br>  What to do with him?  There are different approaches to the solution.  The most accurate solution is to synthesize members <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D1%258F%25D0%25B4_%25D0%25A4%25D1%2583%25D1%2580%25D1%258C%25D0%25B5">of the Fourier series</a> to approximate the meander.  In fact, it is the overlapping of sines with correctly selected amplitudes, starting from the fundamental frequency and higher, one sinus per harmonic.  But the harmonic synthesis <i>will need to be stopped when the Nyquist frequency is reached</i> .  This approach will give an ideal <i>band-limited</i> (eng. Bandlimited) waveform, all of whose spectral components are strictly between the fundamental frequency and the Nyquist frequency. <br>  Naturally, there is one problem.  This method could be suitable for the highest octaves, where the fundamental (fundamental) frequency is so high that few harmonics remain before the Nyquist frequency.  But for the lower octaves there are a lot of harmonics, to put it mildly: at a frequency of 44.1 kHz, a square wave with a fundamental frequency of 100 Hz will have 219 harmonics to Nyquist, which means that in total, <code>sin()</code> must be calculated 220 times each sample.  In the polyphonic model, this number is still multiplied by the number of notes played.  On the one hand, the sinuses for each note need only be folded once for each note.  But this is true if we do not have any modulation of the tone.  Once it is there, the frequency can change each sample, so a lot of work needs to be done. <br><br><h3>  BLIPs and BLEPs </h3><br><br>  There are other approaches to the synthesis.  Most notable: <br><ul><li>  <a href="https://ccrma.stanford.edu/~stilti/papers/blit.pdf">Band-limited impulse sequence</a> (Bandlimited Impulse Train, BLIT) </li><li>  <a href="http://www.cs.cmu.edu/~eli/papers/icmc01-hardsync.pdf">Minimum phase band-limited step function</a> (Minimum-Phase Bandlimited Step, MinBLEP) </li><li>  <a href="http://www.kvraudio.com/forum/viewtopic.php%3Ft%3D375517">Polynomial band-limited step function</a> (Polynomial Bandlimited Step, PolyBLEP) </li></ul><br><br>  The last two approaches are based on the fact that aliasing arises only because of sharp drops in the form of a wave.  With those waveforms that we synthesize, the only problem is these sharp drops.  Can we shake them like a piece of sandpaper?  Simple rounding is equivalent to easy low-pass filtering, and this is not what we need.  We need to filter nothing before the Nyquist frequency, and have nothing higher than it, as if it were just superimposed sinuses. <br>  Synthesis of a meander from the sinuses looks like this: <br><br><img src="https://habrastorage.org/files/daa/829/024/daa8290247934f96b059938e99a715d5.gif"><br><br>  The sinuses superimposed on each other are marked in blue, the resulting band-limited meander in red.  As you can see, these are not just rounded corners.  This waveform has characteristic vibrations, ‚Äúripples‚Äù. <br>  If simplified, the BLEP methods first generate a waveform, <a href="http://habrahabr.ru/post/226439/">as we did before</a> , and then apply this ripple.  This eliminates (or strongly suppresses) aliasing. <br><br>  If you clicked on the links above, you can already guess that the PolyBLEP method is the simplest.  We use it! <br><br><h3>  Class PolyBLEPOscillator </h3><br><br>  <a href="https://en.wikipedia.org/wiki/Is-a"><code>PolyBLEPOscillator</code> is an <code>Oscillator</code></a> , so we will <a href="http://www.learncpp.com/cpp-tutorial/115-inheritance-and-access-specifiers/">inherit publicly</a> from the latter. <br><br>  Create a new <i>PolyBLEPOscillator</i> class in our project.  If you have not read the previous articles, download the <a href="">finished project</a> and start from now. <br><br>  This is the class definition: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Oscillator.h"</span></span></span><span class="hljs-meta"> class PolyBLEPOscillator: public Oscillator { public: PolyBLEPOscillator() : lastOutput(0.0) { updateIncrement(); }; double nextSample(); private: double poly_blep(double t); double lastOutput; };</span></span></code> </pre><br><br>  We inherit publicity from <code>Oscillator</code> .  To change the way of synthesis, we define a new member function <code>nextSample</code> .  We also add a new <code>private</code> function <code>poly_blep</code> , which will generate oscillations on the meander ramps.  <code>lastOutput</code> stores the last generated value (this is only needed for a triangular waveform). <br>  Add the <code>poly_blep</code> implementation to the <i>PolyBLEPOscillator.cpp</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// PolyBLEP by Tale // (slightly modified) // http://www.kvraudio.com/forum/viewtopic.php?t=375517 double PolyBLEPOscillator::poly_blep(double t) { double dt = mPhaseIncrement / twoPI; // 0 &lt;= t &lt; 1 if (t &lt; dt) { t /= dt; return t+t - t*t - 1.0; } // -1 &lt; t &lt; 0 else if (t &gt; 1.0 - dt) { t = (t - 1.0) / dt; return t*t + t+t + 1.0; } // 0 otherwise else return 0.0; }</span></span></code> </pre><br><br>  This may look a little sophisticated, but, in fact, the function almost always returns <code>0.0</code> , except when we are close to a differential.  The first <code>if</code> for the case when we are at the beginning of the period, and the other <code>else if</code> for when we are almost at the very end.  This is the behavior of the saw, because there is only one difference in it, between two periods. <br><br>  Before implementing <code>nextSample</code> , you need to change something in the class of the oscillator.  Make the <code>nextSample</code> function in <i>Oscillator.h</i> virtual: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nextSample</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre><br><br>  This means that we can change the behavior of the <code>nextSample</code> function in our subclass.  Using <code>virtual</code> in code with critical execution times is not the best solution.  You can use <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD%25D1%258B_C%252B%252B">templates</a> (and avoid duplicating code), but I want to leave the explanation at a simple level and not be distracted from the topic of synthesis. <br>  Change <code>private:</code> to <code>protected:</code>  This way we will be able to access parameters such as <code>mPhase</code> from the member functions of <code>PolyBLEPOscillator</code> . <br>  As I already said, we use our waveforms with aliasing from the <code>Oscillator</code> class and impose <code>poly_blep</code> on them.  Currently, <code>nextSample</code> calculates the waveform and increments the phase.  We need to separate these unrelated things. <br>  Add the following <code>protected</code> member function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">naiveWaveformForMode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OscillatorMode mode)</span></span></span></span>;</code> </pre><br><br>  This function will calculate waveforms with aliasing.  <i>Naive</i> here means that the waveform is generated in a simple and incorrect way.  Let's write it in <i>Oscillator.cpp</i> (you can just copy it, because it is almost identical to <code>Oscillator::nextSample</code> ) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Oscillator::naiveWaveformForMode(OscillatorMode mode) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (mode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_SINE: value = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(mPhase); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_SAW: value = (<span class="hljs-number"><span class="hljs-number">2.0</span></span> * mPhase / twoPI) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_SQUARE: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mPhase &lt; mPI) { value = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = <span class="hljs-number"><span class="hljs-number">-1.0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> OSCILLATOR_MODE_TRIANGLE: value = <span class="hljs-number"><span class="hljs-number">-1.0</span></span> + (<span class="hljs-number"><span class="hljs-number">2.0</span></span> * mPhase / twoPI); value = <span class="hljs-number"><span class="hljs-number">2.0</span></span> * (<span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(value) - <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre><br><br>  The differences from <code>Oscillator::nextSample</code> as follows: <br><ul><li>  The waveform is selected depending on the <code>mode</code> parameter transmitted from outside (instead of <code>mOscillatorMode</code> ) </li><li>  Saw is now ascending, not descending </li></ul><br><br>  Since  this function contains all the code from <code>Oscillator::nextSample</code> , replace the body of <code>nextSample</code> with this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Oscillator::nextSample() { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value = naiveWaveformForMode(mOscillatorMode); mPhase += mPhaseIncrement; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (mPhase &gt;= twoPI) { mPhase -= twoPI; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre><br><br>  Here, <code>naiveWaveformForMode</code> is simply called to calculate the waveform and <code>mPhase</code> . <br><br><h3>  PolyBLEP generation </h3><br><br>  Let's go back to <i>PolyBLEPOscillator.cpp</i> and write <code>nextSample</code> .  Let's start like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> PolyBLEPOscillator::nextSample() { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> value = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> t = mPhase / twoPI; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOscillatorMode == OSCILLATOR_MODE_SINE) { value = naiveWaveformForMode(OSCILLATOR_MODE_SINE); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOscillatorMode == OSCILLATOR_MODE_SAW) { value = naiveWaveformForMode(OSCILLATOR_MODE_SAW); value -= poly_blep(t); }</code> </pre><br><br>  The variable <code>t</code> necessary for the <code>poly_blep</code> function to work.  This is the current phase value divided by <code>twoPI</code> , so it is always between <code>0</code> and <code>1</code> .  The first <code>if</code> separates the waveforms.  Antialiasing is not needed for sine, since it has only one, the first harmonic itself is its fundamental frequency.  For a saw, we first get a simple waveform from an oscillator, and then we impose a <code>pily_blep</code> on it - that's all! <br>  Create a triangle like this: first, take the meander, and then <i>integrate</i> it.  Since we work with discrete values, integration simply means the summation of values.  If you estimate, the meander begins with solid units, so their summation will give a linear increment.  After the half-cycle, solid units are minus, their integration will give a linear decline.  The triangle is just that: linear growth and linear decline. <br>  Keeping this in mind, we will write the code immediately for both the meander and the triangle: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { value = naiveWaveformForMode(OSCILLATOR_MODE_SQUARE); value += poly_blep(t); value -= poly_blep(<span class="hljs-built_in"><span class="hljs-built_in">fmod</span></span>(t + <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>));</code> </pre><br><br>  And again we start with a simple wave with aliasing.  But this time we impose <i>two</i> PolyBLEPs.  One for the start of the period, the other is offset by <code>0.5</code> periods, since  meander have two drops.  The saw has only one differential. <br>  What is missing is a triangle.  Add to the end of the <code>else</code> block: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOscillatorMode == OSCILLATOR_MODE_TRIANGLE) { <span class="hljs-comment"><span class="hljs-comment">// Leaky integrator: y[n] = A * x[n] + (1 - A) * y[n-1] value = mPhaseIncrement * value + (1 - mPhaseIncrement) * lastOutput; lastOutput = value; }</span></span></code> </pre><br><br>  Earlier, I wrote that we will integrate the meander.  This is not entirely accurate.  If we simply integrate, this will lead to huge output values, that is, we will have a monstrous overload.  Instead, you need to use a <i>quasi-</i> integrator (leaky integrator).  It summarizes the new value with the old one, but multiplied by the value slightly less than one.  Thus, the values ‚Äã‚Äãdo not go off-scale. <br>  Let's finish the increment of the phase (everything is as before): <br><br><pre> <code class="cpp hljs"> } mPhase += mPhaseIncrement; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (mPhase &gt;= twoPI) { mPhase -= twoPI; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value; }</code> </pre><br><br>  It was just so easy to create a <code>PolyBLEPOscillator</code> ! <br><br><h3>  Using the new oscillator </h3><br><br>  To use our brilliant new <code>PolyBLEPOscillator</code> you just need to swap a couple of lines in <i>Voice.h</i> .  Replace <code>#include "Oscillator.h"</code> with <code>#include "PolyBLEPOscillator.h"</code> . <br>  In the <code>private</code> section, turn <code>mOscillatorOne</code> and <code>mOscillatorTwo</code> into objects of the <code>PolyBLEPOscillator</code> class: <br><br><pre> <code class="cpp hljs">PolyBLEPOscillator mOscillatorOne; PolyBLEPOscillator mOscillatorTwo;</code> </pre><br><br>  That's all!  Launch our plugin and let's look at the spectrum.  As you can see, the aliasing effect is very noticeably eliminated.  Screenshots before / after for comparison: <br><br>  Saw: <br><img src="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/saw_aliased.png" alt="image"><br><img src="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/saw_polyblep.png" alt="image"><br><br>  Meander: <br><img src="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/square_aliased.png" alt="image"><br><img src="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/square_polyblep.png" alt="image"><br><br>  Triangle: <br><img src="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/triangle_aliased.png" alt="image"><br><img src="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/triangle_polyblep.png" alt="image"><br><br><h3>  What about the LFO? </h3><br><br>  We still use the old <code>Oscillator</code> for the LFO.  Should I switch to <code>PolyBLEPOscillator</code> ?  In fact, sharp boundaries are very desirable in the LFO, with the help of them you can get interesting effects.  And aliasing doesn‚Äôt really bother us because  the fundamental frequency is usually low, less than 30 Hz.  Each next harmonic has an amplitude lower than the previous one, so frequencies above the Nyquist have a very small amplitude. <br><br><h3>  Total </h3><br><br>  We generated a meander and a saw without aliasing using aliasing waveforms, which we imposed on PolyBLEP.  The triangle was generated using a quasi-integrator and a meander without aliasing.  Now you can happily play our synth on the highest octaves and not be afraid that there will be disharmonious frequencies! <br><br>  The code can be downloaded <a href="">from here</a> . <br><br>  Thanks for reading!  :) <br><br>  <a href="http://martin-finke.de/blog/articles/audio-plugins-018-polyblep-oscillator/">Original post</a> . </div><p>Source: <a href="https://habr.com/ru/post/232153/">https://habr.com/ru/post/232153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../232135/index.html">The path of a freelancer. Part 1. Tips for beginners</a></li>
<li><a href="../232137/index.html">New "Authors' Market" on Habr√©</a></li>
<li><a href="../232139/index.html">MegaIndex: a technology leader in the field of automated website promotion</a></li>
<li><a href="../232149/index.html">EtherCalc: Spreadsheets on Node.js</a></li>
<li><a href="../232151/index.html">Mini-printer for screenshots from a smartphone</a></li>
<li><a href="../232155/index.html">IQLab challenge: prove that you are the best</a></li>
<li><a href="../232157/index.html">Generating xkcd passwords in PHP</a></li>
<li><a href="../232159/index.html">Ladies of warez</a></li>
<li><a href="../232163/index.html">The script to create mirror updates for Eset Nod32 on Linux</a></li>
<li><a href="../232167/index.html">Business architecture of car toll systems using satellite navigation data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>