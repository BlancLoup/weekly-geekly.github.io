<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>More on one innovation in the latest version of SObjectizer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When we started talking about our OpenSource actor framework for C ++ on Habr√©, we promised to describe some features of the SObjectizer implementatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>More on one innovation in the latest version of SObjectizer</h1><div class="post__text post__text-html js-mediator-article"><p>  When we started talking about our OpenSource actor framework for C ++ on Habr√©, we promised to describe some features of the SObjectizer implementation details.  One of the new features, which was implemented <a href="https://sourceforge.net/p/sobjectizer/news/2017/05/sobjectizer-v5519-released/">in the recently released version 5.5.19</a> , is great for such a story.  In addition, it is also interesting because we had to look at the scenarios of using SObjectizer from a completely different side.  You could even say that one of our templates was broken. </p><br><p>  It is about the ability of SObjectizer to perform all its actions on one single working thread.  Starting from version 5.5.19, you can even use the Actor- and Publish / Subscribe models in a single-threaded application.  It is clear that the actors will have to work in cooperative multitasking mode, but in some cases this is exactly what is required. </p><br><h1>  And where you may need to use actors in a single-threaded application? </h1><a name="habracut"></a><br><p>  As it turned out, there is a whole class of tasks where small lightweight applications are needed.  Inside which the use of actors in general and SObjectizer, in particular, is appropriate, but the creation of several worker threads and the associated overhead costs are already like a cannon on sparrows. </p><br><p>  Let's say we can have a large application consisting of the main master process and child processes ‚Äî workers, of which there can be at least a hundred, even a thousand.  The master process distributes the work of workers and takes the results of their work, and also controls the viability of the workers, restarting them as needed.  Child workers, as a rule, should be simple and lightweight processes.  I very much want each of them to manage with just one working thread.  Indeed, it is one thing to have a system of a thousand processes-workers with one thread inside, quite another - a thousand workers with four working threads inside. </p><br><p>  Or another example: a small program that should occasionally poll a couple of devices and send the captured data to the MQTT broker.  Work with each of the devices can be framed in the form of agents.  But multithreading is hardly required.  Moreover, all of this can work on a small single-board device with limited resources, and even if the single-board device itself draws an ordinary Linux distribution, it still makes no sense to spend resources without due reason. </p><br><h1>  Where is the gap between our template? </h1><br><p>  Originally, SObjectizer was created as a tool to simplify the development of large and complex multi-threaded applications.  SObjectizer-based dispatchers and agent interaction only by means of asynchronous messages allow writing applications with dozens, and even hundreds, of worker threads inside, while the programmer does not have to deal with any mutex or condition_variable.  Therefore, we did not even consider the segment of small single-threaded applications as a niche for the use of SObjectizer.  As it turned out, nothing.  Model Actors and Publish / Subscribe quite well and feel in single-threaded applications. </p><br><h1>  How did we manage to make SObjectizer work in single-threaded mode? </h1><br><p>  First you need to tell why SObjectizer-in general needed several worker threads.  These workflows are needed for: </p><br><ol><li>  Timer services.  SObjectizer starts a separate timer thread, which determines the time for sending pending and periodic events.  When a timer thread is used, the processing of messages by agents has almost no effect on the accuracy of the timer. <br><br></li><li>  Completion of the deregistration of the cooperation.  When co-operation with agents is withdrawn from the SObjectizer Environment, all agents entering the co-operation must be untied from their dispatchers.  And dispatchers, accordingly, should release the resources allocated to agents.  So, if the agent was bound to the active_obj dispatcher, then the dispatcher must complete the work of the dedicated thread and call join () for it.  And here it is very important on which context join () will be called.  For if you call join () on the context of the thread for which join () is called, a classic deadlock will arise.  Therefore, SObjectizer uses a separate thread, which sends notifications that all cooperation agents have completed their work completely and can be untied from the dispatchers.  Therefore, all joins are safely called on the context of this particular thread. <br><br></li><li>  Maintenance agents tied to the default dispatcher.  If the programmer does not explicitly bind the agent to any particular dispatcher, then the agent is bound to the default dispatcher.  This default dispatcher needs some kind of working thread on which it will trigger events for the agents attached to it. </li></ol><br><p>  It turns out that when the normal SObjectizer is launched by calling so_5 :: launch, the current thread (that is, the one on which so_5 :: launch was called) is used to perform the initial actions, after which it is blocked until the end of the work of the SObjectizer Environment.  Along the way, SObjectizer creates the three threads described above for the timer, the final deregistration of the cooperatives and the default controller.  Plus there are as many threads as additional dispatchers will need. </p><br><p>  We wanted SObjectizer to do all the operations it needs on the context of just one thread - the one on which the so_5 :: launch call occurred. </p><br><p>  For this we needed to introduce a new concept - <i>environment infrastructure</i> , i.e.  infrastructure that will serve the needs of the SObjectizer itself.  The corresponding interface was made, the insides of the SObjectizer Environment were reworked, so that the methods of this interface were twitched in the right places.  Well, then several implementations were made: </p><br><ul><li>  <b>default_mt</b> is a good old implementation that uses a few extra working threads.  It is created and used by default if the programmer has not explicitly specified another type of environment infrastructure; </li><li>  <b>simple_mtsafe</b> is a simple single-threaded implementation in which timers, deregistration of cooperations and the default dispatcher use the thread on which so_5 :: launch was called.  But at the same time, the simple_mtsafe infrastructure provides the thread safety of SObjectizer.  More on this below; </li><li>  <b>simple_not_mtsafe</b> is another simple single-threaded implementation in which timers, deregistration of cooperatives and the default dispatcher also use the same thread on which so_5 :: launch was called.  However, the thread safety of SObjectizer is not ensured. </li></ul><br><h2>  How do single-threaded infrastructures work? </h2><br><p>  At the core of simple single-threaded infrastructures is a single cycle, within which the SObjectizer Environment consistently performs the following actions: </p><br><ul><li>  checks the presence of fully ready for deregistration cooperation.  If there are any, it performs the final deregistration of these cooperatives and destroys the agents in them; </li><li>  checks for the presence of triggered timers and, if any, dispatches deferred / periodic messages whose response time has arrived; </li><li>  Checks the presence of requests in the queue of the default dispatcher.  If the queue is not empty, then the first is taken and executed, after which the cycle is repeated again. </li></ul><br><p>  In this case, obviously, the accuracy of the timer begins to depend on which agents work on the default dispatcher: if these agents quickly process their events, the timer works more or less accurately.  If the processing can be delayed for seconds or tens of seconds, then the accuracy of the timer turns out to be no, and after the completion of the lengthy handler, a packet of timer events can be generated immediately.  But this is quite a natural payment for the absence of a separate timer thread. </p><br><p>  The word ‚Äúsimple‚Äù in the simple_mtsafe and simple_not_mtsafe names is used for a reason, but because the default dispatcher uses a simple FIFO event processing scheme without taking into account the priorities of the agents.  <i>If someone needs a single-threaded infrastructure with support for the priorities of agents, then let us know, we will include such a refinement in our work plan</i> . </p><br><h2>  What is the difference between simple_mtsafe and simple_not_mtsafe? </h2><br><p>  We need to clarify why we have simple_mtsafe and simple_not_mtsafe, and what SObjectizer‚Äôs protection against multithreading generally means. </p><br><p>  Basically, there are two situations where we may need a single-threaded SObjectizer: </p><br><ol><li>  Single-threaded SObjectizer should work strictly within a single-threaded application.  Those.  SObjectizer launched on the main thread and everything, then all the work is done only inside the SObjectizer.  There are no other worker threads, you cannot access the SObjectizer from outside the main application thread.  For such a situation, the simple_not_mtsafe infrastructure is intended.  In its implementation, it uses the fact that they work with SObjectizer from only one thread, so the insides of SObjectizer do not need to be protected from multithreading. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </li><li> Single-threaded SObjectizer should work inside a multi-threaded application.  For example, the GUI interface should work on the main thread of the application, and the SObjectizer should work on the next thread.  In this case, it is possible to contact SObjectizer not only from the thread on which it is running.  But also with any other application thread.  For example, a GUI thread can create new cooperatives, destroy old cooperatives, send messages to agents.  For such a situation, the simple_mtsafe infrastructure is intended.  It protects the internals of SObjectizer from multi-threaded access, which makes possible the operation of SObjectizer on one thread, and sending messages to SObjectizer from another thread. </li></ol><br><p>  We see the simple_mtsafe infrastructure task in minimizing the overhead of a SObjectizer, but at the same time retaining the ability of SObjectizer to work in a multi-threaded application.  So, in simple_mtsafe, SObjectizer will use only one working thread instead of three or four, as is the case with the default_mt infrastructure.  But at the same time, the user can create as many additional workflows in his application as he needs, and the name, while being able to interact with the SObjectizer from these threads. </p><br><p>  The main application of simple_mtsafe we ‚Äã‚Äãsee in the development of small GUI-applications, in which the developer wants to transfer part of his logic to an additional stream, in which the SObjectizer will spin.  At the same time, the main flow of the application will remain available for servicing GUI-related operations. </p><br><p>  But the simple_not_mtsafe infrastructure is needed only for cases when the user wants to have that single-threaded application, in which there should be a single workflow on which all of the application‚Äôs operations are performed. </p><br><p>  Accordingly, we see the main application of simple_not_mtsafe in small utilities, with more or less complex logic inside, but in which resource saving is important.  In lightweight processes ‚Äî worker ‚Äî ah.  And also in applications for very weak platforms. </p><br><p>  Just in that the simple_not_mtsafe infrastructure is intended only and exclusively for single-threaded applications, there is a fundamental difference in the implementations of simple_mtsafe and simple_not_mtsafe: the infrastructure of simple_mtsafe is forced to protect its ‚Äúoffal‚Äù mutex.  While simple_not_mtsafe does not need to do this. </p><br><p>  As a result, the basic infrastructure operation cycles simple_mtsafe and simple_not_mtsafe are very similar, and they differ in the presence of working with std :: mutex in the case of simple_mtsafe.  Code for simple_mtsafe: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ACTIVITY_TRACKER &gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">env_infrastructure_t</span></span>&lt; ACTIVITY_TRACKER &gt;::run_main_loop() { m_activity_tracker.wait_started(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex &gt; lock( m_sync_objects.m_lock ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { process_final_deregs_if_any( lock ); perform_shutdown_related_actions_if_needed( lock ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">shutdown_status_t</span></span>::completed == m_shutdown_status ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; handle_expired_timers_if_any( lock ); try_handle_next_demand( lock ); } }</code> </pre> <br><p>  And for simple_not_mtsafe: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ACTIVITY_TRACKER &gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">env_infrastructure_t</span></span>&lt; ACTIVITY_TRACKER &gt;::run_main_loop() { m_activity_tracker.wait_started(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { process_final_deregs_if_any(); perform_shutdown_related_actions_if_needed(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">shutdown_status_t</span></span>::completed == m_shutdown_status ) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; handle_expired_timers_if_any(); try_handle_next_demand(); } }</code> </pre> <br><p>  <b>Note</b>  The simple_mtsafe infrastructure methods (such as process_final_deregs_if_any () and try_handle_next_demand ()) are passed a link to std :: unique_lock so that you can release the mutex for the duration of the corresponding operations, and then grab it again. </p><br><p>  True, working with std :: mutex in simple_mtsafe is not free.  The efficiency of the simple_mtsafe infrastructure on synthetic benchmarks like ping-pong is 25% -30% lower than that of the default_mt and simple_not_mtsafe infrastructures.  Which is quite expected. </p><br><h1>  Current status and future directions of work </h1><br><p>  Version 5.5.19, which implements the default_mt, simple_mtsafe, simple_not_mtsafe infrastructures, <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/SObjectizer%2520Core%2520v.5.5/">is available for download at SourceForge</a> .  There is also relevant <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5.19%2520Environment%2520Infrastructure/">documentation</a> . </p><br><p>  Currently, the simple_not_mfsafe infrastructure does not have its own mutex, but only for its own main working cycle and related data structures (for example, the mutex lists of cooperatives and time-based applications that are not ready for final deregistration are not protected).  However, in other parts of SObjectizer, various synchronization primitives (like mutex and spinlock) are still present.  For example, inside each agent there is a spinlock, which, in principle, is not needed for simple_not_mtsafe, but it takes its place inside the agent_t class. </p><br><p>  This happened because, according to preliminary estimates, an attempt to remove SObjectizer‚Äôs internals from the synchronization objects for the simple_not_mtsafe infrastructure could delay the work on version 5.5.19 for at least a few more months.  What we really did not want. </p><br><p>  We also didn‚Äôt want to break the compatibility between the SObjectizer versions, which would be inevitable if we tried to switch to the use of template magic for a more efficient implementation of simple_not_mtsafe.  For example, one of the ideas was to set the type of infrastructure for the agent as a template parameter.  Then I would have to describe my agent classes in some way: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ENV_INF&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>&lt;ENV_INF&gt; { ... };</code> </pre> <br><p>  And this would necessarily break the compatibility and significantly complicate the translation of the old code to the new versions of SObjectizer. </p><br><p>  Therefore, we decided in version 5.5.19 to leave the already existing synchronization objects as is, and to consider the way of removing them for simple_not_mtsafe when developing the next version.  Here, we begin to think.  If it seems to someone that this is a very important thing, then let me know, we will start thinking more intensively;) </p><br><p>  In order to demonstrate where all this can lead in the limit, we tried to write down <a href="http-so-55-restinio-asio.html">an example of a primitive single-threaded HTTP server in which asynchronous request processing is delegated to SObjectizer</a> .  At the same time, both the HTTP server (based on the parser from NodeJS and Asio) and SObjectizer work together on the only main thread of the application.  It seems to work.  However, related technologies, like <a href="">restinio</a> (our asynchronous HTTP server) and so_5_extra (allows you to live together on the same thread of SO-5 and Asio) have not yet reached production quality.  But we are working on it. </p><br><h1>  Instead of an afterword </h1><br><p>  Work on version 5.5.19 took much more time than we ourselves expected, although the reason <a href="https://sourceforge.net/p/sobjectizer/blog/2017/05/why-there-is-so-big-pause-between-5518-and-5519-releases/">is quite objective reasons</a> .  We hope that the next version, 5.5.20, work on which, in fact, has already begun, we will be able to roll out much more quickly.  Something like a <a href="https://sourceforge.net/p/sobjectizer/discussion/550088/thread/31dbc561/">wish-list</a> is being formed <a href="https://sourceforge.net/p/sobjectizer/discussion/550088/thread/31dbc561/">for the new version</a> .  Well and, accordingly, readers have the opportunity to influence the functionality of SObjectizer.  Write to us in the comments what you would like to see in SObjectizer.  Or, on the contrary, what you would not want to see.  Or maybe something prevents you from using SObjectizer? </p><br><p>  We listen very carefully to what we are told.  So, at one time, we got rid of the so_5 :: rt namespace and added features such as agent priorities, hierarchical finite automata, and mutable messages precisely because of discussions of SObjectizer on various specialized resources and not only.  Therefore, there is a very real chance to make SObjectizer a tool you need, only by somebody else‚Äôs hands :) </p></div><p>Source: <a href="https://habr.com/ru/post/328872/">https://habr.com/ru/post/328872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328862/index.html">Cisco Meraki MX: Security Settings on the Perimeter in 4 Clicks</a></li>
<li><a href="../328864/index.html">Why programmers can not program</a></li>
<li><a href="../328866/index.html">Using the stm32cube library to create platform independent drivers</a></li>
<li><a href="../328868/index.html">Analysis of the relationship of skills using graphs in R</a></li>
<li><a href="../328870/index.html">The best toys for future techies of our childhood (USSR and USA)</a></li>
<li><a href="../328874/index.html">PHDays VII: how the new rules of the "Confrontation" will affect the balance of power</a></li>
<li><a href="../328876/index.html">Antifraud systems in popular mobile trackers: AppsFlyer, Adjust, AppMetrica, TMC, Kochava</a></li>
<li><a href="../328880/index.html">Laravel more about Homestead</a></li>
<li><a href="../328882/index.html">Attack of the WannaCry cipher family: analysis of the situation and readiness for the next attacks</a></li>
<li><a href="../328886/index.html">Who you are? How did you learn to program? What are you striving for? 20,000 responses</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>