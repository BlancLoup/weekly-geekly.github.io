<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Kicks to common sense (part 9)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... And everything will repeat as before: 
 Night ice channel ripples 
 Pharmacy, street, lantern. 

 Alexander Blok 


 Today, I want to talk about t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Kicks to common sense (part 9)</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>... And everything will repeat as before:</i></b> <b><i><br></i></b>  <b><i>Night ice channel ripples</i></b> <b><i><br></i></b>  <b><i>Pharmacy, street, lantern.</i></b> <b><i><br><br></i></b>  <b><i>Alexander Blok</i></b> <br><br><br>  Today, I want to talk about the problem, traditionally ignored by most board game developers.  If a computer implementation of a game, like checkers or chess, correctly handles situations of winning (or losing) players (and this is also <a href="http://habrahabr.ru/post/234587/">not easy</a> ), the result is considered to be quite satisfactory.  But what if the game is at a standstill?  Players move pieces, without any hope of winning (and can continue to do so indefinitely). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When playing a person with a computer, this is not a problem (it is clear who will get tired first), but what to do if two bots are playing?  To compare the ‚Äústrength‚Äù of various AI variants, for example, a large number of games are required to be automatically played.  Proper handling of "anyone's" in such a situation is vital.  And it is highly desirable that it be carried out in strict accordance with the rules of the game. <br><a name="habracut"></a><br><h4>  <b>2. Repetition</b> </h4><br>  The most straightforward approach is used in games of the "Checkers" family.  The party is interrupted if none of the players can win for a given number of moves.  So, in our well-known <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Russian Checkers</a> , a game is considered a drawn game if it cannot be won in 30 moves.  More complex rules related to the specifics of "slow-moving ladies" are used in the <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">English Checkers</a> .  If each of the opponents has one queen left, it is allowed to make no more than 20 moves, until recognition of a draw.  If one opponent has three queens, and another has two, the latter has the right to demand that the game be played in no more than 40 moves.  The <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">International Checkers</a> Rules describe all possible situations <a href="http://skyruk.livejournal.com/259756.html">in</a> more <a href="http://skyruk.livejournal.com/259756.html">detail</a> : <br><br><ul><li>  If players for 25 moves made moves only with queens, without moving simple checkers and without taking a draw, a draw is declared. </li><li>  If a player has 3 queens at the end of the game, 3 queens and 1 simple, 1 lady and 2 simple, 3 simple checkers, 2 queens, 1 lady and 1 simple against a single lady or 1 lady against a single lady or a single lady, the player must 5 In a move, win, otherwise a draw is declared. </li><li>  If there are 5 ladies on the board (or 4 ladies and 1 simple checker) against 2 ladies, the strongest side must win 50 moves, otherwise a draw is declared. </li><li>  If the same position is repeated three (or more) times (i.e., the same arrangement of the checkers), moreover, the turn of the turn each time after the same side - a draw is also declared. </li></ul><br>  Variations of the last of the listed rules are often used in other games.  In chess, a threefold repetition of the position (taking into account the sequence of the move) is one of the possible reasons for recognizing a " <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B8%25D1%2587%25D1%258C%25D1%258F_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)">draw</a> ".  In some games (for example, <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE">Go</a> ) to repeat the position is prohibited.  I already <a href="http://geektimes.ru/post/240680/">wrote</a> about the problem of "Ko" in this game.  Briefly recall what is at stake: <br><br><img src="https://habrastorage.org/files/5b4/b25/a31/5b4b25a31036479ead586a0b6a5ff2e2.PNG"><br><br>  If the repetition of the position were allowed, the players could continue this sequence of moves to infinity (by taking more and more new stones from the opponent).  This can be fought by forbidding White to play C17, after Black‚Äôs move on D17, but repeating the position may be more difficult.  In the game, situations of ‚Äútriple Co.‚Äù and even more complex positions of ‚ÄúEternal Life‚Äù are possible: <br><br><img src="https://habrastorage.org/files/970/891/486/9708914864fe4192a418db92a8339459.PNG"><br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%2598%25D0%25BD%25D0%25B3%25D0%25B0">Inga's</a> rules try to regulate this issue, but the result is difficult to be considered satisfactory.  In order to distinguish the "combat" Co. from the "disturbing" requires high qualifications.  A beginner is unlikely to handle this.  In a simplified <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BF%25D1%2580%25D0%25BE%25D1%2589%25D1%2591%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25B0_%25D0%2598%25D0%25BD%25D0%25B3%25D0%25B0">version of the</a> rules, the position is simply forbidden to repeat.  This approach is called ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BA%25D0%25BE">superco</a> ‚Äù and can determine the repetition of the position in two different ways: <br><br><ul><li>  Positional Superco - an unconditional prohibition on the repetition of positions, without taking into account the sequence of the move </li><li>  Super Situational Situation - prohibiting repetition of a position, provided that the turn of the same player turns </li></ul><br>  In general, it is clear that the ability to compare different positions may be useful when implementing some board games (and vital for AI), but given the fact that you have to compare a lot, a simple element-wise comparison of positions may be too expensive.  To solve this problem, well-known computer games developer <a href="https://en.wikipedia.org/wiki/Albert_Lindsey_Zobrist">Albert Lindsey Zobrist</a> developed a simple and elegant <a href="http://research.cs.wisc.edu/techreports/1970/TR88.pdf">method</a> , named after him. <br><br>  <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist hashing is</a> applicable to most board games and its essence is simple.  First of all, a table of random numbers is compiled (the more randomly the better), for each possible position of each figure.  In the case of Chess, for each of the 64 board fields, 12 random values ‚Äã‚Äãwill be required (one for each type of pieces, taking into account the color).  Further, a hash is compiled by " <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25BE_%25D0%25BC%25D0%25BE%25D0%25B4%25D1%2583%25D0%25BB%25D1%258E_2">adding modulo 2</a> " of numbers taken from the table for the corresponding arrangement of the pieces on the board.  Of course, if the hash values ‚Äã‚Äãfor the two positions coincide, this does not mean that the positions are the same.  The probability of collisions always remains, but the use of this method allows minimizing the number of elementwise comparisons of positions. <br><br>  It is important that such a hash is obtained <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B4%25D0%25B4%25D0%25B8%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">additive</a> .  It is not necessary to view the entire position each time, building a hash from scratch.  We can ‚Äúmove‚Äù the piece across the board, using only hash.  To do this, you must remove from the hash the value corresponding to the old position of the shape and add a new one (both of which are performed by the xor operation).  Zobrist hashing is a very convenient technique and is used in most computer implementations of board games. <br><br>  Of course, in <a href="http://www.zillions-of-games.com/">ZoG</a> it is also used (in <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> , for sure), but only for internal needs.  The condition for stopping the game with a triple repetition of the position ‚Äúnailed‚Äù in the exe!  Axiom allows you to redefine the behavior (to complete the game with a defeat instead of a draw) or to detect the first repetition of a position instead of the third, but while working as an <a href="http://www.zillions-of-games.com/progsample.html">engine</a> for ZoG, he cannot cancel this test either.  To me personally, such unchangeable ‚Äúdefault behavior‚Äù has <a href="http://habrahabr.ru/post/224661/">spoiled</a> quite a few nerves. <br><br><div class="spoiler">  <b class="spoiler_title">Suffering by '' ur ''</b> <div class="spoiler_text">  Of course, the solution was on the surface, but, to my shame, I myself didn‚Äôt think of it (peeped in the <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D218">Liberian Checkers</a> implementation).  If the repeat position check cannot be disabled, you can try to make each position ‚Äúunique‚Äù.  To do this, it is enough to implement the simplest binary counter in ‚Äúextra‚Äù or hidden positions on the board (the figures will be invisible, but will violate the uniqueness of the position, which is what is required of them).  I remember in early childhood, my father taught me how to make these counters from <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B8%25D0%25B3%25D0%25B3%25D0%25B5%25D1%2580">DC-flip-flops</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Ensuring the uniqueness of positions</b> <div class="spoiler_text"><pre><code class="hljs delphi"><span class="hljs-comment"><span class="hljs-comment">{directions {link}</span></span> cntr q1 q2 <span class="hljs-comment"><span class="hljs-comment">{link}</span></span> cntr q2 q3 <span class="hljs-comment"><span class="hljs-comment">{link}</span></span> cntr q3 q4 <span class="hljs-comment"><span class="hljs-comment">{link}</span></span> cntr q4 q5 directions} : count-locks ( -- ) q1 <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> empty? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> LOCK create-piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TRUE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> capture cntr <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> ENDIF <span class="hljs-keyword"><span class="hljs-keyword">UNTIL</span></span> ;</code> </pre> <br></div></div><br>  That's all!  Just go in a given direction and add a shape to an empty position.  If the position is not empty, delete the figure and move on.  Unnecessary figures "litter" ZSG-notation, but they are required, as a rule, in those games where the recording of moves is already completely unreadable.  By the way, no <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2049">one said</a> that the counter must be binary: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/1ca/661/df1/1ca661df1b834fc7b51c43f9401d0380.gif"></div><br><br>  Pay attention to the upper left corner of the picture.  By only slightly changing the implementation, you can visualize very nice move / take counters, even though there is no arithmetic in ZRF!  Such counters can also be useful for calculating the number of ‚Äúunsuccessful‚Äù moves, within the framework of the implementation of the rules sounded at the beginning of the article.  Unfortunately, this solution cannot be called straightforward.  The use of such techniques leads to an excessive complication of both the ZSG notation and the program itself, and any complication - a loophole for all sorts of errors. <br></div></div><br>  The absence of any possibility of setting up a repeat position check in ZoG, I consider one of the most serious design errors of this program.  Along with <a href="http://habrahabr.ru/post/251401/">‚Äúcheckmated‚Äù</a> and <a href="http://habrahabr.ru/post/253397/">‚Äúmaximal captures‚Äù</a> , this option is worthy of a bronze monument being cast in honor of it, on the theme ‚Äúnever to be done‚Äù.  With the help of ZRF, you can only override the behavior when a threefold repetition of the position is detected, but no more.  By default, the following definition applies: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">draw-condition</span></span> (<span class="hljs-name"><span class="hljs-name">White</span></span> Black) repetition)</code> </pre><br>  One thing is that I can‚Äôt set up this check in any way (for example, to detect the first repetition of a position, and not the third one) is already very bad, but the fact that I cannot turn off this check when it only hinders is just awful!  In my project, I would use (and hopefully still use) something like the following definition: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">not-situation-repeated</span></span>? <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  This is <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE_%25D0%25BA%25D0%25BE">Ko</a> .  The first argument determines which counting of the position must be detected, and the second - the depth of the search.  And it should be a universal expression that can be used not only in the condition of completing the game (as in ZRF), but also in any invariant used by the move generator (since in Gu the repetition of the position should prohibit the move and not interrupt the game).  Of course, it should also be possible to use the predicate <b>* -position-repeated?</b>  , to determine the positional Co., along with situational. <br><br>  Perhaps for the sake of all the above, it would not be worthwhile to plot this article, but Zobrist hashing found another unexpected use.  There is one truly legendary <a href="http://skyruk.livejournal.com/241051.html">game</a> that <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D428">connects</a> " <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Checkers</a> " and " <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B8-%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25B8%25D0%25BA%25D0%25B8">Tic-tac-toe</a> ".  Also, as in the African " <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2384">Bolotoudou</a> ", it is required to build lines "3 in a row" from its stones in order to shoot the stones of the enemy, but, unlike the latter, for this game there are <a href="http://www.iggamecenter.com/info/ru/ninemenmorris.html">options</a> that prohibit taking the build by building the same row two times in a row. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/csy39T5G220%3Ffeature%3Doembed&amp;xid=17259,15700002,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjNACdb6YzJSpVK96ExwsKyym1bFA" frameborder="0" allowfullscreen=""></iframe><br><br>  It is easy to notice that in the video <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D428">implementation</a> , such a check is not performed and it is not accidental!  I find it difficult to come up with a requirement that would be more difficult to implement on ZRF.  This check should control the repetition of the position, but not all, but only its parts.  If three stones make up a line ("the mill"), their repeated location in the same places, in one turn, should be either prohibited or should not lead to taking.  But even a hash can be built only partially! <br><br><div class="spoiler">  <b class="spoiler_title">Partial Hash Build</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> direction) (<span class="hljs-name"><span class="hljs-name">let</span></span> hash <span class="hljs-number"><span class="hljs-number">0</span></span>) (<span class="hljs-name"><span class="hljs-name">add-to-zobrist-hash</span></span> hash) (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) (<span class="hljs-name"><span class="hljs-name">add-to-zobrist-hash</span></span> hash) (<span class="hljs-name"><span class="hljs-name">check</span></span> direction) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) (<span class="hljs-name"><span class="hljs-name">add-to-zobrist-hash</span></span> hash) (<span class="hljs-name"><span class="hljs-name">check</span></span> (<span class="hljs-name"><span class="hljs-name">not-situation-repeated</span></span>? hash <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>)) )</code> </pre><br></div></div><br>  Here, we move along the chosen <b>direction</b> and successively add three positions to the hash if there are friendly stones on them.  After that, we check if such a hash was formed two moves back.  It is implied that the hash keys of all stones are unique, for example, formed on the basis of the attribute value set when adding stones to the board: <br><br><div class="spoiler">  <b class="spoiler_title">Ensuring uniqueness</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> man-drop (<span class="hljs-name"><span class="hljs-name">check</span></span> (<span class="hljs-name"><span class="hljs-name">decrement!</span></span> mans-left)) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-empty?) drop-pieces (<span class="hljs-name"><span class="hljs-name">set!</span></span> unique mans-left) add-move )</code> </pre><br></div></div><br>  With the removal of enemy stones, everything is also not so simple.  Firstly, in most variants of the game, it is impossible to remove stones that make up one of the enemy‚Äôs ‚Äúmills‚Äù (in some varieties such stones are allowed to be removed if there are no other options for taking).  In addition, if we, under our own power, managed to build several ‚Äúmills‚Äù at the same time, we have the right to take an appropriate number of enemy stones (this rule is also often neglected). <br><br><div class="spoiler">  <b class="spoiler_title">Taking stones</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> capturing (<span class="hljs-name"><span class="hljs-name">let</span></span> capturing-count (<span class="hljs-name"><span class="hljs-name">count</span></span> (<span class="hljs-name"><span class="hljs-name">any</span></span> (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> n) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> ne) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> s) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> sw) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> e) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> se) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> w) (<span class="hljs-name"><span class="hljs-name">check-in-line</span></span> nw) ) ) ) (<span class="hljs-name"><span class="hljs-name">while</span></span> (<span class="hljs-name"><span class="hljs-name">decrement!</span></span> capturing-count) (<span class="hljs-name"><span class="hljs-name">all</span></span> any-position (<span class="hljs-name"><span class="hljs-name">check</span></span> is-enemy?) (<span class="hljs-name"><span class="hljs-name">check</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> n) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> ne) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> s) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> sw) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> e) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> se) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> w) (<span class="hljs-name"><span class="hljs-name">check-in-enemy-line</span></span> nw) ))) capture add-move-part ) ) )</code> </pre><br></div></div><br>  As you can see, the ancient developers of board games have worked hard so that we do not get bored with their implementation.  That's probably all that I wanted to tell about the use of Zobrist hashing in the project "Dagaz".  I hope that my story was interesting to you. <br></div><p>Source: <a href="https://habr.com/ru/post/265047/">https://habr.com/ru/post/265047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../265037/index.html">7 tips on how to improve the performance of your site in Microsoft Edge and other modern browsers</a></li>
<li><a href="../265039/index.html">Git for Windows 2.5.0 released</a></li>
<li><a href="../265041/index.html">CRM plus mobile communications. We strike integration at low sales</a></li>
<li><a href="../265043/index.html">Backup ESXi virtual machines with ghettoVCB scripts</a></li>
<li><a href="../265045/index.html">Processor "in slow motion" and its system on a chip</a></li>
<li><a href="../265049/index.html">Business automation: 5 interesting tools (and their analogues)</a></li>
<li><a href="../265051/index.html">Attack on archivers. Hiding in one archive from three programs</a></li>
<li><a href="../265053/index.html">Old market or restored servers conquered the USA and Europe</a></li>
<li><a href="../265055/index.html">Microsoft has released an emergency update for Internet Explorer</a></li>
<li><a href="../265057/index.html">Creating a tester for match-3 games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>