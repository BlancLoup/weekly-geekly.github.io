<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compiler bug? Linker? No, Windows kernel bug</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heisenbag is the worst thing that can happen. In the study described below, which stretched for 20 months , we have already reached the point where we...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compiler bug? Linker? No, Windows kernel bug</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e65/f62/6e4/e65f626e491aebf6a450879d6862b015.png" alt="image" align="right">  Heisenbag is the worst thing that can happen.  In the study described below, which stretched for <b>20 months</b> , we have already reached the point where we began to look for hardware problems, errors in compilers, linkers, and other things that should be done at the very last.  Usually, it is not necessary to translate arrows in this way (the bug is most likely in your code), but in this case we are on the contrary - we didn‚Äôt have enough of a global view of the problem.  Yes, we did find a bug in the linker, but in addition to it we also found a bug in the Windows kernel. <br><br>  In September 2016, we began <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D644525">to notice</a> randomly occurring errors when building Chrome - 3 builds out of 200 failed due to the crash of the protoc.exe process.  This is one of the binaries, which when assembling Chromium is first assembled by itself, and then launched to generate header files for other components.  But instead, it fell with an ‚Äúaccess violation‚Äù error. <br><a name="habracut"></a><br>  The developers who investigated this problem understood that something strange was happening, but could not reproduce the problem locally, so they had to guess about its causes.  Several corrections were made at random - <a href="https://codereview.chromium.org/2324823002">changing the order of the arguments</a> , <a href="https://chromiumcodereview.appspot.com/2427943002">explicitly adding dependencies</a> .  The latter seemed to work - the problems disappeared. <br><br>  But now, literally a couple of days after the bug was celebrated for a year from the day it was created, the problem arose again.  The heavens opened and a loud alarm sounded about the build of the project.  Over the next few months, about 10 different fixes were <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D644525">added</a> in an attempt to rectify the situation.  Something they may have improved, but according to the statistics of the success of the assembly, it was clear that none of them solved the main problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Local reproduction of the problem </h2><br>  I joined this research almost by accident - I once managed to reproduce a bug on my machine.  I ran the ‚Äúbad‚Äù binary under the debugger and saw the following: <br><br><pre><code class="hljs cs">‚Ä¶ <span class="hljs-number"><span class="hljs-number">00000001400010</span></span>A1 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rax],al <span class="hljs-number"><span class="hljs-number">00000001400010</span></span>A3 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rax],al mainCRTStartup: <span class="hljs-number"><span class="hljs-number">00000001400010</span></span>A5 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rax],al <span class="hljs-number"><span class="hljs-number">00000001400010</span></span>A7 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [rax],al ‚Ä¶</code> </pre> <br>  Now we have a problem that we can at least put into words: <b>why are large pieces of a code segment of a binary filled with zeros?</b> <br><br>  I deleted the "bad" binary and linked it again - this time the zero byte sequences were replaced with the correct instructions and it did not fall again.  A long array of zero bytes belonged to the code that created the VC ++ incremental linker so that somehow it is more convenient for it to transfer functions.  At this point, it became obvious that we found a bug in the incremental linker, right?  It was impossible to disable it completely - incremental linking is an important part of the strategy for optimizing the build time of large binaries (like our chrome.dll).  But we could <a href="https://chromium-review.googlesource.com/777764">disable</a> it for smaller binaries like protoc.exe and the like.  So we did. <br><br>  And it helped fix this particular bug in this particular case.  But, as it turned out, this was not the bug that we were actually looking for and which broke most of our builds. <br><br>  Two weeks later, Chrome assembly fell on my computer again.  And it was already an assembly that included the previous fix with disabled incremental linking for protoc.exe.  This time there was again an array of zero bytes in the binary instead of the correct code instructions, but it was already in the code, the creation of which the incremental linker had no relation to. <br><br>  Moreover, these zero bytes were already inserted into the code by another tool ‚Äî by this time I switched from the linker from Microsoft to lld-link (use_lld = true in the build parameters).  Moreover, this time I and the compiler used another (clang instead of VC ++).  It turns out that replacing the entire assembly toolchain in general did not help fix this problem.  This means that the problem is not in the toolchain.  By this time, <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D644525">mass hysteria</a> seemed to be the best explanation for what was happening. <br><br><h2>  But no, we have science! </h2><br>  No wonder the tools and methods of development and debugging have been <a href="https://store.xkcd.com/products/try-science">improved for many years</a> .  We have something that we can oppose to the heisenbags.  The bug was reproduced on my computer more often than on the others, since I was then engaged in optimizing the Chrome build, and I made these assemblies significantly more than the average programmer (even much more than other Chrome developers).  Well, if you need a lot of builds to play a bug, so let's do a lot of builds. <br><br>  I changed my scripts to build Chrome again and again in an infinite loop, which should stop only when the bug makes itself felt.  With the system of <a href="">distributed</a> assembly and the <a href="">minimum level of generation of symbolic information,</a> I could (with good luck) collect Chrome up to 12 times per hour.  With such a frequency of assemblies, even so rarely reproduced a bug began to occur steadily at least once every half day.  Besides him, of course, other bugs ( <a href="https://habrahabr.ru/company/infopulse/blog/349924/">zombies!</a> ) Began to emerge, but this is another story. <br><br>  And then I suddenly got lucky.  One morning I logged into my computer, which drove the Chrome assembly all night and saw that the genmodule.exe module had crashed (and different binaries were falling every time).  Since the build was stopped at that, I had exactly the same binary on the disk, whose launch caused the crash during the build.  And I decided to start it again - it is always more interesting to see a ‚Äúlive‚Äù crash than to dig into the old dumps.  But this time the binaries did not fall. <br><br>  I had crashes (because Windows Error Reporting on my computer was <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb787181%2528v%3Dvs.85%2529.aspx%3Ff%3D255%26MSPPError%3D-2147217396">configured to save local crash dumps</a> , which I advise all Windows developers to do).  In this cracksdump, I saw a sequence of zeros already familiar to me at the point where the code was executed.  This sequence of instructions didn‚Äôt, in any theory, could be executed without error.  I ran the genmodule.exe binary again under the debugger, reached the same address - and there was a normal code, no zeros. <br><br>  I downloaded the crash dump in WinDbg and typed ‚Äú! Chkimg‚Äù.  This command compares the bytes of the commands in the crash dump with the corresponding bytes in the binary image on the disk.  This can be useful, for example, in cases of hardware failures of RAM or HDD, as well as patch errors.  I have seen cases where up to several tens of bytes were subject to change for the above reasons.  In this case, the binary on the disk and the executable code from the crash dump differed in <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D644525">9322 bytes</a> . <br><br>  Perhaps in this place, when the executable code of the binary in memory does not match the bytes in the image of this binary on the disk, it is too sensitive of you to stop reading.  In fact, what next to believe in?  But still continue! <br><br>  Now we can formulate the problem even more specifically: <b>why do we execute the wrong code that the linker wrote in the binary?</b> <br><br>  It began to look like a bug in the Windows file system.  Perhaps something related to caching.  It looked as if the file loader was reading pages with zero bytes when reading a binary from the disk instead of actually written by the linker to the instruction file. <br><br>  My colleague Zack advised me to run the <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D644525">sync</a> utility from sysinternals after the linker was done.  I refused at first - the sync launch is very resource intensive and requires administrative rights, but in the end I gave up and decided to run this test.  Over the weekend I collected Chrome from scratch more than 1000 times, with administrator rights, in three different versions: <br><br><ul><li>  <b>Normal build</b> : drops in 3.5% of cases </li><li>  <b>7-second pause after the end of the linker</b> : a fall in 2% of cases </li><li>  <b>Running sync.exe after the linker is finished</b> : a single crash </li></ul><br>  Hooray!  Running sync.exe is, of course, not fixing the problem (it is very resource intensive), but already something!  The next step was a small C ++ program that opened the newly linked binary and called <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa364439%2528v%3Dvs.85%2529.aspx%3Ff%3D255%26MSPPError%3D-2147217396">FlushFileBuffers</a> for it.  It worked much faster and did not require administrative rights.  And it also prevented the crash bug for 100% of the builds.  The final step was to rewrite it in Python, <a href="https://chromium-review.googlesource.com/876683">add the</a> main Chrome branch to the assembly and write a tweet about it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ff/152/5be/9ff1525beeb6119a01c050b016da89fd.png" alt="image"><br><br>  Later that day (I didn‚Äôt even have time to send the official bug report to Microsoft) - I received a letter from my former colleague, who now works at Microsoft, who asked about this bug from my tweet. <br><br>  I shared with him my findings and research methodology.  He and his colleagues tried to reproduce the bug - but they failed.  Perhaps because they didn‚Äôt run Chrome as many times as I did.  But they helped me set up ETW - a tool that can record a very detailed log of events occurring in the system and stop recording at the time of the error.  After several attempts I managed to reproduce the bug and write down the ETW-log.  I sent it to the guys from Microsoft - I hope it helps them understand the problem. <br><br>  The problem was that when the linker writes a PE file (EXE or DLL) using the Memory Mapped File mechanism and the program then immediately starts (or the library is loaded by calling LoadLibrary / LoadLibraryEx) and the OS is currently under heavy load on / output, the flush call may fail.  This is a very rare event, and I can imagine its appearance only on build servers, like my <a href="https://randomascii.wordpress.com/2017/07/09/24-core-cpu-and-i-cant-move-my-mouse/">24-processor monster</a> when building very large projects, such as Chrome.  Microsoft programmers confirmed that my solution with forced Flush after the end of linking should help fix the problem (I also came to this conclusion, because by this time I had received about 600 consecutive builds without a single crash) and promised to make a correction to the Windows kernel. <br><br><h2>  If you want to understand yourself </h2><br>  Most likely you will not be able to reproduce this bug in a reasonable time on your home computer.  I laid out the cracks, corresponding binary and symbol file <a href="https://github.com/randomascii/blogstuff/tree/master/kernelbug_644525">on GitHub</a> .  You can load them into Visual Studio and see the zeros I mentioned above.  You can also load them into WinDbg and use the! Chkimg command: <br><br><pre> <code class="bash hljs">0:000&gt; .sympath . Symbol search path is: . 0:000&gt; .ecxr eax=cbb75f7e ‚Ä¶ re2c!mainCRTStartup: 00412d40 0000 add byte ptr [eax],al ds:002b:cbb75f7e=?? 0:000&gt; !chkimg 9658 errors : @<span class="hljs-variable"><span class="hljs-variable">$ip</span></span> (00408000-00415815) 0:000&gt; uf eip re2c+0x12d40: 00412d40 0000 add byte ptr [eax],al 00412d42 0000 add byte ptr [eax],al 00412d44 0000 add byte ptr [eax],al 00412d46 0000 add byte ptr [eax],al</code> </pre> <br><h2>  Difficulties in the study </h2><br>  1) Build Chrome causes the CcmExec.exe process to lose handles, which multiplies the zombie processes, I wrote a separate article about it. <br><br>  2) Most Windows developers have seen the number 0xC0000005 many times to remember that it means Access Violation.  That is, your program turned to the area of ‚Äã‚Äãmemory where it was absolutely not worth contacting.  But few people can look at the numbers 3221225477 or -1073741819 and say what they mean.  And in fact, this is the same number 0xC0000005, deduced as a signed or unsigned decimal integer.  Your eye will always catch on 0xC0000005, but at the sight of a negative number of a couple of billions you will not have a single thought. <br><br>  3) When examining this bug ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D644525">crbug.com/644525</a> ), another one was found ( <a href="https://bugs.chromium.org/p/chromium/issues/detail%3Fid%3D812421">crbug.com/812421</a> ).  I was worried that it was the same bug or two interconnected, but it turned out that they were two completely different stories.  The first bug was completed with everything described in this article above, and the second concerned <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/mt637065%2528v%3Dvs.85%2529.aspx%3Ff%3D255%26MSPPError%3D-2147217396">Control Flow Guard</a> - protection against the exploitation of certain types of vulnerabilities.  It turned out that sometimes using problems with incremental linking and control flow guard.  The simple solution was to update our build configurations so that the <a href="https://chromium-review.googlesource.com/920761">/ incremental and / cfg keys are never used together</a> (this makes little sense anyway). <br><br><h2>  Epilogue </h2><br>  We still do not know what caused this problem to affect us.  Perhaps this is our transition to a new build system, which somewhat changed the order of steps in this operation. <br><br>  Also, we do not know why the bug, having appeared once, suddenly disappeared for a whole year.  Perhaps it was generally several different bugs, one of which was accidentally fixed in the past?  Or are we just lucky? <br><br>  In any case, after our latest fixes, Chrome has become more stable.  I can again run a series of my build performance tests without the risk of failing. <br><br>  My problem fix works reliably for all combinations of compilers and linkers.  If you are working on a program that creates executable binaries, then you should also add something like calling <a href="https://github.com/llvm-mirror/llvm/commit/8b2a3e8b203a332bbd71cb9a5708f870dec3ae74">FlushFileBuffers</a> before closing the file.  (I, for example, sent an internal bug to the Go developers).  The problem is currently reproduced on all versions of Windows from 7 to the last 10 with all the installed updates, so take care to fix it if this concerns you. </div><p>Source: <a href="https://habr.com/ru/post/350126/">https://habr.com/ru/post/350126/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350114/index.html">Android data migration tools and improved application support</a></li>
<li><a href="../350116/index.html">Open lesson on "Introduction to JSON Schema"</a></li>
<li><a href="../350118/index.html">Features of the national hunting for bugs or Bug Bounty in Slavic</a></li>
<li><a href="../350120/index.html">Object classification in real time</a></li>
<li><a href="../350124/index.html">Online shooter on Unreal Engine 4 for 90 hours (video creation + source)</a></li>
<li><a href="../350128/index.html">Instruction: what to do if you do not have time to deadline</a></li>
<li><a href="../350130/index.html">Open Data Day in Moscow 2018</a></li>
<li><a href="../350132/index.html">GObject: Inheritance and Interfaces</a></li>
<li><a href="../350134/index.html">DoctrineSolrBundle - Search by Solct-based Doctrine entity on Symfony2 / 3</a></li>
<li><a href="../350136/index.html">Random evolutionary strategies in machine learning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>