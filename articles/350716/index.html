<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust: why do we need macros</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I once told my colleague that there were macros in Rust, it seemed to him that this was bad. I used to have the same reaction, but Rust showed me that...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust: why do we need macros</h1><div class="post__text post__text-html js-mediator-article"><p>  I once told my colleague that there were macros in Rust, it seemed to him that this was bad.  I used to have the same reaction, but Rust showed me that macros are not necessarily bad. </p><br><p>  Where and how to apply them?  Look under the cut. </p><a name="habracut"></a><br><h1 id="pochemu-my-dolzhny-opasatsya-makrosov">  Why should we be wary of macros </h1><br><p> Macros are a form of <a href="https://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> : they are code that manipulates code.  Metaprogramming has received a bad reputation, because using them is not easy to avoid writing bad code.  Examples are <code>#define</code> in C, which <a href="https://en.wikipedia.org/wiki/Hygienic_macro">can easily interact with the code in unpredictable ways</a> , or <code>eval</code> in JavaScript, which increase the danger of <a href="https://stackoverflow.com/a/18208029">code injection</a> . </p><br><h2 id="o-makrosah-v-rust">  About macros in Rust </h2><br><p>  Many of these problems can be solved by using the necessary tools, while macros provide some of these tools: </p><br><ul><li>  generating a redundant / trivial code (boilerplate) instead of writing it manually. </li><li>  language extension before new syntax is added, closing spaces in the language. </li><li>  performance optimization - for some actions that were previously performed at runtime are now executed at the compilation stage -1-. </li></ul><br><p>  In order to achieve these goals, Rust includes two types of macros -2-.  They are known by various names (procedural, declarative, <code>macro_rules</code> , etc.), although I believe that these names are somewhat confusing.  Fortunately, they are not so important, so I will call them <strong>functional</strong> and <strong>attribute</strong> . </p><br><p>  The reason that there are two types of macros is that they are well suited for various tasks: </p><br><ul><li>  functional: easy to include in the code. </li><li>  attribute: better suited to generate code that does not fit into the surrounding code. </li></ul><br><p>  In all other respects, the results of their use are similar: the compiler "erases" macros during compilation, replacing them with code generated from a macro, and compiling it with "normal", not macro code -3-.  The implementation of the two types of macros is very different, but we will not go deeply into this here. </p><br><h2 id="pochemu-funkcionalnye-makrosy">  Why functional macros </h2><br><p>  A functional macro can be executed almost as a function.  This type of macro has <code>!</code>  in the call: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = action(); <span class="hljs-comment"><span class="hljs-comment">//   let y = action!(); //  </span></span></code> </pre> <br><p>  Why use macros when you can use functions?  It must be remembered that functional macros have nothing to do with functions ‚Äî they are similar to functions so that they, macros, are easier to use.  Therefore, the question is not whether this type of macros is better than functions or not, but whether we need the ability to change the source code. </p><br><h2 id="poleznye-utverzhdeniya">  Useful statements </h2><br><p>  Let's start by looking at <code>assert!</code>  which is used to verify that a condition is met, causing <a href="https://doc.rust-lang.org/std/macro.panic.html">panic</a> if it is not.  They are checked at runtime, so what does metaprogramming give us here?  Let's look at the message that is printed when <code>assert!</code>  fails: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-comment"><span class="hljs-comment">//    vec.push(1); //      assert!(vec.is_empty()) //    - assert!   // : // thread 'main' panicked at 'assertion failed: vec.is_empty()', src\main.rs:4 }</span></span></code> </pre> <br><p>  This message contains a condition that we are checking.  In other words, the macro creates an error message that is based on the source code, we receive a meaningful error message without inserting it into the program manually. </p><br><h2 id="tipo-bezopasnaya-rabota-s-formatom-strok">  Tipo-safe work with the format of lines </h2><br><p>  Many programming languages ‚Äã‚Äãsupport setting output formats for -4- lines.  Rust is no exception and also supports defining string formats with <code>format!</code>  .  However, the question still remains: why should we use metaprogramming to solve the problem?  Let's look at <code>println!</code>  (he uses <code>format!</code> inside to process the passed string) -5-. </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//   println!("{} is {} in binary", 2, 10); // : 2 is 10 in binary //        println!("{0} is {0:b} in binary", 3) // : 3 is 11 in binary }</span></span></code> </pre> <br><p>  There are many reasons that <code>format!</code>  implemented as a macro -6-, I want to emphasize the fact that it can split a line into parts during compilation, analyze it and check whether the processing of the passed arguments is type-safe.  We can change our code and get a compilation error: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{} is {} in binary"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-comment"><span class="hljs-comment">/*, 10*/</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  :   ,    println!("{0} is {0:b} in binary", "3") //  :        }</span></span></code> </pre> <br><p>  In many other languages, these errors would appear at runtime, but in Rust we can use macros to perform this check at compile time and generate productive code to process the format of the string without run-time checks -7-. </p><br><h2 id="legkoe-logirovanie">  Easy logging </h2><br><p>  In this example, we‚Äôll go into the language ecosystem a bit.  Rust has <a href="https://docs.rs/log/">a log package</a> , which is used as the main front end logging.  Like other solutions for logging, it provides different levels of logging, but, unlike other solutions, these levels are represented by macros, rather than functions. </p><br><p>  Logging shows the power of metaprogramming in how it uses <code>file!</code> macros <code>file!</code>  and <code>line!</code>  ;  These macros make it possible to determine the exact location of the call to the logging function in the source code.  Let's look at an example.  Since <code>log</code> is frontend, <a href="https://docs.rs/flexi_logger/">let's</a> add a backend, the <a href="https://docs.rs/flexi_logger/">flexi_logger</a> package. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> log; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> flexi_logger; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> flexi_logger::{Logger, LogSpecification, LevelFilter}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//  `trace`      let log_config = LogSpecification::default(LevelFilter::Trace).build(); Logger::with(log_config) .format(flexi_logger::opt_format) // Specify how we want the logs formatted .start() .unwrap(); //    .      info!("Fired up and ready!"); complex_algorithm() } fn complex_algorithm() { debug!("Running complex algorithm."); for x in 0..3 { let y = x * 2; trace!("Step {} gives result {}", x, y) } }</span></span></code> </pre> <br><p>  This program will print: </p><br><pre> <code class="hljs css"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[2018-01-25 14:48:42.416680 +01:00]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">INFO</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[src\main.rs:16]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Fired</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">up</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">and</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ready</span></span>! <span class="hljs-selector-attr"><span class="hljs-selector-attr">[2018-01-25 14:48:42.418680 +01:00]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DEBUG</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[src\main.rs:22]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Running</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">complex</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">algorithm</span></span>. <span class="hljs-selector-attr"><span class="hljs-selector-attr">[2018-01-25 14:48:42.418680 +01:00]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRACE</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[src\main.rs:25]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Step</span></span> 0 <span class="hljs-selector-tag"><span class="hljs-selector-tag">gives</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span> 0 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[2018-01-25 14:48:42.418680 +01:00]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRACE</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[src\main.rs:25]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Step</span></span> 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">gives</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span> 2 <span class="hljs-selector-attr"><span class="hljs-selector-attr">[2018-01-25 14:48:42.418680 +01:00]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TRACE</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[src\main.rs:25]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Step</span></span> 2 <span class="hljs-selector-tag"><span class="hljs-selector-tag">gives</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">result</span></span> 4</code> </pre> <br><p>  As you can see, our logs contain file names and line numbers. </p><br><ul><li>  we get this information without the runtime overhead of getting this data. </li><li>  The information is correct and useful. </li></ul><br><p>  In the first case, the compiler inserts the necessary information into executable files, which we can print if necessary.  If we did not solve this problem at compile time, we <a href="https://stackoverflow.com/questions/115008/how-can-we-print-line-numbers-to-the-log-in-java">would have to examine the stack at run time</a> , which is fraught with errors and reduces performance. </p><br><p>  If we replace the logging macros with functions, we can still call <code>file!</code>  and <code>line!</code>  : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span></span>(input: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   info! Log::log( logger(), RecordBuilder::new() .args(input) .file(Some(file!())) .line(Some(line!())) .build() ) }</span></span></code> </pre> <br><p>  And this code would output the following: </p><br><pre> <code class="hljs pgsql">[<span class="hljs-number"><span class="hljs-number">2018</span></span><span class="hljs-number"><span class="hljs-number">-01</span></span><span class="hljs-number"><span class="hljs-number">-25</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>:<span class="hljs-number"><span class="hljs-number">48</span></span>:<span class="hljs-number"><span class="hljs-number">42.416680</span></span> +<span class="hljs-number"><span class="hljs-number">01</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [src\loggers\<span class="hljs-keyword"><span class="hljs-keyword">info</span></span>.rs:<span class="hljs-number"><span class="hljs-number">7</span></span>] Fired up <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ready!</code> </pre> <br><p>  The file name and line number are useless, for they indicate where the <strong>logging function</strong> was called.  In other words, the first example worked just because we used macros that were replaced by the generated code, putting the <code>file!</code>  and <code>line!</code>  directly to the source code, providing us with the necessary information (the file name and line number are now in the executable file) -8-. </p><br><h2 id="pochemu-atributnye-makrosy">  Why Attribute Macros </h2><br><p>  Rust includes the concept of <a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a> , which is needed for tagging code.  For example, the test function looks like this: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-comment"><span class="hljs-comment">// &lt;-  fn my_test() { assert!(1 &gt; 0) }</span></span></code> </pre> <br><p>  Running the <code>cargo test</code> will launch this feature.  Attribute macros allow you to create new attributes that are similar to native attributes, but have other effects.  At the moment there is an important limitation: in the compiler from the stable branch, only macros using <a href="https://rustbyexample.com/trait/derive.html">the derive</a> attribute are working, while custom attributes work in <a href="https://rustbyexample.com/trait/derive.html">nightly builds</a> .  Consider the difference below. </p><br><p>  Considering the advantages given by attribute macros, it is advisable to compare code that <strong>can</strong> manipulate source code with one that <strong>cannot</strong> . </p><br><h2 id="poluchenie-izbytochnogo-koda-boilerplate">  Obtaining a redundant code (boilerplate) </h2><br><p>  <a href="https://rustbyexample.com/trait/derive.html">The</a> <code>derive</code> <a href="https://rustbyexample.com/trait/derive.html">attribute is</a> used in Rust to generate the implementation of types.  Let's look at <code>PartialEq</code> . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span></span> { content: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data = Data { content: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(data == Data { content: <span class="hljs-number"><span class="hljs-number">2</span></span> }) }</code> </pre> <br><p>  Here we create a structure whose instances we want to check for equality (use <code>==</code> ), so we get the implementation of <code>PartialEq</code> -9-.  We could implement <code>PartialEq</code> independently, but our implementation would be trivial, because we only want to check objects for equality: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">PartialEq</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Data { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eq</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;Data) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.content == other.content } }</code> </pre> <br><p>  This code also generates a compiler for us, so using the macro saves us time, however, more importantly, it saves us from having to support checking for equality of the code in the current state.  If we add a field to the structure, we need to change the validation in our manual implementation of <code>PartialEq</code> , otherwise (for example, if we forget to change the verification code), verification of different objects can be successful. </p><br><p>  Getting rid of the burden of support is a big advantage that the attribute macro gives us.  We wrote the structure code in one place and automatically got the realization of the function of checking and guaranteeing the compilation time that the verification code corresponds to the current structure definition.  A striking example of this is the <a href="https://serde.rs/">serde</a> package used to serialize data, and without macros we would <a href="https://serde.rs/impl-serialize.html">need to use strings to indicate serde to the names of the structure fields</a> , keeping these strings up to date with respect to defining the structure -10-. </p><br><h2 id="derive-s-preimuschestvami">  Derive with benefits </h2><br><p>  <code>derive</code> is one of the many possibilities for code generation by attribute macros, and not just the implementation of types.  At the moment it is available in <a href="https://github.com/rust-lang/rust/issues/38356">nightly assemblies</a> , which I hope will be <a href="https://github.com/rust-lang/rust/issues/38356">stabilized this year</a> . </p><br><p>  The most outstanding use case at the moment is <a href="https://rocket.rs/">Rocket</a> - a library for writing web servers.  Creating REST-endpoints requires adding an attribute to a function, so now the function contains all the necessary information to process the request. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[post(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/user"</span></span></span><span class="hljs-meta">, data = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;new_user&gt;"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new_user</span></span></span></span>(admin: AdminUser, new_user: Form&lt;User&gt;) -&gt; T { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  If you have worked with web libraries in other languages ‚Äã‚Äã(for example, <a href="http://flask.pocoo.org/">Flask</a> or <a href="https://spring.io/">Spring</a> ), then this style is probably not new to you.  I will not compare these libraries here, I will only note that you can write similar code in Rust, taking advantage of its advantages (high performance of the resulting native code, etc.) -11-. </p><br><h2 id="nedostatki">  disadvantages </h2><br><p>  Macros are not perfect, consider some of their flaws: </p><br><ul><li>  increased compilation time, as time is spent getting code from a macro and compiling this code. </li><li>  Macros can lead to an increase in the size of the machine code, because it is easy to fall into copy-paste when using them, in which a small line can turn into a large block of code.  Previously, it was a problem <a href="https://clap.rs/">clap</a> package, about which the author wrote a <a href="https://clap.rs/2018/01/09/new-years-weight-loss/">good note describing the problem and how to put the code on a diet</a> . </li><li>  debugging becomes more difficult, because you need to debug the generated code.  Fortunately, there are <a href="https://github.com/dtolnay/cargo-expand">tools</a> that can help you.  Readability and informational content of error messages when using macros depends not on the compiler, but on the authors of the macro.  Again, there are the necessary tools (for example, <code>compiler_error!</code> And packages like <a href="https://github.com/dtolnay/syn">syn</a> ). </li><li>  DSL overload (a slightly subjective item).  For example, <code>format!</code>  accepts a string written in a mini-language that is not Rust, but <a href="https://stackoverflow.com/questions/809574/what-is-domain-specific-language-anybody-using-it-and-in-what-way">DSL</a> .  Although DSL is a powerful tool, its use can easily put into difficulty if the developer wants to create his own embedded language.  If you decide to write DSL, remember that big opportunities mean a lot of responsibility, and the fact that you can do DSL does not imply the need to do it. </li></ul><br><h2 id="vyvody">  findings </h2><br><p>  Macros are a powerful tool that can help in development.  I hope I was able to instil in you the idea that the macros in Rust are a positive thing and have cases when their use is appropriate. </p><br><p>  -1-: Do not confuse with <code>const fn</code> . <br>  -2-: Known as Macros 1.1. <br>  -3-: Replacing a macro with a generated code is called a macro extension. <br>  -4-: For example, <a href="https://en.wikipedia.org/wiki/Printf_format_string">printf in C</a> , <a href="https://msdn.microsoft.com/en-us/library/system.string.format(v%3Dvs.110).aspx">String.Format in C #</a> , <a href="https://docs.python.org/2/library/stdtypes.html">formatting strings in Python</a> . <br>  -5-: <code>format!</code>  deals with formatting a string that can be used by <code>println!</code> macros <code>println!</code>  and <a href="https://doc.rust-lang.org/std/fmt/">others</a> . <br>  -6-: <a href="https://en.wikipedia.org/wiki/Variadic_function">varargs</a> uses <code>format!</code>  .  This feature (varargs) conflicts with the decision to <a href="https://github.com/rust-lang/rfcs/pull/153">prohibit overloading functions</a> , so using a macro is very appropriate - no need to add support to the core language. <br>  -7-: Scala has a good implementation of <a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html">string interpolation</a> , which does checks at the compilation stage.  I do not know whether the interpolation of lines in Rust will be added, although we have already seen similar examples: <code>try!</code>  It has evolved <a href="https://blog.rust-lang.org/2016/11/10/Rust-1.13.html">from a macro to a built-in ability in a language</a> , so that this is possible with appropriateness. <br>  -8-: Rust has a problem - panicked methods (for example, <code>unwrap</code> and <code>expect</code> ) give useless error messages because they <a href="">do not have access to information about the calling code</a> . <br>  -9-: <code>PartialEq</code> is a type used to check objects for equality, we also use <code>Eq</code> for correctness.  <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">The</a> <code>PartialEq</code> <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html">documentation</a> explains why there is a similar division in Rust. <br>  -10-: The problem can be solved by reflection, which is not supported in Rust, because it contradicts the design of the language, as it <a href="https://stackoverflow.com/a/26424561">reduces the performance of the runtime, because it requires an appropriate runtime</a> . <br>  -11-: Sergio Benitez, author of Rocket, made a <a href="https://www.youtube.com/watch%3Fv%3DQS8mrbAPLJc">good performance</a> related to this. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350716/">https://habr.com/ru/post/350716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350700/index.html">The girls and the fourth industrial revolution</a></li>
<li><a href="../350702/index.html">A couple of tips for beginners gamedeveloper from novice gamedeveloper</a></li>
<li><a href="../350708/index.html">Containers of the introduction of dependencies and the benefits of their use</a></li>
<li><a href="../350710/index.html">Investigate the minor features of C # 7</a></li>
<li><a href="../350712/index.html">FastTrack Training. "Network Basics". "Basics of routing." Eddie Martin December 2012</a></li>
<li><a href="../350718/index.html">We generate levels for the game using neural networks</a></li>
<li><a href="../350720/index.html">[Not only to students] Packet Tracer Lab</a></li>
<li><a href="../350724/index.html">Germicidal emitters for smartphones. Prospects for the integration of these systems in gadgets</a></li>
<li><a href="../350728/index.html">How to recover lost text</a></li>
<li><a href="../350730/index.html">Creating a network with Internet access in GNS3 on Windows 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>