<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pointers are complex, or what is stored in a byte?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! I present to you the translation of the article "Pointers Are Complicated, or: What's in a Byte?" authorship of Ralf Jung. 


 This summe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pointers are complex, or what is stored in a byte?</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, Habr!  I present to you the translation of the article "Pointers Are Complicated, or: What's in a Byte?"  authorship of Ralf Jung. </p><br><p>  This summer I am working on Rust fulltime again, and I will again (among other things) work on a ‚Äúmemory model‚Äù for Rust / MIR.  However, before I talk about my ideas, I finally must dispel the myth that "pointers are simple: they are just numbers."  Both parts of this statement are erroneous, at least in languages ‚Äã‚Äãwith unsafe features, such as Rust or C: pointers cannot be called either prime or (ordinary) numbers. </p><br><p>  I would also like to discuss the part of the memory model that needs to be addressed before we can talk about the more complex parts: in <em>what form is the</em> data stored in memory?  A memory consists of bytes, minimum addressable units and the smallest elements that can be accessed (at least on most platforms), but what are the possible byte values?  Again, it turns out that ‚Äúit's just an 8-bit number‚Äù is not suitable as an answer. <a name="habracut"></a></p><br><p>  I hope that after reading this post, you will agree with me regarding both statements. </p><br><h1 id="ukazateli-slozhny">  Pointers are complicated </h1><br><p>  What is the problem with "pointers are regular numbers"?  Let's look at the following example: (I use C ++ here, since writing unsafe code in C ++ is easier than writing in Rust, and unsafe code is just the place where the problems appear. Insecure Rust and C have all the same problems that and C ++). </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-comment"><span class="hljs-comment">/* -     */</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = &amp;x[i]; *x_ptr = <span class="hljs-number"><span class="hljs-number">23</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  Optimizing the last read of y [0] with a return of 42 is always very beneficial.  The rationale for this optimization is that changing x_ptr, which points to x, cannot change y. </p><br><p>  However, when dealing with low-level languages ‚Äã‚Äãsuch as C ++, we can violate this assumption by assigning i the value yx.  Since &amp; x [i] is the same as x + i, we write 23 in &amp; y [0]. </p><br><p>  Of course, this does not prevent C ++ compilers from doing such optimizations.  To resolve this, the standard says that our code has <a href="https://www.ralfj.de/blog/2017/07/14/undefined-behavior.html">UB</a> . </p><br><p>  Firstly, it is not allowed to perform arithmetic operations on pointers (as in the case of &amp; x [i]), if in this case the pointer <a href="">goes beyond any of the boundaries of the array</a> .  Our program violates this rule: x [i] goes beyond x, so it is UB.  In other words, even <em>calculating</em> the x_ptr value is UB, so we don‚Äôt even get to the place where we want to <em>use</em> this pointer. </p><br><p>  (It turns out that i = yx is also UB, since <a href="">only pointers pointing to the same memory allocation</a> are <a href="">allowed to be subtracted</a> . However, we could write i = ((size_t) y - (size_t) x) / sizeof (int) to bypass this is a limitation.) </p><br><p>  But we are not done yet: this rule has the only exception that we can use to our advantage.  If the arithmetic operation calculates the value of the pointer to the address <em>exactly after the</em> end of the array, then everything is in order.  (This exception is necessary to calculate vec.end () for the most common loops in C ++ 98.) </p><br><p>  Let's change the example a bit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> y = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[<span class="hljs-number"><span class="hljs-number">8</span></span>]; y[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x_ptr = x+<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    if (x_ptr == &amp;y[0]) *x_ptr = 23; return y[0]; }</span></span></code> </pre> <br><p>  Now imagine that x and y were allocated <em>one after another</em> , with y having a larger address.  Then x_ptr points <em>to the beginning of</em> y!  Then the condition is true and assignment occurs.  At the same time, there is no UB due to the exit of the pointer abroad. </p><br><p>  It seems that this will not allow optimization.  However, the C ++ standard has another ace up its sleeve to help compiler creators: in fact, it does not allow us to use x_ptr.  According to what the standard says about <a href="">adding numbers to pointers</a> , x_ptr points to the address after the last element of the array.  It <em>does not</em> point to a specific element of another object, <em>even if they have the same address</em> .  (At least this is a common interpretation of the standard based on which <a href="https://godbolt.org/g/vxmtej">LLVM optimizes this code</a> .) </p><br><p>  And even though x_ptr and &amp; y [0] point to the same <em>address</em> , this does not make them the <em>same pointer</em> , that is, they cannot be used interchangeably: &amp; y [0] points to the first element of y;  x_ptr points to the address after x.  If we replace * x_ptr = 23 with the string * &amp; y [0] = 0, we will change the value of the program, even though the two pointers were checked for equality. </p><br><p>  This is worth repeating: </p><br><blockquote>  Just because two pointers point to the same address does not mean that they are equal and can be used interchangeably. </blockquote><p>  Yes, this difference is elusive.  In fact, this still causes differences in programs compiled with LLVM and GCC. </p><br><p>  Also note that this one-after rule is not the only place in C / C ++ where we can observe such an effect.  Another example is the restrict keyword in C, which can be used to express that pointers do not overlap (are not equal): </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">restrict</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span></span>{ *x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x == y) { *y = <span class="hljs-number"><span class="hljs-number">23</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> foo(&amp;x, &amp;x); }</code> </pre> <br><p>  Calling test () calls UB, since two memory accesses in foo should not occur at the same address.  Replacing * y with * x in foo, we will change the value of the program, and it will no longer call UB.  Once again: although x and y have the same address, they cannot be used interchangeably. </p><br><p>  Pointers are definitely not just numbers. </p><br><h1 id="prostaya-model-ukazateley">  Simple pointer model </h1><br><p>  So what is a pointer?  I do not know the full answer.  In fact, this is an open area for research. </p><br><p>  One important point: here we are looking at an <em>abstract</em> pointer <em>model</em> .  Of course, on a real computer, pointers are numbers.  But a real computer does not carry out the optimizations that modern C ++ compilers do.  If we wrote the above programs in assembler, then there would be no UB, no optimizations.  C ++ and Rust take a more ‚Äúhigher-level‚Äù approach to memory and pointers, limiting the programmer to the compiler.  When you need to formally describe what a programmer can and cannot do in these languages, the model of pointers as numbers is shattered, so we need to find something else.  This is another example of using a "virtual machine" different from a real computer for specification purposes - an idea that <a href="https://www.ralfj.de/blog/2017/06/06/MIR-semantics.html">I wrote about earlier</a> . </p><br><p>  Here is a simple sentence (in fact, this model of pointers is used in <a href="https://hal.inria.fr/hal-00703441/document">CompCert</a> and <a href="https://www.ralfj.de/blog/2017/07/08/rustbelt.html">my work by RustBelt</a> , as well as the way the <a href="https://github.com/solson/miri/">miri interpreter</a> implements <a href="">pointers</a> ): a pointer is a pair of some ID that uniquely identifies a memory area (allocation), and the offset is relative this area.  If you write this in Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pointer</span></span></span></span> { alloc_id: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span>, }</code> </pre> <br><p>  The operations of adding (subtracting) a number to a pointer (from a pointer) affect only the offset, and therefore the pointer can never leave the memory area.  Subtracting pointers is only possible if they belong to the same memory area (in accordance with <a href="">C ++</a> ). </p><br><p>  (As we can see, the C ++ standard applies these rules to arrays, not memory areas. However, LLVM applies them at <a href="https://llvm.org/docs/LangRef.html">the area level</a> .) </p><br><p>  It turns out (and miri shows the same thing) that this model can serve us well.  We always remember which region of memory the pointer belongs to, so we can distinguish the one-after-one pointer of one memory region from the pointer to the beginning of another region.  Thus miri may find that our second example (with &amp; x [8]) has UB. </p><br><h1 id="nasha-model-razvalivaetsya-na-kuski">  Our model is falling apart </h1><br><p>  In our model, pointers, although they are not numbers, are at least simple.  However, this model will begin to fall apart before our eyes, as soon as you remember the conversion of pointers to numbers.  In miri, casting a pointer to a number actually does nothing, we just get a numerical variable (i.e., its <em>type</em> says it is a number) whose <em>value</em> is a pointer (i.e., a pair of memory area and offset).  However, multiplying this number by 2 leads to an error, since it is completely unclear what it means to "multiply such an abstract pointer by 2". </p><br><p>  I must clarify: this is <em>not a</em> good solution when it comes to defining the semantics of a language.  However, this works well for the interpreter.  This is the simplest approach, and we chose it because it is not clear how it can be done otherwise (except to not support such casts at all - but with their support miri can run more programs): in our abstract machine there is no single "address space", in which all allocated memory areas would be located, and all pointers were mapped to specific different numbers.  Each memory area is identified by a (hidden) ID.  Now we can begin to add additional data to our model, such as a base address for each memory area, and somehow use it to bring the number back to the pointer ... and at this point the process becomes really very complicated, and, in any case, a discussion of this Models are not the purpose of writing a post.  Its purpose is to discuss the need for such a model.  If you are interested, I recommend that you read <a href="http://www.cis.upenn.edu/~stevez/papers/KHM%2B15.pdf">this document</a> , which takes a closer look at the above idea of ‚Äã‚Äãadding a base address. </p><br><p>  In short, the casts of pointers and numbers to each other are confusing and difficult to define formally, given the optimizations discussed above.  There is a conflict between the high-level approach needed for optimizations and the low-level approach needed to describe casting pointers to numbers and vice versa.  For the most part, we simply ignore this problem in miri and, whenever possible, try to do as much as possible using the simple model that we work with.  A complete definition of languages ‚Äã‚Äãsuch as C ++ or Rust, of course, cannot go along such a simple path, it should explain what is really happening.  As far as I know, there is no suitable solution, but academic research is <a href="http://sf.snu.ac.kr/publications/llvmtwin.pdf">approaching the truth</a> . </p><br><p>  That is why pointers are also not simple. </p><br><h1 id="ot-ukazateley-k-baytam">  From pointers to bytes </h1><br><p>  I hope I have made a reasonably convincing argument that numbers are not the only data type to consider if we want to formally describe low-level languages ‚Äã‚Äãlike C ++ or the (insecure) part of Rust.  However, this means that a simple operation like reading a byte from memory cannot just return u8.  Imagine that we <a href="">implement memcpy</a> by reading each byte of the source in turn into some local variable v, and then store this value in the target location.  But what if this byte is part of a pointer?  If the pointer is a pair of memory area ID and offset, then what will be its first byte?  We need to say what the value of v is equal to, so we will have to somehow answer this question.  (And this is a completely different problem than the problem with multiplication, which was in the previous section. We just assume that there is some abstract type of Ponter.) </p><br><p>  We cannot represent the byte of the pointer as a value of the range 0..256 (note: hereinafter 0 is turned on, 256 is not).  In general, if we use a naive memory representation model, the extra ‚Äúhidden‚Äù part of the pointer (the one that makes it more than just a number) will be lost when the pointer is written to memory and re-read from it.  We will have to fix this, and for this we will have to expand our concept of ‚Äúbyte‚Äù to represent this additional state.  Thus, the byte is now <em>either the</em> value of the range 0..256 ("raw bits"), <em>or</em> the nth byte of some abstract pointer.  If we had to implement our memory model in Rust, it could look like this: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByteV1</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), }</code> </pre> <br><p>  For example, PtrFragment (ptr, 0) represents the first byte of the ptr pointer.  Thus, memcpy can "break" the pointer into separate bytes that represent this pointer in memory, and copy them individually.  On a 32-bit architecture, the full ptr representation will contain 4 bytes: </p><br><pre> <code class="rust hljs">[PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">0</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">1</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">2</span></span>), PtrFragment(ptr, <span class="hljs-number"><span class="hljs-number">3</span></span>)]</code> </pre> <br><p>  This representation supports all operations of moving data over pointers at the byte level, which is quite enough for memcry.  Arithmetic or bit operations are not fully supported;  as noted above, this would require a more complex representation of pointers. </p><br><h1 id="neinicializirovannaya-pamyat">  Uninitialized memory </h1><br><p>  However, we have not finished with our definition of "byte".  To fully describe the behavior of the program, we need to consider another option: a byte in memory can be <em>uninitialized</em> .  The last byte definition will look like this (suppose we have a Pointer type for pointers): </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Byte</span></span></span></span> { Bits(<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), PtrFragment(Pointer, <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>), Uninit, }</code> </pre> <br><p>  We use the Uninit value for all bytes in the allocated memory into which we have not written any value yet.  It is possible to read uninitialized memory without problems, but any other <em>actions</em> with these bytes (for example, numeric arithmetic) leads to UB. </p><br><p>  This is very similar to LLVM rules for the special poison value.  Note that LLVM <em>also</em> has a undef value, which is used for uninitialized memory and works a bit differently.  However, compiling our Uninit to undef is correct (undef is in some ways "weaker"), and there are suggestions <a href="http://www.cs.utah.edu/~regehr/papers/undef-pldi17.pdf">to remove undef from LLVM and use poison instead</a> . </p><br><p>  You may wonder why we have a special Uninit value at all.  Why not choose some arbitrary b: u8 for each new byte, and then use Bits (b) as the initial value?  This is really one option.  However, first of all, all compilers came to the approach using a special value for uninitialized memory.  Not following this approach means not only causing compilation problems through LLVM, but also reviewing all optimizations and making sure that they work correctly with this modified model.  The key point here: you can always safely replace Uninit with any other value: any operation receiving this value will in any case lead to UB. </p><br><p>  For example, this C code is easier to optimize with Uninit: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (condA()) x = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     ,       ,  condA() //  ,      x. use(x); //  x = 1. }</span></span></code> </pre> <br><p>  With Uninit, we can easily say that x has either a Uninit value or a value of 1, and since replacing Uninit with 1 works, the optimization is easily explained.  Without Uninit, x is either "some kind of arbitrary bit pattern" or 1, and the same optimization is harder to explain. </p><br><p>  (We can argue that we can swap operations when we make a non-deterministic choice, but then we need to prove that the code that is difficult to analyze does not use x in any way. Uninit avoids this trouble with unnecessary evidence.) </p><br><p>  Finally, Uninit is the best choice for interpreters like miri.  Such interpreters have problems with operations such as ‚Äújust select any of these values‚Äù (that is, non-deterministic operations), since they tend to go through all possible paths of program execution, which means that they need to try all possible values.  Using Uninit instead of an arbitrary bit pattern means that miri can tell you after one program run whether your program uses uninitialized values ‚Äã‚Äãincorrectly. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  We saw that in languages ‚Äã‚Äãlike C ++ and Rust (unlike real computers) pointers can be different even if they point to the same address, and that a byte is more than just a number in the range 0..256.  Therefore, if in 1978 the C language could be "portable assembler", now it is an incredibly erroneous statement. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460953/">https://habr.com/ru/post/460953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460941/index.html">Business Email Compromise: No Defense Against Attack</a></li>
<li><a href="../460943/index.html">How to choose promising keys for SEO based on scenario forecasting in Google Data Studio (+ template)</a></li>
<li><a href="../460945/index.html">Experience in using a telegram channel to increase recognition and revenue growth of a gaming studio</a></li>
<li><a href="../460947/index.html">WASM Meet Up 1/08</a></li>
<li><a href="../460951/index.html">Create Android Live Wallpapers</a></li>
<li><a href="../460955/index.html">Educational program for passing parameters by value to constructors and setters (modern C ++, examples)</a></li>
<li><a href="../460959/index.html">Microsoft's new technology allows 3D copies of a real person to speak any language</a></li>
<li><a href="../46096/index.html">Play Pong ... with your browser windows!</a></li>
<li><a href="../460961/index.html">Setting up Unit tests in mixed Swift + Objective-C projects</a></li>
<li><a href="../460965/index.html">Split Controller without these your storyboards</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>