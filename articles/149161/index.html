<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Approximation of images by a genetic algorithm using EvoJ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will tell how you can apply a genetic algorithm to approximate images by polygons. As in my previous articles, for this purpose I wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Approximation of images by a genetic algorithm using EvoJ</h1><div class="post__text post__text-html js-mediator-article">  In this article I will tell how you can apply a genetic algorithm to approximate images by polygons.  As in my previous articles, for this purpose I will use my own <a href="http://evoj-frmw.appspot.com/">EvoJ</a> framework, which I have already written about <a href="http://habrahabr.ru/blogs/algorithm/138276/">here</a> and <a href="http://habrahabr.ru/post/139646/">here</a> . <br><br><img src="https://habrastorage.org/storage2/195/840/56b/19584056b5f24582e5841c3cc3bae042.png"><br><a name="habracut"></a><br><br><h4>  Choosing a method for describing the solution </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Following the traditional way of solving problems with the help of EvoJ, first we will choose how we describe the solutions for our problem.  A straightforward solution would be to describe the approximation as a simple list of polygons: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PolyImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Polygon&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCells</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><br>  This approach has the right to life, we will be able to pick up a satisfactory picture sooner or later.  C is most likely late, since such an approach reduces the effectiveness of crossing good solutions.  And that's why. <br><br>  Imagine for simplicity the following picture. <br><img src="https://habrastorage.org/storage2/003/64b/b83/00364bb834850d127b618d6cbe54c2fb.png"><br>  Suppose we have two good solutions in the gene pool, each of which differs from the ideal one by one polygon. <br><img src="https://habrastorage.org/storage2/eec/ebc/568/eecebc568b341dc9531917c6f7378f82.png"><br><img src="https://habrastorage.org/storage2/b1e/c80/7fd/b1ec807fdf2a3b971ffd77657498e61d.png"><br>  Pay attention to one feature: in both cases polygon number 0 ideally coincides with one of the image polygons, while the other lies somewhere to the side.  It would be great to cross these two solutions so that, as a result, the first two polygons of both solutions turned out together, but this is not possible - EvoJ maps all variables to a byte array and, when crossed, works with bytes without changing their order. <br><br><img src="https://habrastorage.org/storage2/ab0/d0a/a0e/ab0d0aa0ee3d1d0900444590d83241d9.png"><br><br>  The process of crossing over is explained in the following figure. <br><br><img src="https://habrastorage.org/storage2/19d/93f/ac9/19d93fac9590908613ae2bd70cf15820.png"><br><br>  Thus, two elements with the same index can never be in the resulting solution. <br>  The result of crossing most likely will look like this: <br><br><img src="https://habrastorage.org/storage2/fa9/64b/d41/fa964bd41460937c25d959bbaaa791bf.png"><br><br>  That will greatly affect the effectiveness of crossing, significantly slowing down the evolution. <br><br>  It is possible to get around the problem by sowing the original population ‚Äúcorrectly‚Äù by evenly distributing polygons over the image area, so that the location of the polygon in the list is consistent with its geometric location in the figure.  At the same time, it is necessary to limit the mutation so that the polygons cannot ‚Äúcrawl‚Äù too far. <br><br>  A more advanced approach is to initially divide the image into cells, with each cell assigning its own list of polygons.  In the form of a Java interface, this is described as: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PolyImage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Colour </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBkColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; List&lt;List&lt;List&lt;Polygon&gt;&gt;&gt; getCells(); }</code> </pre><br><br>  The external list specifies rows of cells, the next nesting is columns, and finally, the internal list is polygons located in the corresponding cell.  This approach automatically provides an approximate correspondence of the polygon position in a byte array and its geometrical location in the figure. <br><br>  Each polygon will be described as: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Polygon</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">List&lt;Point&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPoints</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Colour </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><br>  Here the order property determines the global polygon rendering order.  The color of the polygon is described as: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Colour</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@MutationRange</span></span>(<span class="hljs-string"><span class="hljs-string">"0.2"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Range</span></span>(min = <span class="hljs-string"><span class="hljs-string">"0"</span></span>, max = <span class="hljs-string"><span class="hljs-string">"1"</span></span>, strict = <span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@MutationRange</span></span>(<span class="hljs-string"><span class="hljs-string">"0.2"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Range</span></span>(min = <span class="hljs-string"><span class="hljs-string">"0"</span></span>, max = <span class="hljs-string"><span class="hljs-string">"1"</span></span>, strict = <span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@MutationRange</span></span>(<span class="hljs-string"><span class="hljs-string">"0.2"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@Range</span></span>(min = <span class="hljs-string"><span class="hljs-string">"0"</span></span>, max = <span class="hljs-string"><span class="hljs-string">"1"</span></span>, strict = <span class="hljs-string"><span class="hljs-string">"true"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBlue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> red)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> green)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setBlue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> blue)</span></span></span></span>; }</code> </pre><br><br>  In other words, just as three components of color, those who wish can still add an alpha channel, however we will draw all polygons with 50% transparency, this will reduce the number of mutations that are indifferent.  Assigning annotations here, I hope, obviously.  If not, take a look at my previous articles, this question is dealt with there. <br><br>  Polygon points will be described as: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><br>  In this case, the coordinates X and Y will be considered relative to the center of the cell to which the polygon belongs.  Please note that annotations regulating the permissible values ‚Äã‚Äãof variables are present only in the color description.  This is due to the fact that the permissible values ‚Äã‚Äãof the coordinates depend on the size of the image and on the configuration of the cells, and the permissible values ‚Äã‚Äãof the color components are predefined things.  In addition, the annotation on two internal lists in the <code>PolyImage</code> interface cannot be hanged at all. <br><br>  To set all the necessary parameters, we will use a mechanism called Detached Annotations. <br><br>  So let's move on to programming.  The sources used in this example can be found <a href="">here</a> .  Much of the above code repeats what was written in my previous articles; a lot of things have nothing to do with the genetic algorithm as such.  Therefore, I will focus on the key points, and the remaining parts are commented in the code. <br><br><h4>  Configuring EvoJ with Detached Annotations <br></h4><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HashMap&lt;String, String&gt; context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, String&gt;(); context.put(<span class="hljs-string"><span class="hljs-string">"cells@Length"</span></span>, ROWS.toString()); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item@Length"</span></span>, COLUMNS.toString()); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item@Length"</span></span>, POLYGONS_PER_CELL.toString()); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points@Length"</span></span>, <span class="hljs-string"><span class="hljs-string">"6"</span></span>); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.x@StrictRange"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.x@Min"</span></span>, String.valueOf(-widthRadius)); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.x@Max"</span></span>, String.valueOf(widthRadius)); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.x@MutationRange"</span></span>, <span class="hljs-string"><span class="hljs-string">"20"</span></span>); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.y@StrictRange"</span></span>, <span class="hljs-string"><span class="hljs-string">"true"</span></span>); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.y@Min"</span></span>, String.valueOf(-heightRadius)); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.y@Max"</span></span>, String.valueOf(heightRadius)); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.points.item.y@MutationRange"</span></span>, <span class="hljs-string"><span class="hljs-string">"20"</span></span>); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.order@Min"</span></span>, <span class="hljs-string"><span class="hljs-string">"0"</span></span>); context.put(<span class="hljs-string"><span class="hljs-string">"cells.item.item.item.order@Max"</span></span>, <span class="hljs-string"><span class="hljs-string">"1000"</span></span>);</code> </pre><br><br>  Here we create a context - <code>Map</code> similar to the <code>properties</code> file, where the name of the property corresponds to the path to the property of the object in a notation similar to the one accepted in <code>BeanUtils</code> , except that the list items are indicated by the keyword <code>item</code> . <br>  Thus, the name of the <code>cells</code> describes the <code>cells</code> property of our root <code>PolyImage</code> interface.  And the line <code>cells.item</code> are the elements of this list, which in turn are the lists described by the line <code>cells.item.item</code> , and so on. <br>  After the property name and <code>@</code> sign, the name of the detached annotation is indicated, which is similar to the name of a regular annotation.  It is mandatory to specify the length of the list so that EvoJ knows how much space to reserve in the byte array. <br>  Annotation <code>cells.item.item.item.points@Length</code> sets the number of points in a polygon (follow the path ‚Äî the <code>cells</code> property, three nested lists, the <code>points</code> property of the elements of the nested list itself. <br>  The boundaries of the coordinates of points, the radius of their mutations, the limits of the values ‚Äã‚Äãof the order property are set in a similar way. <br><br>  Next, we use the completed context when creating the gene pool. <br><br><h4>  Creating a fitness function </h4><br><br>  As a fitness function, we choose the sum of the squares of the deviations of the selected image from the original, with a minus sign - since the best solution corresponds to the smallest amount.  The fitness function is implemented in the <code>ImageRating</code> class, <code>ImageRating</code> 's focus on its key points. <br><br>  As in the examples from previous articles, the class is inherited from the <code>AbstractSimpleRating</code> helper-class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImageRating</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractSimpleRating</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PolyImage</span></span></span><span class="hljs-class">&gt;</span></span></code> </pre><br><br>  and implements the abstract doCalcRating method as follows: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Comparable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doCalcRating</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PolyImage solution)</span></span></span><span class="hljs-function"> </span></span>{ BufferedImage tmp = drawImage(solution); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> compareImages(originalImage, tmp); }</code> </pre><br><br>  Here, the <code>drawImage</code> function trivially <code>drawImage</code> all polygons according to their cell, order, color, and so on.  We will not dwell on it in detail - it does not contain anything related to the genetic algorithm. <br><br>  The <code>compareImages</code> function performs pixel-by-pixel comparison of images.  Consider it a little closer. <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Comparable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compareImages</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BufferedImage originalImage, BufferedImage tmp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] originalPixels = originalImage.getRaster().getPixels(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, originalImage.getWidth(), originalImage.getHeight(), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]) <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] tmpPixels = tmp.getRaster().getPixels(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, tmp.getWidth(), tmp.getHeight(), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[]) <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; originalPixels.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d = originalPixels[i] - tmpPixels[i]; result -= d * d; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  As you can see, the function is rather trivial - it takes rasters of the original and freshly drawn images and compares them element by element, simultaneously adding (with a minus sign) the squares of differences. <br><br><h4>  Iteration </h4><br><br>  In order to quickly achieve the result, it is necessary to choose the optimal mutation parameters: <br><ul><li>  the likelihood that the decision will generally undergo a mutation </li><li>  probability of mutation of each variable inside the solution </li><li>  radius of change - the maximum distance that a point can move during a mutation </li><li>  solution lifetime (not entirely related to mutation, but also affects the rate of convergence) </li></ul><br><br>  The choice of strategy is not trivial.  On the one hand, a strong mutation allows you to quickly cover the solution space and ‚Äúgrope‚Äù the global extremum, but on the other hand, it does not allow it to slide into it - solutions will constantly skip it.  The long life of the solution insures against the deterioration of the fitness function value, but it slows down the overall progress and contributes to rolling into a local extremum instead of a global one.  You also need to decide what to mutate with greater probability - the points of the polygons or their colors. <br>  In addition, the chosen strategy exhausts itself after a while - the solutions found begin to oscillate around the extremum found, instead of slipping into it.  To cope with this problem, strategies need to be changed.  At the same time, the general idea is that the mutation level decreases with time, and the lifetime of successful solutions grows.  The mutation strategies used in the example are chosen empirically. <br><br>  Given all the above written, the main program cycle is as follows: <br><ol><li>  perform 10 iterations of the genetic algorithm </li><li>  take the value of the fitness function from the best solution </li><li>  determine whether it is time to change the strategy </li><li>  change strategy if necessary </li><li>  save picture to temporary file </li><li>  update ui </li></ol><br><br>  By running the program, after 15 minutes (depending on the power of your machine), you will find that the selected image already remotely resembles the original, and in an hour or two you will achieve a result close to that given at the beginning of the article. <br><br><h4>  Further improvement of the algorithm </h4><br><br>  Progress can be significantly accelerated by applying the following optimizations: <br><ul><li>  approximation is performed in Lab space instead of RGB; it is characterized by the fact that the Cartesian distance between points in the color space is approximately consistent with the perceived difference.  The number of iterations per second does not add it, but it will direct the evolution in the right direction. </li><li>  create a mask of the importance of image areas - a black and white image with selected areas of interest, which can then be used when calculating the fitness function; this will allow the evolution to focus on what is really interesting. </li><li>  for images use VolatileImage.  On my machine, drawing on VolatileImage is 10 times faster than drawing on BufferedImage.  True, then the result has to be converted to BufferedImage anyway in order to get the colors of the pixels, this leads to a significant drop in performance, but still the final result is 3 times better than just drawing polygons on BufferedImage. </li><li>  select the optimal mutation parameters at different stages.  The task is not simple, but even here a genetic algorithm can help.  I conducted experiments where the variables were mutation parameters, and the fitness function was the average rate of error reduction per 100 iterations.  The results are encouraging, but to solve this problem requires significant computational power.  Probably I in one of the following articles I will sort this problem closer. </li><li>  start several independent gene pools and make an evolution in them independently, at certain intervals, cross each other individuals from different gene pools.  Such an approach is called the island model of the GA, i.e., evolution seems to take place on islands isolated from each other, crosses between individuals from different islands are extremely rare. </li><li>  sow the image with polygons gradually: first place 1-2 polygons in each cell, allow them to ‚Äúspread out‚Äù, then add another 1-2 polygons to the places where the image deviates from the original the greatest and only evolve newly added polygons, repeat this until the limit of the number of polygons in the cell is reached, and then start the evolution across the entire image, as described in the article above.  This approach leads to the most accurate close approximations. </li></ul><br><br><h4>  Afterword </h4><br><br>  So, we looked at an example of how you can apply EvoJ to solve the problem of approximating an image.  It is worth noting that the approximation of images by a genetic algorithm is more of an academic or aesthetic interest than a practical one, because a similar result can be achieved by other specially sharpened image vectoring algorithms. <br><br>  Next time I will talk about the use of a genetic algorithm for generating design ideas. <br><br>  <b>UPD1: Since the link to the sources given in the text of the article is not striking, I duplicate it here <a href="">http://evoj.sourceforge.net/static/demos/img-demo.rar</a></b> <b><br></b> <br><br>  <b>UPD2: At the request of workers, I cite slides from my first article</b> <br><table><tbody><tr><th>  Source image </th><th>  Matched image </th></tr><tr><td><img src="http://evoj.sourceforge.net/static/showcase/big_ben.png" alt="image"></td><td><img src="http://evoj.sourceforge.net/static/showcase/big_ben_evoj.png" alt="image"></td></tr><tr><td><img src="http://evoj.sourceforge.net/static/showcase/moscow.png" alt="image"></td><td><img src="http://evoj.sourceforge.net/static/showcase/moscow_evoj.png" alt="image"></td></tr></tbody></table></div><p>Source: <a href="https://habr.com/ru/post/149161/">https://habr.com/ru/post/149161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149156/index.html">Apache Deltacloud 1.0 release</a></li>
<li><a href="../149157/index.html">Where do you get the latest news?</a></li>
<li><a href="../149158/index.html">It may have become known the cost of a license for Windows 8</a></li>
<li><a href="../149159/index.html">Experiment "Vigorous Morning": morning test drive of gadgets, receptions and occult techniques</a></li>
<li><a href="../149160/index.html">New turn in the browser war</a></li>
<li><a href="../149162/index.html">Data transmission using neutrinos</a></li>
<li><a href="../149166/index.html">Google has created an interactive scheme for the global arms trade.</a></li>
<li><a href="../149168/index.html">What's inside the Curiosity Mars Rover</a></li>
<li><a href="../149170/index.html">YouTube app removed from iOS 6</a></li>
<li><a href="../149171/index.html">LiveStreet Release 1.0.1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>