<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Aggregation and awareness</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The object aggregation mechanism is one of the great features of my jWidget JavaScript framework, which is not found in most other frameworks. I want ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Aggregation and awareness</h1><div class="post__text post__text-html js-mediator-article">  The object aggregation mechanism is one of the great features of my <a href="http://enepomnyaschih.github.io/jwidget/index.html">jWidget</a> JavaScript framework, which is not found in most other frameworks.  I want to tell you more about it, because it helps to easily solve a wide range of typical tasks faced by the developers of web-application clients on the Model-View architecture.  There will be few pictures, but a lot of interesting code. <br><br>  I briefly described the mechanism of aggregation of objects in section <b>1. Classes and objects of the</b> <a href="http://habrahabr.ru/post/219995/">previous article</a> .  The article was published a year and a half ago.  Since then, there have been 4 major updates to the framework, but the philosophy has been preserved.  With experience, several stunning patterns of code structuring based on an aggregation mechanism were created, which significantly reduced the amount of code and made it easier.  For a start, let me remind you what it is. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  What is the mechanism of aggregation of objects </h1><br><br>  This is an approach to controlling the process of destruction of objects.  Quote from the last article: <br><br><blockquote>  I drew this idea from the introduction to the book <a href="http://ru.wikipedia.org/wiki/Design_Patterns">Object-Oriented Design.</a>  <a href="http://ru.wikipedia.org/wiki/Design_Patterns">Design patterns</a> from the "gang of four."  It says that all pointers to objects are divided into two types: aggregation and awareness.  Awareness means that the object that owns the pointer does not bear any responsibility for the object to which it refers.  He simply has access to his public fields and methods, but the lifetime of this object is not under his control.  Aggregation means that the object owning the link is responsible for the destruction of the object to which it refers.  As a rule, an aggregated object lives while the owner object is alive, although there are more complex cases. <br><br>  In jWidget, the aggregation is implemented through the <a href="http://enepomnyaschih.github.io/jwidget/index.html">own</a> method of the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Class</a> class.  By passing object B to object A's own method, you made object A to own object B. When object A is destroyed, object B will be destroyed automatically.  For convenience, the own method returns object B. <br></blockquote><br><br>  To get the most out of the aggregation mechanism, the framework / language should provide its implementation at the kernel level itself.  So, in C ++, the aggregation mechanism is sewn up at the syntax level of the language, and in jWidget it is sewn up at the level of the most basic class <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Class</a> , from which all other classes inherit.  Any object should be able to aggregate, and any object can be aggregated. <br><br><h1>  Example </h1><br><br>  Last time, the Chabrasoobshchestvo did not really like my example of the destruction of a soldier and his hands ‚Äî they all immediately presented bloody scenes from American militants, so this time I‚Äôll give a slightly less spectacular but no less telling example with a book and a cover. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Book = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ Book._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cover = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Cover()); }; JW.extend(Book, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">destroyObject</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Destroying book"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super(); } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cover = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ Cover._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; JW.extend(Cover, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">destroyObject</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Destroying cover"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super(); } });</code> </pre> <br><br>  A cover is created in the book designer.  The cover is aggregated in the book, so when you destroy a book, the cover is also automatically destroyed. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> book = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Book(); book.destroy(); <span class="hljs-comment"><span class="hljs-comment">//   : // Destroying cover // Destroying book</span></span></code> </pre><br><br><h1>  Real example </h1><br><br>  I will give an example from practice, more close to reality.  Everyone loves to subscribe to jQuery events, but no one likes to unsubscribe from them.  But in some cases it is necessary to unsubscribe, otherwise everything will explode. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyView = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ MyView._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); $(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).resize(JW.inScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._layout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }; JW.extend(MyView, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">_layout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Will it really blow up?</b> <div class="spoiler_text">  Once we were developing an add-on to SketchUp, and we had a freelance documentator on the team.  Once he documented the ‚ÄúKnown Bugs‚Äù section in one of the releases, and read in the task that when grouping objects of a special kind, they may be incorrectly exported to a file.  He asked me a question: ‚ÄúWell, what happens after all if you try to export such objects to a file?‚Äù I jokingly replied: ‚ÄúWell, I don‚Äôt know, it‚Äôs probably going to explode.‚Äù Well, he wrote that.  Since then, the official documentation says ‚ÄúIf you do that, then everything will explode.‚Äù </div></div><br><br>  In this code, obviously, there is not enough formal reply from the ‚Äúresize‚Äù event when the MyView object is destroyed.  When destroying the MyView object, we must be sure that it will not leave behind any traces. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> view = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyView(); view.destroy();</code> </pre><br><br>  But since we did not unsubscribe from the ‚Äúresize‚Äù event, according to it the ‚Äú_layout‚Äù method of the dead object will be called, which may cause unexpected side effects.  Fix the mistake: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyView = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ MyView._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); $(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).bind(<span class="hljs-string"><span class="hljs-string">"resize"</span></span>, JW.inScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._layout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }; JW.extend(MyView, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">_layout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }, destroyObject: function() { $(window).unbind("resize", JW.inScope(this._layout, this)); this._super(); } });</span></span></code> </pre><br><br>  I intentionally made another typical mistake: the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.inScope</a> method creates a new function instance each time, so the ‚Äúunbind‚Äù method does nothing.  Fix this as well: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyView = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._layout = JW.inScope(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._layout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); MyView._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); $(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).bind(<span class="hljs-string"><span class="hljs-string">"resize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._layout); }; JW.extend(MyView, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">_layout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }, destroyObject: function() { $(window).unbind("resize", this._layout); this._super(); } });</span></span></code> </pre><br><br>  Tired of ... A bunch of code for such a trifle?  End this with aggregation! <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyView = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ MyView._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own($(<span class="hljs-built_in"><span class="hljs-built_in">window</span></span>).jwon(<span class="hljs-string"><span class="hljs-string">"resize"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._layout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }; JW.extend(MyView, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">_layout</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } });</span></span></code> </pre><br><br>  The <a href="http://enepomnyaschih.github.io/jwidget/index.html">jwon</a> method returns a subscription to an event, the destruction of which, obviously, leads to a reply from the event. <br><br><h1>  Aggregation properties and collections </h1><br><br>  An important part of the aggregation mechanism of objects is the aggregation properties and collections.  Calling the <a href="http://enepomnyaschih.github.io/jwidget/index.html">property's ownValue</a> method causes it to aggregate any value that is assigned to it.  So, if you change the property value or destroy the property itself, the current value will be destroyed. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> property = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property().ownValue(); property.set(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); property.set(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleValue(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// SampleValue(1)   property.destroy(); // SampleValue(2)  </span></span></code> </pre><br><br>  Similarly, calling the <a href="http://enepomnyaschih.github.io/jwidget/index.html">ownItems</a> method of a collection causes it to aggregate any element that is added to it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> array = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Array().ownItems(); array.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleValue(<span class="hljs-number"><span class="hljs-number">1</span></span>)); array.add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleValue(<span class="hljs-number"><span class="hljs-number">2</span></span>)); array.set(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleValue(<span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// SampleValue(1)   array.remove(1); // SampleValue(2)   array.destroy(); // SampleValue(3)  </span></span></code> </pre><br><br>  In the following examples, we will actively use these opportunities. <br><br>  Now about the patterns. <br><br><h1>  Pattern 1: Easy object update </h1><br><br>  <i><b>If the subobject that you want to be aggregated in the object re-creates over time, place it in an aggregating property.</b></i> <br><br>  Imagine that you are listening to a certain event, and whenever it occurs, in some way replace the contents of the object.  When you create a new content you need to destroy the old. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyView = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ MyView._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initContent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(event.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.refreshContent, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }; JW.extend(MyView, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">destroyObject</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doneContent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super(); }, <span class="hljs-attr"><span class="hljs-attr">initContent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Content(); }, <span class="hljs-attr"><span class="hljs-attr">doneContent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content.destroy(); }, <span class="hljs-attr"><span class="hljs-attr">refreshContent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doneContent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.initContent(); } });</code> </pre><br><br>  If you use the aggregating property of the simple object update pattern, this code can be reduced by 2 times: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyView = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ MyView._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property()).ownValue(); <span class="hljs-comment"><span class="hljs-comment">//   this.refreshContent(); this.own(event.bind(this.refreshContent, this)); }; JW.extend(MyView, JW.Class, { refreshContent: function() { this.content.set(new Content()); } });</span></span></code> </pre><br><br>  If you really need to create new content only after destroying the old one, first set the property to null: <br><br><pre> <code class="javascript hljs"> refreshContent: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content.set(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.content.set(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Content()); }</code> </pre><br><br><h1>  Pattern 2: Easy cancel operation </h1><br><br>  <i><b>If at the moment of the destruction or change of the state of an object a certain operation can be performed, but you do not know for sure, then you should use the aggregating property to cancel it.</b></i> <br><br>  Often, especially when using a router based on the location.hash or History API, it becomes necessary to cancel the loading of the left page if the user quickly switches between pages.  As a rule, loading is a sequential execution of AJAX requests, animations and other asynchronous operations.  In addition, the page itself from time to time initiates a reload of its data.  If the user navigates to another page while performing one of these operations, it must be canceled. <br><br>  To solve this problem, we will get the ‚ÄúcurrentOperation‚Äù aggregation property and we will put the current asynchronous operation there. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyPage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ MyPage._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.currentOperation = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property()).ownValue(); <span class="hljs-comment"><span class="hljs-comment">//   this.dataHunkIndex = 0; }; JW.extend(MyPage, JW.UI.Component, { afterRender: function() { this._super(); this._loadData(); }, _loadData: function() { this.currentOperation.set(new Request("/api/data", {hunk: this.dataHunkIndex}, this._onDataLoad, this)); }, _onDataLoad: function(result) { this.currentOperation.set(new Animation("fade in", this._onAnimationFinish, this)); }, _onAnimationFinish: function() { this.currentOperation.set(null); }, renderLoadNextHunkButton: function(el) { el.jwon("click", this._loadNextHunk, this); }, _loadNextHunk: function() { ++this.dataHunkIndex; this._loadData(); } });</span></span></code> </pre><br><br>  Now we don‚Äôt need to worry about the integrity of the application state: when switching between pages and clicking on the ‚ÄúLoad next hunk‚Äù button, the current operation will be canceled and the loading of new data will start from scratch. <br><br>  Naturally, for each such operation, you must create a class, the destruction of which cancels the operation.  An example implementation of the Request class for an AJAX request: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Request = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, data, success, scope</span></span></span><span class="hljs-function">) </span></span>{ Request._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.aborted = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.success = success; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.scope = scope; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ajax = $.ajax({ <span class="hljs-attr"><span class="hljs-attr">url</span></span> : url, <span class="hljs-attr"><span class="hljs-attr">data</span></span> : data, <span class="hljs-attr"><span class="hljs-attr">success</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onSuccess, <span class="hljs-attr"><span class="hljs-attr">error</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._onError, <span class="hljs-attr"><span class="hljs-attr">context</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }); }; JW.extend(Request, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">destroyObject</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    "abort" jQuery   , //     .     this.aborted = true; //    ,   "abort"  . //   -   this.ajax.abort(); this._super(); }, _onSuccess: function(result) { this.success.call(this.scope, result); }, _onError: function() { if (!this.aborted) { alert("Request has failed =(("); } } });</span></span></code> </pre><br><br><h1>  Pattern 3: Mass destruction of objects </h1><br><br>  <i><b>If an object with a call to a certain function provokes the creation of a set of objects, then a single object should be returned to the functions that aggregates all these objects into itself.</b></i> <br><br>  Suppose that when an object is updated, a lot of objects are created that must be destroyed during the next update.  Can I use an aggregation mechanism to reduce the amount of code in this case?  Of course, using the simple object update pattern several times, we can create several properties, one for each sub-object.  But what if you do not know in advance how many objects you need to create?  This is a very common situation if objects are created by some kind of third-party factory.  Consider the following code as an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Client = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, factory</span></span></span><span class="hljs-function">) </span></span>{ Client._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.factory = factory; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Array this.initObjects(); this.own(event.bind(this.refreshObjects, this)); }; JW.extend(Client, JW.Class, { destroyObject: function() { this.doneObjects(); this._super(); }, initObjects: function() { this.objects = this.factory.createObjects(); }, doneObjects: function() { for (var i = this.objects.length - 1; i &gt;= 0; --i) { this.objects[i].destroy(); } this.objects = null; }, refreshObjects: function() { this.doneObjects(); this.initObjects(); } }); var Factory = { createObjects: function() { return [ new Object1(), new Object2(), new Object3() ]; } };</span></span></code> </pre><br><br>  A lot of incomprehensible code: refactoring suggests itself.  Let the factory return the usual JW.Class, which aggregates within itself all 3 objects. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Client = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, factory</span></span></span><span class="hljs-function">) </span></span>{ Client._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.factory = factory; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property()).ownValue(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.refreshObjects(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(event.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.refreshObjects, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); }; JW.extend(Client, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">refreshObjects</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.objects.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.factory.createObjects()); } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Factory = { <span class="hljs-attr"><span class="hljs-attr">createObjects</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   var objects = new JW.Class(); objects.own(new Object1()); objects.own(new Object2()); objects.own(new Object3()); return objects; } };</span></span></code> </pre><br><br><h1>  Pattern 4: Destroying the object driver </h1><br><br>  <i><b>If the function returns an object that has its own driver, aggregate that driver in the object itself.</b></i> <br><br>  Suppose you want to write a method that creates a property, subscribes to some events to update this property, and returns this property.  A subscription to these events is called the <b>driver of</b> this property.  The driver of the object A will be called any object that affects the change of the object A. <br><br>  I will give an example of the driver.  Let somewhere on the page there is a control for dynamic switching between color schemes of the application.  The color scheme is defined by the dictionary "key - color".  Each color scheme is unchanged, but you can switch between them.  Subscribing to the change event of the selected color scheme is a property driver containing a color with a given key.  The key that we need, we know in advance;  the color depends on the chosen color scheme.  In addition, when changing the selected color scheme, the property with color should be automatically updated.  Let's write a class for such a driver. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ColorDriver = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">selectedScheme, colorKey, color</span></span></span><span class="hljs-function">) </span></span>{ ColorDriver._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedScheme = selectedScheme; <span class="hljs-comment"><span class="hljs-comment">// JW.Property&lt;Dictionary&gt; this.colorKey = colorKey; //   color  this.color = color || this.own(new JW.Property()); this._update(); this.own(this.selectedScheme.changeEvent.bind(this._update, this)); }; JW.extend(ColorDriver, JW.Class, { _update: function() { this.color.set(this.selectedScheme.get()[this.colorKey]); } });</span></span></code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  In jWidget, the same can be done without creating a class, if you use the selectedScheme method.  <a href="http://enepomnyaschih.github.io/jwidget/index.html">$$ mapValue</a> .  But at a low level, this method still uses the driver kill pattern, using <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Mapper</a> as the driver.  Therefore, in order to demonstrate the pattern, it is quite reasonable to abandon the use of this method. </div></div><br><br>  To make it easier, we will write a color management class that can create such properties and drivers. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ColorSchemeManager = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ColorSchemeManager._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedScheme = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property()); }; JW.extend(ColorSchemeManager, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">getColorDriver</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColorDriver(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedScheme, key); } });</code> </pre><br><br>  When a color is no longer needed, its driver must be destroyed.  It is impossible to aggregate the driver in the manager, since it is not the manager that provokes the creation of the driver.  For the destruction of the driver should be responsible object that provokes its creation, i.e.  customer. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Client = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">colorSchemeManager</span></span></span><span class="hljs-function">) </span></span>{ Client._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.colorSchemeManager = colorSchemeManager; }; JW.extend(Client, JW.UI.Component, { <span class="hljs-attr"><span class="hljs-attr">renderBackground</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> color = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.colorSchemeManager.getColorDriver(<span class="hljs-string"><span class="hljs-string">"background"</span></span>)).color; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(el.jwcss(<span class="hljs-string"><span class="hljs-string">"background-color"</span></span>, color)); } });</code> </pre><br><br>  This will work, but there are several disadvantages to this solution: <br><br><ol><li>  The driver is not at all interested in the client - the client only needs color </li><li>  Difficulties with polymorphism: if in some cases a driver is needed, and in others it is not needed, then to ensure polymorphism you will have to write a dummy driver who does nothing but keeps a reference to the color </li><li>  This code is hard to read. </li></ol><br><br>  To solve these problems, we use the driver kill pattern.  The pattern recommends that the object driver be aggregated in the object itself.  Since jWidget destroys the aggregated objects before the object itself, this does not produce any side effects. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ColorSchemeManager = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ColorSchemeManager._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedScheme = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property()); }; JW.extend(ColorSchemeManager, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">getColor</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   var color = new JW.Property(); color.own(new ColorDriver(this.selectedScheme, key, color)); return color; } }); var Client = function(colorSchemeManager) { Client._super.call(this): this.colorSchemeManager = colorSchemeManager; }; JW.extend(Client, JW.UI.Component, { renderBackground: function(el) { var color = this.own(this.colorSchemeManager.getColor("background")); this.own(el.jwcss("background-color", color)); } });</span></span></code> </pre><br><br>  Client code has become simpler and clearer. <br><br><h1>  Conclusion </h1><br><br>  With the object aggregation mechanism, you no longer need to explicitly implement and call object destructors.  The implementation of destructors remains only in low-level classes, such as an AJAX request, event subscription, etc.  The jWidget classes implement most of the necessary destructors, so all you have to do is correctly associate the objects with an aggregation relation. <br><br>  Replacing all the explicit calls of class destructors by an object aggregation mechanism on one of the projects, I managed to remove 1000 lines of code from 15,000 (7% win). </div><p>Source: <a href="https://habr.com/ru/post/270879/">https://habr.com/ru/post/270879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270865/index.html">Out of my head. GTD in development</a></li>
<li><a href="../270871/index.html">Office in your pocket. We configure cloud PBX on mobile phones</a></li>
<li><a href="../270873/index.html">SolutionCop</a></li>
<li><a href="../270875/index.html">Project Naptha - select, copy and translate texts from any pictures</a></li>
<li><a href="../270877/index.html">Samba and forbidden characters</a></li>
<li><a href="../270881/index.html">Translation: Ethics Code Review</a></li>
<li><a href="../270883/index.html">HighLoad ++ 2015 through the eyes of a foreign speaker</a></li>
<li><a href="../270885/index.html">Flytouch 2 / Superpad III and an attempt to save bytes in the Linux kernel</a></li>
<li><a href="../270887/index.html">We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: control LED brightness (PWM)</a></li>
<li><a href="../270889/index.html">The best reports of the DotNext 2015 Piter conference: Part 2 (Video inside)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>