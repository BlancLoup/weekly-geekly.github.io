<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Superscalar Stacking Processor: We Cross Horror And Hedgehog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will develop a (software) model of a superscalar processor with OOO and a stack machine front end . 

 In fact, continuation 1 & 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Superscalar Stacking Processor: We Cross Horror And Hedgehog</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/fdf/56e/c9b/fdf56ec9b85b43009aedaa7806d68e6d.jpg"><br>  In this article, we will develop a (software) model of a <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">superscalar</a> processor with <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">OOO</a> and a stack machine <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">front end</a> . <br><a name="habracut"></a><br>  In fact, continuation <a href="https://habrahabr.ru/post/271905/">1</a> &amp; <a href="https://habrahabr.ru/post/267771/">2</a> . <br><h3>  Introduction </h3><br>  Why <a href="https://en.wikipedia.org/wiki/Stack_machine">stack machine</a> ? <br>  <a href="https://users.ece.cmu.edu/~koopman/index.html">Philip Kupman</a> <a href="https://users.ece.cmu.edu/~koopman/stack_computers/sec1_3.html">writes</a> : ‚ÄúFrom a theoretical point of view, the stack is important in itself, since it is the main and most natural mechanism for executing well-structured code ... stack machines are much more efficient than register processors when working with code that has high modularity.  In addition, they are very simple and demonstrate excellent performance with rather modest iron requirements. ‚Äù <br><br>  The advantages of stack machines include compact code, easy compilation and interpretation of code, as well as compact state of the processor. <br><br>  Successful samples of computers with stack architecture can be called <a href="https://en.wikipedia.org/wiki/Burroughs_large_systems">Burroughs</a> <a href="http://www.cs.virginia.edu/brochure/images/manuals/b5000/descrip/descrip.html">B5000</a> (1961 ... 1986) and <a href="http://en.wikipedia.org/wiki/HP_3000">HP3000</a> (1974 ... 2006).  Do not forget about the Soviet <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D1%258C%25D0%25B1%25D1%2580%25D1%2583%25D1%2581_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580)">Elbrus</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So why are stack machines currently pushed out by register processors to the verge of progress?  The reasons, it seems, are as follows: <br><ol><li>  There are two "extreme" implementations of stack processors: with a fixed hardware stack and a stack located in memory.  Both of these extremes have significant flaws: in the case of a fixed-size stack, we have problems with the compiler and / or the operating system, which must think about what will happen if the stack overflows or becomes empty and how to work out the corresponding interrupt.  If there is no interrupt handling, we are dealing with a microcontroller that is doomed to be manually programmable.  With such an interrupt handler, the hardware stack plays the role of a ‚Äúwindow‚Äù to fast-access memory, while shifting this ‚Äúwindow‚Äù is a rather expensive procedure.  As a result, we have unpredictable program behavior that does not allow the use of such a processor, for example, in real-time systems, although, from the point of view of Koopman, this is just an ecological niche of such processors. </li><li>  In the case of a stack that is located entirely in memory, we pay memory access for almost every instruction executed.  Thus, the overall system performance is limited on top by the memory bandwidth. </li><li>  The complexity of the processor has long ceased to be a deterrent to development. </li><li>  The hardware implemented stack implies a strict sequence of events, and, consequently, the impossibility of using implicit program parallelism.  If superscalar processors themselves distribute instructions to pipelines according to available resources, and VLIW processors expect that this work has already been done for them by the compiler, then for stack machines, an attempt to find hidden parallelism in the code faces almost insurmountable difficulties.  In other words, we are again confronted with a situation where technology can provide more than the architecture can afford.  What is strange. </li><li>  Programming for register machines is more ‚Äútechnologically‚Äù.  With only a few general-purpose registers, "manually" you can easily create code that will access memory only when this cannot really be avoided.  Note that in the case of a stack machine, this is much more difficult to achieve.  And, although the optimal distribution of temporary variables in registers <a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">is an</a> NP-complete problem, there are several inexpensive, but effective heuristics that allow you to create quite a decent code in a reasonable time. </li></ol><br>  There were, of course, attempts to hide the register machine inside the stack wrapper, for example, <a href="http://en.wikipedia.org/wiki/Ignite_(microprocessor)">Ignite</a> or <a href="http://en.wikipedia.org/wiki/ICL_2900_Series">ICL2900</a> , but they did not have commercial success, because  in fact, only for the sake of compilation convenience, users had to incur fixed costs at runtime. <br><br>  So why does the author again raise this topic, which makes him think that there are prospects in this area, what problems he is trying to solve by what means? <br><br><h3>  Motives </h3><br>  Nobody argues with the fact that the code for stack machines is much more compact in comparison with register architectures.  You can dispute the significance of this compactness, but the fact remains.  How is code compression achieved?  After all, it is functionally doing the same thing, what is the focus? <br><br>  Consider a simple example, the calculation of the expression x + y * z + u. <br>  When building <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B0%25D0%25BA%25D1%2581%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">a parse tree with a</a> compiler, it looks like this: <br><img src="https://habrastorage.org/files/de8/c75/de0/de8c75de076d4541827039d359615148.png"><br>  The assembly code (x86) for this expression looks like this: <br><pre><code class="cpp hljs">mov eax,dword ptr [y] imul eax,dword ptr [z] mov ecx,dword ptr [x] add ecx,eax mov eax,ecx add eax,dword ptr [u]</code> </pre> <br>  For a hypothetical stack engine, pseudocode is: <br><pre> <code class="cpp hljs"> push x push y push z multiply add push u add</code> </pre><br>  The difference is clear and obvious, in addition to the 4 memory accesses, addition and multiplication, there are register identifiers in each instruction of the register processor. <br><br>  But after all, these registers in reality do not even exist, it is a fiction that the super-scalar processor uses to denote the connection between instructions. <br>  A set of registers and operations with them form the architecture of the processor and (at least for x86) historically formed at a time when super-scalar processors did not exist, and the names of registers meant quite physical registers. <br><br>  As you know, <a href="http://lukoshko.net/marshak/marsrd12.shtml">during the time the dog could grow up</a> and register identifiers are currently used for other purposes.  The architecture now is rather an interface between the compiler and the processor.  The compiler does not know how the processor actually works, and can produce code for a whole heap of compatible devices.  And processors can focus on useful and important things, creating externally compatible products. <br><br>  What is the fee for such a unification? <br><ol><li>  From the point of view of a super-scalar processor.  Here, for example, <a href="http://habrahabr.ru/company/intel/blog/147108">an article</a> from Intel, literally: <blockquote>  The superscalar parallelizes the sequential code.  But this parallelization process is too laborious even for the current processing power, and it is this that limits the performance of the machine.  It is impossible to make this conversion faster than a certain number of teams per clock.  More can be done, but at the same time clocks will drop - this approach is obviously meaningless. </blockquote>  Here is another favorite: <blockquote>  The trouble is not in the superscalar itself, but in the presentation of the programs.  Programs are presented sequentially, and they need to be converted into parallel execution at runtime.  The main problem of the superscalar is in the unsuitability of the input code to its needs.  There is a parallel algorithm of the kernel and parallel organized hardware.  However, between them, in the middle, there is a certain bureaucratic organization - a consistent system of commands </blockquote></li><li>  From the point of view of the compiler.  From the same place: <blockquote>  The compiler converts a program to a sequential instruction set;  the overall speed of the process will depend on the sequence in which it does it.  But the compiler does not know exactly how the machine works.  Therefore, generally speaking, the work of the compiler today is shamanism. </blockquote>  The compiler makes titanic efforts to cram a program into a specified number of registers, and this number is fictitious.  The compiler tries to push all the parallelism detected in the program (like a <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2583%25D1%2588%25D0%25BA%25D0%25BE">rope in the eye of a needle</a> ) through the limitations of the architecture.  To a large extent unsuccessfully. </li></ol><br><h3>  What to do? </h3><br>  The problem is indicated - inconsistency of the interface / architecture with modern requirements. <br>  What are these (new) requirements? <br><ol><li>  All concurrency known to the compiler must be transferred without loss. </li><li>  The cost of unpacking dependencies between instructions should be minimal. </li></ol><br>  Again, consider the example of compiling the expression x + y * z + u. <br><table><tbody><tr><th align="center">  x86 </th><th align="center">  stack machine </th></tr><tr><td><pre>  mov eax, dword ptr [y]
        imul eax, dword ptr [z] 
        mov ecx, dword ptr [x]
        add ecx, eax  
        mov eax, ecx
        add eax, dword ptr [u] </pre></td><td><pre>  push x
        push y
        push z
        multiply
        add
        push u                             
        add </pre></td></tr></tbody></table>  The x86 registers are intended to indicate the relationship between the various instructions.  And what about the stack machine, how are these dependencies implemented there?  Implicitly, through the position in the stack.  Each instruction knows the number of its arguments and expects to find them at the top of the stack before execution. <br><br>  But what if, when we talk about the top of the stack, this is <b>not</b> necessarily a <b>stack of data</b> , but rather a <b>stack of</b> <b>operations</b> ( <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">micro-operations</a> , mops). <br><ul><li>  The stack instructions come from outside, but the processor is actually a register one, it can only execute quite traditional 'add r1 r2 r3'.  These are the 'add ...' we call mopami.  If anything, mop is a universal preform for the internal instructions of a register processor. </li><li>  The processor has a pool of mops, initially they are all free, access is by index. </li><li>  The mop has related information, the links are the numbers of the parent mop, the number of ancestors, ... </li><li>  So, the first instruction is 'push x' (x in this case is the address), the <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">decoder</a> translates it into 'lload R ?, 0x .....', this mop has no input arguments, only output. </li><li>  The mop is taken from the pool of free, when the free mop ends, the decoder suspends the operation. </li><li>  At first this is 'lload R ?, 0x .....'  register not defined. </li><li>  This is our ‚Äúlload R ?, 0x .....‚Äù we put on top of the stack of mop indexes. </li><li>  Next come 'push y; push z' with them we do the same.  Now there are three downloads in the mop stack. </li><li>  Next is' multiply ', for her decoder does mop' lmul R?  R?  R? </li><li>  Since the decoder knows that 2 instructions are needed for this instruction, it takes (and deletes) the top two mops from the top of the stack and links it to the given one.  After that the index of the mop 'multiply' is entered on the top of the stack. </li><li>  Next comes the 'add' with it all the same, just one argument - loading from memory, the second - multiplication. </li><li>  When the mop index is out of the stack, you can try to execute it.  The first one is 'push x', which is now 'lload R ?, 0x .....' </li><li>  For the output argument, take the first register (R1, for example) and mark it as busy.  Since this mop is not waiting for anyone, it can be put in the pipeline for execution. </li><li>  After this mop is completed, we notify the heir (only one, the same tree), if any, while it determines the number of the argument register and decreases the counter of the parent mops. </li><li>  If the input arguments hold the register (s), they (the register (s)) can be freed </li><li>  If the counter of expected mops (at the child mop) has become equal to 0, then this mop can also be shifted to the appropriate conveyor. </li><li>  ... </li></ul><br>  What are the types of mops? <br><ol><li>  Operations with registers, for example, addition: the values ‚Äã‚Äãof two registers are summed and placed in the third.  These mops are binary - before being placed on the stack, the links to the two top mops are removed from the stack and the link to the given one is entered.  And also unary - change of a sign, for example.  When creating such an operation, its reference replaces the reference at the top of the stack. </li><li>  Memory operations - loading a value from memory into a register and vice versa.  A load from memory has no predecessors and is simply pushed onto the stack of the mops.  Unloading into memory removes one item from the stack.  Loading from memory adds a link to the stack. </li><li>  The special operation is pop, it is just an instruction to the decoder to remove an element from the top of the stack. </li><li>  Other - branching, function calls, service, until we consider </li></ol><br>  For operations with memory, there is a special type of communication between the mops - through the address, for example, we load the value into memory and immediately read it from memory into the register.  Formally, between these operations there is no connection through the register, in fact it is.  In other words, it would be nice to wait until the end of the recording before reading.  Therefore, for mops in the decoder cache, it is necessary to track such dependencies.  Outside the cache, this problem is solved by serialization through the memory access bus. <br><br><h3>  Software model </h3><br>  Speculative constructions work fine up to the point of attempting to implement them.  So in the future we will be theorizing in parallel with checking on the model. <br><br>  The author has implemented a simple C subset compiler sufficient for the execution of the <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%2590%25D0%25BA%25D0%25BA%25D0%25B5%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Ackermann</a> function.  The compiler produces code for the stack machine and immediately tries to execute it on the fly. <br><br>  Let's not hurry and practice on something simple, for example <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d1, d2, d3, d4, d5, d6, d7, d8; d1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; d2 = <span class="hljs-number"><span class="hljs-number">2</span></span>; d3 = <span class="hljs-number"><span class="hljs-number">3</span></span>; d4 = <span class="hljs-number"><span class="hljs-number">4</span></span>; d5 = <span class="hljs-number"><span class="hljs-number">5</span></span>; d6 = <span class="hljs-number"><span class="hljs-number">6</span></span>; d7 = <span class="hljs-number"><span class="hljs-number">7</span></span>; d8 = <span class="hljs-number"><span class="hljs-number">8</span></span>; print_long (((d1 + d2)+(d3 + d4))+((d5 + d6)+(d7 + d8))); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><br>  But first it is necessary to determine the parameters of the processor model. <br><ol><li>  32 integer registers </li><li>  4 instructions per clock are decoded </li><li>  one pipeline for working with memory, loading and unloading the word to / from the register takes 3 cycles </li><li>  2 pipelines with <a href="http://www.ixbt.com/cpu/cpu-pedia.shtml">ALU</a> , the operation of summation / subtraction takes 3 cycles, comparison - 1 cycle </li></ol><br>  Here and below, instructions are shown at the time of the end of their execution (when the registers are already defined) in the pipeline where they were executed: <br><table><tbody><tr><th>  tact </th><th>  conv.  of memory </th><th>  conv.  N1 </th><th>  conv.  N2 </th></tr><tr><td>  3 <br>  four <br>  five <br>  6 <br>  7 <br>  eight <br>  9 <br>  ten <br>  eleven <br>  12 <br>  13 <br>  14 <br>  15 <br>  sixteen <br>  17 <br>  18 <br>  nineteen <br>  20 <br>  21 <br>  22 <br>  23 <br>  24 <br>  25 <br>  26 <br>  27 <br>  28 <br>  29 <br>  32 <br>  35 <br></td><td>  LLOAD r3 <br>  LLOAD r2 <br>  LLOAD r1 <br>  Lload r0 <br>  LLOAD r7 <br>  LLOAD r6 <br>  LLOAD r5 <br>  LLOAD r4 <br>  LSTORE r3 <br>  LSTORE r2 <br>  LSTORE r1 <br>  LSTORE r0 <br>  LSTORE r7 <br>  LSTORE r6 <br>  LSTORE r5 <br>  LSTORE r4 <br>  LLOAD r11 <br>  LLOAD r10 <br>  LLOAD r8 <br>  LLOAD r15 <br>  Lload r12 <br>  LLOAD r19 <br>  LLOAD r17 <br>  LLOAD r16 <br><br></td><td><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>  LADD r11 r10 -&gt; r9 <br><br>  LADD r8 r15 -&gt; r14 <br><br>  LADD r12 r19 -&gt; r18 <br>  LADD r9 r14 -&gt; r13 <br>  LADD r17 r16 -&gt; r23 <br>  LADD r18 r23 -&gt; r22 <br>  LADD r13 r22 -&gt; r21 <br></td><td></td></tr></tbody></table>  And in register 21, at 35, we get the cherished value of 36. <br><table><tbody><tr><td><img src="https://habrastorage.org/files/aa4/bc1/92e/aa4bc192e15e41469195af62e9e20604.png"></td></tr></tbody></table>  The data from the same table, but in the form of a mop dependency diagram, in brackets [] is the number of the mop completion cycle (x &amp; y does not make sense here, only the direction of the arrows is important). <br><br>  What do we see? <br><ul><li>  first 8 LLOAD instructions - loading constants </li><li>  further 8 LSTORE - variable initialization by constants.  It may seem strange that they were serialized in this way, because initially (LOAD &amp; STORE) were mixed.  But it is worth remembering that loading a constant from memory goes 3 cycles, 4 instructions per cycle.  While the first constant is waiting for the load, the LSTORE operations, by virtue of their dependence, were in the pipeline behind LLOAD.  <b>Ltd. in action</b> , by the way. </li><li>  It seems strange that having 2 pipelines and obvious parallelism we could not load both pipelines.  On the other hand, the last memory load ended after 26 cycles (8 * 3 + 2).  The expression tree has a depth of three strokes per step.  In total, 26 + 9 = 35 cycles, it is impossible to calculate this in principle faster.  Those.  To calculate this code in the fastest way, one integer pipeline is sufficient. </li></ul><br>  Let's try the same, but without explicit initialization of variables. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d1, d2, d3, d4, d5, d6, d7, d8; print_long (((d1 + d2)+(d3 + d4))+((d5 + d6)+(d7 + d8))); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><table><tbody><tr><th>  tact </th><th>  conv.  of memory </th><th>  conv.  N1 </th><th>  conv.  N2 </th></tr><tr><td>  3 <br>  four <br>  five <br>  6 <br>  7 <br>  eight <br>  9 <br>  ten <br>  eleven <br>  12 <br>  13 <br>  14 <br>  15 <br>  sixteen <br>  17 <br>  18 <br>  nineteen <br></td><td>  LLOAD r3 <br>  LLOAD r2 <br>  Lload r0 <br>  LLOAD r7 <br>  LLOAD r4 <br>  LLOAD r11 <br>  LLOAD r9 <br>  LLOAD r8 <br><br></td><td><br><br><br><br>  LADD r3 r2 -&gt; r1 <br><br>  LADD r0 r7 -&gt; r6 <br><br>  LADD r4 r11 -&gt; r10 <br>  LADD r1 r6 -&gt; r5 <br>  LADD r9 r8 -&gt; r15 <br><br><br>  LADD r10 r15 -&gt; r14 <br><br><br>  LADD r5 r14 -&gt; r13 <br></td><td></td></tr></tbody></table><table><tbody><tr><td><img src="https://habrastorage.org/files/5be/58e/966/5be58e9666714a85b8efb0a943bed1ae.png"></td></tr></tbody></table>  The calculation took 8 + 2 + 3 * 3 = 19 cycles, the minimum of the possible, again one pipeline was enough. <br><br>  Now we will try to remove all the brackets and just sum up the variables. <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d1, d2, d3, d4, d5, d6, d7, d8; print_long (d1+d2+d3+d4+d5+d6+d7+d8); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><table><tbody><tr><th>  tact </th><th>  conv.  of memory </th><th>  conv.  N1 </th><th>  conv.  N2 </th></tr><tr><td>  3 <br>  four <br>  five <br>  6 <br>  7 <br>  eight <br>  9 <br>  ten <br>  eleven <br>  12 <br>  13 <br>  14 <br>  15 <br>  sixteen <br>  17 <br>  18 <br>  nineteen <br>  20 <br>  21 <br>  22 <br>  23 <br>  24 <br>  25 <br></td><td>  LLOAD r3 <br>  LLOAD r2 <br>  Lload r0 <br>  LLOAD r6 <br>  LLOAD r4 <br>  LLOAD r10 <br>  LLOAD r8 <br>  LLOAD r14 <br><br></td><td><br><br><br><br>  LADD r3 r2 -&gt; r1 <br><br><br>  LADD r1 r0 -&gt; r7 <br><br><br>  LADD r7 r6 -&gt; r5 <br><br><br>  LADD r5 r4 -&gt; r11 <br><br><br>  LADD r11 r10 -&gt; r9 <br><br><br>  LADD r9 r8 -&gt; r15 <br><br><br>  LADD r15 r14 -&gt; r13 <br><br></td><td></td></tr></tbody></table><table><tbody><tr><td><img src="https://habrastorage.org/files/21c/4ad/1fc/21c4ad1fce1840dc93188925b538deec.png"></td></tr></tbody></table>  In this case, there is a data dependency and the inability to fully load the conveyor led to an extra 6 bars. <br><br>  How about turning the expression inside out? <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d1, d2, d3, d4, d5, d6, d7, d8; print_long (d1+(d2+(d3+(d4+(d5+(d6+(d7+d8))))))); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><table><tbody><tr><td><img src="https://habrastorage.org/files/7cd/13d/d96/7cd13dd96d4247549c66d292da04501e.png"></td></tr></tbody></table>  It was worth the extra clock since  data loading is not in the optimal order. <br><br>  It is strange that in the presence of explicit concurrency and two integer pipelines, the second one is idle.  Let's try to move the system.  Let's go back to <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d1, d2, d3, d4, d5, d6, d7, d8; print_long (((d1 + d2)+(d3 + d4))+((d5 + d6)+(d7 + d8))); <span class="hljs-comment"><span class="hljs-comment">//   </span></span></code> </pre><br>  Let's try to increase the speed of access to memory, let the reading into the register occur in 1 clock cycle.  Funny, but little has changed.  The total time decreased by 2 clocks, more precisely, the whole picture moved up by 2 clocks.  It is understandable, the memory bandwidth has not changed, we just removed the delay to obtain the first result. <br><br>  Perhaps the summation is going too fast.  Let it be done 7 cycles instead of 3. <br>  The total time increased to 29 (8 + 3 * 7) cycles, but in principle nothing has changed, the second pipeline is idle. <br><br>  Let's try to sum up the pyramid of 16 numbers and enter 2 memory pipelines.  The total time is 36 cycles (16/2 + 4 * 7).  The second numeric pipeline was not involved.  Numbers now come in pairs, all 8 summations of the first level start with a delay in tact and this is enough for everything to fit into one conveyor. <br><br>  And only if you enter 4 memory pipelines and allow 6 decoding per clock, it comes to the second numeric pipeline (it has already executed 3 (sic!) Instructions), however, the total time is 33 clock cycles.  Those.  the effectiveness of the summation itself has even deteriorated. <br><br>  Indeed, the conveyor is a very effective mechanism and we need quite weighty arguments to have more than one. <br><br><h3>  Register allocation </h3><br>  In the examples described above, the assignment of registers took place at the time of creation of the mops.  As a result, the register usage map when summing variables with a pyramid looks like this (initial parameters - 4 instructions are decoded per cycle, one memory pipeline, three clocks for reading and summing): <br><table><tbody><tr><td>  8 variables </td><td>  16 variables </td></tr><tr><td><img src="https://habrastorage.org/files/926/e74/786/926e7478650d4792ba2c3dbae4e02197.png"></td><td><img src="https://habrastorage.org/files/98b/fb7/79a/98bfb779a15f437597ada2b26375003a.png"></td></tr></tbody></table>  If, on the other hand, you assign registers at the time the instructions are placed in the pipeline, the picture looks much better: <br><table><tbody><tr><td>  8 variables </td><td>  16 variables </td></tr><tr><td><img src="https://habrastorage.org/files/586/a03/369/586a0336911a4502bfb8a7c5909edcba.png"></td><td><img src="https://habrastorage.org/files/1db/9cd/0c1/1db9cd0c1dd7488eb4c0a93250a3627f.png"></td></tr></tbody></table>  For the control, it is worthwhile to give the instruction dependency diagram (8 numbers): <br><table><tbody><tr><td><img src="https://habrastorage.org/files/66b/3db/767/66b3db767f9c49f4a184dae6f96b6fa8.png"></td></tr></tbody></table><br><h3>  Function call </h3><br>  From general considerations, the architecture being described has problems calling functions.  In fact, after returning from a function, we expect a return of the state of the registers in the context of the current function.  In modern register architectures for this, registers are divided into two categories ‚Äî the caller is responsible for the safety of some, the callee for others. <br><br>  But in our front-end stack architecture, therefore, the compiler may not be aware of the existence of any kind of registers.  And the processor itself should take care of saving / restoring the context, which seems to be a non-trivial task. <br><br>  However, we will solve this problem in the <a href="https://habrahabr.ru/post/279123/">next article</a> . </div><p>Source: <a href="https://habr.com/ru/post/278575/">https://habr.com/ru/post/278575/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278565/index.html">libuniset2 is a library for creating ACS. It is better to see once ... Part 3 (Creating a management process)</a></li>
<li><a href="../278567/index.html">Still messing around with debugging?</a></li>
<li><a href="../278569/index.html">Critical vulnerability of Cisco Nexus 3000 Series Switches and 3500 Platform allows remote access to them</a></li>
<li><a href="../278571/index.html">Preparing an ASP.NET 5 (Core) project and DNX environment to participate in the hackathon as part of hack.summit () 2016 at Koding.com</a></li>
<li><a href="../278573/index.html">Adaptive Split View Controller and Popover in iOS 9 (Swift). Part 1</a></li>
<li><a href="../278577/index.html">Automation of easy database 1C list management</a></li>
<li><a href="../278579/index.html">Using the Chromium project codebase as an SDK for developing cross-platform applications</a></li>
<li><a href="../278581/index.html">History of Chatto</a></li>
<li><a href="../278583/index.html">Work with FireBird from 1C. Collection of proven recipes</a></li>
<li><a href="../278585/index.html">Margaret Hamilton: "Guys, I'll send you to the moon"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>