<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The history of the development of TWIME - the new high-speed interface of the Moscow Exchange</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this hub, we will tell you about our unique experience in developing a high-speed TWIME interface for the Moscow Exchange, explain why low latency ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The history of the development of TWIME - the new high-speed interface of the Moscow Exchange</h1><div class="post__text post__text-html js-mediator-article">  In this hub, we will tell you about our unique experience in developing a high-speed TWIME interface for the Moscow Exchange, explain why low latency (response time) is so important to us and how to shorten it.  We hope that in conclusion you will understand a little more clearly why the Moscow Exchange is more technological in some areas than, for example, such high-load giants as Nginx, VK or MailRu. <br><a name="habracut"></a><br>  To explain what a high-speed TWIME interface is, you have to start from afar.  What is traded on the stock exchange is called a trading instrument - it has a price and can be bought or sold.  A trading instrument can be, for example, a barrel of oil, a Sberbank share, or a pair of currencies.  Derivatives market is a segment of the Moscow Stock Exchange, in which they trade derivatives (derivatives) - futures and options. <br><br>  The main function of the exchange is to take orders for the purchase / sale of trading instruments, to reduce orders to a transaction under strict rules and to issue information about the transactions made. <br>  Accordingly, exchanges have several types of interfaces.  Trading interfaces allow you to make transactions and receive operational information about the transactions.  It is the exchange trading interfaces that are most critical to the response time.  The TWIME protocol implementing gateway is a new, fastest, trading interface to the derivatives market. <br><br>  Before answering the question of how we managed to speed up access to the stock exchange, we will explain why this was necessary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Once upon a time applications of the exchange were taken by phone.  Bidding occurred in manual mode.  Latency from issuing to the notice of applications in the transaction was calculated in seconds, or even minutes. <br><br>  At present, the Exchange accepts applications via the optical channels of communication of the best Russian data centers, and the reduction occurs on the best hardware.  Accordingly, the bidding time is now tens of microseconds.  Agree, the trend to reduce the time for issuing an application is obvious. <br><br>  First of all, this need is caused by the competition of exchanges.  Customers want to submit an order as quickly as possible in order to get ahead of other customers, and, moreover, get ahead of the rhinestone on all exchanges.  This approach allows you to make deals at the best price when the price moves.  At the same time, by and large, no matter how long the application is reduced within the system.  The main thing is to take a queue before competitors. <br><br><h4>  <b>Why does the exchange need low latency?</b> </h4><br>  It is no secret that the exchange receives income from each transaction that is in the book of active orders.  Tariffs, of course, vary and differ in different markets, exchanges, but they are all similar in that the more bandwidth, the more operations are made and money is earned. <br><br>  Over time, the response is more complicated.  The exchange needs a smooth, without bursts, response time.  Because otherwise the principle of "Fair Play" is violated.  If one user had an application for X Œºs, and another for 10 Œºs, and the delay occurred on the exchange side, then there is a threat of lost profit, which greatly distresses the trader.  It is impossible to make the response time strictly the same for all, to reduce the latency variance to 0, but you should always strive for such an indicator. <br><br>  Is the median response time important for the exchange?  For clients, the median is only important if it is not different from the median of other clients.  Otherwise, it is not significant.  One of the latest trends in stock photography is when the exchange slows down itself.  Such a trend began with Michael Lewis's well-known book ‚ÄúFlash Boys‚Äù and continued in the summer of 2016, when the SEC (Securities and Exchange Commission) decided to make one of such slow exchanges public. <br><br><img src="https://habrastorage.org/files/60c/15e/8d4/60c15e8d4f5145fd9e71a3732680265e.png" alt="image"><br><br>  Is the median response time important for the exchange?  This question remains open.  As a rule, you have to find a compromise between bandwidth, median and latency variance.  For example, disabling the Nagle algorithm reduces the median, but also reduces throughput.  There are many such examples. <br><br>  What trading interfaces does the derivatives market have?  We wrote about this in our blog earlier, so we will only repeat in general terms. <br><br>  Previously, the fastest interface was CGate API - a set of libraries with a single API.  CGate communicates with the exchange through a closed internal exchange protocol.  Although this interface is the fastest, but since its protocol is closed and linking to the library is required, there are natural limitations on the supported languages ‚Äã‚Äãand platforms, and there is no possibility to use FPGA, which many of our customers would like. <br><br>  Another trading interface is FIX.  It is quite convenient for customers, since the FIX protocol is an old, time-tested standard for bidding.  Under it created a huge number of libraries and FPGA-solutions.  Unfortunately, on the derivatives market, this interface is somewhat slower than CGate. <br><br>  And most customers naturally preferred CGate.  Now we have developed a new interface, it is faster than CGate, does not require linking, is suitable for FPGA, while the most advanced industry standards are used in its development - and its name is TWIME (Trading Wire Interface for Moscow Exchange). <br><br><h4>  <b>How did we manage to reduce the response time?</b> </h4><br>  We conducted a painstaking analysis of available stock exchange interfaces.  Work continued throughout the summer of 2015.  By the fall, we had a finished prototype that showed latency at 10 ¬µs towards the core.  It was an order of magnitude faster than the fastest interface at that time.  By December, we launched a public test, and in April, began full operation. <br><br>  In developing the fastest interface, we focused on three aspects: <br><br><ul><li>  System architecture, conceptual changes in interfaces. </li><li>  The new protocol, which took the best from its predecessors. </li><li>  Algorithms - private improvements in the implementation of the gateway logic. </li></ul><br><img src="https://habrastorage.org/files/685/5de/a84/6855dea84aae492f9c0ff3d8670a4331.png" alt="image"><br><br>  We cut corners in architecture.  The largest angle is the common gateway of requests, through which all messages to the core, including insensitive to the response time, the so-called non-trading orders, passed earlier.  This gateway performs the functions of monitoring, authentication and flood control.  As a result, we implemented the necessary functionality within our TWIME gateway, and threw out the extra.  Thus, it was possible to avoid unnecessary hop in the network, since usually the common gateway and the core were located on different boxes. <br><br>  We prohibit connecting to the exchange through the TWIME gateway (send TCP SYN) more than once a second from one address.  This reduced the damage from incorrectly written client applications and the attempts of malicious damage. <br><br>  In the new gateway, we use bidding by a numeric identifier, which makes it a little difficult for our customers to get the correct tool identifier, but it allows us to reduce our messages. <br><br>  In developing the new trading protocol, we used the recommendations of the Fix Community, a community of organizations interested in unifying access to various trading platforms. <br><br>  We took FIXP as the basis for our session level, we use SBE at the presentation level, and on the one hand, for the efficiency, it is as close as possible to the internal message format of the trading system core, and on the other hand, it uses the FIX semantics.  The result was a very simple protocol for implementing clients.  We received positive feedback from manufacturers of FPGA-based trading solutions. <br><br>  There are a lot of exchanges, there are hundreds of them, and it turns out to the bidders that it is expensive to support the zoo from the protocols.  The simplicity and uniformity of our protocol allows us to hope that TWIME clients will be able to use more advanced hardware and waste developers' time on optimization, rather than on the implementation of non-standard protocols. <br><br>  Has anyone used google protobuf?  On some tests, SBE shows acceleration tenfold compared to GPB.  SBE is like C language structures that are sent to the network ‚Äúas is‚Äù by passing a pointer to the structure and sizeof structure to the send system call.  Accordingly, serialization and deserialization is simply a C-style cast at compile time.  In fact, everything is a little more complicated, but I think that the advantages and disadvantages of this approach are clear. <br><br>  Each message in TWIME has a fixed size.  The first field in each message is the size of the message without a header, and the second is the identifier of the message type ‚Äî the structure.  By the type of message, you can definitely get the length, but it would be an extra switch, which is long.  Two more fields in the header are the schema identifier and the schema version.  This is all the standard SBE header.  Next come the business logic fields: price, tool, client account. <br><br>  The protocol is more efficient than FIX, because we use binary coding.  For example, in FIX, the time to within milliseconds is 19 bytes, in TWIME the time to within nanoseconds is 8 bytes.  This is the number of nanoseconds from the unix era. <br><br>  It is also more efficient than the internal exchange protocol (Plaza2), the size of messages is 4 times less on average due to the absence of internal core fields. <br><br><img src="https://habrastorage.org/files/0bb/059/2f4/0bb0592f4ac845938f21e2cff4ae8204.png" alt="image"><br><br>  The main secret of low latency is the absence of locks on the critical path. <br>  Mutexes cannot be used in low-latency applications on a critical path, since the time of one slice of time (the minimum time allocated by the OS to programs) of the OS scheduler is usually longer than the processing time of the application.  Memory allocation cannot be performed on a critical path as it uses a mutex. <br><br>  The number of context switches must be minimized using affinity and realtime scheduling.  Ideally, it is better not to have a context-switch for worker threads at all. <br><br>  This may seem banal to some, but the lack of mutexes and memory allocations on the critical path, as well as minimizing context switches, is a necessary condition for the success of a low-latency application. <br><br><img src="https://habrastorage.org/files/0ba/5a1/3a4/0ba5a13a45c44de2b40c209d597d1686.png" alt="image"><br><br>  One of the optimizations we have done relates to working with heartbeat.  A significant part of our clients constantly send and receive messages throughout the day, in which case it is immediately obvious that the client is active and no heartbeat is needed.  We require that the client send heartbeat only in the absence of other messages. <br><br>  Breaking a session over a missed heartbeat is very important for the clients of the exchange.  Since there is an opportunity to ask the exchange in advance to cancel all applications in case of a disconnection. <br><br>  Therefore, the algorithm that is used in other interfaces requires re-registration of the event by a timer on each message.  Which in turn means having to pull out the timer event from the reactor heap and add a new event to the heap (and this is for every new message from the client!). <br><br>  In the new gateway, we chose a different path.  When a new user is connected, we register a timer event at the reactor.  For each message from the client is flagged that there was a message.  When a timer event triggers, we check the flag and drop it.  If the flag was not raised, the client disconnects with an error that heartbeat is missing. <br><br>  This approach does not allow you to accurately trigger an event exactly at a certain interval after the last message.  Therefore, the new gateway disables clients during the interval from one to two intervals after the last message received.  This is the compromise we decided to make to speed up the work of the gateway. <br><br>  Each message that the client sends to the exchange, in fact, is an official document that must be saved and processed.  At what point is the message considered to be on the exchange?  A message is considered technically to come to the exchange if it has been confirmed by TCP ACK. <br><br>  It turns out that in the case of excessive load on the stock exchange there are several ways that you can do with messages.  They cannot be ignored, they cannot be rejected without a good reason either, they can be accumulated in memory, for example, put in a queue in RAM.  So the general gateway of applications behaved.  Not the most effective way to work with messages, may require a lot of memory and unnecessary copying messages. <br><br>  In the new gateway, we chose a different path; we read from socket buffers only those messages that we can process.  If the gateway is heavily loaded, the TCP buffer will be blocked on the server side and TCP ACK messages will stop coming to clients.  Thus, the client will get an EAGAIN error with clogged buffers and asynchronous sockets and will be able to decide for itself whether it is worthwhile in the situation of excessive load on the stock exchange to continue trading as before or change the strategy. <br><br><img src="https://habrastorage.org/files/031/1c2/853/0311c285316343e9bf17c47bc2028636.png" alt="image"><br><br>  One of the most interesting algorithms in our gateway is the priority packet size algorithm. <br><br>  Suppose one of the clients, using super-fast iron and a brilliant code, learned to send messages to the stock exchange faster than the stock manages to process them: does this mean that in this situation the stock exchange will be forced to serve only one client?  Definitely not, because it would be unfair to less fast bidders. <br><br>  Solving the problem that was used before assumed tracking the number of messages from each client and the distribution of gateway time between clients.  In the new gate, we found a simpler solution.  At each iteration of polling sockets, we read no more than a predetermined N-th number of bytes.  Thus, if one of the clients sent 100 messages in one TCP segment, the second sent 15 messages, the third 5 messages, and the priority packet size is 10 messages, then on the first iteration only the messages from the third client will be fully processed.  Messages from the first client will take 10 iterations of the reactor poling, and the second two iterations. <br><br>  Another optimization we have done in the new gateway is the use of a static scheme instead of the dynamic one as it was before. <br><br>  A schema is a set of messages and fields in them.  In the case when the message fields are not known at compile time, this is a dynamic scheme, and if the fields are known at the compilation stage, then we get the static scheme.  Both approaches have their positive and negative sides.  In the first case, the same code can work with different schemes;  in the second, changing the schema requires recompiling the code.  The static scheme allows the compiler to make many additional optimizations, for example, when writing messages to the log.  The code for writing messages from the static scheme to the log is most likely to be inline with the compiler, due to the fact that the number and types of fields are known at the compilation stage. <br><br>  <i>The material was prepared by Nikolai Viskov - an engineer at the Moscow Exchange.</i> </div><p>Source: <a href="https://habr.com/ru/post/321280/">https://habr.com/ru/post/321280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321268/index.html">Let's Encrypt and Express. To each server - on the green lock</a></li>
<li><a href="../321270/index.html">How to evaluate big tasks</a></li>
<li><a href="../321274/index.html">Features of the distributed storage architecture in Dropbox</a></li>
<li><a href="../321276/index.html">As we did not go to Y Combinator, ‚Äú... the profit plan is simple - here the drugs are legal, $ 70 cant ...‚Äù</a></li>
<li><a href="../321278/index.html">Local multiplayer in Unity using Unet</a></li>
<li><a href="../321282/index.html">Riot loafers, or again about the accounting of working time</a></li>
<li><a href="../321286/index.html">Password recovery D-Link DPH-400S or the story of a small hack</a></li>
<li><a href="../321288/index.html">Undocumented features of Windows: breakpoints for registry keys</a></li>
<li><a href="../321290/index.html">The brilliance and poverty of test automation</a></li>
<li><a href="../321292/index.html">There are two functions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>