<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Distributed data structures (part 2, how it's done)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article - part 1, overview - I talked about why we need distributed data structures (hereinafter referred to as RSD) and discussed sev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Distributed data structures (part 2, how it's done)</h1><div class="post__text post__text-html js-mediator-article"><p>  In the previous article - <a href="https://habrahabr.ru/post/328086/">part 1, overview</a> - I talked about why we need distributed data structures (hereinafter referred to as RSD) and discussed several options offered by the distributed <a href="http://ignite.apache.org/">Apache Ignite</a> cache. </p><br><p>  Today I want to talk about the details of the implementation of specific RSD, as well as to conduct a small educational program for distributed caches. </p><br><p>  So: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f4a/0b7/a59/f4a0b7a5959f4aba953c80cefd9e6ffe.jpg"></div><br><a name="habracut"></a><br><p>  Let's start with the fact that, at least in the case of <a href="http://ignite.apache.org/">Apache Ignite</a> , RSDs are not implemented from scratch, but are a superstructure over a distributed cache. </p><br><div class="spoiler">  <b class="spoiler_title">Distributed cache is ...</b> <div class="spoiler_text"><p>  Distributed cache is a data storage system in which information is stored on <u>more than one server</u> , but it provides access to the entire volume of data at once. </p><br><p>  The main advantage of this kind of systems is the ability to <del>  cram in nevpihuemoe </del>  store huge amounts of data without splitting them into pieces, limited by the volumes of specific drives or even entire servers. </p><br><p>  Most often, such systems allow you to dynamically increase storage by adding new servers to the distributed storage system. </p><br><p>  In order to be able to change the cluster topology (add and delete servers), as well as balance data, the principle of <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BA%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">partitioning data is used</a> . </p><br><p>  When creating a distributed cache, you specify the number of partitions into which the data will be divided, for example, 1024. When adding data, the partition responsible for storing them is selected, for example, by key hash.  Each partition can be stored on one or several servers, depending on the cache configuration.  For each specific topology (set of servers), the server where the partition will be stored is calculated using a predetermined algorithm. </p><br><p>  For example, when starting the cache, we indicate that: </p><br><ul><li>  Partitions will be 4 [A, B, C, D] </li><li>  each partition will be stored on two servers (i.e., each will have one backup) </li></ul><br><p>  We will launch four data nodes [JVM 1-4] (responsible for data storage) and one client node [Client JVM] (responsible only for providing data access). </p><br><p>  Each of the four data nodes can be used as a client node (that is, to provide access to all data).  For example, JVM 1 was able to get data on partitions A, C, D, although, locally, it only has A (Primary) and D (Backup). </p><br><div class="spoiler">  <b class="spoiler_title">Primary and Backup node</b> <div class="spoiler_text"><p>  Any data node of a distributed cache for a particular partition can be Primary or Backup, or it may not contain a partition at all. </p><br><p>  Primary node differs from Backup in that it processes requests within the partition and, if necessary, replicates the results to the Backup node. </p><br><p>  In case of failure of the Primary node, one of the Backup nodes becomes Primary. </p><br><p>  If the Primary node fails, in the absence of the Backup node, the partition is considered lost. </p></div></div><br><p>  Some distributed caches provide the ability to locally cache data located on other nodes.  For example, the Client JVM cached part B locally and will not request additional data until it changes. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/web/716/f72/598/716f725980be4139a1462c8b8f5a8593.png" width="500"></div><br><p>  Distributed caches are divided into Partitioned and Replicated. </p><br><p>  The difference is that the Partitioned cache stores one (or one + N backups) partition partition within the cluster, and Replicated stores one instance of the partition on each data node. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/web/26e/b33/076/26eb33076d9246e199677fe75d5028c5.png" width="500"></div><br><p>  Partitioned cache makes sense to use for data storage, whose volumes exceed the capabilities of individual servers, and Replicated - for storing the same data ‚Äúeverywhere‚Äù. </p><br><p>  A good example for understanding is the <em>Employee</em> - <em>Organization</em> bundle.  There are a lot of employees and they change quite often, so it‚Äôs better to keep them in the partitioned cache.  There are few organizations and they rarely change, so it makes sense to store them in the Replicated cache, reading from it is much faster. </p></div></div><br><p>  So, we will pass to implementation details. </p><br><div class="spoiler">  <b class="spoiler_title">Traditional explanation</b> <div class="spoiler_text"><p>  I want to once again indicate that we are talking about implementation within <a href="https://github.com/apache/ignite">the Apache Ignite source code</a> , the implementation may differ in other distributed caches. </p></div></div><br><p>  To ensure the work of the RSD, two caches are used: one Replicated and one Partitioned. </p><br><p> Replicated cache - in this case, it is the system cache, ( <code>ignite-sys-cache</code> ) responsible, among other things, for storing information about the RSDs registered in the system. </p><br><p>  Partitioned-cache ( <code>ignite-atomics-sys-cache</code> ) stores the data necessary for the operation of the RSD, and their state. </p><br><p>  So, most of the RSD is created as follows: </p><br><ol><li>  The transaction starts. </li><li>  In the <code>ignite-sys-cache</code> , using the <code>DATA_STRUCTURES_KEY</code> key, <code>Map&lt;_, DataStructureInfo&gt;</code> is taken (it is created if necessary), and a new item is added to it with a description, for example, <code>IgniteAtomicReference</code> . </li><li>  In the <code>ignite-atomics-sys-cache</code> , by the key from the previously added <code>DataStructureInfo</code> , an element is added that is responsible for the state of the RSD. </li><li>  The transaction commits. </li></ol><br><p>  The first request to create the RSD creates a new instance, and subsequent requests receive the previously created one. </p><br><h3 id="igniteatomicreference-i-igniteatomiclong-kratkaya-vvodnayahttpshabrahabrrupost328086atomicreference-i-atomiclong">  IgniteAtomicReference and IgniteAtomicLong ( <a href="https://habrahabr.ru/post/328086/">brief introductory</a> ) </h3><br><p>  The third initialization step for both types is to add an object of type <code>GridCacheAtomicReferenceValue</code> or <code>GridCacheAtomicLongValue</code> to <code>ignite-atomics-sys-cache</code> . </p><br><p>  Both classes contain one single <code>val</code> field. </p><br><p>  Accordingly, any change in the <code>IgniteAtomicReference</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    . ref.compareAndSet(expVal, newVal);</span></span></code> </pre> <br><p>  ... is launching an <code>EntryProcessor</code> with the following <code>process</code> method code: </p><br><div class="spoiler">  <b class="spoiler_title">EntryProcessor is ...</b> <div class="spoiler_text"><p>  <a href="https://static.javadoc.io/javax.cache/cache-api/1.0.0/javax/cache/processor/EntryProcessor.html">EntryProcessor</a> is a function that allows you to atomically perform complex operations on objects in the cache. </p><br><p>  The <code>process</code> method accepts <a href="https://static.javadoc.io/javax.cache/cache-api/1.0.0/javax/cache/processor/MutableEntry.html">MutableEntry</a> (object in the cache) and can change its value. </p><br><p>  EntryProcessor, in fact, is an alternative to a transaction with a single key (sometimes even implemented as a transaction). </p><br><p>  As a result, it is <u>guaranteed</u> that only one <code>EntryProcessor</code> will be executed on a single object in the cache per time. </p></div></div><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MutableEntry&lt;GridCacheInternalKey, GridCacheAtomicReferenceValue&lt;T&gt;&gt; e, Object... args)</span></span></span><span class="hljs-function"> </span></span>{ GridCacheAtomicReferenceValue&lt;T&gt; val = e.getValue(); T curVal = val.get(); <span class="hljs-comment"><span class="hljs-comment">//  expVal  newVal ‚Äî   // ref.compareAndSet(expVal, newVal); if (F.eq(expVal, curVal)) { e.setValue(new GridCacheAtomicReferenceValue&lt;T&gt;(newVal)); return true; } return false; }</span></span></code> </pre> <br><p>  <code>IgniteAtomicLong</code> is a defacto extension of the <code>IgniteAtomicReference</code> , therefore its <code>compareAndSet</code> method <code>compareAndSet</code> implemented in the same way. </p><br><p>  The <code>incrementAndGet</code> method does not check for the expected value, but simply adds one. </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MutableEntry&lt;GridCacheInternalKey, GridCacheAtomicLongValue&gt; e, Object... args)</span></span></span><span class="hljs-function"> </span></span>{ GridCacheAtomicLongValue val = e.getValue(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> newVal = val.get() + <span class="hljs-number"><span class="hljs-number">1</span></span>; e.setValue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridCacheAtomicLongValue(newVal)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newVal; }</code> </pre> <br><h3 id="igniteatomicsequence-kratkaya-vvodnayahttpshabrahabrrupost328086atomicsequence">  IgniteAtomicSequence ( <a href="https://habrahabr.ru/post/328086/">brief introductory</a> ) </h3><br><p>  When creating each instance of <code>IgniteAtomicSequence</code> ... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      IgniteAtomicSequence. final IgniteAtomicSequence seq = ignite.atomicSequence("seqName", 0, true);</span></span></code> </pre> <br><p>  ... it is allocated a pool of identifiers. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   try (GridNearTxLocal tx = CU.txStartInternal(ctx, seqView, PESSIMISTIC, REPEATABLE_READ)) { GridCacheAtomicSequenceValue seqVal = cast(dsView.get(key), GridCacheAtomicSequenceValue.class); //      locCntr = seqVal.get(); //   upBound = locCntr + off; seqVal.set(upBound + 1); //   GridCacheAtomicSequenceValue   dsView.put(key, seqVal); //   tx.commit();</span></span></code> </pre> <br><p>  Accordingly, the challenge ... </p><br><pre> <code class="java hljs">seq.incrementAndGet();</code> </pre> <br><p>  ... simply increments the local counter to reach the upper boundary of the value pool. </p><br><p>  When the boundary is reached, a new pool of identifiers is <code>IgniteAtomicSequence</code> , in the same way as when creating a new instance of the <code>IgniteAtomicSequence</code> . </p><br><h3 id="ignitecountdownlatch-kratkaya-vvodnayahttpshabrahabrrupost328086countdownlatch">  IgniteCountDownLatch ( <a href="https://habrahabr.ru/post/328086/">brief introductory</a> ) </h3><br><p>  Decrement counter: </p><br><pre> <code class="java hljs">latch.countDown();</code> </pre> <br><p>  ... is implemented as follows: </p><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">//   try (GridNearTxLocal tx = CU.txStartInternal(ctx, latchView, PESSIMISTIC, REPEATABLE_READ)) { GridCacheCountDownLatchValue latchVal = latchView.get(key); int retVal; if (val &gt; 0) { //   retVal = latchVal.get() - val; if (retVal &lt; 0) retVal = 0; } else retVal = 0; latchVal.set(retVal); //   latchView.put(key, latchVal); //   tx.commit(); return retVal; }</span></span></code> </pre> <br><p>  Waiting for decrementing counter to 0 ... </p><br><pre> <code class="java hljs">latch.await();</code> </pre> <br><p>  ... is implemented through the <a href="https://apacheignite.readme.io/docs/continuous-queries">Continuous Queries</a> mechanism, that is, each time the <code>GridCacheCountDownLatchValue</code> changes in the cache, all instances of <code>IgniteCountDownLatch</code> notified of these changes. </p><br><p>  Each instance of <code>IgniteCountDownLatch</code> has a local: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** Internal latch (transient). */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CountDownLatch internalLatch;</code> </pre> <br><p>  Each notification decrements <code>internalLatch</code> to the current value.  Therefore, <code>latch.await()</code> is implemented very simply: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (internalLatch.getCount() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) internalLatch.await();</code> </pre> <br><h3 id="ignitesemaphore-kratkaya-vvodnayahttpshabrahabrrupost328086semaphore">  IgniteSemaphore ( <a href="https://habrahabr.ru/post/328086/">short introductory</a> ) </h3><br><p>  Getting permission... </p><br><pre> <code class="java hljs">semaphore.acquire();</code> </pre> <br><p>  ... proceeds as follows: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      for (;;) { int expVal = getState(); int newVal = expVal - acquires; try (GridNearTxLocal tx = CU.txStartInternal(ctx, semView, PESSIMISTIC, REPEATABLE_READ)) { GridCacheSemaphoreState val = semView.get(key); boolean retVal = val.getCount() == expVal; if (retVal) { //     . //      - node, //     . { UUID nodeID = ctx.localNodeId(); Map&lt;UUID, Integer&gt; map = val.getWaiters(); int waitingCnt = expVal - newVal; if (map.containsKey(nodeID)) waitingCnt += map.get(nodeID); map.put(nodeID, waitingCnt); val.setWaiters(map); } //    val.setCount(newVal); semView.put(key, val); tx.commit(); } return retVal; } }</span></span></code> </pre><br><p>  Return Permission ... </p><br><pre> <code class="java hljs">semaphore.release();</code> </pre> <br><p>  ... occurs in a similar way, except that the new value is greater than the current one. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> newVal = cur + releases;</code> </pre> <br><h3 id="ignitequeue-kratkaya-vvodnayahttpshabrahabrrupost328086blockingqueue">  IgniteQueue ( <a href="https://habrahabr.ru/post/328086/">short introductory</a> ) </h3><br><p>  Unlike other RSDs, <code>IgniteQueue</code> does not use <code>ignite-atomics-sys-cache</code> .  The used cache is described using the <code>colCfg</code> parameter. </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      IgniteQueue. IgniteQueue&lt;String&gt; queue = ignite.queue("queueName", 0, colCfg);</span></span></code> </pre> <br><p>  Depending on the specified <a href="https://apacheignite.readme.io/docs/transactions">Atomicity Mode</a> (TRANSACTIONAL, ATOMIC), you can get different versions of <code>IgniteQueue</code> . </p><br><pre> <code class="java hljs">queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridCacheQueueProxy(cctx, cctx.atomic() ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridAtomicCacheQueueImpl&lt;&gt;(name, hdr, cctx) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridTransactionalCacheQueueImpl&lt;&gt;(name, hdr, cctx));</code> </pre> <br><p>  In both cases, the state of <code>IgniteQueue</code> controlled by: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridCacheQueueHeader</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> head; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> tail; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> cap; ...</code> </pre> <br><p>  <code>AddProcessor</code> used to add an item ... </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">Long </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MutableEntry&lt;GridCacheQueueHeaderKey, GridCacheQueueHeader&gt; e, Object... args)</span></span></span><span class="hljs-function"> </span></span>{ GridCacheQueueHeader hdr = e.getValue(); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> rmvd = queueRemoved(hdr, id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rmvd || !spaceAvailable(hdr, size)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rmvd ? QUEUE_REMOVED_IDX : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; GridCacheQueueHeader newHdr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridCacheQueueHeader(hdr.id(), hdr.capacity(), hdr.collocated(), hdr.head(), hdr.tail() + size, <span class="hljs-comment"><span class="hljs-comment">//     hdr.removedIndexes()); e.setValue(newHdr); return hdr.tail(); }</span></span></code> </pre> <br><p>  ... which, in essence, simply moves the pointer to the tail of the queue. </p><br><p>  Thereafter... </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    //  hdr.tail() QueueItemKey key = itemKey(idx);</span></span></code> </pre> <br><p>  ... a new item is added to the queue: </p><br><pre> <code class="java hljs">cache.getAndPut(key, item);</code> </pre> <br><p>  Deleting an element is similar, but the pointer does not change to <code>tail</code> , but to <code>head</code> ... </p><br><pre> <code class="java hljs">GridCacheQueueHeader newHdr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GridCacheQueueHeader(hdr.id(), hdr.capacity(), hdr.collocated(), hdr.head() + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-comment"><span class="hljs-comment">//     hdr.tail(), null);</span></span></code> </pre> <br><p>  ... and the item is deleted. </p><br><pre> <code class="java hljs">Long idx = transformHeader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PollProcessor(id)); QueueItemKey key = itemKey(idx); T data = (T)cache.getAndRemove(key);</code> </pre> <br><p>  The difference between <code>GridAtomicCacheQueueImpl</code> and <code>GridTransactionalCacheQueueImpl</code> is that: </p><br><ul><li><p>  When adding an element, <code>GridAtomicCacheQueueImpl</code> first atomically increments <code>hdr.tail()</code> , and then adds an element to the cache using the resulting index. </p><br></li><li>  <code>GridTransactionalCacheQueueImpl</code> does both actions in the same transaction. </li></ul><br><p>  As a result, <code>GridAtomicCacheQueueImpl</code> works faster, but there may be a problem of data consistency: if the information about the size of the queue and the data itself are not stored at the same time, then they may not be deducted at the same time. </p><br><p>  It is quite possible that the inside of the <code>poll</code> method shows that the queue contains new elements, but there are no elements themselves yet.  This is extremely rare, but still possible. </p><br><p>  This problem is solved by waiting for the value. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> stop = U.currentTimeMillis() + RETRY_TIMEOUT; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (U.currentTimeMillis() &lt; stop) { data = (T)cache.getAndRemove(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">A few words about the reliability of a non-transactional decision</b> <div class="spoiler_text"><p>  There were real cases when there was not enough five-second timeout, which led to data loss in the queue. </p></div></div><br><h3 id="vmesto-zaklyucheniya">  Instead of conclusion </h3><br><p>  Once again, I would like to point out that distributed cache is, in fact, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a> within many cluster-integrated computers. </p><br><p>  Distributed cache can be used to implement many important, complex, but reliable systems. </p><br><p>  A special case of implementation are distributed data structures, but in general they are used for storing and processing huge amounts of data in real time, with the possibility of increasing the volume or speed of processing by simply adding new nodes. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/328368/">https://habr.com/ru/post/328368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328358/index.html">Fatty programs - we study the factor of memory part B</a></li>
<li><a href="../328360/index.html">Min-Long Chou: What I designed for Uncharted 4. Part 2</a></li>
<li><a href="../328362/index.html">Accelerate std :: shared_mutex 10 times</a></li>
<li><a href="../328364/index.html">Crystal High Performance Services, Newbie Introduction</a></li>
<li><a href="../328366/index.html">Build 2017: text translation. Day 2</a></li>
<li><a href="../328370/index.html">Should I buy ECC memory?</a></li>
<li><a href="../328372/index.html">Metrics in machine learning tasks</a></li>
<li><a href="../328374/index.html">Thread safe std :: map with lock-free map performance</a></li>
<li><a href="../328376/index.html">As an open password field in registration forms increases conversion</a></li>
<li><a href="../328378/index.html">Key announcements of the first day of the Build 2017 conference</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>