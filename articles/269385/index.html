<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cache in Drupal from A to Z</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 

 The pages of the sites are getting bigger in size, and the question of asynchronous content loading on them arises. But if for images ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cache in Drupal from A to Z</h1><div class="post__text post__text-html js-mediator-article">  <b>Introduction</b> <br><br>  The pages of the sites are getting bigger in size, and the question of asynchronous content loading on them arises.  But if for images there is a library for their simple loading after loading the main page, then with asynchronous loading of HTML parts of the page (blocks), everything is much more complicated.  For example: to implement asynchronous block loading in Drupal without loss of site performance, you need to understand how caching works, how to use it and how to optimize it.  And after that, according to the planned ‚ÄúLazy Loading‚Äù plan, load the blocks of the site. <br><a name="habracut"></a><br>  <b>Cache in Drupal - introduction</b> <br><br><img align="left" src="https://habrastorage.org/files/7f0/c0d/9de/7f0c0d9de7d34912b07b4307f63aee9a.png" alt="image">  The cache in Drupal is an intermediate buffer that stores frequently requested data that can be returned to the user with the least amount of system resources and maximum speed.  This buffer can be a table (s) in a database, a file with data on a hard disk, or a set of key-value in a network logged data repository.  Any storage option that can be integrated with PHP to cache a web application on Drupal will do. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One example of using cache in Drupal is the menu cache.  In most cases, the menu is not a frequently changeable part of the site.  It makes no sense to rebuild each time (get all the items, their dependence on each other, display them in a template) menu for display to the user when he enters the new page of the site.  Moreover, if this is a menu of a catalog of 1000 items, it can be rebuilt for output for a long time.  Why make the user wait?  Therefore, Drupal caches the once built menu for the time specified by the administrator and caches it to the user, avoiding a long menu rebuilding operation. <br><br>  Drupal contains a built-in cache (in its basic modules), which can be configured on the page: / admin / settings / performance.  You need to remember to periodically clean it when you add new functionality in any of your developments (whether they are templates or modules). <br><br>  You can clear the cache in several ways: <br><ul><li>  Using the "Clear Cache" button on the / admin / settings / performance page </li><li>  Install the admin_menu module and select Flush all caches in the leftmost tab (Clear all caches) </li><li>  Using the ‚ÄúEmpty cache‚Äù link to clear the Devel Block block (Devel module) </li><li>  Having executed the Drush command: drush cache-clear theme (only the theme cache is cleaned) </li><li>  Programmatically, by calling the drupal_rebuild_theme function (only the theme cache is cleared) </li></ul><br>  <b>Cache in Drupal - cache segments</b> <br><br><img width="175" align="left" src="https://habrastorage.org/files/d24/113/f57/d24113f57fb04943bf7f4fb22600be85.png" alt="image">  Drupal cache is divided into segments, and not stored in a single place.  By default, each cache segment is stored as a separate table in the database.  This allows you to move frequently updated cache segments to other cache storage systems, such as Memcached or Boost.  It also improves the performance of the cache - in smaller amounts of data work with records occur faster.  Moreover, with certain actions, the cache can be partially cleared (segment). <br><br>  Drupal has many different cache segments.  Cache segments are similar for versions 7.XX and 6.XX: <br><br>  <b>1. {cache}</b> - a segment for shared cache storage.  This includes data that cannot be classified, or there is no point in creating a new cache segment for them. <br><br>  <b>2. {cache_block}</b> - added when the Block module is turned on (included in the kernel).  When the Drupal theme region is loaded, data is loaded for all blocks of this region and, if necessary, the block is built or displayed from the cache, skipping the hook_block_view () hook.  It should be noted that caching for blocks is disabled if the modules for working with access to the material that use hook_node_access () are enabled.  It is also necessary to know that when programmatically creating a block via hook_block_info (), you can control the caching parameters for the block (for more details, see the documentation). <br><br>  <b>3. {cache_filter}</b> - the Filter module creates its own table for storing the cache for the text processed by filters.  The more complex the filter, the more CPU time is spent on text processing.  Therefore, whenever possible, all calls to check_markup () are cached.  The cache ID for the {cache_filter} table is built according to the format_name rule: language: hash_text. <br><br>  <b>4. {cache_form}</b> - if the rest of the cached data is stored to speed up the operation of the site, then this cache does not affect the performance in any way.  It is necessary for forms built using the Forms API to be completely safe in terms of vulnerabilities.  Each time a form is built, it is stored in the {cache_form} segment.  If there are a lot of forms and visitors, then {cache_form} tends to grow to impressive sizes, if you do not run cron to clear the cache every hour or two. <br><br>  <b>5. {cache_menu}</b> - enabled when the Menu module is enabled and is a repository of links from all the menus created via the interface.  Cache ID is built according to the rule links: name_name: tree-data: language: hash_parameters. <br><br>  <b>6. {cache_page}</b> - stores cached page data for anonymous users.  If a cache is found for the current page, only 2 hooks will be called: hook_boot () and hook_exit ().  The rest of the hooks (including hook_init () and others) will be skipped.  This is exactly the cache that is enabled on the site in the performance settings section (admin / config / development / performance) by ticking ‚ÄúCache pages for anonymous users‚Äù. <br><br>  <b>7. {cache_update}</b> - Update manager module adds this segment.  It stores all release data for the included modules. <br><br>  <i><b>Cache segments available in Drupal version 7.XX (not in version 6.XX)</b> :</i> <br><br>  <b>1. {cache_path}</b> - stores the correspondence between the system path and its aliases for faster search of the alias by the system path. <br><br>  <b>2. {cache_image}</b> - it is reserved by the Image module and can be used as a storage of information about the various manipulations of images. <br><br>  <b>3. {cache_bootstrap}</b> - a cache segment in which data initialized when Drupal is loaded is stored. <br><br>  <b>4. {cache_field}</b> - this segment stores data for all fields (fields).  Cache ID is formed according to the rule field: entity_type: entity_id. <br><br>  Also, third-party modules can create their own cache segments.  For example, segments for modules hacked, l10n_update, token, views: <br><ul><li>  cache_hacked </li><li>  cache_l10n_update </li><li>  cache_token </li><li>  cache_views </li><li>  cache_views_data </li></ul><br>  It is worth mentioning the Ctools object cache, which is not related to the kernel and is created by the CTools module.  The CTools object cache is a segment of the cache that provides its space for storing large objects that are currently being edited.  For example, the cache of the modified view before its saving in the Views module is stored in the CTools object cache.  Unlike other cache segments, it has an additional sid field (Session ID) - the identifier of the current user session.  Thanks to him, the changed data is visible only to the user who changed the object.  This segment does not have an expire field and is not deleted when the cache is cleared through the interface, but is cleared once a day by Cron, removing the week-old cache from this segment. <br><br>  <b>Page life cycle</b> <br><br><img width="175" align="left" src="https://habrastorage.org/files/e30/6d6/3fe/e306d63fe94e44b6bae2ec91b5351f8b.jpg" alt="image">  When a page is requested from the web server by the user's browser, the following occurs (using the example of Drupal version 7.XX): <br><br>  The Drupal kernel is initially loaded with one of the parameters: <br><ul><li>  <b>DRUPAL_BOOTSTRAP_CONFIGURATION</b> : Initializes only the configuration. </li><li>  <b>DRUPAL_BOOTSTRAP_PAGE_CACHE</b> : Initialization of the caching layer. </li><li>  <b>DRUPAL_BOOTSTRAP_DATABASE</b> : Initialization of the database layer. </li><li>  <b>DRUPAL_BOOTSTRAP_VARIABLES</b> : Initialization of a layer of variables. </li><li>  <b>DRUPAL_BOOTSTRAP_SESSION</b> : Initialization of work with sessions. </li><li>  <b>DRUPAL_BOOTSTRAP_PAGE_HEADER</b> : Initialization of the header layer. </li><li>  <b>DRUPAL_BOOTSTRAP_LANGUAGE</b> : Initialization of the page language layer. </li><li>  <b>DRUPAL_BOOTSTRAP_FULL</b> : Fully loads Drupal.  And also adds the function of checking and correcting the entered data. </li></ul><br>  More details can be found in the drupal_bootstrap () function from the bootstrap.inc file located in the includes folder. <br><br>  When running drupal_bootstrap () with the parameter DRUPAL_BOOTSTRAP_FULL, the following is performed: <br><ul><li>  Connection of system functions files. </li><li>  Initialization of all layers and primary settings. </li><li>  Connection of files of all included modules. </li><li>  Initialization of variables and system functions for working with paths and their aliases in Drupal. </li><li>  Initialization of the included theme. </li><li>  Performed by executing module_invoke_all ().  Implements an API for loading and interacting with Drupal modules, registering all the hooks of the currently enabled modules. </li></ul><br>  After that, the menu_execute_active_handler () function is called, which defines the navigation menus and converts page requests to function calls associated with paths on the site.  Also inside this function, a call is made: <br><ul><li>  Functions drupal_deliver_html_page (), which returns these pages as HTML to the user's browser.  Inside this function, the drupal_render () function is called, which not only outputs the data, but also saves it to one of the cache segments and retrieves it from there if available instead of re-generating the page using the template engine. </li><li>  The drupal_page_footer () function, which sets the page cache ('cache_path' and 'cache_bootstrap'), if necessary, and allows modules to respond when the page is closed by hook_exit ().  Immediately, if necessary, run Cron. </li></ul><br>  In general: <br><ol><li>  All the necessary variables and functions are initialized. </li><li>  It checks to see if there is a cache at the given URL ({cache_page}).  If it is, it is returned, otherwise further actions are performed. </li><li>  It checks whether there is a cache of fields ({cache_field}), content ({cache_filter}), menu ({cache_menu}), blocks ({cache_block}), as well as images ({cache_image}) and aliases ({cache_path}).  If the cache is not available, then an operation is performed to obtain and process the necessary data and save it to the cache.  The received data is transmitted to the theme function. </li><li>  The theme function builds the page and caches it at the given URL ({cache_page}). </li><li>  Data is returned to the user. </li></ol><br>  <b>Software work with cache in Drupal 7.X</b> <br><br><img width="175" align="left" src="https://habrastorage.org/files/330/71d/426/33071d4261b64b73af15dc7beac8de7a.png" alt="image">  The most common way to work with the cache is to save the data of the developed module to the cache using the function cache_set.  And also extracting them from it using the cache_get function. <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">// ,     : my_module_data. if ($cache = cache_get('my_module_data')) { //   ,   . return $cache-&gt;data; } else { //   ,   . $my_data = '   '; //      : my_module_data : {cache}. cache_set('my_module_data', $my_data, 'cache'); //  . return $my_data; } </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre> <br>  You can clear the cache data called my_module_data by calling one of the functions: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//        //   (    ). cache_clear_all(); //    {my_module_data}. cache_clear_all('*', 'my_module_data', TRUE); //    {my_module_data} , //   Cache ID  c 'my_module'. cache_clear_all('my_module', 'my_module_data', TRUE); </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span></span></code> </pre> <br>  Via the site‚Äôs admin interface, this can be done on the page: <a href="http://example.com/admin/config/development/performance">example.com/admin/config/development/performance</a> by clicking the Clear cache button. <br><br>  If you want the data to be cached for a specific time and do not depend on pressing the clear cache button on the <a href="http://example.com/admin/config/development/performance">example.com/admin/config/development/performance</a> page, then it is enough to add an additional parameter to the cache_set function - how many seconds to cache the data. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> cache_set(<span class="hljs-string"><span class="hljs-string">'my_module_data'</span></span>, $my_data, <span class="hljs-string"><span class="hljs-string">'cache'</span></span>, time() + <span class="hljs-number"><span class="hljs-number">360</span></span>); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  Drupal allows you to create your own cache segments for data storage.  Create a module for this: mymodule.  To do this in the site directory: ./sites/default/modules create a folder: mymodule.  In it, we will create a file describing the module mymodule.info with the contents: <br><br><pre> <code class="php hljs">name = My module description = <span class="hljs-string"><span class="hljs-string">"      ."</span></span> core = <span class="hljs-number"><span class="hljs-number">7.</span></span>x version = <span class="hljs-number"><span class="hljs-number">7.</span></span>x<span class="hljs-number"><span class="hljs-number">-1.</span></span>x-dev files[] = mymodule.module</code> </pre> <br>  We will also create a file mymodule.install in which, using hook_schema (), we will create a new table to store the data of our cache segment: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Implements hook_schema(). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mymodule_schema</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    : {cache}. //         //      . $schema['mymodule'] = drupal_get_schema_unprocessed('system', 'cache'); $schema['mymodule']['description'] = 'Cache table stores some example data.'; return $schema; }</span></span></code> </pre><br>  The last step before starting to use the cache_set function with an indication of the segment we created is to create the mymodule.module file and take care of automatically resetting the cache when you click the cache clear button on the page <a href="http://example.com/admin/config/development/performance">example.com/admin/config/development/performance</a> . <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">/** * Implements hook_flush_caches(). */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mymodule_flush_caches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//          . return array('mymodule'); }</span></span></code> </pre> <br>  We include the module on the page <a href="http://example.com/%25D0%25B0dmin/modules">example.com/admin/modules</a> , after which, for example, we will save the data in our own segment of the cache created by the module: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> cache_set(<span class="hljs-string"><span class="hljs-string">'my_module_data'</span></span>, <span class="hljs-string"><span class="hljs-string">'     '</span></span>, <span class="hljs-string"><span class="hljs-string">'mymodule'</span></span>); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  There is a little-known function cache_is_empty, with which you can find out if any data is stored in the cache with the specified name: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> cache_is_empty(<span class="hljs-string"><span class="hljs-string">'my_module'</span></span>); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  How to work with the cache in Drupal 6.X and 8.X, you can always see in the submodule cache_example, module: examples from page: <a href="https://www.drupal.org/project/examples">www.drupal.org/project/examples</a> . <br><br>  <b>Cache removal from database</b> <br><br><img width="175" align="left" src="https://habrastorage.org/files/bf3/b73/b4b/bf3b73b4bc47400892e99ae52ddfed82.png" alt="image">  Segment cache can be migrated, for example to Memcached or Redis. <br><br>  Each repository has its own supporters.  Evgeniy Maslovskiy (Spleshka, <a href="https://www.drupal.org/u/spleshka">www.drupal.org/u/spleshka</a> ), who <a href="https://www.drupal.org/u/spleshka">helped</a> write the article, is a supporter of Memcached, and his website describes in detail the integration of Memcached and Drupal.  In the module of integration with Memcached described by it there are additional advantages over other solutions: it is bypassing the connection to the database when receiving the cache and bypassing calls to hook_exit () and hook_boostrap () in other modules. <br><br>  In this article, we‚Äôll consider making cache in Redis, which I like more simple setup compared to Memcached.  A comparative tests of the speeds of both storages will be discussed in another article. <br><br>  Redis settings on the server can be found on the Internet.  The module for integration with Drupal will be downloaded from <a href="https://www.drupal.org/project/redis">www.drupal.org/project/redis</a> and unpacked to the directory ./sites/all/modules.  After that, we make changes to the Drupal configuration file ./sites/default/settings.php, adding the lines to it: <br><br><pre> <code class="php hljs">$conf[<span class="hljs-string"><span class="hljs-string">'redis_client_interface'</span></span>] = <span class="hljs-string"><span class="hljs-string">'PhpRedis'</span></span>; $conf[<span class="hljs-string"><span class="hljs-string">'redis_client_host'</span></span>] = $relationships[<span class="hljs-string"><span class="hljs-string">'redis'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'host'</span></span>]; $conf[<span class="hljs-string"><span class="hljs-string">'redis_client_port'</span></span>] = $relationships[<span class="hljs-string"><span class="hljs-string">'redis'</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'port'</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//     PHP    Redis. $conf['redis_client_interface'] = 'PhpRedis'; $conf['cache_backends'][] = 'sites/all/modules/redis/redis.autoload.inc'; $conf['cache_default_class'] = 'Redis_Cache'; //     {cache_form}      . $conf['cache_class_cache_form'] = 'DrupalDatabaseCache'; //           : {mymodule} //     Redis. $conf['cache_class_mymodule'] = 'Redis_Cache';</span></span></code> </pre> <br>  Do not forget to read the README.txt file in the module folder, since it describes all the module settings. <br><br>  <b>Where can this be applied?</b> <br><br><img src="https://habrastorage.org/files/545/52d/550/54552d5509b84bd59779cd8d886832f5.png" alt="image"><br><br>  One of the options for applying the described knowledge is the removal of part of the site data into blocks that load after the main page load, both to speed up the site load and to speed up the overall site operation.  All you need to do is to take the Ajax Blocks module as a basis, integrate it with the High-performance JavaScript callback handler module, and place the data cache in your Redis repository using this article. <br><br>  <b>Conclusion</b> <br><br>  This article did not get a description of a large number of caching modules written by the community and posted on <a href="https://www.drupal.org/">www.drupal.org</a> .  If you like the article, vote for it, and then in the next article I will try to include a bonus in the form of a review of caching in Drupal 8. And also consider the topic of use in Drupal as a cache store Redis or Elasticsearch with a frontend on Silex and AngularJS. </div><p>Source: <a href="https://habr.com/ru/post/269385/">https://habr.com/ru/post/269385/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269375/index.html">My cat is about "perfect code"</a></li>
<li><a href="../269377/index.html">Api-platform</a></li>
<li><a href="../269379/index.html">Analysis of options for building telephony based on Microsoft Skype For Business</a></li>
<li><a href="../269381/index.html">Pirate metrics: how to create an AARRR email campaign from Dave McClure. Part 1</a></li>
<li><a href="../269383/index.html">Embed JSON in Embedded? Easy peasy</a></li>
<li><a href="../269387/index.html">Oracle regular expressions. Dangerous range</a></li>
<li><a href="../269389/index.html">Xamarin.UITest</a></li>
<li><a href="../269391/index.html">ShishNashKi</a></li>
<li><a href="../269393/index.html">Security Week 43: hard prime numbers, cryptography in HDD, Adobe and Oracle patches</a></li>
<li><a href="../269395/index.html">Golden Site distributed elephants to the best Internet projects.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>