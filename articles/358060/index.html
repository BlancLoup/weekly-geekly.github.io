<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Service Workers: transparent cache update</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Service Workes as a technology for creating offline applications is very well suited for caching various resources. A variety of tactics work in the s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Service Workers: transparent cache update</h1><div class="post__text post__text-html js-mediator-article">  Service Workes as a technology for creating offline applications is very well suited for caching various resources.  A variety of tactics work in the service worker with a local cache are described in detail on the Internet. <br><br>  Not described one - how to update the files in the cache.  The only thing that Google and MDN offers is to make several caches for different types of resources, and, when necessary, change the version of this cache in the worker's sw.js service script, after which it will be completely removed. <a name="habracut"></a><br><br><div class="spoiler">  <b class="spoiler_title">Cache removal</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CURRENT_CACHES = { <span class="hljs-attr"><span class="hljs-attr">font</span></span>: <span class="hljs-string"><span class="hljs-string">'font-cache-v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">css</span></span>:<span class="hljs-string"><span class="hljs-string">'css-cache-v1'</span></span>, <span class="hljs-attr"><span class="hljs-attr">js</span></span>:<span class="hljs-string"><span class="hljs-string">'js-cache-v1'</span></span> }; self.addEventListener(<span class="hljs-string"><span class="hljs-string">'activate'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expectedCacheNames = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(CURRENT_CACHES).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CURRENT_CACHES[key]; }); <span class="hljs-comment"><span class="hljs-comment">// Delete out of date cahes event.waitUntil( caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if (expectedCacheNames.indexOf(cacheName) == -1) { console.log('Deleting out of date cache:', cacheName); return caches.delete(cacheName); } }) ); }) ); });</span></span></code> </pre> <br></div></div><br>  In other words, if you have, for example, ten js files, and you have changed one of them, all users will have to reload all js files.  Enough clumsy work. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of the third-party products (albeit from Google developers), the worker's service closest to solving the problem of updating cache files is the <a href="https://github.com/GoogleChromeLabs/sw-precache">sw-precache library</a> .  It adds hashes to sw.js for all files whose change tracking has been set by the developer.  When at least one of them changes on the server, the next time the service is activated, the worker‚Äôs service again updates the entire client cache, but now without the programmer‚Äôs special gestures.  Ax replaced with a hammer. <br><br><h3>  Formulation of the problem </h3><br>  We need a transparent and reliable update of the worker service cache files.  This means that the developer uploads the modified files to the server, and only the user updates them automatically at the next login / request.  Let's try to solve this problem. <br><br>  Take the common <a href="https://developers.google.com/web/ilt/pwa/lab-offline-quickstart">Google example of a</a> worker service, which operates on the principle: ‚Äúfirst from the cache, if not there, from the network‚Äù. <br><br>  For a start it is clear that you need to have a list of monitored files  Also, you need to somehow compare them with the versions of files in the cache.  This can be done either on the server or on the client. <br><br><h3>  Option 1 </h3><br>  We use cookies.  We will write to the user's cookie the time of his last visit.  On the next run, we compare it with the modification time of the monitored files on the server, and transmit a list of the files that have been modified since that moment in the html code of the page, immediately before registering the worker's service.  To do this, we include there the output of this php file: <br><br><div class="spoiler">  <b class="spoiler_title">updated_resources.php</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $files = [ <span class="hljs-string"><span class="hljs-string">"/css/fonts.css"</span></span>, <span class="hljs-string"><span class="hljs-string">"/css/custom.css"</span></span>, <span class="hljs-string"><span class="hljs-string">"/js/m-js.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"/js/header.css"</span></span>]; $la = $_COOKIE[<span class="hljs-string"><span class="hljs-string">"vg-last-access"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($la)) $la = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>($files <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $file) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (filemtime(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">"/../.."</span></span> . $file) &gt; $la) { $updated[] = $file; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"&lt;script src='/update-resource$file'&gt;&lt;/script&gt;\n"</span></span>; } } setcookie(<span class="hljs-string"><span class="hljs-string">"vg-last-access"</span></span>, time(), time() + <span class="hljs-number"><span class="hljs-number">31536000</span></span>, <span class="hljs-string"><span class="hljs-string">"/"</span></span>); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre><br></div></div><br>  $ files - an array of monitored resources.  For each modified file a script tag with the <i>/ update-resource</i> keyword will be generated, which will entail a request to the service worker. <br><br>  There we filter these requests by keyword and reload resources. <br><br><div class="spoiler">  <b class="spoiler_title">sw.js fetch</b> <div class="spoiler_text"><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> url = event.request.url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (url.indexOf(<span class="hljs-string"><span class="hljs-string">"/update-resource"</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(url.replace(<span class="hljs-string"><span class="hljs-string">"\/update-resource"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetchAndCache(r); } <span class="hljs-comment"><span class="hljs-comment">//    ,   -  fetchAndCache() ... });</span></span></code> </pre> <br></div></div><br>  That's all, resources are updated as they change.  However, there are weaknesses: cookies may disappear, and then the user will have to download all the files again.  It is also likely that after the user has installed the cookie, for some reason he will not be able to download all the updated files.  In this case, he will have a "broken" application.  Let's try to think of something more reliable. <br><br><h3>  Option 2 </h3><br>  We will, like the guys from Google, transfer the tracked files to sw.js, and check the changes on the client side.  As a functional measure without inventing a hash bike, we take the E-Tag or Last-Modified respawn headers ‚Äî they are perfectly stored in the worker's cache.  It is more correct to take an E-Tag, but to get it on the server side, you will need to perform a local request to the web server, which is a little expensive, and Last-Modified is perfectly calculated using filemtime (). <br><br>  So, instead of sw.js, we now register sw.php with the following code: <br><br><div class="spoiler">  <b class="spoiler_title">sw.php</b> <div class="spoiler_text"><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> header(<span class="hljs-string"><span class="hljs-string">"Content-Type: application/javascript"</span></span>); header(<span class="hljs-string"><span class="hljs-string">"Cache-Control: no-store, no-cache, must-revalidate"</span></span>); $files = [ <span class="hljs-string"><span class="hljs-string">"/css/fonts.css"</span></span>, <span class="hljs-string"><span class="hljs-string">"/css/custom.css"</span></span>, <span class="hljs-string"><span class="hljs-string">"/js/m-js.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"/js/header.js"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"var updated = {};\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span>($files <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $file) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"updated['$file'] = '"</span></span> . gmdate(<span class="hljs-string"><span class="hljs-string">"D, d MYH:i:s \G\M\T"</span></span>, filemtime(<span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . $file)) . <span class="hljs-string"><span class="hljs-string">"';\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>; readfile(<span class="hljs-string"><span class="hljs-string">'sw.js'</span></span>); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br></div></div><br>  It generates at the beginning of sw.js a declaration of an associative array initialized by the {url, Last-Modified} pairs of our monitored resources. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updated = {}; updated[<span class="hljs-string"><span class="hljs-string">'/css/fonts.css'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Mon, 07 May 2018 02:47:54 GMT'</span></span>; updated[<span class="hljs-string"><span class="hljs-string">'/css/custom.css'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Sat, 05 May 2018 13:10:07 GMT'</span></span>; updated[<span class="hljs-string"><span class="hljs-string">'/js/m-js.js'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Mon, 07 May 2018 11:33:56 GMT'</span></span>; updated[<span class="hljs-string"><span class="hljs-string">'/js/header.js'</span></span>] = <span class="hljs-string"><span class="hljs-string">'Mon, 07 May 2018 15:34:08 GMT'</span></span>;</code> </pre> <br>  Further, with each request by the client for a resource, if the url hits the updated array, we check with what we have in the cache. <br><br><div class="spoiler">  <b class="spoiler_title">sw.js fetch</b> <div class="spoiler_text"><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Fetching:'</span></span>, event.request); event.respondWith(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cachedResponse = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> caches.match(event.request); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cachedResponse) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Cached version found: "</span></span> + event.request.url); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(event.request.url); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updated[l.pathname] === <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> || updated[l.pathname] == cachedResponse.headers.get(<span class="hljs-string"><span class="hljs-string">"Last-Modified"</span></span>)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Returning from cache"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cachedResponse; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Updating to recent version"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> fetchAndCache(event.request); }()); });</code> </pre> <br></div></div><br>  Fifteen lines of code, and you can safely upload files to the server, and they will be updated in the client cache. <br><br>  The only remaining time - after the resource is loaded, it will be necessary to update the updated [url.pathname] new response.headers.get (‚ÄúLast-Modified‚Äù) - there is a possibility that this file has been updated once again after the last receipt of sw.php last modified time, and this file will be constantly updated upon request. <br><br><h3>  findings </h3><br>  We need to remember about the cycle of life sw.js / sw.php.  This file is subject to the rules of the standard browser caching with one exception - it lives on the client for no more than 24 hours, then the service worker will be forced to restart at the next registration.  With sw.php, we are almost guaranteed to always have the latest version. <br><br>  If you do not want to get into the generation of sw.js, you can download a list of monitored resources from Last-Modified from the server in the <i>activate</i> block - this is probably the more correct way, but at the cost of one extra request to the server.  And as in option 1, it is possible to crash into the html page code, create an ajax request with json data into the service worker, where it can be processed by initializing the updated array - this is probably the most optimal and dynamic option, it will, if you wish, update the cache resources without reinstalling the service worker. <br><br>  As a further development of this scheme, each monitored resource will not have problems adding a declarative ability to load postponed - first return to the client from the cache, then download from the network for subsequent hits. <br><br>  Another sample application is images with different sizes (srcset or software installation).  When downloading such a resource, you can search for a higher resolution image in the cache first, thereby saving the request to the server.  Or use a smaller image at the time of loading the main one. <br><br>  Premature loading is also interesting from common caching techniques: for example, it is known that additional resources will appear in the next release of the application ‚Äî a new font or a heavy picture, for example.  You can load it into the cache in advance for the load event ‚Äî when the user opens the page completely and starts reading it.  It will be unnoticed and effective. <br><br>  Finally, an example of a working sw.js (works in conjunction with the aforementioned sw.php) with several caches (including caching php-generated images) and implemented a transparent update of the cache according to the second variant. <br><br><div class="spoiler">  <b class="spoiler_title">sw.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Caches var CURRENT_CACHES = { font: 'font-cache-v1', css:'css-cache-v1', js:'js-cache-v1', icons: 'icons-cache-v1', icons_ext: 'icons_ext-cache-v1', image: 'image-cache-v1' }; self.addEventListener('install', (event) =&gt; { self.skipWaiting(); console.log('Service Worker has been installed'); }); self.addEventListener('activate', (event) =&gt; { var expectedCacheNames = Object.keys(CURRENT_CACHES).map(function(key) { return CURRENT_CACHES[key]; }); // Delete out of date cahes event.waitUntil( caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if (expectedCacheNames.indexOf(cacheName) == -1) { console.log('Deleting out of date cache:', cacheName); return caches.delete(cacheName); } }) ); }) ); console.log('Service Worker has been activated'); }); self.addEventListener('fetch', function(event) { console.log('Fetching:', event.request.url); event.respondWith(async function() { const cachedResponse = await caches.match(event.request); if (cachedResponse) { // console.log("Cached version found: " + event.request.url); var l = new URL(event.request.url); if (updated[l.pathname] === undefined || updated[l.pathname] == cachedResponse.headers.get("Last-Modified")) { // console.log("Returning from cache"); return cachedResponse; } console.log("Updating to recent version"); } return await fetchAndCache(event.request); }()); }); function fetchAndCache(url) { return fetch(url) .then(function(response) { // Check if we received a valid response if (!response.ok) { return response; // throw Error(response.statusText); } // console.log(' Response for %s from network is: %O', url.url, response); if (response.status &lt; 400 &amp;&amp; response.type === 'basic' &amp;&amp; response.headers.has('content-type')) { // debugger; var cur_cache; if (response.headers.get('content-type').indexOf("application/javascript") &gt;= 0) { cur_cache = CURRENT_CACHES.js; } else if (response.headers.get('content-type').indexOf("text/css") &gt;= 0) { cur_cache = CURRENT_CACHES.css; } else if (response.headers.get('content-type').indexOf("font") &gt;= 0) { cur_cache = CURRENT_CACHES.font; } else if (url.url.indexOf('/css/icons/') &gt;= 0) { cur_cache = CURRENT_CACHES.icons; } else if (url.url.indexOf('/misc/image.php?') &gt;= 0) { cur_cache = CURRENT_CACHES.image; } if (cur_cache) { console.log(' Caching the response to', url); return caches.open(cur_cache).then(function(cache) { cache.put(url, response.clone()); updated[(new URL(url.url)).pathname] = response.headers.get("Last-Modified"); return response; }); } } return response; }) .catch(function(error) { console.log('Request failed:', error); throw error; // You could return a custom offline 404 page here }); }</span></span></code> </pre> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/358060/">https://habr.com/ru/post/358060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358050/index.html">From January 1, 2018, in the Russian Federation it will be prohibited to use mobile messengers anonymously</a></li>
<li><a href="../358052/index.html">The Security Council of Russia and the FSB are working on an identification system for users of online games</a></li>
<li><a href="../358054/index.html">What happens if Google Global Cache is banned - in simple language</a></li>
<li><a href="../358056/index.html">Who scans the Internet. To be continued</a></li>
<li><a href="../358058/index.html">Build 2018: Translation of the key report in Russian</a></li>
<li><a href="../358064/index.html">Issue # 21: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../358066/index.html">The mountains</a></li>
<li><a href="../358068/index.html">50 announcements of Build 2018. Part 1. Hardware & Dev Tools</a></li>
<li><a href="../358072/index.html">Pension interview programmer</a></li>
<li><a href="../358076/index.html">Moving a physical server to a virtual one - how to manage in 1 day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>