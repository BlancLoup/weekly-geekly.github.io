<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithms for video processing processor TI DM368, continued ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first part of the article, we looked at the hardware blocks that make up the TI DM368 video processor, and now we are going to review our algor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithms for video processing processor TI DM368, continued ...</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/company/sigrand/blog/217317/">first part of the article,</a> we looked at the hardware blocks that make up the TI DM368 video processor, and now we are going to review our algorithms and code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a2/070/bba/7a2070bbac5e0b181810834c654f1142.png"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The entire hardware conveyor of the camera operates in streaming mode, that is, immediately after the pixel is processed by one of the blocks, it is transferred to the next one.  When turned on, the video processor software sets parameters and initializes all conveyors, then enters a continuous processing cycle of each frame.  If the frame rate of the sensor is 30 fps, then all necessary functions will be called 30 times per second. <br>  Now about the principles of the algorithms.  The essence of the algorithm AE (auto expouse - auto exposure) is to set the exposure values, multiplication factor (gain) and shift (offset) so that the output to get a picture with a minimum number of overexposed and dark areas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/894/8f0/7d4/8948f07d4e9d6e6cd1ecbcdff22fa0d9.jpg"><br><br>  The exposure or electronic shutter is responsible for the amount of light falling on the sensor.  In modern sensors, it can vary from 1,000,000 to 1 microsecond, so there is no need to use a diaphragm to limit the luminous intensity.  Gain and offset are used to convert from 12 bits to 8, and are chosen so as to maximize the use of a scant 8 bit dynamic range. <br>  How to determine the value of the exposure?  We tried several options: and limited from above, that is, changed the exposure so that the maximum value of the histogram was below a certain threshold, and lowered the lower limit of the histogram to a certain value. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/007/2e6/796/0072e67968c184110b815132eb9df6fd.jpg"><br><br>  Both the one and the other method maximally use the entire dynamic range, but they have one drawback - on a bright sunny day, objects in the shade are almost invisible.  Thus, in order to consider blackouts, it is sometimes better to re-flash some parts of the scene.  Therefore, we let the maximum of the histogram float freely and select the exposure so that the average value of Y coincides with the value we selected. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ed/d4b/944/5edd4b94416d2359bd7e1009a260228c.jpg"><br><br>  It's time to go to the algorithms, let's start with the auto exposure: <br><br>  1. The algorithm begins with the acquisition of statistics from Boxcar. <br><br><pre><code class="cpp hljs">Uint32 w, h; Uint16 *box; status = DRV_ipipeGetBoxcarBuf(&amp;bufId, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(status!= OSA_SOK) { OSA_ERROR(<span class="hljs-string"><span class="hljs-string">"ERROR: DRV_ipipeGetBoxcarBuf()\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> status; } pBufInfo = DRV_ipipeGetBoxcarBufInfo(bufId); DRV_ipipePutBoxcarBuf(bufId); box = pBufInfo-&gt;virtAddr; w = gDRV_ipipeObj.boxcarInfo.width; <span class="hljs-comment"><span class="hljs-comment">//Boxcar width h = gDRV_ipipeObj.boxcarInfo.height; // Boxcar height</span></span></code> </pre> <br><br>  2. Then, using this data, a histogram is constructed and the average value of Y is calculated. <br><br><pre> <code class="cpp hljs">Uint32 sz = w*h, sz4 = sz*<span class="hljs-number"><span class="hljs-number">4</span></span>, hsz = <span class="hljs-number"><span class="hljs-number">512</span></span>; Uint32 hist[hsz]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GN[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">-16</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(hist, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(Uint32)*hsz); <span class="hljs-comment"><span class="hljs-comment">//AE and WB for(i=0; i &lt; sz4; i+=4) { r = box[i+2]&gt;&gt;2; g = box[i+1]&gt;&gt;2; b = box[i ]&gt;&gt;2; RR += r; GG += g; BB += b; Y += ((117*b + 601*g + 306*r)&gt;&gt;10); hist[r&gt;&gt;3]++; hist[g&gt;&gt;3]++; hist[b&gt;&gt;3]++; for(j=0; j &lt; ns; j++) { GB[j] += abs(g - (b*(512 + GN[j])&gt;&gt;9)); GR[j] += abs(g - (r*(512 + GN[j])&gt;&gt;9)); } } Y = Y/sz; hn-&gt;Y.New = Y; RR = RR/sz; GG = GG/sz; BB = BB/sz;</span></span></code> </pre><br>  3. Find the minimum value of the histogram. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//Find histogram min sum = 0; for(i=0; sum &lt; hn-&gt;SatTh; i++) sum += hist[i]; hn-&gt;Hmin.New = i; //Find histogram max sum = 0; for(i=hsz-1; sum &lt; hn-&gt;SatTh; i--) sum += hist[i]; hn-&gt;Hmax.New = i;</span></span></code> </pre><br>  4. Change the exposure value.  If the value of the average value of Y is two times greater or less than our threshold YAE, then the step of change increases, and if the change of Y is less than 20%, then the exposure does not change. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hn-&gt;Y.New) tmp = (hn-&gt;Y.New &gt; hn-&gt;YAE) ? hn-&gt;Y.New*<span class="hljs-number"><span class="hljs-number">100</span></span>/hn-&gt;YAE : hn-&gt;YAE*<span class="hljs-number"><span class="hljs-number">100</span></span>/hn-&gt;Y.New; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tmp &gt; <span class="hljs-number"><span class="hljs-number">200</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hn-&gt;Y.New) hn-&gt;Exp.New = hn-&gt;Exp.Old*(hn-&gt;Y.New*<span class="hljs-number"><span class="hljs-number">2</span></span> + hn-&gt;YAE)/(hn-&gt;Y.New*<span class="hljs-number"><span class="hljs-number">3</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tmp &gt; <span class="hljs-number"><span class="hljs-number">20</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hn-&gt;Y.New &gt; hn-&gt;YAE) hn-&gt;Exp.New = hn-&gt;Exp.Old*<span class="hljs-number"><span class="hljs-number">99</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> hn-&gt;Exp.New = hn-&gt;Exp.Old*<span class="hljs-number"><span class="hljs-number">100</span></span>/<span class="hljs-number"><span class="hljs-number">99</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hn-&gt;Exp.New &gt; hn-&gt;Exp.Range.max) hn-&gt;Exp.New = hn-&gt;Exp.Range.max;</code> </pre><br>  5. To smoothly change the video streaming image, we do averaging the last few values ‚Äã‚Äãof the values ‚Äã‚Äãused in the AE algorithm: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HISTORY 30 int history = 0; typedef struct IAEWBF_Param{ XDAS_Int32 Old; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//Old value XDAS_Int32 New; //New value XDAS_Int32 Step; //The step of changing XDAS_Int32 Avrg; //Sum of all history value XDAS_Int32 Change; //Need for smooth change XDAS_Int32 Hist[HISTORY]; //History array XDAS_Int32 HistC; //History count XDAS_Int32 NewA; //Avarage of value IAEWBF_Range Range; //The range of value changes }IAEWBF_Param; int add_history(IAEWBF_Param *p) { int diff = 0; p-&gt;Avrg += p-&gt;New; p-&gt;Avrg -= p-&gt;Hist[p-&gt;HistC]; if(p-&gt;New) diff = abs(p-&gt;Hist[p-&gt;HistC] - p-&gt;New)*100/p-&gt;New; p-&gt;Hist[p-&gt;HistC] = p-&gt;New; p-&gt;HistC = (p-&gt;HistC == (HISTORY - 1)) ? 0 : p-&gt;HistC + 1; p-&gt;NewA = (history &lt; HISTORY) ? p-&gt;Avrg/history : p-&gt;Avrg/HISTORY; return diff; } history++; add_history(&amp;hn-&gt;Hmax); add_history(&amp;hn-&gt;Hmin); add_history(&amp;hn-&gt;Y);</span></span></span></span></code> </pre><br>  6. And finally, the final stage AE is the gain and shift setting.  At the output, we are guided by the fact that the average value of Y falls approximately in the middle of the output range HmaxTh.  Taking into account gamma correction and experiment, this value is hn-&gt; HmaxTh / 4. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//Change the offset and gain hn-&gt;Offset.New = hn-&gt;Hmin.NewA; if(hn-&gt;Y.NewA - hn-&gt;Offset.New) hn-&gt;GIFIF.New = ((hn-&gt;HmaxTh/4)*512)/(hn-&gt;Y.NewA - hn-&gt;Offset.New); up = hn-&gt;Hmax.NewA*hn-&gt;GIFIF.New&gt;&gt;9; if((up &lt; hn-&gt;HmaxTh) &amp;&amp; (hn-&gt;Y.NewA - hn-&gt;Offset.New)) if(hn-&gt;Y.NewA - hn-&gt;Offset.New) hn-&gt;GIFIF.New = (((hn-&gt;HmaxTh*2 - up)/4)*512)/(hn-&gt;Y.NewA - hn-&gt;Offset.New); //Check gain range hn-&gt;GIFIF.New = hn-&gt;GIFIF.New &gt; hn-&gt;GIFIF.Range.max ? hn-&gt;GIFIF.Range.max : hn-&gt;GIFIF.New; hn-&gt;GIFIF.New = hn-&gt;GIFIF.New &lt; hn-&gt;GIFIF.Range.min ? hn-&gt;GIFIF.Range.min : hn-&gt;GIFIF.New;</span></span></code> </pre><br>  Now for the <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D0%25BB%25D0%25B0%25D0%25BD%25D1%2581_%25D0%25B1%25D0%25B5%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25BE_%25D1%2586%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B0">white balance</a> (WB). <br>  There are many algorithms for setting it up; we use 2 of them in our camera. <br>  In day mode, we minimize local color deviations throughout the entire image.  Since white, black and gray have R = G = B, and white is also the brightest in the scene, its minimization makes the greatest contribution to the total energy. <br>  At night, with an open infrared filter, we use the <a href="http://en.wikipedia.org/wiki/Color_normalization">gray world</a> algorithm, that is, simply align the color averages. <br>  In the main cycle when filling the histograms, we look for the values ‚Äã‚Äãof the total deviations of the red GR [j] and blue GB [j] from the green and find the direction of movement to the minimum: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IRcutClose){ min = GR[<span class="hljs-number"><span class="hljs-number">0</span></span>]; minr = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; ns; j++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GR[j] &lt; min) { min = GR[j]; minr = j; } } min = GB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; minb = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(j=<span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; ns; j++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GB[j] &lt; min) { min = GB[j]; minb = j; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(minr != <span class="hljs-number"><span class="hljs-number">1</span></span>) hn-&gt;Rgain.New = hn-&gt;Rgain.Old + (GN[minr]*hn-&gt;Rgain.Old/<span class="hljs-number"><span class="hljs-number">512</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(minb != <span class="hljs-number"><span class="hljs-number">1</span></span>) hn-&gt;Bgain.New = hn-&gt;Bgain.Old + (GN[minb]*hn-&gt;Bgain.Old/<span class="hljs-number"><span class="hljs-number">512</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//Night AW mode if(RR) hn-&gt;Rgain.New = GG*hn-&gt;Rgain.Old/RR; if(BB) hn-&gt;Bgain.New = GG*hn-&gt;Bgain.Old/BB; }</span></span></code> </pre><br>  Different sensors have completely different color deviations, but the algorithm always works correctly during the day, an example for a SONY IMX136 sensor before and after white balance: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/874/6ca/82e/8746ca82eddb914a8ea9a2c932f065dc.jpg"><br><br>  Let us dwell on the <a href="http://www.cambridgeincolour.com/ru/tutorials/gamma-correction.htm">gamma correction</a> , it is necessary in order to even out the sensitivity of the camera and the human eye.  As a rule, the transformation function has a power dependence, but we use another, according to our subjective sensations, it reflects reality better: <br><br>  gam [i] = out * ((log (i + in * a) - log (in * a)) / (log (in + in * a) - log (in * a))); <br><br>  where in is the maximum of the input range, <br>  out - maximum output range <br>  a - curvature coefficient (in our case, 0.05 is best suited for different scenes) <br><br><img width="500" src="https://habrastorage.org/getpro/habr/post_images/387/71e/7eb/38771e7eb183b361e50d6bfc80796b1a.png"><br><br>  During system initialization, we load this curve into the LUT table and each frame passes through it.  An example of how the gamma correction image changes: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/873/643/8a9/8736438a953a097846a09215875f4ffa.jpg"><br><br>  I would also like to mention the capabilities of our cameras, which are not very often found.  First, switching to a lower frame rate while reducing the illumination, and secondly, in the night mode, when the infrared filter is removed, the camera can remain in color. <br><br>  The source code for the firmware of our cameras is available via the Git version control system at: git: //sigrand.ru/sigticam.git.  To download the source code you can use the following command: git clone git: //sigrand.ru/sigticam.git. <br>  The above algorithms are in the directory sigticam / sigticam / platform / ti_dm368 / appro2 / av_capture / framework / alg / src / aewbf_sig <br>  Live broadcast from our, and not only ours, cameras can be viewed <a href="http://www.sigrand.ru:8080/moment/">here</a> . <br>  In the next article we will look at how autofocus is implemented in our cameras. <br>  and what is the wide dynamic range of HDR or WDR. <br><br>  . </div><p>Source: <a href="https://habr.com/ru/post/220141/">https://habr.com/ru/post/220141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220127/index.html">Discover MODX</a></li>
<li><a href="../220129/index.html">Jump Start April 22: Data Center Virtualization using Windows Server 2012 R2 and System Center 2012 R2. Ensuring the security and high availability of virtual machines</a></li>
<li><a href="../220131/index.html">EditorConfig - Alone Settings for All Editors / IDE</a></li>
<li><a href="../220135/index.html">Plan-fact, dynamics and profits in one diagram with R</a></li>
<li><a href="../220137/index.html">Automate the deployment of applications in 1 click on the platform InfoboxCloud Jelastic with JPS</a></li>
<li><a href="../220147/index.html">Service goal setting. Now on Android and iOS</a></li>
<li><a href="../220149/index.html">Free plugin for IT service providers - Veeam Backup & Replication Add-on for Kaseya</a></li>
<li><a href="../220151/index.html">InfoTeX opens the door</a></li>
<li><a href="../220157/index.html">Mail.Ru Group announces the launch of a vulnerability scanner</a></li>
<li><a href="../220159/index.html">2500 Bunsen burners and sound wave imaging</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>