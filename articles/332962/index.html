<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reference TCP / IP steganography</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TCP steganography is not something fundamentally new, for example, John Torakis implemented quite interesting things on Python in 2016, it 's a pity t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reference TCP / IP steganography</h1><div class="post__text post__text-html js-mediator-article"><p>  TCP <a href="https://habrahabr.ru/post/253045/">steganography is</a> not something fundamentally new, for example, <a href="https://github.com/operatorequals">John Torakis</a> implemented <a href="https://securosophy.com/2016/09/14/teaching-an-old-dog-not-that-new-tricks-stego-in-tcpip-made-easy-part-1/">quite</a> <a href="https://securosophy.com/2016/09/19/pozzo-lucky-stego-in-tcpip-part-2/">interesting</a> <a href="https://securosophy.com/2016/09/28/pozzo-lucky-busted-the-tales-of-a-mathematician-soc-analyst/">things</a> on Python in 2016, <a href="https://securosophy.com/2016/09/19/pozzo-lucky-stego-in-tcpip-part-2/">it</a> 's a pity that not all of them are publicly available.  It was not fundamentally new at the time of writing the articles by Thorakis.  Here is a <a href="https://habrahabr.ru/post/60726/">post on Habr√© of</a> 2009, describing the idea and, for example, the <a href="">Covert_TCP</a> program of the far (and maybe not very much) 1996, written in pure C and implementing quite subtle settings. </p><br><p>  If Covert TCP proposes to transfer one byte of payload in a TCP packet, Torakis used from 2 to 6 bytes per packet and suggested the idea of ‚Äã‚Äãcreating a protocol in the protocol.  But even in this way it is difficult to transfer large amounts of data. </p><br><p>  Here the <a href="https://habrahabr.ru/post/132153/">system of one-time messages</a> can come to the rescue.  Indeed, why not combine the two approaches, since they were invented before us? </p><br><p><img src="https://habrastorage.org/web/90c/082/99d/90c08299d77844c68c52f8ea0aeec9a2.gif" alt="picture"></p><a name="habracut"></a><br><p>  So, the characters are machine 1 (sender) and machine 2 (recipient).  It is required to automate the following actions: </p><br><ol><li>  Create a message from the machine on a resource with a one-time URL and get a link (for example, <a href="https://onetimesecret.com/">One-Time Secret</a> ). </li><li>  Send link as payload in TCP / IP packet. </li><li>  Read the message from the site on machine 2 and perform some actions with it. </li></ol><br><p>  Let's start from the middle - with the introduction of the payload. </p><br><h1 id="tcpip-steganografiya">  TCP / IP Steganography </h1><br><p>  The packet into which we will inject (secret but not encrypted) bits consists of an IP header and a TCP header. </p><br><p>  IPv4 header. </p><br><pre><code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <span class="hljs-params"><span class="hljs-params">|Version|</span></span> IHL <span class="hljs-params"><span class="hljs-params">|Type of Service|</span></span> Total Length <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Identification <span class="hljs-params"><span class="hljs-params">|Flags|</span></span> Fragment Offset <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Time to Live <span class="hljs-params"><span class="hljs-params">| Protocol |</span></span> Header Checksum <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Source Address <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Destination Address <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Options <span class="hljs-params"><span class="hljs-params">| Padding |</span></span> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code> </pre> <br><p>  <a href="https://tools.ietf.org/html/rfc791">RFC 791</a> contains the following: </p><br><pre> <code class="hljs pgsql"> Identification: <span class="hljs-number"><span class="hljs-number">16</span></span> bits An identifying <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> assigned <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the sender <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> aid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assembling the fragments <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> a datagram.</code> </pre> <br><p>  The ID field is needed to collect ordered data fragments.  Those.  in the case of a single packet, this field is not used.  So for our purposes, you can already use 2 bytes.  <em>It was established experimentally that the zero field ID is automatically filled with random values, probably this is also written somewhere.</em> </p><br><p>  Consider the TCP header. </p><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <span class="hljs-params"><span class="hljs-params">| Source Port |</span></span> Destination Port <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Sequence Number <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Acknowledgment Number <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Data <span class="hljs-params"><span class="hljs-params">| |</span></span>U<span class="hljs-params"><span class="hljs-params">|A|</span></span>P<span class="hljs-params"><span class="hljs-params">|R|</span></span>S<span class="hljs-params"><span class="hljs-params">|F|</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span> Offset<span class="hljs-params"><span class="hljs-params">| Reserved |</span></span>R<span class="hljs-params"><span class="hljs-params">|C|</span></span>S<span class="hljs-params"><span class="hljs-params">|S|</span></span>Y<span class="hljs-params"><span class="hljs-params">|I|</span></span> Window <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>G<span class="hljs-params"><span class="hljs-params">|K|</span></span>H<span class="hljs-params"><span class="hljs-params">|T|</span></span>N<span class="hljs-params"><span class="hljs-params">|N|</span></span> <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> Checksum <span class="hljs-params"><span class="hljs-params">| Urgent Pointer |</span></span> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ <span class="hljs-params"><span class="hljs-params">| Options |</span></span> Padding <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |</span></span> data <span class="hljs-params"><span class="hljs-params">| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span></code> </pre> <br><p>  The Sequence Number field of the first connection packet is not fixed, because otherwise attackers might have known it ( <a href="https://tools.ietf.org/html/rfc793">RCF 793</a> ).  And this is another 4 bytes. </p><br><h2 id="realizaciya">  Implementation </h2><br><div class="spoiler">  <b class="spoiler_title">Details under the spoiler</b> <div class="spoiler_text"><p>  <em><strong>Disclaimer:</strong> Yes, global variables are ugly and ayayay, but for small test programs, it seems to me acceptable.</em> </p><br><p>  The code in this section will be pure C and is oriented to linux systems, since  they require fewer non-obvious steps to make the programs work (and no winpcap).  All programs using raw sockets should be run from under the root. </p><br><p>  <em>Thanks to <a href="http://www.binarytides.com/">binarytides.com</a> for parsed examples with <a href="http://www.binarytides.com/raw-sockets-c-code-linux/">sending packages</a> , as well as a <a href="http://www.binarytides.com/packet-sniffer-code-c-linux/">ready-made sniffer</a> .</em> </p><br><h3 id="otpravitel">  Sender </h3><br><div class="spoiler">  <b class="spoiler_title">Details under the spoiler</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; //for printf #include&lt;string.h&gt; //memset #include&lt;sys/socket.h&gt; //for socket ofcourse #include&lt;stdlib.h&gt; //for exit(0); #include&lt;errno.h&gt; //For errno - the error number #include&lt;netinet/tcp.h&gt; //Provides declarations for tcp header #include&lt;netinet/ip.h&gt; //Provides declarations for ip header #include &lt;unistd.h&gt; // 96  (12 ) -,    - struct pseudo_header { u_int32_t source_address; u_int32_t dest_address; u_int8_t placeholder; u_int8_t protocol; u_int16_t tcp_length; }; //   - unsigned short csum(unsigned short *ptr,int nbytes) { register long sum; unsigned short oddbyte; register short answer; sum=0; while(nbytes&gt;1) { sum+=*ptr++; nbytes-=2; } if(nbytes==1) { oddbyte=0; *((u_char*)&amp;oddbyte)=*(u_char*)ptr; sum+=oddbyte; } sum = (sum&gt;&gt;16)+(sum &amp; 0xffff); sum = sum + (sum&gt;&gt;16); answer=(short)~sum; return(answer); } int main (int argc, char* argv[]) { srand(time(NULL)); if (argc &lt; 3) { puts("Enter source and destination ip"); return 1; } while (1) { puts("Enter payload:"); char payload[1024]; //   fgets(payload, 1024, stdin); //    int length = strlen(payload); // -  if (length &gt; 0 &amp;&amp; payload[strlen (payload) - 1] == '\n') payload[strlen (payload) - 1] = '\0'; //      if (!length) break; //     int n = (length + 5)/6; int i; for (i = 0; i &lt; n; ++i) { //     usleep(10000); //    RAW  int s = socket (PF_INET, SOCK_RAW, IPPROTO_TCP); if(s == -1) { //     // , -   perror("Failed to create socket"); exit(1); } //    char datagram[4096] , source_ip[32] , *pseudogram; //   memset (datagram, 0, 4096); // IP  struct iphdr *iph = (struct iphdr *) datagram; //TCP  struct tcphdr *tcph = (struct tcphdr *) (datagram + sizeof (struct iphdr)); struct sockaddr_in sin; struct pseudo_header psh; //some address resolution strcpy(source_ip , argv[1]); sin.sin_family = AF_INET; sin.sin_port = htons(80); sin.sin_addr.s_addr = inet_addr (argv[2]); //  IP  //    5 iph-&gt;ihl = 5; // IPv3 iph-&gt;version = 4; //    iph-&gt;tos = 0; //     iph-&gt;tot_len = sizeof (struct iphdr) + sizeof (struct tcphdr); //     iph-&gt;id = (6*i &lt; length ? payload[6*i] &lt;&lt; 8 : 0) + (6*i + 1 &lt; length ? payload[6*i + 1] : 0); //  id == 0,     ,     //    ,    , //     if (iph-&gt;id == 0) iph-&gt;id = 1; //   =&gt;   iph-&gt;frag_off = 0; //     TTL iph-&gt;ttl = 64; //  TCP iph-&gt;protocol = IPPROTO_TCP; //     - iph-&gt;check = 0; //  IP iph-&gt;saddr = inet_addr ( source_ip ); // IP   iph-&gt;daddr = sin.sin_addr.s_addr; //   IP  iph-&gt;check = csum ((unsigned short *) datagram, iph-&gt;tot_len); //  TCP //   tcph-&gt;source = htons (20); //   tcph-&gt;dest = htons (rand() % 10000); // ""   tcph-&gt;ack_seq = 0; //     tcph-&gt;seq = 0; int j; for (j = 0; j &lt; 4; ++j) tcph-&gt;seq += (6*i + 2 + j &lt; length ? payload[6*i + 2 + j] : 0) &lt;&lt; 8*j; //     tcph-&gt;doff = 5; //     SYN tcph-&gt;fin=0; tcph-&gt;syn=1; tcph-&gt;rst=0; tcph-&gt;psh=0; tcph-&gt;ack=0; tcph-&gt;urg=0; //    tcph-&gt;window = htons (5840); // -     - tcph-&gt;check = 0; //  "" tcph-&gt;urg_ptr = 0; //     psh.source_address = inet_addr( source_ip ); psh.dest_address = sin.sin_addr.s_addr; psh.placeholder = 0; psh.protocol = IPPROTO_TCP; psh.tcp_length = 0; int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr); pseudogram = (char*)malloc(psize); memcpy(pseudogram , (char*) &amp;psh , sizeof (struct pseudo_header)); memcpy(pseudogram + sizeof(struct pseudo_header) , tcph, sizeof(struct tcphdr)); tcph-&gt;check = csum( (unsigned short*) pseudogram , psize); free(pseudogram); //IP_HDRINCL   ,      int one = 1; const int *val = &amp;one; if (setsockopt (s, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) &lt; 0) { perror("Error setting IP_HDRINCL"); exit(0); } //   if (sendto (s, datagram, iph-&gt;tot_len , 0, (struct sockaddr *) &amp;sin, sizeof (sin)) &lt; 0) { perror("sendto failed"); } //  else { //     printf ("Packet sent. \"" ); for (j = 0; j &lt; 6; ++j) if (6*i + j &lt; length) printf("%c", payload[6*i + j]); puts("\""); } } } return 0; }</span></span></span></span></code> </pre> </div></div><br><p>  For convenience of verification, we will transmit messages entered from the keyboard. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   fgets(payload, 1024, stdin); //    int length = strlen(payload);</span></span></code> </pre> <br><p>  There are 6 bytes in total, so the number of required packets is equal to the length divided by 6 and rounded down. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     int n = (length + 5)/6;</span></span></code> </pre> <br><p>  Further actions are performed n times. </p><br><p>  Creating a TCP packet in raw mode. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = socket (PF_INET, SOCK_RAW, IPPROTO_TCP);</code> </pre> <br><p>  Creating the necessary variables, filling in the fields. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    char datagram[4096] , source_ip[32] , *pseudogram; //   memset (datagram, 0, 4096); // IP  struct iphdr *iph = (struct iphdr *) datagram; //TCP  struct tcphdr *tcph = (struct tcphdr *) (datagram + sizeof (struct iphdr));</span></span></code> </pre><br><p>  Implementation of the first part of the payload (2 bytes in the ID field). </p><br><pre> <code class="cpp hljs">iph-&gt;id = (<span class="hljs-number"><span class="hljs-number">6</span></span>*i &lt; length ? payload[<span class="hljs-number"><span class="hljs-number">6</span></span>*i] &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) + (<span class="hljs-number"><span class="hljs-number">6</span></span>*i + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; length ? payload[<span class="hljs-number"><span class="hljs-number">6</span></span>*i + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Implementation of the second part of the payload (4 bytes in the Sequence Number field). </p><br><pre> <code class="cpp hljs">tcph-&gt;seq = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; ++j) tcph-&gt;seq += (<span class="hljs-number"><span class="hljs-number">6</span></span>*i + <span class="hljs-number"><span class="hljs-number">2</span></span> + j &lt; length ? payload[<span class="hljs-number"><span class="hljs-number">6</span></span>*i + <span class="hljs-number"><span class="hljs-number">2</span></span> + j] : <span class="hljs-number"><span class="hljs-number">0</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span>*j;</code> </pre><br><p>  Sending a packet and outputting its payload. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sendto (s, datagram, iph-&gt;tot_len , <span class="hljs-number"><span class="hljs-number">0</span></span>, (struct sockaddr *) &amp;<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { perror(<span class="hljs-string"><span class="hljs-string">"sendto failed"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//  else { //     printf ("Packet sent. \"" ); for (j = 0; j &lt; 6; ++j) if (6*i + j &lt; length) printf("%c", payload[6*i + j]); puts("\""); }</span></span></code> </pre><br><h3 id="poluchatel">  Recipient </h3><br><div class="spoiler">  <b class="spoiler_title">Immediately all the code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; //For standard things #include&lt;stdlib.h&gt; //malloc #include&lt;string.h&gt; //memset #include&lt;netinet/ip_icmp.h&gt; //Provides declarations for icmp header #include&lt;netinet/udp.h&gt; //Provides declarations for udp header #include&lt;netinet/tcp.h&gt; //Provides declarations for tcp header #include&lt;netinet/ip.h&gt; //Provides declarations for ip header #include&lt;sys/socket.h&gt; #include&lt;arpa/inet.h&gt; void processPacket(unsigned char*); void handleMessage(unsigned char*); int sock_raw; //     char global_buffer[1024]; //    int global_n = 0; char * src_addr, *dst_addr; int main(int argc, char* argv[]) { if (argc &lt; 3) { puts("Enter source and destination ip"); return 1; } src_addr = argv[1]; dst_addr = argv[2]; int saddr_size , data_size; struct sockaddr saddr; unsigned char *buffer = (unsigned char *)malloc(65536); //Its Big! puts("Starting..."); //  "" ,    sock_raw = socket(AF_INET , SOCK_RAW , IPPROTO_TCP); if(sock_raw &lt; 0) { printf("Socket Error\n"); return 1; } while(1) { saddr_size = sizeof saddr; //   data_size = recvfrom(sock_raw , buffer , 65536 , 0 , &amp;saddr , &amp;saddr_size); if(data_size &lt;0 ) { printf("Recvfrom error , failed to get packets\n"); return 1; } //   processPacket(buffer); } close(sock_raw); printf("Finished"); return 0; } void processPacket(unsigned char* buffer) { //    IP   struct iphdr *iph = (struct iphdr*)buffer; //   TCP  if (iph-&gt;protocol == IPPROTO_TCP) { //   handleMessage(buffer); } } void handleMessage(unsigned char *Buffer) { int i; struct iphdr *iph = (struct iphdr *)Buffer; struct tcphdr *tcph = (struct tcphdr *) (Buffer + sizeof (struct iphdr)); struct sockaddr_in source,dest; //      memset(&amp;source, 0, sizeof(source)); source.sin_addr.s_addr = iph-&gt;saddr; memset(&amp;dest, 0, sizeof(dest)); dest.sin_addr.s_addr = iph-&gt;daddr; //       if (source.sin_addr.s_addr == inet_addr(src_addr) &amp;&amp; dest.sin_addr.s_addr == inet_addr(dst_addr)) { //    setvbuf (stdout, NULL, _IONBF, 0); //     char payload[6]; //      payload[0] = iph-&gt;id &gt;&gt; 8; payload[1] = iph-&gt;id &amp; ((1 &lt;&lt; 8) - 1); //     for (i = 0; i &lt; 4; ++i) { payload[i + 2] = (tcph-&gt;seq &gt;&gt; i*8) &amp; ((1 &lt;&lt; 8 ) - 1); } //    for (i = 0; i &lt; 6; ++i) { global_buffer[global_n++] = payload[i]; } //     for (i = 0; i &lt; 6; ++i) { //    if (payload[i]) printf("%c", payload[i]); else { // 0 =&gt;   //   puts(""); //     global_n = 0; //    break; } } } }</span></span></span></span></code> </pre> </div></div><br><p>  In order not to load the code with unnecessary variable transfers, the message and its length will be controlled in global variables.  At the current stage, it is not necessary to record a message, but why not take care of its storage in advance. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     char global_buffer[1024]; //    int global_n = 0;</span></span></code> </pre> <br><p>  Create a raw socket for listening and get packets in an infinite loop, followed by a call to the packet processing function. </p><br><pre> <code class="cpp hljs">sock_raw = socket(AF_INET , SOCK_RAW , IPPROTO_TCP); <span class="hljs-comment"><span class="hljs-comment">// ... while(1) { // ... //   recvfrom(sock_raw , buffer , 65536 , 0 , &amp;saddr , &amp;saddr_size); //... //   processPacket(buffer); }</span></span></code> </pre> <br><p>  After checking that the TCP packet was received, and it is from the desired address, we extract both parts of the payload. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... char payload[6]; //      payload[0] = iph-&gt;id &gt;&gt; 8; payload[1] = iph-&gt;id &amp; ((1 &lt;&lt; 8) - 1); //     for (i = 0; i &lt; 4; ++i) payload[i + 2] = (tcph-&gt;seq &gt;&gt; i*8) &amp; ((1 &lt;&lt; 8 ) - 1); // ...</span></span></code> </pre> <br></div></div><br><h3 id="primer-raboty">  Work example </h3><br><p>  <em>(Recipient on the left, sender on the right)</em> </p><br><p><img src="https://habrastorage.org/web/607/ce6/4bb/607ce64bb48a4397a49bcf5e0a7ad4c5.png" alt="example1"></p><br><p>  The load is perfectly visible when analyzing a packet, for example, in Wireshark.  So it would be nice to introduce encryption, but for Proof Of Consept we will not do this. </p><br><p><img src="https://habrastorage.org/web/029/92c/c62/02992cc6267043078ab633e2dce67250.png" alt="example2"></p><br><p>  So, until now, we have repeated the success of Torakis from his <a href="https://securosophy.com/2016/09/14/teaching-an-old-dog-not-that-new-tricks-stego-in-tcpip-made-easy-part-1/">first article</a> , but using C, not Python.  It's time for discrepancies. </p><br><h1 id="sistema-odnorazovyh-soobscheniy">  One-time messaging system </h1><br><p>  I would like to transfer large data arrays in TCP packets, but this is inconvenient, since the steganographic data transfer rate is rather small.  However, no one bothers to leave a message in a specified place, and this place can be either a site created specifically for today's experiment, or <a href="https://www.thismessagewillselfdestruct.com/">one</a> <a href="https://onetimesecret.com/">of the</a> <a href="https://privnote.com/">existing ones</a> . </p><br><h2 id="realizaciya-1">  Implementation </h2><br><div class="spoiler">  <b class="spoiler_title">Details under the spoiler</b> <div class="spoiler_text"><p>  Here things are somewhat more complicated than last time, because you have to supplement ready-made applications by loading pages via https and parsing them.  Since  we use a specific site, "parsing" will be simplified to find the right line in the page code and extract the code from there for reference by known adjacent characters. </p><br><p>  First you need the curl library.  By default, it sends the received web page to the console, so you need to make a buffer into which we want to write the source code of the page and the callback function corresponding to the curl API that produces the same record. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> html_buffer[<span class="hljs-number"><span class="hljs-number">65530</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> writeCallback(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *contents, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nmemb, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *userp) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> realsize = size * nmemb; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(html_buffer, contents, realsize); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> realsize; }</code> </pre> <br><h3 id="otpravitel-1">  Sender </h3><br><div class="spoiler">  <b class="spoiler_title">All code at once</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; //for printf #include&lt;string.h&gt; //memset #include&lt;sys/socket.h&gt; //for socket ofcourse #include&lt;stdlib.h&gt; //for exit(0); #include&lt;errno.h&gt; //For errno - the error number #include&lt;netinet/tcp.h&gt; //Provides declarations for tcp header #include&lt;netinet/ip.h&gt; //Provides declarations for ip header #include &lt;unistd.h&gt; #include &lt;curl/curl.h&gt; // 96  (12 ) -,    - struct pseudo_header { u_int32_t source_address; u_int32_t dest_address; u_int8_t placeholder; u_int8_t protocol; u_int16_t tcp_length; }; unsigned short csum(unsigned short *ptr,int nbytes); size_t writeCallback(void *contents, size_t size, size_t nmemb, void *userp); char * findMessage(); const char post_parameter[] = "message%5Bbody%5D="; char html_buffer[65530]; int main (int argc, char* argv[]) { srand(time(NULL)); if (argc &lt; 3) { puts("Enter source and destination ip"); return 1; } while (1) { puts("Enter payload:"); // ,   POST-   char post[65530]; memset(post, 0, sizeof(post)); memcpy(post, post_parameter, sizeof(post_parameter)*sizeof(char)); //       fgets(post + sizeof(post_parameter) - 1, sizeof(post) - sizeof(post_parameter), stdin); // -  post[strlen (post) - 1] = '\0'; puts(post); //  curl CURL *curl; CURLcode res; //  xurl curl_global_init(CURL_GLOBAL_DEFAULT); curl = curl_easy_init(); if(curl) { //     curl_easy_setopt(curl, CURLOPT_URL, "https://tmwsd.ws/messages"); //   "test" curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post); //   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); //     curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback); //   res = curl_easy_perform(curl); // /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res)); /* always cleanup */ curl_easy_cleanup(curl); } curl_global_cleanup(); char *link = findMessage(); puts("Link:"); puts(link); //    int length = strlen(link); // -  //      if (!length) break; //     int n = (length + 5)/6; int i; for (i = 0; i &lt; n; ++i) { //     usleep(10000); //    RAW  // AF_INTER == PF_INER - IP v4 int s = socket (PF_INET, SOCK_RAW, IPPROTO_TCP); if(s == -1) { //     // , -   perror("Failed to create socket"); exit(1); } //    char datagram[4096] , source_ip[32] , *pseudogram; //   memset (datagram, 0, 4096); // IP  struct iphdr *iph = (struct iphdr *) datagram; //TCP  struct tcphdr *tcph = (struct tcphdr *) (datagram + sizeof (struct iphdr)); struct sockaddr_in sin; struct pseudo_header psh; //some address resolution strcpy(source_ip , argv[1]); sin.sin_family = AF_INET; sin.sin_port = htons(80); sin.sin_addr.s_addr = inet_addr (argv[2]); //  IP  //    5 iph-&gt;ihl = 5; // IPv3 iph-&gt;version = 4; //    iph-&gt;tos = 0; //     iph-&gt;tot_len = sizeof (struct iphdr) + sizeof (struct tcphdr); //     iph-&gt;id = (6*i &lt; length ? link[6*i] &lt;&lt; 8 : 0) + (6*i + 1 &lt; length ? link[6*i + 1] : 0); //  id == 0,      //    ,    , //     if (iph-&gt;id == 0) iph-&gt;id = 1; //   =&gt;   iph-&gt;frag_off = 0; //     TTL iph-&gt;ttl = 64; //  TCP iph-&gt;protocol = IPPROTO_TCP; //     - iph-&gt;check = 0; //  IP iph-&gt;saddr = inet_addr ( source_ip ); // IP   iph-&gt;daddr = sin.sin_addr.s_addr; //   IP  iph-&gt;check = csum ((unsigned short *) datagram, iph-&gt;tot_len); //  TCP //   tcph-&gt;source = htons (20); //   tcph-&gt;dest = htons (rand() % 10000); // ""   tcph-&gt;ack_seq = 0; //     tcph-&gt;seq = 0; int j; for (j = 0; j &lt; 4; ++j) tcph-&gt;seq += (6*i + 2 + j &lt; length ? link[6*i + 2 + j] : 0) &lt;&lt; 8*j; //     tcph-&gt;doff = 5; //     SYN tcph-&gt;fin=0; tcph-&gt;syn=1; tcph-&gt;rst=0; tcph-&gt;psh=0; tcph-&gt;ack=0; tcph-&gt;urg=0; //    tcph-&gt;window = htons (5840); // -     - tcph-&gt;check = 0; //  "" tcph-&gt;urg_ptr = 0; //     psh.source_address = inet_addr( source_ip ); psh.dest_address = sin.sin_addr.s_addr; psh.placeholder = 0; psh.protocol = IPPROTO_TCP; psh.tcp_length = 0; int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr); pseudogram = (char*)malloc(psize); memcpy(pseudogram , (char*) &amp;psh , sizeof (struct pseudo_header)); memcpy(pseudogram + sizeof(struct pseudo_header) , tcph, sizeof(struct tcphdr)); tcph-&gt;check = csum( (unsigned short*) pseudogram , psize); free(pseudogram); //IP_HDRINCL   ,      int one = 1; const int *val = &amp;one; if (setsockopt (s, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) &lt; 0) { perror("Error setting IP_HDRINCL"); exit(0); } //   if (sendto (s, datagram, iph-&gt;tot_len , 0, (struct sockaddr *) &amp;sin, sizeof (sin)) &lt; 0) { perror("sendto failed"); } //  else { //     printf ("Packet sent. \"" ); for (j = 0; j &lt; 6; ++j) if (6*i + j &lt; length) printf("%c", link[6*i + j]); puts("\""); } } free(link); } return 0; } //   - unsigned short csum(unsigned short *ptr,int nbytes) { register long sum; unsigned short oddbyte; register short answer; sum=0; while(nbytes&gt;1) { sum+=*ptr++; nbytes-=2; } if(nbytes==1) { oddbyte=0; *((u_char*)&amp;oddbyte)=*(u_char*)ptr; sum+=oddbyte; } sum = (sum&gt;&gt;16)+(sum &amp; 0xffff); sum = sum + (sum&gt;&gt;16); answer=(short)~sum; return(answer); } size_t writeCallback(void *contents, size_t size, size_t nmemb, void *userp) { size_t realsize = size * nmemb; memcpy(html_buffer, contents, realsize); return realsize; } char * findMessage() { //  75-  size_t i, j = 0; for (i = 0; i &lt; 74; ++i) { while (html_buffer[j++] != '\n'); } while (html_buffer[j++] != 'w'); int first, last; first = j+2; while (html_buffer[++j] != '&lt;'); last = j; char * link = malloc(sizeof(char)*(last - first + 1)); memset(link, 0, last - first + 1); memcpy(link, html_buffer + first, last - first); return link; }</span></span></span></span></code> </pre> </div></div><br><p>  To create a message, you need to send to <a href="https://tmwsd.ws/messages">https://tmwsd.ws/messages</a> (or any other of their domain names) a POST request with at least the <code>message[body]</code> variable specified, which will be our message.  As a result, the site will redirect to the page containing the one-link link. </p><br><p>  <em>An example of a page with a link.</em> </p><br><p><img src="https://habrastorage.org/web/20b/ba7/2d4/20bba72d48234b7c91d6bfc9dc5d7dd9.png" alt="example3"></p><br><div class="spoiler">  <b class="spoiler_title">What will happen after clicking on the link tmwsd.ws/4Gn30zLh</b> <div class="spoiler_text"><p>  We see the left message "test" and a warning that the message will be deleted. </p><br><p><img src="https://habrastorage.org/web/231/c34/ac8/231c34ac86f9464da1cd01d21546062b.png" alt="example4"></p><br><p>  If you try your luck again and follow the same link, you will not be able to see the message. </p><br><p><img src="https://habrastorage.org/web/e2c/034/8f9/e2c0348f9f1e4d7ea82b68d212173646.png" alt="example5"></p></div></div><br><p>  From the whole page, we are only interested in the address, i.e.  in this case, <code>https://‚å´.ws/4Gn30zLh</code> , and since  the domain name is agreed in advance; only the <code>4Gn30zLh</code> set is <code>4Gn30zLh</code> .  In the source code of the page, it lies on line 75 in this form: </p><br><p> <code>&lt;span id="message_url_366056"&gt;https://‚å´.ws/4Gn30zLh&lt;/span&gt;</code> </p> <br><p>  And the number 366056 is not fixed.  So, you can first go to the 75th line, then go to the 'w' symbol, and starting from the offset from it by 2 to the right to the next angle bracket, get the message </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findLink</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  74  size_t i, j = 0; for (i = 0; i &lt; 74; ++i) { while (html_buffer[j++] != '\n'); } while (html_buffer[j++] != 'w'); int first, last; first = j+2; while (html_buffer[++j] != '&lt;'); last = j; char * msg = malloc(sizeof(char)*(last-first)); for (i = first; i &lt; last; ++i) msg[i - first] = html_buffer[i]; return msg; }</span></span></code> </pre> <br><p><del>  The author does not understand the web </del>  What if you try to break the algorithm by sending the <code>&lt;</code> character?  Nothing will happen, in the page source it will be in the form of html code <code>&amp;lt;</code>  . </p><br><h4 id="proverka-svyazi">  Connection check </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  curl CURL *curl; CURLcode res; //  curl curl_global_init(CURL_GLOBAL_DEFAULT); curl = curl_easy_init(); if(curl) { //     curl_easy_setopt(curl, CURLOPT_URL, "https://tmwsd.ws/messages"); //   "test" curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "message%5Bbody%5D=test"); //   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); //     curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback); //   res = curl_easy_perform(curl);</span></span></code> </pre> <br><p>  After parsing we get the work address. </p><br><p><img src="https://habrastorage.org/web/24b/0af/64a/24b0af64a60d481e88735237b8e8ac3e.png" alt="example6"></p><br><p>  It will be necessary to transmit it in TCP packets. </p><br><h4 id="sobirem-voedino">  Putting it together </h4><br><p>  To begin with, we will assign a variable to the constant part of the POST request. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> post_parameter[] = <span class="hljs-string"><span class="hljs-string">"message%5Bbody%5D="</span></span>;</code> </pre> <br><p>  The constant part is copied to the array containing the POST request, and then the message is read with offset. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> post[<span class="hljs-number"><span class="hljs-number">65530</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(post, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(post)); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(post, post_parameter, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(post_parameter)*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//       fgets(post + sizeof(post_parameter) - 1, sizeof(post) - sizeof(post_parameter), stdin);</span></span></code> </pre> <br><p>  Next, the already known manipulations with curl and TCP packets are performed. </p><br><p>  As a result, we can send any message using two packets. </p><br><p><img src="https://habrastorage.org/web/523/61c/01a/52361c01aa8f4f25a5d14ca32981113d.png" alt="example7"></p><br><p>  We check the message on the link. </p><br><p><img src="https://habrastorage.org/web/1b7/4fd/d81/1b74fdd8172d44cfa12a5c71962616ea.png" alt="example8"></p><br><p>  It remains to learn how to receive messages! </p><br><h3 id="poluchatel-1">  Recipient </h3><br><p>  We are able to extract the load, we are able to load the html, and the message is on the 31st line. </p><br><p><img src="https://habrastorage.org/web/fe8/807/9f6/fe88079f6fa8417ba30257d18b520c1e.png" alt="example9"></p><br><h4 id="snova-sobiraem">  Again collect </h4><br><p>  All the nuances of a similar implementation were dismantled.  In order not to read the same thing once again, I suggest that those wishing to familiarize themselves with the code, and the rest go to the "check connection". </p><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; //for printf #include&lt;string.h&gt; //memset #include&lt;sys/socket.h&gt; //for socket ofcourse #include&lt;stdlib.h&gt; //for exit(0); #include&lt;errno.h&gt; //For errno - the error number #include&lt;netinet/tcp.h&gt; //Provides declarations for tcp header #include&lt;netinet/ip.h&gt; //Provides declarations for ip header #include &lt;unistd.h&gt; #include &lt;curl/curl.h&gt; // 96  (12 ) -,    - struct pseudo_header { u_int32_t source_address; u_int32_t dest_address; u_int8_t placeholder; u_int8_t protocol; u_int16_t tcp_length; }; unsigned short csum(unsigned short *ptr,int nbytes); size_t writeCallback(void *contents, size_t size, size_t nmemb, void *userp); char * findMessage(); const char post_parameter[] = "message%5Bbody%5D="; char html_buffer[65530]; int main (int argc, char* argv[]) { srand(time(NULL)); if (argc &lt; 3) { puts("Enter source and destination ip"); return 1; } while (1) { puts("Enter payload:"); // ,   POST-   char post[65530]; memset(post, 0, sizeof(post)); memcpy(post, post_parameter, sizeof(post_parameter)*sizeof(char)); //       fgets(post + sizeof(post_parameter) - 1, sizeof(post) - sizeof(post_parameter), stdin); // -  post[strlen (post) - 1] = '\0'; puts(post); //  curl CURL *curl; CURLcode res; //  xurl curl_global_init(CURL_GLOBAL_DEFAULT); curl = curl_easy_init(); if(curl) { //     curl_easy_setopt(curl, CURLOPT_URL, "https://tmwsd.ws/messages"); //   "test" curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post); //   curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); //     curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback); //   res = curl_easy_perform(curl); // /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res)); /* always cleanup */ curl_easy_cleanup(curl); } curl_global_cleanup(); char *link = findMessage(); puts("Link:"); puts(link); //    int length = strlen(link); // -  //      if (!length) break; //     int n = (length + 5)/6; int i; for (i = 0; i &lt; n; ++i) { //     usleep(10000); //    RAW  // AF_INTER == PF_INER - IP v4 int s = socket (PF_INET, SOCK_RAW, IPPROTO_TCP); if(s == -1) { //     // , -   perror("Failed to create socket"); exit(1); } //    char datagram[4096] , source_ip[32] , *pseudogram; //   memset (datagram, 0, 4096); // IP  struct iphdr *iph = (struct iphdr *) datagram; //TCP  struct tcphdr *tcph = (struct tcphdr *) (datagram + sizeof (struct iphdr)); struct sockaddr_in sin; struct pseudo_header psh; //some address resolution strcpy(source_ip , argv[1]); sin.sin_family = AF_INET; sin.sin_port = htons(80); sin.sin_addr.s_addr = inet_addr (argv[2]); //  IP  //    5 iph-&gt;ihl = 5; // IPv3 iph-&gt;version = 4; //    iph-&gt;tos = 0; //     iph-&gt;tot_len = sizeof (struct iphdr) + sizeof (struct tcphdr); //     iph-&gt;id = (6*i &lt; length ? link[6*i] &lt;&lt; 8 : 0) + (6*i + 1 &lt; length ? link[6*i + 1] : 0); //  id == 0,      //    ,    , //     if (iph-&gt;id == 0) iph-&gt;id = 1; //   =&gt;   iph-&gt;frag_off = 0; //     TTL iph-&gt;ttl = 64; //  TCP iph-&gt;protocol = IPPROTO_TCP; //     - iph-&gt;check = 0; //  IP iph-&gt;saddr = inet_addr ( source_ip ); // IP   iph-&gt;daddr = sin.sin_addr.s_addr; //   IP  iph-&gt;check = csum ((unsigned short *) datagram, iph-&gt;tot_len); //  TCP //   tcph-&gt;source = htons (20); //   tcph-&gt;dest = htons (rand() % 10000); // ""   tcph-&gt;ack_seq = 0; //     tcph-&gt;seq = 0; int j; for (j = 0; j &lt; 4; ++j) tcph-&gt;seq += (6*i + 2 + j &lt; length ? link[6*i + 2 + j] : 0) &lt;&lt; 8*j; //     tcph-&gt;doff = 5; //     SYN tcph-&gt;fin=0; tcph-&gt;syn=1; tcph-&gt;rst=0; tcph-&gt;psh=0; tcph-&gt;ack=0; tcph-&gt;urg=0; //    tcph-&gt;window = htons (5840); // -     - tcph-&gt;check = 0; //  "" tcph-&gt;urg_ptr = 0; //     psh.source_address = inet_addr( source_ip ); psh.dest_address = sin.sin_addr.s_addr; psh.placeholder = 0; psh.protocol = IPPROTO_TCP; psh.tcp_length = 0; int psize = sizeof(struct pseudo_header) + sizeof(struct tcphdr); pseudogram = (char*)malloc(psize); memcpy(pseudogram , (char*) &amp;psh , sizeof (struct pseudo_header)); memcpy(pseudogram + sizeof(struct pseudo_header) , tcph, sizeof(struct tcphdr)); tcph-&gt;check = csum( (unsigned short*) pseudogram , psize); free(pseudogram); //IP_HDRINCL   ,      int one = 1; const int *val = &amp;one; if (setsockopt (s, IPPROTO_IP, IP_HDRINCL, val, sizeof (one)) &lt; 0) { perror("Error setting IP_HDRINCL"); exit(0); } //   if (sendto (s, datagram, iph-&gt;tot_len , 0, (struct sockaddr *) &amp;sin, sizeof (sin)) &lt; 0) { perror("sendto failed"); } //  else { //     printf ("Packet sent. \"" ); for (j = 0; j &lt; 6; ++j) if (6*i + j &lt; length) printf("%c", link[6*i + j]); puts("\""); } } free(link); } return 0; } //   - unsigned short csum(unsigned short *ptr,int nbytes) { register long sum; unsigned short oddbyte; register short answer; sum=0; while(nbytes&gt;1) { sum+=*ptr++; nbytes-=2; } if(nbytes==1) { oddbyte=0; *((u_char*)&amp;oddbyte)=*(u_char*)ptr; sum+=oddbyte; } sum = (sum&gt;&gt;16)+(sum &amp; 0xffff); sum = sum + (sum&gt;&gt;16); answer=(short)~sum; return(answer); } size_t writeCallback(void *contents, size_t size, size_t nmemb, void *userp) { size_t realsize = size * nmemb; memcpy(html_buffer, contents, realsize); return realsize; } char * findMessage() { //  75-  size_t i, j = 0; for (i = 0; i &lt; 74; ++i) { while (html_buffer[j++] != '\n'); } while (html_buffer[j++] != 'w'); int first, last; first = j+2; while (html_buffer[++j] != '&lt;'); last = j; char * link = malloc(sizeof(char)*(last - first + 1)); memset(link, 0, last - first + 1); memcpy(link, html_buffer + first, last - first); return link; }</span></span></span></span></code> </pre> </div></div></div></div><br><h4 id="finalnaya-proverka-svyazi">    </h4><br><p><img src="https://habrastorage.org/web/6a1/68a/c38/6a168ac385d64518bffe65fb1c02f417.png" alt="example10"></p><br><p> ,  ,    ,    ,         . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Rol7MfyOtek" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  ,   ,    ( <a href="https://drive.google.com/drive/folders/0B8hGB0dDldqKbWpkdExJbmVfS2s%3Fusp%3Dsharing"> </a> , <a href="https://yadi.sk/d/Hu2k_znl3L2JxS"></a> ). </p><br><h1 id="itogi">  Results </h1><br><ul><li> <em> ,         .</em> </li><li>       (         ),             ,    . </li><li> ,   ,   ,   ,     (,      ,  <a href="https://securosophy.com/2016/09/19/pozzo-lucky-stego-in-tcpip-part-2/"></a> ). </li></ul><br><p> <strong>  <a href="https://habrahabr.ru/users/pavelmstu/" class="user_link">PavelMSTU</a>    .</strong> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332962/">https://habr.com/ru/post/332962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332952/index.html">Show me a business problem and I will try to avoid it.</a></li>
<li><a href="../332954/index.html">Notifications of missed calls from Asterisk to Bitrix24</a></li>
<li><a href="../332956/index.html">Red, white, blue: eight rules for choosing a color palette that everyone should know</a></li>
<li><a href="../332958/index.html">35 tips for those attending a technical conference</a></li>
<li><a href="../332960/index.html">"Do you want to do well, do it yourself" or as I do my survival on Unity 3D and C #</a></li>
<li><a href="../332966/index.html">Historical essay on the great mathematician Karl Friedrich Gauss</a></li>
<li><a href="../332968/index.html">Google Developer Days Comes to Europe</a></li>
<li><a href="../332970/index.html">OAuth Authorization for Xamarin Applications</a></li>
<li><a href="../332974/index.html">Import () from the webpack will soon master JS + CSS, but how you can use it now</a></li>
<li><a href="../332976/index.html">Released the first drive on 64-layer 3D TLC NAND from Intel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>