<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive JavaScript: Regular Expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive JavaScript: Regular Expressions</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>Some people, faced with a problem, think: "Oh, and I use regular expressions."</i>  <i>Now they have two problems.</i> <i><br></i>  <i>Jamie Zavinsky</i> <i><br><br></i>  <i>Yuan-Ma said: ‚ÄúIt takes a lot of power to cut wood across the wood structure.</i>  <i>It takes a lot of code to program across the problem structure.</i> <i><br></i>  <i>Master Yuan-Ma, "Programming Book"</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Programming tools and techniques survive and spread in a chaotic evolutionary way.  Sometimes not beautiful and ingenious ones survive, but simply those who work quite well in their field - for example, if they are integrated into another successful technology. <br><br>  In this chapter, we will discuss this tool - regular expressions.  This is a way to describe patterns in string data.  They create a small separate language that is included in JavaScript and in many other languages ‚Äã‚Äãand tools. <br><br>  Regulars are both very strange and extremely useful.  Their syntax is mysterious, and the program interface in JavaScript is awkward for them.  But it is a powerful tool for researching and processing strings.  Having dealt with them, you will become a more effective programmer. <br><a name="habracut"></a><br><h4>  Create a regular expression </h4><br>  Regular - the type of object.  It can be created by calling the RegExp constructor, or by writing the desired template, surrounded by slashes. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> re1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">"abc"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> re2 = <span class="hljs-regexp"><span class="hljs-regexp">/abc/</span></span>;</code> </pre> <br><br>  Both of these regular expressions represent one pattern: the character ‚Äúa‚Äù followed by the character ‚Äúb‚Äù followed by the character ‚Äúc‚Äù. <br><br>  If you use the RegExp constructor, then the pattern is written as a regular string, so all the rules regarding backslashes apply. <br><br>  The second entry, where the template is between slashes, handles backslashes differently.  First, since the pattern ends with a forward slash, you need to put a backslash in front of the forward slash, which we want to include in our pattern.  In addition, backslashes that are not part of special characters like \ n will be saved (and not ignored, as in strings), and will change the meaning of the pattern.  Some characters, such as a question mark or plus sign, have a special meaning in regulars, and if you need to find such a character, it must also be preceded by a backslash. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eighteenPlus = <span class="hljs-regexp"><span class="hljs-regexp">/eighteen\+/</span></span>;</code> </pre><br><br>  To know which characters you need to precede with a slash, you need to learn the list of all the special characters in the regulars.  While this is unrealistic, so if in doubt, just put a backslash in front of any character that is not a letter, number or space. <br><br><h4>  Check for matches </h4><br>  Regularists have several methods.  The simplest is test.  If you pass it a string, it returns a Boolean value, telling whether the string contains an occurrence of the specified pattern. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/abc/</span></span>.test(<span class="hljs-string"><span class="hljs-string">"abcde"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(/abc/.test("abxde")); // ‚Üí false</span></span></code> </pre><br><br>  Regular, consisting only of non-special characters, simply represents a sequence of these characters.  If abc is somewhere in the string that we are checking (not only at the beginning), test returns true. <br><br><h4>  We are looking for a set of characters </h4><br>  It would be possible to find out whether the string contains abc, using indexOf.  Regulars allow you to go further and create more complex patterns. <br><br>  Suppose we need to find any number.  When we put a set of characters in square brackets in the regular box, this means that this part of the expression matches any of the characters in the brackets. <br><br>  Both expressions are in the lines containing the number. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/[0123456789]/</span></span>.test(<span class="hljs-string"><span class="hljs-string">"in 1992"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(/[0-9]/.test("in 1992")); // ‚Üí true</span></span></code> </pre><br><br>  In square brackets, a dash between two characters is used to specify a range of characters, where the sequence is specified in Unicode.  Characters from 0 to 9 are there just in a row (codes from 48 to 57), so [0-9] captures them all and matches any digit. <br><br>  Several groups of characters have their own inline abbreviations. <br><br>  \ d Any number <br>  \ w Alphanumeric character <br>  \ s Space character (space, tab, newline, etc.) <br>  \ D is not a digit <br>  \ W is not an alphanumeric character <br>  \ S is not white space <br>  .  any character except newline <br><br>  Thus, you can set the date and time format like 30-01-2003 15:20 with the following expression: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dateTime = <span class="hljs-regexp"><span class="hljs-regexp">/\d\d-\d\d-\d\d\d\d \d\d:\d\d/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dateTime.test(<span class="hljs-string"><span class="hljs-string">"30-01-2003 15:20"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(dateTime.test("30-jan-2003 15:20")); // ‚Üí false</span></span></code> </pre><br><br>  It looks awful, right?  Too many backslashes that make it difficult to understand the pattern.  Later we will slightly improve it. <br><br>  Backslashes can also be used in square brackets.  For example, [\ d.] Means any number or point.  Notice that the point inside the square brackets loses its special meaning and turns into just a point.  The same applies to other special characters, such as +. <br><br>  You can invert the character set ‚Äî that is, say that you need to find any character except those in the set ‚Äî by putting a ^ immediately after the opening square bracket. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notBinary = <span class="hljs-regexp"><span class="hljs-regexp">/[^01]/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(notBinary.test(<span class="hljs-string"><span class="hljs-string">"1100100010100110"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí false console.log(notBinary.test("1100100010200110")); // ‚Üí true</span></span></code> </pre><br><br><h4>  Repeat parts of the pattern </h4><br>  We know how to find one digit.  And if we need to find a whole number - a sequence of one or more digits? <br><br>  If you put a + sign after something in a regular schedule, it will mean that this element can be repeated more than once.  / \ d + / means one or more numbers. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/'\d+'/</span></span>.test(<span class="hljs-string"><span class="hljs-string">"'123'"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(/'\d+'/.test("''")); // ‚Üí false console.log(/'\d*'/.test("'123'")); // ‚Üí true console.log(/'\d*'/.test("''")); // ‚Üí true</span></span></code> </pre><br><br>  The asterisk * value is almost the same, but it allows the pattern to be present zero times.  If there is an asterisk after something, then it never prevents the template from being in a line ‚Äî it is simply there zero times. <br><br>  The question mark makes part of the pattern optional, that is, it may occur zero or once.  In the following example, the u character may occur, but the pattern is the same when it does not exist. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbor = <span class="hljs-regexp"><span class="hljs-regexp">/neighbou?r/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(neighbor.test(<span class="hljs-string"><span class="hljs-string">"neighbour"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(neighbor.test("neighbor")); // ‚Üí true</span></span></code> </pre><br><br>  To specify the exact number of times the pattern should occur, use curly braces.  {4} after the element means that it must occur 4 times in a row.  You can also specify the interval: {2,4} means that the element must occur at least 2 and not more than 4 times. <br><br>  Another version of the date and time format, where days, months and hours are allowed in one or two digits.  And it is a bit more readable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dateTime = <span class="hljs-regexp"><span class="hljs-regexp">/\d{1,2}-\d{1,2}-\d{4} \d{1,2}:\d{2}/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(dateTime.test(<span class="hljs-string"><span class="hljs-string">"30-1-2003 8:45"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true</span></span></code> </pre><br><br>  You can use open-end gaps by omitting one of the numbers.  {, 5} means that the pattern can occur from zero to five times, and {5,} - from five or more. <br><br><h4>  Grouping subexpressions </h4><br>  To use the * or + operators on several elements at once, you can use parentheses.  The part of the regulars in parentheses is considered one element from the point of view of operators. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cartoonCrying = <span class="hljs-regexp"><span class="hljs-regexp">/boo+(hoo+)+/i</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(cartoonCrying.test(<span class="hljs-string"><span class="hljs-string">"Boohoooohoohooo"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true</span></span></code> </pre><br><br>  The first and second pluses refer only to the second letters o in the words boo and hoo.  The third + refers to the whole group (hoo +), finding one or more of these sequences. <br><br>  The letter i at the end of the expression makes the regularity case-insensitive, so that B coincides with b. <br><br><h4>  Matches and groups </h4><br>  The test method is the easiest method for checking regulars.  He only reports whether a match was found or not.  Regulars have another exec method that returns null if nothing was found, and otherwise returns an object with information about a match. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match = <span class="hljs-regexp"><span class="hljs-regexp">/\d+/</span></span>.exec(<span class="hljs-string"><span class="hljs-string">"one two 100"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(match); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["100"] console.log(match.index); // ‚Üí 8</span></span></code> </pre><br><br>  The returned exec object has an index property, which contains the number of the character from which the match occurred.  In general, an object looks like an array of strings, where the first element is a string that was checked for a match.  In our example, this will be the sequence of numbers we were looking for. <br><br>  Strings have a match method that works much the same way. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"one two 100"</span></span>.match(<span class="hljs-regexp"><span class="hljs-regexp">/\d+/</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["100"]</span></span></code> </pre><br><br>  When the regular expression contains subexpressions grouped by parentheses, the text that matches these groups will also appear in the array.  The first element is always a complete match.  The second is the part that matched the first group (the one who had the parentheses met before everyone else), then the second group, and so on. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> quotedText = <span class="hljs-regexp"><span class="hljs-regexp">/'([^']*)'/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(quotedText.exec(<span class="hljs-string"><span class="hljs-string">"she said 'hello'"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["'hello'", "hello"]</span></span></code> </pre><br><br>  When a group is not found at all (for example, if there is a question mark behind it), its position in the array contains undefined.  If the group has matched several times, then only the last match will be in the array. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/bad(ly)?/</span></span>.exec(<span class="hljs-string"><span class="hljs-string">"bad"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["bad", undefined] console.log(/(\d)+/.exec("123")); // ‚Üí ["123", "3"]</span></span></code> </pre><br><br>  Groups are useful for extracting parts of strings.  If we do not just need to check if there is a date in the string, but extract it and create a date representing object, we can enclose the sequence of numbers in parentheses and select the date from the exec result. <br><br>  But first, a small digression, in which we will learn the preferred way to store date and time in JavaScript. <br><br><h4>  Date type </h4><br>  JavaScript has a standard object type for dates - or rather, moments in time.  It is called Date.  If you simply create a date object with new, you will get the current date and time. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí Sun Nov 09 2014 00:07:57 GMT+0300 (CET)</span></span></code> </pre><br><br>  You can also create an object that contains the specified time. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2015</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí Wed Oct 21 2015 00:00:00 GMT+0300 (CET) console.log(new Date(2009, 11, 9, 12, 59, 59, 999)); // ‚Üí Wed Dec 09 2009 12:59:59 GMT+0300 (CET)</span></span></code> </pre><br><br>  JavaScript uses a convention in which the month numbers start from zero, and the day numbers start from one.  This is stupid and ridiculous.  Watch out. <br><br>  The last four arguments (hours, minutes, seconds and milliseconds) are optional, and in the case of absence are equated to zero. <br><br>  Time stamps are stored as the number of milliseconds that have elapsed since the beginning of 1970.  Negative numbers are used for time before 1970 (this is due to the Unix time agreement that was created around that time).  The date object's getTime method returns this number.  It is naturally large. <br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-number"><span class="hljs-number">2013</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>).getTime()); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1387407600000 console.log(new Date(1387407600000)); // ‚Üí Thu Dec 19 2013 00:00:00 GMT+0100 (CET)</span></span></code> </pre><br><br>  If you give the Date constructor one argument, it is taken as this number of milliseconds.  You can get the current millisecond value by creating a Date object and calling the getTime method, or by calling the Date.now function. <br><br>  The Date object for retrieving its components has methods getFullYear, getMonth, getDate, getHours, getMinutes, and getSeconds.  There is also a getYear method that returns a rather useless two-digit code, such as 93 or 14. <br><br>  Having enclosed the necessary parts of the template in parentheses, we can create a date object directly from a string. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findDate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dateTime = <span class="hljs-regexp"><span class="hljs-regexp">/(\d{1,2})-(\d{1,2})-(\d{4})/</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match = dateTime.exec(string); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(match[<span class="hljs-number"><span class="hljs-number">3</span></span>]), <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(match[<span class="hljs-number"><span class="hljs-number">2</span></span>]) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(match[<span class="hljs-number"><span class="hljs-number">1</span></span>])); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(findDate(<span class="hljs-string"><span class="hljs-string">"30-1-2003"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí Thu Jan 30 2003 00:00:00 GMT+0100 (CET)</span></span></code> </pre><br><br><h4>  Word boundaries and lines </h4><br>  Unfortunately, findDate will also happily extract the meaningless date 00-1-3000 from the string "100-1-30000".  The match can happen anywhere on the line, so in this case it will simply start from the second character and end on the penultimate. <br><br>  If we need to force a match to take the entire string as a whole, we use the ^ and $ labels.  ^ coincides with the beginning of the line, and $ with the end.  Therefore, / ^ \ d + $ / coincides with a string consisting of only one or several digits, / ^! / Coincides with a line beginning with an exclamation mark, and / x ^ / does not match any line (there can be no x). <br><br>  If, on the other hand, we just need to make sure that the date begins and ends at the word boundary, we use the label \ b.  The word boundary can be the beginning or end of a line, or any place in a line where, on the one hand, there is an alphanumeric \ w character, and on the other, not an alphanumeric character. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-regexp"><span class="hljs-regexp">/cat/</span></span>.test(<span class="hljs-string"><span class="hljs-string">"concatenate"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(/\bcat\b/.test("concatenate")); // ‚Üí false</span></span></code> </pre><br><br>  Note that the border label is not a character.  This is just a limitation, meaning that a match occurs only if a certain condition is met. <br><br><h4>  Templates with a choice </h4><br>  Suppose you need to find out whether the text contains not just a number, but a number, followed by pig, cow, or chicken in the singular or plural form. <br><br>  One could write three regulars and check them one by one, but there is a better way.  Symbol |  indicates the choice between the patterns to the left and to the right of it.  And you can say the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animalCount = <span class="hljs-regexp"><span class="hljs-regexp">/\b\d+ (pig|cow|chicken)s?\b/</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(animalCount.test(<span class="hljs-string"><span class="hljs-string">"15 pigs"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true console.log(animalCount.test("15 pigchickens")); // ‚Üí false</span></span></code> </pre><br><br>  The brackets limit the portion of the pattern to which | is applied, and many such operators can be put one after another to indicate a choice of more than two options. <br><br><h4>  Search mechanism </h4><br>  Regular expressions can be thought of as flowcharts.  The following chart describes the latest livestock example. <br><br><img src="https://habrastorage.org/files/0fd/f0d/6a4/0fdf0d6a44d541828651c8a2d5f13e07.PNG"><br><br>  The expression matches the string if you can find the path from the left side of the diagram to the right.  We remember the current position in the line, and each time we pass a rectangle, we check that the part of the line immediately after our position in it coincides with the contents of the rectangle. <br><br>  So, checking the match of our regular season in the ‚Äúthe 3 pigs‚Äù line as it passes through the flowchart looks like this: <br><br>  - at position 4 there is a word boundary, and we pass the first rectangle <br>  - starting with the 4th position we find the number, and we pass the second rectangle <br>  - at position 5 one way closes back in front of the second rectangle, and the second goes further to the rectangle with a space.  We have a space, not a number, and we choose the second path. <br>  - now we are at position 6, the beginning of the ‚Äúpigs‚Äù, and on the triple branching of the paths.  There is no ‚Äúcow‚Äù or ‚Äúchicken‚Äù in the line, but there is a ‚Äúpig‚Äù, so we choose this way. <br>  - at position 9 after triple branching, one way goes around ‚Äús‚Äù and goes to the last rectangle with the word boundary, and the second one passes through ‚Äús‚Äù.  We have an ‚Äús‚Äù, so we go there. <br>  - at position 10 we are at the end of the line, and only the word boundary can match.  The end of the line is considered a border, and we pass through the last rectangle.  And so we successfully found our template. <br><br>  In principle, regular expressions work as follows: the algorithm starts at the beginning of a line and tries to find a match there.  In our case, there is a word boundary, so it passes the first rectangle - but there is no digit, so it stumbles on the second rectangle.  Then he moves to the second character in the string, and tries to find a match there ... And so on, until he finds a match or does not reach the end of the line, in which case the match is not found. <br><br><h4>  Kickbacks </h4><br>  The regular / \ b ([01] + b | \ d + | [\ da-f] h) \ b / matches either a binary number, followed by b, or a decimal number without a suffix, or a hexadecimal number (digits from 0 to 9 or characters from a to h), followed by h.  Relevant Chart: <br><br><img src="https://habrastorage.org/files/eac/04e/3a5/eac04e3a5ff04792abf0755e17afc3ad.PNG"><br><br>  In the search for a match, it may happen that the algorithm followed the upper path (binary number), even if there is no such number in the string.  If there is a line ‚Äú103‚Äù, for example, it is clear that only having reached the number 3 the algorithm will understand that it is on the wrong path.  In general, the string coincides with the regular, just not in this thread. <br><br>  Then the algorithm rolls back.  At the fork, he remembers the current position (in our case, this is the beginning of the line, immediately after the word boundary) so that you can go back and try another way if the selected one does not work.  For the line ‚Äú103‚Äù after meeting with the troika, he will return and try to pass the path for decimal numbers.  This will work, so a match will be found. <br><br>  The algorithm stops as soon as it finds a complete match.  This means that even if several options may come up, only one of them is used (in the order in which they appear in the regular season). <br><br>  Kickbacks happen when using repetition operators, such as + and *.  If you are looking for /^.*x/ in the ‚Äúabcxe‚Äù line, part of the regular schedule. * Will try to absorb the entire line.  The algorithm then realizes that he also needs an ‚Äúx‚Äù.  Since there is no ‚Äúx‚Äù after the end of the line, the algorithm will try to find a match by rolling back one character.  After abcx there is also no x, then it rolls back again, already to the substring abc.  And after the line, he finds x and reports a successful match, at positions 0 through 4. <br><br>  You can write a regular list that will lead to multiple rollbacks.  Such a problem occurs when a template can match the input data in many different ways.  For example, if we make a mistake when writing a regular number for binary numbers, we may accidentally write something like / ([01] +) + b /. <br><br><img src="https://habrastorage.org/files/3a2/a2f/daf/3a2a2fdaf17249b9a7f0020207779367.PNG"><br><br>  If the algorithm searches for such a pattern in a long string of zeros and ones that does not contain ‚Äúb‚Äù at the end, it will first go through the inner loop until it runs out of numbers.  Then he will notice that at the end there is no ‚Äúb‚Äù, he will roll back one position, pass through the outer loop, give up again, try to roll back to another position along the inner loop ... And he will continue to search in this way, using both loops.  That is, the amount of work with each character of the string will double.  Even for a few dozen characters, the search for a match will take a very long time. <br><br><h4>  Replace method </h4><br>  Strings have a replace method that can replace part of a string with another string. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">""</span></span>.replace(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí </span></span></code> </pre><br><br>  The first argument can be regular, in which case the first occurrence of the regular record in the string is replaced.  When the ‚Äúg‚Äù (global, universal) option is added to the regular list, all occurrences are replaced, not just the first <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Borobudur"</span></span>.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[ou]/</span></span>, <span class="hljs-string"><span class="hljs-string">"a"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí Barobudur console.log("Borobudur".replace(/[ou]/g, "a")); // ‚Üí Barabadar</span></span></code> </pre><br><br>  It would make sense to pass the ‚Äúreplace all‚Äù option through a separate argument, or through a separate method of type replaceAll.  But unfortunately, the option is passed through the regular schedule itself. <br><br>  The whole power of the regulars is revealed when we use the links to the groups found in the row, set in the regular season.  For example, we have a string containing the names of people, one name per line, in the format "Last Name, First Name".  If we need to swap them and remove the comma in order to get the "First Name", we write the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">"Hopper, Grace\nMcCarthy, John\nRitchie, Dennis"</span></span> .replace(<span class="hljs-regexp"><span class="hljs-regexp">/([\w ]+), ([\w ]+)/g</span></span>, <span class="hljs-string"><span class="hljs-string">"$2 $1"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí Grace Hopper // John McCarthy // Dennis Ritchie</span></span></code> </pre><br><br>  $ 1 and $ 2 in the replacement line refer to groups of characters enclosed in brackets.  $ 1 is replaced with text that matched the first group, $ 2 with the second group, and so on, up to $ 9.  The entire match is entirely contained in the $ &amp; variable. <br><br>  You can also pass a function as the second argument.  For each replacement, a function will be called, the arguments of which will be the found groups (and the entire matching part of the string as a whole), and its result will be inserted into a new line. <br><br>  A simple example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"the cia and fbi"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(s.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\b(fbi|cia)\b/g</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">str</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.toUpperCase(); })); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí the CIA and FBI</span></span></code> </pre><br><br>  But more interesting: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stock = <span class="hljs-string"><span class="hljs-string">"1 lemon, 2 cabbages, and 101 eggs"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minusOne</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">match, amount, unit</span></span></span><span class="hljs-function">) </span></span>{ amount = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(amount) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   ,  's'   unit = unit.slice(0, unit.length - 1); else if (amount == 0) amount = "no"; return amount + " " + unit; } console.log(stock.replace(/(\d+) (\w+)/g, minusOne)); // ‚Üí no lemon, 1 cabbage, and 100 eggs</span></span></code> </pre><br><br>  The code takes a string, finds all occurrences of numbers followed by a word, and returns a string where each number is reduced by one. <br><br>  The group (\ d +) is in the amount argument, and (\ w +) is in the unit.  The function converts the amount to a number - and it always works, because our pattern is just \ d +.  And then makes changes to the word, in case there is only 1 item left. <br><br><h4>  Greed </h4><br>  It is easy with the help of replace to write a function that removes all comments from the JavaScript code.  Here is the first attempt: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stripComments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|\/\*[^]*\*\//g</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(stripComments(<span class="hljs-string"><span class="hljs-string">"1 + /* 2 */3"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1 + 3 console.log(stripComments("x = 10;// ten!")); // ‚Üí x = 10; console.log(stripComments("1 /* a */+/* b */ 1")); // ‚Üí 1 1</span></span></code> </pre><br><br>  The part before the ‚Äúor‚Äù operator matches two slashes, followed by any number of characters, except for newline characters.  The part that removes multi-line comments is more complex.  We use [^], i.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any non-empty character as a way to find any character. We cannot use the period because block comments continue on the new line, and the newline character does not match the period. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the output of the previous example is incorrect.</font></font> Why? <br><br>  [^]*     ,  .  -        ,        .  ,     ,   .   4  ,     */ ‚Äî    ,   . -     ,          . <br><br> -   ,    (+, *, ?, and {}) ,     ,  ,    .        (+?, *?, ??, {}?),    ,        . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is what we need. </font><font style="vertical-align: inherit;">By making the asterisk match in the minimum possible number of characters in the line, we absorb only one block of comments, and no more.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stripComments</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> code.replace(<span class="hljs-regexp"><span class="hljs-regexp">/\/\/.*|\/\*[^]*?\*\//g</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(stripComments(<span class="hljs-string"><span class="hljs-string">"1 /* a */+/* b */ 1"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 1 + 1</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Many errors occur when using greedy operators instead of non-greedy ones. </font><font style="vertical-align: inherit;">When using the replay operator, always consider first the option of a non-greasy operator.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic creation of RegExp objects </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some cases, the exact pattern is unknown at the time of writing the code. </font><font style="vertical-align: inherit;">For example, you will need to search for the username in the text, and enclose it in underscores. </font><font style="vertical-align: inherit;">Since you only learn the name after starting the program, you cannot use a record with slashes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But you can build a string and use the RegExp constructor.</font></font> Here is an example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-string"><span class="hljs-string">"     ."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regexp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">"\\b("</span></span> + name + <span class="hljs-string"><span class="hljs-string">")\\b"</span></span>, <span class="hljs-string"><span class="hljs-string">"gi"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(text.replace(regexp, <span class="hljs-string"><span class="hljs-string">"_$1_"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí   __   .</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating the boundaries of the word, we have to use double slashes, because we write them in the normal line, and not in the regular line with straight slashes. </font><font style="vertical-align: inherit;">The second argument for RegExp contains options for regulars - in our case ‚Äúgi‚Äù, i.e. </font><font style="vertical-align: inherit;">global and register-independent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what if the name is ‚Äúdea + hl [] rd‚Äù (if our user is a Culhacker)? </font><font style="vertical-align: inherit;">As a result, we get a meaningless regular record that does not find matches in the string. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can add backslashes in front of any character we don‚Äôt like. </font><font style="vertical-align: inherit;">We cannot add backslashes before letters, because \ b or \ n are special characters. </font><font style="vertical-align: inherit;">But you can add slashes before any non-alphanumeric characters without problems.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> name = <span class="hljs-string"><span class="hljs-string">"dea+hl[]rd"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> text = <span class="hljs-string"><span class="hljs-string">" dea+hl[]rd  ."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> escaped = name.replace(<span class="hljs-regexp"><span class="hljs-regexp">/[^\w\s]/g</span></span>, <span class="hljs-string"><span class="hljs-string">"\\$&amp;"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regexp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">"\\b("</span></span> + escaped + <span class="hljs-string"><span class="hljs-string">")\\b"</span></span>, <span class="hljs-string"><span class="hljs-string">"gi"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(text.replace(regexp, <span class="hljs-string"><span class="hljs-string">"_$1_"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  _dea+hl[]rd_  .</span></span></code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Search method </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The indexOf method cannot be used with regulars. </font><font style="vertical-align: inherit;">But there is a search method, which is just waiting for the regular list. </font><font style="vertical-align: inherit;">Like indexOf, it returns the index of the first occurrence, or -1 if it did not happen.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" word"</span></span>.search(<span class="hljs-regexp"><span class="hljs-regexp">/\S/</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 console.log(" ".search(/\S/)); // ‚Üí -1</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, there is no way to set the method to search for a match, starting from a specific offset (as can be done with indexOf). </font><font style="vertical-align: inherit;">That would be helpful.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LastIndex property </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The exec method also does not provide a convenient way to start a search from a given position in the string. But an uncomfortable way gives. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regular object has properties. One of these is source, which contains a string. Another one is lastIndex, which controls, in some conditions, where the next search for occurrences will begin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These conditions include the presence of the global g option, and that the search should proceed using the exec method. A more sensible solution would be to simply allow an additional argument to be passed to exec, but reasonableness is not a fundamental feature in the JavaScript regularizer interface.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pattern = <span class="hljs-regexp"><span class="hljs-regexp">/y/g</span></span>; pattern.lastIndex = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match = pattern.exec(<span class="hljs-string"><span class="hljs-string">"xyzzy"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(match.index); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 4 console.log(pattern.lastIndex); // ‚Üí 5</span></span></code> </pre><br><br>    ,  exec   lastIndex,        .    , lastIndex    ‚Äì   lastIndex     . <br><br>    -    exec    lastIndex    .       ,    . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> digit = <span class="hljs-regexp"><span class="hljs-regexp">/\d/g</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(digit.exec(<span class="hljs-string"><span class="hljs-string">"here it is: 1"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["1"] console.log(digit.exec("and now: 1")); // ‚Üí null</span></span></code> </pre><br><br>      g  ,      match.      ,   ,     exec,             . <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">""</span></span>.match(<span class="hljs-regexp"><span class="hljs-regexp">//g</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí ["", ""]</span></span></code> </pre><br><br>      -.  ,    ‚Äì  replace  ,     lastIndex ‚Äì    ,     . <br><br><h4>    </h4><br><br>   ‚Äì        ,      match   ,  lastIndex  exec. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-string"><span class="hljs-string">"  3   ... 42  88."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number = <span class="hljs-regexp"><span class="hljs-regexp">/\b(\d+)\b/g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (match = number.exec(input)) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">" "</span></span>, match[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">"  "</span></span>, match.index); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí  3  14 //  42  33 //  88  40</span></span></code> </pre><br><br>   ,      .   match = re.exec(input)      while,       ,    ,   ,    . <br><br><h4>  INI  </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, the chapter will consider the problem using regulars. Imagine that we are writing a program that collects information about our enemies via the Internet in automatic mode. (We will not write the whole program, only the part that reads the settings file. Sorry.) The file looks like this:</font></font><br><br><pre> <code class="javascript hljs">searchengine=http:<span class="hljs-comment"><span class="hljs-comment">//www.google.com/search?q=$1 spitefulness=9.7 ;       ;       [larry] fullname=Larry Doe type=   website=http://www.geocities.com/CapeCanaveral/11451 [gargamel] fullname=Gargamel type=  outputdir=/home/marijn/enemies/gargamel</span></span></code> </pre><br><br>    (   ,    INI), : <br><br> ‚Äî    ,     ,  <br> ‚Äî ,    ,    <br> ‚Äî ,  - ,    =,      <br><br>   ‚Äì  . <br><br>   ‚Äì      ,    name   .      ,    ‚Äì     . <br><br>      ,       .     6   string.split("\n").          \n,   ‚Äî \r\n.    split     ,        /\r?\n/,    \n  \r\n  . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseINI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,     var currentSection = {name: null, fields: []}; var categories = [currentSection]; string.split(/\r?\n/).forEach(function(line) { var match; if (/^\s*(;.*)?$/.test(line)) { return; } else if (match = line.match(/^\[(.*)\]$/)) { currentSection = {name: match[1], fields: []}; categories.push(currentSection); } else if (match = line.match(/^(\w+)=(.*)$/)) { currentSection.fields.push({name: match[1], value: match[2]}); } else { throw new Error(" '" + line + "'   ."); } }); return categories; }</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code passes all lines, updating the current section object. First, he checks whether the line can be ignored with the help of the regular /^\s*(;.*)?$/. See how it works? The part between the brackets is the same as the comments, eh? makes it so that the regular match coincides with the lines consisting of single spaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the line is not a comment, the code checks to see if it starts a new section. If so, it creates a new object for the current section, to which subsequent settings are added. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last sensible possibility is that the string is the usual setting, in which case it is added to the current object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If none of the options worked, the function gives an error.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice how the frequent use of ^ and $ takes care that the expression matches the entire string, not the part. </font><font style="vertical-align: inherit;">If you do not use them, the code as a whole will work, but sometimes it will produce strange results, and such an error will be difficult to track. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The if construct (match = string.match (...)) is similar to a trick using assignment as a condition in a while loop. </font><font style="vertical-align: inherit;">Often you don‚Äôt know that the call to match will succeed, so you can access the resultant object only inside an if block that checks this. </font><font style="vertical-align: inherit;">Not to break a beautiful chain of checks if, we assign the search result to a variable, and immediately use this assignment as a check.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> International characters </font></font></h4><br> -    ,      ¬´ ¬ª,  JavaScript   ,     .  ,  ¬´¬ª     JavaScript,     26   ,  -  .   √©  Œ≤,   ,    \w (   \W,    -). <br><br>    ,  \s ()    ,   Unicode  ,   ,       . <br><br>                Unicode,  ¬´  ¬ª, ¬´  ¬ª  ¬´ ¬ª.         JavaScript,  , ,    . <br><br><h4>  Total </h4><br><br>  ‚Äì  ,     .        . <br><br> /abc/   <br> /[abc]/     <br> /[^abc]/  ,     <br> /[0-9]/     <br> /x+/      x <br> /x+?/    ,  <br> /x*/     <br> /x?/     <br> /x{2,4}/      <br> /(abc)/  <br> /a|b|c/     <br> /\d/   <br> /\w/  -  (¬´¬ª) <br> /\s/    <br> /./  ,    <br> /\b/   <br> /^/   <br> /$/   <br><br>     test,   ,     .   exec,  ,    .     index,    ,    . <br><br>     match   ,   search,     .  replace       .  ,     replace ,      ,      . <br><br>    ,     .  i   ,   g   , ,  ,   replace    ,    . <br><br>  RegExp       . <br><br>  ‚Äì     .     ,       ,  .       ,        ,     . <br><br><h4>  Exercises </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inevitably, when solving problems, you will encounter incomprehensible cases, and you can sometimes despair, seeing the unpredictable behavior of some regulars. </font><font style="vertical-align: inherit;">Sometimes it helps to study the behavior of the regular season through an online service like debuggex.com, where you can see its visualization and compare it with the desired effect.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Regular golf </font></font></h5><br> ¬´¬ª    ,        .   ‚Äì           ,   . <br><br>            .       .     ,     .      ,   . <br><br> ‚Äî car  cat <br> ‚Äî pop  prop <br> ‚Äî ferret, ferry,  ferrari <br> ‚Äî  ,   ious <br> ‚Äî ,    , ,     . <br> ‚Äî     <br> ‚Äî    e <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    verify(/.../, ["my car", "bad cats"], ["camper", "high art"]); verify(/.../, ["pop culture", "mad props"], ["plop"]); verify(/.../, ["ferret", "ferry", "ferrari"], ["ferrum", "transfer A"]); verify(/.../, ["how delicious", "spacious room"], ["ruinous", "consciousness"]); verify(/.../, ["bad punctuation ."], ["escape the dot"]); verify(/.../, ["hottentottententen"], ["no", "hotten totten tenten"]); verify(/.../, ["red platypus", "wobbling nest"], ["earth bed", "learning ape"]); function verify(regexp, yes, no) { // Ignore unfinished exercises if (regexp.source == "...") return; yes.forEach(function(s) { if (!regexp.test(s)) console.log("  '" + s + "'"); }); no.forEach(function(s) { if (regexp.test(s)) console.log("  '" + s + "'"); }); }</span></span></code> </pre><br><br><h5>    </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose you wrote a story, and everywhere for the designation of dialogues used single quotes. </font><font style="vertical-align: inherit;">Now you want to replace the quotes of dialogs with double ones, and leave single quotes in the abbreviations of the words such as aren't. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come up with a pattern that distinguishes between these two uses of quotes, and write a call to the replace method that performs the replacement.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Numbers again </font></font></h5><br>       /\d+/. <br><br>  ,   ,    JavaScript.         ,  ,    5e-3  1E10 ‚Äì -     .  ,          ,          .  , .5  5. ‚Äì  ,       ‚Äì . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   . var number = /^...$/; // Tests: ["1", "-1", "+15", "1.55", ".5", "5.", "1.3e2", "1E-4", "1e+12"].forEach(function(s) { if (!number.test(s)) console.log("  '" + s + "'"); }); ["1a", "+-1", "1.2.3", "1+1", "1e4.5", ".5.", "1f5", "."].forEach(function(s) { if (number.test(s)) console.log("  '" + s + "'"); });</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/242695/">https://habr.com/ru/post/242695/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242681/index.html">The harsh everyday life of the Internet on the African continent</a></li>
<li><a href="../242683/index.html">IT chat rooms or squeeze out all the juice from Skype</a></li>
<li><a href="../242685/index.html">Codeship.io: a free CI server for a private Github / Bitbucket repository</a></li>
<li><a href="../242687/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ21 (November 3 - 9, 2014)</a></li>
<li><a href="../242691/index.html">HR Acquisition Payoneer</a></li>
<li><a href="../242697/index.html">Features of loading objects from a KML map onto a Yandex map</a></li>
<li><a href="../242699/index.html">Explore the internal mechanisms of Hyper-V</a></li>
<li><a href="../242701/index.html">A / B testing: 70 resources that will serve as a good start for beginners</a></li>
<li><a href="../242707/index.html">The story of how a mobile operator wrote off money from the developer Dr. Tariff (grab popcorn)</a></li>
<li><a href="../242709/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ133 (November 3 - 9, 2014)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>