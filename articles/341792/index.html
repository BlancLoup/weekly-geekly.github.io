<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET Security is easy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We present interviews with leading security experts: Vladimir Kochetkov (head of application security analysis research at Positive Technologies ) and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET Security is easy</h1><div class="post__text post__text-html js-mediator-article"><p>  We present interviews with leading security experts: Vladimir Kochetkov (head of application security analysis research at <a href="https://habrahabr.ru/company/pt/">Positive Technologies</a> ) and Mikhail Scherbakov (independent developer and consultant in information security). </p><br><p>  What is this article about?  I will quote one of Michael‚Äôs remarks: </p><br><p>  <em>‚ÄúDeveloping a secure application is a special case of developing an application that does not contain errors at all.</em>  <em>In addition, your application uses third-party libraries, the security of which is also not guaranteed, then it runs on the OS and hardware.</em>  <em>Often we can not even say on which OS and on which hardware.</em>  <em>And all this changes with time! ‚Äù</em> </p><br><p><img src="https://habrastorage.org/webt/ac/bk/ea/acbkeamaluqrssuln9o5rnblprc.png"></p><a name="habracut"></a><br><p><img src="https://habrastorage.org/webt/v0/t-/3a/v0t-3aboegwvy7ue7fmc0bdnz8i.jpeg" align="left">  <strong>Vladimir Kochetkov</strong> - since 2006 he worked in the subject area of ‚Äã‚Äãinformation security.  In 2012, Positive Technologies came to the position of the leading expert of the web application security analysis group.  He participated in projects on the analysis of application security, investigated application testing techniques.  With the participation of Vladimir implemented the product PT Application Inspector.  In 2014-2016, he led the development team for analyzers of compiled applications and led the project to develop a binary code analysis module.  Since September 2016, she has headed the application security analysis research department.  He is directly involved in theoretical research in the direction of analyzing the security of applications and prototyping promising products of the company.  He has published articles in HITB Magazine, Hacker, and RSDN Magazine.  Repeatedly participated in the international forum Positive Hack Days (as organizer and speaker) and the .NET developer conference DotNext, regularly speaks at user group developer meetings.  Takes part in the development community of Russian-speaking developers RSDN.  One of the organizers of the Positive Development User Group is an initiative aimed at immersing developers in the application protection domain.  Keeps the blog <a href="https://kochetkov.github.io/">kochetkov.github.io</a> . </p><br><p>  At DotNext 2017 Moscow arrives with the <a href="https://dotnext-moscow.ru/2017/msk/talks/7alwdnxp0kayquoukwmky8/">report ‚ÄúWinning Injections‚Äù.</a> <br><br clear="all"><img src="https://habrastorage.org/webt/t8/m3/ss/t8m3ssv3bbcu9zcysgqz0lkvoga.jpeg" align="left">  <strong>Mikhail Shcherbakov</strong> - Microsoft .NET MVP, participant of the .NET Core Bug Bounty Program, co-organizer of the .NET programmers community, independent developer and consultant.  Professional interests: static and dynamic code analysis, information security, code debugging automation, .NET CLR internal device research. </p><br><p>  DotNext 2017 Moscow arrives with the <a href="https://dotnext-moscow.ru/2017/msk/talks/56xfqlt2aq44wauewm0u2q/">report ‚ÄúASP.NET Core: Attack Prevention Mechanisms 2.0‚Äù.</a> <br><br clear="all"></p><br><hr><br><p>  <strong>- What types of vulnerabilities are usually found in the .NET Framework now?</strong> </p><br><p>  <strong>Mikhail Shcherbakov</strong> : Here we need to separate vulnerabilities in the .NET Framework itself and in applications that are written based on the .NET platform.  The .NET Framework is a platform for developing various types of applications: from websites and services to desktop applications.  And this is an integral part of the Windows operating system, so the .NET Framework security should be treated like an OS.  The main part of the vulnerabilities in it is not the usual web developers XSS, CSRF, SQL / XML / JSON and other injections, but the execution of arbitrary code, elevation of user privileges, information disclosure, denial of service. </p><br><p>  <strong>- Tell us, please, what do you know about the vulnerabilities found recently in ASP .NET and in .NET Core?</strong> </p><br><p>  <strong>Michael</strong> : A detailed story would not have turned out for one hour :) I made a report about vulnerabilities in the ‚Äúbig‚Äù .NET Framework a year ago at DotNext Moscow.  With a demonstration of examples of exploits and analysis of errors that lead to these vulnerabilities.  Of course, in 45 minutes it turned out to include less than I would like, I tried to focus on the vulnerabilities that developers can allow in their products, primarily in web applications, in ASP .NET.  There have been examples of DoS, Elevation of Privileges, XXE, Information Disclosure, data deserialization attacks. </p><br><p>  For .NET Core this year a large patch was released, fixing several vulnerabilities: DoS, Elevation of Privilege, protection bypass.  Including the vulnerability CVE-2017-0256 I found in protection against Open Redirect.  The problem, as is often the case, was the lack of validation of user input.  You should also pay attention to Kestrel, I am now in my free time doing a review of this code, and my opinion coincides with the position of Microsoft and the .NET Foundation, that it is not yet ready for use on the front.  Be sure to close it with any reverse proxy (Nginx, Apache, IIS).  I think I can soon tell you more about this. </p><br><p>  <strong>Vladimir Kochetkov</strong> : Over the past couple of years, there has been another surge in platform vulnerabilities related to the processing of XML documents.  In 2013, our guys made a <a href="https://media.blackhat.com/eu-13/briefings/Osipov/bh-eu-13-XML-data-osipov-slides.pdf">report</a> at the BlackHat EU conference about the OOB techniques of attack introducing external XML entities, which resulted in the elimination of a large number of vulnerabilities in a wide variety of XML libraries, including System.Xml.  However, progress does not stand still and, a few years later, we again see in .NET a set of quite traditional XML processing vulnerabilities: XXE (CVE-2016-3255), signature forgery of XML documents (CVE-2016-0132), DoS via specially crafted XSLT documents leading to recursive transformations (CVE-2016-0033).  Not without the vulnerabilities of the OS level, which directly determines the security of the overlying levels.  Thus, the CVE-2016-0145 vulnerability in win32k.sys (in fact, the Windows kernel) allowed an attacker to execute arbitrary code in the system using a specially crafted font (!!) embedded in any document.  Of course, using this vulnerability could be successfully attacked and .NET-applications that work with documents of suitable formats. </p><br><p>  Separately, it is worth noting immediately two vulnerabilities of remote execution of arbitrary code found in .NET this year: <a href="https://www.cvedetails.com/cve/CVE-2017-0160/">CVE-2017-0160</a> and <a href="https://www.cvedetails.com/cve/CVE-2017-8759/">CVE-2017-8759</a> .  A detailed analysis of the first (as well as the proof-of-concept code for its operation) can be found at <a href="https://www.exploit-db.com/exploits/41903/"></a>  <a href="https://www.exploit-db.com/exploits/41903/">https://www.exploit-db.com/exploits/41903/</a> .  The second <a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html">article is</a> devoted to a separate <a href="https://www.fireeye.com/blog/threat-research/2017/09/zero-day-used-to-distribute-finspy.html">article in the FireEye company blog</a> .  It is noteworthy that this vulnerability, among others, was used for the introduction of the FinSpy government spy system, which became known due to another publication on WikiLeaks. </p><br><p>  <strong>- What could be the goal of attacking the .NET Framework in the first place?</strong>  <strong>Have the attackers changed their goals over a period of, say, five years?</strong> </p><br><p>  <strong>Michael</strong> : The main goals are the components used in web applications, various parsers working with input data that an attacker can manipulate.  Since the .NET Framework is on every modern version of Windows, any of its components is potentially interesting for information security researchers to implement an attack to elevate the privileges of a local user.  For example, CVE-2014-0257 was used to exit Internet Explorer 11 Sandbox, and CVE-2014-4073 from ClickOnce.  Access to the .NET object from the code executed in the sandbox was implemented through Managed DCOM.  This year, the story of DCOM repeated, and CVE-2017-7293 was found, similar in attack technique.  You can read the whole fascinating story <a href="https://googleprojectzero.blogspot.ru/2017/04/exploiting-net-managed-dcom.html">in the blog of the Google Project Zero team</a> . </p><br><p>  Over the past few years, it has become less interesting in applying the attack to exit the .NET Sandbox, because the technology itself is used all in fewer products.  It was not included in .NET Core, the ASP .NET team finally refused to use the sandbox to isolate applications inside IIS, Silverlight is almost dead, the latest versions of IE warned the user about the execution of third-party XBAP applications.  Four years ago it was possible, using CVE-2013-0073, to launch the Remote Code Execution attack on a user's computer simply by opening a specially prepared page in the browser.  I <a href="https://www.youtube.com/watch%3Fv%3DPkFuKQo6Iss%26feature%3Dyoutu.be%26list%3DPLtWrKx3nUGBeCTpN--0BsxxM0dFPVMXip">showed</a> an example of this exploit at DotNext Moscow 2014. </p><br><p>  I mentioned the .NET Core, so when working on it, the vulnerabilities in the RyuJIT compiler were fixed: CVE-2015-2479, CVE-2015-2480, CVE-2015-2481.  The open-ended Bug Bounty .NET Core vulnerability scan program <a href="https://aka.ms/BugBounty">with rewards of up to $ 15,000</a> is now open, and the .NET Core components, of course, are now excellent targets for information security researchers. </p><br><p>  <strong>Vladimir</strong> : It depends, first of all, on who the attacker is and what kind of attack he is conducting.  In the case of an automated mass attack, the goal may be, for example, the seizure of control by as many network hosts as possible.  Accordingly, in this case, fresh vulnerabilities of the platform, popular frameworks, engines, and libraries are attacked at random, and credentials are selected for known entry points using a small dictionary. </p><br><p>  In the case of a competent targeted attack, the scenario develops in the best traditions of the notorious killchein: reconnaissance is being carried out, exploits are being prepared, being introduced into the system, fixed in it and performing actions aimed at achieving the attacker's goal.  The goal in this case, as a rule, is the one-time receipt of any confidential information or its continuous monitoring.  With regard to .NET, this means a scrupulous analysis of any source available to him attacking the attacked application (including the source of the platform itself), using the identified zero-day vulnerabilities, possibly focusing on code that directly interacts with databases (System.Data, ORM ) or other external repositories of the extracted information. </p><br><p>  In purely technical terms, the targets of attackers have changed little over the past 5 years - the same set of vulnerabilities, attacks and threats, varying from year to year within insignificant limits (see <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">OWASP Top 10</a> , if we talk about web applications).  Of the noticeable changes - in the last two or three years, there has been a tendency towards a significant development of consolidation techniques in Windows systems, which inevitably affects the consequences of successful exploitation of vulnerabilities in .NET applications, which are still traditionally attributed to this OS in most cases. </p><br><p>  <strong>- Can knowledge of the main types of attacks help develop protected applications, and if so, how?</strong> </p><br><p>  <strong>Michael</strong> : It can help.  Often, developers' eyes are filled with knowledge of ‚Äútemplate‚Äù web vulnerabilities: XSS, Path Traversal, various injections, and they pay little attention to logical errors that lead to a violation of application security.  Therefore, examples of successful attacks on the platform under which you are developing expands the horizons and allows you to take a fresh look at your code.  But to develop secure applications, you need a systematic approach.  Vladimir and I conducted one of the first meetings of the <a href="https://vk.com/spbdotnet">SPB .NET Community</a> dedicated to the security of .NET applications, and tried to solve the topic from both the theory and the practice side.  The network has a video of this meeting. </p><br><p> <strong>Vladimir</strong> : If we talk about the principle of ‚Äúhack-yourself-first‚Äù, then it simply does not work.  In order for a developer to effectively protect an application, thinking the categories of an attacker, he must be as professional in this regard as the average intended attacker is professional.  For developers, this actually means getting a second specialization.  Fighting attacks is not their area of ‚Äã‚Äãresponsibility.  From the point of view of ensuring the security of the application, the main task of the development stage is to combat flaws - an ineffective implementation of application domain control, which leads to the emergence of vulnerabilities to <a href="http://projects.webappsec.org/w/page/13246978/Threat%2520Classification">attacks of various kinds</a> .  In sufficient detail, this topic was revealed <a href="https://www.youtube.com/watch%3Fv%3Dmb7tcT-9VXk">at the CodeFreeze community meeting</a> in Moscow, in April last year.  There were also several examples of how the struggle of developers against attacks instead of flaws can lead to the appearance of vulnerabilities in their applications. </p><br><p>  Of course, it is worth knowing the main types of attacks for developers, at least for general development.  But you should not use this knowledge to make decisions regarding the protection of the applications they develop.  Developers interested in the specifics of carrying out attacks on ASP.NET applications may be interested in my article ‚Äú <a href="https://xakep.ru/pdf/xa/165/">Hack a ASP.NET website?</a>  <a href="https://xakep.ru/pdf/xa/165/">Difficult, but possible!</a>  ‚Äù, Published in the 165th issue of Hacker magazine (p. 63). </p><br><p>  <strong>- What aspects of the security of the .NET Framework should the developer focus on and why?</strong> </p><br><p>  <strong>Mikhail</strong> : For the developer, this is, first of all, validation of all input data, sanitization of output data.  About validation of input data speak from school.  Everything that comes from the user should be checked for compliance with the requirements (including the requirements of the security model).  And the main thing is to do it correctly: use white list checking, where possible, to correctly describe the grammar of the input data format (this I mean, you don't need to parse XML or HTML with <a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454">regular expressions</a> ).  This is also following all bored principles of <a href="https://www.owasp.org/index.php/Security_by_Design_Principles">Secure by Design / Default / Deployment</a> . </p><br><p>  Plus, there is a best practice set for developing secure applications, for example, the <a href="https://github.com/OWASP/DevGuide">OWASP Developer Guide</a> <a href="https://docs.microsoft.com/en-us/aspnet/aspnet/overview/web-development-best-practices/what-not-to-do-in-aspnet-and-what-to-do-instead">, and</a>  Knowing and following them is just as important as knowing the architectural patterns and principles of SOLID. </p><br><p>  <strong>Vladimir</strong> : First of all, it is worth paying attention to the preliminary processing of input and output data.  With reference to .NET, this means: </p><br><p>  <strong>a)</strong> Strong typing of all data received from outside.  Any external data received in the form of System.String should be transformed into specific entities of business logic and then used in this form (unless, of course, the semantics of the input data does not imply that this is a string entity, such as "message text on forum ").  However, despite the need for typing all the input data, it must be remembered that for any non-primitive types, it can entail serious security problems, such as SSRF, deserialization vulnerabilities, etc. </p><br><p>  <strong>b)</strong> Semantic validation of all typed external data.  Ideally, it is necessary to define invariants for each entity and to ensure their observance by means of contract programming, such as CodeContracts or PostSharp Contracts. </p><br><p> <strong>c)</strong> Syntactic sanitization of all data sent out in accordance with the grammar of the receiving party.  It must be remembered here that the need to apply certain sanitizers depends not only on the host grammar, but also on the context in which the data is transmitted.  So, for example, using <code>HttpUtility.UrlEncode</code> for data transmitted, for example, in JavaScript code, will leave the application vulnerable to an XSS attack.  Most sanitizers in .NET are concentrated in the <code>HttpUtility</code> , <code>HttpServerUtility</code> , <code>WebUtility</code> and <code>System.Web.Security.AntiXss</code> classes.  You should also pay attention to our library <a href="https://github.com/PositiveTechnologies/libprotection-dotnet">LibProtection</a> , the first public release of which is scheduled for November 13 of this year and which is dedicated to <a href="https://dotnext-moscow.ru/2017/msk/talks/7alwdnxp0kayquoukwmky8/">my report at the upcoming DotNext Moscow 2017</a> . </p><br><p>  <strong>- What types of vulnerabilities in the .NET Framework that interfered (or hindered earlier) in your work could you name?</strong> </p><br><p>  <strong>Michael</strong> : Any vulnerabilities help my work more than they interfere :) By analyzing vulnerabilities in .NET FW, you can learn new types of attacks and (anti) code writing patterns.  It helps to develop secure applications and analyze system security. </p><br><p>  <strong>Vladimir</strong> : The nature of my work is such that any vulnerability in .NET contributes to it rather than interferes.  But if we talk about your favorite .NET vulnerabilities, then this is definitely the sensation in 2010 of the suspicion of attacking an oracle in the ASP.NET WebForms encrypted token pattern (CVE-2010-3332), which allowed you to read arbitrary web server files and forge authentication tokens.  A detailed analysis of this attack can be found in the <a href="http://www.infobytesec.com/down/paddingoracle_openjam.pdf">presentation</a> . </p><br><p>  <strong>- What security errors are most often made by developers of the .NET Framework application?</strong> </p><br><p>  <strong>Michael</strong> : In my experience of conducting a security review of web projects, these are all kinds of injections ‚Äúin the broad sense of the word‚Äù: XSS, SQLi, XXE, Path Traversal, and application configuration problems.  This is also confirmed by the data on the basis of which the well-known <a href="https://github.com/OWASP/Top10/tree/master/2017/datacall">OWASP Top 10</a> rating of this year and the information security reports of companies were compiled. </p><br><p>  Injections are possible only with insufficient validation of input data and improper sanitization of the weekend, I mentioned above.  Configuration errors are resolved by following best practices and using vulnerability scanners. </p><br><p>  <strong>Vladimir</strong> : As I said above, a very significant part of security problems is associated with inefficient preprocessing of data.  This is confirmed by the annual statistics of vulnerable web applications published by Positive Technologies.  So, <a href="https://www.ptsecurity.com/upload/corporate/ru-ru/analytics/Web-vulners-2017-rus.pdf">according to the data for 2016</a> , the most typical for ASP.NET applications are vulnerabilities to cross-site scripting, credential selection and information leakage. </p><br><p>  <strong>- What are the most effective methods of dealing with attacks on .NET applications you can name?</strong> </p><br><p>  <strong>Michael</strong> : Usually the goal of any software vendor is not to fight attacks, but to develop secure applications, to guarantee the confidentiality of user data.  Therefore, security must be approached from the point of view of protection, not attack. </p><br><p>  Developing secure applications is, first and foremost, thoughtful risk management.  It is impossible to develop the most secure application "accidentally", only due to the qualifications of the developers.  The security level of each component of the application is the same requirement for which resources are required both at the design stage and at the testing stage.  It is necessary to understand the price of the risk of an attack on each component, and on this basis to decide how much effort to spend on preventing this risk.  And in any case, have a plan of action if the risk has been realized, i.e.  Your application has been successfully attacked. </p><br><p>  If you are still ready for additional costs, then a systematic approach is important.  It is necessary to systematically introduce the Secure Development Lifecycle (SDL) techniques into the development process, improve the development culture in the company: add a security review step to the product release process, develop and implement best practices for writing secure applications, train developers in the company, pay attention to security during testing, carry out penetration tests (both internal and external), constantly use ‚Äúwhite box‚Äù and ‚Äúblack box‚Äù scanners in order to maximally automate the process of searching for vulnerabilities, to accept  Venting protection measures, for example, use a Web Application Firewall (WAF). </p><br><p>  <strong>Vladimir</strong> : Whatever the specifics of .NET, the general principles for ensuring application security are: </p><br><ul><li>  Embedding SSDL (Secure Software Developent Lifecycle) into the overall software development cycle; </li><li>  focusing developers on combating flaws in the code; </li><li>  use of application-level firewalls during the operation phase. </li></ul><br><p>  In addition, specifically developers of .NET applications should pay attention to the .NET security cheat sheet <a href="https://www.owasp.org/index.php/.NET_Security_Cheat_Sheet">from OWASP</a> and Stan Drapkin <a href="http://securitydriven.net/">'s</a> remarkable book <a href="http://securitydriven.net/">‚ÄúSecurity Driven .NET‚Äù</a> , revealing the specifics of ensuring security of .NET applications with a bias in cryptography. </p><br><p>  <strong>- Have you ever hacked your own .NET applications?</strong>  <strong>If so, can you tell more about it?</strong>  <strong>Maybe you can tell a couple of cases about similar situations with applications of familiar developers?</strong> </p><br><p>  <strong>Mikhail</strong> : I had no interesting examples.  The first thing that comes to mind is the study of the Strangelove SCADA team, in which they ‚Äúmodeled‚Äù the attack on the Siemens WinCC SCADA / HMI system.  The WinCC Web Navigator server is written on the .NET platform, and researchers have found a whole bunch of vulnerabilities in it: XPath Injection, Path Traversal, more than 20 XSS, CSRF, SQLi, and others.  Using these vulnerabilities, the guys suggested what an attack on a real SCADA system might look like if the attacker is located outside the perimeter of the attacked network, as in the real world.  You can see a <a href="https://www.youtube.com/watch%3Fv%3DdAL3XHFE78s">report with PHDays</a> about this attack. </p><br><p>  <strong>Vladimir</strong> : The most memorable incident was an attack on the users of the forums of the site RSDN.org in May 2014, whose engine is currently running on ASP.NET MVC.  One of the regulars, offended by the policy of moderation, began methodically brutessing the credentials of other users and using them to publish an avalanche of meaningless or offensive messages.  At that time, the site's engine did not use any means of controlling the complexity of the passwords used, and as a result, the attacker managed to pick up passwords for more than a dozen accounts before the attack was stopped.  In the registration and change password forms, control of its complexity was implemented and the passwords of users whose accounts the attacker managed to get were reset. </p><br><p>  After that, we took a database of user password hashes and carried out an offline dictionary attack of dictionary selection of ~ 250K elements.  As a result, 83,165 registered at that time users accounted for 11,017, whose passwords were able to pick up in a reasonable time.  Their passwords were also reset, and notifications were sent to the mail about the need to undergo a password recovery procedure. </p><br><p>  It is noteworthy that after all this, the attacker still had the opportunity to use the accounts under which he had already managed to log in and whose authorization cookies he used to organize the attack.  The fact is that the authentication token ASP.NET implements the concept of so-called.  "Disconnected authentication" and, by virtue of the ASP.NET design, is life-long valid, without the ability to revoke it from a specific user. </p><br><p>  Thus, even after changing the passwords of the affected users, the attacker was left with working authentication tokens, using which he could easily enter under these users in the future.  In order to invalidate all of its tokens, we had to change the machine key used to encrypt authentication tickets, which made absolutely all previously issued tokens invalid and caused the mass reauthentication of all users of the site. </p><br><p>  <strong>- Is it possible to make a 100% protected application using the .NET Framework?</strong>  <strong>What is required for this?</strong> </p><br><p>  <strong>Michael</strong> : No.  It is impossible to make a 100% protected application on any platform.  Everything is even worse, if you create a 100% protected application with the help of magic and deals with the devil, you cannot prove that it is 100% protected!  It is theoretically impossible to verify any nontrivial algorithm for an adequate time, including the requirements of security. </p><br><p>  Developing a secure application is a special case of developing an application that does not contain errors at all.  I think every developer intuitively understands that this is an unattainable perfect result, to which we all endlessly strive.  In addition, your application uses third-party libraries, the security of which is also not guaranteed, then it runs on the OS and hardware. </p><br><p>  Often we can not even say on which OS and on which hardware.  And all this changes over time!  I think any attempt to achieve 100% is doomed to failure with so many unknowns. </p><br><p>  In my opinion, the .NET Framework is a good choice for building secure applications.  I would already bet on .NET Core.  This is a small, cross-platform open source framework supported by a large company with vast experience in the development of secure systems.  I foresee the skepticism of Linux users about the last phrase :) Without going into the statistics of the found and fixed vulnerabilities, for me was an indicative battle ‚ÄúWindows vs.  Linux ‚Äùat one of <a href="https://zeronights.org/">ZeroNights</a> , where at the end the audience decided that it was a more secure platform ... The majority voted for Windows! </p><br><p>  <strong>Vladimir</strong> : Let's fantasize a bit and imagine that this is really possible.  In other words, we assume that there is some finite set of rules, following which the developer is guaranteed to receive a safe application at the output.  What is each such rule?  This is a kind of algorithm that describes step by step the developer‚Äôs actions to create a secure application for him.  As we have already agreed, the set of all such algorithms is finite, and, therefore, is enumerable and solvable.  Consider the addition of this set, i.e.  a set of all other theoretically possible algorithms that do not affect the security of the application.  Obviously, it is infinite and includes algorithms based on the fact that they have a very specific nontrivial and invariant property.  And this means that, by the Rice theorem, it is insoluble.  But, since it is not solvable, its addition (that is, the very set of rules for developing a secure application) is not enumerable, according to the Post theorem.  And therefore, to be finite, well, can not. </p><br><p>  If we move from the theoretical plane to the applied one, the concept of managed code and strict type control saves .NET developers from having to think about low-level security problems associated with memory corruption, dereferencing null pointers, format strings, type mixing, etc.  However, all high-level security flaws associated with data preprocessing, access control, and multithreaded access to resources are still possible.  Not to mention the shortcomings of business logic, for which at the moment there is not even an intelligible classification or formal model, and therefore, recommendations on how to avoid them. </p><br><p>  <strong>- What do you think is missing in .NET in terms of security?</strong> </p><br><p>  <strong>Mikhail</strong> : I would like to see a data sanitization process that is more transparent for the developer so that the programmer does not think about the context where this data will be inserted.  This can be partially implemented with the current approach.  For example, the cshtml page parser knows about the context into which the data will be inserted, namely, it knows all the nested grammars of the current node in the parse tree.  This means that he can fully sanitize the data in this context in order to avoid even a theoretical possibility of an injection.  Now the programmer needs to take care of this and choose the correct sanitization algorithm, i.e.  valid encoder call or call sequence. </p><br><p>  Since .NET Core is a completely open project, I hope that my hands will reach at least proof-of-concept-implementation of this idea in the near future.  Or I will be happy if someone from the readers picks up this idea and implements it. </p><br><p>  The next thing is session data protection.  This problem has been known since the ‚Äúbig‚Äù .NET Framework.  In .NET Core, it has somewhat worsened, and the attacker has more opportunities to conduct an Session Fixation attack.  I will talk in detail including about this in a few days in the report <a href="https://dotnext-moscow.ru/2017/msk/talks/56xfqlt2aq44wauewm0u2q/">‚ÄúASP.NET Core: Attack Prevention Mechanisms 2.0‚Äù</a> at DotNext 2017 Moscow. </p><br><p>  And third, in my opinion, ASP.NET-templates by default should impose the best security patterns in writing web applications in order to instill the right approaches in the development of secure systems.  Mostly minor changes are needed, such as enabled and properly configured CSP, protection against CSRF for all POST / PUT / DELETE requests, added security headers to server responses.  But often it is the absence of these little things that can be the cause of a successful attack on your application. </p><br><p>  <strong>Vladimir</strong> : First of all, the elimination of ‚Äúchildhood diseases‚Äù related to safety and stretching from the first versions of the framework.  Take at least the BinarySerializer (used in the same Remoting).  During deserialization, this serializer does not check the expected and deserializable types before instantiation.  This allows an attacker to transfer an arbitrary type to the deserializer, as a result of which the constructor of this type will be executed, all its properties will be filled and its finalizer will be executed later.  This is enough for any application deserializing the input data using the BinarySerializer to be unconditionally exposed to attacks on deleting arbitrary files and SSRF on the SMB server controlled by the attacking SMB server, and also (if certain conditions are met) - and attacks on the execution of arbitrary code: <a href="https://blog.scrt.ch/2016/05/12/net-serialiception/"></a>  <a href="https://blog.scrt.ch/2016/05/12/net-serialiception/">https://blog.scrt.ch/2016/05/12/net-serialiception/</a> .  Nothing prevents the BinarySerializer from implementing a preliminary match of the expected type to the deserialized BEFORE creating the instance.  And the current behavior is optional for backward compatibility. </p><br><p>  If we talk about C #, then, from a security point of view, it lacks the built-in tools of contract programming.  At least at the level at which this is <a href="https://github.com/rsdn/nemerle/wiki/Design-by-contract-macros">implemented</a> in the Nemerle language, where functions can be defined for any method or class, confirming the fulfillment of pre- and post-conditions for the methods or ensuring control of invariants in the case of classes.  In C #, one could go further and allow to define such "strict" methods and classes, marking them with a key word like "strict", for which explicit checks of their contracts would be mandatory.  This would close a significant part of the problems associated with both the disadvantages of data preprocessing and business logic vulnerabilities. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341792/">https://habr.com/ru/post/341792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341774/index.html">Analysis of robots.txt files of the largest sites</a></li>
<li><a href="../341776/index.html">RailsClub 2017. Materials</a></li>
<li><a href="../341778/index.html">How to incorrectly test the performance of NoSQL DB in Amazon</a></li>
<li><a href="../341782/index.html">Let's look into the future: how will the storage infrastructure change?</a></li>
<li><a href="../341790/index.html">Texts that expel the user from the site</a></li>
<li><a href="../341794/index.html">Open broadcast of the main hall HighLoad ++</a></li>
<li><a href="../341796/index.html">IdM implementation. Part 3.1. It is clear that IdM is needed - what next? Goals, Objectives, Stakeholders</a></li>
<li><a href="../341798/index.html">Vue.js tutorial: from jQuery to Vue.js</a></li>
<li><a href="../341800/index.html">Parallels Desktop 13 - seven tips for effective work</a></li>
<li><a href="../341802/index.html">On the issue of documentation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>