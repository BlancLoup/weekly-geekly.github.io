<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Details of the implementation of double buffering in Windows Forms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Much has been written here and here about double buffering. 

 Here you can read how DB is implemented in Java . 

 I will tell how double buffering i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Details of the implementation of double buffering in Windows Forms</h1><div class="post__text post__text-html js-mediator-article">  Much has been written <a href="http://msdn.microsoft.com/ru-ru/library/ms229622.aspx">here</a> and <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B9%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D1%2583%25D1%2584%25D0%25B5%25D1%2580%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">here</a> about double buffering. <br><br>  Here you can read how DB is implemented in <a href="http://habrahabr.ru/post/135700/">Java</a> . <br><br>  I will tell how double buffering is implemented on C #.  Much of what is written here can be read in MSDN, but without implementation details. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Manual double buffering (hereinafter referred to as DB) </h4><br>  For manual double buffering, the .NET Framework provides the following 3 classes: <br><ul><li>  <a href="http://msdn.microsoft.com/ru-ru/library/system.drawing.bufferedgraphics.aspx">BufferedGraphics</a> - provides a buffer for temporary storage of graphics and means of outputting it to the control canvas. </li><li>  <a href="http://msdn.microsoft.com/ru-ru/library/system.drawing.BufferedGraphicsContext">BufferedGraphicsContext</a> - provides creation of a new <b>BufferedGraphics</b> object based on a <b>Graphics</b> object; </li><li>  <a href="http://msdn.microsoft.com/ru-ru/library/system.drawing.bufferedgraphicsmanager.aspx">BufferedGraphicsManager</a> - provides default <b>BufferedGraphicsContext</b> . </li></ul><a name="habracut"></a><br><h5>  BufferedGraphicsManager </h5><br>  The <b>BufferedGraphicsManager</b> class is used to access (through the static <b>Current</b> property) an object of the <b>BufferedGraphicsContext</b> class associated with the current application domain ( <b>AppDomain</b> ).  In fact, <i>Current</i> returns a <b>BufferedGraphicsContext</b> class object created in the static constructor.  Here is the source code of the <b>BufferedGraphicsManager</b> class: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BufferedGraphicsManager</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BufferedGraphicsContext bufferedGraphicsContext; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> BufferedGraphicsContext Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BufferedGraphicsManager.bufferedGraphicsContext; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BufferedGraphicsManager</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { BufferedGraphicsManager.bufferedGraphicsContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedGraphicsContext(); AppDomain.CurrentDomain.ProcessExit += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler(BufferedGraphicsManager.OnShutdown); AppDomain.CurrentDomain.DomainUnload += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler(BufferedGraphicsManager.OnShutdown); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnShutdown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { BufferedGraphicsManager.Current.Invalidate(); } }</code> </pre> <br>  From this code, you can see that the object of the class <b>BufferedGraphicsContext</b> stored inside the <b>BufferedGraphicsManager</b> is destroyed when the current application domain is unloaded. <br><br><h5>  BufferedGraphicsContext </h5><br>  <b>BufferedGraphicsContext</b> provides the creation (and also destruction) of a new <b>BufferedGraphics</b> instance based on the <b>Graphics</b> object, providing for this a single <i><a href="http://msdn.microsoft.com/en-us/library/ms141960(v%3Dvs.80).aspx">Allocate</a></i> method: <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetRectangle.Width * targetRectangle.Height &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MaximumBuffer.Width * <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.MaximumBuffer.Height) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllocBufferInTempManager(targetGraphics, IntPtr.Zero, targetRectangle); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.AllocBuffer(targetGraphics, IntPtr.Zero, targetRectangle); }</code> </pre>  The method takes as a parameter a <b>Graphics</b> object and an area on it for which you want to create a buffer. <br>  If the area of ‚Äã‚Äãthis area does not exceed the area specified by the <i>MaximumBuffer</i> property, the <i>AllocBuffer</i> method is <i>called</i> and the resulting <b>BufferedGraphics</b> object is returned.  The <i>AllocBuffer</i> method creates inside of itself (using the <i>CreateBuffer</i> method described below), a new offscreen graph, wraps it in <b>BufferedGraphics</b> , saves it into a variable of the <i>buffer</i> object and returns it.  This variable is used to further, when destroying an instance of <b>BufferedGraphicsContext</b> (using the <i>Dispose</i> method), to destroy the associated instance of <b>BufferedGraphics</b> . <br>  The creationBuffer method is responsible for creating an offscreen (i.e., stored only in memory without displaying on the screen) of the <b>Graphics</b> <i>instance</i> .  Using the native function <i><a href="http://msdn.microsoft.com/en-us/library/dd183494%2528v%3DVS.85%2529.aspx">CreateDIBSection, it</a></i> creates a ‚Äúhardware-independent bitmap‚Äù (DIB), on the basis of which it creates a new <b>Graphics</b> object, and returns it as a result. <br><br>  If the area of ‚Äã‚Äãthe transferred area exceeds the <i>MaximumBuffer</i> area, then the <i>AllocBufferInTempManager</i> method is <i>called</i> , the source code of which is given below: <br><pre> <code class="hljs ruby">private BufferedGraphics AllocBufferInTempManager(Graphics targetGraphics, IntPtr targetDC, Rectangle targetRectangle) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">""</span></span>  var bufferedGraphicsContext= new BufferedGraphicsContext(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      (graphics),    ( context)  /<span class="hljs-regexp"><span class="hljs-regexp">/     var bufferedGraphics = bufferedGraphicsContext.AllocBuffer(targetGraphics, targetDC, targetRectangle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   ,   bufferedGraphics /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ bufferedGraphicsContext: bufferedGraphics.DisposeContext = true; return bufferedGraphics; }</span></span></code> </pre><br>  From this code, you can see that inside the <i>AllocBufferInTempManager</i> method, a new instance of <b>BufferedGraphicsContext is created</b> , in which the <i>AllocBuffer</i> method is <i>called</i> , and the resulting <b>BufferedGraphics is</b> returned as a result.  Moreover, the temporary <b>BufferedGraphicsContext</b> object created is not immediately destroyed, but only when the <b>BufferedGraphics</b> created by it is destroyed.  For this, <b>BufferedGraphics</b> keeps a reciprocal link to its creator, and when destroyed, if the <i>DisposeContext</i> property is <i>true</i> , it takes it with itself. <br><br><h5>  BufferedGraphics </h5><br>  The <b>BufferedGraphics</b> class is very small.  Its source code takes a little more than 100 lines.  It is a simple wrapper over a <b>Graphics</b> object, and provides a Render method for copying it onto another <b>Graphics</b> : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Graphics target</span></span></span><span class="hljs-function">)</span></span></code> </pre><br>  Copying is done by the native BitBlt function. <br><br><h4>  Automatic db </h4><br>  The simplest way to use db to render a control is to turn on automatic db for the desired control: <br><pre> <code class="hljs objectivec">control.DoubleBuffered = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre>  or <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">control</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetStyle</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ControlStyles</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.OptimizedDoubleBuffer</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>);</code> </pre><br>  Consider what happens to the control when we enable automatic DB for it.  The <i>DoubleBuffered</i> property, as well as the <i>SetStyle</i> method, is located in the <b>Control</b> class.  Let's look at the source code of this class.  The code for the <i>DoubleBuffered</i> property looks like this: <br><pre> <code class="hljs cs"> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DoubleBuffered { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.OptimizedDoubleBuffer); } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> != <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DoubleBuffered) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.OptimizedDoubleBuffer, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetStyle(ControlStyles.OptimizedDoubleBuffer, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } }</code> </pre><br>  As you can see from this code snippet, the above 2 ways of including dBs do not differ from each other, except that the <i>ControlStyles.AllPaintingInWmPaint</i> flag is set in the <i>DoubleBuffered</i> setter.  But since this flag is also set in the constructor of the control <a href="https://habr.com/ru/post/144294/"><sup>1</sup></a> , then if you did not reset it manually, both of these methods have the same effect. <br>  From the source code of the <b>Control</b> class, you can also see that the <i>ControlStyles.AllPaintingInWmPaint</i> flag is checked only inside the private <i>WmEraseBkgnd</i> method (and is set only in the constructor and setter of the <i>DoubleBuffered</i> property), which is responsible for processing the <i><b>WM_ERASEBKGND</b></i> <a href="https://habr.com/ru/post/144294/"><sup>2</sup></a> system message, and when it is received, it draws the background of the control.  Here is its implementation: <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WmEraseBkgnd</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Message m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.UserPaint) &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.AllPaintingInWmPaint)) { ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (PaintEventArgs e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PaintEventArgs(wparam, ClientRect)) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PaintWithErrorHandling(e, (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>); } ... }</code> </pre><br>  This shows that if the <i>AllPaintingInWmPaint</i> flag <i>is</i> NOT set, then when the window <i><b>receives a WM_ERASEBKGND</b></i> message, it calls the <i>PaintWithErrorHandling</i> method, with the <i>layer</i> parameter equal to 1 <a href="https://habr.com/ru/post/144294/"><sup>3</sup></a> , which in turn causes the redrawing of the background of the control <a href="https://habr.com/ru/post/144294/"><sup>4</sup></a> . <br><br>  It is also worth considering the <i>ControlStyles.UserPaint</i> flag.  This flag indicates that the contents of the control will be rendered by the Framework .NET tools, and not by the system tools.  For example, if you specify a background image for your form, and <i>reset the UserPaint</i> flag, the picture will not be drawn. <br><br>  The main actions on DB are deployed inside the <i>WmPaint</i> method.  This method is responsible for processing the <i><b>WM_PAINT</b></i> system message, which arrives when a section of the control needs to be redrawn.  The <i>WmPaint</i> method is private and only called from the <i>WndProc</i> method, provided that the <i>ControlStyles.UserPaint</i> flag is set: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WndProc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Message m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (m.Msg) { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_PAINT: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.UserPaint)) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WmPaint(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> m); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... } }</code> </pre><br>  If we omit the details not related to the DB, the implementation of the <i>WmPaint</i> method is as follows: <br><pre> <code class="hljs coffeescript">private void WmPaint(ref Message m) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DoubleBuffered || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.AllPaintingInWmPaint) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DoubleBufferingEnabled) { IntPtr num; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Graphics Rectangle rectangle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  num  rectangle... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rectangle.Width &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; rectangle.Height &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { Rectangle clientRectangle = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ClientRectangle; using (BufferedGraphics bufferedGraphics = BufferedGraphicsManager.Current.Allocate(num, clientRectangle)) { Graphics graphics = bufferedGraphics.Graphics; graphics.SetClip(rectangle); System.Drawing.Drawing2D.GraphicsState gstate = graphics.Save(); using (PaintEventArgs e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PaintEventArgs(graphics, rectangle)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PaintWithErrorHandling(e, (short) <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); graphics.Restore(gstate); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.PaintWithErrorHandling(e, (short) <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); bufferedGraphics.Render(); } } } ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ... } }</code> </pre><br>  As can be seen from the above code snippet, in order for graphics to be drawn with <i>db, DoubleBuffered should</i> be <i>true</i> , or <i>ControlStyles</i> flag should be set. <i>AllPaintingInWmPaint</i> ( <i>DoubleBufferingEnabled is</i> not taken into account because it is always <i>true</i> <a href="https://habr.com/ru/post/144294/"><sup>5 here</sup></a> ). <br><br>  Next, using the default BufferedGrpahicsContext, a graphic buffer is created. <br>  It sets a draw rectangle equal to the area for which a redraw is required and the current state is saved. <br>  After that, the OnBackgroundPaint and OnPaint methods are called for it through a call to the PaintWithErrorHandling <a href="https://habr.com/ru/post/144294/"><sup>3</sup></a> method, and the resulting image is copied into the graphics control. <br><br>  As it can be seen, the same DB method is used for automatic buffering as for manual one. <br><br><br><hr><br><br><a name="1"></a>  1. A fragment of the source code of the <b>Control</b> class constructor in which the <i>ControlStyles</i> flags are set: <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Control</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> autoInstallSyncContext</span></span></span><span class="hljs-function">)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetStyle(ControlStyles.UserPaint | ControlStyles.StandardClick | ControlStyles.Selectable | ControlStyles.StandardDoubleClick | ControlStyles.AllPaintingInWmPaint | ControlStyles.UseTextForAccessibility, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); ... }</code> </pre><br><a name="2"></a>  2. The <b><i>WM_ERASEBKGND</i></b> message arrives when the control is resized.  Source code fragment in which the <b><i>WM_ERASEBKGND</i></b> message is <b><i>processed</i></b> : <br><pre> <code class="hljs cs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WndProc</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Message m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (m.Msg) { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> WM_ERASEBKGND: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.WmEraseBkgnd(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> m); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... } }</code> </pre><br><a name="3"></a>  3. Implementation of the PaintWithErrorHandling method: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PaintWithErrorHandling</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PaintEventArgs e, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">short</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer</span></span></span><span class="hljs-function">)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (layer) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.Opaque)) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnPaintBackground(e); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">short</span></span>) <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnPaint(e); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ... }</code> </pre><br><a name="4"></a>  4. The background of the control is not redrawn if the <i>ControlStyles.Opaque</i> flag is set. <br><br><a name="5"></a>  5. Private property <i>DoubleBufferingEnabled</i> , has the following implementation: <br><pre> <code class="hljs kotlin"> bool DoubleBufferingEnabled { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStyle(ControlStyles.UserPaint | ControlStyles.DoubleBuffer); } }</code> </pre>  Since the WmPaint method is called only if the <i>ControlStyles.UserPaint</i> flag is set, <i>DoubleBufferingEnabled</i> will always be <i>true here</i> .  And since it is closed and is not checked anywhere except <i>WmPaint</i> , its purpose is not clear. </div><p>Source: <a href="https://habr.com/ru/post/144294/">https://habr.com/ru/post/144294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144289/index.html">Antitrust investigation against google</a></li>
<li><a href="../144290/index.html">Diskless iSCSI boot</a></li>
<li><a href="../144291/index.html">Adaptive layout: CSS & JS framework Skeleton</a></li>
<li><a href="../144292/index.html">The standard for wireless communications on the human body</a></li>
<li><a href="../144293/index.html">SIPML5 - SIP client for a browser based on WebRTC</a></li>
<li><a href="../144295/index.html">Microsoft Research Team Breaks World Sorting Record</a></li>
<li><a href="../144297/index.html">Pro Correct Tools</a></li>
<li><a href="../144300/index.html">Entropy - Inaccurate programming language</a></li>
<li><a href="../144301/index.html">Loading and storing data in an application with a complex database structure</a></li>
<li><a href="../144302/index.html">How to do several things at the same time and at the same time in turn?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>