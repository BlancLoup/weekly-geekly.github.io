<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a web service on Go (part one)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I would like to tell you how you can quickly and easily write a small web application in the Go language, which, despite its young ag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a web service on Go (part one)</h1><div class="post__text post__text-html js-mediator-article">  In this article, I would like to tell you how you can quickly and easily write a small web application in the Go language, which, despite its young age, managed to win favor with many developers.  Usually, for such articles they write artificial applications, such as the TODO sheet.  We will try to write something useful that already exists and is used. <br><br>  Often, when developing services, you need to understand what data is sent to another service, and the ability to capture traffic is not always there.  And just to catch such requests, there is a project <a href="http://requestb.in/">requestb.in</a> , which allows you to collect requests on a specific URL and display them in the web interface.  Writing a similar application, we will do.  To simplify a task a little, let's take some framework, for example <a href="http://martini.codegangsta.io/">Martini</a> , as a basis. <br><br>  In the end, we should have a service like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img align="left" src="https://habrastorage.org/getpro/habr/post_images/a18/13a/db9/a1813adb9fcbbd5f30549ad4d0429b8f.png"><br><br><a name="habracut"></a><br><br><h4>  Training </h4><br>  This article will be divided into steps, each of which will contain code stored in a separate repository branch on GitHub.  You can always run and see the results, as well as play around with the code. <br>  To run the application, you need to have Go compiler on your machine.  I proceed from the assumption that you already have it and are configured as you like.  If not, then you can find out how to do this <a href="http://golang.org/doc/install">on the project page</a> . <br>  As a development environment, you can use what is more convenient for you, thank you. Go plugins are available for almost every editor.  <a href="https://github.com/DisposaBoy/GoSublime">GoSublime is</a> most popular.  But I would advise IntelijIdea + <a href="http://plugins.jetbrains.com/plugin/5047">go-lang-ide-plugin</a> , which has recently been very actively developing, for example, from the last added application debug. <br><br>  You can try the ready-made service at work via the link <a href="http://skimmer.tulu.la/">skimmer.tulu.la</a> . <br><br>  To get started, you need to clone the repository to your machine in any directory, like this: <br><br><pre><code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/m0sth8/skimmer ./skimmer</code> </pre> <br>  You can add a project to your work environment (you can read more about this on <a href="http://golang.org/doc/code.html">the project website</a> ), or arrange the code as you like.  For simplicity, I use <a href="https://github.com/pwoolcoc/goenv">goenv</a> , which allows you to specify the go compiler versions and create a clean working environment in the project directory. <br><br>  Now we need to go to the skimmer's cloned directory and install the necessary dependencies with the command: <br><br><pre> <code class="bash hljs">go get -d ./src/</code> </pre><br>  After the dependency installation is complete, you can run the project: <br><br><pre> <code class="bash hljs">go run ./src/main.go</code> </pre><br>  You should start the web service on port 3000 (the port and the host can be specified via the PORT and HOST environment variables, respectively).  Now you can open it in the browser at 127.0.0.1.1000 and try the ready-made service at work. <br><br>  Ahead of us are the following stages: <br><ol><li>  Step one.  Meet Martini; </li><li>  Step two.  Create a Bin model and respond to requests; </li><li>  Step three.  We accept requests and save them in storage; </li><li>  Step Four.  But what about the tests? </li><li>  Step five - decorations and a web interface; </li><li>  Step Six.  Add a bit of privacy; </li><li>  Step Seven.  We clear the unnecessary; </li><li>  Step Eight.  Use Redis for storage. </li></ol><br><br>  Special thanks to <a href="https://habrahabr.ru/users/kavu/" class="user_link">kavu</a> for correcting the first and second parts of the article. <br><br>  Let's start the development. <br><br><h4>  Step one.  Meet the Martini. </h4><br>  Load the first step code: <br><br><pre> <code class="hljs vbscript">git checkout <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span></code> </pre><br>  To get started, just try to print the request that comes to us.  The entry point to any Go application is the main function of the main package.  Create the main.go file in the src directory.  Martini already has an application stub that adds logs, error handling, recovery, and a router;  and in order not to repeat, we will use it. <br><br>  Martini itself is pretty simple: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Martini represents the top level web application. inject.Injector methods can be invoked to map services on a global level. type Martini struct { inject.Injector handlers []Handler action Handler logger *log.Logger }</span></span></code> </pre><br>  It implements the <a href="http/">http.Handler</a> interface by implementing the ServeHTTP method.  Further, all incoming requests are passed through various handlers stored in handlers and at the end executes Handler action. <br><br>  Classic Martini: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Classic creates a classic Martini with some basic default middleware - martini.Logger, martini.Recovery, and martini.Static. func Classic() *ClassicMartini { r := NewRouter() m := New() m.Use(Logger()) m.Use(Recovery()) m.Use(Static("public")) m.Action(r.Handle) return &amp;ClassicMartini{m, r} }</span></span></code> </pre><br>  In this constructor, an object of type Martini and Router is created, handler handlers are added via the martini.Use method to request logging, intercept panic ( <a href="http://blog.golang.org/defer-panic-and-recover">more</a> about this mechanism), return static, and the last action sets the handler of the router. <br><br>  We will intercept any HTTP requests to our application using the <code>Any</code> method from the router, intercepting any URLs and methods.  The router interface is described in Martini like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Router <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Get adds a route for a HTTP GET request to the specified matching pattern. Get(string, ...Handler) Route // Patch adds a route for a HTTP PATCH request to the specified matching pattern. Patch(string, ...Handler) Route // Post adds a route for a HTTP POST request to the specified matching pattern. Post(string, ...Handler) Route // Put adds a route for a HTTP PUT request to the specified matching pattern. Put(string, ...Handler) Route // Delete adds a route for a HTTP DELETE request to the specified matching pattern. Delete(string, ...Handler) Route // Options adds a route for a HTTP OPTIONS request to the specified matching pattern. Options(string, ...Handler) Route // Any adds a route for any HTTP method request to the specified matching pattern. Any(string, ...Handler) Route // NotFound sets the handlers that are called when a no route matches a request. Throws a basic 404 by default. NotFound(...Handler) // Handle is the entry point for routing. This is used as a martini.Handler Handle(http.ResponseWriter, *http.Request, Context) }</span></span></code> </pre><br>  If you really want to - you can implement your implementation of the address handler, but we will use the one that goes to Martini by default. <br><br>  The first parameter is the location.  Locations in Martini support parameters via <code>":param"</code> , regular expressions, as well as <a href="http://en.wikipedia.org/wiki/Glob_(programming)">glob</a> .  The second parameter and the following ones take the function that will handle the request.  Since Martini supports a chain of handlers, you can add various auxiliary handlers here, such as checking access rights.  We still have nothing to do with it, so we will add only one handler with an interface that is processed by the usual Go web handler (an example of development on it can be found <a href="http://golang.org/doc/articles/wiki/">in the documentation</a> ).  Here is the code of our handler: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { api := martini.Classic() api.Any(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res http.ResponseWriter, req *http.Request,)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dumped, err := httputil.DumpRequest(req, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { res.WriteHeader(<span class="hljs-number"><span class="hljs-number">200</span></span>) res.Write(dumped) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { res.WriteHeader(<span class="hljs-number"><span class="hljs-number">500</span></span>) fmt.Fprintf(res, <span class="hljs-string"><span class="hljs-string">"Error: %v"</span></span>, err) } }) api.Run() }</code> </pre><br>  Using the ready-made <a href="httputil/">DumpRequest</a> function from the <a href="httputil/">httputil</a> package <a href="httputil/">,</a> we preserve the structure of the http.Request request, and write it in the http.ResponseWriter response.  Just do not forget to handle possible errors.  The api.Run function simply starts the built-in go server from the standard library, specifying the port and host it takes from the PORT (3000 by default) and HOST environment parameters. <br><br>  Run our first application: <br><br><pre> <code class="bash hljs">go run ./src/main.go</code> </pre><br>  Let's try to send a request to the server: <br><pre> <code class="bash hljs">&gt; curl -X POST -d <span class="hljs-string"><span class="hljs-string">"fizz=buzz"</span></span> http://127.0.0.1:3000 POST / HTTP/1.1 Host: 127.0.0.1:3000 Accept: */* Content-Type: application/x-www-form-urlencoded User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8y zlib/1.2.5 fizz=buzz</code> </pre><br><br>  It was just a test of strength, now let's start writing this application. <br><br><h4>  Step two.  Create a Bin model and respond to requests. </h4><br><br>  Do not forget to download the code: <br><br><pre> <code class="hljs vbscript">git checkout <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-2</span></span></code> </pre><br><br>  Placing the code inside the main package is not very correct, because, for example, <a href="https://developers.google.com/appengine/docs/go/">Google Application Engine</a> creates its main package, in which yours are already connected.  Therefore, we move the creation of the API into a separate module, let's call it, for example, skimmer / api.go. <br><br>  Now we need to create an entity in which we can store captured requests, let's call it Bin, by analogy with requestbin.  With the model, we will have just the usual Go data structure. <blockquote>  The order of the fields in the structure is quite important, but we will not think about it, but those who want to know how order affects the size of the structure in memory can read these articles here - <a href="http://www.goinggo.net/2013/07/understanding-type-in-go.html">www.goinggo.net/2013/07/understanding-type-in -go.html</a> and <a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing</a> . </blockquote><br><br>  So, our Bin model will contain fields with the name, the number of requests caught, and the dates of creation and modification.  Each field is also described by a tag. <br><blockquote>  Tags are normal lines that do not affect the program as a whole, but you can read them using the package of reflection while the program is running (so-called introspection), and based on this, change your behavior (about how to work with tags through <a href="http://golang.org/pkg/reflect/">reflection</a> ).  In our example, the json package takes the tag value into account when encoding / decoding, something like this: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"reflect"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Bin <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { bin := Bin{} bt := reflect.TypeOf(bin) field := bt.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Field's '%s' json name is '%s'"</span></span>, field.Name, field.Tag.Get(<span class="hljs-string"><span class="hljs-string">"json"</span></span>)) }</code> </pre><br><br>  Will output <br> <code>Field's 'Name' json name is 'name'</code> <br> <br>  The encoding / json package supports various options when generating tags: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   Field int `json:"-"` //  json     myName Field int `json:"myName"`</span></span></code> </pre><br><br>  The second parameter may be, for example, the omitempty option - if the value in json is omitted, the field is not filled.  So for example, if the field is a link, we can find out if it is in the json object by comparing it with nil.  You can read more about json serialization in the <a href="http://golang.org/pkg/encoding/json/">documentation.</a> </blockquote><br>  We also describe the auxiliary function NewBin, in which the values ‚Äã‚Äãof the Bin object are initialized (a kind of constructor): <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Bin <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"name"`</span></span> Created <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`json:"created"`</span></span> Updated <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> <span class="hljs-string"><span class="hljs-string">`json:"updated"`</span></span> RequestCount <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-string"><span class="hljs-string">`json:"requestCount"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bin</span></span></span></span> { now := time.Now().Unix() bin := Bin{ Created: now, Updated: now, Name: rs.Generate(<span class="hljs-number"><span class="hljs-number">6</span></span>), } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;bin }</code> </pre><br><br><blockquote>  Structures in Go can be initialized in two ways: <br><br>  1) Mandatory listing of all fields in order: <br><br><pre> <code class="go hljs">Bin{rs.Generate(<span class="hljs-number"><span class="hljs-number">6</span></span>), now, now, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre><br>  2) Indicating the fields for which values ‚Äã‚Äãare assigned: <br><br><pre> <code class="go hljs">Bin{ Created: now, Updated: now, Name: rs.Generate(<span class="hljs-number"><span class="hljs-number">6</span></span>), }</code> </pre><br>  Fields that are not specified accept default values.  For example, for integers it will be 0, for strings - the empty string "", for links, channels, arrays, slices and dictionaries - this will be nil.  Read more in the <a href="http://golang.org/ref/spec">documentation</a> .  The main thing to remember is that you cannot mix these two types of initialization. </blockquote><br><br>  Now in more detail about generation of lines through object rs.  It is initialized as follows: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rs = NewRandomString(<span class="hljs-string"><span class="hljs-string">"0123456789abcdefghijklmnopqrstuvwxyz"</span></span>)</code> </pre><br>  The code itself is in the utils.go file.  In the function, we pass an array of characters from which we need to generate a string and create a RandomString object: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> RandomString <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { pool <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> rg *rand.Rand } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRandomString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pool </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RandomString</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;RandomString{ pool, rand.New(rand.NewSource(time.Now().Unix())), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rs *RandomString)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(length </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> length &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } b := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, length) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, _ := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> b { b[i] = rs.pool[rs.rg.Intn(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(rs.pool))] } r = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br>  Here we use the <a href="http://golang.org/pkg/math/rand">math / rand</a> package, which gives us access to random number generation.  Most importantly, sow the generator before starting work with it, so that we do not get the same sequence of random numbers with each launch. <br><br>  In the Generate method, we create an array of bytes, and each of the bytes is filled with a random character from the string pool.  The resulting string is returned. <br><br>  Let us proceed, in fact, to the description of Api.  To begin, we need three methods for working with objects of type Bin, displaying a list of objects, creating and obtaining a specific object. <br>  Earlier, I wrote that martini accepts a handler function with the HandlerFunc interface, in fact, the received function in Martini is described as interface {} - that is, it can be absolutely any function.  How are arguments inserted into this function?  This is done with the help of a well-known pattern - <a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency injection</a> (hereinafter DI) with the help of a small <a href="https://github.com/codegangsta/inject/">inject</a> package from the author martini.  I will not go into details regarding how this is done, you can look into the code yourself, since it‚Äôs not great and everything is pretty simple.  But if in two words, with the help of the already mentioned package reflect, the types of the function arguments are obtained and after that the necessary objects of this type are substituted.  For example, when inject sees the type * http.Request, it substitutes the object req * http.Request in this parameter. <br>  We can add the necessary objects ourselves for reflection through the methods of the Map and MapTo object globally, or through the martini.Context request context object for each request separately. <br><br>  We will declare temporary variables history and bins, the first will contain the history of the Bin objects we created, and the second will be a certain short version of the Bin object storage. <br>  Now consider the created methods. <br><br><h5>  Creating a Bin Object </h5><br><pre> <code class="go hljs"> api.Post(<span class="hljs-string"><span class="hljs-string">"/api/v1/bins/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r render.Render)</span></span></span></span>{ bin := NewBin() bins[bin.Name] = bin history = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(history, bin.Name) r.JSON(http.StatusCreated, bin) })</code> </pre><br><h5>  Getting a list of Bin objects </h5><br><pre> <code class="go hljs"> api.Get(<span class="hljs-string"><span class="hljs-string">"/api/v1/bins/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r render.Render)</span></span></span></span>{ filteredBins := []*Bin{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, name := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>(history) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin, ok := bins[name]; ok { filteredBins = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(filteredBins, bin) } } r.JSON(http.StatusOK, filteredBins) })</code> </pre><br><h5>  Getting a specific instance </h5><br><pre> <code class="go hljs"> api.Get(<span class="hljs-string"><span class="hljs-string">"/api/v1/bins/:bin"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r render.Render, params martini.Params)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin, ok := bins[params[<span class="hljs-string"><span class="hljs-string">"bin"</span></span>]]; ok{ r.JSON(http.StatusOK, bin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.Error(http.StatusNotFound) } })</code> </pre><br>  The method allows you to get the Bin object by its name, in it we use the martini.Params object (in fact, simply map [string] string), through which we can access the parsed address parameters. <br><blockquote>  In Go, we can access the dictionary element in two ways: <br><ol><li>  By requesting the value of the key <code>a := m[key]</code> , in this case either the key value in the dictionary, if any, or the default value of the initialization of the value type is returned.  Thus, for example for numbers, it is difficult to understand whether the key contains 0 or just the value of this key does not exist.  Therefore, the second option is provided for in go. </li><li>  In this way, by requesting by key and get its value by the first parameter and the indicator of the existence of this key by the second parameter - <code>a, ok := m[key]</code> </li></ol><br></blockquote><br>  Let's experiment with our application.  First, run it: <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> run ./src/main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span></code> </pre><br>  Add a new Bin object: <br><br><pre> <code class="hljs pgsql">&gt; curl -i -X POST "127.0.0.1:3000/api/v1/bins/" HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">201</span></span> Created Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: application/<span class="hljs-type"><span class="hljs-type">json</span></span>; charset=UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>: Mon, <span class="hljs-number"><span class="hljs-number">03</span></span> Mar <span class="hljs-number"><span class="hljs-number">2014</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">38</span></span> GMT Content-Length: <span class="hljs-number"><span class="hljs-number">76</span></span> {"name":"7xpogf","created":<span class="hljs-number"><span class="hljs-number">1393819838</span></span>,"updated":<span class="hljs-number"><span class="hljs-number">1393819838</span></span>,"requestCount":<span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre><br>  Get a list of available Bin objects: <br><br><pre> <code class="hljs pgsql">&gt; curl -i "127.0.0.1:3000/api/v1/bins/" HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: application/<span class="hljs-type"><span class="hljs-type">json</span></span>; charset=UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>: Mon, <span class="hljs-number"><span class="hljs-number">03</span></span> Mar <span class="hljs-number"><span class="hljs-number">2014</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span> GMT Content-Length: <span class="hljs-number"><span class="hljs-number">78</span></span> [{"name":"7xpogf","created":<span class="hljs-number"><span class="hljs-number">1393819838</span></span>,"updated":<span class="hljs-number"><span class="hljs-number">1393819838</span></span>,"requestCount":<span class="hljs-number"><span class="hljs-number">0</span></span>}]</code> </pre><br>  Request a specific Bin object by taking the name value from the previous query: <br><br><pre> <code class="hljs pgsql">curl -i "127.0.0.1:3000/api/v1/bins/7xpogf" HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> OK Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: application/<span class="hljs-type"><span class="hljs-type">json</span></span>; charset=UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>: Mon, <span class="hljs-number"><span class="hljs-number">03</span></span> Mar <span class="hljs-number"><span class="hljs-number">2014</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> GMT Content-Length: <span class="hljs-number"><span class="hljs-number">76</span></span> {"name":"7xpogf","created":<span class="hljs-number"><span class="hljs-number">1393819838</span></span>,"updated":<span class="hljs-number"><span class="hljs-number">1393819838</span></span>,"requestCount":<span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre><br>  Great, now we have learned how to create models and respond to inquiries, it seems now nothing will keep us from completing everything else. <br><br><h4>  Step three.  We accept requests and save them in storage. </h4><br>  Now we need to learn how to save requests that come to us in the desired Bin object. <br><br>  Download the code for the third step. <br><pre> <code class="hljs vbscript">git checkout <span class="hljs-keyword"><span class="hljs-keyword">step</span></span><span class="hljs-number"><span class="hljs-number">-3</span></span></code> </pre><br><h5>  Model Request </h5><br>  To begin, create a model that will store an HTTP request. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Request struct { Id string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"id"` Created int64 `<span class="hljs-type"><span class="hljs-type">json</span></span>:"created"` <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"method"` // <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span>, POST, PUT, etc. Proto string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"proto"` // "HTTP/1.0" <span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> http.<span class="hljs-keyword"><span class="hljs-keyword">Header</span></span> `<span class="hljs-type"><span class="hljs-type">json</span></span>:"header"` ContentLength int64 `<span class="hljs-type"><span class="hljs-type">json</span></span>:"contentLength"` RemoteAddr string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"remoteAddr"` Host string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"host"` RequestURI string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"requestURI"` Body string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"body"` FormValue map[string][]string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"formValue"` FormFile []string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"formFile"` }</code> </pre><br>  I think it makes no sense to explain what kind of field it is for, but there are a couple of notes: for the files we will store only their names, and for the form data, we will store the ready dictionary of meanings. <br><br>  By analogy with the creation of the Bin object, we write the function that creates the Request object from the HTTP request: <br><br><pre> <code class="hljs lua">func NewRequest(httpRequest *http.Request, maxBodySize int) *Request { var ( bodyValue <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> formValue map[<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>][]<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> formFile []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ) //             <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> body, err := ioutil.ReadAll(httpRequest.Body); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(body) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; maxBodySize != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> maxBodySize == <span class="hljs-number"><span class="hljs-number">-1</span></span> || httpRequest.ContentLength &lt; int64(maxBodySize) { bodyValue = <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(body) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { bodyValue = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%s\n&lt;&lt;&lt;TRUNCATED , %d of %d"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(body[<span class="hljs-number"><span class="hljs-number">0</span></span>:maxBodySize]), maxBodySize, httpRequest.ContentLength) } } httpRequest.Body = ioutil.NopCloser(bytes.NewBuffer(body)) defer httpRequest.Body.Close() } httpRequest.ParseMultipartForm(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> httpRequest.MultipartForm != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { formValue = httpRequest.MultipartForm.Value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key := range httpRequest.MultipartForm.File { formFile = append(formFile, key) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { formValue = httpRequest.PostForm } request := Request{ Id: rs.Generate(<span class="hljs-number"><span class="hljs-number">12</span></span>), Created: <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>.Now().Unix(), Method: httpRequest.Method, Proto: httpRequest.Proto, Host: httpRequest.Host, Header: httpRequest.Header, ContentLength: httpRequest.ContentLength, RemoteAddr: httpRequest.RemoteAddr, RequestURI: httpRequest.RequestURI, FormValue: formValue, FormFile: formFile, Body: bodyValue, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;request }</code> </pre><br>  The function turned out to be quite large, but in general, understandable, I will explain only some of the points.  In the <a href="http/">http.Request</a> object, the request body - Body is a kind of buffer that implements the <a href="http://golang.org/pkg/io/">io.ReadCloser</a> interface; for this reason, after parsing the form (a call to the ParseMultipartForm method), we can‚Äôt get the raw request data.  Therefore, for starters, we copy the Body into a separate variable and then replace the original buffer with our own.  Next, we invoke the parsing of incoming data and collect information about the values ‚Äã‚Äãof the forms and files. <br><br>  In addition to the Bin objects, now we also need to store the requests, so it's time to add the ability to store data in our project.  We describe its interface in the file storage.go: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Storage</span></span></span><span class="hljs-class"> interface { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupBin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) (*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">one</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">element</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupBins</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">names</span></span></span><span class="hljs-class"> []</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) ([]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slice</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">elements</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binName</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">) (*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">LookupRequests</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binName</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class">) ([]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class">) // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">slice</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">from</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">by</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">position</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateBin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">storage</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UpdateBin</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> // </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">save</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CreateRequest</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">req</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">error</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br><blockquote>  The interfaces in Go are a contract linking the expected functionality and the actual implementation.  In our case, we described the storage interface, which we will use later in the program, but depending on the settings, the implementation may be completely different (for example, it may be Redis or Mongo).  Learn more about <a href="http://golangtutorials.blogspot.com/2011/06/interfaces-in-go.html">interfaces</a> . </blockquote><br>  In addition, we will create a basic storage object, which will have auxiliary fields that we will need in each implementation: <br><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseStorage</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> maxRequests int }</code> </pre><br>  Now it's time to implement the behavior of our storage interface.  To begin with, we will try to store everything in memory, delimiting parallel access to data by <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D0%25BA%25D1%2581">mutexes</a> . <br><br>  Create a memory.go file. Our storage will be based on a simple data structure: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MemoryStorage</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BaseStorage</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sync</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RWMutex</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">binRecords</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinRecord</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  It consists of nested, anonymous BaseStorage and sync.RWMutex fields. <blockquote>  Anonymous fields enable us to call methods and fields of anonymous structures directly.  For example, if we have a variable obj of type MemoryStorage, we can access the maxRequests field directly obj.BaseStorage.maxRequests, or as if they are members of the MemoryStorage obj.maxRequests itself.  More information about anonymous fields in data structures can be found in the <a href="http://golangtutorials.blogspot.com/2011/06/anonymous-fields-in-structs-like-object.html">documentation</a> . </blockquote><br>  We need <a href="http://golang.org/pkg/sync/">RWMutex</a> to block simultaneous work with the binRecords dictionary, since Go does not guarantee the correct behavior when changing data in dictionaries in parallel. <br><br>  The data itself will be stored in the binRecords field, which is a dictionary with the keys from the name Bin field of objects and data of the BinRecord type. <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinRecord</span></span></span><span class="hljs-class"> struct { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bin</span></span></span><span class="hljs-class"> *</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requests</span></span></span><span class="hljs-class"> []*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">requestMap</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class">]*</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Request</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  This structure contains all the necessary data.  References to queries are stored in two fields, in the list, where they go in the order of addition and in the dictionary, for faster search by identifier. <br><blockquote>  Dictionaries in Go in the current implementation are a hash of the table, so searching for an element in the dictionary has a constant value.  More information about the internal device can be found in this <a href="http://www.goinggo.net/2013/12/macro-view-of-map-internals-in-go.html">excellent article</a> . </blockquote><br>  Also, for the BinRecord object, a method is implemented for trimming unnecessary requests, which simply removes unnecessary elements from requests and requestMap. <br><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(binRecord *BinRecord)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShrinkRequests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(binRecord.requests) &gt; size { requests := binRecord.requests lenDiff := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(requests) - size removed := requests[:lenDiff] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, removedReq := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> removed { <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(binRecord.requestMap, removedReq.Id) } requests = requests[lenDiff:] binRecord.requests = requests } }</code> </pre><br>  All MemoryStorage methods implement the behavior of the Storage interface, and we also have a getBinRecord helper method in which we can read the record we need.  At the moment when we read the record, we put the lock on the read and immediately indicate the deferred call of the unlock in the defer.  The defer expression allows us to specify a function that will always be executed when the function completes, even if the function was interrupted by panic.  You can read more about defer in the <a href="http://blog.golang.org/defer-panic-and-recover">documentation.</a> <br><br>  It makes no sense to examine each MemoryStorage method in more detail, everything is not so difficult there, you can look into the code yourself. <br><br><div class="spoiler">  <b class="spoiler_title">MemoryStorage code</b> <div class="spoiler_text"><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> skimmer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MemoryStorage <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { BaseStorage sync.RWMutex binRecords <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*BinRecord } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BinRecord <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { bin *Bin requests []*Request requestMap <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Request } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(binRecord *BinRecord)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShrinkRequests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> size &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(binRecord.requests) &gt; size { requests := binRecord.requests lenDiff := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(requests) - size removed := requests[:lenDiff] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, removedReq := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> removed { <span class="hljs-built_in"><span class="hljs-built_in">delete</span></span>(binRecord.requestMap, removedReq.Id) } requests = requests[lenDiff:] binRecord.requests = requests } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMemoryStorage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(maxRequests </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MemoryStorage</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;MemoryStorage{ BaseStorage{ maxRequests: maxRequests, }, sync.RWMutex{}, <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*BinRecord{}, } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBinRecord</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*BinRecord, error)</span></span></span></span> { storage.RLock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> storage.RUnlock() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord, ok := storage.binRecords[name]; ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> binRecord, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"Bin not found"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookupBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Bin, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord, err := storage.getBinRecord(name); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> binRecord.bin, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookupBins</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(names []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Bin, error)</span></span></span></span> { bins := []*Bin{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, name := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> names { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord, err := storage.getBinRecord(name); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { bins = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(bins, binRecord.bin) } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bins, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bin *Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { storage.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> storage.Unlock() binRec := BinRecord{bin, []*Request{}, <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Request{}} storage.binRecords[bin.Name] = &amp;binRec <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_ *Bin)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookupRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(binName, id </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*Request, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord, err := storage.getBinRecord(binName); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request, ok := binRecord.requestMap[id]; ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"Request not found"</span></span>) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LookupRequests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(binName </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, from </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, to </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">([]*Request, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord, err := storage.getBinRecord(binName); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { requestLen := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(binRecord.requests) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> to &gt;= requestLen { to = requestLen } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> to &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { to = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> from &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> { from = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> from &gt; to { from = to } reversedLen := to - from reversed := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]*Request, reversedLen) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, request := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> binRecord.requests[from:to] { reversed[reversedLen-i<span class="hljs-number"><span class="hljs-number">-1</span></span>] = request } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reversed, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(storage *MemoryStorage)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bin *Bin, req *Request)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> binRecord, err := storage.getBinRecord(bin.Name); err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { storage.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> storage.Unlock() binRecord.requests = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(binRecord.requests, req) binRecord.requestMap[req.Id] = req binRecord.ShrinkRequests(storage.maxRequests) binRecord.bin.RequestCount = <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(binRecord.requests) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } }</code> </pre><br></div></div><br><br> ,     ,     api.     . <br><br>        . <br><br><pre> <code class="hljs go"> memoryStorage := NewMemoryStorage(MAX_REQUEST_COUNT) api.MapTo(memoryStorage, (*Storage)(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>))</code> </pre><br>          Storage      .    ,       Bin       Storage. <br><br><pre> <code class="hljs pgsql"> api.Post("/api/v1/bins/", func(r render.Render, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>){ bin := NewBin() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.CreateBin(bin); err == nil { history = append(history, bin.Name) r.JSON(http.StatusCreated, bin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusInternalServerError, ErrorMsg{err.Error()}) } }) api.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>("/api/v1/bins/", func(r render.Render, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bins, err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupBins(history); err == nil { r.JSON(http.StatusOK, bins) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusInternalServerError, ErrorMsg{err.Error()}) } }) api.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>("/api/v1/bins/:bin", func(r render.Render, params martini.Params, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin, err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupBin(params["bin"]); err == nil{ r.JSON(http.StatusOK, bin) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusNotFound, ErrorMsg{err.Error()}) } })</code> </pre><br>  ,      Request. <br><br><pre> <code class="hljs pgsql">//    api.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>("/api/v1/bins/:bin/requests/", func(r render.Render, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>, params martini.Params, req *http.Request){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin, error := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupBin(params["bin"]); error == nil { <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> := <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fromVal, err := strconv.Atoi(req.FormValue("from")); err == nil { <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = fromVal } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> toVal, err := strconv.Atoi(req.FormValue("to")); err == nil { <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> = toVal } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> requests, err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupRequests(bin.Name, <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>); err == nil { r.JSON(http.StatusOK, requests) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusInternalServerError, ErrorMsg{err.Error()}) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.Error(http.StatusNotFound) } }) //     Request api.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>("/api/v1/bins/:bin/requests/:request", func(r render.Render, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>, params martini.Params){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request, err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupRequest(params["bin"], params["request"]); err == nil { r.JSON(http.StatusOK, request) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusNotFound, ErrorMsg{err.Error()}) } }) //  http    Request  Bin(<span class="hljs-type"><span class="hljs-type">name</span></span>) api.<span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>("/bins/:name", func(r render.Render, <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span>, params martini.Params, req *http.Request){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bin, error := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.LookupBin(params["name"]); error == nil { request := NewRequest(req, REQUEST_BODY_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.CreateRequest(bin, request); err == nil { r.JSON(http.StatusOK, request) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.JSON(http.StatusInternalServerError, ErrorMsg{err.Error()}) } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.Error(http.StatusNotFound) } })</code> </pre><br>   ,        . <br><br>   Bin   HTTP  <br><br><pre> <code class="hljs pgsql">&gt; curl -i -X POST "127.0.0.1:3000/api/v1/bins/" HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">201</span></span> Created Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: application/<span class="hljs-type"><span class="hljs-type">json</span></span>; charset=UTF<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>: Mon, <span class="hljs-number"><span class="hljs-number">03</span></span> Mar <span class="hljs-number"><span class="hljs-number">2014</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">28</span></span> GMT Content-Length: <span class="hljs-number"><span class="hljs-number">76</span></span> {"name":"ws87ui","created":<span class="hljs-number"><span class="hljs-number">1393849168</span></span>,"updated":<span class="hljs-number"><span class="hljs-number">1393849168</span></span>,"requestCount":<span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre><br>      <br><pre> <code class="hljs erlang-repl">&gt; curl -X POST -d <span class="hljs-string"><span class="hljs-string">"fizz=buzz"</span></span> http://<span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0.1</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span>/bins/ws87ui {<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-string"><span class="hljs-string">"i0aigrrc1b40"</span></span>,<span class="hljs-string"><span class="hljs-string">"created"</span></span>:<span class="hljs-number"><span class="hljs-number">1393849284</span></span>,...}</code> </pre><br> ,    : <br><pre> <code class="hljs coffeescript">&gt; curl http:<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">127.0</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">3000</span></span>/api<span class="hljs-regexp"><span class="hljs-regexp">/v1/bins/ws87ui/requests/</span></span> [{<span class="hljs-string"><span class="hljs-string">"id"</span></span>:<span class="hljs-string"><span class="hljs-string">"i0aigrrc1b40"</span></span>,<span class="hljs-string"><span class="hljs-string">"created"</span></span>:<span class="hljs-number"><span class="hljs-number">1393849284</span></span>,...}]</code> </pre><br><br> ,    ,           . <br><br>    <a href="http://habrahabr.ru/post/214425/"> </a> ,      ,   -   AngularJS  Bootstrap,       Redis  . </div><p>Source: <a href="https://habr.com/ru/post/208680/">https://habr.com/ru/post/208680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208664/index.html">Rust 0.9 released</a></li>
<li><a href="../208666/index.html">Monte Carlo method in particle physics</a></li>
<li><a href="../208672/index.html">VKontakte service is not available (at all)</a></li>
<li><a href="../208676/index.html">IPOP - IP over P2P</a></li>
<li><a href="../208678/index.html">Convenient URL generation (CNC). Laravel 4 + third-party packages</a></li>
<li><a href="../208684/index.html">Converting a uniformly distributed random variable to a normally distributed one</a></li>
<li><a href="../208688/index.html">Large retail network Overstock began to accept Bitcoin</a></li>
<li><a href="../208690/index.html">CBOR - New Binary Data Format</a></li>
<li><a href="../208692/index.html">Making difficult conditions</a></li>
<li><a href="../208694/index.html">How to send a letter when you do not know gmail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>