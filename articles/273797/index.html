<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we made Rich Text Editor with support for co-editing under Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúMobilizing‚Äù workflows in companies means that more and more collaboration features are being transferred to the phone or tablet. For Wrike , as a cro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we made Rich Text Editor with support for co-editing under Android</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/1b5/1e4/1a2/1b51e41a2f33454db7826e482aec0988.png" width="327" height="500" hspace="1" vspace="1" alt="picture"></div><br>  ‚ÄúMobilizing‚Äù workflows in companies means that more and more collaboration features are being transferred to the phone or tablet.  For <a href="https://www.wrike.com/ru%3Futm_source%3Dhabrahabr%26utm_medium%3Dblogposts%26utm_campaign%3Drichtexteditor">Wrike</a> , as a cross-platform project management service, it is important that the functionality of the mobile application is completely complete, convenient and does not restrict users to work.  And when the task arose to create Rich Text Editor with the support of joint editing of the description of the tasks, we, assessing the capabilities of existing WebView components, decided to go our own way and implemented our own native tool. <br><br><a name="habracut"></a><br><br><br clear="all">  First, a little about the history of the product.  One of the basic functions of Wrike was initially mail integration.  From the very first version of the task it was possible to create and update via e-mail, and then work on them together with other employees.  The body of the letter turned into a description of the problem, and all further discussion went in the comments to it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since you can use HTML formatting in the mail, in earlier versions of the product we used CKEditor to further work with the description of the task.  But in a collaborative environment, this is very inconvenient - it is necessary to block all or part of the document so that the prepared description of the task does not get erased by someone else.  As a result, we decided to delve into the practice of Operation Transformation (OT) and make a tool for real collaboration.  In this article I will not consider in detail the theory and implementation of OT for rich text documents, there are already enough <a href="http://habrahabr.ru/company/ncloudtech/blog/264923/">materials</a> about this.  I will consider only the difficulties faced by our team when developing a mobile application. <br><br><h4>  <b>Joint editing on a smartphone - but why?</b> </h4><br>  Perhaps there is no need, unless, of course, this is a key function of your product.  In addition to the common goal to provide maximum basic functionality on all platforms, there were a number of more specific reasons why we had to think about it: <br><ol><li>  An OT implementation requires you to store the document in a specific format that supports co-editing.  In the case of plain text, there is no special format ‚Äî it may just be a string.  But in the case of Rich Text (formatted text), the storage format becomes more complicated. </li><li>  We need a way to save changes made by the mobile client without breaking the document and creating a conflict with the changes that other users could make at the same time.  These are tasks that are just solved by OT algorithms. </li><li>  Since we need to transfer the OT algorithm to the mobile platform in order to fulfill the conditions of clause 2, then full-fledged collaborative editing does not require much additional effort. </li></ol><br>  So, we have a rich text description of the problem as the basic functionality, the need to support a specific document format and synchronization protocol, so we will take up the search for a solution. <br><br><h4>  <b>Implementation options</b> </h4><br>  With the implementation of the component to work together, the experience was already there, but with how to transfer it to Android, you had to figure it out.  Much depended on the requirements for the editor and there were, by and large, two of them: <br><ol><li>  Support for basic formatting, lists, inserting pictures and tables, </li><li>  An API that allows you to make and track changes both in the text itself and in its formatting. </li></ol><br><br><h5>  <b>Method 1: Use an Existing Component from a Web Product</b> </h5><br>  Indeed, we could use a component that we already have and wrap it in a webview.  One of the advantages is simplicity of integration, since virtually all the code of the editor is in scripts, and the Android / iOS developer need only implement the WebView wrapper. <br><br>  It quickly became clear that the existing component from the main application, working with the ContentEditable document, is very unstable, depending on the version of the OS and the vendor.  Exotic bugs in some places went off scale, but mostly they surfaced around the functions of selecting and entering text, as well as the disappearing focus and keyboard. <br><br>  To get around the problems of ContentEditable, we tried to use <a href="http://codemirror.net/">CodeMirror</a> as a front-end for the editor, while it works much better and more stable on Android, since it processes all keyboard events and rendering itself.  There were, of course, disadvantages, but as a quick workaround, it worked very well until there was a well-known change in handling keystroke events in IME - this problem is discussed in some detail <a href="http://stackoverflow.com/questions/18581636/android-cannot-capture-backspace-delete-press-in-soft-keyboard/19980975">here</a> .  If in a nutshell - when using LatinIME, it does not send an event for KEYCODE_DEL. <br><br>  What does this mean for the user?  When you click on Delete, nothing happens, that is, the editor works correctly, you can enter text, apply formatting ... only the text cannot be deleted, no matter how absurd it sounds.  The only solution to this problem, among other things, included the following code: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> InputConnection </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreateInputConnection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EditorInfo outAttrs)</span></span></span><span class="hljs-function"> </span></span>{ BaseInputConnection baseInputConnection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BaseInputConnection(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendKeyEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(KeyEvent event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (needsKeyboardFix() &amp;&amp; event.getAction() == KeyEvent.ACTION_MULTIPLE &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_UNKNOWN) { passUnicodeCharToEditor(event); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.sendKeyEvent(event); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteSurroundingText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beforeLength, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> afterLength)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &amp;&amp; (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) &amp;&amp; (beforeLength == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; afterLength == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">// Send Backspace key down and up events return super.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL)) &amp;&amp; super.sendKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL)); } else { return super.deleteSurroundingText(beforeLength, afterLength); } } }; outAttrs.inputType = InputType.TYPE_NULL; return baseInputConnection; }</span></span></code> </pre> <br>  InputType.TYPE_NULL at the same time translated the IME into a ‚Äúsimplified‚Äù view, signaling that the InputConnection works in a limited mode, which means no copy / paste, autocorrect / autocomplete, or text input using gestures, but it also allows you to handle all keyboard events . <br><br>  As a result, in the latest implementation of the editor, which used the web interface, there were the following disadvantages: <br><ul><li>  slow download speed; </li><li>  lack of access to advanced features of IME (copy / paste, autocomplete / autocorrect, gesture input); </li><li>  in some cases, unstable work, due to the different implementation of WebView on different versions of the API and modifications of this component by some vendors; </li><li>  Usually, WebView does not last long in memory, especially on devices with a small amount of memory, and if the application is minimized and after some time restarted, in most cases WebView will have to be initialized again; </li><li>  numerous crutches in the code, the number of which only increased over time. </li></ul><br>  Realizing that supporting such an implementation of the editor is not easy, and given the described shortcomings and limitations, it was decided to develop a native component that would give the opportunity to work with formatted text. <br><br><h5>  <b>Method 2: native implementation</b> </h5><br>  For the native implementation it is necessary to solve two problems: <br><ol><li>  UI editor, that is, the display of text with regard to formatting and editing. </li><li>  Work with the document format, change tracking, and data exchange with the server. </li></ol><br>  In order to solve the first problem, you do not need to reinvent the wheel - Android provides the necessary tools, namely the EditText component and the Spannable interface, which describes the labeling of the text. <br><br>  The second problem is solved by transferring OT algorithms from JavaScript to Java, and the process here is quite transparent. <br><br><h4>  <b>Rich Text Display in EditText</b> </h4><br>  Android has a wonderful <a href="http://developer.android.com/reference/android/text/Spannable.html">Spannable</a> interface that allows you to set text markup.  The process of creating markup is quite simple - you need to use a special class SpannableStringBuilder, which allows you to set / change the text, and set styles for specified sections of text through the method <br><br><pre> <code class="java hljs">setSpan(Object what, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> end, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags).</code> </pre><br>  The first parameter just sets the style.  It must be an instance of a class that implements one or more interfaces from the android.text.style package: CharacterStyle, UpdateAppearance, UpdateLayout, ParagraphStyle, etc.  The set of default styles is quite wide - from changing the character format (StyleSpan, UnderlineSpan), setting the text size (RelativeSizeSpan) and changing its position (AlignmentSpan) to supporting images (ImageSpan) and clickable text (ClickableSpan). <br><br>  The last parameter sets the flags, the role of which will be described below.  For example, this is how you can change the color of the entire text: <br><br><pre> <code class="java hljs">SpannableStringBuilder ssb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpannableStringBuilder(text); ssb.setSpan(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ForegroundColorSpan(Color.BLUE), <span class="hljs-number"><span class="hljs-number">0</span></span>, text.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); textView.setText(ssb, TextView.BufferType.SPANNABLE);</code> </pre><br>  So, at the entrance there is text in a certain format, and at the exit you need to get its representation in the form of a Spannable object and pass it to EditText.  In our case, the document comes from the server in a special format in the form of an attributed string ‚Äî you need to parse this string using our OT library and apply attributes to the specified text areas.  Depending on the style, you need to set the correct flag so that the text marking meets the user's expectations. <br><br>  If you mark a style with the SPAN_EXCLUSIVE_INCLUSIVE flag, it will be applied to the text entered at the end of the interval, but will not be applied at the beginning.  For example, there is an interval [10, 20] for which the style UnderlineSpan + SPAN_EXCLUSIVE_INCLUSIVE is set.  In this case, when you enter text at position 9, the UnderlineSpan style will not be applied to it, but if you start entering text at position 20, the interval that covers the style will expand and become [10, 21].  Naturally, this is useful for inline formatting (bold / italic / underline, etc.). <br><br>  When using the SPAN_EXCLUSIVE_EXCLUSIVE flag, the style interval is limited at both ends.  This is suitable, for example, for links - if you start to insert text immediately after the link, the link style should not be applied to it. <br><br>  Using the SPAN_EXLUSIVE_INCLUSIVE and SPAN_EXCLUSIVE_EXCLUSIVE flags, you can control the formatting behavior when entering text depending on the user's expectations.  For example, if you have turned on the Bold formatting mode, then the entered text should remain bold.  And if you made a link, then appending text at the end should not extend the boundaries of the link. <br><br>  BulletSpan can be used to display the list items, but it is suitable only for unnumbered lists.  If numbering is necessary, then you can write your own class that implements the LeadingMarginSpan and UpdateAppearance interfaces, drawing the list indicator at your discretion in the drawLeadingMargin method. <br><br><h4>  <b>Custom Style Processing</b> </h4><br>  It is clear that the editor should give the user the ability to apply formatting, this includes: <br><ol><li>  Adding a new style to the selected text. </li><li>  Insert a new style at the cursor position, </li><li>  Apply current style when editing. </li></ol><br>  First of all, you need somewhere to place the buttons for styles supported by the editor.  Putting them in the Activity toolbar was not practical until the release of Android Marshmallow.  By default, the same toolbar is used for the context menu when text is selected, and thus it is impossible to select a style for the selected text.  Therefore, you can put them on the toolbar at the bottom of the screen.  When you click on the style button, you must decide on the current state of the editor and either apply the style to the selected text, or remember this style as temporary in the cursor position. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onApplyInlineAttributeToSelection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> selectionStart, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> selectionEnd, TextAttribute attribute)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selectionStart = mEditText.getSelectionStart(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> selectionEnd = mEditText.getSelectionEnd(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mEditText.hasSelection()) { <span class="hljs-comment"><span class="hljs-comment">// if there's no selection, insert/delete empty span for the appropriate attribute, // but only in case the cursor is present if (selectionStart == selectionEnd &amp;&amp; selectionStart != -1) { if (mTempAttributes == null || mTempAttributes.getPos() != selectionStart) { mTempAttributes = new TempAttributes(selectionStart); } Set&lt;Object&gt; attributeSpans = getAttributeSpans(selectionStart, selectionEnd, attribute); if (attributeSpans.size() &gt; 0) { attribute.nullify(); } mTempAttributes.addAttribute(attribute); } return; } if (attribute == null) { return; } boolean changed = applyInlineAttributeToSelection(selectionStart, selectionEnd, attribute); // if nothing changed, then there's no need to build any changesets and send updates to server if (!changed) { return; } // ... }</span></span></code> </pre><br>  mTempAttributes is an instance of the TempAttributes class.  It defines a set of attributes in a given position, selected by the user.  This variable is reset either after use or when the cursor position changes. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TempAttributes</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mPos; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;AttributeName, TextAttribute&gt; mAttributeMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TempAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pos)</span></span></span><span class="hljs-function"> </span></span>{ mPos = pos; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPos</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mPos; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Collection&lt;TextAttribute&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAttributes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mAttributeMap.values(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TextAttribute attribute)</span></span></span><span class="hljs-function"> </span></span>{ AttributeName name = attribute.getAttributeName(); TextAttribute oldAttribute = mAttributeMap.get(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldAttribute != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; !oldAttribute.isNull()) { attribute.nullify(); } mAttributeMap.put(name, attribute); } }</code> </pre><br>  If the user presses a button corresponding to a certain style on the toolbar, but no text is selected, in this case, you must save this style as ‚Äútemporary‚Äù at the current cursor position and apply it when entering text at this position.  More on this below. <br><br>  When the text has been selected, it is necessary to determine whether this style already exists in the selected interval or not.  If not or is partially, then it is necessary to combine all existing spans and cover the interval with this style completely.  If there is, then remove the corresponding span from the interval, breaking it if necessary. <br><br>  <b>Example 1</b> <br>  There is a text: <b>Quick</b> brown <b>fox</b> . <br>  It has 2 span-a: bold [0,4] and bold [12,14].  If the user selects all the text and applies the bold style to it, then in the end he should cover the entire interval.  To do this, you can either delete both spans and add a new bold [0, 14], or delete the second one and extend the first one to the end of the interval. <br><br>  <b>Example 2</b> <br>  There is a text: <b>Quick brown fox</b> . <br>  It has one span: bold [0, 14].  If the user selects the text [4, 12] and selects the bold style in the toolbar, then the style must be removed from the interval, since it is fully present in the selection.  To do this, split the interval into two parts: shorten the entire interval [0, 14] before the start of the selection ([0, 4]) and add a new interval from the end of the selection to the end of the text ([4, 12]). <br><br><h4>  <b>Tracking document changes</b> </h4><br>  In order to correctly track user changes and feed them to the OT algorithm, the editor must be able to track them.  The TextWatcher interface is used for this - every time some changes occur in the EditText, the beforeTextChanged, onTextChanged and afterTextChanged methods of this interface are sequentially called, allowing you to determine where has changed. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> mIgnoreNextTextChange = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mCurrentPos; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String mOldStr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> String mNewStr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... public void ignoreNextTextChange(boolean ignore) { mIgnoreNextTextChange = ignore; } public void beforeTextChanged(CharSequence s, int start, int count, int after){ if (mIgnoreNextTextChange) { return; } mOldStr = null; mCurrentPos = start; if (s.length() &gt; 0 &amp;&amp; count &gt; 0) { mOldStr = s.subSequence(start, start + count).toString(); } } public void onTextChanged(CharSequence s, int start, int before, int count) { if (mIgnoreNextTextChange) { return; } mNewStr = null; if (s.length() &gt; 0 &amp;&amp; count &gt; 0) { mNewStr = s.subSequence(start, start + count).toString(); } } public void afterTextChanged(Editable s) { // ... }</span></span></code> </pre><br>  It is important to note that during the initial installation of text into the editor via setText (CharSequence), TextWatcher will also receive a notification about this, so the programmatic installation of the text turns into: <br><br><pre> <code class="java hljs">mEditTextWatcher.ignoreNextTextChange(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); mEditText.setText(builder); mEditTextWatcher.ignoreNextTextChange(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>);</code> </pre><br>  The mOldStr and mNewStr variables store the old line and the new line, respectively, mCurrentPos indicates the position from which the changes occurred.  For example, if a user added the character ‚Äúa‚Äù at position 10, then <br><br><pre> <code class="java hljs">mOldStr = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; mNewStr = <span class="hljs-string"><span class="hljs-string">"a"</span></span>; mCurrentPos = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><br>  However, there is a small nuance - when inserting text due to autocorrection, these values ‚Äã‚Äãmay include the beginning of a word.  For example, if the text starts with the word ‚ÄúText‚Äù and the user replaces the third character with ‚Äús‚Äù, then the IME can report this change as: <br><br><pre> <code class="java hljs">mOldStr = <span class="hljs-string"><span class="hljs-string">"Tex"</span></span>; mNewStr = <span class="hljs-string"><span class="hljs-string">"Tes"</span></span>; mCurrentPos = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br>  In this case, you need to cut off the same sequence of characters from the beginning of the line. <br><br>  In the end, using TextWatcher, you can unambiguously determine what exactly happened - whether the text was replaced, deleted or added.  If the user adds text to the position or replaces part of the existing text with text from the buffer, you must apply those attributes that are at the cursor position to the added text.  To do this, find all Spannable objects at the cursor position, while not forgetting to exclude those that have become empty (s.getSpanStart (span) == s.getSpanEnd (span)), deleting Spannable objects themselves and filtering only by inline attributes (bold, italic, etc.).  Additionally, the attributes that correspond to the styles selected by the user on the toolbar (mTempAttributes) are added. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterTextChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Editable s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... Object[] spans = s.getSpans(mCurrentPos, mCurrentPos, Object.class); Map&lt;Object, TextAttribute&gt; spanAttrMap = new LinkedHashMap&lt;&gt;(); for (Object span : spans) { TextAttribute attr = AttributeManager.attributeForSpan(span); if (attr != null) { spanAttrMap.put(span, attr); } } if (!TextUtils.isEmpty(mOldStr)) { Iterator&lt;Map.Entry&lt;Object, TextAttribute&gt;&gt; iterator = spanAttrMap.entrySet().iterator(); while (iterator.hasNext()) { Map.Entry&lt;Object, TextAttribute&gt; entry = iterator.next(); Object span = entry.getKey(); TextAttribute attr = entry.getValue(); // ... if (s.getSpanStart(span) == s.getSpanEnd(span)) { s.removeSpan(span); iterator.remove(); } } } // ... Set&lt;TextAttribute&gt; attributes = new HashSet&lt;&gt;(); if (!TextUtils.isEmpty(mNewStr)) { // determine all inline attributes at current position for (Map.Entry&lt;Object, TextAttribute&gt; entry : spanAttrMap.entrySet()) { TextAttribute attr = entry.getValue(); if (AttributeManager.isInlineAttribute(attr)) { attributes.add(attr); } } } if (mCallbacks != null) { mCallbacks.onTextChanged(mCurrentPos, mOldStr, mNewStr, attributes); } }</span></span></code> </pre><br>  As a result, there is a position in which changes occurred, the old and new texts in this position are known, as well as inline attributes that need to be applied to the new text.  After that, you can add additional processing.  For example, if a user inserts a line break at the end of the last list item, you can insert a new list item at the current cursor position to continue the list.  In the end, a list of changes is compiled from these data and sent to the server. <br><br>  It is worth noting that when tracking changes in the editor, it is good practice to use wrappers for all default styles.  For example, instead of UnderlineSpan use the class CustomUnderlineSpan, which is inherited from UnderlineSpan, but at the same time no methods in it are redefined.  Such an approach will allow for the class to unambiguously separate ‚Äútheir‚Äù styles from those used by EditText.  For example, if AutoCorrect support is enabled, then when editing the word EditText adds the UnderlineSpan style to it, and the word is visually underlined at the time of editing. <br><br><h4>  <b>About compatibility with different API versions</b> </h4><br>  On versions of APIs prior to Android KitKat, there is a <a href="https://code.google.com/p/android/issues/detail%3Fid%3D38770">problem</a> with overlaying spannable text when editing.  It is solved by disabling TextView hardware acceleration (perhaps there are other ways to fix this ‚Äî suggestions in the comments are most welcome): <br><br><pre> <code class="java hljs">mEditText.setLayerType(View.LAYER_TYPE_SOFTWARE, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>);</code> </pre><br>  However, in this form, the TextView cannot be placed in the ScrollView, since the entire View will be rendered in memory (‚ÄúView too large to fit into drawing cache‚Äù), so you need to enable scrolling in the TextView itself. <br><br><pre> <code class="java hljs">mEditText.setVerticalScrollBarEnabled(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); mEditText.setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);</code> </pre><br><br><h4>  <b>Conclusion</b> </h4><br>  Having troubled with the implementation of the editor on a webview and realizing the deadlock of this approach, we were able to develop a native component that solves the difficult but quite interesting task of co-editing text.  This allowed us to improve the usability of the application and increase the productivity of our users.  The resulting result can be estimated by downloading our application <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.wrike">from Google Play</a> . <br><br><img src="https://habrastorage.org/files/9e8/7fc/fc7/9e87fcfc701c4873a018d83b12a5dae1.gif"></div><p>Source: <a href="https://habr.com/ru/post/273797/">https://habr.com/ru/post/273797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273783/index.html">Non-standard city for non-standard people: a guide to the architecture of Innopolis</a></li>
<li><a href="../273785/index.html">RHCSA certification: preparation and delivery experience</a></li>
<li><a href="../273791/index.html">Embedded Hyper-V Virtualization - First Step</a></li>
<li><a href="../273793/index.html">SID change during cloning and mass deployment</a></li>
<li><a href="../273795/index.html">Creating a website. Course young fighter</a></li>
<li><a href="../273799/index.html">New Year Promotion for HPE ProLiant Gen9 Servers</a></li>
<li><a href="../273801/index.html">A new version of LinqTestable has been released - libraries for testing requests to the database via ORM</a></li>
<li><a href="../273803/index.html">IBM FlashSystem 900 storage system overview</a></li>
<li><a href="../273805/index.html">Zabbix + SoapUI = monitoring web services</a></li>
<li><a href="../273807/index.html">Parse HTML in .NET and Survive: Analyzing and Comparing Libraries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>